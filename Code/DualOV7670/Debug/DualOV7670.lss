
DualOV7670.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001f6  00800100  000054bc  00005550  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000054bc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000aa0  008002f6  008002f6  00005746  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00005748  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00005e14  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001e0  00000000  00000000  00005ea0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005258  00000000  00000000  00006080  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000128f  00000000  00000000  0000b2d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001d96  00000000  00000000  0000c567  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000105c  00000000  00000000  0000e300  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000ae7  00000000  00000000  0000f35c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000662e  00000000  00000000  0000fe43  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000118  00000000  00000000  00016471  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 82 05 	jmp	0xb04	; 0xb04 <__vector_1>
       8:	0c 94 ad 05 	jmp	0xb5a	; 0xb5a <__vector_2>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 67 08 	jmp	0x10ce	; 0x10ce <__vector_16>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 fa 28 	jmp	0x51f4	; 0x51f4 <__vector_26>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d0 e1       	ldi	r29, 0x10	; 16
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	12 e0       	ldi	r17, 0x02	; 2
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	ec eb       	ldi	r30, 0xBC	; 188
      90:	f4 e5       	ldi	r31, 0x54	; 84
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	a6 3f       	cpi	r26, 0xF6	; 246
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	1d e0       	ldi	r17, 0x0D	; 13
      a0:	a6 ef       	ldi	r26, 0xF6	; 246
      a2:	b2 e0       	ldi	r27, 0x02	; 2
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	a6 39       	cpi	r26, 0x96	; 150
      aa:	b1 07       	cpc	r27, r17
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 8b 08 	call	0x1116	; 0x1116 <main>
      b2:	0c 94 5c 2a 	jmp	0x54b8	; 0x54b8 <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <WriteBMPHeader>:
										};



FRESULT WriteBMPHeader(FIL *File)
{
      ba:	0f 93       	push	r16
      bc:	1f 93       	push	r17
      be:	cf 93       	push	r28
      c0:	df 93       	push	r29
      c2:	00 d0       	rcall	.+0      	; 0xc4 <WriteBMPHeader+0xa>
      c4:	00 d0       	rcall	.+0      	; 0xc6 <WriteBMPHeader+0xc>
      c6:	cd b7       	in	r28, 0x3d	; 61
      c8:	de b7       	in	r29, 0x3e	; 62
      ca:	8c 01       	movw	r16, r24
	uint32_t p;
	FRESULT f; 
	
	f_lseek(File, 0);
      cc:	40 e0       	ldi	r20, 0x00	; 0
      ce:	50 e0       	ldi	r21, 0x00	; 0
      d0:	ba 01       	movw	r22, r20
      d2:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <f_lseek>
	f = f_write(File, BMPHeader, BMPHEADERSIZE, &p);
      d6:	c8 01       	movw	r24, r16
      d8:	60 e0       	ldi	r22, 0x00	; 0
      da:	71 e0       	ldi	r23, 0x01	; 1
      dc:	2e e0       	ldi	r18, 0x0E	; 14
      de:	30 e0       	ldi	r19, 0x00	; 0
      e0:	40 e0       	ldi	r20, 0x00	; 0
      e2:	50 e0       	ldi	r21, 0x00	; 0
      e4:	8e 01       	movw	r16, r28
      e6:	0f 5f       	subi	r16, 0xFF	; 255
      e8:	1f 4f       	sbci	r17, 0xFF	; 255
      ea:	0e 94 16 1c 	call	0x382c	; 0x382c <f_write>
	
	return f;
}
      ee:	0f 90       	pop	r0
      f0:	0f 90       	pop	r0
      f2:	0f 90       	pop	r0
      f4:	0f 90       	pop	r0
      f6:	df 91       	pop	r29
      f8:	cf 91       	pop	r28
      fa:	1f 91       	pop	r17
      fc:	0f 91       	pop	r16
      fe:	08 95       	ret

00000100 <WriteDIBHeader>:

FRESULT WriteDIBHeader(FIL *File)
{
     100:	0f 93       	push	r16
     102:	1f 93       	push	r17
     104:	cf 93       	push	r28
     106:	df 93       	push	r29
     108:	00 d0       	rcall	.+0      	; 0x10a <WriteDIBHeader+0xa>
     10a:	00 d0       	rcall	.+0      	; 0x10c <WriteDIBHeader+0xc>
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
     110:	8c 01       	movw	r16, r24
	uint32_t p;
	FRESULT f;
	
	f_lseek(File, BMPHEADERSIZE);//place just after the bitmap header
     112:	4e e0       	ldi	r20, 0x0E	; 14
     114:	50 e0       	ldi	r21, 0x00	; 0
     116:	60 e0       	ldi	r22, 0x00	; 0
     118:	70 e0       	ldi	r23, 0x00	; 0
     11a:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <f_lseek>
	f = f_write(File, DIBHead, DIBHEADERSIZE, &p);
     11e:	c8 01       	movw	r24, r16
     120:	6e e0       	ldi	r22, 0x0E	; 14
     122:	71 e0       	ldi	r23, 0x01	; 1
     124:	2c e7       	ldi	r18, 0x7C	; 124
     126:	30 e0       	ldi	r19, 0x00	; 0
     128:	40 e0       	ldi	r20, 0x00	; 0
     12a:	50 e0       	ldi	r21, 0x00	; 0
     12c:	8e 01       	movw	r16, r28
     12e:	0f 5f       	subi	r16, 0xFF	; 255
     130:	1f 4f       	sbci	r17, 0xFF	; 255
     132:	0e 94 16 1c 	call	0x382c	; 0x382c <f_write>
	return f;
}
     136:	0f 90       	pop	r0
     138:	0f 90       	pop	r0
     13a:	0f 90       	pop	r0
     13c:	0f 90       	pop	r0
     13e:	df 91       	pop	r29
     140:	cf 91       	pop	r28
     142:	1f 91       	pop	r17
     144:	0f 91       	pop	r16
     146:	08 95       	ret

00000148 <IO_Init>:
#include "Config.h"
#include <avr/io.h>
void IO_Init(void)
{
	//initialise timer 0 to interrupt every 10 ms
	TIMSK0 |= (1 << OCIE0A);
     148:	ee e6       	ldi	r30, 0x6E	; 110
     14a:	f0 e0       	ldi	r31, 0x00	; 0
     14c:	80 81       	ld	r24, Z
     14e:	82 60       	ori	r24, 0x02	; 2
     150:	80 83       	st	Z, r24
	TCCR0A |= (1 << WGM01);
     152:	84 b5       	in	r24, 0x24	; 36
     154:	82 60       	ori	r24, 0x02	; 2
     156:	84 bd       	out	0x24, r24	; 36
	OCR0A = 117; //10ms interrupt at 12MHz
     158:	85 e7       	ldi	r24, 0x75	; 117
     15a:	87 bd       	out	0x27, r24	; 39
	TCCR0B |= (1 << CS02) | (1 << CS00);
     15c:	85 b5       	in	r24, 0x25	; 37
     15e:	85 60       	ori	r24, 0x05	; 5
     160:	85 bd       	out	0x25, r24	; 37
	
	
	DDRA = 0x00;
     162:	11 b8       	out	0x01, r1	; 1
	//PORTB = 0xBF;
	DDRC = 0xFC;
     164:	8c ef       	ldi	r24, 0xFC	; 252
     166:	87 b9       	out	0x07, r24	; 7
	DDRD = 0xF2;
     168:	82 ef       	ldi	r24, 0xF2	; 242
     16a:	8a b9       	out	0x0a, r24	; 10
	
	
	
	//set int0 and int1 to trigger on falling edge
	EIMSK = (1 << INT0) | (1 << INT1);				//Enable INT0 and INT1
     16c:	83 e0       	ldi	r24, 0x03	; 3
     16e:	8d bb       	out	0x1d, r24	; 29
	EICRA = (1 << ISC01) | (1 << ISC11);			//Trigger INT0 and INT1 on the falling edge
     170:	8a e0       	ldi	r24, 0x0A	; 10
     172:	80 93 69 00 	sts	0x0069, r24
     176:	08 95       	ret

00000178 <power_off>:
}

static
void power_off (void)
{
	SPCR = 0;				/* Disable SPI function */
     178:	1c bc       	out	0x2c, r1	; 44
// 	DDRB  &= ~0b00110111;	/* Set SCK/MOSI/CS as hi-z, INS#/WP as pull-up */
// 	PORTB &= ~0b00000111;
// 	PORTB |=  0b00110000;


	PORTB = ~0b00010000;      // SS high
     17a:	8f ee       	ldi	r24, 0xEF	; 239
     17c:	85 b9       	out	0x05, r24	; 5
	DDRB =  ~(uint8_t)0b10110000;      // !SS,SCK and MOSI outputs
     17e:	8f e4       	ldi	r24, 0x4F	; 79
     180:	84 b9       	out	0x04, r24	; 4
// 	{	/* Remove this block if no socket power control */
// 		PORTE |= _BV(7);		/* Socket power off (PE7=high) */
// 		for (Timer1 = 20; Timer1; );	/* Wait for 20ms */
// 	}
}
     182:	08 95       	ret

00000184 <xchg_spi>:
static
BYTE xchg_spi (		/* Returns received data */
	BYTE dat		/* Data to be sent */
)
{
	SPDR = dat;
     184:	8e bd       	out	0x2e, r24	; 46
	loop_until_bit_is_set(SPSR, SPIF);
     186:	0d b4       	in	r0, 0x2d	; 45
     188:	07 fe       	sbrs	r0, 7
     18a:	fd cf       	rjmp	.-6      	; 0x186 <xchg_spi+0x2>
	return SPDR;
     18c:	8e b5       	in	r24, 0x2e	; 46
}
     18e:	08 95       	ret

00000190 <wait_ready>:
int wait_ready (void)	/* 1:OK, 0:Timeout */
{
	BYTE d;


	Timer2 = 50;	/* Wait for ready in timeout of 500ms */
     190:	82 e3       	ldi	r24, 0x32	; 50
     192:	80 93 f6 02 	sts	0x02F6, r24
	do
		d = xchg_spi(0xFF);
     196:	8f ef       	ldi	r24, 0xFF	; 255
     198:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	while (d != 0xFF && Timer2);
     19c:	8f 3f       	cpi	r24, 0xFF	; 255
     19e:	21 f0       	breq	.+8      	; 0x1a8 <wait_ready+0x18>
     1a0:	90 91 f6 02 	lds	r25, 0x02F6
     1a4:	99 23       	and	r25, r25
     1a6:	b9 f7       	brne	.-18     	; 0x196 <wait_ready+0x6>

	return (d == 0xFF) ? 1 : 0;
     1a8:	21 e0       	ldi	r18, 0x01	; 1
     1aa:	30 e0       	ldi	r19, 0x00	; 0
     1ac:	8f 3f       	cpi	r24, 0xFF	; 255
     1ae:	11 f0       	breq	.+4      	; 0x1b4 <wait_ready+0x24>
     1b0:	20 e0       	ldi	r18, 0x00	; 0
     1b2:	30 e0       	ldi	r19, 0x00	; 0
}
     1b4:	82 2f       	mov	r24, r18
     1b6:	93 2f       	mov	r25, r19
     1b8:	08 95       	ret

000001ba <deselect>:
/*-----------------------------------------------------------------------*/

static
void deselect (void)
{
	CS_HIGH();
     1ba:	2c 9a       	sbi	0x05, 4	; 5
	xchg_spi(0xFF);	/* Dummy clock (force DO hi-z for multiple slave SPI) */
     1bc:	8f ef       	ldi	r24, 0xFF	; 255
     1be:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
}
     1c2:	08 95       	ret

000001c4 <select>:
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:Successful, 0:Timeout */
{
	CS_LOW();
     1c4:	2c 98       	cbi	0x05, 4	; 5
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */
     1c6:	8f ef       	ldi	r24, 0xFF	; 255
     1c8:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>

	if (wait_ready()) return 1;	/* OK */
     1cc:	0e 94 c8 00 	call	0x190	; 0x190 <wait_ready>
     1d0:	00 97       	sbiw	r24, 0x00	; 0
     1d2:	29 f4       	brne	.+10     	; 0x1de <select+0x1a>
	deselect();
     1d4:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
	return 0;	/* Timeout */
     1d8:	80 e0       	ldi	r24, 0x00	; 0
     1da:	90 e0       	ldi	r25, 0x00	; 0
     1dc:	08 95       	ret
int select (void)	/* 1:Successful, 0:Timeout */
{
	CS_LOW();
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */

	if (wait_ready()) return 1;	/* OK */
     1de:	81 e0       	ldi	r24, 0x01	; 1
     1e0:	90 e0       	ldi	r25, 0x00	; 0
	deselect();
	return 0;	/* Timeout */
}
     1e2:	08 95       	ret

000001e4 <rcvr_datablock>:
static
int rcvr_datablock (
	BYTE *buff,			/* Data buffer to store received data */
	UINT btr			/* Byte count (must be multiple of 4) */
)
{
     1e4:	cf 92       	push	r12
     1e6:	df 92       	push	r13
     1e8:	ef 92       	push	r14
     1ea:	ff 92       	push	r15
     1ec:	cf 93       	push	r28
     1ee:	df 93       	push	r29
     1f0:	ec 01       	movw	r28, r24
     1f2:	6a 01       	movw	r12, r20
     1f4:	7b 01       	movw	r14, r22
	BYTE token;


	Timer1 = 20;
     1f6:	84 e1       	ldi	r24, 0x14	; 20
     1f8:	80 93 f7 02 	sts	0x02F7, r24
	do {							/* Wait for data packet in timeout of 200ms */
		token = xchg_spi(0xFF);
     1fc:	8f ef       	ldi	r24, 0xFF	; 255
     1fe:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	} while ((token == 0xFF) && Timer1);
     202:	8f 3f       	cpi	r24, 0xFF	; 255
     204:	39 f4       	brne	.+14     	; 0x214 <rcvr_datablock+0x30>
     206:	80 91 f7 02 	lds	r24, 0x02F7
     20a:	88 23       	and	r24, r24
     20c:	b9 f7       	brne	.-18     	; 0x1fc <rcvr_datablock+0x18>
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */
     20e:	80 e0       	ldi	r24, 0x00	; 0
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	28 c0       	rjmp	.+80     	; 0x264 <rcvr_datablock+0x80>
     214:	8e 3f       	cpi	r24, 0xFE	; 254
     216:	21 f5       	brne	.+72     	; 0x260 <rcvr_datablock+0x7c>
	BYTE *p,	/* Data buffer */
	UINT cnt	/* Size of data block */
)
{
	do {
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
     218:	8f ef       	ldi	r24, 0xFF	; 255
     21a:	8e bd       	out	0x2e, r24	; 46
     21c:	0d b4       	in	r0, 0x2d	; 45
     21e:	07 fe       	sbrs	r0, 7
     220:	fd cf       	rjmp	.-6      	; 0x21c <rcvr_datablock+0x38>
     222:	9e b5       	in	r25, 0x2e	; 46
     224:	98 83       	st	Y, r25
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
     226:	8e bd       	out	0x2e, r24	; 46
     228:	0d b4       	in	r0, 0x2d	; 45
     22a:	07 fe       	sbrs	r0, 7
     22c:	fd cf       	rjmp	.-6      	; 0x228 <rcvr_datablock+0x44>
     22e:	9e b5       	in	r25, 0x2e	; 46
     230:	99 83       	std	Y+1, r25	; 0x01
/*-----------------------------------------------------------------------*/
/* Receive a data packet from MMC                                        */
/*-----------------------------------------------------------------------*/

static
int rcvr_datablock (
     232:	22 96       	adiw	r28, 0x02	; 2
)
{
	do {
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
	} while (cnt -= 2);
     234:	2e ef       	ldi	r18, 0xFE	; 254
     236:	3f ef       	ldi	r19, 0xFF	; 255
     238:	4f ef       	ldi	r20, 0xFF	; 255
     23a:	5f ef       	ldi	r21, 0xFF	; 255
     23c:	c2 0e       	add	r12, r18
     23e:	d3 1e       	adc	r13, r19
     240:	e4 1e       	adc	r14, r20
     242:	f5 1e       	adc	r15, r21
     244:	c1 14       	cp	r12, r1
     246:	d1 04       	cpc	r13, r1
     248:	e1 04       	cpc	r14, r1
     24a:	f1 04       	cpc	r15, r1
     24c:	31 f7       	brne	.-52     	; 0x21a <rcvr_datablock+0x36>
		token = xchg_spi(0xFF);
	} while ((token == 0xFF) && Timer1);
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */

	rcvr_spi_multi(buff, btr);		/* Receive the data block into buffer */
	xchg_spi(0xFF);					/* Discard CRC */
     24e:	8f ef       	ldi	r24, 0xFF	; 255
     250:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi(0xFF);
     254:	8f ef       	ldi	r24, 0xFF	; 255
     256:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>

	return 1;						/* Return with success */
     25a:	81 e0       	ldi	r24, 0x01	; 1
     25c:	90 e0       	ldi	r25, 0x00	; 0
     25e:	02 c0       	rjmp	.+4      	; 0x264 <rcvr_datablock+0x80>

	Timer1 = 20;
	do {							/* Wait for data packet in timeout of 200ms */
		token = xchg_spi(0xFF);
	} while ((token == 0xFF) && Timer1);
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */
     260:	80 e0       	ldi	r24, 0x00	; 0
     262:	90 e0       	ldi	r25, 0x00	; 0
	rcvr_spi_multi(buff, btr);		/* Receive the data block into buffer */
	xchg_spi(0xFF);					/* Discard CRC */
	xchg_spi(0xFF);

	return 1;						/* Return with success */
}
     264:	df 91       	pop	r29
     266:	cf 91       	pop	r28
     268:	ff 90       	pop	r15
     26a:	ef 90       	pop	r14
     26c:	df 90       	pop	r13
     26e:	cf 90       	pop	r12
     270:	08 95       	ret

00000272 <xmit_datablock>:
static
int xmit_datablock (
	const BYTE *buff,	/* 512 byte data block to be transmitted */
	BYTE token			/* Data/Stop token */
)
{
     272:	1f 93       	push	r17
     274:	cf 93       	push	r28
     276:	df 93       	push	r29
     278:	ec 01       	movw	r28, r24
     27a:	16 2f       	mov	r17, r22
	BYTE resp;


	if (!wait_ready()) return 0;
     27c:	0e 94 c8 00 	call	0x190	; 0x190 <wait_ready>
     280:	00 97       	sbiw	r24, 0x00	; 0
     282:	41 f1       	breq	.+80     	; 0x2d4 <xmit_datablock+0x62>

	xchg_spi(token);					/* Xmit data token */
     284:	81 2f       	mov	r24, r17
     286:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	if (token != 0xFD) {	/* Is data token */
     28a:	1d 3f       	cpi	r17, 0xFD	; 253
     28c:	31 f1       	breq	.+76     	; 0x2da <xmit_datablock+0x68>
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     28e:	ce 01       	movw	r24, r28
     290:	80 50       	subi	r24, 0x00	; 0
     292:	9e 4f       	sbci	r25, 0xFE	; 254
	const BYTE *p,	/* Data block to be sent */
	UINT cnt		/* Size of data block */
)
{
	do {
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     294:	28 81       	ld	r18, Y
     296:	2e bd       	out	0x2e, r18	; 46
     298:	0d b4       	in	r0, 0x2d	; 45
     29a:	07 fe       	sbrs	r0, 7
     29c:	fd cf       	rjmp	.-6      	; 0x298 <xmit_datablock+0x26>
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     29e:	29 81       	ldd	r18, Y+1	; 0x01
     2a0:	2e bd       	out	0x2e, r18	; 46
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     2a2:	22 96       	adiw	r28, 0x02	; 2
	UINT cnt		/* Size of data block */
)
{
	do {
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     2a4:	0d b4       	in	r0, 0x2d	; 45
     2a6:	07 fe       	sbrs	r0, 7
     2a8:	fd cf       	rjmp	.-6      	; 0x2a4 <xmit_datablock+0x32>
	} while (cnt -= 2);
     2aa:	8c 17       	cp	r24, r28
     2ac:	9d 07       	cpc	r25, r29
     2ae:	91 f7       	brne	.-28     	; 0x294 <xmit_datablock+0x22>
	if (!wait_ready()) return 0;

	xchg_spi(token);					/* Xmit data token */
	if (token != 0xFD) {	/* Is data token */
		xmit_spi_multi(buff, 512);		/* Xmit the data block to the MMC */
		xchg_spi(0xFF);					/* CRC (Dummy) */
     2b0:	8f ef       	ldi	r24, 0xFF	; 255
     2b2:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
		xchg_spi(0xFF);
     2b6:	8f ef       	ldi	r24, 0xFF	; 255
     2b8:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
		resp = xchg_spi(0xFF);			/* Reveive data response */
     2bc:	8f ef       	ldi	r24, 0xFF	; 255
     2be:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
     2c2:	8f 71       	andi	r24, 0x1F	; 31
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     2c4:	21 e0       	ldi	r18, 0x01	; 1
     2c6:	30 e0       	ldi	r19, 0x00	; 0
     2c8:	85 30       	cpi	r24, 0x05	; 5
     2ca:	11 f0       	breq	.+4      	; 0x2d0 <xmit_datablock+0x5e>
     2cc:	20 e0       	ldi	r18, 0x00	; 0
     2ce:	30 e0       	ldi	r19, 0x00	; 0
)
{
	BYTE resp;


	if (!wait_ready()) return 0;
     2d0:	c9 01       	movw	r24, r18
     2d2:	05 c0       	rjmp	.+10     	; 0x2de <xmit_datablock+0x6c>
     2d4:	80 e0       	ldi	r24, 0x00	; 0
     2d6:	90 e0       	ldi	r25, 0x00	; 0
     2d8:	02 c0       	rjmp	.+4      	; 0x2de <xmit_datablock+0x6c>
		resp = xchg_spi(0xFF);			/* Reveive data response */
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
			return 0;
	}

	return 1;
     2da:	81 e0       	ldi	r24, 0x01	; 1
     2dc:	90 e0       	ldi	r25, 0x00	; 0
}
     2de:	df 91       	pop	r29
     2e0:	cf 91       	pop	r28
     2e2:	1f 91       	pop	r17
     2e4:	08 95       	ret

000002e6 <send_cmd>:
static
BYTE send_cmd (		/* Returns R1 resp (bit7==1:Send failed) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
     2e6:	ff 92       	push	r15
     2e8:	0f 93       	push	r16
     2ea:	1f 93       	push	r17
     2ec:	cf 93       	push	r28
     2ee:	df 93       	push	r29
     2f0:	c8 2f       	mov	r28, r24
     2f2:	d4 2f       	mov	r29, r20
     2f4:	15 2f       	mov	r17, r21
     2f6:	06 2f       	mov	r16, r22
     2f8:	f7 2e       	mov	r15, r23
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
     2fa:	88 23       	and	r24, r24
     2fc:	4c f4       	brge	.+18     	; 0x310 <send_cmd+0x2a>
		cmd &= 0x7F;
		res = send_cmd(CMD55, 0);
     2fe:	87 e3       	ldi	r24, 0x37	; 55
     300:	40 e0       	ldi	r20, 0x00	; 0
     302:	50 e0       	ldi	r21, 0x00	; 0
     304:	ba 01       	movw	r22, r20
     306:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
		if (res > 1) return res;
     30a:	82 30       	cpi	r24, 0x02	; 2
     30c:	68 f5       	brcc	.+90     	; 0x368 <send_cmd+0x82>
{
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
     30e:	cf 77       	andi	r28, 0x7F	; 127
		res = send_cmd(CMD55, 0);
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	deselect();
     310:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
	if (!select()) return 0xFF;
     314:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <select>
     318:	00 97       	sbiw	r24, 0x00	; 0
     31a:	29 f1       	breq	.+74     	; 0x366 <send_cmd+0x80>

	/* Send command packet */
	xchg_spi(0x40 | cmd);				/* Start + Command index */
     31c:	8c 2f       	mov	r24, r28
     31e:	80 64       	ori	r24, 0x40	; 64
     320:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
     324:	8f 2d       	mov	r24, r15
     326:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
     32a:	80 2f       	mov	r24, r16
     32c:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
     330:	81 2f       	mov	r24, r17
     332:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
     336:	8d 2f       	mov	r24, r29
     338:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) + Stop */
     33c:	cc 23       	and	r28, r28
     33e:	f1 f0       	breq	.+60     	; 0x37c <send_cmd+0x96>
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) Stop */
     340:	c8 30       	cpi	r28, 0x08	; 8
     342:	c1 f0       	breq	.+48     	; 0x374 <send_cmd+0x8e>
	xchg_spi(n);
     344:	81 e0       	ldi	r24, 0x01	; 1
     346:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>

	/* Receive command response */
	if (cmd == CMD12) xchg_spi(0xFF);		/* Skip a stuff byte when stop reading */
     34a:	cc 30       	cpi	r28, 0x0C	; 12
     34c:	19 f4       	brne	.+6      	; 0x354 <send_cmd+0x6e>
     34e:	8f ef       	ldi	r24, 0xFF	; 255
     350:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
static
BYTE send_cmd (		/* Returns R1 resp (bit7==1:Send failed) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
     354:	ca e0       	ldi	r28, 0x0A	; 10

	/* Receive command response */
	if (cmd == CMD12) xchg_spi(0xFF);		/* Skip a stuff byte when stop reading */
	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do
		res = xchg_spi(0xFF);
     356:	8f ef       	ldi	r24, 0xFF	; 255
     358:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	while ((res & 0x80) && --n);
     35c:	88 23       	and	r24, r24
     35e:	24 f4       	brge	.+8      	; 0x368 <send_cmd+0x82>
     360:	c1 50       	subi	r28, 0x01	; 1
     362:	c9 f7       	brne	.-14     	; 0x356 <send_cmd+0x70>
     364:	01 c0       	rjmp	.+2      	; 0x368 <send_cmd+0x82>
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	deselect();
	if (!select()) return 0xFF;
     366:	8f ef       	ldi	r24, 0xFF	; 255
	do
		res = xchg_spi(0xFF);
	while ((res & 0x80) && --n);

	return res;			/* Return with the response value */
}
     368:	df 91       	pop	r29
     36a:	cf 91       	pop	r28
     36c:	1f 91       	pop	r17
     36e:	0f 91       	pop	r16
     370:	ff 90       	pop	r15
     372:	08 95       	ret
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) + Stop */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) Stop */
	xchg_spi(n);
     374:	87 e8       	ldi	r24, 0x87	; 135
     376:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     37a:	ec cf       	rjmp	.-40     	; 0x354 <send_cmd+0x6e>
     37c:	85 e9       	ldi	r24, 0x95	; 149
     37e:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     382:	e8 cf       	rjmp	.-48     	; 0x354 <send_cmd+0x6e>

00000384 <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
     384:	cf 92       	push	r12
     386:	df 92       	push	r13
     388:	ef 92       	push	r14
     38a:	ff 92       	push	r15
     38c:	0f 93       	push	r16
     38e:	1f 93       	push	r17
     390:	cf 93       	push	r28
     392:	df 93       	push	r29
     394:	00 d0       	rcall	.+0      	; 0x396 <disk_initialize+0x12>
     396:	00 d0       	rcall	.+0      	; 0x398 <disk_initialize+0x14>
     398:	cd b7       	in	r28, 0x3d	; 61
     39a:	de b7       	in	r29, 0x3e	; 62
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only single drive */
     39c:	88 23       	and	r24, r24
     39e:	09 f0       	breq	.+2      	; 0x3a2 <disk_initialize+0x1e>
     3a0:	a8 c0       	rjmp	.+336    	; 0x4f2 <disk_initialize+0x16e>
	power_off();						/* Turn off the socket power to reset the card */
     3a2:	0e 94 bc 00 	call	0x178	; 0x178 <power_off>
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
     3a6:	80 91 8a 01 	lds	r24, 0x018A
     3aa:	81 ff       	sbrs	r24, 1
     3ac:	03 c0       	rjmp	.+6      	; 0x3b4 <disk_initialize+0x30>
     3ae:	80 91 8a 01 	lds	r24, 0x018A
     3b2:	a0 c0       	rjmp	.+320    	; 0x4f4 <disk_initialize+0x170>
	// Configure for: PB4 - /SS
	//                PB5 - MOSI
	//                PB6 - MISO
	//                PB7 - SCK

	PORTB = 0b00010000;      // SS high
     3b4:	80 e1       	ldi	r24, 0x10	; 16
     3b6:	85 b9       	out	0x05, r24	; 5
	DDRB =  0b10110000;      // !SS,SCK and MOSI outputs
     3b8:	80 eb       	ldi	r24, 0xB0	; 176
     3ba:	84 b9       	out	0x04, r24	; 4

	/* Set MOSI and SCK output, all others input */
	//DDR_SPI = (1<<DD_MOSI)|(1<<DD_SCK);
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
     3bc:	81 e5       	ldi	r24, 0x51	; 81
     3be:	8c bd       	out	0x2c, r24	; 44

	if (drv) return STA_NOINIT;			/* Supports only single drive */
	power_off();						/* Turn off the socket power to reset the card */
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
	power_on();							/* Turn on the socket power */
	FCLK_SLOW();
     3c0:	82 e5       	ldi	r24, 0x52	; 82
     3c2:	8c bd       	out	0x2c, r24	; 44
     3c4:	0a e0       	ldi	r16, 0x0A	; 10
	for (n = 10; n; n--) xchg_spi(0xFF);	/* 80 dummy clocks */
     3c6:	8f ef       	ldi	r24, 0xFF	; 255
     3c8:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     3cc:	01 50       	subi	r16, 0x01	; 1
     3ce:	d9 f7       	brne	.-10     	; 0x3c6 <disk_initialize+0x42>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
     3d0:	80 e0       	ldi	r24, 0x00	; 0
     3d2:	40 e0       	ldi	r20, 0x00	; 0
     3d4:	50 e0       	ldi	r21, 0x00	; 0
     3d6:	ba 01       	movw	r22, r20
     3d8:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     3dc:	81 30       	cpi	r24, 0x01	; 1
     3de:	09 f0       	breq	.+2      	; 0x3e2 <disk_initialize+0x5e>
     3e0:	9c c0       	rjmp	.+312    	; 0x51a <disk_initialize+0x196>
		Timer1 = 100;						/* Initialization timeout of 1000 msec */
     3e2:	84 e6       	ldi	r24, 0x64	; 100
     3e4:	80 93 f7 02 	sts	0x02F7, r24
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
     3e8:	88 e0       	ldi	r24, 0x08	; 8
     3ea:	4a ea       	ldi	r20, 0xAA	; 170
     3ec:	51 e0       	ldi	r21, 0x01	; 1
     3ee:	60 e0       	ldi	r22, 0x00	; 0
     3f0:	70 e0       	ldi	r23, 0x00	; 0
     3f2:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     3f6:	81 30       	cpi	r24, 0x01	; 1
     3f8:	09 f0       	breq	.+2      	; 0x3fc <disk_initialize+0x78>
     3fa:	42 c0       	rjmp	.+132    	; 0x480 <disk_initialize+0xfc>
     3fc:	6e 01       	movw	r12, r28
     3fe:	08 94       	sec
     400:	c1 1c       	adc	r12, r1
     402:	d1 1c       	adc	r13, r1

/*-----------------------------------------------------------------------*/
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
     404:	8e 01       	movw	r16, r28
     406:	0b 5f       	subi	r16, 0xFB	; 251
     408:	1f 4f       	sbci	r17, 0xFF	; 255
     40a:	76 01       	movw	r14, r12

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		Timer1 = 100;						/* Initialization timeout of 1000 msec */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);		/* Get trailing return value of R7 resp */
     40c:	8f ef       	ldi	r24, 0xFF	; 255
     40e:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     412:	f7 01       	movw	r30, r14
     414:	81 93       	st	Z+, r24
     416:	7f 01       	movw	r14, r30
     418:	e0 17       	cp	r30, r16
     41a:	f1 07       	cpc	r31, r17
     41c:	b9 f7       	brne	.-18     	; 0x40c <disk_initialize+0x88>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	81 30       	cpi	r24, 0x01	; 1
     422:	09 f0       	breq	.+2      	; 0x426 <disk_initialize+0xa2>
     424:	7a c0       	rjmp	.+244    	; 0x51a <disk_initialize+0x196>
     426:	8c 81       	ldd	r24, Y+4	; 0x04
     428:	8a 3a       	cpi	r24, 0xAA	; 170
     42a:	09 f0       	breq	.+2      	; 0x42e <disk_initialize+0xaa>
     42c:	76 c0       	rjmp	.+236    	; 0x51a <disk_initialize+0x196>
				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
     42e:	80 91 f7 02 	lds	r24, 0x02F7
     432:	88 23       	and	r24, r24
     434:	49 f0       	breq	.+18     	; 0x448 <disk_initialize+0xc4>
     436:	89 ea       	ldi	r24, 0xA9	; 169
     438:	40 e0       	ldi	r20, 0x00	; 0
     43a:	50 e0       	ldi	r21, 0x00	; 0
     43c:	60 e0       	ldi	r22, 0x00	; 0
     43e:	70 e4       	ldi	r23, 0x40	; 64
     440:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     444:	88 23       	and	r24, r24
     446:	99 f7       	brne	.-26     	; 0x42e <disk_initialize+0xaa>
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
     448:	80 91 f7 02 	lds	r24, 0x02F7
     44c:	88 23       	and	r24, r24
     44e:	09 f4       	brne	.+2      	; 0x452 <disk_initialize+0xce>
     450:	64 c0       	rjmp	.+200    	; 0x51a <disk_initialize+0x196>
     452:	8a e3       	ldi	r24, 0x3A	; 58
     454:	40 e0       	ldi	r20, 0x00	; 0
     456:	50 e0       	ldi	r21, 0x00	; 0
     458:	ba 01       	movw	r22, r20
     45a:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     45e:	88 23       	and	r24, r24
     460:	09 f0       	breq	.+2      	; 0x464 <disk_initialize+0xe0>
     462:	5b c0       	rjmp	.+182    	; 0x51a <disk_initialize+0x196>
     464:	04 e0       	ldi	r16, 0x04	; 4
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
     466:	8f ef       	ldi	r24, 0xFF	; 255
     468:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     46c:	f6 01       	movw	r30, r12
     46e:	81 93       	st	Z+, r24
     470:	6f 01       	movw	r12, r30
     472:	01 50       	subi	r16, 0x01	; 1
     474:	c1 f7       	brne	.-16     	; 0x466 <disk_initialize+0xe2>
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
     476:	89 81       	ldd	r24, Y+1	; 0x01
     478:	86 fd       	sbrc	r24, 6
     47a:	49 c0       	rjmp	.+146    	; 0x50e <disk_initialize+0x18a>
     47c:	84 e0       	ldi	r24, 0x04	; 4
     47e:	48 c0       	rjmp	.+144    	; 0x510 <disk_initialize+0x18c>
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
     480:	89 ea       	ldi	r24, 0xA9	; 169
     482:	40 e0       	ldi	r20, 0x00	; 0
     484:	50 e0       	ldi	r21, 0x00	; 0
     486:	ba 01       	movw	r22, r20
     488:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     48c:	82 30       	cpi	r24, 0x02	; 2
     48e:	18 f4       	brcc	.+6      	; 0x496 <disk_initialize+0x112>
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
     490:	12 e0       	ldi	r17, 0x02	; 2
     492:	09 ea       	ldi	r16, 0xA9	; 169
     494:	02 c0       	rjmp	.+4      	; 0x49a <disk_initialize+0x116>
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
     496:	11 e0       	ldi	r17, 0x01	; 1
     498:	01 e0       	ldi	r16, 0x01	; 1
			}
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
     49a:	80 91 f7 02 	lds	r24, 0x02F7
     49e:	88 23       	and	r24, r24
     4a0:	41 f0       	breq	.+16     	; 0x4b2 <disk_initialize+0x12e>
     4a2:	80 2f       	mov	r24, r16
     4a4:	40 e0       	ldi	r20, 0x00	; 0
     4a6:	50 e0       	ldi	r21, 0x00	; 0
     4a8:	ba 01       	movw	r22, r20
     4aa:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     4ae:	88 23       	and	r24, r24
     4b0:	a1 f7       	brne	.-24     	; 0x49a <disk_initialize+0x116>
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
     4b2:	80 91 f7 02 	lds	r24, 0x02F7
     4b6:	88 23       	and	r24, r24
     4b8:	81 f1       	breq	.+96     	; 0x51a <disk_initialize+0x196>
     4ba:	80 e1       	ldi	r24, 0x10	; 16
     4bc:	40 e0       	ldi	r20, 0x00	; 0
     4be:	52 e0       	ldi	r21, 0x02	; 2
     4c0:	60 e0       	ldi	r22, 0x00	; 0
     4c2:	70 e0       	ldi	r23, 0x00	; 0
     4c4:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     4c8:	88 23       	and	r24, r24
     4ca:	39 f5       	brne	.+78     	; 0x51a <disk_initialize+0x196>
				ty = 0;
		}
	}
	CardType = ty;
     4cc:	10 93 f8 02 	sts	0x02F8, r17
	deselect();
     4d0:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>

	if (ty) {			/* Initialization succeded */
     4d4:	11 23       	and	r17, r17
     4d6:	41 f0       	breq	.+16     	; 0x4e8 <disk_initialize+0x164>
		Stat &= ~STA_NOINIT;		/* Clear STA_NOINIT */
     4d8:	80 91 8a 01 	lds	r24, 0x018A
     4dc:	8e 7f       	andi	r24, 0xFE	; 254
     4de:	80 93 8a 01 	sts	0x018A, r24
		FCLK_FAST();
     4e2:	80 e5       	ldi	r24, 0x50	; 80
     4e4:	8c bd       	out	0x2c, r24	; 44
     4e6:	02 c0       	rjmp	.+4      	; 0x4ec <disk_initialize+0x168>
	} else {			/* Initialization failed */
		power_off();
     4e8:	0e 94 bc 00 	call	0x178	; 0x178 <power_off>
	}

	return Stat;
     4ec:	80 91 8a 01 	lds	r24, 0x018A
     4f0:	01 c0       	rjmp	.+2      	; 0x4f4 <disk_initialize+0x170>
)
{
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only single drive */
     4f2:	81 e0       	ldi	r24, 0x01	; 1
	} else {			/* Initialization failed */
		power_off();
	}

	return Stat;
}
     4f4:	0f 90       	pop	r0
     4f6:	0f 90       	pop	r0
     4f8:	0f 90       	pop	r0
     4fa:	0f 90       	pop	r0
     4fc:	df 91       	pop	r29
     4fe:	cf 91       	pop	r28
     500:	1f 91       	pop	r17
     502:	0f 91       	pop	r16
     504:	ff 90       	pop	r15
     506:	ef 90       	pop	r14
     508:	df 90       	pop	r13
     50a:	cf 90       	pop	r12
     50c:	08 95       	ret
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);		/* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
     50e:	8c e0       	ldi	r24, 0x0C	; 12
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
     510:	80 93 f8 02 	sts	0x02F8, r24
	deselect();
     514:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
     518:	df cf       	rjmp	.-66     	; 0x4d8 <disk_initialize+0x154>
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
     51a:	10 92 f8 02 	sts	0x02F8, r1
	deselect();
     51e:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
     522:	e2 cf       	rjmp	.-60     	; 0x4e8 <disk_initialize+0x164>

00000524 <disk_status>:

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
     524:	88 23       	and	r24, r24
     526:	19 f4       	brne	.+6      	; 0x52e <disk_status+0xa>
	return Stat;
     528:	80 91 8a 01 	lds	r24, 0x018A
     52c:	08 95       	ret

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
     52e:	81 e0       	ldi	r24, 0x01	; 1
	return Stat;
}
     530:	08 95       	ret

00000532 <disk_read>:
	BYTE drv,			/* Physical drive nmuber (0) */
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
     532:	0f 93       	push	r16
     534:	cf 93       	push	r28
     536:	df 93       	push	r29
     538:	eb 01       	movw	r28, r22
	if (drv || !count) return RES_PARERR;
     53a:	88 23       	and	r24, r24
     53c:	09 f0       	breq	.+2      	; 0x540 <disk_read+0xe>
     53e:	4a c0       	rjmp	.+148    	; 0x5d4 <disk_read+0xa2>
     540:	00 23       	and	r16, r16
     542:	09 f4       	brne	.+2      	; 0x546 <disk_read+0x14>
     544:	49 c0       	rjmp	.+146    	; 0x5d8 <disk_read+0xa6>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     546:	80 91 8a 01 	lds	r24, 0x018A
     54a:	80 fd       	sbrc	r24, 0
     54c:	47 c0       	rjmp	.+142    	; 0x5dc <disk_read+0xaa>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
     54e:	80 91 f8 02 	lds	r24, 0x02F8
     552:	83 fd       	sbrc	r24, 3
     554:	09 c0       	rjmp	.+18     	; 0x568 <disk_read+0x36>
     556:	01 2e       	mov	r0, r17
     558:	19 e0       	ldi	r17, 0x09	; 9
     55a:	22 0f       	add	r18, r18
     55c:	33 1f       	adc	r19, r19
     55e:	44 1f       	adc	r20, r20
     560:	55 1f       	adc	r21, r21
     562:	1a 95       	dec	r17
     564:	d1 f7       	brne	.-12     	; 0x55a <disk_read+0x28>
     566:	10 2d       	mov	r17, r0

	if (count == 1) {	/* Single block read */
     568:	01 30       	cpi	r16, 0x01	; 1
     56a:	89 f4       	brne	.+34     	; 0x58e <disk_read+0x5c>
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
     56c:	81 e1       	ldi	r24, 0x11	; 17
     56e:	ba 01       	movw	r22, r20
     570:	a9 01       	movw	r20, r18
     572:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     576:	88 23       	and	r24, r24
     578:	31 f5       	brne	.+76     	; 0x5c6 <disk_read+0x94>
			&& rcvr_datablock(buff, 512))
     57a:	ce 01       	movw	r24, r28
     57c:	40 e0       	ldi	r20, 0x00	; 0
     57e:	52 e0       	ldi	r21, 0x02	; 2
     580:	60 e0       	ldi	r22, 0x00	; 0
     582:	70 e0       	ldi	r23, 0x00	; 0
     584:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     588:	00 97       	sbiw	r24, 0x00	; 0
     58a:	e1 f4       	brne	.+56     	; 0x5c4 <disk_read+0x92>
     58c:	1c c0       	rjmp	.+56     	; 0x5c6 <disk_read+0x94>
			count = 0;
	}
	else {				/* Multiple block read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
     58e:	82 e1       	ldi	r24, 0x12	; 18
     590:	ba 01       	movw	r22, r20
     592:	a9 01       	movw	r20, r18
     594:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     598:	88 23       	and	r24, r24
     59a:	a9 f4       	brne	.+42     	; 0x5c6 <disk_read+0x94>
			do {
				if (!rcvr_datablock(buff, 512)) break;
     59c:	ce 01       	movw	r24, r28
     59e:	40 e0       	ldi	r20, 0x00	; 0
     5a0:	52 e0       	ldi	r21, 0x02	; 2
     5a2:	60 e0       	ldi	r22, 0x00	; 0
     5a4:	70 e0       	ldi	r23, 0x00	; 0
     5a6:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     5aa:	00 97       	sbiw	r24, 0x00	; 0
     5ac:	21 f0       	breq	.+8      	; 0x5b6 <disk_read+0x84>
				buff += 512;
     5ae:	c0 50       	subi	r28, 0x00	; 0
     5b0:	de 4f       	sbci	r29, 0xFE	; 254
			} while (--count);
     5b2:	01 50       	subi	r16, 0x01	; 1
     5b4:	99 f7       	brne	.-26     	; 0x59c <disk_read+0x6a>
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
     5b6:	8c e0       	ldi	r24, 0x0C	; 12
     5b8:	40 e0       	ldi	r20, 0x00	; 0
     5ba:	50 e0       	ldi	r21, 0x00	; 0
     5bc:	ba 01       	movw	r22, r20
     5be:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     5c2:	01 c0       	rjmp	.+2      	; 0x5c6 <disk_read+0x94>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */

	if (count == 1) {	/* Single block read */
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
			&& rcvr_datablock(buff, 512))
			count = 0;
     5c4:	00 e0       	ldi	r16, 0x00	; 0
				buff += 512;
			} while (--count);
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
		}
	}
	deselect();
     5c6:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>

	return count ? RES_ERROR : RES_OK;
     5ca:	81 e0       	ldi	r24, 0x01	; 1
     5cc:	00 23       	and	r16, r16
     5ce:	39 f4       	brne	.+14     	; 0x5de <disk_read+0xac>
     5d0:	80 e0       	ldi	r24, 0x00	; 0
     5d2:	05 c0       	rjmp	.+10     	; 0x5de <disk_read+0xac>
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
	if (drv || !count) return RES_PARERR;
     5d4:	84 e0       	ldi	r24, 0x04	; 4
     5d6:	03 c0       	rjmp	.+6      	; 0x5de <disk_read+0xac>
     5d8:	84 e0       	ldi	r24, 0x04	; 4
     5da:	01 c0       	rjmp	.+2      	; 0x5de <disk_read+0xac>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     5dc:	83 e0       	ldi	r24, 0x03	; 3
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
     5de:	df 91       	pop	r29
     5e0:	cf 91       	pop	r28
     5e2:	0f 91       	pop	r16
     5e4:	08 95       	ret

000005e6 <disk_write>:
	BYTE drv,			/* Physical drive nmuber (0) */
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
     5e6:	cf 92       	push	r12
     5e8:	df 92       	push	r13
     5ea:	ef 92       	push	r14
     5ec:	ff 92       	push	r15
     5ee:	0f 93       	push	r16
     5f0:	cf 93       	push	r28
     5f2:	df 93       	push	r29
     5f4:	eb 01       	movw	r28, r22
     5f6:	69 01       	movw	r12, r18
     5f8:	7a 01       	movw	r14, r20
	if (drv || !count) return RES_PARERR;
     5fa:	88 23       	and	r24, r24
     5fc:	09 f0       	breq	.+2      	; 0x600 <disk_write+0x1a>
     5fe:	57 c0       	rjmp	.+174    	; 0x6ae <disk_write+0xc8>
     600:	00 23       	and	r16, r16
     602:	09 f4       	brne	.+2      	; 0x606 <disk_write+0x20>
     604:	56 c0       	rjmp	.+172    	; 0x6b2 <disk_write+0xcc>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     606:	80 91 8a 01 	lds	r24, 0x018A
     60a:	80 fd       	sbrc	r24, 0
     60c:	54 c0       	rjmp	.+168    	; 0x6b6 <disk_write+0xd0>
	if (Stat & STA_PROTECT) return RES_WRPRT;
     60e:	80 91 8a 01 	lds	r24, 0x018A
     612:	82 fd       	sbrc	r24, 2
     614:	52 c0       	rjmp	.+164    	; 0x6ba <disk_write+0xd4>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
     616:	80 91 f8 02 	lds	r24, 0x02F8
     61a:	90 e0       	ldi	r25, 0x00	; 0
     61c:	83 fd       	sbrc	r24, 3
     61e:	09 c0       	rjmp	.+18     	; 0x632 <disk_write+0x4c>
     620:	0b 2e       	mov	r0, r27
     622:	b9 e0       	ldi	r27, 0x09	; 9
     624:	cc 0c       	add	r12, r12
     626:	dd 1c       	adc	r13, r13
     628:	ee 1c       	adc	r14, r14
     62a:	ff 1c       	adc	r15, r15
     62c:	ba 95       	dec	r27
     62e:	d1 f7       	brne	.-12     	; 0x624 <disk_write+0x3e>
     630:	b0 2d       	mov	r27, r0

	if (count == 1) {	/* Single block write */
     632:	01 30       	cpi	r16, 0x01	; 1
     634:	71 f4       	brne	.+28     	; 0x652 <disk_write+0x6c>
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
     636:	88 e1       	ldi	r24, 0x18	; 24
     638:	b7 01       	movw	r22, r14
     63a:	a6 01       	movw	r20, r12
     63c:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     640:	88 23       	and	r24, r24
     642:	71 f5       	brne	.+92     	; 0x6a0 <disk_write+0xba>
			&& xmit_datablock(buff, 0xFE))
     644:	ce 01       	movw	r24, r28
     646:	6e ef       	ldi	r22, 0xFE	; 254
     648:	0e 94 39 01 	call	0x272	; 0x272 <xmit_datablock>
     64c:	00 97       	sbiw	r24, 0x00	; 0
     64e:	29 f5       	brne	.+74     	; 0x69a <disk_write+0xb4>
     650:	27 c0       	rjmp	.+78     	; 0x6a0 <disk_write+0xba>
			count = 0;
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
     652:	86 70       	andi	r24, 0x06	; 6
     654:	90 70       	andi	r25, 0x00	; 0
     656:	00 97       	sbiw	r24, 0x00	; 0
     658:	39 f0       	breq	.+14     	; 0x668 <disk_write+0x82>
     65a:	40 2f       	mov	r20, r16
     65c:	50 e0       	ldi	r21, 0x00	; 0
     65e:	60 e0       	ldi	r22, 0x00	; 0
     660:	70 e0       	ldi	r23, 0x00	; 0
     662:	87 e9       	ldi	r24, 0x97	; 151
     664:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
     668:	89 e1       	ldi	r24, 0x19	; 25
     66a:	b7 01       	movw	r22, r14
     66c:	a6 01       	movw	r20, r12
     66e:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     672:	88 23       	and	r24, r24
     674:	a9 f4       	brne	.+42     	; 0x6a0 <disk_write+0xba>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
     676:	ce 01       	movw	r24, r28
     678:	6c ef       	ldi	r22, 0xFC	; 252
     67a:	0e 94 39 01 	call	0x272	; 0x272 <xmit_datablock>
     67e:	00 97       	sbiw	r24, 0x00	; 0
     680:	21 f0       	breq	.+8      	; 0x68a <disk_write+0xa4>
				buff += 512;
     682:	c0 50       	subi	r28, 0x00	; 0
     684:	de 4f       	sbci	r29, 0xFE	; 254
			} while (--count);
     686:	01 50       	subi	r16, 0x01	; 1
     688:	b1 f7       	brne	.-20     	; 0x676 <disk_write+0x90>
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
     68a:	80 e0       	ldi	r24, 0x00	; 0
     68c:	90 e0       	ldi	r25, 0x00	; 0
     68e:	6d ef       	ldi	r22, 0xFD	; 253
     690:	0e 94 39 01 	call	0x272	; 0x272 <xmit_datablock>
     694:	00 97       	sbiw	r24, 0x00	; 0
     696:	19 f0       	breq	.+6      	; 0x69e <disk_write+0xb8>
     698:	03 c0       	rjmp	.+6      	; 0x6a0 <disk_write+0xba>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */

	if (count == 1) {	/* Single block write */
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
			&& xmit_datablock(buff, 0xFE))
			count = 0;
     69a:	00 e0       	ldi	r16, 0x00	; 0
     69c:	01 c0       	rjmp	.+2      	; 0x6a0 <disk_write+0xba>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
				buff += 512;
			} while (--count);
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
				count = 1;
     69e:	01 e0       	ldi	r16, 0x01	; 1
		}
	}
	deselect();
     6a0:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>

	return count ? RES_ERROR : RES_OK;
     6a4:	81 e0       	ldi	r24, 0x01	; 1
     6a6:	00 23       	and	r16, r16
     6a8:	49 f4       	brne	.+18     	; 0x6bc <disk_write+0xd6>
     6aa:	80 e0       	ldi	r24, 0x00	; 0
     6ac:	07 c0       	rjmp	.+14     	; 0x6bc <disk_write+0xd6>
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
	if (drv || !count) return RES_PARERR;
     6ae:	84 e0       	ldi	r24, 0x04	; 4
     6b0:	05 c0       	rjmp	.+10     	; 0x6bc <disk_write+0xd6>
     6b2:	84 e0       	ldi	r24, 0x04	; 4
     6b4:	03 c0       	rjmp	.+6      	; 0x6bc <disk_write+0xd6>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     6b6:	83 e0       	ldi	r24, 0x03	; 3
     6b8:	01 c0       	rjmp	.+2      	; 0x6bc <disk_write+0xd6>
	if (Stat & STA_PROTECT) return RES_WRPRT;
     6ba:	82 e0       	ldi	r24, 0x02	; 2
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
     6bc:	df 91       	pop	r29
     6be:	cf 91       	pop	r28
     6c0:	0f 91       	pop	r16
     6c2:	ff 90       	pop	r15
     6c4:	ef 90       	pop	r14
     6c6:	df 90       	pop	r13
     6c8:	cf 90       	pop	r12
     6ca:	08 95       	ret

000006cc <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
     6cc:	ef 92       	push	r14
     6ce:	ff 92       	push	r15
     6d0:	0f 93       	push	r16
     6d2:	1f 93       	push	r17
     6d4:	cf 93       	push	r28
     6d6:	df 93       	push	r29
     6d8:	cd b7       	in	r28, 0x3d	; 61
     6da:	de b7       	in	r29, 0x3e	; 62
     6dc:	60 97       	sbiw	r28, 0x10	; 16
     6de:	0f b6       	in	r0, 0x3f	; 63
     6e0:	f8 94       	cli
     6e2:	de bf       	out	0x3e, r29	; 62
     6e4:	0f be       	out	0x3f, r0	; 63
     6e6:	cd bf       	out	0x3d, r28	; 61
     6e8:	7a 01       	movw	r14, r20
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	DWORD csize;


	if (drv) return RES_PARERR;
     6ea:	88 23       	and	r24, r24
     6ec:	09 f0       	breq	.+2      	; 0x6f0 <disk_ioctl+0x24>
     6ee:	da c1       	rjmp	.+948    	; 0xaa4 <disk_ioctl+0x3d8>

	res = RES_ERROR;

	if (ctrl == CTRL_POWER) {
     6f0:	65 30       	cpi	r22, 0x05	; 5
     6f2:	89 f4       	brne	.+34     	; 0x716 <disk_ioctl+0x4a>
		switch (ptr[0]) {
     6f4:	fa 01       	movw	r30, r20
     6f6:	80 81       	ld	r24, Z
     6f8:	88 23       	and	r24, r24
     6fa:	21 f0       	breq	.+8      	; 0x704 <disk_ioctl+0x38>
     6fc:	81 30       	cpi	r24, 0x01	; 1
     6fe:	09 f0       	breq	.+2      	; 0x702 <disk_ioctl+0x36>
     700:	d3 c1       	rjmp	.+934    	; 0xaa8 <disk_ioctl+0x3dc>
     702:	04 c0       	rjmp	.+8      	; 0x70c <disk_ioctl+0x40>
		case 0:		/* Sub control code (POWER_OFF) */
			power_off();		/* Power off */
     704:	0e 94 bc 00 	call	0x178	; 0x178 <power_off>
			res = RES_OK;
     708:	00 e0       	ldi	r16, 0x00	; 0
			break;
     70a:	d1 c1       	rjmp	.+930    	; 0xaae <disk_ioctl+0x3e2>
		case 1:		/* Sub control code (POWER_GET) */
			ptr[1] = (BYTE)power_status();
     70c:	81 e0       	ldi	r24, 0x01	; 1
     70e:	fa 01       	movw	r30, r20
     710:	81 83       	std	Z+1, r24	; 0x01
			res = RES_OK;
     712:	00 e0       	ldi	r16, 0x00	; 0
			break;
     714:	cc c1       	rjmp	.+920    	; 0xaae <disk_ioctl+0x3e2>
		default :
			res = RES_PARERR;
		}
	}
	else {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
     716:	80 91 8a 01 	lds	r24, 0x018A
     71a:	80 fd       	sbrc	r24, 0
     71c:	c7 c1       	rjmp	.+910    	; 0xaac <disk_ioctl+0x3e0>

		switch (ctrl) {
     71e:	6a 30       	cpi	r22, 0x0A	; 10
     720:	09 f4       	brne	.+2      	; 0x724 <disk_ioctl+0x58>
     722:	44 c1       	rjmp	.+648    	; 0x9ac <disk_ioctl+0x2e0>
     724:	6b 30       	cpi	r22, 0x0B	; 11
     726:	58 f4       	brcc	.+22     	; 0x73e <disk_ioctl+0x72>
     728:	61 30       	cpi	r22, 0x01	; 1
     72a:	f9 f0       	breq	.+62     	; 0x76a <disk_ioctl+0x9e>
     72c:	61 30       	cpi	r22, 0x01	; 1
     72e:	a0 f0       	brcs	.+40     	; 0x758 <disk_ioctl+0x8c>
     730:	62 30       	cpi	r22, 0x02	; 2
     732:	09 f4       	brne	.+2      	; 0x736 <disk_ioctl+0x6a>
     734:	98 c0       	rjmp	.+304    	; 0x866 <disk_ioctl+0x19a>
     736:	63 30       	cpi	r22, 0x03	; 3
     738:	09 f0       	breq	.+2      	; 0x73c <disk_ioctl+0x70>
     73a:	94 c1       	rjmp	.+808    	; 0xa64 <disk_ioctl+0x398>
     73c:	9b c0       	rjmp	.+310    	; 0x874 <disk_ioctl+0x1a8>
     73e:	6c 30       	cpi	r22, 0x0C	; 12
     740:	09 f4       	brne	.+2      	; 0x744 <disk_ioctl+0x78>
     742:	4f c1       	rjmp	.+670    	; 0x9e2 <disk_ioctl+0x316>
     744:	6c 30       	cpi	r22, 0x0C	; 12
     746:	08 f4       	brcc	.+2      	; 0x74a <disk_ioctl+0x7e>
     748:	37 c1       	rjmp	.+622    	; 0x9b8 <disk_ioctl+0x2ec>
     74a:	6d 30       	cpi	r22, 0x0D	; 13
     74c:	09 f4       	brne	.+2      	; 0x750 <disk_ioctl+0x84>
     74e:	5e c1       	rjmp	.+700    	; 0xa0c <disk_ioctl+0x340>
     750:	6e 30       	cpi	r22, 0x0E	; 14
     752:	09 f0       	breq	.+2      	; 0x756 <disk_ioctl+0x8a>
     754:	87 c1       	rjmp	.+782    	; 0xa64 <disk_ioctl+0x398>
     756:	70 c1       	rjmp	.+736    	; 0xa38 <disk_ioctl+0x36c>
		case CTRL_SYNC :		/* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
			if (select()) {
     758:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <select>
     75c:	00 97       	sbiw	r24, 0x00	; 0
     75e:	09 f4       	brne	.+2      	; 0x762 <disk_ioctl+0x96>
     760:	83 c1       	rjmp	.+774    	; 0xa68 <disk_ioctl+0x39c>
				deselect();
     762:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
				res = RES_OK;
     766:	00 e0       	ldi	r16, 0x00	; 0
     768:	9a c1       	rjmp	.+820    	; 0xa9e <disk_ioctl+0x3d2>
			}
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
     76a:	89 e0       	ldi	r24, 0x09	; 9
     76c:	40 e0       	ldi	r20, 0x00	; 0
     76e:	50 e0       	ldi	r21, 0x00	; 0
     770:	ba 01       	movw	r22, r20
     772:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     776:	88 23       	and	r24, r24
     778:	09 f0       	breq	.+2      	; 0x77c <disk_ioctl+0xb0>
     77a:	78 c1       	rjmp	.+752    	; 0xa6c <disk_ioctl+0x3a0>
     77c:	ce 01       	movw	r24, r28
     77e:	01 96       	adiw	r24, 0x01	; 1
     780:	40 e1       	ldi	r20, 0x10	; 16
     782:	50 e0       	ldi	r21, 0x00	; 0
     784:	60 e0       	ldi	r22, 0x00	; 0
     786:	70 e0       	ldi	r23, 0x00	; 0
     788:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     78c:	00 97       	sbiw	r24, 0x00	; 0
     78e:	09 f4       	brne	.+2      	; 0x792 <disk_ioctl+0xc6>
     790:	6f c1       	rjmp	.+734    	; 0xa70 <disk_ioctl+0x3a4>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
     792:	89 81       	ldd	r24, Y+1	; 0x01
     794:	82 95       	swap	r24
     796:	86 95       	lsr	r24
     798:	86 95       	lsr	r24
     79a:	83 70       	andi	r24, 0x03	; 3
     79c:	81 30       	cpi	r24, 0x01	; 1
     79e:	51 f5       	brne	.+84     	; 0x7f4 <disk_ioctl+0x128>
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
     7a0:	48 85       	ldd	r20, Y+8	; 0x08
     7a2:	50 e0       	ldi	r21, 0x00	; 0
     7a4:	60 e0       	ldi	r22, 0x00	; 0
     7a6:	70 e0       	ldi	r23, 0x00	; 0
     7a8:	4f 73       	andi	r20, 0x3F	; 63
     7aa:	50 70       	andi	r21, 0x00	; 0
     7ac:	60 70       	andi	r22, 0x00	; 0
     7ae:	70 70       	andi	r23, 0x00	; 0
     7b0:	ba 01       	movw	r22, r20
     7b2:	55 27       	eor	r21, r21
     7b4:	44 27       	eor	r20, r20
     7b6:	4f 5f       	subi	r20, 0xFF	; 255
     7b8:	5f 4f       	sbci	r21, 0xFF	; 255
     7ba:	6f 4f       	sbci	r22, 0xFF	; 255
     7bc:	7f 4f       	sbci	r23, 0xFF	; 255
     7be:	99 85       	ldd	r25, Y+9	; 0x09
     7c0:	80 e0       	ldi	r24, 0x00	; 0
     7c2:	2a 85       	ldd	r18, Y+10	; 0x0a
     7c4:	82 0f       	add	r24, r18
     7c6:	91 1d       	adc	r25, r1
     7c8:	a0 e0       	ldi	r26, 0x00	; 0
     7ca:	b0 e0       	ldi	r27, 0x00	; 0
     7cc:	84 0f       	add	r24, r20
     7ce:	95 1f       	adc	r25, r21
     7d0:	a6 1f       	adc	r26, r22
     7d2:	b7 1f       	adc	r27, r23
					*(DWORD*)buff = csize << 10;
     7d4:	07 2e       	mov	r0, r23
     7d6:	7a e0       	ldi	r23, 0x0A	; 10
     7d8:	88 0f       	add	r24, r24
     7da:	99 1f       	adc	r25, r25
     7dc:	aa 1f       	adc	r26, r26
     7de:	bb 1f       	adc	r27, r27
     7e0:	7a 95       	dec	r23
     7e2:	d1 f7       	brne	.-12     	; 0x7d8 <disk_ioctl+0x10c>
     7e4:	70 2d       	mov	r23, r0
     7e6:	f7 01       	movw	r30, r14
     7e8:	80 83       	st	Z, r24
     7ea:	91 83       	std	Z+1, r25	; 0x01
     7ec:	a2 83       	std	Z+2, r26	; 0x02
     7ee:	b3 83       	std	Z+3, r27	; 0x03
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = csize << (n - 9);
				}
				res = RES_OK;
     7f0:	00 e0       	ldi	r16, 0x00	; 0
     7f2:	55 c1       	rjmp	.+682    	; 0xa9e <disk_ioctl+0x3d2>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = csize << 10;
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
     7f4:	29 85       	ldd	r18, Y+9	; 0x09
     7f6:	22 95       	swap	r18
     7f8:	26 95       	lsr	r18
     7fa:	26 95       	lsr	r18
     7fc:	23 70       	andi	r18, 0x03	; 3
     7fe:	88 85       	ldd	r24, Y+8	; 0x08
     800:	90 e0       	ldi	r25, 0x00	; 0
     802:	88 0f       	add	r24, r24
     804:	99 1f       	adc	r25, r25
     806:	88 0f       	add	r24, r24
     808:	99 1f       	adc	r25, r25
     80a:	82 0f       	add	r24, r18
     80c:	91 1d       	adc	r25, r1
     80e:	01 96       	adiw	r24, 0x01	; 1
     810:	2f 81       	ldd	r18, Y+7	; 0x07
     812:	30 e0       	ldi	r19, 0x00	; 0
     814:	23 70       	andi	r18, 0x03	; 3
     816:	30 70       	andi	r19, 0x00	; 0
     818:	32 2f       	mov	r19, r18
     81a:	22 27       	eor	r18, r18
     81c:	33 0f       	add	r19, r19
     81e:	33 0f       	add	r19, r19
     820:	82 0f       	add	r24, r18
     822:	93 1f       	adc	r25, r19
     824:	ac 01       	movw	r20, r24
     826:	60 e0       	ldi	r22, 0x00	; 0
     828:	70 e0       	ldi	r23, 0x00	; 0
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = csize << 10;
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
     82a:	9e 81       	ldd	r25, Y+6	; 0x06
     82c:	9f 70       	andi	r25, 0x0F	; 15
     82e:	8b 85       	ldd	r24, Y+11	; 0x0b
     830:	88 1f       	adc	r24, r24
     832:	88 27       	eor	r24, r24
     834:	88 1f       	adc	r24, r24
     836:	98 0f       	add	r25, r24
     838:	9e 5f       	subi	r25, 0xFE	; 254
     83a:	8a 85       	ldd	r24, Y+10	; 0x0a
     83c:	83 70       	andi	r24, 0x03	; 3
     83e:	88 0f       	add	r24, r24
     840:	89 0f       	add	r24, r25
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = csize << (n - 9);
     842:	90 e0       	ldi	r25, 0x00	; 0
     844:	09 97       	sbiw	r24, 0x09	; 9
     846:	8a 01       	movw	r16, r20
     848:	9b 01       	movw	r18, r22
     84a:	04 c0       	rjmp	.+8      	; 0x854 <disk_ioctl+0x188>
     84c:	00 0f       	add	r16, r16
     84e:	11 1f       	adc	r17, r17
     850:	22 1f       	adc	r18, r18
     852:	33 1f       	adc	r19, r19
     854:	8a 95       	dec	r24
     856:	d2 f7       	brpl	.-12     	; 0x84c <disk_ioctl+0x180>
     858:	f7 01       	movw	r30, r14
     85a:	00 83       	st	Z, r16
     85c:	11 83       	std	Z+1, r17	; 0x01
     85e:	22 83       	std	Z+2, r18	; 0x02
     860:	33 83       	std	Z+3, r19	; 0x03
				}
				res = RES_OK;
     862:	00 e0       	ldi	r16, 0x00	; 0
     864:	1c c1       	rjmp	.+568    	; 0xa9e <disk_ioctl+0x3d2>
			}
			break;

		case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
			*(WORD*)buff = 512;
     866:	80 e0       	ldi	r24, 0x00	; 0
     868:	92 e0       	ldi	r25, 0x02	; 2
     86a:	fa 01       	movw	r30, r20
     86c:	91 83       	std	Z+1, r25	; 0x01
     86e:	80 83       	st	Z, r24
			res = RES_OK;
     870:	00 e0       	ldi	r16, 0x00	; 0
			break;
     872:	15 c1       	rjmp	.+554    	; 0xa9e <disk_ioctl+0x3d2>

		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
			if (CardType & CT_SD2) {	/* SDv2? */
     874:	00 91 f8 02 	lds	r16, 0x02F8
     878:	02 ff       	sbrs	r16, 2
     87a:	31 c0       	rjmp	.+98     	; 0x8de <disk_ioctl+0x212>
				if (send_cmd(ACMD13, 0) == 0) {	/* Read SD status */
     87c:	8d e8       	ldi	r24, 0x8D	; 141
     87e:	40 e0       	ldi	r20, 0x00	; 0
     880:	50 e0       	ldi	r21, 0x00	; 0
     882:	ba 01       	movw	r22, r20
     884:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     888:	88 23       	and	r24, r24
     88a:	09 f0       	breq	.+2      	; 0x88e <disk_ioctl+0x1c2>
     88c:	f3 c0       	rjmp	.+486    	; 0xa74 <disk_ioctl+0x3a8>
					xchg_spi(0xFF);
     88e:	8f ef       	ldi	r24, 0xFF	; 255
     890:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
					if (rcvr_datablock(csd, 16)) {				/* Read partial block */
     894:	ce 01       	movw	r24, r28
     896:	01 96       	adiw	r24, 0x01	; 1
     898:	40 e1       	ldi	r20, 0x10	; 16
     89a:	50 e0       	ldi	r21, 0x00	; 0
     89c:	60 e0       	ldi	r22, 0x00	; 0
     89e:	70 e0       	ldi	r23, 0x00	; 0
     8a0:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     8a4:	00 97       	sbiw	r24, 0x00	; 0
     8a6:	09 f4       	brne	.+2      	; 0x8aa <disk_ioctl+0x1de>
     8a8:	e7 c0       	rjmp	.+462    	; 0xa78 <disk_ioctl+0x3ac>
     8aa:	00 e3       	ldi	r16, 0x30	; 48
						for (n = 64 - 16; n; n--) xchg_spi(0xFF);	/* Purge trailing data */
     8ac:	8f ef       	ldi	r24, 0xFF	; 255
     8ae:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     8b2:	01 50       	subi	r16, 0x01	; 1
     8b4:	d9 f7       	brne	.-10     	; 0x8ac <disk_ioctl+0x1e0>
						*(DWORD*)buff = 16UL << (csd[10] >> 4);
     8b6:	2b 85       	ldd	r18, Y+11	; 0x0b
     8b8:	22 95       	swap	r18
     8ba:	2f 70       	andi	r18, 0x0F	; 15
     8bc:	80 e1       	ldi	r24, 0x10	; 16
     8be:	90 e0       	ldi	r25, 0x00	; 0
     8c0:	a0 e0       	ldi	r26, 0x00	; 0
     8c2:	b0 e0       	ldi	r27, 0x00	; 0
     8c4:	04 c0       	rjmp	.+8      	; 0x8ce <disk_ioctl+0x202>
     8c6:	88 0f       	add	r24, r24
     8c8:	99 1f       	adc	r25, r25
     8ca:	aa 1f       	adc	r26, r26
     8cc:	bb 1f       	adc	r27, r27
     8ce:	2a 95       	dec	r18
     8d0:	d2 f7       	brpl	.-12     	; 0x8c6 <disk_ioctl+0x1fa>
     8d2:	f7 01       	movw	r30, r14
     8d4:	80 83       	st	Z, r24
     8d6:	91 83       	std	Z+1, r25	; 0x01
     8d8:	a2 83       	std	Z+2, r26	; 0x02
     8da:	b3 83       	std	Z+3, r27	; 0x03
     8dc:	e0 c0       	rjmp	.+448    	; 0xa9e <disk_ioctl+0x3d2>
						res = RES_OK;
					}
				}
			} else {					/* SDv1 or MMCv3 */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
     8de:	89 e0       	ldi	r24, 0x09	; 9
     8e0:	40 e0       	ldi	r20, 0x00	; 0
     8e2:	50 e0       	ldi	r21, 0x00	; 0
     8e4:	ba 01       	movw	r22, r20
     8e6:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     8ea:	88 23       	and	r24, r24
     8ec:	09 f0       	breq	.+2      	; 0x8f0 <disk_ioctl+0x224>
     8ee:	c6 c0       	rjmp	.+396    	; 0xa7c <disk_ioctl+0x3b0>
     8f0:	ce 01       	movw	r24, r28
     8f2:	01 96       	adiw	r24, 0x01	; 1
     8f4:	40 e1       	ldi	r20, 0x10	; 16
     8f6:	50 e0       	ldi	r21, 0x00	; 0
     8f8:	60 e0       	ldi	r22, 0x00	; 0
     8fa:	70 e0       	ldi	r23, 0x00	; 0
     8fc:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     900:	00 97       	sbiw	r24, 0x00	; 0
     902:	09 f4       	brne	.+2      	; 0x906 <disk_ioctl+0x23a>
     904:	bd c0       	rjmp	.+378    	; 0xa80 <disk_ioctl+0x3b4>
					if (CardType & CT_SD1) {	/* SDv1 */
     906:	01 ff       	sbrs	r16, 1
     908:	25 c0       	rjmp	.+74     	; 0x954 <disk_ioctl+0x288>
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
     90a:	8c 85       	ldd	r24, Y+12	; 0x0c
     90c:	88 1f       	adc	r24, r24
     90e:	88 27       	eor	r24, r24
     910:	88 1f       	adc	r24, r24
     912:	90 e0       	ldi	r25, 0x00	; 0
     914:	01 96       	adiw	r24, 0x01	; 1
     916:	2b 85       	ldd	r18, Y+11	; 0x0b
     918:	30 e0       	ldi	r19, 0x00	; 0
     91a:	2f 73       	andi	r18, 0x3F	; 63
     91c:	30 70       	andi	r19, 0x00	; 0
     91e:	22 0f       	add	r18, r18
     920:	33 1f       	adc	r19, r19
     922:	28 0f       	add	r18, r24
     924:	39 1f       	adc	r19, r25
     926:	8e 85       	ldd	r24, Y+14	; 0x0e
     928:	82 95       	swap	r24
     92a:	86 95       	lsr	r24
     92c:	86 95       	lsr	r24
     92e:	83 70       	andi	r24, 0x03	; 3
     930:	90 e0       	ldi	r25, 0x00	; 0
     932:	01 97       	sbiw	r24, 0x01	; 1
     934:	89 01       	movw	r16, r18
     936:	02 c0       	rjmp	.+4      	; 0x93c <disk_ioctl+0x270>
     938:	00 0f       	add	r16, r16
     93a:	11 1f       	adc	r17, r17
     93c:	8a 95       	dec	r24
     93e:	e2 f7       	brpl	.-8      	; 0x938 <disk_ioctl+0x26c>
     940:	c8 01       	movw	r24, r16
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	f7 01       	movw	r30, r14
     948:	80 83       	st	Z, r24
     94a:	91 83       	std	Z+1, r25	; 0x01
     94c:	a2 83       	std	Z+2, r26	; 0x02
     94e:	b3 83       	std	Z+3, r27	; 0x03
					} else {					/* MMCv3 */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
					}
					res = RES_OK;
     950:	00 e0       	ldi	r16, 0x00	; 0
     952:	a5 c0       	rjmp	.+330    	; 0xa9e <disk_ioctl+0x3d2>
			} else {					/* SDv1 or MMCv3 */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
					if (CardType & CT_SD1) {	/* SDv1 */
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
					} else {					/* MMCv3 */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
     954:	8c 85       	ldd	r24, Y+12	; 0x0c
     956:	48 2f       	mov	r20, r24
     958:	50 e0       	ldi	r21, 0x00	; 0
     95a:	43 70       	andi	r20, 0x03	; 3
     95c:	50 70       	andi	r21, 0x00	; 0
     95e:	44 0f       	add	r20, r20
     960:	55 1f       	adc	r21, r21
     962:	44 0f       	add	r20, r20
     964:	55 1f       	adc	r21, r21
     966:	44 0f       	add	r20, r20
     968:	55 1f       	adc	r21, r21
     96a:	82 95       	swap	r24
     96c:	86 95       	lsr	r24
     96e:	87 70       	andi	r24, 0x07	; 7
     970:	48 0f       	add	r20, r24
     972:	51 1d       	adc	r21, r1
     974:	4f 5f       	subi	r20, 0xFF	; 255
     976:	5f 4f       	sbci	r21, 0xFF	; 255
     978:	2b 85       	ldd	r18, Y+11	; 0x0b
     97a:	30 e0       	ldi	r19, 0x00	; 0
     97c:	2c 77       	andi	r18, 0x7C	; 124
     97e:	30 70       	andi	r19, 0x00	; 0
     980:	35 95       	asr	r19
     982:	27 95       	ror	r18
     984:	35 95       	asr	r19
     986:	27 95       	ror	r18
     988:	2f 5f       	subi	r18, 0xFF	; 255
     98a:	3f 4f       	sbci	r19, 0xFF	; 255
     98c:	42 9f       	mul	r20, r18
     98e:	c0 01       	movw	r24, r0
     990:	43 9f       	mul	r20, r19
     992:	90 0d       	add	r25, r0
     994:	52 9f       	mul	r21, r18
     996:	90 0d       	add	r25, r0
     998:	11 24       	eor	r1, r1
     99a:	a0 e0       	ldi	r26, 0x00	; 0
     99c:	b0 e0       	ldi	r27, 0x00	; 0
     99e:	f7 01       	movw	r30, r14
     9a0:	80 83       	st	Z, r24
     9a2:	91 83       	std	Z+1, r25	; 0x01
     9a4:	a2 83       	std	Z+2, r26	; 0x02
     9a6:	b3 83       	std	Z+3, r27	; 0x03
					}
					res = RES_OK;
     9a8:	00 e0       	ldi	r16, 0x00	; 0
     9aa:	79 c0       	rjmp	.+242    	; 0xa9e <disk_ioctl+0x3d2>
				}
			}
			break;

		case MMC_GET_TYPE :		/* Get card type flags (1 byte) */
			*ptr = CardType;
     9ac:	80 91 f8 02 	lds	r24, 0x02F8
     9b0:	fa 01       	movw	r30, r20
     9b2:	80 83       	st	Z, r24
			res = RES_OK;
     9b4:	00 e0       	ldi	r16, 0x00	; 0
			break;
     9b6:	73 c0       	rjmp	.+230    	; 0xa9e <disk_ioctl+0x3d2>

		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
     9b8:	89 e0       	ldi	r24, 0x09	; 9
     9ba:	40 e0       	ldi	r20, 0x00	; 0
     9bc:	50 e0       	ldi	r21, 0x00	; 0
     9be:	ba 01       	movw	r22, r20
     9c0:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     9c4:	88 23       	and	r24, r24
     9c6:	09 f0       	breq	.+2      	; 0x9ca <disk_ioctl+0x2fe>
     9c8:	5d c0       	rjmp	.+186    	; 0xa84 <disk_ioctl+0x3b8>
				&& rcvr_datablock(ptr, 16))
     9ca:	c7 01       	movw	r24, r14
     9cc:	40 e1       	ldi	r20, 0x10	; 16
     9ce:	50 e0       	ldi	r21, 0x00	; 0
     9d0:	60 e0       	ldi	r22, 0x00	; 0
     9d2:	70 e0       	ldi	r23, 0x00	; 0
     9d4:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     9d8:	00 97       	sbiw	r24, 0x00	; 0
     9da:	09 f0       	breq	.+2      	; 0x9de <disk_ioctl+0x312>
     9dc:	55 c0       	rjmp	.+170    	; 0xa88 <disk_ioctl+0x3bc>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     9de:	01 e0       	ldi	r16, 0x01	; 1
     9e0:	5e c0       	rjmp	.+188    	; 0xa9e <disk_ioctl+0x3d2>
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
			break;

		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
     9e2:	8a e0       	ldi	r24, 0x0A	; 10
     9e4:	40 e0       	ldi	r20, 0x00	; 0
     9e6:	50 e0       	ldi	r21, 0x00	; 0
     9e8:	ba 01       	movw	r22, r20
     9ea:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     9ee:	88 23       	and	r24, r24
     9f0:	09 f0       	breq	.+2      	; 0x9f4 <disk_ioctl+0x328>
     9f2:	4c c0       	rjmp	.+152    	; 0xa8c <disk_ioctl+0x3c0>
				&& rcvr_datablock(ptr, 16))
     9f4:	c7 01       	movw	r24, r14
     9f6:	40 e1       	ldi	r20, 0x10	; 16
     9f8:	50 e0       	ldi	r21, 0x00	; 0
     9fa:	60 e0       	ldi	r22, 0x00	; 0
     9fc:	70 e0       	ldi	r23, 0x00	; 0
     9fe:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     a02:	00 97       	sbiw	r24, 0x00	; 0
     a04:	09 f0       	breq	.+2      	; 0xa08 <disk_ioctl+0x33c>
     a06:	44 c0       	rjmp	.+136    	; 0xa90 <disk_ioctl+0x3c4>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a08:	01 e0       	ldi	r16, 0x01	; 1
     a0a:	49 c0       	rjmp	.+146    	; 0xa9e <disk_ioctl+0x3d2>
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
			break;

		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
			if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
     a0c:	8a e3       	ldi	r24, 0x3A	; 58
     a0e:	40 e0       	ldi	r20, 0x00	; 0
     a10:	50 e0       	ldi	r21, 0x00	; 0
     a12:	ba 01       	movw	r22, r20
     a14:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     a18:	88 23       	and	r24, r24
     a1a:	e1 f5       	brne	.+120    	; 0xa94 <disk_ioctl+0x3c8>
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
/*-----------------------------------------------------------------------*/

#if _USE_IOCTL
DRESULT disk_ioctl (
     a1c:	87 01       	movw	r16, r14
     a1e:	0c 5f       	subi	r16, 0xFC	; 252
     a20:	1f 4f       	sbci	r17, 0xFF	; 255
				res = RES_OK;
			break;

		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
			if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
				for (n = 4; n; n--) *ptr++ = xchg_spi(0xFF);
     a22:	8f ef       	ldi	r24, 0xFF	; 255
     a24:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     a28:	f7 01       	movw	r30, r14
     a2a:	81 93       	st	Z+, r24
     a2c:	7f 01       	movw	r14, r30
     a2e:	e0 17       	cp	r30, r16
     a30:	f1 07       	cpc	r31, r17
     a32:	b9 f7       	brne	.-18     	; 0xa22 <disk_ioctl+0x356>
				res = RES_OK;
     a34:	00 e0       	ldi	r16, 0x00	; 0
     a36:	33 c0       	rjmp	.+102    	; 0xa9e <disk_ioctl+0x3d2>
			}
			break;

		case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
			if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
     a38:	8d e8       	ldi	r24, 0x8D	; 141
     a3a:	40 e0       	ldi	r20, 0x00	; 0
     a3c:	50 e0       	ldi	r21, 0x00	; 0
     a3e:	ba 01       	movw	r22, r20
     a40:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     a44:	88 23       	and	r24, r24
     a46:	41 f5       	brne	.+80     	; 0xa98 <disk_ioctl+0x3cc>
				xchg_spi(0xFF);
     a48:	8f ef       	ldi	r24, 0xFF	; 255
     a4a:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
				if (rcvr_datablock(ptr, 64))
     a4e:	c7 01       	movw	r24, r14
     a50:	40 e4       	ldi	r20, 0x40	; 64
     a52:	50 e0       	ldi	r21, 0x00	; 0
     a54:	60 e0       	ldi	r22, 0x00	; 0
     a56:	70 e0       	ldi	r23, 0x00	; 0
     a58:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     a5c:	00 97       	sbiw	r24, 0x00	; 0
     a5e:	f1 f4       	brne	.+60     	; 0xa9c <disk_ioctl+0x3d0>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a60:	01 e0       	ldi	r16, 0x01	; 1
     a62:	1d c0       	rjmp	.+58     	; 0xa9e <disk_ioctl+0x3d2>
					res = RES_OK;
			}
			break;

		default:
			res = RES_PARERR;
     a64:	04 e0       	ldi	r16, 0x04	; 4
     a66:	1b c0       	rjmp	.+54     	; 0xa9e <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a68:	01 e0       	ldi	r16, 0x01	; 1
     a6a:	19 c0       	rjmp	.+50     	; 0xa9e <disk_ioctl+0x3d2>
     a6c:	01 e0       	ldi	r16, 0x01	; 1
     a6e:	17 c0       	rjmp	.+46     	; 0xa9e <disk_ioctl+0x3d2>
     a70:	01 e0       	ldi	r16, 0x01	; 1
     a72:	15 c0       	rjmp	.+42     	; 0xa9e <disk_ioctl+0x3d2>
     a74:	01 e0       	ldi	r16, 0x01	; 1
     a76:	13 c0       	rjmp	.+38     	; 0xa9e <disk_ioctl+0x3d2>
     a78:	01 e0       	ldi	r16, 0x01	; 1
     a7a:	11 c0       	rjmp	.+34     	; 0xa9e <disk_ioctl+0x3d2>
     a7c:	01 e0       	ldi	r16, 0x01	; 1
     a7e:	0f c0       	rjmp	.+30     	; 0xa9e <disk_ioctl+0x3d2>
     a80:	01 e0       	ldi	r16, 0x01	; 1
     a82:	0d c0       	rjmp	.+26     	; 0xa9e <disk_ioctl+0x3d2>
     a84:	01 e0       	ldi	r16, 0x01	; 1
     a86:	0b c0       	rjmp	.+22     	; 0xa9e <disk_ioctl+0x3d2>
			break;

		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
     a88:	00 e0       	ldi	r16, 0x00	; 0
     a8a:	09 c0       	rjmp	.+18     	; 0xa9e <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a8c:	01 e0       	ldi	r16, 0x01	; 1
     a8e:	07 c0       	rjmp	.+14     	; 0xa9e <disk_ioctl+0x3d2>
			break;

		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
     a90:	00 e0       	ldi	r16, 0x00	; 0
     a92:	05 c0       	rjmp	.+10     	; 0xa9e <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a94:	01 e0       	ldi	r16, 0x01	; 1
     a96:	03 c0       	rjmp	.+6      	; 0xa9e <disk_ioctl+0x3d2>
     a98:	01 e0       	ldi	r16, 0x01	; 1
     a9a:	01 c0       	rjmp	.+2      	; 0xa9e <disk_ioctl+0x3d2>

		case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
			if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
				xchg_spi(0xFF);
				if (rcvr_datablock(ptr, 64))
					res = RES_OK;
     a9c:	00 e0       	ldi	r16, 0x00	; 0

		default:
			res = RES_PARERR;
		}

		deselect();
     a9e:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
     aa2:	05 c0       	rjmp	.+10     	; 0xaae <disk_ioctl+0x3e2>
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	DWORD csize;


	if (drv) return RES_PARERR;
     aa4:	04 e0       	ldi	r16, 0x04	; 4
     aa6:	03 c0       	rjmp	.+6      	; 0xaae <disk_ioctl+0x3e2>
		case 1:		/* Sub control code (POWER_GET) */
			ptr[1] = (BYTE)power_status();
			res = RES_OK;
			break;
		default :
			res = RES_PARERR;
     aa8:	04 e0       	ldi	r16, 0x04	; 4
     aaa:	01 c0       	rjmp	.+2      	; 0xaae <disk_ioctl+0x3e2>
		}
	}
	else {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
     aac:	03 e0       	ldi	r16, 0x03	; 3

		deselect();
	}

	return res;
}
     aae:	80 2f       	mov	r24, r16
     ab0:	60 96       	adiw	r28, 0x10	; 16
     ab2:	0f b6       	in	r0, 0x3f	; 63
     ab4:	f8 94       	cli
     ab6:	de bf       	out	0x3e, r29	; 62
     ab8:	0f be       	out	0x3f, r0	; 63
     aba:	cd bf       	out	0x3d, r28	; 61
     abc:	df 91       	pop	r29
     abe:	cf 91       	pop	r28
     ac0:	1f 91       	pop	r17
     ac2:	0f 91       	pop	r16
     ac4:	ff 90       	pop	r15
     ac6:	ef 90       	pop	r14
     ac8:	08 95       	ret

00000aca <disk_timerproc>:
void disk_timerproc (void)
{
	BYTE n, s;


	n = Timer1;				/* 100Hz decrement timer */
     aca:	80 91 f7 02 	lds	r24, 0x02F7
	if (n) Timer1 = --n;
     ace:	88 23       	and	r24, r24
     ad0:	19 f0       	breq	.+6      	; 0xad8 <disk_timerproc+0xe>
     ad2:	81 50       	subi	r24, 0x01	; 1
     ad4:	80 93 f7 02 	sts	0x02F7, r24
	n = Timer2;
     ad8:	80 91 f6 02 	lds	r24, 0x02F6
	if (n) Timer2 = --n;
     adc:	88 23       	and	r24, r24
     ade:	19 f0       	breq	.+6      	; 0xae6 <disk_timerproc+0x1c>
     ae0:	81 50       	subi	r24, 0x01	; 1
     ae2:	80 93 f6 02 	sts	0x02F6, r24

	s = Stat;
     ae6:	80 91 8a 01 	lds	r24, 0x018A

	if (SOCKWP)				/* Write protected */
     aea:	18 9b       	sbis	0x03, 0	; 3
     aec:	02 c0       	rjmp	.+4      	; 0xaf2 <disk_timerproc+0x28>
		s |= STA_PROTECT;
     aee:	84 60       	ori	r24, 0x04	; 4
     af0:	01 c0       	rjmp	.+2      	; 0xaf4 <disk_timerproc+0x2a>
	else					/* Write enabled */
		s &= ~STA_PROTECT;
     af2:	8b 7f       	andi	r24, 0xFB	; 251

	if (SOCKINS)			/* Card inserted */
     af4:	19 99       	sbic	0x03, 1	; 3
     af6:	02 c0       	rjmp	.+4      	; 0xafc <disk_timerproc+0x32>
		s &= ~STA_NODISK;
     af8:	8d 7f       	andi	r24, 0xFD	; 253
     afa:	01 c0       	rjmp	.+2      	; 0xafe <disk_timerproc+0x34>
	else					/* Socket empty */
		s |= (STA_NODISK | STA_NOINIT);
     afc:	83 60       	ori	r24, 0x03	; 3

	Stat = s;				/* Update MMC status */
     afe:	80 93 8a 01 	sts	0x018A, r24
}
     b02:	08 95       	ret

00000b04 <__vector_1>:



//ISR for controlling WEN.
ISR(INT0_vect)
{
     b04:	1f 92       	push	r1
     b06:	0f 92       	push	r0
     b08:	0f b6       	in	r0, 0x3f	; 63
     b0a:	0f 92       	push	r0
     b0c:	11 24       	eor	r1, r1
     b0e:	8f 93       	push	r24
	//printf("ISR INT0 Entered\n");
	if (VSYNC_0_Count==1)//start a frame read
     b10:	80 91 05 03 	lds	r24, 0x0305
     b14:	81 30       	cpi	r24, 0x01	; 1
     b16:	39 f4       	brne	.+14     	; 0xb26 <__vector_1+0x22>
	{
		FIFO_WEN_0_SET;
     b18:	5e 9a       	sbi	0x0b, 6	; 11
		VSYNC_0_Count++;
     b1a:	80 91 05 03 	lds	r24, 0x0305
     b1e:	8f 5f       	subi	r24, 0xFF	; 255
     b20:	80 93 05 03 	sts	0x0305, r24
     b24:	14 c0       	rjmp	.+40     	; 0xb4e <__vector_1+0x4a>
	}
	else if (VSYNC_0_Count==2)//end a frame read
     b26:	80 91 05 03 	lds	r24, 0x0305
     b2a:	82 30       	cpi	r24, 0x02	; 2
     b2c:	39 f4       	brne	.+14     	; 0xb3c <__vector_1+0x38>
	{
		FIFO_WEN_0_CLR;
     b2e:	5e 98       	cbi	0x0b, 6	; 11
		VSYNC_0_Count++;
     b30:	80 91 05 03 	lds	r24, 0x0305
     b34:	8f 5f       	subi	r24, 0xFF	; 255
     b36:	80 93 05 03 	sts	0x0305, r24
     b3a:	09 c0       	rjmp	.+18     	; 0xb4e <__vector_1+0x4a>
	}
	else if(VSYNC_0_Count == 3)
     b3c:	80 91 05 03 	lds	r24, 0x0305
     b40:	83 30       	cpi	r24, 0x03	; 3
     b42:	11 f4       	brne	.+4      	; 0xb48 <__vector_1+0x44>
	{
		FIFO_WEN_0_CLR;
     b44:	5e 98       	cbi	0x0b, 6	; 11
     b46:	03 c0       	rjmp	.+6      	; 0xb4e <__vector_1+0x4a>
	}
	else
	{
		FIFO_WEN_0_CLR
     b48:	5e 98       	cbi	0x0b, 6	; 11
		VSYNC_0_Count = 0;//wait for a read to be started
     b4a:	10 92 05 03 	sts	0x0305, r1
	}
}
     b4e:	8f 91       	pop	r24
     b50:	0f 90       	pop	r0
     b52:	0f be       	out	0x3f, r0	; 63
     b54:	0f 90       	pop	r0
     b56:	1f 90       	pop	r1
     b58:	18 95       	reti

00000b5a <__vector_2>:
//ISR for controlling WEN.
ISR(INT1_vect)
{
     b5a:	1f 92       	push	r1
     b5c:	0f 92       	push	r0
     b5e:	0f b6       	in	r0, 0x3f	; 63
     b60:	0f 92       	push	r0
     b62:	11 24       	eor	r1, r1
     b64:	8f 93       	push	r24
	//printf("ISR INT1 Entered\n");
	if (VSYNC_1_Count==1)//start a frame read
     b66:	80 91 46 0b 	lds	r24, 0x0B46
     b6a:	81 30       	cpi	r24, 0x01	; 1
     b6c:	39 f4       	brne	.+14     	; 0xb7c <__vector_2+0x22>
	{
		FIFO_WEN_1_SET;
     b6e:	44 9a       	sbi	0x08, 4	; 8
		VSYNC_1_Count++;
     b70:	80 91 46 0b 	lds	r24, 0x0B46
     b74:	8f 5f       	subi	r24, 0xFF	; 255
     b76:	80 93 46 0b 	sts	0x0B46, r24
     b7a:	14 c0       	rjmp	.+40     	; 0xba4 <__vector_2+0x4a>
	}
	else if (VSYNC_1_Count==2)//end a frame read
     b7c:	80 91 46 0b 	lds	r24, 0x0B46
     b80:	82 30       	cpi	r24, 0x02	; 2
     b82:	39 f4       	brne	.+14     	; 0xb92 <__vector_2+0x38>
	{
		FIFO_WEN_1_CLR;
     b84:	44 98       	cbi	0x08, 4	; 8
		VSYNC_1_Count++;
     b86:	80 91 46 0b 	lds	r24, 0x0B46
     b8a:	8f 5f       	subi	r24, 0xFF	; 255
     b8c:	80 93 46 0b 	sts	0x0B46, r24
     b90:	09 c0       	rjmp	.+18     	; 0xba4 <__vector_2+0x4a>
	}
	else if(VSYNC_1_Count == 3)
     b92:	80 91 46 0b 	lds	r24, 0x0B46
     b96:	83 30       	cpi	r24, 0x03	; 3
     b98:	11 f4       	brne	.+4      	; 0xb9e <__vector_2+0x44>
	{
		FIFO_WEN_1_CLR;
     b9a:	44 98       	cbi	0x08, 4	; 8
     b9c:	03 c0       	rjmp	.+6      	; 0xba4 <__vector_2+0x4a>
	}
	else
	{
		FIFO_WEN_1_CLR
     b9e:	44 98       	cbi	0x08, 4	; 8
		VSYNC_1_Count = 0;//wait for a read to be started
     ba0:	10 92 46 0b 	sts	0x0B46, r1
	}
}
     ba4:	8f 91       	pop	r24
     ba6:	0f 90       	pop	r0
     ba8:	0f be       	out	0x3f, r0	; 63
     baa:	0f 90       	pop	r0
     bac:	1f 90       	pop	r1
     bae:	18 95       	reti

00000bb0 <wrOV7670Reg>:

//Write Register Method
unsigned char wrOV7670Reg(unsigned char regID, unsigned char regDat)
{
     bb0:	cf 93       	push	r28
     bb2:	df 93       	push	r29
     bb4:	00 d0       	rcall	.+0      	; 0xbb6 <wrOV7670Reg+0x6>
     bb6:	00 d0       	rcall	.+0      	; 0xbb8 <wrOV7670Reg+0x8>
     bb8:	cd b7       	in	r28, 0x3d	; 61
     bba:	de b7       	in	r29, 0x3e	; 62
	/*	I2C Traffic Generated:
	 *	S | OV_7670 + W | A | RegID | A | Data | A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE];
	messageBuf[0] = (OV7670_ADDR  <<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consit of General Call code or the TWI slave address.
     bbc:	92 e4       	ldi	r25, 0x42	; 66
     bbe:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for commands.
     bc0:	8a 83       	std	Y+2, r24	; 0x02
	messageBuf[2] = regDat;                        // The second byte is used for the data.
     bc2:	6b 83       	std	Y+3, r22	; 0x03
	TWI_Start_Transceiver_With_Data( messageBuf, 3 );
     bc4:	ce 01       	movw	r24, r28
     bc6:	01 96       	adiw	r24, 0x01	; 1
     bc8:	63 e0       	ldi	r22, 0x03	; 3
     bca:	0e 94 a2 28 	call	0x5144	; 0x5144 <TWI_Start_Transceiver_With_Data>
	
	while(TWI_Transceiver_Busy()) ; //Wait for transceiver to clear
     bce:	0e 94 97 28 	call	0x512e	; 0x512e <TWI_Transceiver_Busy>
     bd2:	88 23       	and	r24, r24
     bd4:	e1 f7       	brne	.-8      	; 0xbce <wrOV7670Reg+0x1e>
	
	return TWI_statusReg.lastTransOK;
     bd6:	80 91 fe 02 	lds	r24, 0x02FE
}
     bda:	81 70       	andi	r24, 0x01	; 1
     bdc:	0f 90       	pop	r0
     bde:	0f 90       	pop	r0
     be0:	0f 90       	pop	r0
     be2:	0f 90       	pop	r0
     be4:	df 91       	pop	r29
     be6:	cf 91       	pop	r28
     be8:	08 95       	ret

00000bea <rdOV7670Reg>:

//Read Register Method
unsigned char rdOV7670Reg(unsigned char regID, unsigned char *regDat)
{
     bea:	0f 93       	push	r16
     bec:	1f 93       	push	r17
     bee:	cf 93       	push	r28
     bf0:	df 93       	push	r29
     bf2:	00 d0       	rcall	.+0      	; 0xbf4 <rdOV7670Reg+0xa>
     bf4:	00 d0       	rcall	.+0      	; 0xbf6 <rdOV7670Reg+0xc>
     bf6:	cd b7       	in	r28, 0x3d	; 61
     bf8:	de b7       	in	r29, 0x3e	; 62
     bfa:	8b 01       	movw	r16, r22
	 *	S	|	OV_ADDR + W	| A | RegID | A | P |
	 *	S	|	OV_ADDR + R | A | Data	|~A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE]; //Initialise a buffer
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
     bfc:	92 e4       	ldi	r25, 0x42	; 66
     bfe:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for Address Pointer.
     c00:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
     c02:	ce 01       	movw	r24, r28
     c04:	01 96       	adiw	r24, 0x01	; 1
     c06:	62 e0       	ldi	r22, 0x02	; 2
     c08:	0e 94 a2 28 	call	0x5144	; 0x5144 <TWI_Start_Transceiver_With_Data>
	
	// Request/collect the data from the Slave
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
     c0c:	83 e4       	ldi	r24, 0x43	; 67
     c0e:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );              
     c10:	ce 01       	movw	r24, r28
     c12:	01 96       	adiw	r24, 0x01	; 1
     c14:	62 e0       	ldi	r22, 0x02	; 2
     c16:	0e 94 a2 28 	call	0x5144	; 0x5144 <TWI_Start_Transceiver_With_Data>
    
	// Get the received data from the transceiver buffer
	TWI_Get_Data_From_Transceiver( messageBuf, 2 );
     c1a:	ce 01       	movw	r24, r28
     c1c:	01 96       	adiw	r24, 0x01	; 1
     c1e:	62 e0       	ldi	r22, 0x02	; 2
     c20:	0e 94 d8 28 	call	0x51b0	; 0x51b0 <TWI_Get_Data_From_Transceiver>
	*regDat = messageBuf[1];       
     c24:	8a 81       	ldd	r24, Y+2	; 0x02
     c26:	f8 01       	movw	r30, r16
     c28:	80 83       	st	Z, r24
	return TWI_statusReg.lastTransOK;
     c2a:	80 91 fe 02 	lds	r24, 0x02FE
}
     c2e:	81 70       	andi	r24, 0x01	; 1
     c30:	0f 90       	pop	r0
     c32:	0f 90       	pop	r0
     c34:	0f 90       	pop	r0
     c36:	0f 90       	pop	r0
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	1f 91       	pop	r17
     c3e:	0f 91       	pop	r16
     c40:	08 95       	ret

00000c42 <OV7670_init>:


unsigned char OV7670_init()
{
     c42:	0f 93       	push	r16
     c44:	1f 93       	push	r17
     c46:	cf 93       	push	r28
     c48:	df 93       	push	r29
	uint8_t i = 0;
	if(0==wrOV7670Reg(OV_COM7, 0x80)) //Reset Camera
     c4a:	82 e1       	ldi	r24, 0x12	; 18
     c4c:	60 e8       	ldi	r22, 0x80	; 128
     c4e:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <wrOV7670Reg>
     c52:	88 23       	and	r24, r24
     c54:	f1 f0       	breq	.+60     	; 0xc92 <OV7670_init+0x50>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     c56:	8f e2       	ldi	r24, 0x2F	; 47
     c58:	95 e7       	ldi	r25, 0x75	; 117
     c5a:	01 97       	sbiw	r24, 0x01	; 1
     c5c:	f1 f7       	brne	.-4      	; 0xc5a <OV7670_init+0x18>
     c5e:	00 c0       	rjmp	.+0      	; 0xc60 <OV7670_init+0x1e>
     c60:	00 00       	nop
     c62:	c8 e9       	ldi	r28, 0x98	; 152
     c64:	d1 e0       	ldi	r29, 0x01	; 1
	*regDat = messageBuf[1];       
	return TWI_statusReg.lastTransOK;
}


unsigned char OV7670_init()
     c66:	06 ee       	ldi	r16, 0xE6	; 230
     c68:	12 e0       	ldi	r17, 0x02	; 2
     c6a:	fe 01       	movw	r30, r28
     c6c:	31 97       	sbiw	r30, 0x01	; 1
		return 1;
	}
	_delay_ms(10);
	for(i=0; i<SETTINGS_LENGTH; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
     c6e:	80 81       	ld	r24, Z
     c70:	68 81       	ld	r22, Y
     c72:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <wrOV7670Reg>
     c76:	88 23       	and	r24, r24
     c78:	71 f0       	breq	.+28     	; 0xc96 <OV7670_init+0x54>
     c7a:	87 eb       	ldi	r24, 0xB7	; 183
     c7c:	9b e0       	ldi	r25, 0x0B	; 11
     c7e:	01 97       	sbiw	r24, 0x01	; 1
     c80:	f1 f7       	brne	.-4      	; 0xc7e <OV7670_init+0x3c>
     c82:	00 c0       	rjmp	.+0      	; 0xc84 <OV7670_init+0x42>
     c84:	00 00       	nop
     c86:	22 96       	adiw	r28, 0x02	; 2
	if(0==wrOV7670Reg(OV_COM7, 0x80)) //Reset Camera
	{
		return 1;
	}
	_delay_ms(10);
	for(i=0; i<SETTINGS_LENGTH; i++)
     c88:	c0 17       	cp	r28, r16
     c8a:	d1 07       	cpc	r29, r17
     c8c:	71 f7       	brne	.-36     	; 0xc6a <OV7670_init+0x28>
			return 1;
		}
		_delay_ms(1);
	}
	
	return 0;
     c8e:	80 e0       	ldi	r24, 0x00	; 0
     c90:	03 c0       	rjmp	.+6      	; 0xc98 <OV7670_init+0x56>
unsigned char OV7670_init()
{
	uint8_t i = 0;
	if(0==wrOV7670Reg(OV_COM7, 0x80)) //Reset Camera
	{
		return 1;
     c92:	81 e0       	ldi	r24, 0x01	; 1
     c94:	01 c0       	rjmp	.+2      	; 0xc98 <OV7670_init+0x56>
	_delay_ms(10);
	for(i=0; i<SETTINGS_LENGTH; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
		{
			return 1;
     c96:	81 e0       	ldi	r24, 0x01	; 1
		}
		_delay_ms(1);
	}
	
	return 0;
}
     c98:	df 91       	pop	r29
     c9a:	cf 91       	pop	r28
     c9c:	1f 91       	pop	r17
     c9e:	0f 91       	pop	r16
     ca0:	08 95       	ret

00000ca2 <FIFO_init>:

void FIFO_init( void )
{
	//Reset Buffer 0
	FIFO_WRST_0_CLR;
     ca2:	5f 98       	cbi	0x0b, 7	; 11
	FIFO_RCLK_0_CLR;
     ca4:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nOE_0_CLR;
     ca6:	46 98       	cbi	0x08, 6	; 8
	FIFO_nRRST_0_SET;
     ca8:	5d 9a       	sbi	0x0b, 5	; 11
	FIFO_WEN_0_CLR;
     caa:	5e 98       	cbi	0x0b, 6	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     cac:	88 e2       	ldi	r24, 0x28	; 40
     cae:	8a 95       	dec	r24
     cb0:	f1 f7       	brne	.-4      	; 0xcae <FIFO_init+0xc>
	_delay_us(10);
	FIFO_RCLK_0_SET;
     cb2:	5c 9a       	sbi	0x0b, 4	; 11
     cb4:	88 e2       	ldi	r24, 0x28	; 40
     cb6:	8a 95       	dec	r24
     cb8:	f1 f7       	brne	.-4      	; 0xcb6 <FIFO_init+0x14>
	_delay_us(10);
	FIFO_RCLK_0_CLR;
     cba:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_0_CLR;
     cbc:	5d 98       	cbi	0x0b, 5	; 11
     cbe:	88 e2       	ldi	r24, 0x28	; 40
     cc0:	8a 95       	dec	r24
     cc2:	f1 f7       	brne	.-4      	; 0xcc0 <FIFO_init+0x1e>
	_delay_us(10);
	FIFO_RCLK_0_SET;
     cc4:	5c 9a       	sbi	0x0b, 4	; 11
     cc6:	88 e2       	ldi	r24, 0x28	; 40
     cc8:	8a 95       	dec	r24
     cca:	f1 f7       	brne	.-4      	; 0xcc8 <FIFO_init+0x26>
	_delay_us(10);
	FIFO_RCLK_0_CLR;
     ccc:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_0_SET;
     cce:	5d 9a       	sbi	0x0b, 5	; 11
     cd0:	88 e2       	ldi	r24, 0x28	; 40
     cd2:	8a 95       	dec	r24
     cd4:	f1 f7       	brne	.-4      	; 0xcd2 <FIFO_init+0x30>
	_delay_us(10);
	FIFO_WRST_0_SET;
     cd6:	5f 9a       	sbi	0x0b, 7	; 11
	
	//Reset Buffer 1
	FIFO_WRST_1_CLR;
     cd8:	45 98       	cbi	0x08, 5	; 8
	FIFO_RCLK_1_CLR;
     cda:	42 98       	cbi	0x08, 2	; 8
	FIFO_nOE_1_CLR;
     cdc:	47 98       	cbi	0x08, 7	; 8
	FIFO_nRRST_1_SET;
     cde:	43 9a       	sbi	0x08, 3	; 8
	FIFO_WEN_1_CLR;
     ce0:	44 98       	cbi	0x08, 4	; 8
     ce2:	88 e2       	ldi	r24, 0x28	; 40
     ce4:	8a 95       	dec	r24
     ce6:	f1 f7       	brne	.-4      	; 0xce4 <FIFO_init+0x42>
	_delay_us(10);
	FIFO_RCLK_1_SET;
     ce8:	42 9a       	sbi	0x08, 2	; 8
     cea:	88 e2       	ldi	r24, 0x28	; 40
     cec:	8a 95       	dec	r24
     cee:	f1 f7       	brne	.-4      	; 0xcec <FIFO_init+0x4a>
	_delay_us(10);
	FIFO_RCLK_1_CLR;
     cf0:	42 98       	cbi	0x08, 2	; 8
	FIFO_nRRST_1_CLR;
     cf2:	43 98       	cbi	0x08, 3	; 8
     cf4:	88 e2       	ldi	r24, 0x28	; 40
     cf6:	8a 95       	dec	r24
     cf8:	f1 f7       	brne	.-4      	; 0xcf6 <FIFO_init+0x54>
	_delay_us(10);
	FIFO_RCLK_1_SET;
     cfa:	42 9a       	sbi	0x08, 2	; 8
     cfc:	88 e2       	ldi	r24, 0x28	; 40
     cfe:	8a 95       	dec	r24
     d00:	f1 f7       	brne	.-4      	; 0xcfe <FIFO_init+0x5c>
	_delay_us(10);
	FIFO_RCLK_1_CLR;
     d02:	42 98       	cbi	0x08, 2	; 8
	FIFO_nRRST_1_SET;
     d04:	43 9a       	sbi	0x08, 3	; 8
     d06:	88 e2       	ldi	r24, 0x28	; 40
     d08:	8a 95       	dec	r24
     d0a:	f1 f7       	brne	.-4      	; 0xd08 <FIFO_init+0x66>
	_delay_us(10);
	FIFO_WRST_1_SET;
     d0c:	45 9a       	sbi	0x08, 5	; 8

}
     d0e:	08 95       	ret

00000d10 <FIFO_TO_AVR>:
//Write one pixel in AVR
uint16_t FIFO_TO_AVR(uint8_t ID)
{
	uint16_t data = 0;
	
	DDRA = 0;
     d10:	11 b8       	out	0x01, r1	; 1
	if(ID == 1)
     d12:	81 30       	cpi	r24, 0x01	; 1
     d14:	61 f4       	brne	.+24     	; 0xd2e <FIFO_TO_AVR+0x1e>
	{
		FIFO_RCLK_1_SET;
     d16:	42 9a       	sbi	0x08, 2	; 8
		data = PINA;
     d18:	80 b1       	in	r24, 0x00	; 0
		FIFO_RCLK_1_CLR;
     d1a:	42 98       	cbi	0x08, 2	; 8
		data <<= 8;
     d1c:	38 2f       	mov	r19, r24
     d1e:	20 e0       	ldi	r18, 0x00	; 0
		FIFO_RCLK_1_SET;
     d20:	42 9a       	sbi	0x08, 2	; 8
		data |= PINA;
     d22:	80 b1       	in	r24, 0x00	; 0
     d24:	90 e0       	ldi	r25, 0x00	; 0
     d26:	82 2b       	or	r24, r18
     d28:	93 2b       	or	r25, r19
		FIFO_RCLK_1_CLR;
     d2a:	42 98       	cbi	0x08, 2	; 8
     d2c:	08 95       	ret
	}		
	else
	{	
		FIFO_RCLK_0_SET;
     d2e:	5c 9a       	sbi	0x0b, 4	; 11
		data = PINA;
     d30:	80 b1       	in	r24, 0x00	; 0
		FIFO_RCLK_0_CLR;
     d32:	5c 98       	cbi	0x0b, 4	; 11
		data <<= 8;
     d34:	38 2f       	mov	r19, r24
     d36:	20 e0       	ldi	r18, 0x00	; 0
		FIFO_RCLK_0_SET;
     d38:	5c 9a       	sbi	0x0b, 4	; 11
		data |= PINA;
     d3a:	80 b1       	in	r24, 0x00	; 0
     d3c:	90 e0       	ldi	r25, 0x00	; 0
     d3e:	82 2b       	or	r24, r18
     d40:	93 2b       	or	r25, r19
		FIFO_RCLK_0_CLR;
     d42:	5c 98       	cbi	0x0b, 4	; 11
	}		
	return(data);
}
     d44:	08 95       	ret

00000d46 <FIFO_Reset>:


//Resets both pointers
void FIFO_Reset(uint8_t CameraID)
{
	if(CameraID == 0)
     d46:	88 23       	and	r24, r24
     d48:	39 f4       	brne	.+14     	; 0xd58 <FIFO_Reset+0x12>
	{
		FIFO_WRST_0_CLR;
     d4a:	5f 98       	cbi	0x0b, 7	; 11
		FIFO_nRRST_0_CLR;
     d4c:	5d 98       	cbi	0x0b, 5	; 11
		FIFO_RCLK_0_SET;
     d4e:	5c 9a       	sbi	0x0b, 4	; 11
		FIFO_RCLK_0_CLR;
     d50:	5c 98       	cbi	0x0b, 4	; 11
		FIFO_nRRST_0_SET;
     d52:	5d 9a       	sbi	0x0b, 5	; 11
		FIFO_WRST_0_SET;
     d54:	5f 9a       	sbi	0x0b, 7	; 11
     d56:	08 95       	ret
	}
	else
	{
		FIFO_WRST_1_CLR;
     d58:	45 98       	cbi	0x08, 5	; 8
		FIFO_nRRST_1_CLR;
     d5a:	43 98       	cbi	0x08, 3	; 8
		FIFO_RCLK_1_SET;
     d5c:	42 9a       	sbi	0x08, 2	; 8
		FIFO_RCLK_1_CLR;
     d5e:	42 98       	cbi	0x08, 2	; 8
		FIFO_nRRST_1_SET;
     d60:	43 9a       	sbi	0x08, 3	; 8
		FIFO_WRST_1_SET;
     d62:	45 9a       	sbi	0x08, 5	; 8
     d64:	08 95       	ret

00000d66 <LoadImagesToBuffer>:
	}
	
}
void LoadImagesToBuffer()
{
	VSYNC_0_Count = 0;
     d66:	10 92 05 03 	sts	0x0305, r1
	VSYNC_1_Count = 0;
     d6a:	10 92 46 0b 	sts	0x0B46, r1
	FIFO_Reset(0);
     d6e:	80 e0       	ldi	r24, 0x00	; 0
     d70:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
	FIFO_Reset(1);
     d74:	81 e0       	ldi	r24, 0x01	; 1
     d76:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
	VSYNC_0_Count = 1;
     d7a:	81 e0       	ldi	r24, 0x01	; 1
     d7c:	80 93 05 03 	sts	0x0305, r24
	VSYNC_1_Count = 1;
     d80:	80 93 46 0b 	sts	0x0B46, r24
	
}
     d84:	08 95       	ret

00000d86 <GetImageIfAvailiable>:
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
{
     d86:	2f 92       	push	r2
     d88:	3f 92       	push	r3
     d8a:	4f 92       	push	r4
     d8c:	5f 92       	push	r5
     d8e:	6f 92       	push	r6
     d90:	7f 92       	push	r7
     d92:	8f 92       	push	r8
     d94:	9f 92       	push	r9
     d96:	af 92       	push	r10
     d98:	bf 92       	push	r11
     d9a:	cf 92       	push	r12
     d9c:	df 92       	push	r13
     d9e:	ff 92       	push	r15
     da0:	0f 93       	push	r16
     da2:	1f 93       	push	r17
     da4:	cf 93       	push	r28
     da6:	df 93       	push	r29
     da8:	00 d0       	rcall	.+0      	; 0xdaa <GetImageIfAvailiable+0x24>
     daa:	00 d0       	rcall	.+0      	; 0xdac <GetImageIfAvailiable+0x26>
     dac:	cd b7       	in	r28, 0x3d	; 61
     dae:	de b7       	in	r29, 0x3e	; 62
     db0:	3c 01       	movw	r6, r24
     db2:	f6 2e       	mov	r15, r22

	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
     db4:	66 23       	and	r22, r22
     db6:	31 f4       	brne	.+12     	; 0xdc4 <GetImageIfAvailiable+0x3e>
     db8:	80 91 05 03 	lds	r24, 0x0305
     dbc:	83 30       	cpi	r24, 0x03	; 3
     dbe:	69 f0       	breq	.+26     	; 0xdda <GetImageIfAvailiable+0x54>
		FIFO_nOE_1_SET;
		return 0;
	}
	else
	{
		return 2;
     dc0:	82 e0       	ldi	r24, 0x02	; 2
     dc2:	7f c0       	rjmp	.+254    	; 0xec2 <GetImageIfAvailiable+0x13c>
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
{

	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
     dc4:	81 e0       	ldi	r24, 0x01	; 1
     dc6:	68 17       	cp	r22, r24
     dc8:	09 f0       	breq	.+2      	; 0xdcc <GetImageIfAvailiable+0x46>
     dca:	7a c0       	rjmp	.+244    	; 0xec0 <GetImageIfAvailiable+0x13a>
		((CameraID == 1) && (VSYNC_1_Count == 3)) )
     dcc:	80 91 46 0b 	lds	r24, 0x0B46
     dd0:	83 30       	cpi	r24, 0x03	; 3
     dd2:	09 f4       	brne	.+2      	; 0xdd6 <GetImageIfAvailiable+0x50>
     dd4:	8c c0       	rjmp	.+280    	; 0xeee <GetImageIfAvailiable+0x168>
		FIFO_nOE_1_SET;
		return 0;
	}
	else
	{
		return 2;
     dd6:	82 e0       	ldi	r24, 0x02	; 2
     dd8:	74 c0       	rjmp	.+232    	; 0xec2 <GetImageIfAvailiable+0x13c>
	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
		((CameraID == 1) && (VSYNC_1_Count == 3)) )
	{
		
		//Write Bitmap Headers
		WriteBMPHeader(File);
     dda:	c3 01       	movw	r24, r6
     ddc:	0e 94 5d 00 	call	0xba	; 0xba <WriteBMPHeader>
		WriteDIBHeader(File);
     de0:	c3 01       	movw	r24, r6
     de2:	0e 94 80 00 	call	0x100	; 0x100 <WriteDIBHeader>
		if (CameraID == 0)
		{
			//Enable output of Camera 0
			FIFO_nOE_0_CLR;
     de6:	46 98       	cbi	0x08, 6	; 8
			//Reset Read Pointer
			FIFO_nRRST_0_CLR;
     de8:	5d 98       	cbi	0x0b, 5	; 11
			FIFO_RCLK_0_SET;
     dea:	5c 9a       	sbi	0x0b, 4	; 11
			FIFO_RCLK_0_CLR;
     dec:	5c 98       	cbi	0x0b, 4	; 11
			FIFO_nRRST_0_SET;
     dee:	5d 9a       	sbi	0x0b, 5	; 11
	VSYNC_0_Count = 1;
	VSYNC_1_Count = 1;
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
{
     df0:	0f 2e       	mov	r0, r31
     df2:	fa e8       	ldi	r31, 0x8A	; 138
     df4:	8f 2e       	mov	r8, r31
     df6:	f0 e0       	ldi	r31, 0x00	; 0
     df8:	9f 2e       	mov	r9, r31
     dfa:	f0 e0       	ldi	r31, 0x00	; 0
     dfc:	af 2e       	mov	r10, r31
     dfe:	f0 e0       	ldi	r31, 0x00	; 0
     e00:	bf 2e       	mov	r11, r31
     e02:	f0 2d       	mov	r31, r0
		uint32_t pointer;
		uint16_t Temp;
		uint32_t p;
		FRESULT fr;
		//for(j = HEIGHT; j>0; j--)
		for(j = 0; j < HEIGHT; j++)
     e04:	0f 2e       	mov	r0, r31
     e06:	f7 e4       	ldi	r31, 0x47	; 71
     e08:	4f 2e       	mov	r4, r31
     e0a:	f7 e0       	ldi	r31, 0x07	; 7
     e0c:	5f 2e       	mov	r5, r31
     e0e:	f0 2d       	mov	r31, r0
	FIFO_Reset(1);
	VSYNC_0_Count = 1;
	VSYNC_1_Count = 1;
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
     e10:	0f 2e       	mov	r0, r31
     e12:	f7 ec       	ldi	r31, 0xC7	; 199
     e14:	cf 2e       	mov	r12, r31
     e16:	f9 e0       	ldi	r31, 0x09	; 9
     e18:	df 2e       	mov	r13, r31
     e1a:	f0 2d       	mov	r31, r0
				Buff[pointer++] = (uint8_t)Temp >> 8;
				Buff[pointer++] = (uint8_t)Temp;
			}
			pointer = (uint32_t)j * (uint32_t)WIDTH * 2 + BMPHEADERSIZE + DIBHEADERSIZE;
			f_lseek(File, pointer);
			fr = f_write(File, Buff, WIDTH * 2, &p);
     e1c:	0f 2e       	mov	r0, r31
     e1e:	f6 e4       	ldi	r31, 0x46	; 70
     e20:	2f 2e       	mov	r2, r31
     e22:	f7 e0       	ldi	r31, 0x07	; 7
     e24:	3f 2e       	mov	r3, r31
     e26:	f0 2d       	mov	r31, r0
     e28:	3f c0       	rjmp	.+126    	; 0xea8 <GetImageIfAvailiable+0x122>
		for(j = 0; j < HEIGHT; j++)
		{
			pointer = 0;
			for(i = 0; i < WIDTH; i++)
			{
				Temp = FIFO_TO_AVR(CameraID);
     e2a:	8f 2d       	mov	r24, r15
     e2c:	0e 94 88 06 	call	0xd10	; 0xd10 <FIFO_TO_AVR>
	FIFO_Reset(1);
	VSYNC_0_Count = 1;
	VSYNC_1_Count = 1;
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
     e30:	f8 01       	movw	r30, r16
     e32:	31 97       	sbiw	r30, 0x01	; 1
			pointer = 0;
			for(i = 0; i < WIDTH; i++)
			{
				Temp = FIFO_TO_AVR(CameraID);
				//USART0_Senduint16(Temp);
				Buff[pointer++] = (uint8_t)Temp >> 8;
     e34:	10 82       	st	Z, r1
				Buff[pointer++] = (uint8_t)Temp;
     e36:	d8 01       	movw	r26, r16
     e38:	8c 93       	st	X, r24
     e3a:	0e 5f       	subi	r16, 0xFE	; 254
     e3c:	1f 4f       	sbci	r17, 0xFF	; 255
		FRESULT fr;
		//for(j = HEIGHT; j>0; j--)
		for(j = 0; j < HEIGHT; j++)
		{
			pointer = 0;
			for(i = 0; i < WIDTH; i++)
     e3e:	0c 15       	cp	r16, r12
     e40:	1d 05       	cpc	r17, r13
     e42:	99 f7       	brne	.-26     	; 0xe2a <GetImageIfAvailiable+0xa4>
				//USART0_Senduint16(Temp);
				Buff[pointer++] = (uint8_t)Temp >> 8;
				Buff[pointer++] = (uint8_t)Temp;
			}
			pointer = (uint32_t)j * (uint32_t)WIDTH * 2 + BMPHEADERSIZE + DIBHEADERSIZE;
			f_lseek(File, pointer);
     e44:	c3 01       	movw	r24, r6
     e46:	b5 01       	movw	r22, r10
     e48:	a4 01       	movw	r20, r8
     e4a:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <f_lseek>
			fr = f_write(File, Buff, WIDTH * 2, &p);
     e4e:	c3 01       	movw	r24, r6
     e50:	b1 01       	movw	r22, r2
     e52:	20 e8       	ldi	r18, 0x80	; 128
     e54:	32 e0       	ldi	r19, 0x02	; 2
     e56:	40 e0       	ldi	r20, 0x00	; 0
     e58:	50 e0       	ldi	r21, 0x00	; 0
     e5a:	8e 01       	movw	r16, r28
     e5c:	0f 5f       	subi	r16, 0xFF	; 255
     e5e:	1f 4f       	sbci	r17, 0xFF	; 255
     e60:	0e 94 16 1c 	call	0x382c	; 0x382c <f_write>
			if(fr != FR_OK)
     e64:	88 23       	and	r24, r24
     e66:	79 f0       	breq	.+30     	; 0xe86 <GetImageIfAvailiable+0x100>
			{
				printf("Write Fail.\n");
     e68:	8b e8       	ldi	r24, 0x8B	; 139
     e6a:	91 e0       	ldi	r25, 0x01	; 1
     e6c:	0e 94 2e 2a 	call	0x545c	; 0x545c <puts>
				VSYNC_0_Count = 0;
     e70:	10 92 05 03 	sts	0x0305, r1
				VSYNC_1_Count = 0;
     e74:	10 92 46 0b 	sts	0x0B46, r1
				FIFO_Reset(CameraID);
     e78:	8f 2d       	mov	r24, r15
     e7a:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
				FIFO_nOE_0_SET;
     e7e:	46 9a       	sbi	0x08, 6	; 8
				FIFO_nOE_1_SET;
     e80:	47 9a       	sbi	0x08, 7	; 8
				return 1;
     e82:	81 e0       	ldi	r24, 0x01	; 1
     e84:	1e c0       	rjmp	.+60     	; 0xec2 <GetImageIfAvailiable+0x13c>
     e86:	80 e8       	ldi	r24, 0x80	; 128
     e88:	92 e0       	ldi	r25, 0x02	; 2
     e8a:	a0 e0       	ldi	r26, 0x00	; 0
     e8c:	b0 e0       	ldi	r27, 0x00	; 0
     e8e:	88 0e       	add	r8, r24
     e90:	99 1e       	adc	r9, r25
     e92:	aa 1e       	adc	r10, r26
     e94:	bb 1e       	adc	r11, r27
		uint32_t pointer;
		uint16_t Temp;
		uint32_t p;
		FRESULT fr;
		//for(j = HEIGHT; j>0; j--)
		for(j = 0; j < HEIGHT; j++)
     e96:	9a e8       	ldi	r25, 0x8A	; 138
     e98:	89 16       	cp	r8, r25
     e9a:	98 e5       	ldi	r25, 0x58	; 88
     e9c:	99 06       	cpc	r9, r25
     e9e:	92 e0       	ldi	r25, 0x02	; 2
     ea0:	a9 06       	cpc	r10, r25
     ea2:	90 e0       	ldi	r25, 0x00	; 0
     ea4:	b9 06       	cpc	r11, r25
     ea6:	11 f0       	breq	.+4      	; 0xeac <GetImageIfAvailiable+0x126>
     ea8:	82 01       	movw	r16, r4
     eaa:	bf cf       	rjmp	.-130    	; 0xe2a <GetImageIfAvailiable+0xa4>
				FIFO_nOE_0_SET;
				FIFO_nOE_1_SET;
				return 1;
			}
		}
		FIFO_Reset(CameraID);
     eac:	8f 2d       	mov	r24, r15
     eae:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
		fr = f_close(File);
     eb2:	c3 01       	movw	r24, r6
     eb4:	0e 94 cf 1e 	call	0x3d9e	; 0x3d9e <f_close>
		FIFO_nOE_0_SET;
     eb8:	46 9a       	sbi	0x08, 6	; 8
		FIFO_nOE_1_SET;
     eba:	47 9a       	sbi	0x08, 7	; 8
		return 0;
     ebc:	80 e0       	ldi	r24, 0x00	; 0
     ebe:	01 c0       	rjmp	.+2      	; 0xec2 <GetImageIfAvailiable+0x13c>
	}
	else
	{
		return 2;
     ec0:	82 e0       	ldi	r24, 0x02	; 2
	}
}
     ec2:	0f 90       	pop	r0
     ec4:	0f 90       	pop	r0
     ec6:	0f 90       	pop	r0
     ec8:	0f 90       	pop	r0
     eca:	df 91       	pop	r29
     ecc:	cf 91       	pop	r28
     ece:	1f 91       	pop	r17
     ed0:	0f 91       	pop	r16
     ed2:	ff 90       	pop	r15
     ed4:	df 90       	pop	r13
     ed6:	cf 90       	pop	r12
     ed8:	bf 90       	pop	r11
     eda:	af 90       	pop	r10
     edc:	9f 90       	pop	r9
     ede:	8f 90       	pop	r8
     ee0:	7f 90       	pop	r7
     ee2:	6f 90       	pop	r6
     ee4:	5f 90       	pop	r5
     ee6:	4f 90       	pop	r4
     ee8:	3f 90       	pop	r3
     eea:	2f 90       	pop	r2
     eec:	08 95       	ret
	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
		((CameraID == 1) && (VSYNC_1_Count == 3)) )
	{
		
		//Write Bitmap Headers
		WriteBMPHeader(File);
     eee:	c3 01       	movw	r24, r6
     ef0:	0e 94 5d 00 	call	0xba	; 0xba <WriteBMPHeader>
		WriteDIBHeader(File);
     ef4:	c3 01       	movw	r24, r6
     ef6:	0e 94 80 00 	call	0x100	; 0x100 <WriteDIBHeader>
			FIFO_nRRST_0_SET;
		}		
		else 
		{
			//Enable output of Camera 0
			FIFO_nOE_1_CLR;
     efa:	47 98       	cbi	0x08, 7	; 8
			//Reset Read Pointer
			FIFO_nRRST_1_CLR;
     efc:	43 98       	cbi	0x08, 3	; 8
			FIFO_RCLK_1_SET;
     efe:	42 9a       	sbi	0x08, 2	; 8
			FIFO_RCLK_1_CLR;
     f00:	42 98       	cbi	0x08, 2	; 8
			FIFO_nRRST_1_SET;
     f02:	43 9a       	sbi	0x08, 3	; 8
     f04:	75 cf       	rjmp	.-278    	; 0xdf0 <GetImageIfAvailiable+0x6a>

00000f06 <SCCB_wrOV7670Reg>:
		return 2;
	}
}

unsigned char SCCB_wrOV7670Reg(unsigned char regID, unsigned char regDat)
{
     f06:	cf 93       	push	r28
     f08:	df 93       	push	r29
     f0a:	c8 2f       	mov	r28, r24
     f0c:	d6 2f       	mov	r29, r22
	startSCCB();
     f0e:	0e 94 d1 27 	call	0x4fa2	; 0x4fa2 <startSCCB>
	if(0==SCCBwriteByte(0x42))
     f12:	82 e4       	ldi	r24, 0x42	; 66
     f14:	0e 94 21 28 	call	0x5042	; 0x5042 <SCCBwriteByte>
     f18:	88 23       	and	r24, r24
     f1a:	21 f4       	brne	.+8      	; 0xf24 <SCCB_wrOV7670Reg+0x1e>
	{
		stopSCCB();
     f1c:	0e 94 ee 27 	call	0x4fdc	; 0x4fdc <stopSCCB>
		return(0);
     f20:	80 e0       	ldi	r24, 0x00	; 0
     f22:	21 c0       	rjmp	.+66     	; 0xf66 <SCCB_wrOV7670Reg+0x60>
     f24:	8b e2       	ldi	r24, 0x2B	; 43
     f26:	91 e0       	ldi	r25, 0x01	; 1
     f28:	01 97       	sbiw	r24, 0x01	; 1
     f2a:	f1 f7       	brne	.-4      	; 0xf28 <SCCB_wrOV7670Reg+0x22>
     f2c:	00 c0       	rjmp	.+0      	; 0xf2e <SCCB_wrOV7670Reg+0x28>
     f2e:	00 00       	nop
	}
	_delay_us(100);
	if(0==SCCBwriteByte(regID))
     f30:	8c 2f       	mov	r24, r28
     f32:	0e 94 21 28 	call	0x5042	; 0x5042 <SCCBwriteByte>
     f36:	88 23       	and	r24, r24
     f38:	21 f4       	brne	.+8      	; 0xf42 <SCCB_wrOV7670Reg+0x3c>
	{
		stopSCCB();
     f3a:	0e 94 ee 27 	call	0x4fdc	; 0x4fdc <stopSCCB>
		return(0);
     f3e:	80 e0       	ldi	r24, 0x00	; 0
     f40:	12 c0       	rjmp	.+36     	; 0xf66 <SCCB_wrOV7670Reg+0x60>
     f42:	8b e2       	ldi	r24, 0x2B	; 43
     f44:	91 e0       	ldi	r25, 0x01	; 1
     f46:	01 97       	sbiw	r24, 0x01	; 1
     f48:	f1 f7       	brne	.-4      	; 0xf46 <SCCB_wrOV7670Reg+0x40>
     f4a:	00 c0       	rjmp	.+0      	; 0xf4c <SCCB_wrOV7670Reg+0x46>
     f4c:	00 00       	nop
	}
	_delay_us(100);
	if(0==SCCBwriteByte(regDat))
     f4e:	8d 2f       	mov	r24, r29
     f50:	0e 94 21 28 	call	0x5042	; 0x5042 <SCCBwriteByte>
     f54:	88 23       	and	r24, r24
     f56:	21 f4       	brne	.+8      	; 0xf60 <SCCB_wrOV7670Reg+0x5a>
	{
		stopSCCB();
     f58:	0e 94 ee 27 	call	0x4fdc	; 0x4fdc <stopSCCB>
		return(0);
     f5c:	80 e0       	ldi	r24, 0x00	; 0
     f5e:	03 c0       	rjmp	.+6      	; 0xf66 <SCCB_wrOV7670Reg+0x60>
	}
	stopSCCB();
     f60:	0e 94 ee 27 	call	0x4fdc	; 0x4fdc <stopSCCB>
	
	return(1);
     f64:	81 e0       	ldi	r24, 0x01	; 1
}
     f66:	df 91       	pop	r29
     f68:	cf 91       	pop	r28
     f6a:	08 95       	ret

00000f6c <SCCB_rdOV7670Reg>:

//Read the OV7670 Registers

unsigned char SCCB_rdOV7670Reg(unsigned regID, unsigned char *regDat)
{
     f6c:	1f 93       	push	r17
     f6e:	cf 93       	push	r28
     f70:	df 93       	push	r29
     f72:	18 2f       	mov	r17, r24
     f74:	eb 01       	movw	r28, r22
	//Using write operate to set the Register Address
	startSCCB();
     f76:	0e 94 d1 27 	call	0x4fa2	; 0x4fa2 <startSCCB>
	if(0==SCCBwriteByte(0x42))
     f7a:	82 e4       	ldi	r24, 0x42	; 66
     f7c:	0e 94 21 28 	call	0x5042	; 0x5042 <SCCBwriteByte>
     f80:	88 23       	and	r24, r24
     f82:	21 f4       	brne	.+8      	; 0xf8c <SCCB_rdOV7670Reg+0x20>
	{
		stopSCCB();
     f84:	0e 94 ee 27 	call	0x4fdc	; 0x4fdc <stopSCCB>
		return(0);
     f88:	80 e0       	ldi	r24, 0x00	; 0
     f8a:	30 c0       	rjmp	.+96     	; 0xfec <SCCB_rdOV7670Reg+0x80>
     f8c:	8b e2       	ldi	r24, 0x2B	; 43
     f8e:	91 e0       	ldi	r25, 0x01	; 1
     f90:	01 97       	sbiw	r24, 0x01	; 1
     f92:	f1 f7       	brne	.-4      	; 0xf90 <SCCB_rdOV7670Reg+0x24>
     f94:	00 c0       	rjmp	.+0      	; 0xf96 <SCCB_rdOV7670Reg+0x2a>
     f96:	00 00       	nop
	}
	_delay_us(100);
	if(0==SCCBwriteByte(regID))
     f98:	81 2f       	mov	r24, r17
     f9a:	0e 94 21 28 	call	0x5042	; 0x5042 <SCCBwriteByte>
     f9e:	88 23       	and	r24, r24
     fa0:	21 f4       	brne	.+8      	; 0xfaa <SCCB_rdOV7670Reg+0x3e>
	{
		stopSCCB();
     fa2:	0e 94 ee 27 	call	0x4fdc	; 0x4fdc <stopSCCB>
		return(0);
     fa6:	80 e0       	ldi	r24, 0x00	; 0
     fa8:	21 c0       	rjmp	.+66     	; 0xfec <SCCB_rdOV7670Reg+0x80>
	}
	stopSCCB();
     faa:	0e 94 ee 27 	call	0x4fdc	; 0x4fdc <stopSCCB>
     fae:	8b e2       	ldi	r24, 0x2B	; 43
     fb0:	91 e0       	ldi	r25, 0x01	; 1
     fb2:	01 97       	sbiw	r24, 0x01	; 1
     fb4:	f1 f7       	brne	.-4      	; 0xfb2 <SCCB_rdOV7670Reg+0x46>
     fb6:	00 c0       	rjmp	.+0      	; 0xfb8 <SCCB_rdOV7670Reg+0x4c>
     fb8:	00 00       	nop
	
	_delay_us(100);
	
	//Begin to read
	startSCCB();
     fba:	0e 94 d1 27 	call	0x4fa2	; 0x4fa2 <startSCCB>
	if(0==SCCBwriteByte(0x43))
     fbe:	83 e4       	ldi	r24, 0x43	; 67
     fc0:	0e 94 21 28 	call	0x5042	; 0x5042 <SCCBwriteByte>
     fc4:	88 23       	and	r24, r24
     fc6:	21 f4       	brne	.+8      	; 0xfd0 <SCCB_rdOV7670Reg+0x64>
	{
		stopSCCB();
     fc8:	0e 94 ee 27 	call	0x4fdc	; 0x4fdc <stopSCCB>
		return(0);
     fcc:	80 e0       	ldi	r24, 0x00	; 0
     fce:	0e c0       	rjmp	.+28     	; 0xfec <SCCB_rdOV7670Reg+0x80>
     fd0:	8b e2       	ldi	r24, 0x2B	; 43
     fd2:	91 e0       	ldi	r25, 0x01	; 1
     fd4:	01 97       	sbiw	r24, 0x01	; 1
     fd6:	f1 f7       	brne	.-4      	; 0xfd4 <SCCB_rdOV7670Reg+0x68>
     fd8:	00 c0       	rjmp	.+0      	; 0xfda <SCCB_rdOV7670Reg+0x6e>
     fda:	00 00       	nop
	}
	_delay_us(100);
	*regDat=SCCBreadByte();
     fdc:	0e 94 6a 28 	call	0x50d4	; 0x50d4 <SCCBreadByte>
     fe0:	88 83       	st	Y, r24
	noAck();
     fe2:	0e 94 04 28 	call	0x5008	; 0x5008 <noAck>
	stopSCCB();
     fe6:	0e 94 ee 27 	call	0x4fdc	; 0x4fdc <stopSCCB>
	return(1);
     fea:	81 e0       	ldi	r24, 0x01	; 1
}
     fec:	df 91       	pop	r29
     fee:	cf 91       	pop	r28
     ff0:	1f 91       	pop	r17
     ff2:	08 95       	ret

00000ff4 <OV7670_SCCB_init>:



// Initial OV7670
unsigned char OV7670_SCCB_init(void)
{
     ff4:	0f 93       	push	r16
     ff6:	1f 93       	push	r17
     ff8:	cf 93       	push	r28
     ffa:	df 93       	push	r29
	unsigned char temp;
	
	unsigned int i=0;

	
	InitSCCB();
     ffc:	0e 94 ca 27 	call	0x4f94	; 0x4f94 <InitSCCB>

	temp=0x80;
	if(0==SCCB_wrOV7670Reg(0x12, temp)) //Reset SCCB
    1000:	82 e1       	ldi	r24, 0x12	; 18
    1002:	60 e8       	ldi	r22, 0x80	; 128
    1004:	0e 94 83 07 	call	0xf06	; 0xf06 <SCCB_wrOV7670Reg>
    1008:	88 23       	and	r24, r24
    100a:	c1 f0       	breq	.+48     	; 0x103c <OV7670_SCCB_init+0x48>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    100c:	8f e2       	ldi	r24, 0x2F	; 47
    100e:	95 e7       	ldi	r25, 0x75	; 117
    1010:	01 97       	sbiw	r24, 0x01	; 1
    1012:	f1 f7       	brne	.-4      	; 0x1010 <OV7670_SCCB_init+0x1c>
    1014:	00 c0       	rjmp	.+0      	; 0x1016 <OV7670_SCCB_init+0x22>
    1016:	00 00       	nop
    1018:	c8 e9       	ldi	r28, 0x98	; 152
    101a:	d1 e0       	ldi	r29, 0x01	; 1




// Initial OV7670
unsigned char OV7670_SCCB_init(void)
    101c:	06 ee       	ldi	r16, 0xE6	; 230
    101e:	12 e0       	ldi	r17, 0x02	; 2
    1020:	fe 01       	movw	r30, r28
    1022:	31 97       	sbiw	r30, 0x01	; 1
	}
	_delay_ms(10);

	for(i=0;i<SETTINGS_LENGTH;i++)
	{
		if( 0==SCCB_wrOV7670Reg(default_settings[i][0],default_settings[i][1] ))
    1024:	80 81       	ld	r24, Z
    1026:	68 81       	ld	r22, Y
    1028:	0e 94 83 07 	call	0xf06	; 0xf06 <SCCB_wrOV7670Reg>
    102c:	88 23       	and	r24, r24
    102e:	41 f0       	breq	.+16     	; 0x1040 <OV7670_SCCB_init+0x4c>
    1030:	22 96       	adiw	r28, 0x02	; 2
	{
		return 1 ;
	}
	_delay_ms(10);

	for(i=0;i<SETTINGS_LENGTH;i++)
    1032:	c0 17       	cp	r28, r16
    1034:	d1 07       	cpc	r29, r17
    1036:	a1 f7       	brne	.-24     	; 0x1020 <OV7670_SCCB_init+0x2c>
		{
			return 2;
		}
	}

	return 0; //ok
    1038:	80 e0       	ldi	r24, 0x00	; 0
    103a:	03 c0       	rjmp	.+6      	; 0x1042 <OV7670_SCCB_init+0x4e>
	InitSCCB();

	temp=0x80;
	if(0==SCCB_wrOV7670Reg(0x12, temp)) //Reset SCCB
	{
		return 1 ;
    103c:	81 e0       	ldi	r24, 0x01	; 1
    103e:	01 c0       	rjmp	.+2      	; 0x1042 <OV7670_SCCB_init+0x4e>

	for(i=0;i<SETTINGS_LENGTH;i++)
	{
		if( 0==SCCB_wrOV7670Reg(default_settings[i][0],default_settings[i][1] ))
		{
			return 2;
    1040:	82 e0       	ldi	r24, 0x02	; 2
	}

	return 0; //ok

	
    1042:	df 91       	pop	r29
    1044:	cf 91       	pop	r28
    1046:	1f 91       	pop	r17
    1048:	0f 91       	pop	r16
    104a:	08 95       	ret

0000104c <UI_LEDs>:
#define STATUS_CAM0Err		0x04
#define STATUS_CAM1Err		0x08
#define STATUS_EXIT_Good	0x40
#define STATUS_Exit_Bad		0x80
unsigned char UI_LEDs(uint8_t LED)
{
    104c:	cf 93       	push	r28
    104e:	df 93       	push	r29
    1050:	00 d0       	rcall	.+0      	; 0x1052 <UI_LEDs+0x6>
    1052:	00 d0       	rcall	.+0      	; 0x1054 <UI_LEDs+0x8>
    1054:	cd b7       	in	r28, 0x3d	; 61
    1056:	de b7       	in	r29, 0x3e	; 62
	unsigned char mesbuf[TWI_BUFFER_SIZE];
	mesbuf[0] = (0x15 << TWI_ADR_BITS) | (FALSE << TWI_READ_BIT);
    1058:	9a e2       	ldi	r25, 0x2A	; 42
    105a:	99 83       	std	Y+1, r25	; 0x01
	mesbuf[1] = 0x10;
    105c:	90 e1       	ldi	r25, 0x10	; 16
    105e:	9a 83       	std	Y+2, r25	; 0x02
	mesbuf[2] = LED;
    1060:	8b 83       	std	Y+3, r24	; 0x03
	TWI_Start_Transceiver_With_Data(mesbuf, 3);
    1062:	ce 01       	movw	r24, r28
    1064:	01 96       	adiw	r24, 0x01	; 1
    1066:	63 e0       	ldi	r22, 0x03	; 3
    1068:	0e 94 a2 28 	call	0x5144	; 0x5144 <TWI_Start_Transceiver_With_Data>
	while(TWI_Transceiver_Busy())	;
    106c:	0e 94 97 28 	call	0x512e	; 0x512e <TWI_Transceiver_Busy>
    1070:	88 23       	and	r24, r24
    1072:	e1 f7       	brne	.-8      	; 0x106c <UI_LEDs+0x20>
	return TWI_statusReg.lastTransOK;
    1074:	80 91 fe 02 	lds	r24, 0x02FE
}
    1078:	81 70       	andi	r24, 0x01	; 1
    107a:	0f 90       	pop	r0
    107c:	0f 90       	pop	r0
    107e:	0f 90       	pop	r0
    1080:	0f 90       	pop	r0
    1082:	df 91       	pop	r29
    1084:	cf 91       	pop	r28
    1086:	08 95       	ret

00001088 <UI_Buttons>:
unsigned char UI_Buttons()
{
    1088:	cf 93       	push	r28
    108a:	df 93       	push	r29
    108c:	00 d0       	rcall	.+0      	; 0x108e <UI_Buttons+0x6>
    108e:	00 d0       	rcall	.+0      	; 0x1090 <UI_Buttons+0x8>
    1090:	cd b7       	in	r28, 0x3d	; 61
    1092:	de b7       	in	r29, 0x3e	; 62
	unsigned char messageBuf[TWI_BUFFER_SIZE]; //Initialise a buffer
	messageBuf[0] = (0x15<<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
    1094:	8a e2       	ldi	r24, 0x2A	; 42
    1096:	89 83       	std	Y+1, r24	; 0x01
	messageBuf[1] = 0x20;             // The first byte is used for the command
    1098:	80 e2       	ldi	r24, 0x20	; 32
    109a:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
    109c:	ce 01       	movw	r24, r28
    109e:	01 96       	adiw	r24, 0x01	; 1
    10a0:	62 e0       	ldi	r22, 0x02	; 2
    10a2:	0e 94 a2 28 	call	0x5144	; 0x5144 <TWI_Start_Transceiver_With_Data>
	//_delay_us(500);
	// Request/collect the data from the Slave
	messageBuf[0] = (0x15<<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
    10a6:	8b e2       	ldi	r24, 0x2B	; 43
    10a8:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
    10aa:	ce 01       	movw	r24, r28
    10ac:	01 96       	adiw	r24, 0x01	; 1
    10ae:	62 e0       	ldi	r22, 0x02	; 2
    10b0:	0e 94 a2 28 	call	0x5144	; 0x5144 <TWI_Start_Transceiver_With_Data>
	
	// Get the received data from the transceiver buffer
	TWI_Get_Data_From_Transceiver( messageBuf, 2 );
    10b4:	ce 01       	movw	r24, r28
    10b6:	01 96       	adiw	r24, 0x01	; 1
    10b8:	62 e0       	ldi	r22, 0x02	; 2
    10ba:	0e 94 d8 28 	call	0x51b0	; 0x51b0 <TWI_Get_Data_From_Transceiver>
	return messageBuf[1];
}
    10be:	8a 81       	ldd	r24, Y+2	; 0x02
    10c0:	0f 90       	pop	r0
    10c2:	0f 90       	pop	r0
    10c4:	0f 90       	pop	r0
    10c6:	0f 90       	pop	r0
    10c8:	df 91       	pop	r29
    10ca:	cf 91       	pop	r28
    10cc:	08 95       	ret

000010ce <__vector_16>:
ISR(TIMER0_COMPA_vect)
{
    10ce:	1f 92       	push	r1
    10d0:	0f 92       	push	r0
    10d2:	0f b6       	in	r0, 0x3f	; 63
    10d4:	0f 92       	push	r0
    10d6:	11 24       	eor	r1, r1
    10d8:	2f 93       	push	r18
    10da:	3f 93       	push	r19
    10dc:	4f 93       	push	r20
    10de:	5f 93       	push	r21
    10e0:	6f 93       	push	r22
    10e2:	7f 93       	push	r23
    10e4:	8f 93       	push	r24
    10e6:	9f 93       	push	r25
    10e8:	af 93       	push	r26
    10ea:	bf 93       	push	r27
    10ec:	ef 93       	push	r30
    10ee:	ff 93       	push	r31
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
    10f0:	0e 94 65 05 	call	0xaca	; 0xaca <disk_timerproc>
// 	if(!TWI_statusReg.lastTransOK) //if the last TWI transmission failed, reset the protocol
// 		TWI_Start_Transceiver();
// 	if(!TWI_Transceiver_Busy())
// 		UI_LEDs(StatusReg);
}
    10f4:	ff 91       	pop	r31
    10f6:	ef 91       	pop	r30
    10f8:	bf 91       	pop	r27
    10fa:	af 91       	pop	r26
    10fc:	9f 91       	pop	r25
    10fe:	8f 91       	pop	r24
    1100:	7f 91       	pop	r23
    1102:	6f 91       	pop	r22
    1104:	5f 91       	pop	r21
    1106:	4f 91       	pop	r20
    1108:	3f 91       	pop	r19
    110a:	2f 91       	pop	r18
    110c:	0f 90       	pop	r0
    110e:	0f be       	out	0x3f, r0	; 63
    1110:	0f 90       	pop	r0
    1112:	1f 90       	pop	r1
    1114:	18 95       	reti

00001116 <main>:
int main(void)
{
	unsigned long int a = 0;
	uint8_t b = 0;
	FRESULT fr;
	TWI_Master_Initialise();
    1116:	0e 94 8d 28 	call	0x511a	; 0x511a <TWI_Master_Initialise>
	IO_Init();
    111a:	0e 94 a4 00 	call	0x148	; 0x148 <IO_Init>
	sei();
    111e:	78 94       	sei
	
	
	StatusReg = STATUS_OKAY;
    1120:	81 e0       	ldi	r24, 0x01	; 1
    1122:	80 93 8f 0d 	sts	0x0D8F, r24
	UI_LEDs(StatusReg);
    1126:	0e 94 26 08 	call	0x104c	; 0x104c <UI_LEDs>
    112a:	8f e2       	ldi	r24, 0x2F	; 47
    112c:	95 e7       	ldi	r25, 0x75	; 117
    112e:	01 97       	sbiw	r24, 0x01	; 1
    1130:	f1 f7       	brne	.-4      	; 0x112e <main+0x18>
    1132:	00 c0       	rjmp	.+0      	; 0x1134 <main+0x1e>
    1134:	00 00       	nop
	_delay_ms(10);
	UI_Buttons();
    1136:	0e 94 44 08 	call	0x1088	; 0x1088 <UI_Buttons>
    113a:	ff cf       	rjmp	.-2      	; 0x113a <main+0x24>

0000113c <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
    113c:	e6 2f       	mov	r30, r22
    113e:	f7 2f       	mov	r31, r23
    1140:	ba 01       	movw	r22, r20
    1142:	a9 01       	movw	r20, r18
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
    1144:	41 15       	cp	r20, r1
    1146:	51 05       	cpc	r21, r1
    1148:	61 05       	cpc	r22, r1
    114a:	71 05       	cpc	r23, r1
    114c:	59 f0       	breq	.+22     	; 0x1164 <mem_cpy+0x28>
    114e:	ae 2f       	mov	r26, r30
    1150:	bf 2f       	mov	r27, r31
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    1152:	e8 2f       	mov	r30, r24
    1154:	f9 2f       	mov	r31, r25
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
    1156:	8d 91       	ld	r24, X+
    1158:	81 93       	st	Z+, r24
    115a:	41 50       	subi	r20, 0x01	; 1
    115c:	50 40       	sbci	r21, 0x00	; 0
    115e:	60 40       	sbci	r22, 0x00	; 0
    1160:	70 40       	sbci	r23, 0x00	; 0
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
    1162:	c9 f7       	brne	.-14     	; 0x1156 <mem_cpy+0x1a>
    1164:	08 95       	ret

00001166 <mem_set>:
		*d++ = *s++;
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
    1166:	a6 2f       	mov	r26, r22
    1168:	ba 01       	movw	r22, r20
    116a:	a9 01       	movw	r20, r18
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    116c:	41 15       	cp	r20, r1
    116e:	51 05       	cpc	r21, r1
    1170:	61 05       	cpc	r22, r1
    1172:	71 05       	cpc	r23, r1
    1174:	41 f0       	breq	.+16     	; 0x1186 <mem_set+0x20>
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    1176:	e8 2f       	mov	r30, r24
    1178:	f9 2f       	mov	r31, r25

	while (cnt--)
		*d++ = (BYTE)val;
    117a:	a1 93       	st	Z+, r26
    117c:	41 50       	subi	r20, 0x01	; 1
    117e:	50 40       	sbci	r21, 0x00	; 0
    1180:	60 40       	sbci	r22, 0x00	; 0
    1182:	70 40       	sbci	r23, 0x00	; 0
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    1184:	d1 f7       	brne	.-12     	; 0x117a <mem_set+0x14>
    1186:	08 95       	ret

00001188 <ld_clust>:
static
DWORD ld_clust (
	FATFS *fs,	/* Pointer to the fs object */
	BYTE *dir	/* Pointer to the directory entry */
)
{
    1188:	0f 93       	push	r16
    118a:	1f 93       	push	r17
    118c:	dc 01       	movw	r26, r24
    118e:	fb 01       	movw	r30, r22
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
    1190:	93 8d       	ldd	r25, Z+27	; 0x1b
    1192:	80 e0       	ldi	r24, 0x00	; 0
    1194:	02 8d       	ldd	r16, Z+26	; 0x1a
    1196:	10 e0       	ldi	r17, 0x00	; 0
    1198:	08 2b       	or	r16, r24
    119a:	19 2b       	or	r17, r25
    119c:	20 e0       	ldi	r18, 0x00	; 0
    119e:	30 e0       	ldi	r19, 0x00	; 0
	if (fs->fs_type == FS_FAT32)
    11a0:	8c 91       	ld	r24, X
    11a2:	83 30       	cpi	r24, 0x03	; 3
    11a4:	79 f4       	brne	.+30     	; 0x11c4 <ld_clust+0x3c>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
    11a6:	55 89       	ldd	r21, Z+21	; 0x15
    11a8:	40 e0       	ldi	r20, 0x00	; 0
    11aa:	84 89       	ldd	r24, Z+20	; 0x14
    11ac:	90 e0       	ldi	r25, 0x00	; 0
    11ae:	84 2b       	or	r24, r20
    11b0:	95 2b       	or	r25, r21
    11b2:	a0 e0       	ldi	r26, 0x00	; 0
    11b4:	b0 e0       	ldi	r27, 0x00	; 0
    11b6:	dc 01       	movw	r26, r24
    11b8:	99 27       	eor	r25, r25
    11ba:	88 27       	eor	r24, r24
    11bc:	08 2b       	or	r16, r24
    11be:	19 2b       	or	r17, r25
    11c0:	2a 2b       	or	r18, r26
    11c2:	3b 2b       	or	r19, r27

	return cl;
}
    11c4:	60 2f       	mov	r22, r16
    11c6:	71 2f       	mov	r23, r17
    11c8:	82 2f       	mov	r24, r18
    11ca:	93 2f       	mov	r25, r19
    11cc:	1f 91       	pop	r17
    11ce:	0f 91       	pop	r16
    11d0:	08 95       	ret

000011d2 <st_clust>:
static
void st_clust (
	BYTE *dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
    11d2:	fc 01       	movw	r30, r24
	ST_WORD(dir+DIR_FstClusLO, cl);
    11d4:	42 8f       	std	Z+26, r20	; 0x1a
    11d6:	53 8f       	std	Z+27, r21	; 0x1b
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
    11d8:	ab 01       	movw	r20, r22
    11da:	66 27       	eor	r22, r22
    11dc:	77 27       	eor	r23, r23
    11de:	44 8b       	std	Z+20, r20	; 0x14
    11e0:	55 8b       	std	Z+21, r21	; 0x15
}
    11e2:	08 95       	ret

000011e4 <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to the file information to be filled */
)
{
    11e4:	ef 92       	push	r14
    11e6:	ff 92       	push	r15
    11e8:	0f 93       	push	r16
    11ea:	1f 93       	push	r17
    11ec:	cf 93       	push	r28
    11ee:	df 93       	push	r29
    11f0:	fc 01       	movw	r30, r24
    11f2:	7b 01       	movw	r14, r22
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
    11f4:	8b 01       	movw	r16, r22
    11f6:	07 5f       	subi	r16, 0xF7	; 247
    11f8:	1f 4f       	sbci	r17, 0xFF	; 255
	if (dj->sect) {
    11fa:	86 85       	ldd	r24, Z+14	; 0x0e
    11fc:	97 85       	ldd	r25, Z+15	; 0x0f
    11fe:	a0 89       	ldd	r26, Z+16	; 0x10
    1200:	b1 89       	ldd	r27, Z+17	; 0x11
    1202:	00 97       	sbiw	r24, 0x00	; 0
    1204:	a1 05       	cpc	r26, r1
    1206:	b1 05       	cpc	r27, r1
    1208:	09 f4       	brne	.+2      	; 0x120c <get_fileinfo+0x28>
    120a:	65 c0       	rjmp	.+202    	; 0x12d6 <get_fileinfo+0xf2>
		dir = dj->dir;
    120c:	c2 89       	ldd	r28, Z+18	; 0x12
    120e:	d3 89       	ldd	r29, Z+19	; 0x13
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
    1210:	28 81       	ld	r18, Y
			if (c == ' ') break;
    1212:	20 32       	cpi	r18, 0x20	; 32
    1214:	99 f0       	breq	.+38     	; 0x123c <get_fileinfo+0x58>
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
    1216:	de 01       	movw	r26, r28
    1218:	11 96       	adiw	r26, 0x01	; 1
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
    121a:	f8 01       	movw	r30, r16
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
    121c:	80 e0       	ldi	r24, 0x00	; 0
    121e:	90 e0       	ldi	r25, 0x00	; 0
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
    1220:	35 ee       	ldi	r19, 0xE5	; 229
    1222:	04 c0       	rjmp	.+8      	; 0x122c <get_fileinfo+0x48>
	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
    1224:	2d 91       	ld	r18, X+
    1226:	01 96       	adiw	r24, 0x01	; 1
			if (c == ' ') break;
    1228:	20 32       	cpi	r18, 0x20	; 32
    122a:	41 f0       	breq	.+16     	; 0x123c <get_fileinfo+0x58>
			if (c == NDDE) c = (TCHAR)DDE;
    122c:	25 30       	cpi	r18, 0x05	; 5
    122e:	09 f4       	brne	.+2      	; 0x1232 <get_fileinfo+0x4e>
    1230:	23 2f       	mov	r18, r19
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
    1232:	21 93       	st	Z+, r18
    1234:	8f 01       	movw	r16, r30

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
    1236:	87 30       	cpi	r24, 0x07	; 7
    1238:	91 05       	cpc	r25, r1
    123a:	a1 f7       	brne	.-24     	; 0x1224 <get_fileinfo+0x40>
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
    123c:	88 85       	ldd	r24, Y+8	; 0x08
    123e:	80 32       	cpi	r24, 0x20	; 32
    1240:	81 f0       	breq	.+32     	; 0x1262 <get_fileinfo+0x7e>
			*p++ = '.';
    1242:	8e e2       	ldi	r24, 0x2E	; 46
    1244:	f8 01       	movw	r30, r16
    1246:	80 83       	st	Z, r24
			for (i = 8; i < 11; i++) {
				c = dir[i];
    1248:	88 85       	ldd	r24, Y+8	; 0x08
				if (c == ' ') break;
    124a:	80 32       	cpi	r24, 0x20	; 32
    124c:	09 f0       	breq	.+2      	; 0x1250 <get_fileinfo+0x6c>
    124e:	4c c0       	rjmp	.+152    	; 0x12e8 <get_fileinfo+0x104>
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
    1250:	0f 5f       	subi	r16, 0xFF	; 255
    1252:	1f 4f       	sbci	r17, 0xFF	; 255
    1254:	06 c0       	rjmp	.+12     	; 0x1262 <get_fileinfo+0x7e>
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
    1256:	8c 01       	movw	r16, r24
    1258:	04 c0       	rjmp	.+8      	; 0x1262 <get_fileinfo+0x7e>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    125a:	f8 01       	movw	r30, r16
    125c:	23 83       	std	Z+3, r18	; 0x03
    125e:	0c 5f       	subi	r16, 0xFC	; 252
    1260:	1f 4f       	sbci	r17, 0xFF	; 255
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
    1262:	8b 85       	ldd	r24, Y+11	; 0x0b
    1264:	f7 01       	movw	r30, r14
    1266:	80 87       	std	Z+8, r24	; 0x08
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
    1268:	8f 8d       	ldd	r24, Y+31	; 0x1f
    126a:	90 e0       	ldi	r25, 0x00	; 0
    126c:	a0 e0       	ldi	r26, 0x00	; 0
    126e:	b0 e0       	ldi	r27, 0x00	; 0
    1270:	b8 2f       	mov	r27, r24
    1272:	aa 27       	eor	r26, r26
    1274:	99 27       	eor	r25, r25
    1276:	88 27       	eor	r24, r24
    1278:	4e 8d       	ldd	r20, Y+30	; 0x1e
    127a:	50 e0       	ldi	r21, 0x00	; 0
    127c:	60 e0       	ldi	r22, 0x00	; 0
    127e:	70 e0       	ldi	r23, 0x00	; 0
    1280:	ba 01       	movw	r22, r20
    1282:	55 27       	eor	r21, r21
    1284:	44 27       	eor	r20, r20
    1286:	48 2b       	or	r20, r24
    1288:	59 2b       	or	r21, r25
    128a:	6a 2b       	or	r22, r26
    128c:	7b 2b       	or	r23, r27
    128e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1290:	90 e0       	ldi	r25, 0x00	; 0
    1292:	a0 e0       	ldi	r26, 0x00	; 0
    1294:	b0 e0       	ldi	r27, 0x00	; 0
    1296:	48 2b       	or	r20, r24
    1298:	59 2b       	or	r21, r25
    129a:	6a 2b       	or	r22, r26
    129c:	7b 2b       	or	r23, r27
    129e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    12a0:	80 e0       	ldi	r24, 0x00	; 0
    12a2:	a0 e0       	ldi	r26, 0x00	; 0
    12a4:	b0 e0       	ldi	r27, 0x00	; 0
    12a6:	84 2b       	or	r24, r20
    12a8:	95 2b       	or	r25, r21
    12aa:	a6 2b       	or	r26, r22
    12ac:	b7 2b       	or	r27, r23
    12ae:	80 83       	st	Z, r24
    12b0:	91 83       	std	Z+1, r25	; 0x01
    12b2:	a2 83       	std	Z+2, r26	; 0x02
    12b4:	b3 83       	std	Z+3, r27	; 0x03
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
    12b6:	39 8d       	ldd	r19, Y+25	; 0x19
    12b8:	20 e0       	ldi	r18, 0x00	; 0
    12ba:	88 8d       	ldd	r24, Y+24	; 0x18
    12bc:	90 e0       	ldi	r25, 0x00	; 0
    12be:	82 2b       	or	r24, r18
    12c0:	93 2b       	or	r25, r19
    12c2:	95 83       	std	Z+5, r25	; 0x05
    12c4:	84 83       	std	Z+4, r24	; 0x04
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
    12c6:	9f 89       	ldd	r25, Y+23	; 0x17
    12c8:	80 e0       	ldi	r24, 0x00	; 0
    12ca:	2e 89       	ldd	r18, Y+22	; 0x16
    12cc:	30 e0       	ldi	r19, 0x00	; 0
    12ce:	82 2b       	or	r24, r18
    12d0:	93 2b       	or	r25, r19
    12d2:	97 83       	std	Z+7, r25	; 0x07
    12d4:	86 83       	std	Z+6, r24	; 0x06
	}
	*p = 0;		/* Terminate SFN str by a \0 */
    12d6:	f8 01       	movw	r30, r16
    12d8:	10 82       	st	Z, r1
			}
		}
		tp[i] = 0;	/* Terminate the LFN str by a \0 */
	}
#endif
}
    12da:	df 91       	pop	r29
    12dc:	cf 91       	pop	r28
    12de:	1f 91       	pop	r17
    12e0:	0f 91       	pop	r16
    12e2:	ff 90       	pop	r15
    12e4:	ef 90       	pop	r14
    12e6:	08 95       	ret
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    12e8:	f8 01       	movw	r30, r16
    12ea:	81 83       	std	Z+1, r24	; 0x01
    12ec:	c8 01       	movw	r24, r16
    12ee:	02 96       	adiw	r24, 0x02	; 2
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
    12f0:	29 85       	ldd	r18, Y+9	; 0x09
				if (c == ' ') break;
    12f2:	20 32       	cpi	r18, 0x20	; 32
    12f4:	09 f4       	brne	.+2      	; 0x12f8 <get_fileinfo+0x114>
    12f6:	af cf       	rjmp	.-162    	; 0x1256 <get_fileinfo+0x72>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    12f8:	22 83       	std	Z+2, r18	; 0x02
    12fa:	c8 01       	movw	r24, r16
    12fc:	03 96       	adiw	r24, 0x03	; 3
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
    12fe:	2a 85       	ldd	r18, Y+10	; 0x0a
				if (c == ' ') break;
    1300:	20 32       	cpi	r18, 0x20	; 32
    1302:	09 f0       	breq	.+2      	; 0x1306 <get_fileinfo+0x122>
    1304:	aa cf       	rjmp	.-172    	; 0x125a <get_fileinfo+0x76>
    1306:	a7 cf       	rjmp	.-178    	; 0x1256 <get_fileinfo+0x72>

00001308 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
    1308:	dc 01       	movw	r26, r24
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
    130a:	ed 91       	ld	r30, X+
    130c:	fc 91       	ld	r31, X
    130e:	11 97       	sbiw	r26, 0x01	; 1
    1310:	30 97       	sbiw	r30, 0x00	; 0
    1312:	99 f0       	breq	.+38     	; 0x133a <validate+0x32>
    1314:	80 81       	ld	r24, Z
    1316:	88 23       	and	r24, r24
    1318:	91 f0       	breq	.+36     	; 0x133e <validate+0x36>
    131a:	26 81       	ldd	r18, Z+6	; 0x06
    131c:	37 81       	ldd	r19, Z+7	; 0x07
    131e:	12 96       	adiw	r26, 0x02	; 2
    1320:	8d 91       	ld	r24, X+
    1322:	9c 91       	ld	r25, X
    1324:	13 97       	sbiw	r26, 0x03	; 3
    1326:	28 17       	cp	r18, r24
    1328:	39 07       	cpc	r19, r25
    132a:	59 f4       	brne	.+22     	; 0x1342 <validate+0x3a>
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
    132c:	81 81       	ldd	r24, Z+1	; 0x01
    132e:	0e 94 92 02 	call	0x524	; 0x524 <disk_status>
    1332:	80 ff       	sbrs	r24, 0
    1334:	08 c0       	rjmp	.+16     	; 0x1346 <validate+0x3e>
		return FR_NOT_READY;
    1336:	83 e0       	ldi	r24, 0x03	; 3
    1338:	08 95       	ret
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
		return FR_INVALID_OBJECT;
    133a:	89 e0       	ldi	r24, 0x09	; 9
    133c:	08 95       	ret
    133e:	89 e0       	ldi	r24, 0x09	; 9
    1340:	08 95       	ret
    1342:	89 e0       	ldi	r24, 0x09	; 9
    1344:	08 95       	ret
	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
    1346:	80 e0       	ldi	r24, 0x00	; 0
}
    1348:	08 95       	ret

0000134a <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    134a:	0f 93       	push	r16
    134c:	cf 93       	push	r28
    134e:	df 93       	push	r29
    1350:	ec 01       	movw	r28, r24
    1352:	9a 01       	movw	r18, r20
    1354:	ab 01       	movw	r20, r22
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    1356:	bc 01       	movw	r22, r24
    1358:	6e 5c       	subi	r22, 0xCE	; 206
    135a:	7f 4f       	sbci	r23, 0xFF	; 255
    135c:	89 81       	ldd	r24, Y+1	; 0x01
    135e:	01 e0       	ldi	r16, 0x01	; 1
    1360:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    1364:	88 23       	and	r24, r24
    1366:	09 f0       	breq	.+2      	; 0x136a <check_fs+0x20>
    1368:	83 c0       	rjmp	.+262    	; 0x1470 <check_fs+0x126>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    136a:	fe 01       	movw	r30, r28
    136c:	ef 5c       	subi	r30, 0xCF	; 207
    136e:	fd 4f       	sbci	r31, 0xFD	; 253
    1370:	90 81       	ld	r25, Z
    1372:	80 e0       	ldi	r24, 0x00	; 0
    1374:	fe 01       	movw	r30, r28
    1376:	e0 5d       	subi	r30, 0xD0	; 208
    1378:	fd 4f       	sbci	r31, 0xFD	; 253
    137a:	20 81       	ld	r18, Z
    137c:	30 e0       	ldi	r19, 0x00	; 0
    137e:	82 2b       	or	r24, r18
    1380:	93 2b       	or	r25, r19
    1382:	2a ea       	ldi	r18, 0xAA	; 170
    1384:	85 35       	cpi	r24, 0x55	; 85
    1386:	92 07       	cpc	r25, r18
    1388:	09 f0       	breq	.+2      	; 0x138c <check_fs+0x42>
    138a:	74 c0       	rjmp	.+232    	; 0x1474 <check_fs+0x12a>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    138c:	fe 01       	movw	r30, r28
    138e:	e5 59       	subi	r30, 0x95	; 149
    1390:	ff 4f       	sbci	r31, 0xFF	; 255
    1392:	80 81       	ld	r24, Z
    1394:	90 e0       	ldi	r25, 0x00	; 0
    1396:	a0 e0       	ldi	r26, 0x00	; 0
    1398:	b0 e0       	ldi	r27, 0x00	; 0
    139a:	b8 2f       	mov	r27, r24
    139c:	aa 27       	eor	r26, r26
    139e:	99 27       	eor	r25, r25
    13a0:	88 27       	eor	r24, r24
    13a2:	fe 01       	movw	r30, r28
    13a4:	e6 59       	subi	r30, 0x96	; 150
    13a6:	ff 4f       	sbci	r31, 0xFF	; 255
    13a8:	40 81       	ld	r20, Z
    13aa:	50 e0       	ldi	r21, 0x00	; 0
    13ac:	60 e0       	ldi	r22, 0x00	; 0
    13ae:	70 e0       	ldi	r23, 0x00	; 0
    13b0:	ba 01       	movw	r22, r20
    13b2:	55 27       	eor	r21, r21
    13b4:	44 27       	eor	r20, r20
    13b6:	48 2b       	or	r20, r24
    13b8:	59 2b       	or	r21, r25
    13ba:	6a 2b       	or	r22, r26
    13bc:	7b 2b       	or	r23, r27
    13be:	fe 01       	movw	r30, r28
    13c0:	e8 59       	subi	r30, 0x98	; 152
    13c2:	ff 4f       	sbci	r31, 0xFF	; 255
    13c4:	80 81       	ld	r24, Z
    13c6:	90 e0       	ldi	r25, 0x00	; 0
    13c8:	a0 e0       	ldi	r26, 0x00	; 0
    13ca:	b0 e0       	ldi	r27, 0x00	; 0
    13cc:	48 2b       	or	r20, r24
    13ce:	59 2b       	or	r21, r25
    13d0:	6a 2b       	or	r22, r26
    13d2:	7b 2b       	or	r23, r27
    13d4:	fe 01       	movw	r30, r28
    13d6:	e7 59       	subi	r30, 0x97	; 151
    13d8:	ff 4f       	sbci	r31, 0xFF	; 255
    13da:	90 81       	ld	r25, Z
    13dc:	80 e0       	ldi	r24, 0x00	; 0
    13de:	a0 e0       	ldi	r26, 0x00	; 0
    13e0:	b0 e0       	ldi	r27, 0x00	; 0
    13e2:	48 2b       	or	r20, r24
    13e4:	59 2b       	or	r21, r25
    13e6:	6a 2b       	or	r22, r26
    13e8:	7b 2b       	or	r23, r27
    13ea:	70 70       	andi	r23, 0x00	; 0
    13ec:	46 34       	cpi	r20, 0x46	; 70
    13ee:	81 e4       	ldi	r24, 0x41	; 65
    13f0:	58 07       	cpc	r21, r24
    13f2:	84 e5       	ldi	r24, 0x54	; 84
    13f4:	68 07       	cpc	r22, r24
    13f6:	80 e0       	ldi	r24, 0x00	; 0
    13f8:	78 07       	cpc	r23, r24
    13fa:	f1 f1       	breq	.+124    	; 0x1478 <check_fs+0x12e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    13fc:	fe 01       	movw	r30, r28
    13fe:	e9 57       	subi	r30, 0x79	; 121
    1400:	ff 4f       	sbci	r31, 0xFF	; 255
    1402:	80 81       	ld	r24, Z
    1404:	90 e0       	ldi	r25, 0x00	; 0
    1406:	a0 e0       	ldi	r26, 0x00	; 0
    1408:	b0 e0       	ldi	r27, 0x00	; 0
    140a:	b8 2f       	mov	r27, r24
    140c:	aa 27       	eor	r26, r26
    140e:	99 27       	eor	r25, r25
    1410:	88 27       	eor	r24, r24
    1412:	fe 01       	movw	r30, r28
    1414:	ea 57       	subi	r30, 0x7A	; 122
    1416:	ff 4f       	sbci	r31, 0xFF	; 255
    1418:	40 81       	ld	r20, Z
    141a:	50 e0       	ldi	r21, 0x00	; 0
    141c:	60 e0       	ldi	r22, 0x00	; 0
    141e:	70 e0       	ldi	r23, 0x00	; 0
    1420:	ba 01       	movw	r22, r20
    1422:	55 27       	eor	r21, r21
    1424:	44 27       	eor	r20, r20
    1426:	48 2b       	or	r20, r24
    1428:	59 2b       	or	r21, r25
    142a:	6a 2b       	or	r22, r26
    142c:	7b 2b       	or	r23, r27
    142e:	fe 01       	movw	r30, r28
    1430:	ec 57       	subi	r30, 0x7C	; 124
    1432:	ff 4f       	sbci	r31, 0xFF	; 255
    1434:	80 81       	ld	r24, Z
    1436:	90 e0       	ldi	r25, 0x00	; 0
    1438:	a0 e0       	ldi	r26, 0x00	; 0
    143a:	b0 e0       	ldi	r27, 0x00	; 0
    143c:	48 2b       	or	r20, r24
    143e:	59 2b       	or	r21, r25
    1440:	6a 2b       	or	r22, r26
    1442:	7b 2b       	or	r23, r27
    1444:	cb 57       	subi	r28, 0x7B	; 123
    1446:	df 4f       	sbci	r29, 0xFF	; 255
    1448:	98 81       	ld	r25, Y
    144a:	80 e0       	ldi	r24, 0x00	; 0
    144c:	a0 e0       	ldi	r26, 0x00	; 0
    144e:	b0 e0       	ldi	r27, 0x00	; 0
    1450:	48 2b       	or	r20, r24
    1452:	59 2b       	or	r21, r25
    1454:	6a 2b       	or	r22, r26
    1456:	7b 2b       	or	r23, r27
    1458:	70 70       	andi	r23, 0x00	; 0
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
    145a:	81 e0       	ldi	r24, 0x01	; 1
    145c:	46 34       	cpi	r20, 0x46	; 70
    145e:	91 e4       	ldi	r25, 0x41	; 65
    1460:	59 07       	cpc	r21, r25
    1462:	94 e5       	ldi	r25, 0x54	; 84
    1464:	69 07       	cpc	r22, r25
    1466:	90 e0       	ldi	r25, 0x00	; 0
    1468:	79 07       	cpc	r23, r25
    146a:	39 f4       	brne	.+14     	; 0x147a <check_fs+0x130>
    146c:	80 e0       	ldi	r24, 0x00	; 0
    146e:	05 c0       	rjmp	.+10     	; 0x147a <check_fs+0x130>
    1470:	83 e0       	ldi	r24, 0x03	; 3
    1472:	03 c0       	rjmp	.+6      	; 0x147a <check_fs+0x130>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
    1474:	82 e0       	ldi	r24, 0x02	; 2
    1476:	01 c0       	rjmp	.+2      	; 0x147a <check_fs+0x130>

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;
    1478:	80 e0       	ldi	r24, 0x00	; 0
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
    147a:	df 91       	pop	r29
    147c:	cf 91       	pop	r28
    147e:	0f 91       	pop	r16
    1480:	08 95       	ret

00001482 <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
    1482:	2f 92       	push	r2
    1484:	3f 92       	push	r3
    1486:	4f 92       	push	r4
    1488:	5f 92       	push	r5
    148a:	6f 92       	push	r6
    148c:	7f 92       	push	r7
    148e:	8f 92       	push	r8
    1490:	9f 92       	push	r9
    1492:	af 92       	push	r10
    1494:	bf 92       	push	r11
    1496:	cf 92       	push	r12
    1498:	df 92       	push	r13
    149a:	ef 92       	push	r14
    149c:	ff 92       	push	r15
    149e:	0f 93       	push	r16
    14a0:	1f 93       	push	r17
    14a2:	cf 93       	push	r28
    14a4:	df 93       	push	r29
    14a6:	cd b7       	in	r28, 0x3d	; 61
    14a8:	de b7       	in	r29, 0x3e	; 62
    14aa:	60 97       	sbiw	r28, 0x10	; 16
    14ac:	0f b6       	in	r0, 0x3f	; 63
    14ae:	f8 94       	cli
    14b0:	de bf       	out	0x3e, r29	; 62
    14b2:	0f be       	out	0x3f, r0	; 63
    14b4:	cd bf       	out	0x3d, r28	; 61
    14b6:	8b 01       	movw	r16, r22
    14b8:	d4 2e       	mov	r13, r20
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
    14ba:	dc 01       	movw	r26, r24
    14bc:	ed 91       	ld	r30, X+
    14be:	fc 91       	ld	r31, X
    14c0:	11 97       	sbiw	r26, 0x01	; 1
	FATFS *fs;


	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
    14c2:	40 81       	ld	r20, Z
    14c4:	50 e0       	ldi	r21, 0x00	; 0
    14c6:	40 53       	subi	r20, 0x30	; 48
    14c8:	50 40       	sbci	r21, 0x00	; 0
    14ca:	66 27       	eor	r22, r22
    14cc:	57 fd       	sbrc	r21, 7
    14ce:	60 95       	com	r22
    14d0:	76 2f       	mov	r23, r22
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    14d2:	4a 30       	cpi	r20, 0x0A	; 10
    14d4:	51 05       	cpc	r21, r1
    14d6:	61 05       	cpc	r22, r1
    14d8:	71 05       	cpc	r23, r1
    14da:	48 f4       	brcc	.+18     	; 0x14ee <chk_mounted+0x6c>
    14dc:	81 81       	ldd	r24, Z+1	; 0x01
    14de:	8a 33       	cpi	r24, 0x3A	; 58
    14e0:	31 f4       	brne	.+12     	; 0x14ee <chk_mounted+0x6c>
		p += 2; *path = p;				/* Return pointer to the path name */
    14e2:	cf 01       	movw	r24, r30
    14e4:	02 96       	adiw	r24, 0x02	; 2
    14e6:	11 96       	adiw	r26, 0x01	; 1
    14e8:	9c 93       	st	X, r25
    14ea:	8e 93       	st	-X, r24
    14ec:	05 c0       	rjmp	.+10     	; 0x14f8 <chk_mounted+0x76>
	} else {							/* No drive number is given */
#if _FS_RPATH
		vol = CurrVol;					/* Use current drive */
    14ee:	40 91 fb 02 	lds	r20, 0x02FB
    14f2:	50 e0       	ldi	r21, 0x00	; 0
    14f4:	60 e0       	ldi	r22, 0x00	; 0
    14f6:	70 e0       	ldi	r23, 0x00	; 0
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
    14f8:	f8 01       	movw	r30, r16
    14fa:	11 82       	std	Z+1, r1	; 0x01
    14fc:	10 82       	st	Z, r1
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    14fe:	41 15       	cp	r20, r1
    1500:	51 05       	cpc	r21, r1
    1502:	61 05       	cpc	r22, r1
    1504:	71 05       	cpc	r23, r1
    1506:	09 f0       	breq	.+2      	; 0x150a <chk_mounted+0x88>
    1508:	a3 c3       	rjmp	.+1862   	; 0x1c50 <chk_mounted+0x7ce>
		return FR_INVALID_DRIVE;
	fs = FatFs[vol];					/* Get corresponding file system object */
    150a:	e0 90 f9 02 	lds	r14, 0x02F9
    150e:	f0 90 fa 02 	lds	r15, 0x02FA
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    1512:	e1 14       	cp	r14, r1
    1514:	f1 04       	cpc	r15, r1
    1516:	09 f4       	brne	.+2      	; 0x151a <chk_mounted+0x98>
    1518:	9d c3       	rjmp	.+1850   	; 0x1c54 <chk_mounted+0x7d2>

	ENTER_FF(fs);						/* Lock file system */

	*rfs = fs;							/* Return pointer to the corresponding file system object */
    151a:	f1 82       	std	Z+1, r15	; 0x01
    151c:	e0 82       	st	Z, r14
	if (fs->fs_type) {					/* If the volume has been mounted */
    151e:	d7 01       	movw	r26, r14
    1520:	8c 91       	ld	r24, X
    1522:	88 23       	and	r24, r24
    1524:	69 f0       	breq	.+26     	; 0x1540 <chk_mounted+0xbe>
		stat = disk_status(fs->drv);
    1526:	11 96       	adiw	r26, 0x01	; 1
    1528:	8c 91       	ld	r24, X
    152a:	0e 94 92 02 	call	0x524	; 0x524 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    152e:	80 fd       	sbrc	r24, 0
    1530:	07 c0       	rjmp	.+14     	; 0x1540 <chk_mounted+0xbe>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
    1532:	dd 20       	and	r13, r13
    1534:	09 f4       	brne	.+2      	; 0x1538 <chk_mounted+0xb6>
    1536:	90 c3       	rjmp	.+1824   	; 0x1c58 <chk_mounted+0x7d6>
    1538:	82 fd       	sbrc	r24, 2
    153a:	90 c3       	rjmp	.+1824   	; 0x1c5c <chk_mounted+0x7da>
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
    153c:	80 e0       	ldi	r24, 0x00	; 0
    153e:	af c3       	rjmp	.+1886   	; 0x1c9e <chk_mounted+0x81c>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
    1540:	f7 01       	movw	r30, r14
    1542:	10 82       	st	Z, r1
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    1544:	11 82       	std	Z+1, r1	; 0x01
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
    1546:	80 e0       	ldi	r24, 0x00	; 0
    1548:	0e 94 c2 01 	call	0x384	; 0x384 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    154c:	80 fd       	sbrc	r24, 0
    154e:	88 c3       	rjmp	.+1808   	; 0x1c60 <chk_mounted+0x7de>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    1550:	dd 20       	and	r13, r13
    1552:	11 f0       	breq	.+4      	; 0x1558 <chk_mounted+0xd6>
    1554:	82 fd       	sbrc	r24, 2
    1556:	86 c3       	rjmp	.+1804   	; 0x1c64 <chk_mounted+0x7e2>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    1558:	c7 01       	movw	r24, r14
    155a:	40 e0       	ldi	r20, 0x00	; 0
    155c:	50 e0       	ldi	r21, 0x00	; 0
    155e:	ba 01       	movw	r22, r20
    1560:	0e 94 a5 09 	call	0x134a	; 0x134a <check_fs>
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    1564:	81 30       	cpi	r24, 0x01	; 1
    1566:	e9 f5       	brne	.+122    	; 0x15e2 <chk_mounted+0x160>
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
    1568:	f7 01       	movw	r30, r14
    156a:	ec 50       	subi	r30, 0x0C	; 12
    156c:	fe 4f       	sbci	r31, 0xFE	; 254
    156e:	80 81       	ld	r24, Z
    1570:	88 23       	and	r24, r24
    1572:	09 f4       	brne	.+2      	; 0x1576 <chk_mounted+0xf4>
    1574:	79 c3       	rjmp	.+1778   	; 0x1c68 <chk_mounted+0x7e6>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    1576:	f7 01       	movw	r30, r14
    1578:	e5 50       	subi	r30, 0x05	; 5
    157a:	fe 4f       	sbci	r31, 0xFE	; 254
    157c:	80 81       	ld	r24, Z
    157e:	90 e0       	ldi	r25, 0x00	; 0
    1580:	a0 e0       	ldi	r26, 0x00	; 0
    1582:	b0 e0       	ldi	r27, 0x00	; 0
    1584:	b8 2f       	mov	r27, r24
    1586:	aa 27       	eor	r26, r26
    1588:	99 27       	eor	r25, r25
    158a:	88 27       	eor	r24, r24
    158c:	f7 01       	movw	r30, r14
    158e:	e6 50       	subi	r30, 0x06	; 6
    1590:	fe 4f       	sbci	r31, 0xFE	; 254
    1592:	40 81       	ld	r20, Z
    1594:	50 e0       	ldi	r21, 0x00	; 0
    1596:	60 e0       	ldi	r22, 0x00	; 0
    1598:	70 e0       	ldi	r23, 0x00	; 0
    159a:	ba 01       	movw	r22, r20
    159c:	55 27       	eor	r21, r21
    159e:	44 27       	eor	r20, r20
    15a0:	84 2b       	or	r24, r20
    15a2:	95 2b       	or	r25, r21
    15a4:	a6 2b       	or	r26, r22
    15a6:	b7 2b       	or	r27, r23
    15a8:	f7 01       	movw	r30, r14
    15aa:	e8 50       	subi	r30, 0x08	; 8
    15ac:	fe 4f       	sbci	r31, 0xFE	; 254
    15ae:	40 81       	ld	r20, Z
    15b0:	50 e0       	ldi	r21, 0x00	; 0
    15b2:	60 e0       	ldi	r22, 0x00	; 0
    15b4:	70 e0       	ldi	r23, 0x00	; 0
    15b6:	48 2b       	or	r20, r24
    15b8:	59 2b       	or	r21, r25
    15ba:	6a 2b       	or	r22, r26
    15bc:	7b 2b       	or	r23, r27
    15be:	f7 01       	movw	r30, r14
    15c0:	e7 50       	subi	r30, 0x07	; 7
    15c2:	fe 4f       	sbci	r31, 0xFE	; 254
    15c4:	90 81       	ld	r25, Z
    15c6:	80 e0       	ldi	r24, 0x00	; 0
    15c8:	4c 01       	movw	r8, r24
    15ca:	aa 24       	eor	r10, r10
    15cc:	bb 24       	eor	r11, r11
    15ce:	84 2a       	or	r8, r20
    15d0:	95 2a       	or	r9, r21
    15d2:	a6 2a       	or	r10, r22
    15d4:	b7 2a       	or	r11, r23
			fmt = check_fs(fs, bsect);		/* Check the partition */
    15d6:	c7 01       	movw	r24, r14
    15d8:	b5 01       	movw	r22, r10
    15da:	a4 01       	movw	r20, r8
    15dc:	0e 94 a5 09 	call	0x134a	; 0x134a <check_fs>
    15e0:	03 c0       	rjmp	.+6      	; 0x15e8 <chk_mounted+0x166>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    15e2:	88 24       	eor	r8, r8
    15e4:	99 24       	eor	r9, r9
    15e6:	54 01       	movw	r10, r8
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    15e8:	83 30       	cpi	r24, 0x03	; 3
    15ea:	09 f4       	brne	.+2      	; 0x15ee <chk_mounted+0x16c>
    15ec:	3f c3       	rjmp	.+1662   	; 0x1c6c <chk_mounted+0x7ea>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    15ee:	88 23       	and	r24, r24
    15f0:	09 f0       	breq	.+2      	; 0x15f4 <chk_mounted+0x172>
    15f2:	3e c3       	rjmp	.+1660   	; 0x1c70 <chk_mounted+0x7ee>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    15f4:	d7 01       	movw	r26, r14
    15f6:	de 96       	adiw	r26, 0x3e	; 62
    15f8:	9c 91       	ld	r25, X
    15fa:	de 97       	sbiw	r26, 0x3e	; 62
    15fc:	80 e0       	ldi	r24, 0x00	; 0
    15fe:	dd 96       	adiw	r26, 0x3d	; 61
    1600:	2c 91       	ld	r18, X
    1602:	dd 97       	sbiw	r26, 0x3d	; 61
    1604:	30 e0       	ldi	r19, 0x00	; 0
    1606:	82 2b       	or	r24, r18
    1608:	93 2b       	or	r25, r19
    160a:	b2 e0       	ldi	r27, 0x02	; 2
    160c:	80 30       	cpi	r24, 0x00	; 0
    160e:	9b 07       	cpc	r25, r27
    1610:	09 f0       	breq	.+2      	; 0x1614 <chk_mounted+0x192>
    1612:	30 c3       	rjmp	.+1632   	; 0x1c74 <chk_mounted+0x7f2>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    1614:	f7 01       	movw	r30, r14
    1616:	e7 5b       	subi	r30, 0xB7	; 183
    1618:	ff 4f       	sbci	r31, 0xFF	; 255
    161a:	30 81       	ld	r19, Z
    161c:	20 e0       	ldi	r18, 0x00	; 0
    161e:	f7 01       	movw	r30, r14
    1620:	e8 5b       	subi	r30, 0xB8	; 184
    1622:	ff 4f       	sbci	r31, 0xFF	; 255
    1624:	80 81       	ld	r24, Z
    1626:	90 e0       	ldi	r25, 0x00	; 0
    1628:	82 2b       	or	r24, r18
    162a:	93 2b       	or	r25, r19
    162c:	2c 01       	movw	r4, r24
    162e:	66 24       	eor	r6, r6
    1630:	77 24       	eor	r7, r7
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    1632:	41 14       	cp	r4, r1
    1634:	51 04       	cpc	r5, r1
    1636:	61 04       	cpc	r6, r1
    1638:	71 04       	cpc	r7, r1
    163a:	89 f5       	brne	.+98     	; 0x169e <chk_mounted+0x21c>
    163c:	f7 01       	movw	r30, r14
    163e:	e7 5a       	subi	r30, 0xA7	; 167
    1640:	ff 4f       	sbci	r31, 0xFF	; 255
    1642:	40 81       	ld	r20, Z
    1644:	50 e0       	ldi	r21, 0x00	; 0
    1646:	60 e0       	ldi	r22, 0x00	; 0
    1648:	70 e0       	ldi	r23, 0x00	; 0
    164a:	74 2f       	mov	r23, r20
    164c:	66 27       	eor	r22, r22
    164e:	55 27       	eor	r21, r21
    1650:	44 27       	eor	r20, r20
    1652:	f7 01       	movw	r30, r14
    1654:	e8 5a       	subi	r30, 0xA8	; 168
    1656:	ff 4f       	sbci	r31, 0xFF	; 255
    1658:	80 81       	ld	r24, Z
    165a:	90 e0       	ldi	r25, 0x00	; 0
    165c:	a0 e0       	ldi	r26, 0x00	; 0
    165e:	b0 e0       	ldi	r27, 0x00	; 0
    1660:	dc 01       	movw	r26, r24
    1662:	99 27       	eor	r25, r25
    1664:	88 27       	eor	r24, r24
    1666:	48 2b       	or	r20, r24
    1668:	59 2b       	or	r21, r25
    166a:	6a 2b       	or	r22, r26
    166c:	7b 2b       	or	r23, r27
    166e:	f7 01       	movw	r30, r14
    1670:	ea 5a       	subi	r30, 0xAA	; 170
    1672:	ff 4f       	sbci	r31, 0xFF	; 255
    1674:	80 81       	ld	r24, Z
    1676:	90 e0       	ldi	r25, 0x00	; 0
    1678:	a0 e0       	ldi	r26, 0x00	; 0
    167a:	b0 e0       	ldi	r27, 0x00	; 0
    167c:	48 2b       	or	r20, r24
    167e:	59 2b       	or	r21, r25
    1680:	6a 2b       	or	r22, r26
    1682:	7b 2b       	or	r23, r27
    1684:	f7 01       	movw	r30, r14
    1686:	e9 5a       	subi	r30, 0xA9	; 169
    1688:	ff 4f       	sbci	r31, 0xFF	; 255
    168a:	90 81       	ld	r25, Z
    168c:	80 e0       	ldi	r24, 0x00	; 0
    168e:	a0 e0       	ldi	r26, 0x00	; 0
    1690:	b0 e0       	ldi	r27, 0x00	; 0
    1692:	2a 01       	movw	r4, r20
    1694:	3b 01       	movw	r6, r22
    1696:	48 2a       	or	r4, r24
    1698:	59 2a       	or	r5, r25
    169a:	6a 2a       	or	r6, r26
    169c:	7b 2a       	or	r7, r27
	fs->fsize = fasize;
    169e:	f7 01       	movw	r30, r14
    16a0:	46 8e       	std	Z+30, r4	; 0x1e
    16a2:	57 8e       	std	Z+31, r5	; 0x1f
    16a4:	60 a2       	lds	r22, 0x90
    16a6:	71 a2       	lds	r23, 0x91

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    16a8:	ee 5b       	subi	r30, 0xBE	; 190
    16aa:	ff 4f       	sbci	r31, 0xFF	; 255
    16ac:	c0 80       	ld	r12, Z
    16ae:	d7 01       	movw	r26, r14
    16b0:	13 96       	adiw	r26, 0x03	; 3
    16b2:	cc 92       	st	X, r12
    16b4:	13 97       	sbiw	r26, 0x03	; 3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    16b6:	8c 2d       	mov	r24, r12
    16b8:	81 50       	subi	r24, 0x01	; 1
    16ba:	82 30       	cpi	r24, 0x02	; 2
    16bc:	08 f0       	brcs	.+2      	; 0x16c0 <chk_mounted+0x23e>
    16be:	dc c2       	rjmp	.+1464   	; 0x1c78 <chk_mounted+0x7f6>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    16c0:	df 96       	adiw	r26, 0x3f	; 63
    16c2:	dc 90       	ld	r13, X
    16c4:	df 97       	sbiw	r26, 0x3f	; 63
    16c6:	12 96       	adiw	r26, 0x02	; 2
    16c8:	dc 92       	st	X, r13
    16ca:	12 97       	sbiw	r26, 0x02	; 2
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    16cc:	dd 20       	and	r13, r13
    16ce:	09 f4       	brne	.+2      	; 0x16d2 <chk_mounted+0x250>
    16d0:	d5 c2       	rjmp	.+1450   	; 0x1c7c <chk_mounted+0x7fa>
    16d2:	8d 2d       	mov	r24, r13
    16d4:	90 e0       	ldi	r25, 0x00	; 0
    16d6:	9c 01       	movw	r18, r24
    16d8:	21 50       	subi	r18, 0x01	; 1
    16da:	30 40       	sbci	r19, 0x00	; 0
    16dc:	82 23       	and	r24, r18
    16de:	93 23       	and	r25, r19
    16e0:	00 97       	sbiw	r24, 0x00	; 0
    16e2:	09 f0       	breq	.+2      	; 0x16e6 <chk_mounted+0x264>
    16e4:	cd c2       	rjmp	.+1434   	; 0x1c80 <chk_mounted+0x7fe>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    16e6:	f7 01       	movw	r30, r14
    16e8:	ec 5b       	subi	r30, 0xBC	; 188
    16ea:	ff 4f       	sbci	r31, 0xFF	; 255
    16ec:	30 81       	ld	r19, Z
    16ee:	20 e0       	ldi	r18, 0x00	; 0
    16f0:	f7 01       	movw	r30, r14
    16f2:	ed 5b       	subi	r30, 0xBD	; 189
    16f4:	ff 4f       	sbci	r31, 0xFF	; 255
    16f6:	80 81       	ld	r24, Z
    16f8:	90 e0       	ldi	r25, 0x00	; 0
    16fa:	19 01       	movw	r2, r18
    16fc:	28 2a       	or	r2, r24
    16fe:	39 2a       	or	r3, r25
    1700:	f7 01       	movw	r30, r14
    1702:	31 86       	std	Z+9, r3	; 0x09
    1704:	20 86       	std	Z+8, r2	; 0x08
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    1706:	c1 01       	movw	r24, r2
    1708:	8f 70       	andi	r24, 0x0F	; 15
    170a:	90 70       	andi	r25, 0x00	; 0
    170c:	00 97       	sbiw	r24, 0x00	; 0
    170e:	09 f0       	breq	.+2      	; 0x1712 <chk_mounted+0x290>
    1710:	b9 c2       	rjmp	.+1394   	; 0x1c84 <chk_mounted+0x802>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    1712:	ea 5b       	subi	r30, 0xBA	; 186
    1714:	ff 4f       	sbci	r31, 0xFF	; 255
    1716:	30 81       	ld	r19, Z
    1718:	20 e0       	ldi	r18, 0x00	; 0
    171a:	f7 01       	movw	r30, r14
    171c:	eb 5b       	subi	r30, 0xBB	; 187
    171e:	ff 4f       	sbci	r31, 0xFF	; 255
    1720:	80 81       	ld	r24, Z
    1722:	90 e0       	ldi	r25, 0x00	; 0
    1724:	82 2b       	or	r24, r18
    1726:	93 2b       	or	r25, r19
    1728:	8c 01       	movw	r16, r24
    172a:	20 e0       	ldi	r18, 0x00	; 0
    172c:	30 e0       	ldi	r19, 0x00	; 0
    172e:	09 83       	std	Y+1, r16	; 0x01
    1730:	1a 83       	std	Y+2, r17	; 0x02
    1732:	2b 83       	std	Y+3, r18	; 0x03
    1734:	3c 83       	std	Y+4, r19	; 0x04
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    1736:	01 15       	cp	r16, r1
    1738:	11 05       	cpc	r17, r1
    173a:	21 05       	cpc	r18, r1
    173c:	31 05       	cpc	r19, r1
    173e:	a9 f5       	brne	.+106    	; 0x17aa <chk_mounted+0x328>
    1740:	f7 01       	movw	r30, r14
    1742:	eb 5a       	subi	r30, 0xAB	; 171
    1744:	ff 4f       	sbci	r31, 0xFF	; 255
    1746:	80 81       	ld	r24, Z
    1748:	90 e0       	ldi	r25, 0x00	; 0
    174a:	a0 e0       	ldi	r26, 0x00	; 0
    174c:	b0 e0       	ldi	r27, 0x00	; 0
    174e:	78 2f       	mov	r23, r24
    1750:	66 27       	eor	r22, r22
    1752:	55 27       	eor	r21, r21
    1754:	44 27       	eor	r20, r20
    1756:	f7 01       	movw	r30, r14
    1758:	ec 5a       	subi	r30, 0xAC	; 172
    175a:	ff 4f       	sbci	r31, 0xFF	; 255
    175c:	80 81       	ld	r24, Z
    175e:	90 e0       	ldi	r25, 0x00	; 0
    1760:	a0 e0       	ldi	r26, 0x00	; 0
    1762:	b0 e0       	ldi	r27, 0x00	; 0
    1764:	dc 01       	movw	r26, r24
    1766:	99 27       	eor	r25, r25
    1768:	88 27       	eor	r24, r24
    176a:	48 2b       	or	r20, r24
    176c:	59 2b       	or	r21, r25
    176e:	6a 2b       	or	r22, r26
    1770:	7b 2b       	or	r23, r27
    1772:	f7 01       	movw	r30, r14
    1774:	ee 5a       	subi	r30, 0xAE	; 174
    1776:	ff 4f       	sbci	r31, 0xFF	; 255
    1778:	80 81       	ld	r24, Z
    177a:	90 e0       	ldi	r25, 0x00	; 0
    177c:	a0 e0       	ldi	r26, 0x00	; 0
    177e:	b0 e0       	ldi	r27, 0x00	; 0
    1780:	48 2b       	or	r20, r24
    1782:	59 2b       	or	r21, r25
    1784:	6a 2b       	or	r22, r26
    1786:	7b 2b       	or	r23, r27
    1788:	f7 01       	movw	r30, r14
    178a:	ed 5a       	subi	r30, 0xAD	; 173
    178c:	ff 4f       	sbci	r31, 0xFF	; 255
    178e:	90 81       	ld	r25, Z
    1790:	80 e0       	ldi	r24, 0x00	; 0
    1792:	a0 e0       	ldi	r26, 0x00	; 0
    1794:	b0 e0       	ldi	r27, 0x00	; 0
    1796:	8a 01       	movw	r16, r20
    1798:	9b 01       	movw	r18, r22
    179a:	08 2b       	or	r16, r24
    179c:	19 2b       	or	r17, r25
    179e:	2a 2b       	or	r18, r26
    17a0:	3b 2b       	or	r19, r27
    17a2:	09 83       	std	Y+1, r16	; 0x01
    17a4:	1a 83       	std	Y+2, r17	; 0x02
    17a6:	2b 83       	std	Y+3, r18	; 0x03
    17a8:	3c 83       	std	Y+4, r19	; 0x04

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    17aa:	f7 01       	movw	r30, r14
    17ac:	ef 5b       	subi	r30, 0xBF	; 191
    17ae:	ff 4f       	sbci	r31, 0xFF	; 255
    17b0:	30 81       	ld	r19, Z
    17b2:	20 e0       	ldi	r18, 0x00	; 0
    17b4:	f7 01       	movw	r30, r14
    17b6:	e0 5c       	subi	r30, 0xC0	; 192
    17b8:	ff 4f       	sbci	r31, 0xFF	; 255
    17ba:	80 81       	ld	r24, Z
    17bc:	90 e0       	ldi	r25, 0x00	; 0
    17be:	89 01       	movw	r16, r18
    17c0:	08 2b       	or	r16, r24
    17c2:	19 2b       	or	r17, r25
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    17c4:	01 15       	cp	r16, r1
    17c6:	11 05       	cpc	r17, r1
    17c8:	09 f4       	brne	.+2      	; 0x17cc <chk_mounted+0x34a>
    17ca:	5e c2       	rjmp	.+1212   	; 0x1c88 <chk_mounted+0x806>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
    17cc:	2c 2d       	mov	r18, r12
    17ce:	30 e0       	ldi	r19, 0x00	; 0
    17d0:	40 e0       	ldi	r20, 0x00	; 0
    17d2:	50 e0       	ldi	r21, 0x00	; 0
    17d4:	c3 01       	movw	r24, r6
    17d6:	b2 01       	movw	r22, r4
    17d8:	0e 94 ed 29 	call	0x53da	; 0x53da <__mulsi3>
    17dc:	6d 87       	std	Y+13, r22	; 0x0d
    17de:	7e 87       	std	Y+14, r23	; 0x0e
    17e0:	8f 87       	std	Y+15, r24	; 0x0f
    17e2:	98 8b       	std	Y+16, r25	; 0x10

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    17e4:	98 01       	movw	r18, r16
    17e6:	40 e0       	ldi	r20, 0x00	; 0
    17e8:	50 e0       	ldi	r21, 0x00	; 0
    17ea:	29 87       	std	Y+9, r18	; 0x09
    17ec:	3a 87       	std	Y+10, r19	; 0x0a
    17ee:	4b 87       	std	Y+11, r20	; 0x0b
    17f0:	5c 87       	std	Y+12, r21	; 0x0c
    17f2:	c1 01       	movw	r24, r2
    17f4:	92 95       	swap	r25
    17f6:	82 95       	swap	r24
    17f8:	8f 70       	andi	r24, 0x0F	; 15
    17fa:	89 27       	eor	r24, r25
    17fc:	9f 70       	andi	r25, 0x0F	; 15
    17fe:	89 27       	eor	r24, r25
    1800:	a0 e0       	ldi	r26, 0x00	; 0
    1802:	b0 e0       	ldi	r27, 0x00	; 0
    1804:	82 0f       	add	r24, r18
    1806:	93 1f       	adc	r25, r19
    1808:	a4 1f       	adc	r26, r20
    180a:	b5 1f       	adc	r27, r21
    180c:	0d 85       	ldd	r16, Y+13	; 0x0d
    180e:	1e 85       	ldd	r17, Y+14	; 0x0e
    1810:	2f 85       	ldd	r18, Y+15	; 0x0f
    1812:	38 89       	ldd	r19, Y+16	; 0x10
    1814:	08 0f       	add	r16, r24
    1816:	19 1f       	adc	r17, r25
    1818:	2a 1f       	adc	r18, r26
    181a:	3b 1f       	adc	r19, r27
    181c:	0d 83       	std	Y+5, r16	; 0x05
    181e:	1e 83       	std	Y+6, r17	; 0x06
    1820:	2f 83       	std	Y+7, r18	; 0x07
    1822:	38 87       	std	Y+8, r19	; 0x08
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    1824:	89 81       	ldd	r24, Y+1	; 0x01
    1826:	9a 81       	ldd	r25, Y+2	; 0x02
    1828:	ab 81       	ldd	r26, Y+3	; 0x03
    182a:	bc 81       	ldd	r27, Y+4	; 0x04
    182c:	80 17       	cp	r24, r16
    182e:	91 07       	cpc	r25, r17
    1830:	a2 07       	cpc	r26, r18
    1832:	b3 07       	cpc	r27, r19
    1834:	08 f4       	brcc	.+2      	; 0x1838 <chk_mounted+0x3b6>
    1836:	2a c2       	rjmp	.+1108   	; 0x1c8c <chk_mounted+0x80a>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    1838:	bc 01       	movw	r22, r24
    183a:	cd 01       	movw	r24, r26
    183c:	60 1b       	sub	r22, r16
    183e:	71 0b       	sbc	r23, r17
    1840:	82 0b       	sbc	r24, r18
    1842:	93 0b       	sbc	r25, r19
    1844:	2d 2d       	mov	r18, r13
    1846:	30 e0       	ldi	r19, 0x00	; 0
    1848:	40 e0       	ldi	r20, 0x00	; 0
    184a:	50 e0       	ldi	r21, 0x00	; 0
    184c:	0e 94 0c 2a 	call	0x5418	; 0x5418 <__udivmodsi4>
    1850:	89 01       	movw	r16, r18
    1852:	9a 01       	movw	r18, r20
    1854:	d9 01       	movw	r26, r18
    1856:	c8 01       	movw	r24, r16
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    1858:	01 15       	cp	r16, r1
    185a:	11 05       	cpc	r17, r1
    185c:	21 05       	cpc	r18, r1
    185e:	31 05       	cpc	r19, r1
    1860:	09 f4       	brne	.+2      	; 0x1864 <chk_mounted+0x3e2>
    1862:	16 c2       	rjmp	.+1068   	; 0x1c90 <chk_mounted+0x80e>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    1864:	06 3f       	cpi	r16, 0xF6	; 246
    1866:	ef e0       	ldi	r30, 0x0F	; 15
    1868:	1e 07       	cpc	r17, r30
    186a:	e0 e0       	ldi	r30, 0x00	; 0
    186c:	2e 07       	cpc	r18, r30
    186e:	e0 e0       	ldi	r30, 0x00	; 0
    1870:	3e 07       	cpc	r19, r30
    1872:	18 f4       	brcc	.+6      	; 0x187a <chk_mounted+0x3f8>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
    1874:	dd 24       	eor	r13, r13
    1876:	d3 94       	inc	r13
    1878:	03 c0       	rjmp	.+6      	; 0x1880 <chk_mounted+0x3fe>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    187a:	dd 24       	eor	r13, r13
    187c:	68 94       	set
    187e:	d1 f8       	bld	r13, 1
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    1880:	86 3f       	cpi	r24, 0xF6	; 246
    1882:	ff ef       	ldi	r31, 0xFF	; 255
    1884:	9f 07       	cpc	r25, r31
    1886:	f0 e0       	ldi	r31, 0x00	; 0
    1888:	af 07       	cpc	r26, r31
    188a:	f0 e0       	ldi	r31, 0x00	; 0
    188c:	bf 07       	cpc	r27, r31
    188e:	08 f0       	brcs	.+2      	; 0x1892 <chk_mounted+0x410>
    1890:	1f c2       	rjmp	.+1086   	; 0x1cd0 <chk_mounted+0x84e>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    1892:	b9 01       	movw	r22, r18
    1894:	a8 01       	movw	r20, r16
    1896:	4e 5f       	subi	r20, 0xFE	; 254
    1898:	5f 4f       	sbci	r21, 0xFF	; 255
    189a:	6f 4f       	sbci	r22, 0xFF	; 255
    189c:	7f 4f       	sbci	r23, 0xFF	; 255
    189e:	d7 01       	movw	r26, r14
    18a0:	5a 96       	adiw	r26, 0x1a	; 26
    18a2:	4d 93       	st	X+, r20
    18a4:	5d 93       	st	X+, r21
    18a6:	6d 93       	st	X+, r22
    18a8:	7c 93       	st	X, r23
    18aa:	5d 97       	sbiw	r26, 0x1d	; 29
	fs->database = bsect + sysect;						/* Data start sector */
    18ac:	8d 81       	ldd	r24, Y+5	; 0x05
    18ae:	9e 81       	ldd	r25, Y+6	; 0x06
    18b0:	af 81       	ldd	r26, Y+7	; 0x07
    18b2:	b8 85       	ldd	r27, Y+8	; 0x08
    18b4:	88 0d       	add	r24, r8
    18b6:	99 1d       	adc	r25, r9
    18b8:	aa 1d       	adc	r26, r10
    18ba:	bb 1d       	adc	r27, r11
    18bc:	f7 01       	movw	r30, r14
    18be:	82 a7       	lds	r24, 0x72
    18c0:	93 a7       	lds	r25, 0x73
    18c2:	a4 a7       	lds	r26, 0x74
    18c4:	b5 a7       	lds	r27, 0x75
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    18c6:	89 85       	ldd	r24, Y+9	; 0x09
    18c8:	9a 85       	ldd	r25, Y+10	; 0x0a
    18ca:	ab 85       	ldd	r26, Y+11	; 0x0b
    18cc:	bc 85       	ldd	r27, Y+12	; 0x0c
    18ce:	88 0d       	add	r24, r8
    18d0:	99 1d       	adc	r25, r9
    18d2:	aa 1d       	adc	r26, r10
    18d4:	bb 1d       	adc	r27, r11
    18d6:	82 a3       	lds	r24, 0x52
    18d8:	93 a3       	lds	r25, 0x53
    18da:	a4 a3       	lds	r26, 0x54
    18dc:	b5 a3       	lds	r27, 0x55
	if (fmt == FS_FAT32) {
    18de:	f3 e0       	ldi	r31, 0x03	; 3
    18e0:	df 16       	cp	r13, r31
    18e2:	09 f0       	breq	.+2      	; 0x18e6 <chk_mounted+0x464>
    18e4:	41 c0       	rjmp	.+130    	; 0x1968 <chk_mounted+0x4e6>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    18e6:	21 14       	cp	r2, r1
    18e8:	31 04       	cpc	r3, r1
    18ea:	09 f0       	breq	.+2      	; 0x18ee <chk_mounted+0x46c>
    18ec:	d3 c1       	rjmp	.+934    	; 0x1c94 <chk_mounted+0x812>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    18ee:	f7 01       	movw	r30, r14
    18f0:	ef 59       	subi	r30, 0x9F	; 159
    18f2:	ff 4f       	sbci	r31, 0xFF	; 255
    18f4:	80 81       	ld	r24, Z
    18f6:	90 e0       	ldi	r25, 0x00	; 0
    18f8:	a0 e0       	ldi	r26, 0x00	; 0
    18fa:	b0 e0       	ldi	r27, 0x00	; 0
    18fc:	38 2f       	mov	r19, r24
    18fe:	22 27       	eor	r18, r18
    1900:	11 27       	eor	r17, r17
    1902:	00 27       	eor	r16, r16
    1904:	f7 01       	movw	r30, r14
    1906:	e0 5a       	subi	r30, 0xA0	; 160
    1908:	ff 4f       	sbci	r31, 0xFF	; 255
    190a:	80 81       	ld	r24, Z
    190c:	90 e0       	ldi	r25, 0x00	; 0
    190e:	a0 e0       	ldi	r26, 0x00	; 0
    1910:	b0 e0       	ldi	r27, 0x00	; 0
    1912:	dc 01       	movw	r26, r24
    1914:	99 27       	eor	r25, r25
    1916:	88 27       	eor	r24, r24
    1918:	08 2b       	or	r16, r24
    191a:	19 2b       	or	r17, r25
    191c:	2a 2b       	or	r18, r26
    191e:	3b 2b       	or	r19, r27
    1920:	f7 01       	movw	r30, r14
    1922:	e2 5a       	subi	r30, 0xA2	; 162
    1924:	ff 4f       	sbci	r31, 0xFF	; 255
    1926:	80 81       	ld	r24, Z
    1928:	90 e0       	ldi	r25, 0x00	; 0
    192a:	a0 e0       	ldi	r26, 0x00	; 0
    192c:	b0 e0       	ldi	r27, 0x00	; 0
    192e:	08 2b       	or	r16, r24
    1930:	19 2b       	or	r17, r25
    1932:	2a 2b       	or	r18, r26
    1934:	3b 2b       	or	r19, r27
    1936:	f7 01       	movw	r30, r14
    1938:	e1 5a       	subi	r30, 0xA1	; 161
    193a:	ff 4f       	sbci	r31, 0xFF	; 255
    193c:	90 81       	ld	r25, Z
    193e:	80 e0       	ldi	r24, 0x00	; 0
    1940:	a0 e0       	ldi	r26, 0x00	; 0
    1942:	b0 e0       	ldi	r27, 0x00	; 0
    1944:	80 2b       	or	r24, r16
    1946:	91 2b       	or	r25, r17
    1948:	a2 2b       	or	r26, r18
    194a:	b3 2b       	or	r27, r19
    194c:	f7 01       	movw	r30, r14
    194e:	86 a3       	lds	r24, 0x56
    1950:	97 a3       	lds	r25, 0x57
    1952:	a0 a7       	lds	r26, 0x70
    1954:	b1 a7       	lds	r27, 0x71
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    1956:	44 0f       	add	r20, r20
    1958:	55 1f       	adc	r21, r21
    195a:	66 1f       	adc	r22, r22
    195c:	77 1f       	adc	r23, r23
    195e:	44 0f       	add	r20, r20
    1960:	55 1f       	adc	r21, r21
    1962:	66 1f       	adc	r22, r22
    1964:	77 1f       	adc	r23, r23
    1966:	2f c0       	rjmp	.+94     	; 0x19c6 <chk_mounted+0x544>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    1968:	21 14       	cp	r2, r1
    196a:	31 04       	cpc	r3, r1
    196c:	09 f4       	brne	.+2      	; 0x1970 <chk_mounted+0x4ee>
    196e:	94 c1       	rjmp	.+808    	; 0x1c98 <chk_mounted+0x816>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    1970:	0d 85       	ldd	r16, Y+13	; 0x0d
    1972:	1e 85       	ldd	r17, Y+14	; 0x0e
    1974:	2f 85       	ldd	r18, Y+15	; 0x0f
    1976:	38 89       	ldd	r19, Y+16	; 0x10
    1978:	80 0f       	add	r24, r16
    197a:	91 1f       	adc	r25, r17
    197c:	a2 1f       	adc	r26, r18
    197e:	b3 1f       	adc	r27, r19
    1980:	f7 01       	movw	r30, r14
    1982:	86 a3       	lds	r24, 0x56
    1984:	97 a3       	lds	r25, 0x57
    1986:	a0 a7       	lds	r26, 0x70
    1988:	b1 a7       	lds	r27, 0x71
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    198a:	f2 e0       	ldi	r31, 0x02	; 2
    198c:	df 16       	cp	r13, r31
    198e:	29 f4       	brne	.+10     	; 0x199a <chk_mounted+0x518>
    1990:	44 0f       	add	r20, r20
    1992:	55 1f       	adc	r21, r21
    1994:	66 1f       	adc	r22, r22
    1996:	77 1f       	adc	r23, r23
    1998:	16 c0       	rjmp	.+44     	; 0x19c6 <chk_mounted+0x544>
    199a:	db 01       	movw	r26, r22
    199c:	ca 01       	movw	r24, r20
    199e:	88 0f       	add	r24, r24
    19a0:	99 1f       	adc	r25, r25
    19a2:	aa 1f       	adc	r26, r26
    19a4:	bb 1f       	adc	r27, r27
    19a6:	84 0f       	add	r24, r20
    19a8:	95 1f       	adc	r25, r21
    19aa:	a6 1f       	adc	r26, r22
    19ac:	b7 1f       	adc	r27, r23
    19ae:	b6 95       	lsr	r27
    19b0:	a7 95       	ror	r26
    19b2:	97 95       	ror	r25
    19b4:	87 95       	ror	r24
    19b6:	41 70       	andi	r20, 0x01	; 1
    19b8:	50 70       	andi	r21, 0x00	; 0
    19ba:	60 70       	andi	r22, 0x00	; 0
    19bc:	70 70       	andi	r23, 0x00	; 0
    19be:	48 0f       	add	r20, r24
    19c0:	59 1f       	adc	r21, r25
    19c2:	6a 1f       	adc	r22, r26
    19c4:	7b 1f       	adc	r23, r27
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    19c6:	db 01       	movw	r26, r22
    19c8:	ca 01       	movw	r24, r20
    19ca:	81 50       	subi	r24, 0x01	; 1
    19cc:	9e 4f       	sbci	r25, 0xFE	; 254
    19ce:	af 4f       	sbci	r26, 0xFF	; 255
    19d0:	bf 4f       	sbci	r27, 0xFF	; 255
    19d2:	07 2e       	mov	r0, r23
    19d4:	79 e0       	ldi	r23, 0x09	; 9
    19d6:	b6 95       	lsr	r27
    19d8:	a7 95       	ror	r26
    19da:	97 95       	ror	r25
    19dc:	87 95       	ror	r24
    19de:	7a 95       	dec	r23
    19e0:	d1 f7       	brne	.-12     	; 0x19d6 <chk_mounted+0x554>
    19e2:	70 2d       	mov	r23, r0
    19e4:	48 16       	cp	r4, r24
    19e6:	59 06       	cpc	r5, r25
    19e8:	6a 06       	cpc	r6, r26
    19ea:	7b 06       	cpc	r7, r27
    19ec:	08 f4       	brcc	.+2      	; 0x19f0 <chk_mounted+0x56e>
    19ee:	56 c1       	rjmp	.+684    	; 0x1c9c <chk_mounted+0x81a>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
    19f0:	8f ef       	ldi	r24, 0xFF	; 255
    19f2:	9f ef       	ldi	r25, 0xFF	; 255
    19f4:	dc 01       	movw	r26, r24
    19f6:	f7 01       	movw	r30, r14
    19f8:	86 87       	std	Z+14, r24	; 0x0e
    19fa:	97 87       	std	Z+15, r25	; 0x0f
    19fc:	a0 8b       	std	Z+16, r26	; 0x10
    19fe:	b1 8b       	std	Z+17, r27	; 0x11
	fs->last_clust = 0;
    1a00:	12 86       	std	Z+10, r1	; 0x0a
    1a02:	13 86       	std	Z+11, r1	; 0x0b
    1a04:	14 86       	std	Z+12, r1	; 0x0c
    1a06:	15 86       	std	Z+13, r1	; 0x0d

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
    1a08:	b3 e0       	ldi	r27, 0x03	; 3
    1a0a:	db 16       	cp	r13, r27
    1a0c:	09 f0       	breq	.+2      	; 0x1a10 <chk_mounted+0x58e>
    1a0e:	03 c1       	rjmp	.+518    	; 0x1c16 <chk_mounted+0x794>
	 	fs->fsi_flag = 0;
    1a10:	15 82       	std	Z+5, r1	; 0x05
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
    1a12:	ed 59       	subi	r30, 0x9D	; 157
    1a14:	ff 4f       	sbci	r31, 0xFF	; 255
    1a16:	30 81       	ld	r19, Z
    1a18:	20 e0       	ldi	r18, 0x00	; 0
    1a1a:	f7 01       	movw	r30, r14
    1a1c:	ee 59       	subi	r30, 0x9E	; 158
    1a1e:	ff 4f       	sbci	r31, 0xFF	; 255
    1a20:	80 81       	ld	r24, Z
    1a22:	90 e0       	ldi	r25, 0x00	; 0
    1a24:	82 2b       	or	r24, r18
    1a26:	93 2b       	or	r25, r19
    1a28:	a0 e0       	ldi	r26, 0x00	; 0
    1a2a:	b0 e0       	ldi	r27, 0x00	; 0
    1a2c:	a5 01       	movw	r20, r10
    1a2e:	94 01       	movw	r18, r8
    1a30:	28 0f       	add	r18, r24
    1a32:	39 1f       	adc	r19, r25
    1a34:	4a 1f       	adc	r20, r26
    1a36:	5b 1f       	adc	r21, r27
    1a38:	d7 01       	movw	r26, r14
    1a3a:	52 96       	adiw	r26, 0x12	; 18
    1a3c:	2d 93       	st	X+, r18
    1a3e:	3d 93       	st	X+, r19
    1a40:	4d 93       	st	X+, r20
    1a42:	5c 93       	st	X, r21
    1a44:	55 97       	sbiw	r26, 0x15	; 21
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    1a46:	b7 01       	movw	r22, r14
    1a48:	6e 5c       	subi	r22, 0xCE	; 206
    1a4a:	7f 4f       	sbci	r23, 0xFF	; 255
    1a4c:	11 96       	adiw	r26, 0x01	; 1
    1a4e:	8c 91       	ld	r24, X
    1a50:	01 e0       	ldi	r16, 0x01	; 1
    1a52:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    1a56:	88 23       	and	r24, r24
    1a58:	09 f0       	breq	.+2      	; 0x1a5c <chk_mounted+0x5da>
    1a5a:	dd c0       	rjmp	.+442    	; 0x1c16 <chk_mounted+0x794>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
    1a5c:	f7 01       	movw	r30, r14
    1a5e:	ef 5c       	subi	r30, 0xCF	; 207
    1a60:	fd 4f       	sbci	r31, 0xFD	; 253
    1a62:	30 81       	ld	r19, Z
    1a64:	20 e0       	ldi	r18, 0x00	; 0
    1a66:	f7 01       	movw	r30, r14
    1a68:	e0 5d       	subi	r30, 0xD0	; 208
    1a6a:	fd 4f       	sbci	r31, 0xFD	; 253
    1a6c:	80 81       	ld	r24, Z
    1a6e:	90 e0       	ldi	r25, 0x00	; 0
    1a70:	82 2b       	or	r24, r18
    1a72:	93 2b       	or	r25, r19

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    1a74:	ba ea       	ldi	r27, 0xAA	; 170
    1a76:	85 35       	cpi	r24, 0x55	; 85
    1a78:	9b 07       	cpc	r25, r27
    1a7a:	09 f0       	breq	.+2      	; 0x1a7e <chk_mounted+0x5fc>
    1a7c:	cc c0       	rjmp	.+408    	; 0x1c16 <chk_mounted+0x794>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
    1a7e:	f7 01       	movw	r30, r14
    1a80:	45 a9       	sts	0x45, r20
    1a82:	50 e0       	ldi	r21, 0x00	; 0
    1a84:	60 e0       	ldi	r22, 0x00	; 0
    1a86:	70 e0       	ldi	r23, 0x00	; 0
    1a88:	74 2f       	mov	r23, r20
    1a8a:	66 27       	eor	r22, r22
    1a8c:	55 27       	eor	r21, r21
    1a8e:	44 27       	eor	r20, r20
    1a90:	84 a9       	sts	0x44, r24
    1a92:	90 e0       	ldi	r25, 0x00	; 0
    1a94:	a0 e0       	ldi	r26, 0x00	; 0
    1a96:	b0 e0       	ldi	r27, 0x00	; 0
    1a98:	dc 01       	movw	r26, r24
    1a9a:	99 27       	eor	r25, r25
    1a9c:	88 27       	eor	r24, r24
    1a9e:	48 2b       	or	r20, r24
    1aa0:	59 2b       	or	r21, r25
    1aa2:	6a 2b       	or	r22, r26
    1aa4:	7b 2b       	or	r23, r27
    1aa6:	82 a9       	sts	0x42, r24
    1aa8:	90 e0       	ldi	r25, 0x00	; 0
    1aaa:	a0 e0       	ldi	r26, 0x00	; 0
    1aac:	b0 e0       	ldi	r27, 0x00	; 0
    1aae:	48 2b       	or	r20, r24
    1ab0:	59 2b       	or	r21, r25
    1ab2:	6a 2b       	or	r22, r26
    1ab4:	7b 2b       	or	r23, r27
    1ab6:	93 a9       	sts	0x43, r25
    1ab8:	80 e0       	ldi	r24, 0x00	; 0
    1aba:	a0 e0       	ldi	r26, 0x00	; 0
    1abc:	b0 e0       	ldi	r27, 0x00	; 0
    1abe:	84 2b       	or	r24, r20
    1ac0:	95 2b       	or	r25, r21
    1ac2:	a6 2b       	or	r26, r22
    1ac4:	b7 2b       	or	r27, r23
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
    1ac6:	82 35       	cpi	r24, 0x52	; 82
    1ac8:	f2 e5       	ldi	r31, 0x52	; 82
    1aca:	9f 07       	cpc	r25, r31
    1acc:	f1 e6       	ldi	r31, 0x61	; 97
    1ace:	af 07       	cpc	r26, r31
    1ad0:	f1 e4       	ldi	r31, 0x41	; 65
    1ad2:	bf 07       	cpc	r27, r31
    1ad4:	09 f0       	breq	.+2      	; 0x1ad8 <chk_mounted+0x656>
    1ad6:	9f c0       	rjmp	.+318    	; 0x1c16 <chk_mounted+0x794>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
    1ad8:	f7 01       	movw	r30, r14
    1ada:	e7 5e       	subi	r30, 0xE7	; 231
    1adc:	fd 4f       	sbci	r31, 0xFD	; 253
    1ade:	80 81       	ld	r24, Z
    1ae0:	90 e0       	ldi	r25, 0x00	; 0
    1ae2:	a0 e0       	ldi	r26, 0x00	; 0
    1ae4:	b0 e0       	ldi	r27, 0x00	; 0
    1ae6:	b8 2f       	mov	r27, r24
    1ae8:	aa 27       	eor	r26, r26
    1aea:	99 27       	eor	r25, r25
    1aec:	88 27       	eor	r24, r24
    1aee:	f7 01       	movw	r30, r14
    1af0:	e8 5e       	subi	r30, 0xE8	; 232
    1af2:	fd 4f       	sbci	r31, 0xFD	; 253
    1af4:	40 81       	ld	r20, Z
    1af6:	50 e0       	ldi	r21, 0x00	; 0
    1af8:	60 e0       	ldi	r22, 0x00	; 0
    1afa:	70 e0       	ldi	r23, 0x00	; 0
    1afc:	ba 01       	movw	r22, r20
    1afe:	55 27       	eor	r21, r21
    1b00:	44 27       	eor	r20, r20
    1b02:	84 2b       	or	r24, r20
    1b04:	95 2b       	or	r25, r21
    1b06:	a6 2b       	or	r26, r22
    1b08:	b7 2b       	or	r27, r23
    1b0a:	f7 01       	movw	r30, r14
    1b0c:	ea 5e       	subi	r30, 0xEA	; 234
    1b0e:	fd 4f       	sbci	r31, 0xFD	; 253
    1b10:	40 81       	ld	r20, Z
    1b12:	50 e0       	ldi	r21, 0x00	; 0
    1b14:	60 e0       	ldi	r22, 0x00	; 0
    1b16:	70 e0       	ldi	r23, 0x00	; 0
    1b18:	48 2b       	or	r20, r24
    1b1a:	59 2b       	or	r21, r25
    1b1c:	6a 2b       	or	r22, r26
    1b1e:	7b 2b       	or	r23, r27
    1b20:	f7 01       	movw	r30, r14
    1b22:	e9 5e       	subi	r30, 0xE9	; 233
    1b24:	fd 4f       	sbci	r31, 0xFD	; 253
    1b26:	90 81       	ld	r25, Z
    1b28:	80 e0       	ldi	r24, 0x00	; 0
    1b2a:	a0 e0       	ldi	r26, 0x00	; 0
    1b2c:	b0 e0       	ldi	r27, 0x00	; 0
    1b2e:	84 2b       	or	r24, r20
    1b30:	95 2b       	or	r25, r21
    1b32:	a6 2b       	or	r26, r22
    1b34:	b7 2b       	or	r27, r23
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
    1b36:	82 37       	cpi	r24, 0x72	; 114
    1b38:	02 e7       	ldi	r16, 0x72	; 114
    1b3a:	90 07       	cpc	r25, r16
    1b3c:	01 e4       	ldi	r16, 0x41	; 65
    1b3e:	a0 07       	cpc	r26, r16
    1b40:	01 e6       	ldi	r16, 0x61	; 97
    1b42:	b0 07       	cpc	r27, r16
    1b44:	09 f0       	breq	.+2      	; 0x1b48 <chk_mounted+0x6c6>
    1b46:	67 c0       	rjmp	.+206    	; 0x1c16 <chk_mounted+0x794>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
    1b48:	f7 01       	movw	r30, r14
    1b4a:	ef 5d       	subi	r30, 0xDF	; 223
    1b4c:	fd 4f       	sbci	r31, 0xFD	; 253
    1b4e:	80 81       	ld	r24, Z
    1b50:	90 e0       	ldi	r25, 0x00	; 0
    1b52:	a0 e0       	ldi	r26, 0x00	; 0
    1b54:	b0 e0       	ldi	r27, 0x00	; 0
    1b56:	b8 2f       	mov	r27, r24
    1b58:	aa 27       	eor	r26, r26
    1b5a:	99 27       	eor	r25, r25
    1b5c:	88 27       	eor	r24, r24
    1b5e:	f7 01       	movw	r30, r14
    1b60:	e0 5e       	subi	r30, 0xE0	; 224
    1b62:	fd 4f       	sbci	r31, 0xFD	; 253
    1b64:	40 81       	ld	r20, Z
    1b66:	50 e0       	ldi	r21, 0x00	; 0
    1b68:	60 e0       	ldi	r22, 0x00	; 0
    1b6a:	70 e0       	ldi	r23, 0x00	; 0
    1b6c:	ba 01       	movw	r22, r20
    1b6e:	55 27       	eor	r21, r21
    1b70:	44 27       	eor	r20, r20
    1b72:	84 2b       	or	r24, r20
    1b74:	95 2b       	or	r25, r21
    1b76:	a6 2b       	or	r26, r22
    1b78:	b7 2b       	or	r27, r23
    1b7a:	f7 01       	movw	r30, r14
    1b7c:	e2 5e       	subi	r30, 0xE2	; 226
    1b7e:	fd 4f       	sbci	r31, 0xFD	; 253
    1b80:	40 81       	ld	r20, Z
    1b82:	50 e0       	ldi	r21, 0x00	; 0
    1b84:	60 e0       	ldi	r22, 0x00	; 0
    1b86:	70 e0       	ldi	r23, 0x00	; 0
    1b88:	48 2b       	or	r20, r24
    1b8a:	59 2b       	or	r21, r25
    1b8c:	6a 2b       	or	r22, r26
    1b8e:	7b 2b       	or	r23, r27
    1b90:	f7 01       	movw	r30, r14
    1b92:	e1 5e       	subi	r30, 0xE1	; 225
    1b94:	fd 4f       	sbci	r31, 0xFD	; 253
    1b96:	90 81       	ld	r25, Z
    1b98:	80 e0       	ldi	r24, 0x00	; 0
    1b9a:	a0 e0       	ldi	r26, 0x00	; 0
    1b9c:	b0 e0       	ldi	r27, 0x00	; 0
    1b9e:	84 2b       	or	r24, r20
    1ba0:	95 2b       	or	r25, r21
    1ba2:	a6 2b       	or	r26, r22
    1ba4:	b7 2b       	or	r27, r23
    1ba6:	f7 01       	movw	r30, r14
    1ba8:	82 87       	std	Z+10, r24	; 0x0a
    1baa:	93 87       	std	Z+11, r25	; 0x0b
    1bac:	a4 87       	std	Z+12, r26	; 0x0c
    1bae:	b5 87       	std	Z+13, r27	; 0x0d
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
    1bb0:	e3 5e       	subi	r30, 0xE3	; 227
    1bb2:	fd 4f       	sbci	r31, 0xFD	; 253
    1bb4:	80 81       	ld	r24, Z
    1bb6:	90 e0       	ldi	r25, 0x00	; 0
    1bb8:	a0 e0       	ldi	r26, 0x00	; 0
    1bba:	b0 e0       	ldi	r27, 0x00	; 0
    1bbc:	b8 2f       	mov	r27, r24
    1bbe:	aa 27       	eor	r26, r26
    1bc0:	99 27       	eor	r25, r25
    1bc2:	88 27       	eor	r24, r24
    1bc4:	f7 01       	movw	r30, r14
    1bc6:	e4 5e       	subi	r30, 0xE4	; 228
    1bc8:	fd 4f       	sbci	r31, 0xFD	; 253
    1bca:	40 81       	ld	r20, Z
    1bcc:	50 e0       	ldi	r21, 0x00	; 0
    1bce:	60 e0       	ldi	r22, 0x00	; 0
    1bd0:	70 e0       	ldi	r23, 0x00	; 0
    1bd2:	ba 01       	movw	r22, r20
    1bd4:	55 27       	eor	r21, r21
    1bd6:	44 27       	eor	r20, r20
    1bd8:	84 2b       	or	r24, r20
    1bda:	95 2b       	or	r25, r21
    1bdc:	a6 2b       	or	r26, r22
    1bde:	b7 2b       	or	r27, r23
    1be0:	f7 01       	movw	r30, r14
    1be2:	e6 5e       	subi	r30, 0xE6	; 230
    1be4:	fd 4f       	sbci	r31, 0xFD	; 253
    1be6:	40 81       	ld	r20, Z
    1be8:	50 e0       	ldi	r21, 0x00	; 0
    1bea:	60 e0       	ldi	r22, 0x00	; 0
    1bec:	70 e0       	ldi	r23, 0x00	; 0
    1bee:	48 2b       	or	r20, r24
    1bf0:	59 2b       	or	r21, r25
    1bf2:	6a 2b       	or	r22, r26
    1bf4:	7b 2b       	or	r23, r27
    1bf6:	f7 01       	movw	r30, r14
    1bf8:	e5 5e       	subi	r30, 0xE5	; 229
    1bfa:	fd 4f       	sbci	r31, 0xFD	; 253
    1bfc:	90 81       	ld	r25, Z
    1bfe:	80 e0       	ldi	r24, 0x00	; 0
    1c00:	a0 e0       	ldi	r26, 0x00	; 0
    1c02:	b0 e0       	ldi	r27, 0x00	; 0
    1c04:	84 2b       	or	r24, r20
    1c06:	95 2b       	or	r25, r21
    1c08:	a6 2b       	or	r26, r22
    1c0a:	b7 2b       	or	r27, r23
    1c0c:	f7 01       	movw	r30, r14
    1c0e:	86 87       	std	Z+14, r24	; 0x0e
    1c10:	97 87       	std	Z+15, r25	; 0x0f
    1c12:	a0 8b       	std	Z+16, r26	; 0x10
    1c14:	b1 8b       	std	Z+17, r27	; 0x11
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
    1c16:	d7 01       	movw	r26, r14
    1c18:	dc 92       	st	X, r13
	fs->id = ++Fsid;		/* File system mount ID */
    1c1a:	80 91 fc 02 	lds	r24, 0x02FC
    1c1e:	90 91 fd 02 	lds	r25, 0x02FD
    1c22:	01 96       	adiw	r24, 0x01	; 1
    1c24:	90 93 fd 02 	sts	0x02FD, r25
    1c28:	80 93 fc 02 	sts	0x02FC, r24
    1c2c:	17 96       	adiw	r26, 0x07	; 7
    1c2e:	9c 93       	st	X, r25
    1c30:	8e 93       	st	-X, r24
    1c32:	16 97       	sbiw	r26, 0x06	; 6
	fs->winsect = 0;		/* Invalidate sector cache */
    1c34:	f7 01       	movw	r30, r14
    1c36:	16 a6       	lds	r17, 0xb6
    1c38:	17 a6       	lds	r17, 0xb7
    1c3a:	10 aa       	sts	0x90, r17
    1c3c:	11 aa       	sts	0x91, r17
	fs->wflag = 0;
    1c3e:	14 82       	std	Z+4, r1	; 0x04
#if _FS_RPATH
	fs->cdir = 0;			/* Current directory (root dir) */
    1c40:	56 96       	adiw	r26, 0x16	; 22
    1c42:	1d 92       	st	X+, r1
    1c44:	1d 92       	st	X+, r1
    1c46:	1d 92       	st	X+, r1
    1c48:	1c 92       	st	X, r1
    1c4a:	59 97       	sbiw	r26, 0x19	; 25
#endif
#if _FS_LOCK				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
    1c4c:	80 e0       	ldi	r24, 0x00	; 0
    1c4e:	27 c0       	rjmp	.+78     	; 0x1c9e <chk_mounted+0x81c>
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
    1c50:	8b e0       	ldi	r24, 0x0B	; 11
    1c52:	25 c0       	rjmp	.+74     	; 0x1c9e <chk_mounted+0x81c>
	fs = FatFs[vol];					/* Get corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    1c54:	8c e0       	ldi	r24, 0x0C	; 12
    1c56:	23 c0       	rjmp	.+70     	; 0x1c9e <chk_mounted+0x81c>
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
    1c58:	80 e0       	ldi	r24, 0x00	; 0
    1c5a:	21 c0       	rjmp	.+66     	; 0x1c9e <chk_mounted+0x81c>
	*rfs = fs;							/* Return pointer to the corresponding file system object */
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
    1c5c:	8a e0       	ldi	r24, 0x0A	; 10
    1c5e:	1f c0       	rjmp	.+62     	; 0x1c9e <chk_mounted+0x81c>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
    1c60:	83 e0       	ldi	r24, 0x03	; 3
    1c62:	1d c0       	rjmp	.+58     	; 0x1c9e <chk_mounted+0x81c>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
    1c64:	8a e0       	ldi	r24, 0x0A	; 10
    1c66:	1b c0       	rjmp	.+54     	; 0x1c9e <chk_mounted+0x81c>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    1c68:	8d e0       	ldi	r24, 0x0D	; 13
    1c6a:	19 c0       	rjmp	.+50     	; 0x1c9e <chk_mounted+0x81c>
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    1c6c:	81 e0       	ldi	r24, 0x01	; 1
    1c6e:	17 c0       	rjmp	.+46     	; 0x1c9e <chk_mounted+0x81c>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    1c70:	8d e0       	ldi	r24, 0x0D	; 13
    1c72:	15 c0       	rjmp	.+42     	; 0x1c9e <chk_mounted+0x81c>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;
    1c74:	8d e0       	ldi	r24, 0x0D	; 13
    1c76:	13 c0       	rjmp	.+38     	; 0x1c9e <chk_mounted+0x81c>
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    1c78:	8d e0       	ldi	r24, 0x0D	; 13
    1c7a:	11 c0       	rjmp	.+34     	; 0x1c9e <chk_mounted+0x81c>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    1c7c:	8d e0       	ldi	r24, 0x0D	; 13
    1c7e:	0f c0       	rjmp	.+30     	; 0x1c9e <chk_mounted+0x81c>
    1c80:	8d e0       	ldi	r24, 0x0D	; 13
    1c82:	0d c0       	rjmp	.+26     	; 0x1c9e <chk_mounted+0x81c>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    1c84:	8d e0       	ldi	r24, 0x0D	; 13
    1c86:	0b c0       	rjmp	.+22     	; 0x1c9e <chk_mounted+0x81c>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    1c88:	8d e0       	ldi	r24, 0x0D	; 13
    1c8a:	09 c0       	rjmp	.+18     	; 0x1c9e <chk_mounted+0x81c>

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    1c8c:	8d e0       	ldi	r24, 0x0D	; 13
    1c8e:	07 c0       	rjmp	.+14     	; 0x1c9e <chk_mounted+0x81c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    1c90:	8d e0       	ldi	r24, 0x0D	; 13
    1c92:	05 c0       	rjmp	.+10     	; 0x1c9e <chk_mounted+0x81c>
	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    1c94:	8d e0       	ldi	r24, 0x0D	; 13
    1c96:	03 c0       	rjmp	.+6      	; 0x1c9e <chk_mounted+0x81c>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    1c98:	8d e0       	ldi	r24, 0x0D	; 13
    1c9a:	01 c0       	rjmp	.+2      	; 0x1c9e <chk_mounted+0x81c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;
    1c9c:	8d e0       	ldi	r24, 0x0D	; 13
#if _FS_LOCK				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
}
    1c9e:	60 96       	adiw	r28, 0x10	; 16
    1ca0:	0f b6       	in	r0, 0x3f	; 63
    1ca2:	f8 94       	cli
    1ca4:	de bf       	out	0x3e, r29	; 62
    1ca6:	0f be       	out	0x3f, r0	; 63
    1ca8:	cd bf       	out	0x3d, r28	; 61
    1caa:	df 91       	pop	r29
    1cac:	cf 91       	pop	r28
    1cae:	1f 91       	pop	r17
    1cb0:	0f 91       	pop	r16
    1cb2:	ff 90       	pop	r15
    1cb4:	ef 90       	pop	r14
    1cb6:	df 90       	pop	r13
    1cb8:	cf 90       	pop	r12
    1cba:	bf 90       	pop	r11
    1cbc:	af 90       	pop	r10
    1cbe:	9f 90       	pop	r9
    1cc0:	8f 90       	pop	r8
    1cc2:	7f 90       	pop	r7
    1cc4:	6f 90       	pop	r6
    1cc6:	5f 90       	pop	r5
    1cc8:	4f 90       	pop	r4
    1cca:	3f 90       	pop	r3
    1ccc:	2f 90       	pop	r2
    1cce:	08 95       	ret
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    1cd0:	b9 01       	movw	r22, r18
    1cd2:	a8 01       	movw	r20, r16
    1cd4:	4e 5f       	subi	r20, 0xFE	; 254
    1cd6:	5f 4f       	sbci	r21, 0xFF	; 255
    1cd8:	6f 4f       	sbci	r22, 0xFF	; 255
    1cda:	7f 4f       	sbci	r23, 0xFF	; 255
    1cdc:	f7 01       	movw	r30, r14
    1cde:	42 8f       	std	Z+26, r20	; 0x1a
    1ce0:	53 8f       	std	Z+27, r21	; 0x1b
    1ce2:	64 8f       	std	Z+28, r22	; 0x1c
    1ce4:	75 8f       	std	Z+29, r23	; 0x1d
	fs->database = bsect + sysect;						/* Data start sector */
    1ce6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ce8:	9e 81       	ldd	r25, Y+6	; 0x06
    1cea:	af 81       	ldd	r26, Y+7	; 0x07
    1cec:	b8 85       	ldd	r27, Y+8	; 0x08
    1cee:	88 0d       	add	r24, r8
    1cf0:	99 1d       	adc	r25, r9
    1cf2:	aa 1d       	adc	r26, r10
    1cf4:	bb 1d       	adc	r27, r11
    1cf6:	82 a7       	lds	r24, 0x72
    1cf8:	93 a7       	lds	r25, 0x73
    1cfa:	a4 a7       	lds	r26, 0x74
    1cfc:	b5 a7       	lds	r27, 0x75
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    1cfe:	89 85       	ldd	r24, Y+9	; 0x09
    1d00:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d02:	ab 85       	ldd	r26, Y+11	; 0x0b
    1d04:	bc 85       	ldd	r27, Y+12	; 0x0c
    1d06:	88 0d       	add	r24, r8
    1d08:	99 1d       	adc	r25, r9
    1d0a:	aa 1d       	adc	r26, r10
    1d0c:	bb 1d       	adc	r27, r11
    1d0e:	82 a3       	lds	r24, 0x52
    1d10:	93 a3       	lds	r25, 0x53
    1d12:	a4 a3       	lds	r26, 0x54
    1d14:	b5 a3       	lds	r27, 0x55
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    1d16:	0f 2e       	mov	r0, r31
    1d18:	f3 e0       	ldi	r31, 0x03	; 3
    1d1a:	df 2e       	mov	r13, r31
    1d1c:	f0 2d       	mov	r31, r0
    1d1e:	e3 cd       	rjmp	.-1082   	; 0x18e6 <chk_mounted+0x464>

00001d20 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
    1d20:	4f 92       	push	r4
    1d22:	5f 92       	push	r5
    1d24:	6f 92       	push	r6
    1d26:	7f 92       	push	r7
    1d28:	8f 92       	push	r8
    1d2a:	9f 92       	push	r9
    1d2c:	af 92       	push	r10
    1d2e:	bf 92       	push	r11
    1d30:	cf 92       	push	r12
    1d32:	df 92       	push	r13
    1d34:	ef 92       	push	r14
    1d36:	ff 92       	push	r15
    1d38:	0f 93       	push	r16
    1d3a:	cf 93       	push	r28
    1d3c:	5c 01       	movw	r10, r24
    1d3e:	2a 01       	movw	r4, r20
    1d40:	3b 01       	movw	r6, r22
	DWORD wsect;


	wsect = fs->winsect;
    1d42:	fc 01       	movw	r30, r24
    1d44:	c6 a4       	lds	r28, 0xa6
    1d46:	d7 a4       	lds	r29, 0xa7
    1d48:	e0 a8       	sts	0x00, r30
    1d4a:	f1 a8       	sts	0x81, r31
	if (wsect != sector) {	/* Changed current window */
    1d4c:	c4 16       	cp	r12, r20
    1d4e:	d5 06       	cpc	r13, r21
    1d50:	e6 06       	cpc	r14, r22
    1d52:	f7 06       	cpc	r15, r23
    1d54:	09 f4       	brne	.+2      	; 0x1d58 <move_window+0x38>
    1d56:	54 c0       	rjmp	.+168    	; 0x1e00 <move_window+0xe0>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
    1d58:	84 81       	ldd	r24, Z+4	; 0x04
    1d5a:	88 23       	and	r24, r24
    1d5c:	d1 f1       	breq	.+116    	; 0x1dd2 <move_window+0xb2>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    1d5e:	0f 2e       	mov	r0, r31
    1d60:	f2 e3       	ldi	r31, 0x32	; 50
    1d62:	8f 2e       	mov	r8, r31
    1d64:	99 24       	eor	r9, r9
    1d66:	f0 2d       	mov	r31, r0
    1d68:	8a 0c       	add	r8, r10
    1d6a:	9b 1c       	adc	r9, r11
    1d6c:	81 81       	ldd	r24, Z+1	; 0x01
    1d6e:	b4 01       	movw	r22, r8
    1d70:	a7 01       	movw	r20, r14
    1d72:	96 01       	movw	r18, r12
    1d74:	01 e0       	ldi	r16, 0x01	; 1
    1d76:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    1d7a:	88 23       	and	r24, r24
    1d7c:	09 f0       	breq	.+2      	; 0x1d80 <move_window+0x60>
    1d7e:	42 c0       	rjmp	.+132    	; 0x1e04 <move_window+0xe4>
				return FR_DISK_ERR;
			fs->wflag = 0;
    1d80:	f5 01       	movw	r30, r10
    1d82:	14 82       	std	Z+4, r1	; 0x04
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    1d84:	46 8d       	ldd	r20, Z+30	; 0x1e
    1d86:	57 8d       	ldd	r21, Z+31	; 0x1f
    1d88:	60 a1       	lds	r22, 0x40
    1d8a:	71 a1       	lds	r23, 0x41
    1d8c:	82 a1       	lds	r24, 0x42
    1d8e:	93 a1       	lds	r25, 0x43
    1d90:	a4 a1       	lds	r26, 0x44
    1d92:	b5 a1       	lds	r27, 0x45
    1d94:	84 0f       	add	r24, r20
    1d96:	95 1f       	adc	r25, r21
    1d98:	a6 1f       	adc	r26, r22
    1d9a:	b7 1f       	adc	r27, r23
    1d9c:	c8 16       	cp	r12, r24
    1d9e:	d9 06       	cpc	r13, r25
    1da0:	ea 06       	cpc	r14, r26
    1da2:	fb 06       	cpc	r15, r27
    1da4:	b0 f4       	brcc	.+44     	; 0x1dd2 <move_window+0xb2>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    1da6:	c3 81       	ldd	r28, Z+3	; 0x03
    1da8:	c2 30       	cpi	r28, 0x02	; 2
    1daa:	98 f0       	brcs	.+38     	; 0x1dd2 <move_window+0xb2>
					wsect += fs->fsize;
    1dac:	f5 01       	movw	r30, r10
    1dae:	86 8d       	ldd	r24, Z+30	; 0x1e
    1db0:	97 8d       	ldd	r25, Z+31	; 0x1f
    1db2:	a0 a1       	lds	r26, 0x40
    1db4:	b1 a1       	lds	r27, 0x41
    1db6:	c8 0e       	add	r12, r24
    1db8:	d9 1e       	adc	r13, r25
    1dba:	ea 1e       	adc	r14, r26
    1dbc:	fb 1e       	adc	r15, r27
					disk_write(fs->drv, fs->win, wsect, 1);
    1dbe:	81 81       	ldd	r24, Z+1	; 0x01
    1dc0:	b4 01       	movw	r22, r8
    1dc2:	a7 01       	movw	r20, r14
    1dc4:	96 01       	movw	r18, r12
    1dc6:	01 e0       	ldi	r16, 0x01	; 1
    1dc8:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    1dcc:	c1 50       	subi	r28, 0x01	; 1
    1dce:	c1 30       	cpi	r28, 0x01	; 1
    1dd0:	69 f7       	brne	.-38     	; 0x1dac <move_window+0x8c>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
    1dd2:	41 14       	cp	r4, r1
    1dd4:	51 04       	cpc	r5, r1
    1dd6:	61 04       	cpc	r6, r1
    1dd8:	71 04       	cpc	r7, r1
    1dda:	b1 f0       	breq	.+44     	; 0x1e08 <move_window+0xe8>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    1ddc:	b5 01       	movw	r22, r10
    1dde:	6e 5c       	subi	r22, 0xCE	; 206
    1de0:	7f 4f       	sbci	r23, 0xFF	; 255
    1de2:	f5 01       	movw	r30, r10
    1de4:	81 81       	ldd	r24, Z+1	; 0x01
    1de6:	a3 01       	movw	r20, r6
    1de8:	92 01       	movw	r18, r4
    1dea:	01 e0       	ldi	r16, 0x01	; 1
    1dec:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    1df0:	88 23       	and	r24, r24
    1df2:	61 f4       	brne	.+24     	; 0x1e0c <move_window+0xec>
				return FR_DISK_ERR;
			fs->winsect = sector;
    1df4:	f5 01       	movw	r30, r10
    1df6:	46 a6       	lds	r20, 0xb6
    1df8:	57 a6       	lds	r21, 0xb7
    1dfa:	60 aa       	sts	0x90, r22
    1dfc:	71 aa       	sts	0x91, r23
    1dfe:	07 c0       	rjmp	.+14     	; 0x1e0e <move_window+0xee>
		}
	}

	return FR_OK;
    1e00:	80 e0       	ldi	r24, 0x00	; 0
    1e02:	05 c0       	rjmp	.+10     	; 0x1e0e <move_window+0xee>
	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
    1e04:	81 e0       	ldi	r24, 0x01	; 1
    1e06:	03 c0       	rjmp	.+6      	; 0x1e0e <move_window+0xee>
				return FR_DISK_ERR;
			fs->winsect = sector;
		}
	}

	return FR_OK;
    1e08:	80 e0       	ldi	r24, 0x00	; 0
    1e0a:	01 c0       	rjmp	.+2      	; 0x1e0e <move_window+0xee>
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
    1e0c:	81 e0       	ldi	r24, 0x01	; 1
			fs->winsect = sector;
		}
	}

	return FR_OK;
}
    1e0e:	cf 91       	pop	r28
    1e10:	0f 91       	pop	r16
    1e12:	ff 90       	pop	r15
    1e14:	ef 90       	pop	r14
    1e16:	df 90       	pop	r13
    1e18:	cf 90       	pop	r12
    1e1a:	bf 90       	pop	r11
    1e1c:	af 90       	pop	r10
    1e1e:	9f 90       	pop	r9
    1e20:	8f 90       	pop	r8
    1e22:	7f 90       	pop	r7
    1e24:	6f 90       	pop	r6
    1e26:	5f 90       	pop	r5
    1e28:	4f 90       	pop	r4
    1e2a:	08 95       	ret

00001e2c <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
    1e2c:	ef 92       	push	r14
    1e2e:	ff 92       	push	r15
    1e30:	0f 93       	push	r16
    1e32:	1f 93       	push	r17
    1e34:	cf 93       	push	r28
    1e36:	7c 01       	movw	r14, r24
	FRESULT res;


	res = move_window(fs, 0);
    1e38:	40 e0       	ldi	r20, 0x00	; 0
    1e3a:	50 e0       	ldi	r21, 0x00	; 0
    1e3c:	ba 01       	movw	r22, r20
    1e3e:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
    1e42:	c8 2f       	mov	r28, r24
	if (res == FR_OK) {
    1e44:	88 23       	and	r24, r24
    1e46:	09 f0       	breq	.+2      	; 0x1e4a <sync+0x1e>
    1e48:	78 c0       	rjmp	.+240    	; 0x1f3a <sync+0x10e>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    1e4a:	f7 01       	movw	r30, r14
    1e4c:	80 81       	ld	r24, Z
    1e4e:	83 30       	cpi	r24, 0x03	; 3
    1e50:	09 f0       	breq	.+2      	; 0x1e54 <sync+0x28>
    1e52:	6a c0       	rjmp	.+212    	; 0x1f28 <sync+0xfc>
    1e54:	85 81       	ldd	r24, Z+5	; 0x05
    1e56:	88 23       	and	r24, r24
    1e58:	09 f4       	brne	.+2      	; 0x1e5c <sync+0x30>
    1e5a:	66 c0       	rjmp	.+204    	; 0x1f28 <sync+0xfc>
			fs->winsect = 0;
    1e5c:	16 a6       	lds	r17, 0xb6
    1e5e:	17 a6       	lds	r17, 0xb7
    1e60:	10 aa       	sts	0x90, r17
    1e62:	11 aa       	sts	0x91, r17
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
    1e64:	87 01       	movw	r16, r14
    1e66:	0e 5c       	subi	r16, 0xCE	; 206
    1e68:	1f 4f       	sbci	r17, 0xFF	; 255
    1e6a:	c8 01       	movw	r24, r16
    1e6c:	60 e0       	ldi	r22, 0x00	; 0
    1e6e:	70 e0       	ldi	r23, 0x00	; 0
    1e70:	20 e0       	ldi	r18, 0x00	; 0
    1e72:	32 e0       	ldi	r19, 0x02	; 2
    1e74:	40 e0       	ldi	r20, 0x00	; 0
    1e76:	50 e0       	ldi	r21, 0x00	; 0
    1e78:	0e 94 b3 08 	call	0x1166	; 0x1166 <mem_set>
			ST_WORD(fs->win+BS_55AA, 0xAA55);
    1e7c:	f7 01       	movw	r30, r14
    1e7e:	e0 5d       	subi	r30, 0xD0	; 208
    1e80:	fd 4f       	sbci	r31, 0xFD	; 253
    1e82:	85 e5       	ldi	r24, 0x55	; 85
    1e84:	80 83       	st	Z, r24
    1e86:	f7 01       	movw	r30, r14
    1e88:	ef 5c       	subi	r30, 0xCF	; 207
    1e8a:	fd 4f       	sbci	r31, 0xFD	; 253
    1e8c:	8a ea       	ldi	r24, 0xAA	; 170
    1e8e:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    1e90:	82 e5       	ldi	r24, 0x52	; 82
    1e92:	f7 01       	movw	r30, r14
    1e94:	82 ab       	sts	0x52, r24
    1e96:	83 ab       	sts	0x53, r24
    1e98:	81 e6       	ldi	r24, 0x61	; 97
    1e9a:	84 ab       	sts	0x54, r24
    1e9c:	91 e4       	ldi	r25, 0x41	; 65
    1e9e:	95 ab       	sts	0x55, r25
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    1ea0:	ea 5e       	subi	r30, 0xEA	; 234
    1ea2:	fd 4f       	sbci	r31, 0xFD	; 253
    1ea4:	22 e7       	ldi	r18, 0x72	; 114
    1ea6:	20 83       	st	Z, r18
    1ea8:	f7 01       	movw	r30, r14
    1eaa:	e9 5e       	subi	r30, 0xE9	; 233
    1eac:	fd 4f       	sbci	r31, 0xFD	; 253
    1eae:	20 83       	st	Z, r18
    1eb0:	f7 01       	movw	r30, r14
    1eb2:	e8 5e       	subi	r30, 0xE8	; 232
    1eb4:	fd 4f       	sbci	r31, 0xFD	; 253
    1eb6:	90 83       	st	Z, r25
    1eb8:	f7 01       	movw	r30, r14
    1eba:	e7 5e       	subi	r30, 0xE7	; 231
    1ebc:	fd 4f       	sbci	r31, 0xFD	; 253
    1ebe:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    1ec0:	f7 01       	movw	r30, r14
    1ec2:	36 85       	ldd	r19, Z+14	; 0x0e
    1ec4:	27 85       	ldd	r18, Z+15	; 0x0f
    1ec6:	90 89       	ldd	r25, Z+16	; 0x10
    1ec8:	81 89       	ldd	r24, Z+17	; 0x11
    1eca:	e6 5e       	subi	r30, 0xE6	; 230
    1ecc:	fd 4f       	sbci	r31, 0xFD	; 253
    1ece:	30 83       	st	Z, r19
    1ed0:	f7 01       	movw	r30, r14
    1ed2:	e5 5e       	subi	r30, 0xE5	; 229
    1ed4:	fd 4f       	sbci	r31, 0xFD	; 253
    1ed6:	20 83       	st	Z, r18
    1ed8:	f7 01       	movw	r30, r14
    1eda:	e4 5e       	subi	r30, 0xE4	; 228
    1edc:	fd 4f       	sbci	r31, 0xFD	; 253
    1ede:	90 83       	st	Z, r25
    1ee0:	f7 01       	movw	r30, r14
    1ee2:	e3 5e       	subi	r30, 0xE3	; 227
    1ee4:	fd 4f       	sbci	r31, 0xFD	; 253
    1ee6:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    1ee8:	f7 01       	movw	r30, r14
    1eea:	32 85       	ldd	r19, Z+10	; 0x0a
    1eec:	23 85       	ldd	r18, Z+11	; 0x0b
    1eee:	94 85       	ldd	r25, Z+12	; 0x0c
    1ef0:	85 85       	ldd	r24, Z+13	; 0x0d
    1ef2:	e2 5e       	subi	r30, 0xE2	; 226
    1ef4:	fd 4f       	sbci	r31, 0xFD	; 253
    1ef6:	30 83       	st	Z, r19
    1ef8:	f7 01       	movw	r30, r14
    1efa:	e1 5e       	subi	r30, 0xE1	; 225
    1efc:	fd 4f       	sbci	r31, 0xFD	; 253
    1efe:	20 83       	st	Z, r18
    1f00:	f7 01       	movw	r30, r14
    1f02:	e0 5e       	subi	r30, 0xE0	; 224
    1f04:	fd 4f       	sbci	r31, 0xFD	; 253
    1f06:	90 83       	st	Z, r25
    1f08:	f7 01       	movw	r30, r14
    1f0a:	ef 5d       	subi	r30, 0xDF	; 223
    1f0c:	fd 4f       	sbci	r31, 0xFD	; 253
    1f0e:	80 83       	st	Z, r24
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    1f10:	f7 01       	movw	r30, r14
    1f12:	22 89       	ldd	r18, Z+18	; 0x12
    1f14:	33 89       	ldd	r19, Z+19	; 0x13
    1f16:	44 89       	ldd	r20, Z+20	; 0x14
    1f18:	55 89       	ldd	r21, Z+21	; 0x15
    1f1a:	81 81       	ldd	r24, Z+1	; 0x01
    1f1c:	b8 01       	movw	r22, r16
    1f1e:	01 e0       	ldi	r16, 0x01	; 1
    1f20:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
			fs->fsi_flag = 0;
    1f24:	f7 01       	movw	r30, r14
    1f26:	15 82       	std	Z+5, r1	; 0x05
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    1f28:	f7 01       	movw	r30, r14
    1f2a:	81 81       	ldd	r24, Z+1	; 0x01
    1f2c:	60 e0       	ldi	r22, 0x00	; 0
    1f2e:	40 e0       	ldi	r20, 0x00	; 0
    1f30:	50 e0       	ldi	r21, 0x00	; 0
    1f32:	0e 94 66 03 	call	0x6cc	; 0x6cc <disk_ioctl>
    1f36:	81 11       	cpse	r24, r1
			res = FR_DISK_ERR;
    1f38:	c1 e0       	ldi	r28, 0x01	; 1
	}

	return res;
}
    1f3a:	8c 2f       	mov	r24, r28
    1f3c:	cf 91       	pop	r28
    1f3e:	1f 91       	pop	r17
    1f40:	0f 91       	pop	r16
    1f42:	ff 90       	pop	r15
    1f44:	ef 90       	pop	r14
    1f46:	08 95       	ret

00001f48 <get_fattime>:
#include "diskio.h"		/* Declarations of low level disk I/O functions */

DWORD get_fattime( void )
{
	return 0;
}
    1f48:	60 e0       	ldi	r22, 0x00	; 0
    1f4a:	70 e0       	ldi	r23, 0x00	; 0
    1f4c:	cb 01       	movw	r24, r22
    1f4e:	08 95       	ret

00001f50 <clust2sect>:

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
    1f50:	0f 93       	push	r16
    1f52:	1f 93       	push	r17
    1f54:	cf 93       	push	r28
    1f56:	df 93       	push	r29
    1f58:	ec 01       	movw	r28, r24
    1f5a:	db 01       	movw	r26, r22
    1f5c:	ca 01       	movw	r24, r20
	clst -= 2;
    1f5e:	02 97       	sbiw	r24, 0x02	; 2
    1f60:	a1 09       	sbc	r26, r1
    1f62:	b1 09       	sbc	r27, r1
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    1f64:	4a 8d       	ldd	r20, Y+26	; 0x1a
    1f66:	5b 8d       	ldd	r21, Y+27	; 0x1b
    1f68:	6c 8d       	ldd	r22, Y+28	; 0x1c
    1f6a:	7d 8d       	ldd	r23, Y+29	; 0x1d
    1f6c:	42 50       	subi	r20, 0x02	; 2
    1f6e:	50 40       	sbci	r21, 0x00	; 0
    1f70:	60 40       	sbci	r22, 0x00	; 0
    1f72:	70 40       	sbci	r23, 0x00	; 0
    1f74:	84 17       	cp	r24, r20
    1f76:	95 07       	cpc	r25, r21
    1f78:	a6 07       	cpc	r26, r22
    1f7a:	b7 07       	cpc	r27, r23
    1f7c:	98 f4       	brcc	.+38     	; 0x1fa4 <clust2sect+0x54>
	return clst * fs->csize + fs->database;
    1f7e:	2a 81       	ldd	r18, Y+2	; 0x02
    1f80:	30 e0       	ldi	r19, 0x00	; 0
    1f82:	40 e0       	ldi	r20, 0x00	; 0
    1f84:	50 e0       	ldi	r21, 0x00	; 0
    1f86:	bc 01       	movw	r22, r24
    1f88:	cd 01       	movw	r24, r26
    1f8a:	0e 94 ed 29 	call	0x53da	; 0x53da <__mulsi3>
    1f8e:	8b 01       	movw	r16, r22
    1f90:	9c 01       	movw	r18, r24
    1f92:	8a a5       	lds	r24, 0x6a
    1f94:	9b a5       	lds	r25, 0x6b
    1f96:	ac a5       	lds	r26, 0x6c
    1f98:	bd a5       	lds	r27, 0x6d
    1f9a:	08 0f       	add	r16, r24
    1f9c:	19 1f       	adc	r17, r25
    1f9e:	2a 1f       	adc	r18, r26
    1fa0:	3b 1f       	adc	r19, r27
    1fa2:	03 c0       	rjmp	.+6      	; 0x1faa <clust2sect+0x5a>
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    1fa4:	00 e0       	ldi	r16, 0x00	; 0
    1fa6:	10 e0       	ldi	r17, 0x00	; 0
    1fa8:	98 01       	movw	r18, r16
	return clst * fs->csize + fs->database;
}
    1faa:	60 2f       	mov	r22, r16
    1fac:	71 2f       	mov	r23, r17
    1fae:	82 2f       	mov	r24, r18
    1fb0:	93 2f       	mov	r25, r19
    1fb2:	df 91       	pop	r29
    1fb4:	cf 91       	pop	r28
    1fb6:	1f 91       	pop	r17
    1fb8:	0f 91       	pop	r16
    1fba:	08 95       	ret

00001fbc <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
    1fbc:	8f 92       	push	r8
    1fbe:	9f 92       	push	r9
    1fc0:	af 92       	push	r10
    1fc2:	bf 92       	push	r11
    1fc4:	cf 92       	push	r12
    1fc6:	df 92       	push	r13
    1fc8:	ef 92       	push	r14
    1fca:	ff 92       	push	r15
    1fcc:	0f 93       	push	r16
    1fce:	1f 93       	push	r17
    1fd0:	cf 93       	push	r28
    1fd2:	df 93       	push	r29
    1fd4:	ec 01       	movw	r28, r24
    1fd6:	6a 01       	movw	r12, r20
    1fd8:	7b 01       	movw	r14, r22
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
    1fda:	42 30       	cpi	r20, 0x02	; 2
    1fdc:	51 05       	cpc	r21, r1
    1fde:	61 05       	cpc	r22, r1
    1fe0:	71 05       	cpc	r23, r1
    1fe2:	08 f4       	brcc	.+2      	; 0x1fe6 <get_fat+0x2a>
    1fe4:	f4 c0       	rjmp	.+488    	; 0x21ce <get_fat+0x212>
    1fe6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1fe8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1fea:	ac 8d       	ldd	r26, Y+28	; 0x1c
    1fec:	bd 8d       	ldd	r27, Y+29	; 0x1d
    1fee:	48 17       	cp	r20, r24
    1ff0:	59 07       	cpc	r21, r25
    1ff2:	6a 07       	cpc	r22, r26
    1ff4:	7b 07       	cpc	r23, r27
    1ff6:	08 f0       	brcs	.+2      	; 0x1ffa <get_fat+0x3e>
    1ff8:	ef c0       	rjmp	.+478    	; 0x21d8 <get_fat+0x21c>
		return 1;

	switch (fs->fs_type) {
    1ffa:	88 81       	ld	r24, Y
    1ffc:	82 30       	cpi	r24, 0x02	; 2
    1ffe:	09 f4       	brne	.+2      	; 0x2002 <get_fat+0x46>
    2000:	81 c0       	rjmp	.+258    	; 0x2104 <get_fat+0x148>
    2002:	83 30       	cpi	r24, 0x03	; 3
    2004:	09 f4       	brne	.+2      	; 0x2008 <get_fat+0x4c>
    2006:	a0 c0       	rjmp	.+320    	; 0x2148 <get_fat+0x18c>
    2008:	81 30       	cpi	r24, 0x01	; 1
    200a:	09 f0       	breq	.+2      	; 0x200e <get_fat+0x52>
    200c:	ea c0       	rjmp	.+468    	; 0x21e2 <get_fat+0x226>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
    200e:	4a 01       	movw	r8, r20
    2010:	5b 01       	movw	r10, r22
    2012:	b6 94       	lsr	r11
    2014:	a7 94       	ror	r10
    2016:	97 94       	ror	r9
    2018:	87 94       	ror	r8
    201a:	84 0e       	add	r8, r20
    201c:	95 1e       	adc	r9, r21
    201e:	a6 1e       	adc	r10, r22
    2020:	b7 1e       	adc	r11, r23
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    2022:	b5 01       	movw	r22, r10
    2024:	a4 01       	movw	r20, r8
    2026:	03 2e       	mov	r0, r19
    2028:	39 e0       	ldi	r19, 0x09	; 9
    202a:	76 95       	lsr	r23
    202c:	67 95       	ror	r22
    202e:	57 95       	ror	r21
    2030:	47 95       	ror	r20
    2032:	3a 95       	dec	r19
    2034:	d1 f7       	brne	.-12     	; 0x202a <get_fat+0x6e>
    2036:	30 2d       	mov	r19, r0
    2038:	8a a1       	lds	r24, 0x4a
    203a:	9b a1       	lds	r25, 0x4b
    203c:	ac a1       	lds	r26, 0x4c
    203e:	bd a1       	lds	r27, 0x4d
    2040:	48 0f       	add	r20, r24
    2042:	59 1f       	adc	r21, r25
    2044:	6a 1f       	adc	r22, r26
    2046:	7b 1f       	adc	r23, r27
    2048:	ce 01       	movw	r24, r28
    204a:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
    204e:	88 23       	and	r24, r24
    2050:	09 f0       	breq	.+2      	; 0x2054 <get_fat+0x98>
    2052:	cb c0       	rjmp	.+406    	; 0x21ea <get_fat+0x22e>
		wc = fs->win[bc % SS(fs)]; bc++;
    2054:	d5 01       	movw	r26, r10
    2056:	c4 01       	movw	r24, r8
    2058:	91 70       	andi	r25, 0x01	; 1
    205a:	a0 70       	andi	r26, 0x00	; 0
    205c:	b0 70       	andi	r27, 0x00	; 0
    205e:	fe 01       	movw	r30, r28
    2060:	e8 0f       	add	r30, r24
    2062:	f9 1f       	adc	r31, r25
    2064:	12 a9       	sts	0x42, r17
    2066:	08 94       	sec
    2068:	81 1c       	adc	r8, r1
    206a:	91 1c       	adc	r9, r1
    206c:	a1 1c       	adc	r10, r1
    206e:	b1 1c       	adc	r11, r1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    2070:	b5 01       	movw	r22, r10
    2072:	a4 01       	movw	r20, r8
    2074:	03 2e       	mov	r0, r19
    2076:	39 e0       	ldi	r19, 0x09	; 9
    2078:	76 95       	lsr	r23
    207a:	67 95       	ror	r22
    207c:	57 95       	ror	r21
    207e:	47 95       	ror	r20
    2080:	3a 95       	dec	r19
    2082:	d1 f7       	brne	.-12     	; 0x2078 <get_fat+0xbc>
    2084:	30 2d       	mov	r19, r0
    2086:	8a a1       	lds	r24, 0x4a
    2088:	9b a1       	lds	r25, 0x4b
    208a:	ac a1       	lds	r26, 0x4c
    208c:	bd a1       	lds	r27, 0x4d
    208e:	48 0f       	add	r20, r24
    2090:	59 1f       	adc	r21, r25
    2092:	6a 1f       	adc	r22, r26
    2094:	7b 1f       	adc	r23, r27
    2096:	ce 01       	movw	r24, r28
    2098:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
    209c:	88 23       	and	r24, r24
    209e:	09 f0       	breq	.+2      	; 0x20a2 <get_fat+0xe6>
    20a0:	a8 c0       	rjmp	.+336    	; 0x21f2 <get_fat+0x236>

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
    20a2:	41 2f       	mov	r20, r17
    20a4:	50 e0       	ldi	r21, 0x00	; 0
    20a6:	60 e0       	ldi	r22, 0x00	; 0
    20a8:	70 e0       	ldi	r23, 0x00	; 0
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
    20aa:	8f ef       	ldi	r24, 0xFF	; 255
    20ac:	91 e0       	ldi	r25, 0x01	; 1
    20ae:	a0 e0       	ldi	r26, 0x00	; 0
    20b0:	b0 e0       	ldi	r27, 0x00	; 0
    20b2:	88 22       	and	r8, r24
    20b4:	99 22       	and	r9, r25
    20b6:	aa 22       	and	r10, r26
    20b8:	bb 22       	and	r11, r27
    20ba:	fe 01       	movw	r30, r28
    20bc:	e8 0d       	add	r30, r8
    20be:	f9 1d       	adc	r31, r9
    20c0:	92 a9       	sts	0x42, r25
    20c2:	80 e0       	ldi	r24, 0x00	; 0
    20c4:	8c 01       	movw	r16, r24
    20c6:	22 27       	eor	r18, r18
    20c8:	17 fd       	sbrc	r17, 7
    20ca:	20 95       	com	r18
    20cc:	32 2f       	mov	r19, r18
    20ce:	40 2b       	or	r20, r16
    20d0:	51 2b       	or	r21, r17
    20d2:	62 2b       	or	r22, r18
    20d4:	73 2b       	or	r23, r19
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    20d6:	91 e0       	ldi	r25, 0x01	; 1
    20d8:	c9 22       	and	r12, r25
    20da:	dd 24       	eor	r13, r13
    20dc:	c1 14       	cp	r12, r1
    20de:	d1 04       	cpc	r13, r1
    20e0:	59 f0       	breq	.+22     	; 0x20f8 <get_fat+0x13c>
    20e2:	8a 01       	movw	r16, r20
    20e4:	9b 01       	movw	r18, r22
    20e6:	68 94       	set
    20e8:	13 f8       	bld	r1, 3
    20ea:	36 95       	lsr	r19
    20ec:	27 95       	ror	r18
    20ee:	17 95       	ror	r17
    20f0:	07 95       	ror	r16
    20f2:	16 94       	lsr	r1
    20f4:	d1 f7       	brne	.-12     	; 0x20ea <get_fat+0x12e>
    20f6:	88 c0       	rjmp	.+272    	; 0x2208 <get_fat+0x24c>
    20f8:	8a 01       	movw	r16, r20
    20fa:	9b 01       	movw	r18, r22
    20fc:	1f 70       	andi	r17, 0x0F	; 15
    20fe:	20 70       	andi	r18, 0x00	; 0
    2100:	30 70       	andi	r19, 0x00	; 0
    2102:	82 c0       	rjmp	.+260    	; 0x2208 <get_fat+0x24c>

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    2104:	45 2f       	mov	r20, r21
    2106:	56 2f       	mov	r21, r22
    2108:	67 2f       	mov	r22, r23
    210a:	77 27       	eor	r23, r23
    210c:	8a a1       	lds	r24, 0x4a
    210e:	9b a1       	lds	r25, 0x4b
    2110:	ac a1       	lds	r26, 0x4c
    2112:	bd a1       	lds	r27, 0x4d
    2114:	48 0f       	add	r20, r24
    2116:	59 1f       	adc	r21, r25
    2118:	6a 1f       	adc	r22, r26
    211a:	7b 1f       	adc	r23, r27
    211c:	ce 01       	movw	r24, r28
    211e:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
    2122:	88 23       	and	r24, r24
    2124:	09 f0       	breq	.+2      	; 0x2128 <get_fat+0x16c>
    2126:	69 c0       	rjmp	.+210    	; 0x21fa <get_fat+0x23e>
		p = &fs->win[clst * 2 % SS(fs)];
    2128:	f6 01       	movw	r30, r12
    212a:	ee 0f       	add	r30, r30
    212c:	ff 1f       	adc	r31, r31
    212e:	f1 70       	andi	r31, 0x01	; 1
		return LD_WORD(p);
    2130:	ce 0f       	add	r28, r30
    2132:	df 1f       	adc	r29, r31
    2134:	9b a9       	sts	0x4b, r25
    2136:	80 e0       	ldi	r24, 0x00	; 0
    2138:	0a a9       	sts	0x4a, r16
    213a:	10 e0       	ldi	r17, 0x00	; 0
    213c:	80 2b       	or	r24, r16
    213e:	91 2b       	or	r25, r17
    2140:	8c 01       	movw	r16, r24
    2142:	20 e0       	ldi	r18, 0x00	; 0
    2144:	30 e0       	ldi	r19, 0x00	; 0
    2146:	60 c0       	rjmp	.+192    	; 0x2208 <get_fat+0x24c>

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    2148:	68 94       	set
    214a:	16 f8       	bld	r1, 6
    214c:	76 95       	lsr	r23
    214e:	67 95       	ror	r22
    2150:	57 95       	ror	r21
    2152:	47 95       	ror	r20
    2154:	16 94       	lsr	r1
    2156:	d1 f7       	brne	.-12     	; 0x214c <get_fat+0x190>
    2158:	8a a1       	lds	r24, 0x4a
    215a:	9b a1       	lds	r25, 0x4b
    215c:	ac a1       	lds	r26, 0x4c
    215e:	bd a1       	lds	r27, 0x4d
    2160:	48 0f       	add	r20, r24
    2162:	59 1f       	adc	r21, r25
    2164:	6a 1f       	adc	r22, r26
    2166:	7b 1f       	adc	r23, r27
    2168:	ce 01       	movw	r24, r28
    216a:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
    216e:	88 23       	and	r24, r24
    2170:	09 f0       	breq	.+2      	; 0x2174 <get_fat+0x1b8>
    2172:	47 c0       	rjmp	.+142    	; 0x2202 <get_fat+0x246>
		p = &fs->win[clst * 4 % SS(fs)];
    2174:	f6 01       	movw	r30, r12
    2176:	ee 0f       	add	r30, r30
    2178:	ff 1f       	adc	r31, r31
    217a:	ee 0f       	add	r30, r30
    217c:	ff 1f       	adc	r31, r31
    217e:	f1 70       	andi	r31, 0x01	; 1
		return LD_DWORD(p) & 0x0FFFFFFF;
    2180:	ce 0f       	add	r28, r30
    2182:	df 1f       	adc	r29, r31
    2184:	0d a9       	sts	0x4d, r16
    2186:	10 e0       	ldi	r17, 0x00	; 0
    2188:	20 e0       	ldi	r18, 0x00	; 0
    218a:	30 e0       	ldi	r19, 0x00	; 0
    218c:	30 2f       	mov	r19, r16
    218e:	22 27       	eor	r18, r18
    2190:	11 27       	eor	r17, r17
    2192:	00 27       	eor	r16, r16
    2194:	8c a9       	sts	0x4c, r24
    2196:	90 e0       	ldi	r25, 0x00	; 0
    2198:	a0 e0       	ldi	r26, 0x00	; 0
    219a:	b0 e0       	ldi	r27, 0x00	; 0
    219c:	dc 01       	movw	r26, r24
    219e:	99 27       	eor	r25, r25
    21a0:	88 27       	eor	r24, r24
    21a2:	08 2b       	or	r16, r24
    21a4:	19 2b       	or	r17, r25
    21a6:	2a 2b       	or	r18, r26
    21a8:	3b 2b       	or	r19, r27
    21aa:	8a a9       	sts	0x4a, r24
    21ac:	90 e0       	ldi	r25, 0x00	; 0
    21ae:	a0 e0       	ldi	r26, 0x00	; 0
    21b0:	b0 e0       	ldi	r27, 0x00	; 0
    21b2:	08 2b       	or	r16, r24
    21b4:	19 2b       	or	r17, r25
    21b6:	2a 2b       	or	r18, r26
    21b8:	3b 2b       	or	r19, r27
    21ba:	9b a9       	sts	0x4b, r25
    21bc:	80 e0       	ldi	r24, 0x00	; 0
    21be:	a0 e0       	ldi	r26, 0x00	; 0
    21c0:	b0 e0       	ldi	r27, 0x00	; 0
    21c2:	08 2b       	or	r16, r24
    21c4:	19 2b       	or	r17, r25
    21c6:	2a 2b       	or	r18, r26
    21c8:	3b 2b       	or	r19, r27
    21ca:	3f 70       	andi	r19, 0x0F	; 15
    21cc:	1d c0       	rjmp	.+58     	; 0x2208 <get_fat+0x24c>
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;
    21ce:	01 e0       	ldi	r16, 0x01	; 1
    21d0:	10 e0       	ldi	r17, 0x00	; 0
    21d2:	20 e0       	ldi	r18, 0x00	; 0
    21d4:	30 e0       	ldi	r19, 0x00	; 0
    21d6:	18 c0       	rjmp	.+48     	; 0x2208 <get_fat+0x24c>
    21d8:	01 e0       	ldi	r16, 0x01	; 1
    21da:	10 e0       	ldi	r17, 0x00	; 0
    21dc:	20 e0       	ldi	r18, 0x00	; 0
    21de:	30 e0       	ldi	r19, 0x00	; 0
    21e0:	13 c0       	rjmp	.+38     	; 0x2208 <get_fat+0x24c>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    21e2:	0f ef       	ldi	r16, 0xFF	; 255
    21e4:	1f ef       	ldi	r17, 0xFF	; 255
    21e6:	98 01       	movw	r18, r16
    21e8:	0f c0       	rjmp	.+30     	; 0x2208 <get_fat+0x24c>
    21ea:	0f ef       	ldi	r16, 0xFF	; 255
    21ec:	1f ef       	ldi	r17, 0xFF	; 255
    21ee:	98 01       	movw	r18, r16
    21f0:	0b c0       	rjmp	.+22     	; 0x2208 <get_fat+0x24c>
    21f2:	0f ef       	ldi	r16, 0xFF	; 255
    21f4:	1f ef       	ldi	r17, 0xFF	; 255
    21f6:	98 01       	movw	r18, r16
    21f8:	07 c0       	rjmp	.+14     	; 0x2208 <get_fat+0x24c>
    21fa:	0f ef       	ldi	r16, 0xFF	; 255
    21fc:	1f ef       	ldi	r17, 0xFF	; 255
    21fe:	98 01       	movw	r18, r16
    2200:	03 c0       	rjmp	.+6      	; 0x2208 <get_fat+0x24c>
    2202:	0f ef       	ldi	r16, 0xFF	; 255
    2204:	1f ef       	ldi	r17, 0xFF	; 255
    2206:	98 01       	movw	r18, r16
}
    2208:	60 2f       	mov	r22, r16
    220a:	71 2f       	mov	r23, r17
    220c:	82 2f       	mov	r24, r18
    220e:	93 2f       	mov	r25, r19
    2210:	df 91       	pop	r29
    2212:	cf 91       	pop	r28
    2214:	1f 91       	pop	r17
    2216:	0f 91       	pop	r16
    2218:	ff 90       	pop	r15
    221a:	ef 90       	pop	r14
    221c:	df 90       	pop	r13
    221e:	cf 90       	pop	r12
    2220:	bf 90       	pop	r11
    2222:	af 90       	pop	r10
    2224:	9f 90       	pop	r9
    2226:	8f 90       	pop	r8
    2228:	08 95       	ret

0000222a <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Index of directory table */
)
{
    222a:	ef 92       	push	r14
    222c:	ff 92       	push	r15
    222e:	0f 93       	push	r16
    2230:	1f 93       	push	r17
    2232:	cf 93       	push	r28
    2234:	df 93       	push	r29
    2236:	ec 01       	movw	r28, r24
    2238:	8b 01       	movw	r16, r22
	DWORD clst;
	WORD ic;


	dj->index = idx;
    223a:	7d 83       	std	Y+5, r23	; 0x05
    223c:	6c 83       	std	Y+4, r22	; 0x04
	clst = dj->sclust;
    223e:	4e 81       	ldd	r20, Y+6	; 0x06
    2240:	5f 81       	ldd	r21, Y+7	; 0x07
    2242:	68 85       	ldd	r22, Y+8	; 0x08
    2244:	79 85       	ldd	r23, Y+9	; 0x09
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    2246:	41 30       	cpi	r20, 0x01	; 1
    2248:	51 05       	cpc	r21, r1
    224a:	61 05       	cpc	r22, r1
    224c:	71 05       	cpc	r23, r1
    224e:	09 f4       	brne	.+2      	; 0x2252 <dir_sdi+0x28>
    2250:	9f c0       	rjmp	.+318    	; 0x2390 <dir_sdi+0x166>
    2252:	e8 81       	ld	r30, Y
    2254:	f9 81       	ldd	r31, Y+1	; 0x01
    2256:	82 8d       	ldd	r24, Z+26	; 0x1a
    2258:	93 8d       	ldd	r25, Z+27	; 0x1b
    225a:	a4 8d       	ldd	r26, Z+28	; 0x1c
    225c:	b5 8d       	ldd	r27, Z+29	; 0x1d
    225e:	48 17       	cp	r20, r24
    2260:	59 07       	cpc	r21, r25
    2262:	6a 07       	cpc	r22, r26
    2264:	7b 07       	cpc	r23, r27
    2266:	08 f0       	brcs	.+2      	; 0x226a <dir_sdi+0x40>
    2268:	95 c0       	rjmp	.+298    	; 0x2394 <dir_sdi+0x16a>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    226a:	41 15       	cp	r20, r1
    226c:	51 05       	cpc	r21, r1
    226e:	61 05       	cpc	r22, r1
    2270:	71 05       	cpc	r23, r1
    2272:	69 f5       	brne	.+90     	; 0x22ce <dir_sdi+0xa4>
    2274:	80 81       	ld	r24, Z
    2276:	83 30       	cpi	r24, 0x03	; 3
    2278:	49 f4       	brne	.+18     	; 0x228c <dir_sdi+0x62>
		clst = dj->fs->dirbase;
    227a:	46 a1       	lds	r20, 0x46
    227c:	57 a1       	lds	r21, 0x47
    227e:	60 a5       	lds	r22, 0x60
    2280:	71 a5       	lds	r23, 0x61

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    2282:	41 15       	cp	r20, r1
    2284:	51 05       	cpc	r21, r1
    2286:	61 05       	cpc	r22, r1
    2288:	71 05       	cpc	r23, r1
    228a:	09 f5       	brne	.+66     	; 0x22ce <dir_sdi+0xa4>
		dj->clust = clst;
    228c:	1a 86       	std	Y+10, r1	; 0x0a
    228e:	1b 86       	std	Y+11, r1	; 0x0b
    2290:	1c 86       	std	Y+12, r1	; 0x0c
    2292:	1d 86       	std	Y+13, r1	; 0x0d
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    2294:	80 85       	ldd	r24, Z+8	; 0x08
    2296:	91 85       	ldd	r25, Z+9	; 0x09
    2298:	08 17       	cp	r16, r24
    229a:	19 07       	cpc	r17, r25
    229c:	08 f0       	brcs	.+2      	; 0x22a0 <dir_sdi+0x76>
    229e:	7c c0       	rjmp	.+248    	; 0x2398 <dir_sdi+0x16e>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    22a0:	c8 01       	movw	r24, r16
    22a2:	92 95       	swap	r25
    22a4:	82 95       	swap	r24
    22a6:	8f 70       	andi	r24, 0x0F	; 15
    22a8:	89 27       	eor	r24, r25
    22aa:	9f 70       	andi	r25, 0x0F	; 15
    22ac:	89 27       	eor	r24, r25
    22ae:	ac 01       	movw	r20, r24
    22b0:	60 e0       	ldi	r22, 0x00	; 0
    22b2:	70 e0       	ldi	r23, 0x00	; 0
    22b4:	86 a1       	lds	r24, 0x46
    22b6:	97 a1       	lds	r25, 0x47
    22b8:	a0 a5       	lds	r26, 0x60
    22ba:	b1 a5       	lds	r27, 0x61
    22bc:	84 0f       	add	r24, r20
    22be:	95 1f       	adc	r25, r21
    22c0:	a6 1f       	adc	r26, r22
    22c2:	b7 1f       	adc	r27, r23
    22c4:	8e 87       	std	Y+14, r24	; 0x0e
    22c6:	9f 87       	std	Y+15, r25	; 0x0f
    22c8:	a8 8b       	std	Y+16, r26	; 0x10
    22ca:	b9 8b       	std	Y+17, r27	; 0x11
    22cc:	4e c0       	rjmp	.+156    	; 0x236a <dir_sdi+0x140>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    22ce:	82 81       	ldd	r24, Z+2	; 0x02
    22d0:	90 e0       	ldi	r25, 0x00	; 0
    22d2:	7c 01       	movw	r14, r24
    22d4:	ee 0c       	add	r14, r14
    22d6:	ff 1c       	adc	r15, r15
    22d8:	ee 0c       	add	r14, r14
    22da:	ff 1c       	adc	r15, r15
    22dc:	ee 0c       	add	r14, r14
    22de:	ff 1c       	adc	r15, r15
    22e0:	ee 0c       	add	r14, r14
    22e2:	ff 1c       	adc	r15, r15
		while (idx >= ic) {	/* Follow cluster chain */
    22e4:	0e 15       	cp	r16, r14
    22e6:	1f 05       	cpc	r17, r15
    22e8:	28 f1       	brcs	.+74     	; 0x2334 <dir_sdi+0x10a>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    22ea:	88 81       	ld	r24, Y
    22ec:	99 81       	ldd	r25, Y+1	; 0x01
    22ee:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <get_fat>
    22f2:	ab 01       	movw	r20, r22
    22f4:	bc 01       	movw	r22, r24
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    22f6:	4f 3f       	cpi	r20, 0xFF	; 255
    22f8:	8f ef       	ldi	r24, 0xFF	; 255
    22fa:	58 07       	cpc	r21, r24
    22fc:	8f ef       	ldi	r24, 0xFF	; 255
    22fe:	68 07       	cpc	r22, r24
    2300:	8f ef       	ldi	r24, 0xFF	; 255
    2302:	78 07       	cpc	r23, r24
    2304:	09 f4       	brne	.+2      	; 0x2308 <dir_sdi+0xde>
    2306:	4a c0       	rjmp	.+148    	; 0x239c <dir_sdi+0x172>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    2308:	42 30       	cpi	r20, 0x02	; 2
    230a:	51 05       	cpc	r21, r1
    230c:	61 05       	cpc	r22, r1
    230e:	71 05       	cpc	r23, r1
    2310:	08 f4       	brcc	.+2      	; 0x2314 <dir_sdi+0xea>
    2312:	46 c0       	rjmp	.+140    	; 0x23a0 <dir_sdi+0x176>
    2314:	e8 81       	ld	r30, Y
    2316:	f9 81       	ldd	r31, Y+1	; 0x01
    2318:	82 8d       	ldd	r24, Z+26	; 0x1a
    231a:	93 8d       	ldd	r25, Z+27	; 0x1b
    231c:	a4 8d       	ldd	r26, Z+28	; 0x1c
    231e:	b5 8d       	ldd	r27, Z+29	; 0x1d
    2320:	48 17       	cp	r20, r24
    2322:	59 07       	cpc	r21, r25
    2324:	6a 07       	cpc	r22, r26
    2326:	7b 07       	cpc	r23, r27
    2328:	e8 f5       	brcc	.+122    	; 0x23a4 <dir_sdi+0x17a>
				return FR_INT_ERR;
			idx -= ic;
    232a:	0e 19       	sub	r16, r14
    232c:	1f 09       	sbc	r17, r15
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
    232e:	0e 15       	cp	r16, r14
    2330:	1f 05       	cpc	r17, r15
    2332:	d8 f6       	brcc	.-74     	; 0x22ea <dir_sdi+0xc0>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
    2334:	4a 87       	std	Y+10, r20	; 0x0a
    2336:	5b 87       	std	Y+11, r21	; 0x0b
    2338:	6c 87       	std	Y+12, r22	; 0x0c
    233a:	7d 87       	std	Y+13, r23	; 0x0d
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    233c:	88 81       	ld	r24, Y
    233e:	99 81       	ldd	r25, Y+1	; 0x01
    2340:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <clust2sect>
    2344:	ab 01       	movw	r20, r22
    2346:	bc 01       	movw	r22, r24
    2348:	c8 01       	movw	r24, r16
    234a:	92 95       	swap	r25
    234c:	82 95       	swap	r24
    234e:	8f 70       	andi	r24, 0x0F	; 15
    2350:	89 27       	eor	r24, r25
    2352:	9f 70       	andi	r25, 0x0F	; 15
    2354:	89 27       	eor	r24, r25
    2356:	a0 e0       	ldi	r26, 0x00	; 0
    2358:	b0 e0       	ldi	r27, 0x00	; 0
    235a:	84 0f       	add	r24, r20
    235c:	95 1f       	adc	r25, r21
    235e:	a6 1f       	adc	r26, r22
    2360:	b7 1f       	adc	r27, r23
    2362:	8e 87       	std	Y+14, r24	; 0x0e
    2364:	9f 87       	std	Y+15, r25	; 0x0f
    2366:	a8 8b       	std	Y+16, r26	; 0x10
    2368:	b9 8b       	std	Y+17, r27	; 0x11
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    236a:	88 81       	ld	r24, Y
    236c:	99 81       	ldd	r25, Y+1	; 0x01
    236e:	c2 96       	adiw	r24, 0x32	; 50
    2370:	0f 70       	andi	r16, 0x0F	; 15
    2372:	10 70       	andi	r17, 0x00	; 0
    2374:	00 0f       	add	r16, r16
    2376:	11 1f       	adc	r17, r17
    2378:	02 95       	swap	r16
    237a:	12 95       	swap	r17
    237c:	10 7f       	andi	r17, 0xF0	; 240
    237e:	10 27       	eor	r17, r16
    2380:	00 7f       	andi	r16, 0xF0	; 240
    2382:	10 27       	eor	r17, r16
    2384:	80 0f       	add	r24, r16
    2386:	91 1f       	adc	r25, r17
    2388:	9b 8b       	std	Y+19, r25	; 0x13
    238a:	8a 8b       	std	Y+18, r24	; 0x12

	return FR_OK;	/* Seek succeeded */
    238c:	80 e0       	ldi	r24, 0x00	; 0
    238e:	0b c0       	rjmp	.+22     	; 0x23a6 <dir_sdi+0x17c>


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
    2390:	82 e0       	ldi	r24, 0x02	; 2
    2392:	09 c0       	rjmp	.+18     	; 0x23a6 <dir_sdi+0x17c>
    2394:	82 e0       	ldi	r24, 0x02	; 2
    2396:	07 c0       	rjmp	.+14     	; 0x23a6 <dir_sdi+0x17c>
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
    2398:	82 e0       	ldi	r24, 0x02	; 2
    239a:	05 c0       	rjmp	.+10     	; 0x23a6 <dir_sdi+0x17c>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    239c:	81 e0       	ldi	r24, 0x01	; 1
    239e:	03 c0       	rjmp	.+6      	; 0x23a6 <dir_sdi+0x17c>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
    23a0:	82 e0       	ldi	r24, 0x02	; 2
    23a2:	01 c0       	rjmp	.+2      	; 0x23a6 <dir_sdi+0x17c>
    23a4:	82 e0       	ldi	r24, 0x02	; 2
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
    23a6:	df 91       	pop	r29
    23a8:	cf 91       	pop	r28
    23aa:	1f 91       	pop	r17
    23ac:	0f 91       	pop	r16
    23ae:	ff 90       	pop	r15
    23b0:	ef 90       	pop	r14
    23b2:	08 95       	ret

000023b4 <dir_remove>:
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
	DIR *dj				/* Directory object pointing the entry to be removed */
)
{
    23b4:	cf 93       	push	r28
    23b6:	df 93       	push	r29
    23b8:	ec 01       	movw	r28, r24
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
	}

#else			/* Non LFN configuration */
	res = dir_sdi(dj, dj->index);
    23ba:	6c 81       	ldd	r22, Y+4	; 0x04
    23bc:	7d 81       	ldd	r23, Y+5	; 0x05
    23be:	0e 94 15 11 	call	0x222a	; 0x222a <dir_sdi>
	if (res == FR_OK) {
    23c2:	88 23       	and	r24, r24
    23c4:	91 f4       	brne	.+36     	; 0x23ea <dir_remove+0x36>
		res = move_window(dj->fs, dj->sect);
    23c6:	4e 85       	ldd	r20, Y+14	; 0x0e
    23c8:	5f 85       	ldd	r21, Y+15	; 0x0f
    23ca:	68 89       	ldd	r22, Y+16	; 0x10
    23cc:	79 89       	ldd	r23, Y+17	; 0x11
    23ce:	88 81       	ld	r24, Y
    23d0:	99 81       	ldd	r25, Y+1	; 0x01
    23d2:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
		if (res == FR_OK) {
    23d6:	88 23       	and	r24, r24
    23d8:	41 f4       	brne	.+16     	; 0x23ea <dir_remove+0x36>
			*dj->dir = DDE;			/* Mark the entry "deleted" */
    23da:	ea 89       	ldd	r30, Y+18	; 0x12
    23dc:	fb 89       	ldd	r31, Y+19	; 0x13
    23de:	95 ee       	ldi	r25, 0xE5	; 229
    23e0:	90 83       	st	Z, r25
			dj->fs->wflag = 1;
    23e2:	e8 81       	ld	r30, Y
    23e4:	f9 81       	ldd	r31, Y+1	; 0x01
    23e6:	91 e0       	ldi	r25, 0x01	; 1
    23e8:	94 83       	std	Z+4, r25	; 0x04
		}
	}
#endif

	return res;
}
    23ea:	df 91       	pop	r29
    23ec:	cf 91       	pop	r28
    23ee:	08 95       	ret

000023f0 <put_fat>:
FRESULT put_fat (
	FATFS *fs,	/* File system object */
	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
	DWORD val	/* New value to mark the cluster */
)
{
    23f0:	4f 92       	push	r4
    23f2:	5f 92       	push	r5
    23f4:	6f 92       	push	r6
    23f6:	7f 92       	push	r7
    23f8:	8f 92       	push	r8
    23fa:	9f 92       	push	r9
    23fc:	af 92       	push	r10
    23fe:	bf 92       	push	r11
    2400:	cf 92       	push	r12
    2402:	df 92       	push	r13
    2404:	ef 92       	push	r14
    2406:	ff 92       	push	r15
    2408:	0f 93       	push	r16
    240a:	1f 93       	push	r17
    240c:	cf 93       	push	r28
    240e:	df 93       	push	r29
    2410:	ec 01       	movw	r28, r24
    2412:	6a 01       	movw	r12, r20
    2414:	7b 01       	movw	r14, r22
    2416:	48 01       	movw	r8, r16
    2418:	59 01       	movw	r10, r18
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    241a:	42 30       	cpi	r20, 0x02	; 2
    241c:	51 05       	cpc	r21, r1
    241e:	61 05       	cpc	r22, r1
    2420:	71 05       	cpc	r23, r1
    2422:	08 f4       	brcc	.+2      	; 0x2426 <put_fat+0x36>
    2424:	e0 c0       	rjmp	.+448    	; 0x25e6 <put_fat+0x1f6>
    2426:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2428:	9b 8d       	ldd	r25, Y+27	; 0x1b
    242a:	ac 8d       	ldd	r26, Y+28	; 0x1c
    242c:	bd 8d       	ldd	r27, Y+29	; 0x1d
    242e:	48 17       	cp	r20, r24
    2430:	59 07       	cpc	r21, r25
    2432:	6a 07       	cpc	r22, r26
    2434:	7b 07       	cpc	r23, r27
    2436:	08 f0       	brcs	.+2      	; 0x243a <put_fat+0x4a>
    2438:	d8 c0       	rjmp	.+432    	; 0x25ea <put_fat+0x1fa>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
    243a:	88 81       	ld	r24, Y
    243c:	82 30       	cpi	r24, 0x02	; 2
    243e:	09 f4       	brne	.+2      	; 0x2442 <put_fat+0x52>
    2440:	80 c0       	rjmp	.+256    	; 0x2542 <put_fat+0x152>
    2442:	83 30       	cpi	r24, 0x03	; 3
    2444:	09 f4       	brne	.+2      	; 0x2448 <put_fat+0x58>
    2446:	98 c0       	rjmp	.+304    	; 0x2578 <put_fat+0x188>
    2448:	81 30       	cpi	r24, 0x01	; 1
    244a:	09 f0       	breq	.+2      	; 0x244e <put_fat+0x5e>
    244c:	c8 c0       	rjmp	.+400    	; 0x25de <put_fat+0x1ee>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
    244e:	db 01       	movw	r26, r22
    2450:	ca 01       	movw	r24, r20
    2452:	b6 95       	lsr	r27
    2454:	a7 95       	ror	r26
    2456:	97 95       	ror	r25
    2458:	87 95       	ror	r24
    245a:	2c 01       	movw	r4, r24
    245c:	3d 01       	movw	r6, r26
    245e:	44 0e       	add	r4, r20
    2460:	55 1e       	adc	r5, r21
    2462:	66 1e       	adc	r6, r22
    2464:	77 1e       	adc	r7, r23
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    2466:	b3 01       	movw	r22, r6
    2468:	a2 01       	movw	r20, r4
    246a:	03 2e       	mov	r0, r19
    246c:	39 e0       	ldi	r19, 0x09	; 9
    246e:	76 95       	lsr	r23
    2470:	67 95       	ror	r22
    2472:	57 95       	ror	r21
    2474:	47 95       	ror	r20
    2476:	3a 95       	dec	r19
    2478:	d1 f7       	brne	.-12     	; 0x246e <put_fat+0x7e>
    247a:	30 2d       	mov	r19, r0
    247c:	8a a1       	lds	r24, 0x4a
    247e:	9b a1       	lds	r25, 0x4b
    2480:	ac a1       	lds	r26, 0x4c
    2482:	bd a1       	lds	r27, 0x4d
    2484:	48 0f       	add	r20, r24
    2486:	59 1f       	adc	r21, r25
    2488:	6a 1f       	adc	r22, r26
    248a:	7b 1f       	adc	r23, r27
    248c:	ce 01       	movw	r24, r28
    248e:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
			if (res != FR_OK) break;
    2492:	88 23       	and	r24, r24
    2494:	09 f0       	breq	.+2      	; 0x2498 <put_fat+0xa8>
    2496:	a4 c0       	rjmp	.+328    	; 0x25e0 <put_fat+0x1f0>
			p = &fs->win[bc % SS(fs)];
    2498:	c2 01       	movw	r24, r4
    249a:	91 70       	andi	r25, 0x01	; 1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    249c:	31 e0       	ldi	r19, 0x01	; 1
    249e:	c3 22       	and	r12, r19
    24a0:	dd 24       	eor	r13, r13
    24a2:	c1 14       	cp	r12, r1
    24a4:	d1 04       	cpc	r13, r1
    24a6:	51 f0       	breq	.+20     	; 0x24bc <put_fat+0xcc>
    24a8:	fe 01       	movw	r30, r28
    24aa:	e8 0f       	add	r30, r24
    24ac:	f9 1f       	adc	r31, r25
    24ae:	22 a9       	sts	0x42, r18
    24b0:	2f 70       	andi	r18, 0x0F	; 15
    24b2:	38 2d       	mov	r19, r8
    24b4:	32 95       	swap	r19
    24b6:	30 7f       	andi	r19, 0xF0	; 240
    24b8:	23 2b       	or	r18, r19
    24ba:	01 c0       	rjmp	.+2      	; 0x24be <put_fat+0xce>
    24bc:	28 2d       	mov	r18, r8
    24be:	fe 01       	movw	r30, r28
    24c0:	e8 0f       	add	r30, r24
    24c2:	f9 1f       	adc	r31, r25
    24c4:	22 ab       	sts	0x52, r18
			bc++;
    24c6:	08 94       	sec
    24c8:	41 1c       	adc	r4, r1
    24ca:	51 1c       	adc	r5, r1
    24cc:	61 1c       	adc	r6, r1
    24ce:	71 1c       	adc	r7, r1
			fs->wflag = 1;
    24d0:	81 e0       	ldi	r24, 0x01	; 1
    24d2:	8c 83       	std	Y+4, r24	; 0x04
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    24d4:	b3 01       	movw	r22, r6
    24d6:	a2 01       	movw	r20, r4
    24d8:	03 2e       	mov	r0, r19
    24da:	39 e0       	ldi	r19, 0x09	; 9
    24dc:	76 95       	lsr	r23
    24de:	67 95       	ror	r22
    24e0:	57 95       	ror	r21
    24e2:	47 95       	ror	r20
    24e4:	3a 95       	dec	r19
    24e6:	d1 f7       	brne	.-12     	; 0x24dc <put_fat+0xec>
    24e8:	30 2d       	mov	r19, r0
    24ea:	8a a1       	lds	r24, 0x4a
    24ec:	9b a1       	lds	r25, 0x4b
    24ee:	ac a1       	lds	r26, 0x4c
    24f0:	bd a1       	lds	r27, 0x4d
    24f2:	48 0f       	add	r20, r24
    24f4:	59 1f       	adc	r21, r25
    24f6:	6a 1f       	adc	r22, r26
    24f8:	7b 1f       	adc	r23, r27
    24fa:	ce 01       	movw	r24, r28
    24fc:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
			if (res != FR_OK) break;
    2500:	88 23       	and	r24, r24
    2502:	09 f0       	breq	.+2      	; 0x2506 <put_fat+0x116>
    2504:	6d c0       	rjmp	.+218    	; 0x25e0 <put_fat+0x1f0>
			p = &fs->win[bc % SS(fs)];
    2506:	ef ef       	ldi	r30, 0xFF	; 255
    2508:	f1 e0       	ldi	r31, 0x01	; 1
    250a:	4e 22       	and	r4, r30
    250c:	5f 22       	and	r5, r31
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    250e:	c1 14       	cp	r12, r1
    2510:	d1 04       	cpc	r13, r1
    2512:	49 f0       	breq	.+18     	; 0x2526 <put_fat+0x136>
    2514:	68 94       	set
    2516:	13 f8       	bld	r1, 3
    2518:	b6 94       	lsr	r11
    251a:	a7 94       	ror	r10
    251c:	97 94       	ror	r9
    251e:	87 94       	ror	r8
    2520:	16 94       	lsr	r1
    2522:	d1 f7       	brne	.-12     	; 0x2518 <put_fat+0x128>
    2524:	09 c0       	rjmp	.+18     	; 0x2538 <put_fat+0x148>
    2526:	fe 01       	movw	r30, r28
    2528:	e4 0d       	add	r30, r4
    252a:	f5 1d       	adc	r31, r5
    252c:	22 a9       	sts	0x42, r18
    252e:	20 7f       	andi	r18, 0xF0	; 240
    2530:	99 2d       	mov	r25, r9
    2532:	9f 70       	andi	r25, 0x0F	; 15
    2534:	82 2e       	mov	r8, r18
    2536:	89 2a       	or	r8, r25
    2538:	4c 0e       	add	r4, r28
    253a:	5d 1e       	adc	r5, r29
    253c:	f2 01       	movw	r30, r4
    253e:	82 aa       	sts	0x92, r24
			break;
    2540:	4f c0       	rjmp	.+158    	; 0x25e0 <put_fat+0x1f0>

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    2542:	45 2f       	mov	r20, r21
    2544:	56 2f       	mov	r21, r22
    2546:	67 2f       	mov	r22, r23
    2548:	77 27       	eor	r23, r23
    254a:	8a a1       	lds	r24, 0x4a
    254c:	9b a1       	lds	r25, 0x4b
    254e:	ac a1       	lds	r26, 0x4c
    2550:	bd a1       	lds	r27, 0x4d
    2552:	48 0f       	add	r20, r24
    2554:	59 1f       	adc	r21, r25
    2556:	6a 1f       	adc	r22, r26
    2558:	7b 1f       	adc	r23, r27
    255a:	ce 01       	movw	r24, r28
    255c:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
			if (res != FR_OK) break;
    2560:	88 23       	and	r24, r24
    2562:	09 f0       	breq	.+2      	; 0x2566 <put_fat+0x176>
    2564:	3d c0       	rjmp	.+122    	; 0x25e0 <put_fat+0x1f0>
			p = &fs->win[clst * 2 % SS(fs)];
    2566:	f6 01       	movw	r30, r12
    2568:	ee 0f       	add	r30, r30
    256a:	ff 1f       	adc	r31, r31
    256c:	f1 70       	andi	r31, 0x01	; 1
			ST_WORD(p, (WORD)val);
    256e:	ec 0f       	add	r30, r28
    2570:	fd 1f       	adc	r31, r29
    2572:	82 aa       	sts	0x92, r24
    2574:	93 aa       	sts	0x93, r25
			break;
    2576:	34 c0       	rjmp	.+104    	; 0x25e0 <put_fat+0x1f0>

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    2578:	68 94       	set
    257a:	16 f8       	bld	r1, 6
    257c:	76 95       	lsr	r23
    257e:	67 95       	ror	r22
    2580:	57 95       	ror	r21
    2582:	47 95       	ror	r20
    2584:	16 94       	lsr	r1
    2586:	d1 f7       	brne	.-12     	; 0x257c <put_fat+0x18c>
    2588:	8a a1       	lds	r24, 0x4a
    258a:	9b a1       	lds	r25, 0x4b
    258c:	ac a1       	lds	r26, 0x4c
    258e:	bd a1       	lds	r27, 0x4d
    2590:	48 0f       	add	r20, r24
    2592:	59 1f       	adc	r21, r25
    2594:	6a 1f       	adc	r22, r26
    2596:	7b 1f       	adc	r23, r27
    2598:	ce 01       	movw	r24, r28
    259a:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
			if (res != FR_OK) break;
    259e:	88 23       	and	r24, r24
    25a0:	f9 f4       	brne	.+62     	; 0x25e0 <put_fat+0x1f0>
			p = &fs->win[clst * 4 % SS(fs)];
    25a2:	96 01       	movw	r18, r12
    25a4:	22 0f       	add	r18, r18
    25a6:	33 1f       	adc	r19, r19
    25a8:	22 0f       	add	r18, r18
    25aa:	33 1f       	adc	r19, r19
    25ac:	31 70       	andi	r19, 0x01	; 1
			val |= LD_DWORD(p) & 0xF0000000;
    25ae:	fe 01       	movw	r30, r28
    25b0:	e2 0f       	add	r30, r18
    25b2:	f3 1f       	adc	r31, r19
    25b4:	45 a9       	sts	0x45, r20
    25b6:	50 e0       	ldi	r21, 0x00	; 0
    25b8:	60 e0       	ldi	r22, 0x00	; 0
    25ba:	70 e0       	ldi	r23, 0x00	; 0
    25bc:	74 2f       	mov	r23, r20
    25be:	66 27       	eor	r22, r22
    25c0:	55 27       	eor	r21, r21
    25c2:	44 27       	eor	r20, r20
    25c4:	40 70       	andi	r20, 0x00	; 0
    25c6:	50 70       	andi	r21, 0x00	; 0
    25c8:	60 70       	andi	r22, 0x00	; 0
    25ca:	70 7f       	andi	r23, 0xF0	; 240
    25cc:	48 29       	or	r20, r8
    25ce:	59 29       	or	r21, r9
    25d0:	6a 29       	or	r22, r10
    25d2:	7b 29       	or	r23, r11
			ST_DWORD(p, val);
    25d4:	42 ab       	sts	0x52, r20
    25d6:	53 ab       	sts	0x53, r21
    25d8:	64 ab       	sts	0x54, r22
    25da:	75 ab       	sts	0x55, r23
			break;
    25dc:	01 c0       	rjmp	.+2      	; 0x25e0 <put_fat+0x1f0>

		default :
			res = FR_INT_ERR;
    25de:	82 e0       	ldi	r24, 0x02	; 2
		}
		fs->wflag = 1;
    25e0:	91 e0       	ldi	r25, 0x01	; 1
    25e2:	9c 83       	std	Y+4, r25	; 0x04
    25e4:	03 c0       	rjmp	.+6      	; 0x25ec <put_fat+0x1fc>
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
    25e6:	82 e0       	ldi	r24, 0x02	; 2
    25e8:	01 c0       	rjmp	.+2      	; 0x25ec <put_fat+0x1fc>
    25ea:	82 e0       	ldi	r24, 0x02	; 2
		}
		fs->wflag = 1;
	}

	return res;
}
    25ec:	df 91       	pop	r29
    25ee:	cf 91       	pop	r28
    25f0:	1f 91       	pop	r17
    25f2:	0f 91       	pop	r16
    25f4:	ff 90       	pop	r15
    25f6:	ef 90       	pop	r14
    25f8:	df 90       	pop	r13
    25fa:	cf 90       	pop	r12
    25fc:	bf 90       	pop	r11
    25fe:	af 90       	pop	r10
    2600:	9f 90       	pop	r9
    2602:	8f 90       	pop	r8
    2604:	7f 90       	pop	r7
    2606:	6f 90       	pop	r6
    2608:	5f 90       	pop	r5
    260a:	4f 90       	pop	r4
    260c:	08 95       	ret

0000260e <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
    260e:	2f 92       	push	r2
    2610:	3f 92       	push	r3
    2612:	4f 92       	push	r4
    2614:	5f 92       	push	r5
    2616:	6f 92       	push	r6
    2618:	7f 92       	push	r7
    261a:	8f 92       	push	r8
    261c:	9f 92       	push	r9
    261e:	af 92       	push	r10
    2620:	bf 92       	push	r11
    2622:	cf 92       	push	r12
    2624:	df 92       	push	r13
    2626:	ef 92       	push	r14
    2628:	ff 92       	push	r15
    262a:	0f 93       	push	r16
    262c:	1f 93       	push	r17
    262e:	cf 93       	push	r28
    2630:	df 93       	push	r29
    2632:	00 d0       	rcall	.+0      	; 0x2634 <create_chain+0x26>
    2634:	00 d0       	rcall	.+0      	; 0x2636 <create_chain+0x28>
    2636:	cd b7       	in	r28, 0x3d	; 61
    2638:	de b7       	in	r29, 0x3e	; 62
    263a:	1c 01       	movw	r2, r24
    263c:	49 83       	std	Y+1, r20	; 0x01
    263e:	5a 83       	std	Y+2, r21	; 0x02
    2640:	6b 83       	std	Y+3, r22	; 0x03
    2642:	7c 83       	std	Y+4, r23	; 0x04
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
    2644:	41 15       	cp	r20, r1
    2646:	51 05       	cpc	r21, r1
    2648:	61 05       	cpc	r22, r1
    264a:	71 05       	cpc	r23, r1
    264c:	c1 f4       	brne	.+48     	; 0x267e <create_chain+0x70>
		scl = fs->last_clust;			/* Get suggested start point */
    264e:	dc 01       	movw	r26, r24
    2650:	1a 96       	adiw	r26, 0x0a	; 10
    2652:	8d 90       	ld	r8, X+
    2654:	9d 90       	ld	r9, X+
    2656:	ad 90       	ld	r10, X+
    2658:	bc 90       	ld	r11, X
    265a:	1d 97       	sbiw	r26, 0x0d	; 13
		if (!scl || scl >= fs->n_fatent) scl = 1;
    265c:	81 14       	cp	r8, r1
    265e:	91 04       	cpc	r9, r1
    2660:	a1 04       	cpc	r10, r1
    2662:	b1 04       	cpc	r11, r1
    2664:	51 f1       	breq	.+84     	; 0x26ba <create_chain+0xac>
    2666:	5a 96       	adiw	r26, 0x1a	; 26
    2668:	8d 91       	ld	r24, X+
    266a:	9d 91       	ld	r25, X+
    266c:	0d 90       	ld	r0, X+
    266e:	bc 91       	ld	r27, X
    2670:	a0 2d       	mov	r26, r0
    2672:	88 16       	cp	r8, r24
    2674:	99 06       	cpc	r9, r25
    2676:	aa 06       	cpc	r10, r26
    2678:	bb 06       	cpc	r11, r27
    267a:	20 f5       	brcc	.+72     	; 0x26c4 <create_chain+0xb6>
    267c:	27 c0       	rjmp	.+78     	; 0x26cc <create_chain+0xbe>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
    267e:	49 81       	ldd	r20, Y+1	; 0x01
    2680:	5a 81       	ldd	r21, Y+2	; 0x02
    2682:	6b 81       	ldd	r22, Y+3	; 0x03
    2684:	7c 81       	ldd	r23, Y+4	; 0x04
    2686:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <get_fat>
    268a:	8b 01       	movw	r16, r22
    268c:	9c 01       	movw	r18, r24
		if (cs < 2) return 1;			/* It is an invalid cluster */
    268e:	62 30       	cpi	r22, 0x02	; 2
    2690:	71 05       	cpc	r23, r1
    2692:	81 05       	cpc	r24, r1
    2694:	91 05       	cpc	r25, r1
    2696:	08 f4       	brcc	.+2      	; 0x269a <create_chain+0x8c>
    2698:	ad c0       	rjmp	.+346    	; 0x27f4 <create_chain+0x1e6>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    269a:	f1 01       	movw	r30, r2
    269c:	82 8d       	ldd	r24, Z+26	; 0x1a
    269e:	93 8d       	ldd	r25, Z+27	; 0x1b
    26a0:	a4 8d       	ldd	r26, Z+28	; 0x1c
    26a2:	b5 8d       	ldd	r27, Z+29	; 0x1d
    26a4:	08 17       	cp	r16, r24
    26a6:	19 07       	cpc	r17, r25
    26a8:	2a 07       	cpc	r18, r26
    26aa:	3b 07       	cpc	r19, r27
    26ac:	08 f4       	brcc	.+2      	; 0x26b0 <create_chain+0xa2>
    26ae:	b6 c0       	rjmp	.+364    	; 0x281c <create_chain+0x20e>
		scl = clst;
    26b0:	89 80       	ldd	r8, Y+1	; 0x01
    26b2:	9a 80       	ldd	r9, Y+2	; 0x02
    26b4:	ab 80       	ldd	r10, Y+3	; 0x03
    26b6:	bc 80       	ldd	r11, Y+4	; 0x04
    26b8:	09 c0       	rjmp	.+18     	; 0x26cc <create_chain+0xbe>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
    26ba:	88 24       	eor	r8, r8
    26bc:	99 24       	eor	r9, r9
    26be:	54 01       	movw	r10, r8
    26c0:	83 94       	inc	r8
    26c2:	04 c0       	rjmp	.+8      	; 0x26cc <create_chain+0xbe>
    26c4:	88 24       	eor	r8, r8
    26c6:	99 24       	eor	r9, r9
    26c8:	54 01       	movw	r10, r8
    26ca:	83 94       	inc	r8
		if (cs < 2) return 1;			/* It is an invalid cluster */
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
    26cc:	75 01       	movw	r14, r10
    26ce:	64 01       	movw	r12, r8
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
    26d0:	44 24       	eor	r4, r4
    26d2:	55 24       	eor	r5, r5
    26d4:	32 01       	movw	r6, r4
    26d6:	68 94       	set
    26d8:	41 f8       	bld	r4, 1
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
    26da:	08 94       	sec
    26dc:	c1 1c       	adc	r12, r1
    26de:	d1 1c       	adc	r13, r1
    26e0:	e1 1c       	adc	r14, r1
    26e2:	f1 1c       	adc	r15, r1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
    26e4:	f1 01       	movw	r30, r2
    26e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    26e8:	93 8d       	ldd	r25, Z+27	; 0x1b
    26ea:	a4 8d       	ldd	r26, Z+28	; 0x1c
    26ec:	b5 8d       	ldd	r27, Z+29	; 0x1d
    26ee:	c8 16       	cp	r12, r24
    26f0:	d9 06       	cpc	r13, r25
    26f2:	ea 06       	cpc	r14, r26
    26f4:	fb 06       	cpc	r15, r27
    26f6:	48 f0       	brcs	.+18     	; 0x270a <create_chain+0xfc>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
    26f8:	f2 e0       	ldi	r31, 0x02	; 2
    26fa:	8f 16       	cp	r8, r31
    26fc:	91 04       	cpc	r9, r1
    26fe:	a1 04       	cpc	r10, r1
    2700:	b1 04       	cpc	r11, r1
    2702:	08 f4       	brcc	.+2      	; 0x2706 <create_chain+0xf8>
    2704:	7c c0       	rjmp	.+248    	; 0x27fe <create_chain+0x1f0>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
    2706:	73 01       	movw	r14, r6
    2708:	62 01       	movw	r12, r4
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
    270a:	c1 01       	movw	r24, r2
    270c:	b7 01       	movw	r22, r14
    270e:	a6 01       	movw	r20, r12
    2710:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <get_fat>
    2714:	8b 01       	movw	r16, r22
    2716:	9c 01       	movw	r18, r24
		if (cs == 0) break;				/* Found a free cluster */
    2718:	61 15       	cp	r22, r1
    271a:	71 05       	cpc	r23, r1
    271c:	81 05       	cpc	r24, r1
    271e:	91 05       	cpc	r25, r1
    2720:	a9 f0       	breq	.+42     	; 0x274c <create_chain+0x13e>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    2722:	0f 3f       	cpi	r16, 0xFF	; 255
    2724:	8f ef       	ldi	r24, 0xFF	; 255
    2726:	18 07       	cpc	r17, r24
    2728:	8f ef       	ldi	r24, 0xFF	; 255
    272a:	28 07       	cpc	r18, r24
    272c:	8f ef       	ldi	r24, 0xFF	; 255
    272e:	38 07       	cpc	r19, r24
    2730:	09 f4       	brne	.+2      	; 0x2734 <create_chain+0x126>
    2732:	74 c0       	rjmp	.+232    	; 0x281c <create_chain+0x20e>
    2734:	01 30       	cpi	r16, 0x01	; 1
    2736:	11 05       	cpc	r17, r1
    2738:	21 05       	cpc	r18, r1
    273a:	31 05       	cpc	r19, r1
    273c:	09 f4       	brne	.+2      	; 0x2740 <create_chain+0x132>
    273e:	6e c0       	rjmp	.+220    	; 0x281c <create_chain+0x20e>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
    2740:	c8 14       	cp	r12, r8
    2742:	d9 04       	cpc	r13, r9
    2744:	ea 04       	cpc	r14, r10
    2746:	fb 04       	cpc	r15, r11
    2748:	41 f6       	brne	.-112    	; 0x26da <create_chain+0xcc>
    274a:	5d c0       	rjmp	.+186    	; 0x2806 <create_chain+0x1f8>
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
    274c:	8c 2c       	mov	r8, r12
    274e:	4d 2c       	mov	r4, r13
    2750:	be 2c       	mov	r11, r14
    2752:	af 2c       	mov	r10, r15
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    2754:	c1 01       	movw	r24, r2
    2756:	4c 2d       	mov	r20, r12
    2758:	5d 2d       	mov	r21, r13
    275a:	6e 2d       	mov	r22, r14
    275c:	7f 2d       	mov	r23, r15
    275e:	0f ef       	ldi	r16, 0xFF	; 255
    2760:	1f ef       	ldi	r17, 0xFF	; 255
    2762:	2f ef       	ldi	r18, 0xFF	; 255
    2764:	3f e0       	ldi	r19, 0x0F	; 15
    2766:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <put_fat>
	if (res == FR_OK && clst != 0) {
    276a:	88 23       	and	r24, r24
    276c:	e9 f5       	brne	.+122    	; 0x27e8 <create_chain+0x1da>
    276e:	89 81       	ldd	r24, Y+1	; 0x01
    2770:	9a 81       	ldd	r25, Y+2	; 0x02
    2772:	ab 81       	ldd	r26, Y+3	; 0x03
    2774:	bc 81       	ldd	r27, Y+4	; 0x04
    2776:	00 97       	sbiw	r24, 0x00	; 0
    2778:	a1 05       	cpc	r26, r1
    277a:	b1 05       	cpc	r27, r1
    277c:	69 f0       	breq	.+26     	; 0x2798 <create_chain+0x18a>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    277e:	c1 01       	movw	r24, r2
    2780:	49 81       	ldd	r20, Y+1	; 0x01
    2782:	5a 81       	ldd	r21, Y+2	; 0x02
    2784:	6b 81       	ldd	r22, Y+3	; 0x03
    2786:	7c 81       	ldd	r23, Y+4	; 0x04
    2788:	0c 2d       	mov	r16, r12
    278a:	1d 2d       	mov	r17, r13
    278c:	2e 2d       	mov	r18, r14
    278e:	3f 2d       	mov	r19, r15
    2790:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <put_fat>
	}
	if (res == FR_OK) {
    2794:	88 23       	and	r24, r24
    2796:	41 f5       	brne	.+80     	; 0x27e8 <create_chain+0x1da>
		fs->last_clust = ncl;			/* Update FSINFO */
    2798:	d1 01       	movw	r26, r2
    279a:	1a 96       	adiw	r26, 0x0a	; 10
    279c:	8c 92       	st	X, r8
    279e:	1a 97       	sbiw	r26, 0x0a	; 10
    27a0:	1b 96       	adiw	r26, 0x0b	; 11
    27a2:	4c 92       	st	X, r4
    27a4:	1b 97       	sbiw	r26, 0x0b	; 11
    27a6:	1c 96       	adiw	r26, 0x0c	; 12
    27a8:	bc 92       	st	X, r11
    27aa:	1c 97       	sbiw	r26, 0x0c	; 12
    27ac:	1d 96       	adiw	r26, 0x0d	; 13
    27ae:	ac 92       	st	X, r10
    27b0:	1d 97       	sbiw	r26, 0x0d	; 13
		if (fs->free_clust != 0xFFFFFFFF) {
    27b2:	1e 96       	adiw	r26, 0x0e	; 14
    27b4:	8d 91       	ld	r24, X+
    27b6:	9d 91       	ld	r25, X+
    27b8:	0d 90       	ld	r0, X+
    27ba:	bc 91       	ld	r27, X
    27bc:	a0 2d       	mov	r26, r0
    27be:	8f 3f       	cpi	r24, 0xFF	; 255
    27c0:	ef ef       	ldi	r30, 0xFF	; 255
    27c2:	9e 07       	cpc	r25, r30
    27c4:	ef ef       	ldi	r30, 0xFF	; 255
    27c6:	ae 07       	cpc	r26, r30
    27c8:	ef ef       	ldi	r30, 0xFF	; 255
    27ca:	be 07       	cpc	r27, r30
    27cc:	01 f1       	breq	.+64     	; 0x280e <create_chain+0x200>
			fs->free_clust--;
    27ce:	01 97       	sbiw	r24, 0x01	; 1
    27d0:	a1 09       	sbc	r26, r1
    27d2:	b1 09       	sbc	r27, r1
    27d4:	f1 01       	movw	r30, r2
    27d6:	86 87       	std	Z+14, r24	; 0x0e
    27d8:	97 87       	std	Z+15, r25	; 0x0f
    27da:	a0 8b       	std	Z+16, r26	; 0x10
    27dc:	b1 8b       	std	Z+17, r27	; 0x11
			fs->fsi_flag = 1;
    27de:	81 e0       	ldi	r24, 0x01	; 1
    27e0:	85 83       	std	Z+5, r24	; 0x05
    27e2:	97 01       	movw	r18, r14
    27e4:	86 01       	movw	r16, r12
    27e6:	1a c0       	rjmp	.+52     	; 0x281c <create_chain+0x20e>
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    27e8:	81 30       	cpi	r24, 0x01	; 1
    27ea:	a1 f4       	brne	.+40     	; 0x2814 <create_chain+0x206>
    27ec:	0f ef       	ldi	r16, 0xFF	; 255
    27ee:	1f ef       	ldi	r17, 0xFF	; 255
    27f0:	98 01       	movw	r18, r16
    27f2:	14 c0       	rjmp	.+40     	; 0x281c <create_chain+0x20e>
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* It is an invalid cluster */
    27f4:	01 e0       	ldi	r16, 0x01	; 1
    27f6:	10 e0       	ldi	r17, 0x00	; 0
    27f8:	20 e0       	ldi	r18, 0x00	; 0
    27fa:	30 e0       	ldi	r19, 0x00	; 0
    27fc:	0f c0       	rjmp	.+30     	; 0x281c <create_chain+0x20e>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
    27fe:	00 e0       	ldi	r16, 0x00	; 0
    2800:	10 e0       	ldi	r17, 0x00	; 0
    2802:	98 01       	movw	r18, r16
    2804:	0b c0       	rjmp	.+22     	; 0x281c <create_chain+0x20e>
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
    2806:	00 e0       	ldi	r16, 0x00	; 0
    2808:	10 e0       	ldi	r17, 0x00	; 0
    280a:	98 01       	movw	r18, r16
    280c:	07 c0       	rjmp	.+14     	; 0x281c <create_chain+0x20e>
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
    280e:	97 01       	movw	r18, r14
    2810:	86 01       	movw	r16, r12
    2812:	04 c0       	rjmp	.+8      	; 0x281c <create_chain+0x20e>
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    2814:	01 e0       	ldi	r16, 0x01	; 1
    2816:	10 e0       	ldi	r17, 0x00	; 0
    2818:	20 e0       	ldi	r18, 0x00	; 0
    281a:	30 e0       	ldi	r19, 0x00	; 0
	}

	return ncl;		/* Return new cluster number or error code */
}
    281c:	60 2f       	mov	r22, r16
    281e:	71 2f       	mov	r23, r17
    2820:	82 2f       	mov	r24, r18
    2822:	93 2f       	mov	r25, r19
    2824:	0f 90       	pop	r0
    2826:	0f 90       	pop	r0
    2828:	0f 90       	pop	r0
    282a:	0f 90       	pop	r0
    282c:	df 91       	pop	r29
    282e:	cf 91       	pop	r28
    2830:	1f 91       	pop	r17
    2832:	0f 91       	pop	r16
    2834:	ff 90       	pop	r15
    2836:	ef 90       	pop	r14
    2838:	df 90       	pop	r13
    283a:	cf 90       	pop	r12
    283c:	bf 90       	pop	r11
    283e:	af 90       	pop	r10
    2840:	9f 90       	pop	r9
    2842:	8f 90       	pop	r8
    2844:	7f 90       	pop	r7
    2846:	6f 90       	pop	r6
    2848:	5f 90       	pop	r5
    284a:	4f 90       	pop	r4
    284c:	3f 90       	pop	r3
    284e:	2f 90       	pop	r2
    2850:	08 95       	ret

00002852 <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
    2852:	8f 92       	push	r8
    2854:	9f 92       	push	r9
    2856:	af 92       	push	r10
    2858:	bf 92       	push	r11
    285a:	cf 92       	push	r12
    285c:	df 92       	push	r13
    285e:	ef 92       	push	r14
    2860:	ff 92       	push	r15
    2862:	0f 93       	push	r16
    2864:	1f 93       	push	r17
    2866:	cf 93       	push	r28
    2868:	df 93       	push	r29
    286a:	8c 01       	movw	r16, r24
    286c:	eb 01       	movw	r28, r22
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
    286e:	dc 01       	movw	r26, r24
    2870:	14 96       	adiw	r26, 0x04	; 4
    2872:	ed 90       	ld	r14, X+
    2874:	fc 90       	ld	r15, X
    2876:	15 97       	sbiw	r26, 0x05	; 5
    2878:	08 94       	sec
    287a:	e1 1c       	adc	r14, r1
    287c:	f1 1c       	adc	r15, r1
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    287e:	e1 14       	cp	r14, r1
    2880:	f1 04       	cpc	r15, r1
    2882:	09 f4       	brne	.+2      	; 0x2886 <dir_next+0x34>
    2884:	0b c1       	rjmp	.+534    	; 0x2a9c <dir_next+0x24a>
    2886:	1e 96       	adiw	r26, 0x0e	; 14
    2888:	8d 91       	ld	r24, X+
    288a:	9d 91       	ld	r25, X+
    288c:	0d 90       	ld	r0, X+
    288e:	bc 91       	ld	r27, X
    2890:	a0 2d       	mov	r26, r0
    2892:	00 97       	sbiw	r24, 0x00	; 0
    2894:	a1 05       	cpc	r26, r1
    2896:	b1 05       	cpc	r27, r1
    2898:	09 f4       	brne	.+2      	; 0x289c <dir_next+0x4a>
    289a:	02 c1       	rjmp	.+516    	; 0x2aa0 <dir_next+0x24e>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    289c:	0f 2e       	mov	r0, r31
    289e:	ff e0       	ldi	r31, 0x0F	; 15
    28a0:	cf 2e       	mov	r12, r31
    28a2:	dd 24       	eor	r13, r13
    28a4:	f0 2d       	mov	r31, r0
    28a6:	ce 20       	and	r12, r14
    28a8:	df 20       	and	r13, r15
    28aa:	c1 14       	cp	r12, r1
    28ac:	d1 04       	cpc	r13, r1
    28ae:	09 f0       	breq	.+2      	; 0x28b2 <dir_next+0x60>
    28b0:	da c0       	rjmp	.+436    	; 0x2a66 <dir_next+0x214>
		dj->sect++;					/* Next sector */
    28b2:	01 96       	adiw	r24, 0x01	; 1
    28b4:	a1 1d       	adc	r26, r1
    28b6:	b1 1d       	adc	r27, r1
    28b8:	f8 01       	movw	r30, r16
    28ba:	86 87       	std	Z+14, r24	; 0x0e
    28bc:	97 87       	std	Z+15, r25	; 0x0f
    28be:	a0 8b       	std	Z+16, r26	; 0x10
    28c0:	b1 8b       	std	Z+17, r27	; 0x11

		if (dj->clust == 0) {	/* Static table */
    28c2:	42 85       	ldd	r20, Z+10	; 0x0a
    28c4:	53 85       	ldd	r21, Z+11	; 0x0b
    28c6:	64 85       	ldd	r22, Z+12	; 0x0c
    28c8:	75 85       	ldd	r23, Z+13	; 0x0d
    28ca:	41 15       	cp	r20, r1
    28cc:	51 05       	cpc	r21, r1
    28ce:	61 05       	cpc	r22, r1
    28d0:	71 05       	cpc	r23, r1
    28d2:	51 f4       	brne	.+20     	; 0x28e8 <dir_next+0x96>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    28d4:	01 90       	ld	r0, Z+
    28d6:	f0 81       	ld	r31, Z
    28d8:	e0 2d       	mov	r30, r0
    28da:	80 85       	ldd	r24, Z+8	; 0x08
    28dc:	91 85       	ldd	r25, Z+9	; 0x09
    28de:	e8 16       	cp	r14, r24
    28e0:	f9 06       	cpc	r15, r25
    28e2:	08 f0       	brcs	.+2      	; 0x28e6 <dir_next+0x94>
    28e4:	df c0       	rjmp	.+446    	; 0x2aa4 <dir_next+0x252>
    28e6:	bf c0       	rjmp	.+382    	; 0x2a66 <dir_next+0x214>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    28e8:	01 90       	ld	r0, Z+
    28ea:	f0 81       	ld	r31, Z
    28ec:	e0 2d       	mov	r30, r0
    28ee:	82 81       	ldd	r24, Z+2	; 0x02
    28f0:	90 e0       	ldi	r25, 0x00	; 0
    28f2:	01 97       	sbiw	r24, 0x01	; 1
    28f4:	97 01       	movw	r18, r14
    28f6:	32 95       	swap	r19
    28f8:	22 95       	swap	r18
    28fa:	2f 70       	andi	r18, 0x0F	; 15
    28fc:	23 27       	eor	r18, r19
    28fe:	3f 70       	andi	r19, 0x0F	; 15
    2900:	23 27       	eor	r18, r19
    2902:	82 23       	and	r24, r18
    2904:	93 23       	and	r25, r19
    2906:	00 97       	sbiw	r24, 0x00	; 0
    2908:	09 f0       	breq	.+2      	; 0x290c <dir_next+0xba>
    290a:	ad c0       	rjmp	.+346    	; 0x2a66 <dir_next+0x214>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    290c:	cf 01       	movw	r24, r30
    290e:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <get_fat>
    2912:	4b 01       	movw	r8, r22
    2914:	5c 01       	movw	r10, r24
				if (clst <= 1) return FR_INT_ERR;
    2916:	62 30       	cpi	r22, 0x02	; 2
    2918:	71 05       	cpc	r23, r1
    291a:	81 05       	cpc	r24, r1
    291c:	91 05       	cpc	r25, r1
    291e:	08 f4       	brcc	.+2      	; 0x2922 <dir_next+0xd0>
    2920:	c3 c0       	rjmp	.+390    	; 0x2aa8 <dir_next+0x256>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2922:	6f 3f       	cpi	r22, 0xFF	; 255
    2924:	ef ef       	ldi	r30, 0xFF	; 255
    2926:	7e 07       	cpc	r23, r30
    2928:	ef ef       	ldi	r30, 0xFF	; 255
    292a:	8e 07       	cpc	r24, r30
    292c:	ef ef       	ldi	r30, 0xFF	; 255
    292e:	9e 07       	cpc	r25, r30
    2930:	09 f4       	brne	.+2      	; 0x2934 <dir_next+0xe2>
    2932:	bc c0       	rjmp	.+376    	; 0x2aac <dir_next+0x25a>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    2934:	d8 01       	movw	r26, r16
    2936:	ed 91       	ld	r30, X+
    2938:	fc 91       	ld	r31, X
    293a:	82 8d       	ldd	r24, Z+26	; 0x1a
    293c:	93 8d       	ldd	r25, Z+27	; 0x1b
    293e:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2940:	b5 8d       	ldd	r27, Z+29	; 0x1d
    2942:	88 16       	cp	r8, r24
    2944:	99 06       	cpc	r9, r25
    2946:	aa 06       	cpc	r10, r26
    2948:	bb 06       	cpc	r11, r27
    294a:	08 f4       	brcc	.+2      	; 0x294e <dir_next+0xfc>
    294c:	7a c0       	rjmp	.+244    	; 0x2a42 <dir_next+0x1f0>
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    294e:	20 97       	sbiw	r28, 0x00	; 0
    2950:	09 f4       	brne	.+2      	; 0x2954 <dir_next+0x102>
    2952:	ae c0       	rjmp	.+348    	; 0x2ab0 <dir_next+0x25e>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
    2954:	d8 01       	movw	r26, r16
    2956:	1a 96       	adiw	r26, 0x0a	; 10
    2958:	4d 91       	ld	r20, X+
    295a:	5d 91       	ld	r21, X+
    295c:	6d 91       	ld	r22, X+
    295e:	7c 91       	ld	r23, X
    2960:	1d 97       	sbiw	r26, 0x0d	; 13
    2962:	cf 01       	movw	r24, r30
    2964:	0e 94 07 13 	call	0x260e	; 0x260e <create_chain>
    2968:	4b 01       	movw	r8, r22
    296a:	5c 01       	movw	r10, r24
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    296c:	61 15       	cp	r22, r1
    296e:	71 05       	cpc	r23, r1
    2970:	81 05       	cpc	r24, r1
    2972:	91 05       	cpc	r25, r1
    2974:	09 f4       	brne	.+2      	; 0x2978 <dir_next+0x126>
    2976:	9e c0       	rjmp	.+316    	; 0x2ab4 <dir_next+0x262>
					if (clst == 1) return FR_INT_ERR;
    2978:	61 30       	cpi	r22, 0x01	; 1
    297a:	71 05       	cpc	r23, r1
    297c:	81 05       	cpc	r24, r1
    297e:	91 05       	cpc	r25, r1
    2980:	09 f4       	brne	.+2      	; 0x2984 <dir_next+0x132>
    2982:	9a c0       	rjmp	.+308    	; 0x2ab8 <dir_next+0x266>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2984:	6f 3f       	cpi	r22, 0xFF	; 255
    2986:	ef ef       	ldi	r30, 0xFF	; 255
    2988:	7e 07       	cpc	r23, r30
    298a:	ef ef       	ldi	r30, 0xFF	; 255
    298c:	8e 07       	cpc	r24, r30
    298e:	ef ef       	ldi	r30, 0xFF	; 255
    2990:	9e 07       	cpc	r25, r30
    2992:	09 f4       	brne	.+2      	; 0x2996 <dir_next+0x144>
    2994:	93 c0       	rjmp	.+294    	; 0x2abc <dir_next+0x26a>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    2996:	d8 01       	movw	r26, r16
    2998:	8d 91       	ld	r24, X+
    299a:	9c 91       	ld	r25, X
    299c:	40 e0       	ldi	r20, 0x00	; 0
    299e:	50 e0       	ldi	r21, 0x00	; 0
    29a0:	ba 01       	movw	r22, r20
    29a2:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
    29a6:	88 23       	and	r24, r24
    29a8:	09 f0       	breq	.+2      	; 0x29ac <dir_next+0x15a>
    29aa:	8a c0       	rjmp	.+276    	; 0x2ac0 <dir_next+0x26e>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
    29ac:	f8 01       	movw	r30, r16
    29ae:	80 81       	ld	r24, Z
    29b0:	91 81       	ldd	r25, Z+1	; 0x01
    29b2:	c2 96       	adiw	r24, 0x32	; 50
    29b4:	60 e0       	ldi	r22, 0x00	; 0
    29b6:	70 e0       	ldi	r23, 0x00	; 0
    29b8:	20 e0       	ldi	r18, 0x00	; 0
    29ba:	32 e0       	ldi	r19, 0x02	; 2
    29bc:	40 e0       	ldi	r20, 0x00	; 0
    29be:	50 e0       	ldi	r21, 0x00	; 0
    29c0:	0e 94 b3 08 	call	0x1166	; 0x1166 <mem_set>
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    29c4:	d8 01       	movw	r26, r16
    29c6:	cd 91       	ld	r28, X+
    29c8:	dc 91       	ld	r29, X
    29ca:	ce 01       	movw	r24, r28
    29cc:	b5 01       	movw	r22, r10
    29ce:	a4 01       	movw	r20, r8
    29d0:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <clust2sect>
    29d4:	dc 01       	movw	r26, r24
    29d6:	cb 01       	movw	r24, r22
    29d8:	8e a7       	lds	r24, 0x7e
    29da:	9f a7       	lds	r25, 0x7f
    29dc:	a8 ab       	sts	0x58, r26
    29de:	b9 ab       	sts	0x59, r27
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    29e0:	c0 e0       	ldi	r28, 0x00	; 0
						dj->fs->wflag = 1;
    29e2:	d1 e0       	ldi	r29, 0x01	; 1
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    29e4:	1b c0       	rjmp	.+54     	; 0x2a1c <dir_next+0x1ca>
						dj->fs->wflag = 1;
    29e6:	d4 83       	std	Z+4, r29	; 0x04
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    29e8:	f8 01       	movw	r30, r16
    29ea:	80 81       	ld	r24, Z
    29ec:	91 81       	ldd	r25, Z+1	; 0x01
    29ee:	40 e0       	ldi	r20, 0x00	; 0
    29f0:	50 e0       	ldi	r21, 0x00	; 0
    29f2:	ba 01       	movw	r22, r20
    29f4:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
    29f8:	88 23       	and	r24, r24
    29fa:	09 f0       	breq	.+2      	; 0x29fe <dir_next+0x1ac>
    29fc:	63 c0       	rjmp	.+198    	; 0x2ac4 <dir_next+0x272>
						dj->fs->winsect++;
    29fe:	d8 01       	movw	r26, r16
    2a00:	ed 91       	ld	r30, X+
    2a02:	fc 91       	ld	r31, X
    2a04:	86 a5       	lds	r24, 0x66
    2a06:	97 a5       	lds	r25, 0x67
    2a08:	a0 a9       	sts	0x40, r26
    2a0a:	b1 a9       	sts	0x41, r27
    2a0c:	01 96       	adiw	r24, 0x01	; 1
    2a0e:	a1 1d       	adc	r26, r1
    2a10:	b1 1d       	adc	r27, r1
    2a12:	86 a7       	lds	r24, 0x76
    2a14:	97 a7       	lds	r25, 0x77
    2a16:	a0 ab       	sts	0x50, r26
    2a18:	b1 ab       	sts	0x51, r27
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2a1a:	cf 5f       	subi	r28, 0xFF	; 255
    2a1c:	d8 01       	movw	r26, r16
    2a1e:	ed 91       	ld	r30, X+
    2a20:	fc 91       	ld	r31, X
    2a22:	11 97       	sbiw	r26, 0x01	; 1
    2a24:	82 81       	ldd	r24, Z+2	; 0x02
    2a26:	c8 17       	cp	r28, r24
    2a28:	f0 f2       	brcs	.-68     	; 0x29e6 <dir_next+0x194>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
    2a2a:	86 a5       	lds	r24, 0x66
    2a2c:	97 a5       	lds	r25, 0x67
    2a2e:	a0 a9       	sts	0x40, r26
    2a30:	b1 a9       	sts	0x41, r27
    2a32:	8c 1b       	sub	r24, r28
    2a34:	91 09       	sbc	r25, r1
    2a36:	a1 09       	sbc	r26, r1
    2a38:	b1 09       	sbc	r27, r1
    2a3a:	86 a7       	lds	r24, 0x76
    2a3c:	97 a7       	lds	r25, 0x77
    2a3e:	a0 ab       	sts	0x50, r26
    2a40:	b1 ab       	sts	0x51, r27
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
    2a42:	f8 01       	movw	r30, r16
    2a44:	82 86       	std	Z+10, r8	; 0x0a
    2a46:	93 86       	std	Z+11, r9	; 0x0b
    2a48:	a4 86       	std	Z+12, r10	; 0x0c
    2a4a:	b5 86       	std	Z+13, r11	; 0x0d
				dj->sect = clust2sect(dj->fs, clst);
    2a4c:	80 81       	ld	r24, Z
    2a4e:	91 81       	ldd	r25, Z+1	; 0x01
    2a50:	b5 01       	movw	r22, r10
    2a52:	a4 01       	movw	r20, r8
    2a54:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <clust2sect>
    2a58:	dc 01       	movw	r26, r24
    2a5a:	cb 01       	movw	r24, r22
    2a5c:	f8 01       	movw	r30, r16
    2a5e:	86 87       	std	Z+14, r24	; 0x0e
    2a60:	97 87       	std	Z+15, r25	; 0x0f
    2a62:	a0 8b       	std	Z+16, r26	; 0x10
    2a64:	b1 8b       	std	Z+17, r27	; 0x11
			}
		}
	}

	dj->index = i;
    2a66:	d8 01       	movw	r26, r16
    2a68:	15 96       	adiw	r26, 0x05	; 5
    2a6a:	fc 92       	st	X, r15
    2a6c:	ee 92       	st	-X, r14
    2a6e:	14 97       	sbiw	r26, 0x04	; 4
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    2a70:	8d 91       	ld	r24, X+
    2a72:	9c 91       	ld	r25, X
    2a74:	11 97       	sbiw	r26, 0x01	; 1
    2a76:	c2 96       	adiw	r24, 0x32	; 50
    2a78:	cc 0c       	add	r12, r12
    2a7a:	dd 1c       	adc	r13, r13
    2a7c:	cc 0c       	add	r12, r12
    2a7e:	dd 1c       	adc	r13, r13
    2a80:	cc 0c       	add	r12, r12
    2a82:	dd 1c       	adc	r13, r13
    2a84:	cc 0c       	add	r12, r12
    2a86:	dd 1c       	adc	r13, r13
    2a88:	cc 0c       	add	r12, r12
    2a8a:	dd 1c       	adc	r13, r13
    2a8c:	8c 0d       	add	r24, r12
    2a8e:	9d 1d       	adc	r25, r13
    2a90:	53 96       	adiw	r26, 0x13	; 19
    2a92:	9c 93       	st	X, r25
    2a94:	8e 93       	st	-X, r24
    2a96:	52 97       	sbiw	r26, 0x12	; 18

	return FR_OK;
    2a98:	80 e0       	ldi	r24, 0x00	; 0
    2a9a:	15 c0       	rjmp	.+42     	; 0x2ac6 <dir_next+0x274>


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
    2a9c:	84 e0       	ldi	r24, 0x04	; 4
    2a9e:	13 c0       	rjmp	.+38     	; 0x2ac6 <dir_next+0x274>
    2aa0:	84 e0       	ldi	r24, 0x04	; 4
    2aa2:	11 c0       	rjmp	.+34     	; 0x2ac6 <dir_next+0x274>
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
    2aa4:	84 e0       	ldi	r24, 0x04	; 4
    2aa6:	0f c0       	rjmp	.+30     	; 0x2ac6 <dir_next+0x274>
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
    2aa8:	82 e0       	ldi	r24, 0x02	; 2
    2aaa:	0d c0       	rjmp	.+26     	; 0x2ac6 <dir_next+0x274>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2aac:	81 e0       	ldi	r24, 0x01	; 1
    2aae:	0b c0       	rjmp	.+22     	; 0x2ac6 <dir_next+0x274>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    2ab0:	84 e0       	ldi	r24, 0x04	; 4
    2ab2:	09 c0       	rjmp	.+18     	; 0x2ac6 <dir_next+0x274>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    2ab4:	87 e0       	ldi	r24, 0x07	; 7
    2ab6:	07 c0       	rjmp	.+14     	; 0x2ac6 <dir_next+0x274>
					if (clst == 1) return FR_INT_ERR;
    2ab8:	82 e0       	ldi	r24, 0x02	; 2
    2aba:	05 c0       	rjmp	.+10     	; 0x2ac6 <dir_next+0x274>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2abc:	81 e0       	ldi	r24, 0x01	; 1
    2abe:	03 c0       	rjmp	.+6      	; 0x2ac6 <dir_next+0x274>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    2ac0:	81 e0       	ldi	r24, 0x01	; 1
    2ac2:	01 c0       	rjmp	.+2      	; 0x2ac6 <dir_next+0x274>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    2ac4:	81 e0       	ldi	r24, 0x01	; 1

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
}
    2ac6:	df 91       	pop	r29
    2ac8:	cf 91       	pop	r28
    2aca:	1f 91       	pop	r17
    2acc:	0f 91       	pop	r16
    2ace:	ff 90       	pop	r15
    2ad0:	ef 90       	pop	r14
    2ad2:	df 90       	pop	r13
    2ad4:	cf 90       	pop	r12
    2ad6:	bf 90       	pop	r11
    2ad8:	af 90       	pop	r10
    2ada:	9f 90       	pop	r9
    2adc:	8f 90       	pop	r8
    2ade:	08 95       	ret

00002ae0 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
    2ae0:	2f 92       	push	r2
    2ae2:	3f 92       	push	r3
    2ae4:	4f 92       	push	r4
    2ae6:	5f 92       	push	r5
    2ae8:	6f 92       	push	r6
    2aea:	7f 92       	push	r7
    2aec:	8f 92       	push	r8
    2aee:	9f 92       	push	r9
    2af0:	af 92       	push	r10
    2af2:	bf 92       	push	r11
    2af4:	cf 92       	push	r12
    2af6:	df 92       	push	r13
    2af8:	ef 92       	push	r14
    2afa:	ff 92       	push	r15
    2afc:	0f 93       	push	r16
    2afe:	1f 93       	push	r17
    2b00:	cf 93       	push	r28
    2b02:	df 93       	push	r29
    2b04:	cd b7       	in	r28, 0x3d	; 61
    2b06:	de b7       	in	r29, 0x3e	; 62
    2b08:	2b 97       	sbiw	r28, 0x0b	; 11
    2b0a:	0f b6       	in	r0, 0x3f	; 63
    2b0c:	f8 94       	cli
    2b0e:	de bf       	out	0x3e, r29	; 62
    2b10:	0f be       	out	0x3f, r0	; 63
    2b12:	cd bf       	out	0x3d, r28	; 61
    2b14:	8c 01       	movw	r16, r24
    2b16:	2b 01       	movw	r4, r22
	FRESULT res;
	BYTE *dir, ns;


#if _FS_RPATH
	if (*path == '/' || *path == '\\') { /* There is a heading separator */
    2b18:	db 01       	movw	r26, r22
    2b1a:	8c 91       	ld	r24, X
    2b1c:	8f 32       	cpi	r24, 0x2F	; 47
    2b1e:	11 f0       	breq	.+4      	; 0x2b24 <follow_path+0x44>
    2b20:	8c 35       	cpi	r24, 0x5C	; 92
    2b22:	49 f4       	brne	.+18     	; 0x2b36 <follow_path+0x56>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
    2b24:	08 94       	sec
    2b26:	41 1c       	adc	r4, r1
    2b28:	51 1c       	adc	r5, r1
    2b2a:	f8 01       	movw	r30, r16
    2b2c:	16 82       	std	Z+6, r1	; 0x06
    2b2e:	17 82       	std	Z+7, r1	; 0x07
    2b30:	10 86       	std	Z+8, r1	; 0x08
    2b32:	11 86       	std	Z+9, r1	; 0x09
    2b34:	0c c0       	rjmp	.+24     	; 0x2b4e <follow_path+0x6e>
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
    2b36:	d8 01       	movw	r26, r16
    2b38:	ed 91       	ld	r30, X+
    2b3a:	fc 91       	ld	r31, X
    2b3c:	86 89       	ldd	r24, Z+22	; 0x16
    2b3e:	97 89       	ldd	r25, Z+23	; 0x17
    2b40:	a0 8d       	ldd	r26, Z+24	; 0x18
    2b42:	b1 8d       	ldd	r27, Z+25	; 0x19
    2b44:	f8 01       	movw	r30, r16
    2b46:	86 83       	std	Z+6, r24	; 0x06
    2b48:	97 83       	std	Z+7, r25	; 0x07
    2b4a:	a0 87       	std	Z+8, r26	; 0x08
    2b4c:	b1 87       	std	Z+9, r27	; 0x09
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    2b4e:	d2 01       	movw	r26, r4
    2b50:	8c 91       	ld	r24, X
    2b52:	80 32       	cpi	r24, 0x20	; 32
    2b54:	48 f4       	brcc	.+18     	; 0x2b68 <follow_path+0x88>
		res = dir_sdi(dj, 0);
    2b56:	c8 01       	movw	r24, r16
    2b58:	60 e0       	ldi	r22, 0x00	; 0
    2b5a:	70 e0       	ldi	r23, 0x00	; 0
    2b5c:	0e 94 15 11 	call	0x222a	; 0x222a <dir_sdi>
		dj->dir = 0;
    2b60:	f8 01       	movw	r30, r16
    2b62:	13 8a       	std	Z+19, r1	; 0x13
    2b64:	12 8a       	std	Z+18, r1	; 0x12
    2b66:	a5 c1       	rjmp	.+842    	; 0x2eb2 <follow_path+0x3d2>
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    2b68:	f8 e0       	ldi	r31, 0x08	; 8
    2b6a:	fa 83       	std	Y+2, r31	; 0x02
    2b6c:	1b 82       	std	Y+3, r1	; 0x03
    2b6e:	1c 82       	std	Y+4, r1	; 0x04
    2b70:	1d 82       	std	Y+5, r1	; 0x05
    2b72:	2b e0       	ldi	r18, 0x0B	; 11
    2b74:	2e 83       	std	Y+6, r18	; 0x06
    2b76:	1f 82       	std	Y+7, r1	; 0x07
    2b78:	18 86       	std	Y+8, r1	; 0x08
    2b7a:	19 86       	std	Y+9, r1	; 0x09
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
		res = dir_sdi(dj, 0);
		dj->dir = 0;
    2b7c:	f2 01       	movw	r30, r4
    2b7e:	9f 01       	movw	r18, r30
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    2b80:	81 91       	ld	r24, Z+
    2b82:	8f 32       	cpi	r24, 0x2F	; 47
    2b84:	e1 f3       	breq	.-8      	; 0x2b7e <follow_path+0x9e>
    2b86:	8c 35       	cpi	r24, 0x5C	; 92
    2b88:	d1 f3       	breq	.-12     	; 0x2b7e <follow_path+0x9e>
    2b8a:	3b 87       	std	Y+11, r19	; 0x0b
    2b8c:	2a 87       	std	Y+10, r18	; 0x0a
	sfn = dj->fn;
    2b8e:	d8 01       	movw	r26, r16
    2b90:	54 96       	adiw	r26, 0x14	; 20
    2b92:	2d 90       	ld	r2, X+
    2b94:	3c 90       	ld	r3, X
    2b96:	55 97       	sbiw	r26, 0x15	; 21
	mem_set(sfn, ' ', 11);
    2b98:	c1 01       	movw	r24, r2
    2b9a:	60 e2       	ldi	r22, 0x20	; 32
    2b9c:	70 e0       	ldi	r23, 0x00	; 0
    2b9e:	2b e0       	ldi	r18, 0x0B	; 11
    2ba0:	30 e0       	ldi	r19, 0x00	; 0
    2ba2:	40 e0       	ldi	r20, 0x00	; 0
    2ba4:	50 e0       	ldi	r21, 0x00	; 0
    2ba6:	0e 94 b3 08 	call	0x1166	; 0x1166 <mem_set>
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
    2baa:	ea 85       	ldd	r30, Y+10	; 0x0a
    2bac:	fb 85       	ldd	r31, Y+11	; 0x0b
    2bae:	80 81       	ld	r24, Z
    2bb0:	8e 32       	cpi	r24, 0x2E	; 46
    2bb2:	89 f5       	brne	.+98     	; 0x2c16 <follow_path+0x136>
		for (;;) {
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
    2bb4:	ee e2       	ldi	r30, 0x2E	; 46
    2bb6:	d1 01       	movw	r26, r2
    2bb8:	ec 93       	st	X, r30
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2bba:	aa 85       	ldd	r26, Y+10	; 0x0a
    2bbc:	bb 85       	ldd	r27, Y+11	; 0x0b
    2bbe:	11 96       	adiw	r26, 0x01	; 1
    2bc0:	2c 91       	ld	r18, X
    2bc2:	11 97       	sbiw	r26, 0x01	; 1
			if (c != '.' || si >= 3) break;
    2bc4:	2e 32       	cpi	r18, 0x2E	; 46
    2bc6:	61 f4       	brne	.+24     	; 0x2be0 <follow_path+0x100>
			sfn[i++] = c;
    2bc8:	f1 01       	movw	r30, r2
    2bca:	21 83       	std	Z+1, r18	; 0x01
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2bcc:	12 96       	adiw	r26, 0x02	; 2
    2bce:	2c 91       	ld	r18, X
    2bd0:	12 97       	sbiw	r26, 0x02	; 2
			if (c != '.' || si >= 3) break;
    2bd2:	2e 32       	cpi	r18, 0x2E	; 46
    2bd4:	71 f0       	breq	.+28     	; 0x2bf2 <follow_path+0x112>
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2bd6:	83 e0       	ldi	r24, 0x03	; 3
    2bd8:	90 e0       	ldi	r25, 0x00	; 0
    2bda:	a0 e0       	ldi	r26, 0x00	; 0
    2bdc:	b0 e0       	ldi	r27, 0x00	; 0
    2bde:	04 c0       	rjmp	.+8      	; 0x2be8 <follow_path+0x108>
    2be0:	82 e0       	ldi	r24, 0x02	; 2
    2be2:	90 e0       	ldi	r25, 0x00	; 0
    2be4:	a0 e0       	ldi	r26, 0x00	; 0
    2be6:	b0 e0       	ldi	r27, 0x00	; 0
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    2be8:	2f 32       	cpi	r18, 0x2F	; 47
    2bea:	59 f0       	breq	.+22     	; 0x2c02 <follow_path+0x122>
    2bec:	2c 35       	cpi	r18, 0x5C	; 92
    2bee:	49 f0       	breq	.+18     	; 0x2c02 <follow_path+0x122>
    2bf0:	04 c0       	rjmp	.+8      	; 0x2bfa <follow_path+0x11a>
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2bf2:	83 e0       	ldi	r24, 0x03	; 3
    2bf4:	90 e0       	ldi	r25, 0x00	; 0
    2bf6:	a0 e0       	ldi	r26, 0x00	; 0
    2bf8:	b0 e0       	ldi	r27, 0x00	; 0
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    2bfa:	21 32       	cpi	r18, 0x21	; 33
    2bfc:	08 f0       	brcs	.+2      	; 0x2c00 <follow_path+0x120>
    2bfe:	48 c1       	rjmp	.+656    	; 0x2e90 <follow_path+0x3b0>
    2c00:	71 c1       	rjmp	.+738    	; 0x2ee4 <follow_path+0x404>
		*path = &p[si];									/* Return pointer to the next segment */
    2c02:	4a 84       	ldd	r4, Y+10	; 0x0a
    2c04:	5b 84       	ldd	r5, Y+11	; 0x0b
    2c06:	48 0e       	add	r4, r24
    2c08:	59 1e       	adc	r5, r25
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
    2c0a:	80 e2       	ldi	r24, 0x20	; 32
    2c0c:	d1 01       	movw	r26, r2
    2c0e:	1b 96       	adiw	r26, 0x0b	; 11
    2c10:	8c 93       	st	X, r24
    2c12:	1b 97       	sbiw	r26, 0x0b	; 11
    2c14:	74 c1       	rjmp	.+744    	; 0x2efe <follow_path+0x41e>
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
    2c16:	cc 24       	eor	r12, r12
    2c18:	dd 24       	eor	r13, r13
    2c1a:	76 01       	movw	r14, r12
    2c1c:	40 e0       	ldi	r20, 0x00	; 0
    2c1e:	50 e0       	ldi	r21, 0x00	; 0
    2c20:	ba 01       	movw	r22, r20
    2c22:	88 24       	eor	r8, r8
    2c24:	99 24       	eor	r9, r9
    2c26:	54 01       	movw	r10, r8
    2c28:	68 94       	set
    2c2a:	83 f8       	bld	r8, 3
    2c2c:	19 82       	std	Y+1, r1	; 0x01
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    2c2e:	ea 85       	ldd	r30, Y+10	; 0x0a
    2c30:	fb 85       	ldd	r31, Y+11	; 0x0b
    2c32:	e4 0f       	add	r30, r20
    2c34:	f5 1f       	adc	r31, r21
    2c36:	20 81       	ld	r18, Z
    2c38:	2a 01       	movw	r4, r20
    2c3a:	3b 01       	movw	r6, r22
    2c3c:	08 94       	sec
    2c3e:	41 1c       	adc	r4, r1
    2c40:	51 1c       	adc	r5, r1
    2c42:	61 1c       	adc	r6, r1
    2c44:	71 1c       	adc	r7, r1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    2c46:	21 32       	cpi	r18, 0x21	; 33
    2c48:	08 f4       	brcc	.+2      	; 0x2c4c <follow_path+0x16c>
    2c4a:	95 c0       	rjmp	.+298    	; 0x2d76 <follow_path+0x296>
    2c4c:	2f 32       	cpi	r18, 0x2F	; 47
    2c4e:	09 f4       	brne	.+2      	; 0x2c52 <follow_path+0x172>
    2c50:	4f c1       	rjmp	.+670    	; 0x2ef0 <follow_path+0x410>
    2c52:	2c 35       	cpi	r18, 0x5C	; 92
    2c54:	09 f4       	brne	.+2      	; 0x2c58 <follow_path+0x178>
    2c56:	4c c1       	rjmp	.+664    	; 0x2ef0 <follow_path+0x410>
		if (c == '.' || i >= ni) {
    2c58:	2e 32       	cpi	r18, 0x2E	; 46
    2c5a:	29 f0       	breq	.+10     	; 0x2c66 <follow_path+0x186>
    2c5c:	c8 14       	cp	r12, r8
    2c5e:	d9 04       	cpc	r13, r9
    2c60:	ea 04       	cpc	r14, r10
    2c62:	fb 04       	cpc	r15, r11
    2c64:	c8 f0       	brcs	.+50     	; 0x2c98 <follow_path+0x1b8>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    2c66:	f8 e0       	ldi	r31, 0x08	; 8
    2c68:	8f 16       	cp	r8, r31
    2c6a:	91 04       	cpc	r9, r1
    2c6c:	a1 04       	cpc	r10, r1
    2c6e:	b1 04       	cpc	r11, r1
    2c70:	09 f0       	breq	.+2      	; 0x2c74 <follow_path+0x194>
    2c72:	10 c1       	rjmp	.+544    	; 0x2e94 <follow_path+0x3b4>
    2c74:	2e 32       	cpi	r18, 0x2E	; 46
    2c76:	09 f0       	breq	.+2      	; 0x2c7a <follow_path+0x19a>
    2c78:	0f c1       	rjmp	.+542    	; 0x2e98 <follow_path+0x3b8>
			i = 8; ni = 11;
			b <<= 2; continue;
    2c7a:	29 81       	ldd	r18, Y+1	; 0x01
    2c7c:	22 0f       	add	r18, r18
    2c7e:	22 0f       	add	r18, r18
    2c80:	29 83       	std	Y+1, r18	; 0x01
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    2c82:	b3 01       	movw	r22, r6
    2c84:	a2 01       	movw	r20, r4
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    2c86:	ca 80       	ldd	r12, Y+2	; 0x02
    2c88:	db 80       	ldd	r13, Y+3	; 0x03
    2c8a:	ec 80       	ldd	r14, Y+4	; 0x04
    2c8c:	fd 80       	ldd	r15, Y+5	; 0x05
    2c8e:	8e 80       	ldd	r8, Y+6	; 0x06
    2c90:	9f 80       	ldd	r9, Y+7	; 0x07
    2c92:	a8 84       	ldd	r10, Y+8	; 0x08
    2c94:	b9 84       	ldd	r11, Y+9	; 0x09
    2c96:	cb cf       	rjmp	.-106    	; 0x2c2e <follow_path+0x14e>
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended char? */
    2c98:	22 23       	and	r18, r18
    2c9a:	1c f4       	brge	.+6      	; 0x2ca2 <follow_path+0x1c2>
			b |= 3;						/* Eliminate NT flag */
    2c9c:	89 81       	ldd	r24, Y+1	; 0x01
    2c9e:	83 60       	ori	r24, 0x03	; 3
    2ca0:	89 83       	std	Y+1, r24	; 0x01
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    2ca2:	82 2f       	mov	r24, r18
    2ca4:	81 58       	subi	r24, 0x81	; 129
    2ca6:	8f 31       	cpi	r24, 0x1F	; 31
    2ca8:	18 f0       	brcs	.+6      	; 0x2cb0 <follow_path+0x1d0>
    2caa:	8f 55       	subi	r24, 0x5F	; 95
    2cac:	8d 31       	cpi	r24, 0x1D	; 29
    2cae:	90 f5       	brcc	.+100    	; 0x2d14 <follow_path+0x234>
			d = (BYTE)p[si++];			/* Get 2nd byte */
    2cb0:	ea 85       	ldd	r30, Y+10	; 0x0a
    2cb2:	fb 85       	ldd	r31, Y+11	; 0x0b
    2cb4:	e4 0d       	add	r30, r4
    2cb6:	f5 1d       	adc	r31, r5
    2cb8:	30 81       	ld	r19, Z
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    2cba:	83 2f       	mov	r24, r19
    2cbc:	80 54       	subi	r24, 0x40	; 64
    2cbe:	8f 33       	cpi	r24, 0x3F	; 63
    2cc0:	20 f0       	brcs	.+8      	; 0x2cca <follow_path+0x1ea>
    2cc2:	80 54       	subi	r24, 0x40	; 64
    2cc4:	8d 37       	cpi	r24, 0x7D	; 125
    2cc6:	08 f0       	brcs	.+2      	; 0x2cca <follow_path+0x1ea>
    2cc8:	e9 c0       	rjmp	.+466    	; 0x2e9c <follow_path+0x3bc>
    2cca:	d5 01       	movw	r26, r10
    2ccc:	c4 01       	movw	r24, r8
    2cce:	01 97       	sbiw	r24, 0x01	; 1
    2cd0:	a1 09       	sbc	r26, r1
    2cd2:	b1 09       	sbc	r27, r1
    2cd4:	c8 16       	cp	r12, r24
    2cd6:	d9 06       	cpc	r13, r25
    2cd8:	ea 06       	cpc	r14, r26
    2cda:	fb 06       	cpc	r15, r27
    2cdc:	08 f0       	brcs	.+2      	; 0x2ce0 <follow_path+0x200>
    2cde:	e0 c0       	rjmp	.+448    	; 0x2ea0 <follow_path+0x3c0>
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
    2ce0:	4e 5f       	subi	r20, 0xFE	; 254
    2ce2:	5f 4f       	sbci	r21, 0xFF	; 255
    2ce4:	6f 4f       	sbci	r22, 0xFF	; 255
    2ce6:	7f 4f       	sbci	r23, 0xFF	; 255
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
    2ce8:	f1 01       	movw	r30, r2
    2cea:	ec 0d       	add	r30, r12
    2cec:	fd 1d       	adc	r31, r13
    2cee:	20 83       	st	Z, r18
    2cf0:	d7 01       	movw	r26, r14
    2cf2:	c6 01       	movw	r24, r12
    2cf4:	01 96       	adiw	r24, 0x01	; 1
    2cf6:	a1 1d       	adc	r26, r1
    2cf8:	b1 1d       	adc	r27, r1
			sfn[i++] = d;
    2cfa:	82 0d       	add	r24, r2
    2cfc:	93 1d       	adc	r25, r3
    2cfe:	dc 01       	movw	r26, r24
    2d00:	3c 93       	st	X, r19
    2d02:	82 e0       	ldi	r24, 0x02	; 2
    2d04:	90 e0       	ldi	r25, 0x00	; 0
    2d06:	a0 e0       	ldi	r26, 0x00	; 0
    2d08:	b0 e0       	ldi	r27, 0x00	; 0
    2d0a:	c8 0e       	add	r12, r24
    2d0c:	d9 1e       	adc	r13, r25
    2d0e:	ea 1e       	adc	r14, r26
    2d10:	fb 1e       	adc	r15, r27
    2d12:	8d cf       	rjmp	.-230    	; 0x2c2e <follow_path+0x14e>
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    2d14:	42 2f       	mov	r20, r18
    2d16:	50 e0       	ldi	r21, 0x00	; 0
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    2d18:	42 32       	cpi	r20, 0x22	; 34
    2d1a:	51 05       	cpc	r21, r1
    2d1c:	09 f4       	brne	.+2      	; 0x2d20 <follow_path+0x240>
    2d1e:	c2 c0       	rjmp	.+388    	; 0x2ea4 <follow_path+0x3c4>
    2d20:	e6 ee       	ldi	r30, 0xE6	; 230
    2d22:	f2 e0       	ldi	r31, 0x02	; 2
    2d24:	6a 85       	ldd	r22, Y+10	; 0x0a
    2d26:	7b 85       	ldd	r23, Y+11	; 0x0b
    2d28:	81 91       	ld	r24, Z+
    2d2a:	88 23       	and	r24, r24
    2d2c:	31 f0       	breq	.+12     	; 0x2d3a <follow_path+0x25a>
    2d2e:	90 e0       	ldi	r25, 0x00	; 0
    2d30:	48 17       	cp	r20, r24
    2d32:	59 07       	cpc	r21, r25
    2d34:	c9 f7       	brne	.-14     	; 0x2d28 <follow_path+0x248>
    2d36:	86 e0       	ldi	r24, 0x06	; 6
    2d38:	bc c0       	rjmp	.+376    	; 0x2eb2 <follow_path+0x3d2>
    2d3a:	7b 87       	std	Y+11, r23	; 0x0b
    2d3c:	6a 87       	std	Y+10, r22	; 0x0a
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
    2d3e:	82 2f       	mov	r24, r18
    2d40:	81 54       	subi	r24, 0x41	; 65
    2d42:	8a 31       	cpi	r24, 0x1A	; 26
    2d44:	20 f4       	brcc	.+8      	; 0x2d4e <follow_path+0x26e>
				b |= 2;
    2d46:	99 81       	ldd	r25, Y+1	; 0x01
    2d48:	92 60       	ori	r25, 0x02	; 2
    2d4a:	99 83       	std	Y+1, r25	; 0x01
    2d4c:	08 c0       	rjmp	.+16     	; 0x2d5e <follow_path+0x27e>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
    2d4e:	82 2f       	mov	r24, r18
    2d50:	81 56       	subi	r24, 0x61	; 97
    2d52:	8a 31       	cpi	r24, 0x1A	; 26
    2d54:	20 f4       	brcc	.+8      	; 0x2d5e <follow_path+0x27e>
					b |= 1; c -= 0x20;
    2d56:	a9 81       	ldd	r26, Y+1	; 0x01
    2d58:	a1 60       	ori	r26, 0x01	; 1
    2d5a:	a9 83       	std	Y+1, r26	; 0x01
    2d5c:	20 52       	subi	r18, 0x20	; 32
				}
			}
			sfn[i++] = c;
    2d5e:	f1 01       	movw	r30, r2
    2d60:	ec 0d       	add	r30, r12
    2d62:	fd 1d       	adc	r31, r13
    2d64:	20 83       	st	Z, r18
    2d66:	08 94       	sec
    2d68:	c1 1c       	adc	r12, r1
    2d6a:	d1 1c       	adc	r13, r1
    2d6c:	e1 1c       	adc	r14, r1
    2d6e:	f1 1c       	adc	r15, r1
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    2d70:	b3 01       	movw	r22, r6
    2d72:	a2 01       	movw	r20, r4
    2d74:	5c cf       	rjmp	.-328    	; 0x2c2e <follow_path+0x14e>
    2d76:	ea 85       	ldd	r30, Y+10	; 0x0a
    2d78:	fb 85       	ldd	r31, Y+11	; 0x0b
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    2d7a:	4e 0e       	add	r4, r30
    2d7c:	5f 1e       	adc	r5, r31
    2d7e:	89 81       	ldd	r24, Y+1	; 0x01
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    2d80:	44 e0       	ldi	r20, 0x04	; 4

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    2d82:	c1 14       	cp	r12, r1
    2d84:	d1 04       	cpc	r13, r1
    2d86:	e1 04       	cpc	r14, r1
    2d88:	f1 04       	cpc	r15, r1
    2d8a:	09 f4       	brne	.+2      	; 0x2d8e <follow_path+0x2ae>
    2d8c:	8d c0       	rjmp	.+282    	; 0x2ea8 <follow_path+0x3c8>
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    2d8e:	d1 01       	movw	r26, r2
    2d90:	9c 91       	ld	r25, X
    2d92:	95 3e       	cpi	r25, 0xE5	; 229
    2d94:	11 f4       	brne	.+4      	; 0x2d9a <follow_path+0x2ba>
    2d96:	e5 e0       	ldi	r30, 0x05	; 5
    2d98:	ec 93       	st	X, r30

	if (ni == 8) b <<= 2;
    2d9a:	f8 e0       	ldi	r31, 0x08	; 8
    2d9c:	8f 16       	cp	r8, r31
    2d9e:	91 04       	cpc	r9, r1
    2da0:	a1 04       	cpc	r10, r1
    2da2:	b1 04       	cpc	r11, r1
    2da4:	19 f4       	brne	.+6      	; 0x2dac <follow_path+0x2cc>
    2da6:	88 0f       	add	r24, r24
    2da8:	88 0f       	add	r24, r24
    2daa:	89 83       	std	Y+1, r24	; 0x01
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    2dac:	29 81       	ldd	r18, Y+1	; 0x01
    2dae:	82 2f       	mov	r24, r18
    2db0:	90 e0       	ldi	r25, 0x00	; 0
    2db2:	9c 01       	movw	r18, r24
    2db4:	23 70       	andi	r18, 0x03	; 3
    2db6:	30 70       	andi	r19, 0x00	; 0
    2db8:	21 30       	cpi	r18, 0x01	; 1
    2dba:	31 05       	cpc	r19, r1
    2dbc:	09 f4       	brne	.+2      	; 0x2dc0 <follow_path+0x2e0>
    2dbe:	40 61       	ori	r20, 0x10	; 16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    2dc0:	8c 70       	andi	r24, 0x0C	; 12
    2dc2:	90 70       	andi	r25, 0x00	; 0
    2dc4:	84 30       	cpi	r24, 0x04	; 4
    2dc6:	91 05       	cpc	r25, r1
    2dc8:	09 f4       	brne	.+2      	; 0x2dcc <follow_path+0x2ec>
    2dca:	48 60       	ori	r20, 0x08	; 8

	sfn[NS] = c;		/* Store NT flag, File name is created */
    2dcc:	d1 01       	movw	r26, r2
    2dce:	1b 96       	adiw	r26, 0x0b	; 11
    2dd0:	4c 93       	st	X, r20
    2dd2:	1b 97       	sbiw	r26, 0x0b	; 11
    2dd4:	94 c0       	rjmp	.+296    	; 0x2efe <follow_path+0x41e>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
    2dd6:	f8 01       	movw	r30, r16
    2dd8:	46 85       	ldd	r20, Z+14	; 0x0e
    2dda:	57 85       	ldd	r21, Z+15	; 0x0f
    2ddc:	60 89       	ldd	r22, Z+16	; 0x10
    2dde:	71 89       	ldd	r23, Z+17	; 0x11
    2de0:	80 81       	ld	r24, Z
    2de2:	91 81       	ldd	r25, Z+1	; 0x01
    2de4:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
		if (res != FR_OK) break;
    2de8:	88 23       	and	r24, r24
    2dea:	31 f5       	brne	.+76     	; 0x2e38 <follow_path+0x358>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    2dec:	d8 01       	movw	r26, r16
    2dee:	52 96       	adiw	r26, 0x12	; 18
    2df0:	6d 91       	ld	r22, X+
    2df2:	7c 91       	ld	r23, X
    2df4:	53 97       	sbiw	r26, 0x13	; 19
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    2df6:	fb 01       	movw	r30, r22
    2df8:	90 81       	ld	r25, Z
    2dfa:	99 23       	and	r25, r25
    2dfc:	09 f4       	brne	.+2      	; 0x2e00 <follow_path+0x320>
    2dfe:	90 c0       	rjmp	.+288    	; 0x2f20 <follow_path+0x440>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    2e00:	93 85       	ldd	r25, Z+11	; 0x0b
    2e02:	93 fd       	sbrc	r25, 3
    2e04:	12 c0       	rjmp	.+36     	; 0x2e2a <follow_path+0x34a>
    2e06:	54 96       	adiw	r26, 0x14	; 20
    2e08:	4d 91       	ld	r20, X+
    2e0a:	5c 91       	ld	r21, X
    2e0c:	55 97       	sbiw	r26, 0x15	; 21
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
    2e0e:	9b 01       	movw	r18, r22
    2e10:	25 5f       	subi	r18, 0xF5	; 245
    2e12:	3f 4f       	sbci	r19, 0xFF	; 255
}

/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    2e14:	da 01       	movw	r26, r20
    2e16:	6b 01       	movw	r12, r22
    2e18:	04 c0       	rjmp	.+8      	; 0x2e22 <follow_path+0x342>
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    2e1a:	e2 17       	cp	r30, r18
    2e1c:	f3 07       	cpc	r31, r19
    2e1e:	09 f4       	brne	.+2      	; 0x2e22 <follow_path+0x342>
    2e20:	77 c0       	rjmp	.+238    	; 0x2f10 <follow_path+0x430>
    2e22:	61 91       	ld	r22, Z+
    2e24:	9d 91       	ld	r25, X+
    2e26:	69 17       	cp	r22, r25
    2e28:	c1 f3       	breq	.-16     	; 0x2e1a <follow_path+0x33a>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
    2e2a:	c8 01       	movw	r24, r16
    2e2c:	60 e0       	ldi	r22, 0x00	; 0
    2e2e:	70 e0       	ldi	r23, 0x00	; 0
    2e30:	0e 94 29 14 	call	0x2852	; 0x2852 <dir_next>
	} while (res == FR_OK);
    2e34:	88 23       	and	r24, r24
    2e36:	79 f2       	breq	.-98     	; 0x2dd6 <follow_path+0x2f6>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    2e38:	d8 01       	movw	r26, r16
    2e3a:	54 96       	adiw	r26, 0x14	; 20
    2e3c:	ed 91       	ld	r30, X+
    2e3e:	fc 91       	ld	r31, X
    2e40:	55 97       	sbiw	r26, 0x15	; 21
    2e42:	93 85       	ldd	r25, Z+11	; 0x0b
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
    2e44:	84 30       	cpi	r24, 0x04	; 4
    2e46:	a9 f5       	brne	.+106    	; 0x2eb2 <follow_path+0x3d2>
				/* Object not found */
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
    2e48:	95 ff       	sbrs	r25, 5
    2e4a:	0b c0       	rjmp	.+22     	; 0x2e62 <follow_path+0x382>
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
    2e4c:	f8 01       	movw	r30, r16
    2e4e:	16 82       	std	Z+6, r1	; 0x06
    2e50:	17 82       	std	Z+7, r1	; 0x07
    2e52:	10 86       	std	Z+8, r1	; 0x08
    2e54:	11 86       	std	Z+9, r1	; 0x09
    2e56:	13 8a       	std	Z+19, r1	; 0x13
    2e58:	12 8a       	std	Z+18, r1	; 0x12
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
    2e5a:	92 ff       	sbrs	r25, 2
    2e5c:	8f ce       	rjmp	.-738    	; 0x2b7c <follow_path+0x9c>
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
				/* Object not found */
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
    2e5e:	80 e0       	ldi	r24, 0x00	; 0
    2e60:	28 c0       	rjmp	.+80     	; 0x2eb2 <follow_path+0x3d2>
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    2e62:	92 ff       	sbrs	r25, 2
    2e64:	23 c0       	rjmp	.+70     	; 0x2eac <follow_path+0x3cc>
		dj->dir = 0;
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
    2e66:	84 e0       	ldi	r24, 0x04	; 4
    2e68:	24 c0       	rjmp	.+72     	; 0x2eb2 <follow_path+0x3d2>
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    2e6a:	db 01       	movw	r26, r22
    2e6c:	1b 96       	adiw	r26, 0x0b	; 11
    2e6e:	8c 91       	ld	r24, X
    2e70:	1b 97       	sbiw	r26, 0x0b	; 11
    2e72:	84 ff       	sbrs	r24, 4
    2e74:	1d c0       	rjmp	.+58     	; 0x2eb0 <follow_path+0x3d0>
				res = FR_NO_PATH; break;
			}
			dj->sclust = ld_clust(dj->fs, dir);
    2e76:	f8 01       	movw	r30, r16
    2e78:	80 81       	ld	r24, Z
    2e7a:	91 81       	ldd	r25, Z+1	; 0x01
    2e7c:	0e 94 c4 08 	call	0x1188	; 0x1188 <ld_clust>
    2e80:	dc 01       	movw	r26, r24
    2e82:	cb 01       	movw	r24, r22
    2e84:	f8 01       	movw	r30, r16
    2e86:	86 83       	std	Z+6, r24	; 0x06
    2e88:	97 83       	std	Z+7, r25	; 0x07
    2e8a:	a0 87       	std	Z+8, r26	; 0x08
    2e8c:	b1 87       	std	Z+9, r27	; 0x09
    2e8e:	76 ce       	rjmp	.-788    	; 0x2b7c <follow_path+0x9c>
		for (;;) {
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    2e90:	86 e0       	ldi	r24, 0x06	; 6
    2e92:	0f c0       	rjmp	.+30     	; 0x2eb2 <follow_path+0x3d2>
#endif
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    2e94:	86 e0       	ldi	r24, 0x06	; 6
    2e96:	0d c0       	rjmp	.+26     	; 0x2eb2 <follow_path+0x3d2>
    2e98:	86 e0       	ldi	r24, 0x06	; 6
    2e9a:	0b c0       	rjmp	.+22     	; 0x2eb2 <follow_path+0x3d2>
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    2e9c:	86 e0       	ldi	r24, 0x06	; 6
    2e9e:	09 c0       	rjmp	.+18     	; 0x2eb2 <follow_path+0x3d2>
    2ea0:	86 e0       	ldi	r24, 0x06	; 6
    2ea2:	07 c0       	rjmp	.+14     	; 0x2eb2 <follow_path+0x3d2>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    2ea4:	86 e0       	ldi	r24, 0x06	; 6
    2ea6:	05 c0       	rjmp	.+10     	; 0x2eb2 <follow_path+0x3d2>
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    2ea8:	86 e0       	ldi	r24, 0x06	; 6
    2eaa:	03 c0       	rjmp	.+6      	; 0x2eb2 <follow_path+0x3d2>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    2eac:	85 e0       	ldi	r24, 0x05	; 5
    2eae:	01 c0       	rjmp	.+2      	; 0x2eb2 <follow_path+0x3d2>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
    2eb0:	85 e0       	ldi	r24, 0x05	; 5
			dj->sclust = ld_clust(dj->fs, dir);
		}
	}

	return res;
}
    2eb2:	2b 96       	adiw	r28, 0x0b	; 11
    2eb4:	0f b6       	in	r0, 0x3f	; 63
    2eb6:	f8 94       	cli
    2eb8:	de bf       	out	0x3e, r29	; 62
    2eba:	0f be       	out	0x3f, r0	; 63
    2ebc:	cd bf       	out	0x3d, r28	; 61
    2ebe:	df 91       	pop	r29
    2ec0:	cf 91       	pop	r28
    2ec2:	1f 91       	pop	r17
    2ec4:	0f 91       	pop	r16
    2ec6:	ff 90       	pop	r15
    2ec8:	ef 90       	pop	r14
    2eca:	df 90       	pop	r13
    2ecc:	cf 90       	pop	r12
    2ece:	bf 90       	pop	r11
    2ed0:	af 90       	pop	r10
    2ed2:	9f 90       	pop	r9
    2ed4:	8f 90       	pop	r8
    2ed6:	7f 90       	pop	r7
    2ed8:	6f 90       	pop	r6
    2eda:	5f 90       	pop	r5
    2edc:	4f 90       	pop	r4
    2ede:	3f 90       	pop	r3
    2ee0:	2f 90       	pop	r2
    2ee2:	08 95       	ret
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
		*path = &p[si];									/* Return pointer to the next segment */
    2ee4:	4a 84       	ldd	r4, Y+10	; 0x0a
    2ee6:	5b 84       	ldd	r5, Y+11	; 0x0b
    2ee8:	48 0e       	add	r4, r24
    2eea:	59 1e       	adc	r5, r25
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
    2eec:	84 e2       	ldi	r24, 0x24	; 36
    2eee:	8e ce       	rjmp	.-740    	; 0x2c0c <follow_path+0x12c>
    2ef0:	8a 85       	ldd	r24, Y+10	; 0x0a
    2ef2:	9b 85       	ldd	r25, Y+11	; 0x0b
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    2ef4:	48 0e       	add	r4, r24
    2ef6:	59 1e       	adc	r5, r25
    2ef8:	89 81       	ldd	r24, Y+1	; 0x01
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    2efa:	40 e0       	ldi	r20, 0x00	; 0
    2efc:	42 cf       	rjmp	.-380    	; 0x2d82 <follow_path+0x2a2>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
    2efe:	c8 01       	movw	r24, r16
    2f00:	60 e0       	ldi	r22, 0x00	; 0
    2f02:	70 e0       	ldi	r23, 0x00	; 0
    2f04:	0e 94 15 11 	call	0x222a	; 0x222a <dir_sdi>
	if (res != FR_OK) return res;
    2f08:	88 23       	and	r24, r24
    2f0a:	09 f4       	brne	.+2      	; 0x2f0e <follow_path+0x42e>
    2f0c:	64 cf       	rjmp	.-312    	; 0x2dd6 <follow_path+0x2f6>
    2f0e:	94 cf       	rjmp	.-216    	; 0x2e38 <follow_path+0x358>
    2f10:	b6 01       	movw	r22, r12
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    2f12:	da 01       	movw	r26, r20
    2f14:	1b 96       	adiw	r26, 0x0b	; 11
    2f16:	9c 91       	ld	r25, X
    2f18:	1b 97       	sbiw	r26, 0x0b	; 11
    2f1a:	92 ff       	sbrs	r25, 2
    2f1c:	a6 cf       	rjmp	.-180    	; 0x2e6a <follow_path+0x38a>
    2f1e:	c9 cf       	rjmp	.-110    	; 0x2eb2 <follow_path+0x3d2>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    2f20:	d8 01       	movw	r26, r16
    2f22:	54 96       	adiw	r26, 0x14	; 20
    2f24:	ed 91       	ld	r30, X+
    2f26:	fc 91       	ld	r31, X
    2f28:	55 97       	sbiw	r26, 0x15	; 21
    2f2a:	93 85       	ldd	r25, Z+11	; 0x0b
    2f2c:	8d cf       	rjmp	.-230    	; 0x2e48 <follow_path+0x368>

00002f2e <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
    2f2e:	ef 92       	push	r14
    2f30:	ff 92       	push	r15
    2f32:	0f 93       	push	r16
    2f34:	1f 93       	push	r17
    2f36:	cf 93       	push	r28
    2f38:	8c 01       	movw	r16, r24
			} while (res == FR_OK && --ne);
		}
	}

#else	/* Non LFN configuration */
	res = dir_sdi(dj, 0);
    2f3a:	60 e0       	ldi	r22, 0x00	; 0
    2f3c:	70 e0       	ldi	r23, 0x00	; 0
    2f3e:	0e 94 15 11 	call	0x222a	; 0x222a <dir_sdi>
    2f42:	c8 2f       	mov	r28, r24
	if (res == FR_OK) {
    2f44:	88 23       	and	r24, r24
    2f46:	09 f0       	breq	.+2      	; 0x2f4a <dir_register+0x1c>
    2f48:	3f c0       	rjmp	.+126    	; 0x2fc8 <dir_register+0x9a>
		do {	/* Find a blank entry for the SFN */
			res = move_window(dj->fs, dj->sect);
    2f4a:	d8 01       	movw	r26, r16
    2f4c:	1e 96       	adiw	r26, 0x0e	; 14
    2f4e:	4d 91       	ld	r20, X+
    2f50:	5d 91       	ld	r21, X+
    2f52:	6d 91       	ld	r22, X+
    2f54:	7c 91       	ld	r23, X
    2f56:	51 97       	sbiw	r26, 0x11	; 17
    2f58:	8d 91       	ld	r24, X+
    2f5a:	9c 91       	ld	r25, X
    2f5c:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
    2f60:	c8 2f       	mov	r28, r24
			if (res != FR_OK) break;
    2f62:	88 23       	and	r24, r24
    2f64:	89 f5       	brne	.+98     	; 0x2fc8 <dir_register+0x9a>
			c = *dj->dir;
    2f66:	d8 01       	movw	r26, r16
    2f68:	52 96       	adiw	r26, 0x12	; 18
    2f6a:	ed 91       	ld	r30, X+
    2f6c:	fc 91       	ld	r31, X
    2f6e:	53 97       	sbiw	r26, 0x13	; 19
    2f70:	80 81       	ld	r24, Z
			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
    2f72:	85 3e       	cpi	r24, 0xE5	; 229
    2f74:	81 f1       	breq	.+96     	; 0x2fd6 <dir_register+0xa8>
    2f76:	88 23       	and	r24, r24
    2f78:	71 f1       	breq	.+92     	; 0x2fd6 <dir_register+0xa8>
			res = dir_next(dj, 1);			/* Next entry with table stretch */
    2f7a:	c8 01       	movw	r24, r16
    2f7c:	61 e0       	ldi	r22, 0x01	; 1
    2f7e:	70 e0       	ldi	r23, 0x00	; 0
    2f80:	0e 94 29 14 	call	0x2852	; 0x2852 <dir_next>
    2f84:	c8 2f       	mov	r28, r24
		} while (res == FR_OK);
    2f86:	88 23       	and	r24, r24
    2f88:	01 f3       	breq	.-64     	; 0x2f4a <dir_register+0x1c>
    2f8a:	1e c0       	rjmp	.+60     	; 0x2fc8 <dir_register+0x9a>
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
    2f8c:	f8 01       	movw	r30, r16
    2f8e:	e2 88       	ldd	r14, Z+18	; 0x12
    2f90:	f3 88       	ldd	r15, Z+19	; 0x13
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
    2f92:	c7 01       	movw	r24, r14
    2f94:	60 e0       	ldi	r22, 0x00	; 0
    2f96:	70 e0       	ldi	r23, 0x00	; 0
    2f98:	20 e2       	ldi	r18, 0x20	; 32
    2f9a:	30 e0       	ldi	r19, 0x00	; 0
    2f9c:	40 e0       	ldi	r20, 0x00	; 0
    2f9e:	50 e0       	ldi	r21, 0x00	; 0
    2fa0:	0e 94 b3 08 	call	0x1166	; 0x1166 <mem_set>
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
    2fa4:	d8 01       	movw	r26, r16
    2fa6:	54 96       	adiw	r26, 0x14	; 20
    2fa8:	6d 91       	ld	r22, X+
    2faa:	7c 91       	ld	r23, X
    2fac:	55 97       	sbiw	r26, 0x15	; 21
    2fae:	c7 01       	movw	r24, r14
    2fb0:	2b e0       	ldi	r18, 0x0B	; 11
    2fb2:	30 e0       	ldi	r19, 0x00	; 0
    2fb4:	40 e0       	ldi	r20, 0x00	; 0
    2fb6:	50 e0       	ldi	r21, 0x00	; 0
    2fb8:	0e 94 9e 08 	call	0x113c	; 0x113c <mem_cpy>
#if _USE_LFN
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dj->fs->wflag = 1;
    2fbc:	d8 01       	movw	r26, r16
    2fbe:	ed 91       	ld	r30, X+
    2fc0:	fc 91       	ld	r31, X
    2fc2:	11 97       	sbiw	r26, 0x01	; 1
    2fc4:	81 e0       	ldi	r24, 0x01	; 1
    2fc6:	84 83       	std	Z+4, r24	; 0x04
		}
	}

	return res;
}
    2fc8:	8c 2f       	mov	r24, r28
    2fca:	cf 91       	pop	r28
    2fcc:	1f 91       	pop	r17
    2fce:	0f 91       	pop	r16
    2fd0:	ff 90       	pop	r15
    2fd2:	ef 90       	pop	r14
    2fd4:	08 95       	ret
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
    2fd6:	f8 01       	movw	r30, r16
    2fd8:	46 85       	ldd	r20, Z+14	; 0x0e
    2fda:	57 85       	ldd	r21, Z+15	; 0x0f
    2fdc:	60 89       	ldd	r22, Z+16	; 0x10
    2fde:	71 89       	ldd	r23, Z+17	; 0x11
    2fe0:	80 81       	ld	r24, Z
    2fe2:	91 81       	ldd	r25, Z+1	; 0x01
    2fe4:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
    2fe8:	c8 2f       	mov	r28, r24
		if (res == FR_OK) {
    2fea:	88 23       	and	r24, r24
    2fec:	69 f7       	brne	.-38     	; 0x2fc8 <dir_register+0x9a>
    2fee:	ce cf       	rjmp	.-100    	; 0x2f8c <dir_register+0x5e>

00002ff0 <dir_read>:
#if _FS_MINIMIZE <= 1
static
FRESULT dir_read (
	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
)
{
    2ff0:	cf 93       	push	r28
    2ff2:	df 93       	push	r29
    2ff4:	ec 01       	movw	r28, r24
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
    2ff6:	84 e0       	ldi	r24, 0x04	; 4
	while (dj->sect) {
    2ff8:	17 c0       	rjmp	.+46     	; 0x3028 <dir_read+0x38>
		res = move_window(dj->fs, dj->sect);
    2ffa:	88 81       	ld	r24, Y
    2ffc:	99 81       	ldd	r25, Y+1	; 0x01
    2ffe:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
		if (res != FR_OK) break;
    3002:	88 23       	and	r24, r24
    3004:	e1 f4       	brne	.+56     	; 0x303e <dir_read+0x4e>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    3006:	ea 89       	ldd	r30, Y+18	; 0x12
    3008:	fb 89       	ldd	r31, Y+19	; 0x13
		c = dir[DIR_Name];
    300a:	90 81       	ld	r25, Z
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    300c:	99 23       	and	r25, r25
    300e:	f1 f0       	breq	.+60     	; 0x304c <dir_read+0x5c>
					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    3010:	95 3e       	cpi	r25, 0xE5	; 229
    3012:	19 f0       	breq	.+6      	; 0x301a <dir_read+0x2a>
    3014:	93 85       	ldd	r25, Z+11	; 0x0b
    3016:	93 ff       	sbrs	r25, 3
    3018:	16 c0       	rjmp	.+44     	; 0x3046 <dir_read+0x56>
			break;
#endif
		res = dir_next(dj, 0);				/* Next entry */
    301a:	ce 01       	movw	r24, r28
    301c:	60 e0       	ldi	r22, 0x00	; 0
    301e:	70 e0       	ldi	r23, 0x00	; 0
    3020:	0e 94 29 14 	call	0x2852	; 0x2852 <dir_next>
		if (res != FR_OK) break;
    3024:	88 23       	and	r24, r24
    3026:	59 f4       	brne	.+22     	; 0x303e <dir_read+0x4e>
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
    3028:	4e 85       	ldd	r20, Y+14	; 0x0e
    302a:	5f 85       	ldd	r21, Y+15	; 0x0f
    302c:	68 89       	ldd	r22, Y+16	; 0x10
    302e:	79 89       	ldd	r23, Y+17	; 0x11
    3030:	41 15       	cp	r20, r1
    3032:	51 05       	cpc	r21, r1
    3034:	61 05       	cpc	r22, r1
    3036:	71 05       	cpc	r23, r1
    3038:	01 f7       	brne	.-64     	; 0x2ffa <dir_read+0xa>
#endif
		res = dir_next(dj, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
    303a:	88 23       	and	r24, r24
    303c:	21 f0       	breq	.+8      	; 0x3046 <dir_read+0x56>
    303e:	1e 86       	std	Y+14, r1	; 0x0e
    3040:	1f 86       	std	Y+15, r1	; 0x0f
    3042:	18 8a       	std	Y+16, r1	; 0x10
    3044:	19 8a       	std	Y+17, r1	; 0x11

	return res;
}
    3046:	df 91       	pop	r29
    3048:	cf 91       	pop	r28
    304a:	08 95       	ret
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    304c:	84 e0       	ldi	r24, 0x04	; 4
    304e:	f7 cf       	rjmp	.-18     	; 0x303e <dir_read+0x4e>

00003050 <remove_chain>:
static
FRESULT remove_chain (
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
    3050:	7f 92       	push	r7
    3052:	8f 92       	push	r8
    3054:	9f 92       	push	r9
    3056:	af 92       	push	r10
    3058:	bf 92       	push	r11
    305a:	cf 92       	push	r12
    305c:	df 92       	push	r13
    305e:	ef 92       	push	r14
    3060:	ff 92       	push	r15
    3062:	0f 93       	push	r16
    3064:	1f 93       	push	r17
    3066:	cf 93       	push	r28
    3068:	df 93       	push	r29
    306a:	ec 01       	movw	r28, r24
    306c:	4a 01       	movw	r8, r20
    306e:	5b 01       	movw	r10, r22
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    3070:	42 30       	cpi	r20, 0x02	; 2
    3072:	51 05       	cpc	r21, r1
    3074:	61 05       	cpc	r22, r1
    3076:	71 05       	cpc	r23, r1
    3078:	08 f4       	brcc	.+2      	; 0x307c <remove_chain+0x2c>
    307a:	55 c0       	rjmp	.+170    	; 0x3126 <remove_chain+0xd6>
    307c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    307e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3080:	ac 8d       	ldd	r26, Y+28	; 0x1c
    3082:	bd 8d       	ldd	r27, Y+29	; 0x1d
    3084:	48 17       	cp	r20, r24
    3086:	59 07       	cpc	r21, r25
    3088:	6a 07       	cpc	r22, r26
    308a:	7b 07       	cpc	r23, r27
    308c:	08 f0       	brcs	.+2      	; 0x3090 <remove_chain+0x40>
    308e:	4d c0       	rjmp	.+154    	; 0x312a <remove_chain+0xda>
    3090:	03 c0       	rjmp	.+6      	; 0x3098 <remove_chain+0x48>
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
    3092:	46 01       	movw	r8, r12
    3094:	57 01       	movw	r10, r14
    3096:	02 c0       	rjmp	.+4      	; 0x309c <remove_chain+0x4c>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
				fs->free_clust++;
				fs->fsi_flag = 1;
    3098:	77 24       	eor	r7, r7
    309a:	73 94       	inc	r7
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
    309c:	ce 01       	movw	r24, r28
    309e:	b5 01       	movw	r22, r10
    30a0:	a4 01       	movw	r20, r8
    30a2:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <get_fat>
    30a6:	6b 01       	movw	r12, r22
    30a8:	7c 01       	movw	r14, r24
			if (nxt == 0) break;				/* Empty cluster? */
    30aa:	61 15       	cp	r22, r1
    30ac:	71 05       	cpc	r23, r1
    30ae:	81 05       	cpc	r24, r1
    30b0:	91 05       	cpc	r25, r1
    30b2:	e9 f1       	breq	.+122    	; 0x312e <remove_chain+0xde>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    30b4:	91 e0       	ldi	r25, 0x01	; 1
    30b6:	c9 16       	cp	r12, r25
    30b8:	d1 04       	cpc	r13, r1
    30ba:	e1 04       	cpc	r14, r1
    30bc:	f1 04       	cpc	r15, r1
    30be:	c9 f1       	breq	.+114    	; 0x3132 <remove_chain+0xe2>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    30c0:	8f ef       	ldi	r24, 0xFF	; 255
    30c2:	c8 16       	cp	r12, r24
    30c4:	8f ef       	ldi	r24, 0xFF	; 255
    30c6:	d8 06       	cpc	r13, r24
    30c8:	8f ef       	ldi	r24, 0xFF	; 255
    30ca:	e8 06       	cpc	r14, r24
    30cc:	8f ef       	ldi	r24, 0xFF	; 255
    30ce:	f8 06       	cpc	r15, r24
    30d0:	91 f1       	breq	.+100    	; 0x3136 <remove_chain+0xe6>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    30d2:	ce 01       	movw	r24, r28
    30d4:	b5 01       	movw	r22, r10
    30d6:	a4 01       	movw	r20, r8
    30d8:	00 e0       	ldi	r16, 0x00	; 0
    30da:	10 e0       	ldi	r17, 0x00	; 0
    30dc:	98 01       	movw	r18, r16
    30de:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <put_fat>
			if (res != FR_OK) break;
    30e2:	88 23       	and	r24, r24
    30e4:	49 f5       	brne	.+82     	; 0x3138 <remove_chain+0xe8>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    30e6:	4e 85       	ldd	r20, Y+14	; 0x0e
    30e8:	5f 85       	ldd	r21, Y+15	; 0x0f
    30ea:	68 89       	ldd	r22, Y+16	; 0x10
    30ec:	79 89       	ldd	r23, Y+17	; 0x11
    30ee:	4f 3f       	cpi	r20, 0xFF	; 255
    30f0:	9f ef       	ldi	r25, 0xFF	; 255
    30f2:	59 07       	cpc	r21, r25
    30f4:	9f ef       	ldi	r25, 0xFF	; 255
    30f6:	69 07       	cpc	r22, r25
    30f8:	9f ef       	ldi	r25, 0xFF	; 255
    30fa:	79 07       	cpc	r23, r25
    30fc:	49 f0       	breq	.+18     	; 0x3110 <remove_chain+0xc0>
				fs->free_clust++;
    30fe:	4f 5f       	subi	r20, 0xFF	; 255
    3100:	5f 4f       	sbci	r21, 0xFF	; 255
    3102:	6f 4f       	sbci	r22, 0xFF	; 255
    3104:	7f 4f       	sbci	r23, 0xFF	; 255
    3106:	4e 87       	std	Y+14, r20	; 0x0e
    3108:	5f 87       	std	Y+15, r21	; 0x0f
    310a:	68 8b       	std	Y+16, r22	; 0x10
    310c:	79 8b       	std	Y+17, r23	; 0x11
				fs->fsi_flag = 1;
    310e:	7d 82       	std	Y+5, r7	; 0x05
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
    3110:	4a 8d       	ldd	r20, Y+26	; 0x1a
    3112:	5b 8d       	ldd	r21, Y+27	; 0x1b
    3114:	6c 8d       	ldd	r22, Y+28	; 0x1c
    3116:	7d 8d       	ldd	r23, Y+29	; 0x1d
    3118:	c4 16       	cp	r12, r20
    311a:	d5 06       	cpc	r13, r21
    311c:	e6 06       	cpc	r14, r22
    311e:	f7 06       	cpc	r15, r23
    3120:	08 f4       	brcc	.+2      	; 0x3124 <remove_chain+0xd4>
    3122:	b7 cf       	rjmp	.-146    	; 0x3092 <remove_chain+0x42>
    3124:	09 c0       	rjmp	.+18     	; 0x3138 <remove_chain+0xe8>
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
    3126:	82 e0       	ldi	r24, 0x02	; 2
    3128:	07 c0       	rjmp	.+14     	; 0x3138 <remove_chain+0xe8>
    312a:	82 e0       	ldi	r24, 0x02	; 2
    312c:	05 c0       	rjmp	.+10     	; 0x3138 <remove_chain+0xe8>

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
    312e:	80 e0       	ldi	r24, 0x00	; 0
    3130:	03 c0       	rjmp	.+6      	; 0x3138 <remove_chain+0xe8>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    3132:	82 e0       	ldi	r24, 0x02	; 2
    3134:	01 c0       	rjmp	.+2      	; 0x3138 <remove_chain+0xe8>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    3136:	81 e0       	ldi	r24, 0x01	; 1
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
    3138:	df 91       	pop	r29
    313a:	cf 91       	pop	r28
    313c:	1f 91       	pop	r17
    313e:	0f 91       	pop	r16
    3140:	ff 90       	pop	r15
    3142:	ef 90       	pop	r14
    3144:	df 90       	pop	r13
    3146:	cf 90       	pop	r12
    3148:	bf 90       	pop	r11
    314a:	af 90       	pop	r10
    314c:	9f 90       	pop	r9
    314e:	8f 90       	pop	r8
    3150:	7f 90       	pop	r7
    3152:	08 95       	ret

00003154 <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
    3154:	88 23       	and	r24, r24
    3156:	91 f4       	brne	.+36     	; 0x317c <f_mount+0x28>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
    3158:	e0 91 f9 02 	lds	r30, 0x02F9
    315c:	f0 91 fa 02 	lds	r31, 0x02FA

	if (rfs) {
    3160:	30 97       	sbiw	r30, 0x00	; 0
    3162:	09 f0       	breq	.+2      	; 0x3166 <f_mount+0x12>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
    3164:	10 82       	st	Z, r1
	}

	if (fs) {
    3166:	61 15       	cp	r22, r1
    3168:	71 05       	cpc	r23, r1
    316a:	11 f0       	breq	.+4      	; 0x3170 <f_mount+0x1c>
		fs->fs_type = 0;		/* Clear new fs object */
    316c:	fb 01       	movw	r30, r22
    316e:	10 82       	st	Z, r1
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
    3170:	70 93 fa 02 	sts	0x02FA, r23
    3174:	60 93 f9 02 	sts	0x02F9, r22

	return FR_OK;
    3178:	80 e0       	ldi	r24, 0x00	; 0
    317a:	08 95       	ret
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
    317c:	8b e0       	ldi	r24, 0x0B	; 11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
    317e:	08 95       	ret

00003180 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    3180:	4f 92       	push	r4
    3182:	5f 92       	push	r5
    3184:	6f 92       	push	r6
    3186:	7f 92       	push	r7
    3188:	8f 92       	push	r8
    318a:	9f 92       	push	r9
    318c:	af 92       	push	r10
    318e:	bf 92       	push	r11
    3190:	cf 92       	push	r12
    3192:	df 92       	push	r13
    3194:	ef 92       	push	r14
    3196:	ff 92       	push	r15
    3198:	0f 93       	push	r16
    319a:	1f 93       	push	r17
    319c:	cf 93       	push	r28
    319e:	df 93       	push	r29
    31a0:	cd b7       	in	r28, 0x3d	; 61
    31a2:	de b7       	in	r29, 0x3e	; 62
    31a4:	a4 97       	sbiw	r28, 0x24	; 36
    31a6:	0f b6       	in	r0, 0x3f	; 63
    31a8:	f8 94       	cli
    31aa:	de bf       	out	0x3e, r29	; 62
    31ac:	0f be       	out	0x3f, r0	; 63
    31ae:	cd bf       	out	0x3d, r28	; 61
    31b0:	7c 01       	movw	r14, r24
    31b2:	7c a3       	lds	r23, 0x5c
    31b4:	6b a3       	lds	r22, 0x5b
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    31b6:	00 97       	sbiw	r24, 0x00	; 0
    31b8:	09 f4       	brne	.+2      	; 0x31bc <f_open+0x3c>
    31ba:	ea c0       	rjmp	.+468    	; 0x3390 <f_open+0x210>
	fp->fs = 0;			/* Clear file object */
    31bc:	fc 01       	movw	r30, r24
    31be:	11 82       	std	Z+1, r1	; 0x01
    31c0:	10 82       	st	Z, r1

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    31c2:	04 2f       	mov	r16, r20
    31c4:	0f 71       	andi	r16, 0x1F	; 31
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
    31c6:	4e 71       	andi	r20, 0x1E	; 30
    31c8:	ce 01       	movw	r24, r28
    31ca:	83 96       	adiw	r24, 0x23	; 35
    31cc:	be 01       	movw	r22, r28
    31ce:	6f 5f       	subi	r22, 0xFF	; 255
    31d0:	7f 4f       	sbci	r23, 0xFF	; 255
    31d2:	0e 94 41 0a 	call	0x1482	; 0x1482 <chk_mounted>
    31d6:	18 2f       	mov	r17, r24
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res == FR_OK) {
    31d8:	88 23       	and	r24, r24
    31da:	09 f0       	breq	.+2      	; 0x31de <f_open+0x5e>
    31dc:	da c0       	rjmp	.+436    	; 0x3392 <f_open+0x212>
		INIT_BUF(dj);
    31de:	ce 01       	movw	r24, r28
    31e0:	47 96       	adiw	r24, 0x17	; 23
    31e2:	9e 8b       	std	Y+22, r25	; 0x16
    31e4:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    31e6:	6b a1       	lds	r22, 0x4b
    31e8:	7c a1       	lds	r23, 0x4c
    31ea:	ce 01       	movw	r24, r28
    31ec:	01 96       	adiw	r24, 0x01	; 1
    31ee:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <follow_path>
		dir = dj.dir;
    31f2:	cb 88       	ldd	r12, Y+19	; 0x13
    31f4:	dc 88       	ldd	r13, Y+20	; 0x14
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
    31f6:	88 23       	and	r24, r24
    31f8:	21 f4       	brne	.+8      	; 0x3202 <f_open+0x82>
			if (!dir)	/* Current dir itself */
    31fa:	c1 14       	cp	r12, r1
    31fc:	d1 04       	cpc	r13, r1
    31fe:	09 f4       	brne	.+2      	; 0x3202 <f_open+0x82>
				res = FR_INVALID_NAME;
    3200:	86 e0       	ldi	r24, 0x06	; 6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    3202:	40 2f       	mov	r20, r16
    3204:	50 e0       	ldi	r21, 0x00	; 0
    3206:	9a 01       	movw	r18, r20
    3208:	2c 71       	andi	r18, 0x1C	; 28
    320a:	30 70       	andi	r19, 0x00	; 0
    320c:	21 15       	cp	r18, r1
    320e:	31 05       	cpc	r19, r1
    3210:	09 f4       	brne	.+2      	; 0x3214 <f_open+0x94>
    3212:	5b c0       	rjmp	.+182    	; 0x32ca <f_open+0x14a>
			DWORD dw, cl;

			if (res != FR_OK) {					/* No file, create new */
    3214:	88 23       	and	r24, r24
    3216:	71 f0       	breq	.+28     	; 0x3234 <f_open+0xb4>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    3218:	84 30       	cpi	r24, 0x04	; 4
    321a:	09 f0       	breq	.+2      	; 0x321e <f_open+0x9e>
    321c:	b7 c0       	rjmp	.+366    	; 0x338c <f_open+0x20c>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
    321e:	ce 01       	movw	r24, r28
    3220:	01 96       	adiw	r24, 0x01	; 1
    3222:	0e 94 97 17 	call	0x2f2e	; 0x2f2e <dir_register>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
    3226:	cb 88       	ldd	r12, Y+19	; 0x13
    3228:	dc 88       	ldd	r13, Y+20	; 0x14
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    322a:	88 23       	and	r24, r24
    322c:	09 f0       	breq	.+2      	; 0x3230 <f_open+0xb0>
    322e:	ae c0       	rjmp	.+348    	; 0x338c <f_open+0x20c>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
    3230:	08 60       	ori	r16, 0x08	; 8
    3232:	07 c0       	rjmp	.+14     	; 0x3242 <f_open+0xc2>
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    3234:	f6 01       	movw	r30, r12
    3236:	83 85       	ldd	r24, Z+11	; 0x0b
    3238:	81 71       	andi	r24, 0x11	; 17
    323a:	09 f0       	breq	.+2      	; 0x323e <f_open+0xbe>
    323c:	c2 c0       	rjmp	.+388    	; 0x33c2 <f_open+0x242>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    323e:	02 fd       	sbrc	r16, 2
    3240:	c2 c0       	rjmp	.+388    	; 0x33c6 <f_open+0x246>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    3242:	03 ff       	sbrs	r16, 3
    3244:	c6 c0       	rjmp	.+396    	; 0x33d2 <f_open+0x252>
				dw = get_fattime();					/* Created time */
    3246:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <get_fattime>
				ST_DWORD(dir+DIR_CrtTime, dw);
    324a:	f6 01       	movw	r30, r12
    324c:	66 87       	std	Z+14, r22	; 0x0e
    324e:	77 87       	std	Z+15, r23	; 0x0f
    3250:	80 8b       	std	Z+16, r24	; 0x10
    3252:	91 8b       	std	Z+17, r25	; 0x11
				dir[DIR_Attr] = 0;					/* Reset attribute */
    3254:	13 86       	std	Z+11, r1	; 0x0b
				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
    3256:	14 8e       	std	Z+28, r1	; 0x1c
    3258:	15 8e       	std	Z+29, r1	; 0x1d
    325a:	16 8e       	std	Z+30, r1	; 0x1e
    325c:	17 8e       	std	Z+31, r1	; 0x1f
				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
    325e:	89 81       	ldd	r24, Y+1	; 0x01
    3260:	9a 81       	ldd	r25, Y+2	; 0x02
    3262:	b6 01       	movw	r22, r12
    3264:	0e 94 c4 08 	call	0x1188	; 0x1188 <ld_clust>
    3268:	4b 01       	movw	r8, r22
    326a:	5c 01       	movw	r10, r24
				st_clust(dir, 0);					/* cluster = 0 */
    326c:	c6 01       	movw	r24, r12
    326e:	40 e0       	ldi	r20, 0x00	; 0
    3270:	50 e0       	ldi	r21, 0x00	; 0
    3272:	ba 01       	movw	r22, r20
    3274:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <st_clust>
				dj.fs->wflag = 1;
    3278:	e9 81       	ldd	r30, Y+1	; 0x01
    327a:	fa 81       	ldd	r31, Y+2	; 0x02
    327c:	81 e0       	ldi	r24, 0x01	; 1
    327e:	84 83       	std	Z+4, r24	; 0x04
				if (cl) {							/* Remove the cluster chain if exist */
    3280:	81 14       	cp	r8, r1
    3282:	91 04       	cpc	r9, r1
    3284:	a1 04       	cpc	r10, r1
    3286:	b1 04       	cpc	r11, r1
    3288:	09 f4       	brne	.+2      	; 0x328c <f_open+0x10c>
    328a:	a3 c0       	rjmp	.+326    	; 0x33d2 <f_open+0x252>
					dw = dj.fs->winsect;
    328c:	46 a4       	lds	r20, 0xa6
    328e:	57 a4       	lds	r21, 0xa7
    3290:	60 a8       	sts	0x00, r22
    3292:	71 a8       	sts	0x81, r23
					res = remove_chain(dj.fs, cl);
    3294:	cf 01       	movw	r24, r30
    3296:	b5 01       	movw	r22, r10
    3298:	a4 01       	movw	r20, r8
    329a:	0e 94 28 18 	call	0x3050	; 0x3050 <remove_chain>
					if (res == FR_OK) {
    329e:	88 23       	and	r24, r24
    32a0:	09 f0       	breq	.+2      	; 0x32a4 <f_open+0x124>
    32a2:	74 c0       	rjmp	.+232    	; 0x338c <f_open+0x20c>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    32a4:	e9 81       	ldd	r30, Y+1	; 0x01
    32a6:	fa 81       	ldd	r31, Y+2	; 0x02
    32a8:	d5 01       	movw	r26, r10
    32aa:	c4 01       	movw	r24, r8
    32ac:	01 97       	sbiw	r24, 0x01	; 1
    32ae:	a1 09       	sbc	r26, r1
    32b0:	b1 09       	sbc	r27, r1
    32b2:	82 87       	std	Z+10, r24	; 0x0a
    32b4:	93 87       	std	Z+11, r25	; 0x0b
    32b6:	a4 87       	std	Z+12, r26	; 0x0c
    32b8:	b5 87       	std	Z+13, r27	; 0x0d
						res = move_window(dj.fs, dw);
    32ba:	cf 01       	movw	r24, r30
    32bc:	b3 01       	movw	r22, r6
    32be:	a2 01       	movw	r20, r4
    32c0:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
    32c4:	88 23       	and	r24, r24
    32c6:	69 f0       	breq	.+26     	; 0x32e2 <f_open+0x162>
    32c8:	61 c0       	rjmp	.+194    	; 0x338c <f_open+0x20c>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {						/* Follow succeeded */
    32ca:	88 23       	and	r24, r24
    32cc:	09 f0       	breq	.+2      	; 0x32d0 <f_open+0x150>
    32ce:	5e c0       	rjmp	.+188    	; 0x338c <f_open+0x20c>
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    32d0:	f6 01       	movw	r30, r12
    32d2:	83 85       	ldd	r24, Z+11	; 0x0b
    32d4:	84 fd       	sbrc	r24, 4
    32d6:	79 c0       	rjmp	.+242    	; 0x33ca <f_open+0x24a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    32d8:	01 ff       	sbrs	r16, 1
    32da:	7b c0       	rjmp	.+246    	; 0x33d2 <f_open+0x252>
    32dc:	80 fd       	sbrc	r24, 0
    32de:	77 c0       	rjmp	.+238    	; 0x33ce <f_open+0x24e>
    32e0:	78 c0       	rjmp	.+240    	; 0x33d2 <f_open+0x252>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
    32e2:	00 62       	ori	r16, 0x20	; 32
			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
    32e4:	a9 80       	ldd	r10, Y+1	; 0x01
    32e6:	ba 80       	ldd	r11, Y+2	; 0x02
    32e8:	f5 01       	movw	r30, r10
    32ea:	86 a5       	lds	r24, 0x66
    32ec:	97 a5       	lds	r25, 0x67
    32ee:	a0 a9       	sts	0x40, r26
    32f0:	b1 a9       	sts	0x41, r27
    32f2:	f7 01       	movw	r30, r14
    32f4:	82 8f       	std	Z+26, r24	; 0x1a
    32f6:	93 8f       	std	Z+27, r25	; 0x1b
    32f8:	a4 8f       	std	Z+28, r26	; 0x1c
    32fa:	b5 8f       	std	Z+29, r27	; 0x1d
			fp->dir_ptr = dir;
    32fc:	d7 8e       	std	Z+31, r13	; 0x1f
    32fe:	c6 8e       	std	Z+30, r12	; 0x1e
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
    3300:	04 83       	std	Z+4, r16	; 0x04
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
    3302:	c5 01       	movw	r24, r10
    3304:	b6 01       	movw	r22, r12
    3306:	0e 94 c4 08 	call	0x1188	; 0x1188 <ld_clust>
    330a:	dc 01       	movw	r26, r24
    330c:	cb 01       	movw	r24, r22
    330e:	f7 01       	movw	r30, r14
    3310:	86 87       	std	Z+14, r24	; 0x0e
    3312:	97 87       	std	Z+15, r25	; 0x0f
    3314:	a0 8b       	std	Z+16, r26	; 0x10
    3316:	b1 8b       	std	Z+17, r27	; 0x11
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    3318:	f6 01       	movw	r30, r12
    331a:	87 8d       	ldd	r24, Z+31	; 0x1f
    331c:	90 e0       	ldi	r25, 0x00	; 0
    331e:	a0 e0       	ldi	r26, 0x00	; 0
    3320:	b0 e0       	ldi	r27, 0x00	; 0
    3322:	78 2f       	mov	r23, r24
    3324:	66 27       	eor	r22, r22
    3326:	55 27       	eor	r21, r21
    3328:	44 27       	eor	r20, r20
    332a:	86 8d       	ldd	r24, Z+30	; 0x1e
    332c:	90 e0       	ldi	r25, 0x00	; 0
    332e:	a0 e0       	ldi	r26, 0x00	; 0
    3330:	b0 e0       	ldi	r27, 0x00	; 0
    3332:	dc 01       	movw	r26, r24
    3334:	99 27       	eor	r25, r25
    3336:	88 27       	eor	r24, r24
    3338:	48 2b       	or	r20, r24
    333a:	59 2b       	or	r21, r25
    333c:	6a 2b       	or	r22, r26
    333e:	7b 2b       	or	r23, r27
    3340:	84 8d       	ldd	r24, Z+28	; 0x1c
    3342:	90 e0       	ldi	r25, 0x00	; 0
    3344:	a0 e0       	ldi	r26, 0x00	; 0
    3346:	b0 e0       	ldi	r27, 0x00	; 0
    3348:	48 2b       	or	r20, r24
    334a:	59 2b       	or	r21, r25
    334c:	6a 2b       	or	r22, r26
    334e:	7b 2b       	or	r23, r27
    3350:	95 8d       	ldd	r25, Z+29	; 0x1d
    3352:	80 e0       	ldi	r24, 0x00	; 0
    3354:	a0 e0       	ldi	r26, 0x00	; 0
    3356:	b0 e0       	ldi	r27, 0x00	; 0
    3358:	84 2b       	or	r24, r20
    335a:	95 2b       	or	r25, r21
    335c:	a6 2b       	or	r26, r22
    335e:	b7 2b       	or	r27, r23
    3360:	f7 01       	movw	r30, r14
    3362:	82 87       	std	Z+10, r24	; 0x0a
    3364:	93 87       	std	Z+11, r25	; 0x0b
    3366:	a4 87       	std	Z+12, r26	; 0x0c
    3368:	b5 87       	std	Z+13, r27	; 0x0d
			fp->fptr = 0;						/* File pointer */
    336a:	16 82       	std	Z+6, r1	; 0x06
    336c:	17 82       	std	Z+7, r1	; 0x07
    336e:	10 86       	std	Z+8, r1	; 0x08
    3370:	11 86       	std	Z+9, r1	; 0x09
			fp->dsect = 0;
    3372:	16 8a       	std	Z+22, r1	; 0x16
    3374:	17 8a       	std	Z+23, r1	; 0x17
    3376:	10 8e       	std	Z+24, r1	; 0x18
    3378:	11 8e       	std	Z+25, r1	; 0x19
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    337a:	b1 82       	std	Z+1, r11	; 0x01
    337c:	a0 82       	st	Z, r10
    337e:	f5 01       	movw	r30, r10
    3380:	86 81       	ldd	r24, Z+6	; 0x06
    3382:	97 81       	ldd	r25, Z+7	; 0x07
    3384:	f7 01       	movw	r30, r14
    3386:	93 83       	std	Z+3, r25	; 0x03
    3388:	82 83       	std	Z+2, r24	; 0x02
    338a:	03 c0       	rjmp	.+6      	; 0x3392 <f_open+0x212>
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    338c:	18 2f       	mov	r17, r24
    338e:	01 c0       	rjmp	.+2      	; 0x3392 <f_open+0x212>
    3390:	19 e0       	ldi	r17, 0x09	; 9
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
		}
	}

	LEAVE_FF(dj.fs, res);
}
    3392:	81 2f       	mov	r24, r17
    3394:	a4 96       	adiw	r28, 0x24	; 36
    3396:	0f b6       	in	r0, 0x3f	; 63
    3398:	f8 94       	cli
    339a:	de bf       	out	0x3e, r29	; 62
    339c:	0f be       	out	0x3f, r0	; 63
    339e:	cd bf       	out	0x3d, r28	; 61
    33a0:	df 91       	pop	r29
    33a2:	cf 91       	pop	r28
    33a4:	1f 91       	pop	r17
    33a6:	0f 91       	pop	r16
    33a8:	ff 90       	pop	r15
    33aa:	ef 90       	pop	r14
    33ac:	df 90       	pop	r13
    33ae:	cf 90       	pop	r12
    33b0:	bf 90       	pop	r11
    33b2:	af 90       	pop	r10
    33b4:	9f 90       	pop	r9
    33b6:	8f 90       	pop	r8
    33b8:	7f 90       	pop	r7
    33ba:	6f 90       	pop	r6
    33bc:	5f 90       	pop	r5
    33be:	4f 90       	pop	r4
    33c0:	08 95       	ret
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
					res = FR_DENIED;
    33c2:	87 e0       	ldi	r24, 0x07	; 7
    33c4:	e3 cf       	rjmp	.-58     	; 0x338c <f_open+0x20c>
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
    33c6:	88 e0       	ldi	r24, 0x08	; 8
    33c8:	e1 cf       	rjmp	.-62     	; 0x338c <f_open+0x20c>
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {						/* Follow succeeded */
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
					res = FR_NO_FILE;
    33ca:	84 e0       	ldi	r24, 0x04	; 4
    33cc:	df cf       	rjmp	.-66     	; 0x338c <f_open+0x20c>
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
    33ce:	87 e0       	ldi	r24, 0x07	; 7
    33d0:	dd cf       	rjmp	.-70     	; 0x338c <f_open+0x20c>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
    33d2:	03 ff       	sbrs	r16, 3
    33d4:	87 cf       	rjmp	.-242    	; 0x32e4 <f_open+0x164>
    33d6:	85 cf       	rjmp	.-246    	; 0x32e2 <f_open+0x162>

000033d8 <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
    33d8:	2f 92       	push	r2
    33da:	3f 92       	push	r3
    33dc:	4f 92       	push	r4
    33de:	5f 92       	push	r5
    33e0:	6f 92       	push	r6
    33e2:	7f 92       	push	r7
    33e4:	8f 92       	push	r8
    33e6:	9f 92       	push	r9
    33e8:	af 92       	push	r10
    33ea:	bf 92       	push	r11
    33ec:	cf 92       	push	r12
    33ee:	df 92       	push	r13
    33f0:	ef 92       	push	r14
    33f2:	ff 92       	push	r15
    33f4:	0f 93       	push	r16
    33f6:	1f 93       	push	r17
    33f8:	cf 93       	push	r28
    33fa:	df 93       	push	r29
    33fc:	cd b7       	in	r28, 0x3d	; 61
    33fe:	de b7       	in	r29, 0x3e	; 62
    3400:	29 97       	sbiw	r28, 0x09	; 9
    3402:	0f b6       	in	r0, 0x3f	; 63
    3404:	f8 94       	cli
    3406:	de bf       	out	0x3e, r29	; 62
    3408:	0f be       	out	0x3f, r0	; 63
    340a:	cd bf       	out	0x3d, r28	; 61
    340c:	9c 83       	std	Y+4, r25	; 0x04
    340e:	8b 83       	std	Y+3, r24	; 0x03
    3410:	a6 2e       	mov	r10, r22
    3412:	97 2e       	mov	r9, r23
    3414:	c2 2e       	mov	r12, r18
    3416:	f3 2e       	mov	r15, r19
    3418:	e4 2e       	mov	r14, r20
    341a:	d5 2e       	mov	r13, r21
    341c:	18 01       	movw	r2, r16
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Clear read byte counter */
    341e:	d8 01       	movw	r26, r16
    3420:	1d 92       	st	X+, r1
    3422:	1d 92       	st	X+, r1
    3424:	1d 92       	st	X+, r1
    3426:	1c 92       	st	X, r1
    3428:	13 97       	sbiw	r26, 0x03	; 3

	res = validate(fp);							/* Check validity */
    342a:	0e 94 84 09 	call	0x1308	; 0x1308 <validate>
    342e:	b8 2e       	mov	r11, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3430:	88 23       	and	r24, r24
    3432:	09 f0       	breq	.+2      	; 0x3436 <f_read+0x5e>
    3434:	e1 c1       	rjmp	.+962    	; 0x37f8 <f_read+0x420>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
    3436:	eb 81       	ldd	r30, Y+3	; 0x03
    3438:	fc 81       	ldd	r31, Y+4	; 0x04
    343a:	84 81       	ldd	r24, Z+4	; 0x04
    343c:	88 23       	and	r24, r24
    343e:	0c f4       	brge	.+2      	; 0x3442 <f_read+0x6a>
    3440:	d3 c1       	rjmp	.+934    	; 0x37e8 <f_read+0x410>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    3442:	80 ff       	sbrs	r24, 0
    3444:	d5 c1       	rjmp	.+938    	; 0x37f0 <f_read+0x418>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
    3446:	42 85       	ldd	r20, Z+10	; 0x0a
    3448:	53 85       	ldd	r21, Z+11	; 0x0b
    344a:	64 85       	ldd	r22, Z+12	; 0x0c
    344c:	75 85       	ldd	r23, Z+13	; 0x0d
    344e:	86 81       	ldd	r24, Z+6	; 0x06
    3450:	97 81       	ldd	r25, Z+7	; 0x07
    3452:	a0 85       	ldd	r26, Z+8	; 0x08
    3454:	b1 85       	ldd	r27, Z+9	; 0x09
    3456:	48 1b       	sub	r20, r24
    3458:	59 0b       	sbc	r21, r25
    345a:	6a 0b       	sbc	r22, r26
    345c:	7b 0b       	sbc	r23, r27

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    345e:	4c 2c       	mov	r4, r12
    3460:	5f 2c       	mov	r5, r15
    3462:	6e 2c       	mov	r6, r14
    3464:	7d 2c       	mov	r7, r13
    3466:	44 15       	cp	r20, r4
    3468:	55 05       	cpc	r21, r5
    346a:	66 05       	cpc	r22, r6
    346c:	77 05       	cpc	r23, r7
    346e:	10 f4       	brcc	.+4      	; 0x3474 <f_read+0x9c>
    3470:	2a 01       	movw	r4, r20
    3472:	3b 01       	movw	r6, r22
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    3474:	41 14       	cp	r4, r1
    3476:	51 04       	cpc	r5, r1
    3478:	61 04       	cpc	r6, r1
    347a:	71 04       	cpc	r7, r1
    347c:	09 f4       	brne	.+2      	; 0x3480 <f_read+0xa8>
    347e:	bc c1       	rjmp	.+888    	; 0x37f8 <f_read+0x420>
    3480:	a9 82       	std	Y+1, r10	; 0x01
    3482:	9a 82       	std	Y+2, r9	; 0x02
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    3484:	0b 81       	ldd	r16, Y+3	; 0x03
    3486:	1c 81       	ldd	r17, Y+4	; 0x04
    3488:	00 5e       	subi	r16, 0xE0	; 224
    348a:	1f 4f       	sbci	r17, 0xFF	; 255
    348c:	1e 83       	std	Y+6, r17	; 0x06
    348e:	0d 83       	std	Y+5, r16	; 0x05
    3490:	bf 82       	std	Y+7, r11	; 0x07
    3492:	2b 81       	ldd	r18, Y+3	; 0x03
    3494:	3c 81       	ldd	r19, Y+4	; 0x04
    3496:	39 87       	std	Y+9, r19	; 0x09
    3498:	28 87       	std	Y+8, r18	; 0x08
    349a:	3c 82       	std	Y+4, r3	; 0x04
    349c:	2b 82       	std	Y+3, r2	; 0x03
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    349e:	a8 85       	ldd	r26, Y+8	; 0x08
    34a0:	b9 85       	ldd	r27, Y+9	; 0x09
    34a2:	16 96       	adiw	r26, 0x06	; 6
    34a4:	4d 91       	ld	r20, X+
    34a6:	5d 91       	ld	r21, X+
    34a8:	6d 91       	ld	r22, X+
    34aa:	7c 91       	ld	r23, X
    34ac:	19 97       	sbiw	r26, 0x09	; 9
    34ae:	db 01       	movw	r26, r22
    34b0:	ca 01       	movw	r24, r20
    34b2:	91 70       	andi	r25, 0x01	; 1
    34b4:	a0 70       	andi	r26, 0x00	; 0
    34b6:	b0 70       	andi	r27, 0x00	; 0
    34b8:	00 97       	sbiw	r24, 0x00	; 0
    34ba:	a1 05       	cpc	r26, r1
    34bc:	b1 05       	cpc	r27, r1
    34be:	09 f0       	breq	.+2      	; 0x34c2 <f_read+0xea>
    34c0:	3f c1       	rjmp	.+638    	; 0x3740 <f_read+0x368>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    34c2:	a8 85       	ldd	r26, Y+8	; 0x08
    34c4:	b9 85       	ldd	r27, Y+9	; 0x09
    34c6:	ed 91       	ld	r30, X+
    34c8:	fc 91       	ld	r31, X
    34ca:	db 01       	movw	r26, r22
    34cc:	ca 01       	movw	r24, r20
    34ce:	07 2e       	mov	r0, r23
    34d0:	79 e0       	ldi	r23, 0x09	; 9
    34d2:	b6 95       	lsr	r27
    34d4:	a7 95       	ror	r26
    34d6:	97 95       	ror	r25
    34d8:	87 95       	ror	r24
    34da:	7a 95       	dec	r23
    34dc:	d1 f7       	brne	.-12     	; 0x34d2 <f_read+0xfa>
    34de:	70 2d       	mov	r23, r0
    34e0:	02 81       	ldd	r16, Z+2	; 0x02
    34e2:	01 50       	subi	r16, 0x01	; 1
    34e4:	08 23       	and	r16, r24
			if (!csect) {						/* On the cluster boundary? */
    34e6:	09 f0       	breq	.+2      	; 0x34ea <f_read+0x112>
    34e8:	44 c0       	rjmp	.+136    	; 0x3572 <f_read+0x19a>
				if (fp->fptr == 0) {			/* On the top of the file? */
    34ea:	41 15       	cp	r20, r1
    34ec:	51 05       	cpc	r21, r1
    34ee:	61 05       	cpc	r22, r1
    34f0:	71 05       	cpc	r23, r1
    34f2:	39 f4       	brne	.+14     	; 0x3502 <f_read+0x12a>
					clst = fp->sclust;			/* Follow from the origin */
    34f4:	e8 85       	ldd	r30, Y+8	; 0x08
    34f6:	f9 85       	ldd	r31, Y+9	; 0x09
    34f8:	86 85       	ldd	r24, Z+14	; 0x0e
    34fa:	97 85       	ldd	r25, Z+15	; 0x0f
    34fc:	a0 89       	ldd	r26, Z+16	; 0x10
    34fe:	b1 89       	ldd	r27, Z+17	; 0x11
    3500:	0d c0       	rjmp	.+26     	; 0x351c <f_read+0x144>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    3502:	a8 85       	ldd	r26, Y+8	; 0x08
    3504:	b9 85       	ldd	r27, Y+9	; 0x09
    3506:	52 96       	adiw	r26, 0x12	; 18
    3508:	4d 91       	ld	r20, X+
    350a:	5d 91       	ld	r21, X+
    350c:	6d 91       	ld	r22, X+
    350e:	7c 91       	ld	r23, X
    3510:	55 97       	sbiw	r26, 0x15	; 21
    3512:	cf 01       	movw	r24, r30
    3514:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <get_fat>
    3518:	dc 01       	movw	r26, r24
    351a:	cb 01       	movw	r24, r22
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    351c:	82 30       	cpi	r24, 0x02	; 2
    351e:	91 05       	cpc	r25, r1
    3520:	a1 05       	cpc	r26, r1
    3522:	b1 05       	cpc	r27, r1
    3524:	48 f4       	brcc	.+18     	; 0x3538 <f_read+0x160>
    3526:	e8 85       	ldd	r30, Y+8	; 0x08
    3528:	f9 85       	ldd	r31, Y+9	; 0x09
    352a:	84 81       	ldd	r24, Z+4	; 0x04
    352c:	80 68       	ori	r24, 0x80	; 128
    352e:	84 83       	std	Z+4, r24	; 0x04
    3530:	bb 24       	eor	r11, r11
    3532:	68 94       	set
    3534:	b1 f8       	bld	r11, 1
    3536:	60 c1       	rjmp	.+704    	; 0x37f8 <f_read+0x420>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3538:	8f 3f       	cpi	r24, 0xFF	; 255
    353a:	ff ef       	ldi	r31, 0xFF	; 255
    353c:	9f 07       	cpc	r25, r31
    353e:	ff ef       	ldi	r31, 0xFF	; 255
    3540:	af 07       	cpc	r26, r31
    3542:	ff ef       	ldi	r31, 0xFF	; 255
    3544:	bf 07       	cpc	r27, r31
    3546:	79 f4       	brne	.+30     	; 0x3566 <f_read+0x18e>
    3548:	08 85       	ldd	r16, Y+8	; 0x08
    354a:	19 85       	ldd	r17, Y+9	; 0x09
    354c:	1c 83       	std	Y+4, r17	; 0x04
    354e:	0b 83       	std	Y+3, r16	; 0x03
    3550:	d8 01       	movw	r26, r16
    3552:	14 96       	adiw	r26, 0x04	; 4
    3554:	8c 91       	ld	r24, X
    3556:	14 97       	sbiw	r26, 0x04	; 4
    3558:	80 68       	ori	r24, 0x80	; 128
    355a:	14 96       	adiw	r26, 0x04	; 4
    355c:	8c 93       	st	X, r24
    355e:	14 97       	sbiw	r26, 0x04	; 4
    3560:	bb 24       	eor	r11, r11
    3562:	b3 94       	inc	r11
    3564:	49 c1       	rjmp	.+658    	; 0x37f8 <f_read+0x420>
				fp->clust = clst;				/* Update current cluster */
    3566:	e8 85       	ldd	r30, Y+8	; 0x08
    3568:	f9 85       	ldd	r31, Y+9	; 0x09
    356a:	82 8b       	std	Z+18, r24	; 0x12
    356c:	93 8b       	std	Z+19, r25	; 0x13
    356e:	a4 8b       	std	Z+20, r26	; 0x14
    3570:	b5 8b       	std	Z+21, r27	; 0x15
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    3572:	a8 85       	ldd	r26, Y+8	; 0x08
    3574:	b9 85       	ldd	r27, Y+9	; 0x09
    3576:	2d 90       	ld	r2, X+
    3578:	3c 90       	ld	r3, X
    357a:	11 97       	sbiw	r26, 0x01	; 1
    357c:	52 96       	adiw	r26, 0x12	; 18
    357e:	4d 91       	ld	r20, X+
    3580:	5d 91       	ld	r21, X+
    3582:	6d 91       	ld	r22, X+
    3584:	7c 91       	ld	r23, X
    3586:	55 97       	sbiw	r26, 0x15	; 21
    3588:	c1 01       	movw	r24, r2
    358a:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <clust2sect>
    358e:	dc 01       	movw	r26, r24
    3590:	cb 01       	movw	r24, r22
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    3592:	00 97       	sbiw	r24, 0x00	; 0
    3594:	a1 05       	cpc	r26, r1
    3596:	b1 05       	cpc	r27, r1
    3598:	49 f4       	brne	.+18     	; 0x35ac <f_read+0x1d4>
    359a:	e8 85       	ldd	r30, Y+8	; 0x08
    359c:	f9 85       	ldd	r31, Y+9	; 0x09
    359e:	84 81       	ldd	r24, Z+4	; 0x04
    35a0:	80 68       	ori	r24, 0x80	; 128
    35a2:	84 83       	std	Z+4, r24	; 0x04
    35a4:	bb 24       	eor	r11, r11
    35a6:	68 94       	set
    35a8:	b1 f8       	bld	r11, 1
    35aa:	26 c1       	rjmp	.+588    	; 0x37f8 <f_read+0x420>
			sect += csect;
    35ac:	40 2f       	mov	r20, r16
    35ae:	50 e0       	ldi	r21, 0x00	; 0
    35b0:	60 e0       	ldi	r22, 0x00	; 0
    35b2:	70 e0       	ldi	r23, 0x00	; 0
    35b4:	4c 01       	movw	r8, r24
    35b6:	5d 01       	movw	r10, r26
    35b8:	84 0e       	add	r8, r20
    35ba:	95 1e       	adc	r9, r21
    35bc:	a6 1e       	adc	r10, r22
    35be:	b7 1e       	adc	r11, r23
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    35c0:	73 01       	movw	r14, r6
    35c2:	62 01       	movw	r12, r4
    35c4:	0b 2e       	mov	r0, r27
    35c6:	b9 e0       	ldi	r27, 0x09	; 9
    35c8:	f6 94       	lsr	r15
    35ca:	e7 94       	ror	r14
    35cc:	d7 94       	ror	r13
    35ce:	c7 94       	ror	r12
    35d0:	ba 95       	dec	r27
    35d2:	d1 f7       	brne	.-12     	; 0x35c8 <f_read+0x1f0>
    35d4:	b0 2d       	mov	r27, r0
			if (cc) {							/* Read maximum contiguous sectors directly */
    35d6:	c1 14       	cp	r12, r1
    35d8:	d1 04       	cpc	r13, r1
    35da:	e1 04       	cpc	r14, r1
    35dc:	f1 04       	cpc	r15, r1
    35de:	09 f4       	brne	.+2      	; 0x35e2 <f_read+0x20a>
    35e0:	60 c0       	rjmp	.+192    	; 0x36a2 <f_read+0x2ca>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    35e2:	d1 01       	movw	r26, r2
    35e4:	12 96       	adiw	r26, 0x02	; 2
    35e6:	2c 91       	ld	r18, X
    35e8:	d7 01       	movw	r26, r14
    35ea:	c6 01       	movw	r24, r12
    35ec:	84 0f       	add	r24, r20
    35ee:	95 1f       	adc	r25, r21
    35f0:	a6 1f       	adc	r26, r22
    35f2:	b7 1f       	adc	r27, r23
    35f4:	42 2f       	mov	r20, r18
    35f6:	50 e0       	ldi	r21, 0x00	; 0
    35f8:	60 e0       	ldi	r22, 0x00	; 0
    35fa:	70 e0       	ldi	r23, 0x00	; 0
    35fc:	48 17       	cp	r20, r24
    35fe:	59 07       	cpc	r21, r25
    3600:	6a 07       	cpc	r22, r26
    3602:	7b 07       	cpc	r23, r27
    3604:	48 f4       	brcc	.+18     	; 0x3618 <f_read+0x240>
					cc = fp->fs->csize - csect;
    3606:	82 2f       	mov	r24, r18
    3608:	90 e0       	ldi	r25, 0x00	; 0
    360a:	80 1b       	sub	r24, r16
    360c:	91 09       	sbc	r25, r1
    360e:	6c 01       	movw	r12, r24
    3610:	ee 24       	eor	r14, r14
    3612:	d7 fc       	sbrc	r13, 7
    3614:	e0 94       	com	r14
    3616:	fe 2c       	mov	r15, r14
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    3618:	f1 01       	movw	r30, r2
    361a:	81 81       	ldd	r24, Z+1	; 0x01
    361c:	69 81       	ldd	r22, Y+1	; 0x01
    361e:	7a 81       	ldd	r23, Y+2	; 0x02
    3620:	a5 01       	movw	r20, r10
    3622:	94 01       	movw	r18, r8
    3624:	0c 2d       	mov	r16, r12
    3626:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    362a:	88 23       	and	r24, r24
    362c:	79 f0       	breq	.+30     	; 0x364c <f_read+0x274>
    362e:	08 85       	ldd	r16, Y+8	; 0x08
    3630:	19 85       	ldd	r17, Y+9	; 0x09
    3632:	1c 83       	std	Y+4, r17	; 0x04
    3634:	0b 83       	std	Y+3, r16	; 0x03
					ABORT(fp->fs, FR_DISK_ERR);
    3636:	d8 01       	movw	r26, r16
    3638:	14 96       	adiw	r26, 0x04	; 4
    363a:	8c 91       	ld	r24, X
    363c:	14 97       	sbiw	r26, 0x04	; 4
    363e:	80 68       	ori	r24, 0x80	; 128
    3640:	14 96       	adiw	r26, 0x04	; 4
    3642:	8c 93       	st	X, r24
    3644:	14 97       	sbiw	r26, 0x04	; 4
    3646:	bb 24       	eor	r11, r11
    3648:	b3 94       	inc	r11
    364a:	d6 c0       	rjmp	.+428    	; 0x37f8 <f_read+0x420>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
    364c:	e8 85       	ldd	r30, Y+8	; 0x08
    364e:	f9 85       	ldd	r31, Y+9	; 0x09
    3650:	84 81       	ldd	r24, Z+4	; 0x04
    3652:	86 ff       	sbrs	r24, 6
    3654:	1c c0       	rjmp	.+56     	; 0x368e <f_read+0x2b6>
    3656:	86 89       	ldd	r24, Z+22	; 0x16
    3658:	97 89       	ldd	r25, Z+23	; 0x17
    365a:	a0 8d       	ldd	r26, Z+24	; 0x18
    365c:	b1 8d       	ldd	r27, Z+25	; 0x19
    365e:	88 19       	sub	r24, r8
    3660:	99 09       	sbc	r25, r9
    3662:	aa 09       	sbc	r26, r10
    3664:	bb 09       	sbc	r27, r11
    3666:	8c 15       	cp	r24, r12
    3668:	9d 05       	cpc	r25, r13
    366a:	ae 05       	cpc	r26, r14
    366c:	bf 05       	cpc	r27, r15
    366e:	78 f4       	brcc	.+30     	; 0x368e <f_read+0x2b6>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
    3670:	98 2f       	mov	r25, r24
    3672:	88 27       	eor	r24, r24
    3674:	99 0f       	add	r25, r25
    3676:	09 81       	ldd	r16, Y+1	; 0x01
    3678:	1a 81       	ldd	r17, Y+2	; 0x02
    367a:	80 0f       	add	r24, r16
    367c:	91 1f       	adc	r25, r17
    367e:	6d 81       	ldd	r22, Y+5	; 0x05
    3680:	7e 81       	ldd	r23, Y+6	; 0x06
    3682:	20 e0       	ldi	r18, 0x00	; 0
    3684:	32 e0       	ldi	r19, 0x02	; 2
    3686:	40 e0       	ldi	r20, 0x00	; 0
    3688:	50 e0       	ldi	r21, 0x00	; 0
    368a:	0e 94 9e 08 	call	0x113c	; 0x113c <mem_cpy>
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    368e:	0b 2e       	mov	r0, r27
    3690:	b9 e0       	ldi	r27, 0x09	; 9
    3692:	cc 0c       	add	r12, r12
    3694:	dd 1c       	adc	r13, r13
    3696:	ee 1c       	adc	r14, r14
    3698:	ff 1c       	adc	r15, r15
    369a:	ba 95       	dec	r27
    369c:	d1 f7       	brne	.-12     	; 0x3692 <f_read+0x2ba>
    369e:	b0 2d       	mov	r27, r0
				continue;
    36a0:	79 c0       	rjmp	.+242    	; 0x3794 <f_read+0x3bc>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
    36a2:	a8 85       	ldd	r26, Y+8	; 0x08
    36a4:	b9 85       	ldd	r27, Y+9	; 0x09
    36a6:	56 96       	adiw	r26, 0x16	; 22
    36a8:	0d 91       	ld	r16, X+
    36aa:	1d 91       	ld	r17, X+
    36ac:	2d 91       	ld	r18, X+
    36ae:	3c 91       	ld	r19, X
    36b0:	59 97       	sbiw	r26, 0x19	; 25
    36b2:	08 15       	cp	r16, r8
    36b4:	19 05       	cpc	r17, r9
    36b6:	2a 05       	cpc	r18, r10
    36b8:	3b 05       	cpc	r19, r11
    36ba:	d1 f1       	breq	.+116    	; 0x3730 <f_read+0x358>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
    36bc:	14 96       	adiw	r26, 0x04	; 4
    36be:	8c 91       	ld	r24, X
    36c0:	14 97       	sbiw	r26, 0x04	; 4
    36c2:	86 ff       	sbrs	r24, 6
    36c4:	1f c0       	rjmp	.+62     	; 0x3704 <f_read+0x32c>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    36c6:	f1 01       	movw	r30, r2
    36c8:	81 81       	ldd	r24, Z+1	; 0x01
    36ca:	6d 81       	ldd	r22, Y+5	; 0x05
    36cc:	7e 81       	ldd	r23, Y+6	; 0x06
    36ce:	a9 01       	movw	r20, r18
    36d0:	98 01       	movw	r18, r16
    36d2:	01 e0       	ldi	r16, 0x01	; 1
    36d4:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    36d8:	88 23       	and	r24, r24
    36da:	79 f0       	breq	.+30     	; 0x36fa <f_read+0x322>
    36dc:	08 85       	ldd	r16, Y+8	; 0x08
    36de:	19 85       	ldd	r17, Y+9	; 0x09
    36e0:	1c 83       	std	Y+4, r17	; 0x04
    36e2:	0b 83       	std	Y+3, r16	; 0x03
						ABORT(fp->fs, FR_DISK_ERR);
    36e4:	d8 01       	movw	r26, r16
    36e6:	14 96       	adiw	r26, 0x04	; 4
    36e8:	8c 91       	ld	r24, X
    36ea:	14 97       	sbiw	r26, 0x04	; 4
    36ec:	80 68       	ori	r24, 0x80	; 128
    36ee:	14 96       	adiw	r26, 0x04	; 4
    36f0:	8c 93       	st	X, r24
    36f2:	14 97       	sbiw	r26, 0x04	; 4
    36f4:	bb 24       	eor	r11, r11
    36f6:	b3 94       	inc	r11
    36f8:	7f c0       	rjmp	.+254    	; 0x37f8 <f_read+0x420>
					fp->flag &= ~FA__DIRTY;
    36fa:	e8 85       	ldd	r30, Y+8	; 0x08
    36fc:	f9 85       	ldd	r31, Y+9	; 0x09
    36fe:	84 81       	ldd	r24, Z+4	; 0x04
    3700:	8f 7b       	andi	r24, 0xBF	; 191
    3702:	84 83       	std	Z+4, r24	; 0x04
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    3704:	a8 85       	ldd	r26, Y+8	; 0x08
    3706:	b9 85       	ldd	r27, Y+9	; 0x09
    3708:	ed 91       	ld	r30, X+
    370a:	fc 91       	ld	r31, X
    370c:	81 81       	ldd	r24, Z+1	; 0x01
    370e:	6d 81       	ldd	r22, Y+5	; 0x05
    3710:	7e 81       	ldd	r23, Y+6	; 0x06
    3712:	a5 01       	movw	r20, r10
    3714:	94 01       	movw	r18, r8
    3716:	01 e0       	ldi	r16, 0x01	; 1
    3718:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    371c:	88 23       	and	r24, r24
    371e:	41 f0       	breq	.+16     	; 0x3730 <f_read+0x358>
    3720:	e8 85       	ldd	r30, Y+8	; 0x08
    3722:	f9 85       	ldd	r31, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3724:	84 81       	ldd	r24, Z+4	; 0x04
    3726:	80 68       	ori	r24, 0x80	; 128
    3728:	84 83       	std	Z+4, r24	; 0x04
    372a:	bb 24       	eor	r11, r11
    372c:	b3 94       	inc	r11
    372e:	64 c0       	rjmp	.+200    	; 0x37f8 <f_read+0x420>
			}
#endif
			fp->dsect = sect;
    3730:	a8 85       	ldd	r26, Y+8	; 0x08
    3732:	b9 85       	ldd	r27, Y+9	; 0x09
    3734:	56 96       	adiw	r26, 0x16	; 22
    3736:	8d 92       	st	X+, r8
    3738:	9d 92       	st	X+, r9
    373a:	ad 92       	st	X+, r10
    373c:	bc 92       	st	X, r11
    373e:	59 97       	sbiw	r26, 0x19	; 25
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    3740:	e8 85       	ldd	r30, Y+8	; 0x08
    3742:	f9 85       	ldd	r31, Y+9	; 0x09
    3744:	46 81       	ldd	r20, Z+6	; 0x06
    3746:	57 81       	ldd	r21, Z+7	; 0x07
    3748:	60 85       	ldd	r22, Z+8	; 0x08
    374a:	71 85       	ldd	r23, Z+9	; 0x09
    374c:	db 01       	movw	r26, r22
    374e:	ca 01       	movw	r24, r20
    3750:	91 70       	andi	r25, 0x01	; 1
    3752:	a0 70       	andi	r26, 0x00	; 0
    3754:	b0 70       	andi	r27, 0x00	; 0
    3756:	00 e0       	ldi	r16, 0x00	; 0
    3758:	12 e0       	ldi	r17, 0x02	; 2
    375a:	20 e0       	ldi	r18, 0x00	; 0
    375c:	30 e0       	ldi	r19, 0x00	; 0
    375e:	08 1b       	sub	r16, r24
    3760:	19 0b       	sbc	r17, r25
    3762:	2a 0b       	sbc	r18, r26
    3764:	3b 0b       	sbc	r19, r27
    3766:	73 01       	movw	r14, r6
    3768:	62 01       	movw	r12, r4
    376a:	04 15       	cp	r16, r4
    376c:	15 05       	cpc	r17, r5
    376e:	26 05       	cpc	r18, r6
    3770:	37 05       	cpc	r19, r7
    3772:	10 f4       	brcc	.+4      	; 0x3778 <f_read+0x3a0>
    3774:	68 01       	movw	r12, r16
    3776:	79 01       	movw	r14, r18
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    3778:	ba 01       	movw	r22, r20
    377a:	71 70       	andi	r23, 0x01	; 1
    377c:	60 5e       	subi	r22, 0xE0	; 224
    377e:	7f 4f       	sbci	r23, 0xFF	; 255
    3780:	28 85       	ldd	r18, Y+8	; 0x08
    3782:	39 85       	ldd	r19, Y+9	; 0x09
    3784:	62 0f       	add	r22, r18
    3786:	73 1f       	adc	r23, r19
    3788:	89 81       	ldd	r24, Y+1	; 0x01
    378a:	9a 81       	ldd	r25, Y+2	; 0x02
    378c:	a7 01       	movw	r20, r14
    378e:	96 01       	movw	r18, r12
    3790:	0e 94 9e 08 	call	0x113c	; 0x113c <mem_cpy>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    3794:	89 81       	ldd	r24, Y+1	; 0x01
    3796:	9a 81       	ldd	r25, Y+2	; 0x02
    3798:	8c 0d       	add	r24, r12
    379a:	9d 1d       	adc	r25, r13
    379c:	9a 83       	std	Y+2, r25	; 0x02
    379e:	89 83       	std	Y+1, r24	; 0x01
    37a0:	e8 85       	ldd	r30, Y+8	; 0x08
    37a2:	f9 85       	ldd	r31, Y+9	; 0x09
    37a4:	86 81       	ldd	r24, Z+6	; 0x06
    37a6:	97 81       	ldd	r25, Z+7	; 0x07
    37a8:	a0 85       	ldd	r26, Z+8	; 0x08
    37aa:	b1 85       	ldd	r27, Z+9	; 0x09
    37ac:	8c 0d       	add	r24, r12
    37ae:	9d 1d       	adc	r25, r13
    37b0:	ae 1d       	adc	r26, r14
    37b2:	bf 1d       	adc	r27, r15
    37b4:	86 83       	std	Z+6, r24	; 0x06
    37b6:	97 83       	std	Z+7, r25	; 0x07
    37b8:	a0 87       	std	Z+8, r26	; 0x08
    37ba:	b1 87       	std	Z+9, r27	; 0x09
    37bc:	eb 81       	ldd	r30, Y+3	; 0x03
    37be:	fc 81       	ldd	r31, Y+4	; 0x04
    37c0:	80 81       	ld	r24, Z
    37c2:	91 81       	ldd	r25, Z+1	; 0x01
    37c4:	a2 81       	ldd	r26, Z+2	; 0x02
    37c6:	b3 81       	ldd	r27, Z+3	; 0x03
    37c8:	8c 0d       	add	r24, r12
    37ca:	9d 1d       	adc	r25, r13
    37cc:	ae 1d       	adc	r26, r14
    37ce:	bf 1d       	adc	r27, r15
    37d0:	80 83       	st	Z, r24
    37d2:	91 83       	std	Z+1, r25	; 0x01
    37d4:	a2 83       	std	Z+2, r26	; 0x02
    37d6:	b3 83       	std	Z+3, r27	; 0x03
    37d8:	4c 18       	sub	r4, r12
    37da:	5d 08       	sbc	r5, r13
    37dc:	6e 08       	sbc	r6, r14
    37de:	7f 08       	sbc	r7, r15
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    37e0:	09 f0       	breq	.+2      	; 0x37e4 <f_read+0x40c>
    37e2:	5d ce       	rjmp	.-838    	; 0x349e <f_read+0xc6>
    37e4:	bf 80       	ldd	r11, Y+7	; 0x07
    37e6:	08 c0       	rjmp	.+16     	; 0x37f8 <f_read+0x420>
	*br = 0;	/* Clear read byte counter */

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    37e8:	bb 24       	eor	r11, r11
    37ea:	68 94       	set
    37ec:	b1 f8       	bld	r11, 1
    37ee:	04 c0       	rjmp	.+8      	; 0x37f8 <f_read+0x420>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    37f0:	0f 2e       	mov	r0, r31
    37f2:	f7 e0       	ldi	r31, 0x07	; 7
    37f4:	bf 2e       	mov	r11, r31
    37f6:	f0 2d       	mov	r31, r0
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    37f8:	8b 2d       	mov	r24, r11
    37fa:	29 96       	adiw	r28, 0x09	; 9
    37fc:	0f b6       	in	r0, 0x3f	; 63
    37fe:	f8 94       	cli
    3800:	de bf       	out	0x3e, r29	; 62
    3802:	0f be       	out	0x3f, r0	; 63
    3804:	cd bf       	out	0x3d, r28	; 61
    3806:	df 91       	pop	r29
    3808:	cf 91       	pop	r28
    380a:	1f 91       	pop	r17
    380c:	0f 91       	pop	r16
    380e:	ff 90       	pop	r15
    3810:	ef 90       	pop	r14
    3812:	df 90       	pop	r13
    3814:	cf 90       	pop	r12
    3816:	bf 90       	pop	r11
    3818:	af 90       	pop	r10
    381a:	9f 90       	pop	r9
    381c:	8f 90       	pop	r8
    381e:	7f 90       	pop	r7
    3820:	6f 90       	pop	r6
    3822:	5f 90       	pop	r5
    3824:	4f 90       	pop	r4
    3826:	3f 90       	pop	r3
    3828:	2f 90       	pop	r2
    382a:	08 95       	ret

0000382c <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
    382c:	2f 92       	push	r2
    382e:	3f 92       	push	r3
    3830:	4f 92       	push	r4
    3832:	5f 92       	push	r5
    3834:	6f 92       	push	r6
    3836:	7f 92       	push	r7
    3838:	8f 92       	push	r8
    383a:	9f 92       	push	r9
    383c:	af 92       	push	r10
    383e:	bf 92       	push	r11
    3840:	cf 92       	push	r12
    3842:	df 92       	push	r13
    3844:	ef 92       	push	r14
    3846:	ff 92       	push	r15
    3848:	0f 93       	push	r16
    384a:	1f 93       	push	r17
    384c:	cf 93       	push	r28
    384e:	df 93       	push	r29
    3850:	cd b7       	in	r28, 0x3d	; 61
    3852:	de b7       	in	r29, 0x3e	; 62
    3854:	29 97       	sbiw	r28, 0x09	; 9
    3856:	0f b6       	in	r0, 0x3f	; 63
    3858:	f8 94       	cli
    385a:	de bf       	out	0x3e, r29	; 62
    385c:	0f be       	out	0x3f, r0	; 63
    385e:	cd bf       	out	0x3d, r28	; 61
    3860:	2c 01       	movw	r4, r24
    3862:	c6 2e       	mov	r12, r22
    3864:	f7 2e       	mov	r15, r23
    3866:	49 01       	movw	r8, r18
    3868:	5a 01       	movw	r10, r20
    386a:	1a 83       	std	Y+2, r17	; 0x02
    386c:	09 83       	std	Y+1, r16	; 0x01
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
    386e:	d8 01       	movw	r26, r16
    3870:	1d 92       	st	X+, r1
    3872:	1d 92       	st	X+, r1
    3874:	1d 92       	st	X+, r1
    3876:	1c 92       	st	X, r1
    3878:	13 97       	sbiw	r26, 0x03	; 3

	res = validate(fp);						/* Check validity */
    387a:	0e 94 84 09 	call	0x1308	; 0x1308 <validate>
    387e:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3880:	88 23       	and	r24, r24
    3882:	09 f0       	breq	.+2      	; 0x3886 <f_write+0x5a>
    3884:	17 c2       	rjmp	.+1070   	; 0x3cb4 <f_write+0x488>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
    3886:	f2 01       	movw	r30, r4
    3888:	84 81       	ldd	r24, Z+4	; 0x04
    388a:	88 23       	and	r24, r24
    388c:	0c f4       	brge	.+2      	; 0x3890 <f_write+0x64>
    388e:	0f c2       	rjmp	.+1054   	; 0x3cae <f_write+0x482>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    3890:	81 ff       	sbrs	r24, 1
    3892:	0f c2       	rjmp	.+1054   	; 0x3cb2 <f_write+0x486>
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
    3894:	82 85       	ldd	r24, Z+10	; 0x0a
    3896:	93 85       	ldd	r25, Z+11	; 0x0b
    3898:	a4 85       	ldd	r26, Z+12	; 0x0c
    389a:	b5 85       	ldd	r27, Z+13	; 0x0d
    389c:	b5 01       	movw	r22, r10
    389e:	a4 01       	movw	r20, r8
    38a0:	48 0f       	add	r20, r24
    38a2:	59 1f       	adc	r21, r25
    38a4:	6a 1f       	adc	r22, r26
    38a6:	7b 1f       	adc	r23, r27
    38a8:	48 17       	cp	r20, r24
    38aa:	59 07       	cpc	r21, r25
    38ac:	6a 07       	cpc	r22, r26
    38ae:	7b 07       	cpc	r23, r27
    38b0:	08 f4       	brcc	.+2      	; 0x38b4 <f_write+0x88>
    38b2:	e2 c1       	rjmp	.+964    	; 0x3c78 <f_write+0x44c>

	for ( ;  btw;							/* Repeat until all data written */
    38b4:	81 14       	cp	r8, r1
    38b6:	91 04       	cpc	r9, r1
    38b8:	a1 04       	cpc	r10, r1
    38ba:	b1 04       	cpc	r11, r1
    38bc:	09 f4       	brne	.+2      	; 0x38c0 <f_write+0x94>
    38be:	dc c1       	rjmp	.+952    	; 0x3c78 <f_write+0x44c>
    38c0:	cb 82       	std	Y+3, r12	; 0x03
    38c2:	fc 82       	std	Y+4, r15	; 0x04
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    38c4:	92 01       	movw	r18, r4
    38c6:	20 5e       	subi	r18, 0xE0	; 224
    38c8:	3f 4f       	sbci	r19, 0xFF	; 255
    38ca:	3e 83       	std	Y+6, r19	; 0x06
    38cc:	2d 83       	std	Y+5, r18	; 0x05
    38ce:	1f 83       	std	Y+7, r17	; 0x07
    38d0:	59 86       	std	Y+9, r5	; 0x09
    38d2:	48 86       	std	Y+8, r4	; 0x08
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    38d4:	a8 85       	ldd	r26, Y+8	; 0x08
    38d6:	b9 85       	ldd	r27, Y+9	; 0x09
    38d8:	16 96       	adiw	r26, 0x06	; 6
    38da:	4d 91       	ld	r20, X+
    38dc:	5d 91       	ld	r21, X+
    38de:	6d 91       	ld	r22, X+
    38e0:	7c 91       	ld	r23, X
    38e2:	19 97       	sbiw	r26, 0x09	; 9
    38e4:	db 01       	movw	r26, r22
    38e6:	ca 01       	movw	r24, r20
    38e8:	91 70       	andi	r25, 0x01	; 1
    38ea:	a0 70       	andi	r26, 0x00	; 0
    38ec:	b0 70       	andi	r27, 0x00	; 0
    38ee:	00 97       	sbiw	r24, 0x00	; 0
    38f0:	a1 05       	cpc	r26, r1
    38f2:	b1 05       	cpc	r27, r1
    38f4:	09 f0       	breq	.+2      	; 0x38f8 <f_write+0xcc>
    38f6:	60 c1       	rjmp	.+704    	; 0x3bb8 <f_write+0x38c>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    38f8:	e8 85       	ldd	r30, Y+8	; 0x08
    38fa:	f9 85       	ldd	r31, Y+9	; 0x09
    38fc:	20 81       	ld	r18, Z
    38fe:	31 81       	ldd	r19, Z+1	; 0x01
    3900:	db 01       	movw	r26, r22
    3902:	ca 01       	movw	r24, r20
    3904:	07 2e       	mov	r0, r23
    3906:	79 e0       	ldi	r23, 0x09	; 9
    3908:	b6 95       	lsr	r27
    390a:	a7 95       	ror	r26
    390c:	97 95       	ror	r25
    390e:	87 95       	ror	r24
    3910:	7a 95       	dec	r23
    3912:	d1 f7       	brne	.-12     	; 0x3908 <f_write+0xdc>
    3914:	70 2d       	mov	r23, r0
    3916:	f9 01       	movw	r30, r18
    3918:	12 81       	ldd	r17, Z+2	; 0x02
    391a:	11 50       	subi	r17, 0x01	; 1
    391c:	18 23       	and	r17, r24
			if (!csect) {					/* On the cluster boundary? */
    391e:	09 f0       	breq	.+2      	; 0x3922 <f_write+0xf6>
    3920:	57 c0       	rjmp	.+174    	; 0x39d0 <f_write+0x1a4>
				if (fp->fptr == 0) {		/* On the top of the file? */
    3922:	41 15       	cp	r20, r1
    3924:	51 05       	cpc	r21, r1
    3926:	61 05       	cpc	r22, r1
    3928:	71 05       	cpc	r23, r1
    392a:	c9 f4       	brne	.+50     	; 0x395e <f_write+0x132>
					clst = fp->sclust;		/* Follow from the origin */
    392c:	e8 85       	ldd	r30, Y+8	; 0x08
    392e:	f9 85       	ldd	r31, Y+9	; 0x09
    3930:	86 85       	ldd	r24, Z+14	; 0x0e
    3932:	97 85       	ldd	r25, Z+15	; 0x0f
    3934:	a0 89       	ldd	r26, Z+16	; 0x10
    3936:	b1 89       	ldd	r27, Z+17	; 0x11
					if (clst == 0)			/* When no cluster is allocated, */
    3938:	00 97       	sbiw	r24, 0x00	; 0
    393a:	a1 05       	cpc	r26, r1
    393c:	b1 05       	cpc	r27, r1
    393e:	09 f5       	brne	.+66     	; 0x3982 <f_write+0x156>
						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    3940:	c9 01       	movw	r24, r18
    3942:	40 e0       	ldi	r20, 0x00	; 0
    3944:	50 e0       	ldi	r21, 0x00	; 0
    3946:	ba 01       	movw	r22, r20
    3948:	0e 94 07 13 	call	0x260e	; 0x260e <create_chain>
    394c:	dc 01       	movw	r26, r24
    394e:	cb 01       	movw	r24, r22
    3950:	e8 85       	ldd	r30, Y+8	; 0x08
    3952:	f9 85       	ldd	r31, Y+9	; 0x09
    3954:	86 87       	std	Z+14, r24	; 0x0e
    3956:	97 87       	std	Z+15, r25	; 0x0f
    3958:	a0 8b       	std	Z+16, r26	; 0x10
    395a:	b1 8b       	std	Z+17, r27	; 0x11
    395c:	0d c0       	rjmp	.+26     	; 0x3978 <f_write+0x14c>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    395e:	a8 85       	ldd	r26, Y+8	; 0x08
    3960:	b9 85       	ldd	r27, Y+9	; 0x09
    3962:	52 96       	adiw	r26, 0x12	; 18
    3964:	4d 91       	ld	r20, X+
    3966:	5d 91       	ld	r21, X+
    3968:	6d 91       	ld	r22, X+
    396a:	7c 91       	ld	r23, X
    396c:	55 97       	sbiw	r26, 0x15	; 21
    396e:	c9 01       	movw	r24, r18
    3970:	0e 94 07 13 	call	0x260e	; 0x260e <create_chain>
    3974:	dc 01       	movw	r26, r24
    3976:	cb 01       	movw	r24, r22
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    3978:	00 97       	sbiw	r24, 0x00	; 0
    397a:	a1 05       	cpc	r26, r1
    397c:	b1 05       	cpc	r27, r1
    397e:	09 f4       	brne	.+2      	; 0x3982 <f_write+0x156>
    3980:	78 c1       	rjmp	.+752    	; 0x3c72 <f_write+0x446>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    3982:	81 30       	cpi	r24, 0x01	; 1
    3984:	91 05       	cpc	r25, r1
    3986:	a1 05       	cpc	r26, r1
    3988:	b1 05       	cpc	r27, r1
    398a:	41 f4       	brne	.+16     	; 0x399c <f_write+0x170>
    398c:	48 84       	ldd	r4, Y+8	; 0x08
    398e:	59 84       	ldd	r5, Y+9	; 0x09
    3990:	f2 01       	movw	r30, r4
    3992:	84 81       	ldd	r24, Z+4	; 0x04
    3994:	80 68       	ori	r24, 0x80	; 128
    3996:	84 83       	std	Z+4, r24	; 0x04
    3998:	12 e0       	ldi	r17, 0x02	; 2
    399a:	8c c1       	rjmp	.+792    	; 0x3cb4 <f_write+0x488>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    399c:	8f 3f       	cpi	r24, 0xFF	; 255
    399e:	ff ef       	ldi	r31, 0xFF	; 255
    39a0:	9f 07       	cpc	r25, r31
    39a2:	ff ef       	ldi	r31, 0xFF	; 255
    39a4:	af 07       	cpc	r26, r31
    39a6:	ff ef       	ldi	r31, 0xFF	; 255
    39a8:	bf 07       	cpc	r27, r31
    39aa:	61 f4       	brne	.+24     	; 0x39c4 <f_write+0x198>
    39ac:	48 84       	ldd	r4, Y+8	; 0x08
    39ae:	59 84       	ldd	r5, Y+9	; 0x09
    39b0:	d2 01       	movw	r26, r4
    39b2:	14 96       	adiw	r26, 0x04	; 4
    39b4:	8c 91       	ld	r24, X
    39b6:	14 97       	sbiw	r26, 0x04	; 4
    39b8:	80 68       	ori	r24, 0x80	; 128
    39ba:	14 96       	adiw	r26, 0x04	; 4
    39bc:	8c 93       	st	X, r24
    39be:	14 97       	sbiw	r26, 0x04	; 4
    39c0:	11 e0       	ldi	r17, 0x01	; 1
    39c2:	78 c1       	rjmp	.+752    	; 0x3cb4 <f_write+0x488>
				fp->clust = clst;			/* Update current cluster */
    39c4:	e8 85       	ldd	r30, Y+8	; 0x08
    39c6:	f9 85       	ldd	r31, Y+9	; 0x09
    39c8:	82 8b       	std	Z+18, r24	; 0x12
    39ca:	93 8b       	std	Z+19, r25	; 0x13
    39cc:	a4 8b       	std	Z+20, r26	; 0x14
    39ce:	b5 8b       	std	Z+21, r27	; 0x15
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
    39d0:	a8 85       	ldd	r26, Y+8	; 0x08
    39d2:	b9 85       	ldd	r27, Y+9	; 0x09
    39d4:	14 96       	adiw	r26, 0x04	; 4
    39d6:	8c 91       	ld	r24, X
    39d8:	14 97       	sbiw	r26, 0x04	; 4
    39da:	86 ff       	sbrs	r24, 6
    39dc:	21 c0       	rjmp	.+66     	; 0x3a20 <f_write+0x1f4>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    39de:	ed 91       	ld	r30, X+
    39e0:	fc 91       	ld	r31, X
    39e2:	11 97       	sbiw	r26, 0x01	; 1
    39e4:	56 96       	adiw	r26, 0x16	; 22
    39e6:	2d 91       	ld	r18, X+
    39e8:	3d 91       	ld	r19, X+
    39ea:	4d 91       	ld	r20, X+
    39ec:	5c 91       	ld	r21, X
    39ee:	59 97       	sbiw	r26, 0x19	; 25
    39f0:	81 81       	ldd	r24, Z+1	; 0x01
    39f2:	6d 81       	ldd	r22, Y+5	; 0x05
    39f4:	7e 81       	ldd	r23, Y+6	; 0x06
    39f6:	01 e0       	ldi	r16, 0x01	; 1
    39f8:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    39fc:	88 23       	and	r24, r24
    39fe:	41 f0       	breq	.+16     	; 0x3a10 <f_write+0x1e4>
    3a00:	48 84       	ldd	r4, Y+8	; 0x08
    3a02:	59 84       	ldd	r5, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3a04:	f2 01       	movw	r30, r4
    3a06:	84 81       	ldd	r24, Z+4	; 0x04
    3a08:	80 68       	ori	r24, 0x80	; 128
    3a0a:	84 83       	std	Z+4, r24	; 0x04
    3a0c:	11 e0       	ldi	r17, 0x01	; 1
    3a0e:	52 c1       	rjmp	.+676    	; 0x3cb4 <f_write+0x488>
				fp->flag &= ~FA__DIRTY;
    3a10:	a8 85       	ldd	r26, Y+8	; 0x08
    3a12:	b9 85       	ldd	r27, Y+9	; 0x09
    3a14:	14 96       	adiw	r26, 0x04	; 4
    3a16:	8c 91       	ld	r24, X
    3a18:	14 97       	sbiw	r26, 0x04	; 4
    3a1a:	8f 7b       	andi	r24, 0xBF	; 191
    3a1c:	14 96       	adiw	r26, 0x04	; 4
    3a1e:	8c 93       	st	X, r24
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    3a20:	e8 85       	ldd	r30, Y+8	; 0x08
    3a22:	f9 85       	ldd	r31, Y+9	; 0x09
    3a24:	20 80       	ld	r2, Z
    3a26:	31 80       	ldd	r3, Z+1	; 0x01
    3a28:	42 89       	ldd	r20, Z+18	; 0x12
    3a2a:	53 89       	ldd	r21, Z+19	; 0x13
    3a2c:	64 89       	ldd	r22, Z+20	; 0x14
    3a2e:	75 89       	ldd	r23, Z+21	; 0x15
    3a30:	c1 01       	movw	r24, r2
    3a32:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <clust2sect>
    3a36:	dc 01       	movw	r26, r24
    3a38:	cb 01       	movw	r24, r22
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    3a3a:	00 97       	sbiw	r24, 0x00	; 0
    3a3c:	a1 05       	cpc	r26, r1
    3a3e:	b1 05       	cpc	r27, r1
    3a40:	61 f4       	brne	.+24     	; 0x3a5a <f_write+0x22e>
    3a42:	48 84       	ldd	r4, Y+8	; 0x08
    3a44:	59 84       	ldd	r5, Y+9	; 0x09
    3a46:	d2 01       	movw	r26, r4
    3a48:	14 96       	adiw	r26, 0x04	; 4
    3a4a:	8c 91       	ld	r24, X
    3a4c:	14 97       	sbiw	r26, 0x04	; 4
    3a4e:	80 68       	ori	r24, 0x80	; 128
    3a50:	14 96       	adiw	r26, 0x04	; 4
    3a52:	8c 93       	st	X, r24
    3a54:	14 97       	sbiw	r26, 0x04	; 4
    3a56:	12 e0       	ldi	r17, 0x02	; 2
    3a58:	2d c1       	rjmp	.+602    	; 0x3cb4 <f_write+0x488>
			sect += csect;
    3a5a:	41 2f       	mov	r20, r17
    3a5c:	50 e0       	ldi	r21, 0x00	; 0
    3a5e:	60 e0       	ldi	r22, 0x00	; 0
    3a60:	70 e0       	ldi	r23, 0x00	; 0
    3a62:	2c 01       	movw	r4, r24
    3a64:	3d 01       	movw	r6, r26
    3a66:	44 0e       	add	r4, r20
    3a68:	55 1e       	adc	r5, r21
    3a6a:	66 1e       	adc	r6, r22
    3a6c:	77 1e       	adc	r7, r23
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    3a6e:	75 01       	movw	r14, r10
    3a70:	64 01       	movw	r12, r8
    3a72:	0b 2e       	mov	r0, r27
    3a74:	b9 e0       	ldi	r27, 0x09	; 9
    3a76:	f6 94       	lsr	r15
    3a78:	e7 94       	ror	r14
    3a7a:	d7 94       	ror	r13
    3a7c:	c7 94       	ror	r12
    3a7e:	ba 95       	dec	r27
    3a80:	d1 f7       	brne	.-12     	; 0x3a76 <f_write+0x24a>
    3a82:	b0 2d       	mov	r27, r0
			if (cc) {						/* Write maximum contiguous sectors directly */
    3a84:	c1 14       	cp	r12, r1
    3a86:	d1 04       	cpc	r13, r1
    3a88:	e1 04       	cpc	r14, r1
    3a8a:	f1 04       	cpc	r15, r1
    3a8c:	09 f4       	brne	.+2      	; 0x3a90 <f_write+0x264>
    3a8e:	60 c0       	rjmp	.+192    	; 0x3b50 <f_write+0x324>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    3a90:	f1 01       	movw	r30, r2
    3a92:	22 81       	ldd	r18, Z+2	; 0x02
    3a94:	d7 01       	movw	r26, r14
    3a96:	c6 01       	movw	r24, r12
    3a98:	84 0f       	add	r24, r20
    3a9a:	95 1f       	adc	r25, r21
    3a9c:	a6 1f       	adc	r26, r22
    3a9e:	b7 1f       	adc	r27, r23
    3aa0:	42 2f       	mov	r20, r18
    3aa2:	50 e0       	ldi	r21, 0x00	; 0
    3aa4:	60 e0       	ldi	r22, 0x00	; 0
    3aa6:	70 e0       	ldi	r23, 0x00	; 0
    3aa8:	48 17       	cp	r20, r24
    3aaa:	59 07       	cpc	r21, r25
    3aac:	6a 07       	cpc	r22, r26
    3aae:	7b 07       	cpc	r23, r27
    3ab0:	48 f4       	brcc	.+18     	; 0x3ac4 <f_write+0x298>
					cc = fp->fs->csize - csect;
    3ab2:	82 2f       	mov	r24, r18
    3ab4:	90 e0       	ldi	r25, 0x00	; 0
    3ab6:	81 1b       	sub	r24, r17
    3ab8:	91 09       	sbc	r25, r1
    3aba:	6c 01       	movw	r12, r24
    3abc:	ee 24       	eor	r14, r14
    3abe:	d7 fc       	sbrc	r13, 7
    3ac0:	e0 94       	com	r14
    3ac2:	fe 2c       	mov	r15, r14
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
    3ac4:	d1 01       	movw	r26, r2
    3ac6:	11 96       	adiw	r26, 0x01	; 1
    3ac8:	8c 91       	ld	r24, X
    3aca:	6b 81       	ldd	r22, Y+3	; 0x03
    3acc:	7c 81       	ldd	r23, Y+4	; 0x04
    3ace:	a3 01       	movw	r20, r6
    3ad0:	92 01       	movw	r18, r4
    3ad2:	0c 2d       	mov	r16, r12
    3ad4:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    3ad8:	88 23       	and	r24, r24
    3ada:	41 f0       	breq	.+16     	; 0x3aec <f_write+0x2c0>
    3adc:	48 84       	ldd	r4, Y+8	; 0x08
    3ade:	59 84       	ldd	r5, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3ae0:	f2 01       	movw	r30, r4
    3ae2:	84 81       	ldd	r24, Z+4	; 0x04
    3ae4:	80 68       	ori	r24, 0x80	; 128
    3ae6:	84 83       	std	Z+4, r24	; 0x04
    3ae8:	11 e0       	ldi	r17, 0x01	; 1
    3aea:	e4 c0       	rjmp	.+456    	; 0x3cb4 <f_write+0x488>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
    3aec:	e8 85       	ldd	r30, Y+8	; 0x08
    3aee:	f9 85       	ldd	r31, Y+9	; 0x09
    3af0:	86 89       	ldd	r24, Z+22	; 0x16
    3af2:	97 89       	ldd	r25, Z+23	; 0x17
    3af4:	a0 8d       	ldd	r26, Z+24	; 0x18
    3af6:	b1 8d       	ldd	r27, Z+25	; 0x19
    3af8:	84 19       	sub	r24, r4
    3afa:	95 09       	sbc	r25, r5
    3afc:	a6 09       	sbc	r26, r6
    3afe:	b7 09       	sbc	r27, r7
    3b00:	8c 15       	cp	r24, r12
    3b02:	9d 05       	cpc	r25, r13
    3b04:	ae 05       	cpc	r26, r14
    3b06:	bf 05       	cpc	r27, r15
    3b08:	c8 f4       	brcc	.+50     	; 0x3b3c <f_write+0x310>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
    3b0a:	bc 01       	movw	r22, r24
    3b0c:	76 2f       	mov	r23, r22
    3b0e:	66 27       	eor	r22, r22
    3b10:	77 0f       	add	r23, r23
    3b12:	0b 81       	ldd	r16, Y+3	; 0x03
    3b14:	1c 81       	ldd	r17, Y+4	; 0x04
    3b16:	60 0f       	add	r22, r16
    3b18:	71 1f       	adc	r23, r17
    3b1a:	8d 81       	ldd	r24, Y+5	; 0x05
    3b1c:	9e 81       	ldd	r25, Y+6	; 0x06
    3b1e:	20 e0       	ldi	r18, 0x00	; 0
    3b20:	32 e0       	ldi	r19, 0x02	; 2
    3b22:	40 e0       	ldi	r20, 0x00	; 0
    3b24:	50 e0       	ldi	r21, 0x00	; 0
    3b26:	0e 94 9e 08 	call	0x113c	; 0x113c <mem_cpy>
					fp->flag &= ~FA__DIRTY;
    3b2a:	a8 85       	ldd	r26, Y+8	; 0x08
    3b2c:	b9 85       	ldd	r27, Y+9	; 0x09
    3b2e:	14 96       	adiw	r26, 0x04	; 4
    3b30:	8c 91       	ld	r24, X
    3b32:	14 97       	sbiw	r26, 0x04	; 4
    3b34:	8f 7b       	andi	r24, 0xBF	; 191
    3b36:	14 96       	adiw	r26, 0x04	; 4
    3b38:	8c 93       	st	X, r24
    3b3a:	14 97       	sbiw	r26, 0x04	; 4
				}
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    3b3c:	0b 2e       	mov	r0, r27
    3b3e:	b9 e0       	ldi	r27, 0x09	; 9
    3b40:	cc 0c       	add	r12, r12
    3b42:	dd 1c       	adc	r13, r13
    3b44:	ee 1c       	adc	r14, r14
    3b46:	ff 1c       	adc	r15, r15
    3b48:	ba 95       	dec	r27
    3b4a:	d1 f7       	brne	.-12     	; 0x3b40 <f_write+0x314>
    3b4c:	b0 2d       	mov	r27, r0
				continue;
    3b4e:	65 c0       	rjmp	.+202    	; 0x3c1a <f_write+0x3ee>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
    3b50:	e8 85       	ldd	r30, Y+8	; 0x08
    3b52:	f9 85       	ldd	r31, Y+9	; 0x09
    3b54:	86 89       	ldd	r24, Z+22	; 0x16
    3b56:	97 89       	ldd	r25, Z+23	; 0x17
    3b58:	a0 8d       	ldd	r26, Z+24	; 0x18
    3b5a:	b1 8d       	ldd	r27, Z+25	; 0x19
    3b5c:	84 15       	cp	r24, r4
    3b5e:	95 05       	cpc	r25, r5
    3b60:	a6 05       	cpc	r26, r6
    3b62:	b7 05       	cpc	r27, r7
    3b64:	09 f1       	breq	.+66     	; 0x3ba8 <f_write+0x37c>
				if (fp->fptr < fp->fsize &&
    3b66:	86 81       	ldd	r24, Z+6	; 0x06
    3b68:	97 81       	ldd	r25, Z+7	; 0x07
    3b6a:	a0 85       	ldd	r26, Z+8	; 0x08
    3b6c:	b1 85       	ldd	r27, Z+9	; 0x09
    3b6e:	42 85       	ldd	r20, Z+10	; 0x0a
    3b70:	53 85       	ldd	r21, Z+11	; 0x0b
    3b72:	64 85       	ldd	r22, Z+12	; 0x0c
    3b74:	75 85       	ldd	r23, Z+13	; 0x0d
    3b76:	84 17       	cp	r24, r20
    3b78:	95 07       	cpc	r25, r21
    3b7a:	a6 07       	cpc	r26, r22
    3b7c:	b7 07       	cpc	r27, r23
    3b7e:	a0 f4       	brcc	.+40     	; 0x3ba8 <f_write+0x37c>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    3b80:	d1 01       	movw	r26, r2
    3b82:	11 96       	adiw	r26, 0x01	; 1
    3b84:	8c 91       	ld	r24, X
    3b86:	6d 81       	ldd	r22, Y+5	; 0x05
    3b88:	7e 81       	ldd	r23, Y+6	; 0x06
    3b8a:	a3 01       	movw	r20, r6
    3b8c:	92 01       	movw	r18, r4
    3b8e:	01 e0       	ldi	r16, 0x01	; 1
    3b90:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
    3b94:	88 23       	and	r24, r24
    3b96:	41 f0       	breq	.+16     	; 0x3ba8 <f_write+0x37c>
    3b98:	48 84       	ldd	r4, Y+8	; 0x08
    3b9a:	59 84       	ldd	r5, Y+9	; 0x09
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
    3b9c:	f2 01       	movw	r30, r4
    3b9e:	84 81       	ldd	r24, Z+4	; 0x04
    3ba0:	80 68       	ori	r24, 0x80	; 128
    3ba2:	84 83       	std	Z+4, r24	; 0x04
    3ba4:	11 e0       	ldi	r17, 0x01	; 1
    3ba6:	86 c0       	rjmp	.+268    	; 0x3cb4 <f_write+0x488>
			}
#endif
			fp->dsect = sect;
    3ba8:	a8 85       	ldd	r26, Y+8	; 0x08
    3baa:	b9 85       	ldd	r27, Y+9	; 0x09
    3bac:	56 96       	adiw	r26, 0x16	; 22
    3bae:	4d 92       	st	X+, r4
    3bb0:	5d 92       	st	X+, r5
    3bb2:	6d 92       	st	X+, r6
    3bb4:	7c 92       	st	X, r7
    3bb6:	59 97       	sbiw	r26, 0x19	; 25
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    3bb8:	e8 85       	ldd	r30, Y+8	; 0x08
    3bba:	f9 85       	ldd	r31, Y+9	; 0x09
    3bbc:	46 81       	ldd	r20, Z+6	; 0x06
    3bbe:	57 81       	ldd	r21, Z+7	; 0x07
    3bc0:	60 85       	ldd	r22, Z+8	; 0x08
    3bc2:	71 85       	ldd	r23, Z+9	; 0x09
    3bc4:	db 01       	movw	r26, r22
    3bc6:	ca 01       	movw	r24, r20
    3bc8:	91 70       	andi	r25, 0x01	; 1
    3bca:	a0 70       	andi	r26, 0x00	; 0
    3bcc:	b0 70       	andi	r27, 0x00	; 0
    3bce:	00 e0       	ldi	r16, 0x00	; 0
    3bd0:	12 e0       	ldi	r17, 0x02	; 2
    3bd2:	20 e0       	ldi	r18, 0x00	; 0
    3bd4:	30 e0       	ldi	r19, 0x00	; 0
    3bd6:	08 1b       	sub	r16, r24
    3bd8:	19 0b       	sbc	r17, r25
    3bda:	2a 0b       	sbc	r18, r26
    3bdc:	3b 0b       	sbc	r19, r27
    3bde:	75 01       	movw	r14, r10
    3be0:	64 01       	movw	r12, r8
    3be2:	08 15       	cp	r16, r8
    3be4:	19 05       	cpc	r17, r9
    3be6:	2a 05       	cpc	r18, r10
    3be8:	3b 05       	cpc	r19, r11
    3bea:	10 f4       	brcc	.+4      	; 0x3bf0 <f_write+0x3c4>
    3bec:	68 01       	movw	r12, r16
    3bee:	79 01       	movw	r14, r18
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    3bf0:	ca 01       	movw	r24, r20
    3bf2:	91 70       	andi	r25, 0x01	; 1
    3bf4:	80 96       	adiw	r24, 0x20	; 32
    3bf6:	28 85       	ldd	r18, Y+8	; 0x08
    3bf8:	39 85       	ldd	r19, Y+9	; 0x09
    3bfa:	82 0f       	add	r24, r18
    3bfc:	93 1f       	adc	r25, r19
    3bfe:	6b 81       	ldd	r22, Y+3	; 0x03
    3c00:	7c 81       	ldd	r23, Y+4	; 0x04
    3c02:	a7 01       	movw	r20, r14
    3c04:	96 01       	movw	r18, r12
    3c06:	0e 94 9e 08 	call	0x113c	; 0x113c <mem_cpy>
		fp->flag |= FA__DIRTY;
    3c0a:	a8 85       	ldd	r26, Y+8	; 0x08
    3c0c:	b9 85       	ldd	r27, Y+9	; 0x09
    3c0e:	14 96       	adiw	r26, 0x04	; 4
    3c10:	8c 91       	ld	r24, X
    3c12:	14 97       	sbiw	r26, 0x04	; 4
    3c14:	80 64       	ori	r24, 0x40	; 64
    3c16:	14 96       	adiw	r26, 0x04	; 4
    3c18:	8c 93       	st	X, r24
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    3c1a:	eb 81       	ldd	r30, Y+3	; 0x03
    3c1c:	fc 81       	ldd	r31, Y+4	; 0x04
    3c1e:	ec 0d       	add	r30, r12
    3c20:	fd 1d       	adc	r31, r13
    3c22:	fc 83       	std	Y+4, r31	; 0x04
    3c24:	eb 83       	std	Y+3, r30	; 0x03
    3c26:	e8 85       	ldd	r30, Y+8	; 0x08
    3c28:	f9 85       	ldd	r31, Y+9	; 0x09
    3c2a:	86 81       	ldd	r24, Z+6	; 0x06
    3c2c:	97 81       	ldd	r25, Z+7	; 0x07
    3c2e:	a0 85       	ldd	r26, Z+8	; 0x08
    3c30:	b1 85       	ldd	r27, Z+9	; 0x09
    3c32:	8c 0d       	add	r24, r12
    3c34:	9d 1d       	adc	r25, r13
    3c36:	ae 1d       	adc	r26, r14
    3c38:	bf 1d       	adc	r27, r15
    3c3a:	86 83       	std	Z+6, r24	; 0x06
    3c3c:	97 83       	std	Z+7, r25	; 0x07
    3c3e:	a0 87       	std	Z+8, r26	; 0x08
    3c40:	b1 87       	std	Z+9, r27	; 0x09
    3c42:	e9 81       	ldd	r30, Y+1	; 0x01
    3c44:	fa 81       	ldd	r31, Y+2	; 0x02
    3c46:	80 81       	ld	r24, Z
    3c48:	91 81       	ldd	r25, Z+1	; 0x01
    3c4a:	a2 81       	ldd	r26, Z+2	; 0x02
    3c4c:	b3 81       	ldd	r27, Z+3	; 0x03
    3c4e:	8c 0d       	add	r24, r12
    3c50:	9d 1d       	adc	r25, r13
    3c52:	ae 1d       	adc	r26, r14
    3c54:	bf 1d       	adc	r27, r15
    3c56:	80 83       	st	Z, r24
    3c58:	91 83       	std	Z+1, r25	; 0x01
    3c5a:	a2 83       	std	Z+2, r26	; 0x02
    3c5c:	b3 83       	std	Z+3, r27	; 0x03
    3c5e:	8c 18       	sub	r8, r12
    3c60:	9d 08       	sbc	r9, r13
    3c62:	ae 08       	sbc	r10, r14
    3c64:	bf 08       	sbc	r11, r15
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
    3c66:	09 f0       	breq	.+2      	; 0x3c6a <f_write+0x43e>
    3c68:	35 ce       	rjmp	.-918    	; 0x38d4 <f_write+0xa8>
    3c6a:	1f 81       	ldd	r17, Y+7	; 0x07
    3c6c:	48 84       	ldd	r4, Y+8	; 0x08
    3c6e:	59 84       	ldd	r5, Y+9	; 0x09
    3c70:	03 c0       	rjmp	.+6      	; 0x3c78 <f_write+0x44c>
    3c72:	1f 81       	ldd	r17, Y+7	; 0x07
    3c74:	48 84       	ldd	r4, Y+8	; 0x08
    3c76:	59 84       	ldd	r5, Y+9	; 0x09
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    3c78:	f2 01       	movw	r30, r4
    3c7a:	86 81       	ldd	r24, Z+6	; 0x06
    3c7c:	97 81       	ldd	r25, Z+7	; 0x07
    3c7e:	a0 85       	ldd	r26, Z+8	; 0x08
    3c80:	b1 85       	ldd	r27, Z+9	; 0x09
    3c82:	42 85       	ldd	r20, Z+10	; 0x0a
    3c84:	53 85       	ldd	r21, Z+11	; 0x0b
    3c86:	64 85       	ldd	r22, Z+12	; 0x0c
    3c88:	75 85       	ldd	r23, Z+13	; 0x0d
    3c8a:	48 17       	cp	r20, r24
    3c8c:	59 07       	cpc	r21, r25
    3c8e:	6a 07       	cpc	r22, r26
    3c90:	7b 07       	cpc	r23, r27
    3c92:	20 f4       	brcc	.+8      	; 0x3c9c <f_write+0x470>
    3c94:	82 87       	std	Z+10, r24	; 0x0a
    3c96:	93 87       	std	Z+11, r25	; 0x0b
    3c98:	a4 87       	std	Z+12, r26	; 0x0c
    3c9a:	b5 87       	std	Z+13, r27	; 0x0d
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    3c9c:	d2 01       	movw	r26, r4
    3c9e:	14 96       	adiw	r26, 0x04	; 4
    3ca0:	8c 91       	ld	r24, X
    3ca2:	14 97       	sbiw	r26, 0x04	; 4
    3ca4:	80 62       	ori	r24, 0x20	; 32
    3ca6:	14 96       	adiw	r26, 0x04	; 4
    3ca8:	8c 93       	st	X, r24
    3caa:	14 97       	sbiw	r26, 0x04	; 4

	LEAVE_FF(fp->fs, FR_OK);
    3cac:	03 c0       	rjmp	.+6      	; 0x3cb4 <f_write+0x488>
	*bw = 0;	/* Clear write byte counter */

	res = validate(fp);						/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)				/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    3cae:	12 e0       	ldi	r17, 0x02	; 2
    3cb0:	01 c0       	rjmp	.+2      	; 0x3cb4 <f_write+0x488>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    3cb2:	17 e0       	ldi	r17, 0x07	; 7

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
    3cb4:	81 2f       	mov	r24, r17
    3cb6:	29 96       	adiw	r28, 0x09	; 9
    3cb8:	0f b6       	in	r0, 0x3f	; 63
    3cba:	f8 94       	cli
    3cbc:	de bf       	out	0x3e, r29	; 62
    3cbe:	0f be       	out	0x3f, r0	; 63
    3cc0:	cd bf       	out	0x3d, r28	; 61
    3cc2:	df 91       	pop	r29
    3cc4:	cf 91       	pop	r28
    3cc6:	1f 91       	pop	r17
    3cc8:	0f 91       	pop	r16
    3cca:	ff 90       	pop	r15
    3ccc:	ef 90       	pop	r14
    3cce:	df 90       	pop	r13
    3cd0:	cf 90       	pop	r12
    3cd2:	bf 90       	pop	r11
    3cd4:	af 90       	pop	r10
    3cd6:	9f 90       	pop	r9
    3cd8:	8f 90       	pop	r8
    3cda:	7f 90       	pop	r7
    3cdc:	6f 90       	pop	r6
    3cde:	5f 90       	pop	r5
    3ce0:	4f 90       	pop	r4
    3ce2:	3f 90       	pop	r3
    3ce4:	2f 90       	pop	r2
    3ce6:	08 95       	ret

00003ce8 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
    3ce8:	0f 93       	push	r16
    3cea:	1f 93       	push	r17
    3cec:	cf 93       	push	r28
    3cee:	df 93       	push	r29
    3cf0:	ec 01       	movw	r28, r24
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
    3cf2:	0e 94 84 09 	call	0x1308	; 0x1308 <validate>
	if (res == FR_OK) {
    3cf6:	88 23       	and	r24, r24
    3cf8:	09 f0       	breq	.+2      	; 0x3cfc <f_sync+0x14>
    3cfa:	4c c0       	rjmp	.+152    	; 0x3d94 <f_sync+0xac>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    3cfc:	9c 81       	ldd	r25, Y+4	; 0x04
    3cfe:	95 ff       	sbrs	r25, 5
    3d00:	49 c0       	rjmp	.+146    	; 0x3d94 <f_sync+0xac>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
    3d02:	96 ff       	sbrs	r25, 6
    3d04:	12 c0       	rjmp	.+36     	; 0x3d2a <f_sync+0x42>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3d06:	e8 81       	ld	r30, Y
    3d08:	f9 81       	ldd	r31, Y+1	; 0x01
    3d0a:	be 01       	movw	r22, r28
    3d0c:	60 5e       	subi	r22, 0xE0	; 224
    3d0e:	7f 4f       	sbci	r23, 0xFF	; 255
    3d10:	2e 89       	ldd	r18, Y+22	; 0x16
    3d12:	3f 89       	ldd	r19, Y+23	; 0x17
    3d14:	48 8d       	ldd	r20, Y+24	; 0x18
    3d16:	59 8d       	ldd	r21, Y+25	; 0x19
    3d18:	81 81       	ldd	r24, Z+1	; 0x01
    3d1a:	01 e0       	ldi	r16, 0x01	; 1
    3d1c:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    3d20:	88 23       	and	r24, r24
    3d22:	b9 f5       	brne	.+110    	; 0x3d92 <f_sync+0xaa>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
    3d24:	8c 81       	ldd	r24, Y+4	; 0x04
    3d26:	8f 7b       	andi	r24, 0xBF	; 191
    3d28:	8c 83       	std	Y+4, r24	; 0x04
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
    3d2a:	4a 8d       	ldd	r20, Y+26	; 0x1a
    3d2c:	5b 8d       	ldd	r21, Y+27	; 0x1b
    3d2e:	6c 8d       	ldd	r22, Y+28	; 0x1c
    3d30:	7d 8d       	ldd	r23, Y+29	; 0x1d
    3d32:	88 81       	ld	r24, Y
    3d34:	99 81       	ldd	r25, Y+1	; 0x01
    3d36:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
			if (res == FR_OK) {
    3d3a:	88 23       	and	r24, r24
    3d3c:	59 f5       	brne	.+86     	; 0x3d94 <f_sync+0xac>
				dir = fp->dir_ptr;
    3d3e:	0e 8d       	ldd	r16, Y+30	; 0x1e
    3d40:	1f 8d       	ldd	r17, Y+31	; 0x1f
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    3d42:	f8 01       	movw	r30, r16
    3d44:	83 85       	ldd	r24, Z+11	; 0x0b
    3d46:	80 62       	ori	r24, 0x20	; 32
    3d48:	83 87       	std	Z+11, r24	; 0x0b
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    3d4a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3d4c:	84 8f       	std	Z+28, r24	; 0x1c
    3d4e:	8b 85       	ldd	r24, Y+11	; 0x0b
    3d50:	85 8f       	std	Z+29, r24	; 0x1d
    3d52:	8c 85       	ldd	r24, Y+12	; 0x0c
    3d54:	86 8f       	std	Z+30, r24	; 0x1e
    3d56:	8d 85       	ldd	r24, Y+13	; 0x0d
    3d58:	87 8f       	std	Z+31, r24	; 0x1f
				st_clust(dir, fp->sclust);					/* Update start cluster */
    3d5a:	4e 85       	ldd	r20, Y+14	; 0x0e
    3d5c:	5f 85       	ldd	r21, Y+15	; 0x0f
    3d5e:	68 89       	ldd	r22, Y+16	; 0x10
    3d60:	79 89       	ldd	r23, Y+17	; 0x11
    3d62:	c8 01       	movw	r24, r16
    3d64:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <st_clust>
				tim = get_fattime();						/* Update updated time */
    3d68:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <get_fattime>
				ST_DWORD(dir+DIR_WrtTime, tim);
    3d6c:	f8 01       	movw	r30, r16
    3d6e:	66 8b       	std	Z+22, r22	; 0x16
    3d70:	77 8b       	std	Z+23, r23	; 0x17
    3d72:	80 8f       	std	Z+24, r24	; 0x18
    3d74:	91 8f       	std	Z+25, r25	; 0x19
				ST_WORD(dir+DIR_LstAccDate, 0);
    3d76:	12 8a       	std	Z+18, r1	; 0x12
    3d78:	13 8a       	std	Z+19, r1	; 0x13
				fp->flag &= ~FA__WRITTEN;
    3d7a:	8c 81       	ldd	r24, Y+4	; 0x04
    3d7c:	8f 7d       	andi	r24, 0xDF	; 223
    3d7e:	8c 83       	std	Y+4, r24	; 0x04
				fp->fs->wflag = 1;
    3d80:	e8 81       	ld	r30, Y
    3d82:	f9 81       	ldd	r31, Y+1	; 0x01
    3d84:	81 e0       	ldi	r24, 0x01	; 1
    3d86:	84 83       	std	Z+4, r24	; 0x04
				res = sync(fp->fs);
    3d88:	88 81       	ld	r24, Y
    3d8a:	99 81       	ldd	r25, Y+1	; 0x01
    3d8c:	0e 94 16 0f 	call	0x1e2c	; 0x1e2c <sync>
    3d90:	01 c0       	rjmp	.+2      	; 0x3d94 <f_sync+0xac>
	if (res == FR_OK) {
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
    3d92:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
    3d94:	df 91       	pop	r29
    3d96:	cf 91       	pop	r28
    3d98:	1f 91       	pop	r17
    3d9a:	0f 91       	pop	r16
    3d9c:	08 95       	ret

00003d9e <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    3d9e:	cf 93       	push	r28
    3da0:	df 93       	push	r29
    3da2:	ec 01       	movw	r28, r24
#endif
		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
		LEAVE_FF(fs, res);
	}
#else
	res = f_sync(fp);		/* Flush cached data */
    3da4:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <f_sync>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    3da8:	88 23       	and	r24, r24
    3daa:	11 f4       	brne	.+4      	; 0x3db0 <f_close+0x12>
    3dac:	19 82       	std	Y+1, r1	; 0x01
    3dae:	18 82       	st	Y, r1
	return res;
#endif
}
    3db0:	df 91       	pop	r29
    3db2:	cf 91       	pop	r28
    3db4:	08 95       	ret

00003db6 <f_chdrive>:

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
    3db6:	88 23       	and	r24, r24
    3db8:	19 f4       	brne	.+6      	; 0x3dc0 <f_chdrive+0xa>

	CurrVol = drv;
    3dba:	10 92 fb 02 	sts	0x02FB, r1

	return FR_OK;
    3dbe:	08 95       	ret

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
    3dc0:	8b e0       	ldi	r24, 0x0B	; 11

	CurrVol = drv;

	return FR_OK;
}
    3dc2:	08 95       	ret

00003dc4 <f_chdir>:


FRESULT f_chdir (
	const TCHAR *path	/* Pointer to the directory path */
)
{
    3dc4:	ef 92       	push	r14
    3dc6:	ff 92       	push	r15
    3dc8:	1f 93       	push	r17
    3dca:	cf 93       	push	r28
    3dcc:	df 93       	push	r29
    3dce:	cd b7       	in	r28, 0x3d	; 61
    3dd0:	de b7       	in	r29, 0x3e	; 62
    3dd2:	a4 97       	sbiw	r28, 0x24	; 36
    3dd4:	0f b6       	in	r0, 0x3f	; 63
    3dd6:	f8 94       	cli
    3dd8:	de bf       	out	0x3e, r29	; 62
    3dda:	0f be       	out	0x3f, r0	; 63
    3ddc:	cd bf       	out	0x3d, r28	; 61
    3dde:	9c a3       	lds	r25, 0x5c
    3de0:	8b a3       	lds	r24, 0x5b
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
    3de2:	ce 01       	movw	r24, r28
    3de4:	83 96       	adiw	r24, 0x23	; 35
    3de6:	be 01       	movw	r22, r28
    3de8:	6f 5f       	subi	r22, 0xFF	; 255
    3dea:	7f 4f       	sbci	r23, 0xFF	; 255
    3dec:	40 e0       	ldi	r20, 0x00	; 0
    3dee:	0e 94 41 0a 	call	0x1482	; 0x1482 <chk_mounted>
    3df2:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    3df4:	88 23       	and	r24, r24
    3df6:	81 f5       	brne	.+96     	; 0x3e58 <f_chdir+0x94>
		INIT_BUF(dj);
    3df8:	ce 01       	movw	r24, r28
    3dfa:	47 96       	adiw	r24, 0x17	; 23
    3dfc:	9e 8b       	std	Y+22, r25	; 0x16
    3dfe:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the path */
    3e00:	6b a1       	lds	r22, 0x4b
    3e02:	7c a1       	lds	r23, 0x4c
    3e04:	ce 01       	movw	r24, r28
    3e06:	01 96       	adiw	r24, 0x01	; 1
    3e08:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <follow_path>
    3e0c:	18 2f       	mov	r17, r24
		FREE_BUF();
		if (res == FR_OK) {					/* Follow completed */
    3e0e:	88 23       	and	r24, r24
    3e10:	01 f5       	brne	.+64     	; 0x3e52 <f_chdir+0x8e>
			if (!dj.dir) {
    3e12:	eb 89       	ldd	r30, Y+19	; 0x13
    3e14:	fc 89       	ldd	r31, Y+20	; 0x14
    3e16:	30 97       	sbiw	r30, 0x00	; 0
    3e18:	59 f4       	brne	.+22     	; 0x3e30 <f_chdir+0x6c>
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
    3e1a:	e9 81       	ldd	r30, Y+1	; 0x01
    3e1c:	fa 81       	ldd	r31, Y+2	; 0x02
    3e1e:	8f 81       	ldd	r24, Y+7	; 0x07
    3e20:	98 85       	ldd	r25, Y+8	; 0x08
    3e22:	a9 85       	ldd	r26, Y+9	; 0x09
    3e24:	ba 85       	ldd	r27, Y+10	; 0x0a
    3e26:	86 8b       	std	Z+22, r24	; 0x16
    3e28:	97 8b       	std	Z+23, r25	; 0x17
    3e2a:	a0 8f       	std	Z+24, r26	; 0x18
    3e2c:	b1 8f       	std	Z+25, r27	; 0x19
    3e2e:	14 c0       	rjmp	.+40     	; 0x3e58 <f_chdir+0x94>
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
    3e30:	83 85       	ldd	r24, Z+11	; 0x0b
    3e32:	84 ff       	sbrs	r24, 4
    3e34:	1e c0       	rjmp	.+60     	; 0x3e72 <f_chdir+0xae>
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
    3e36:	e9 80       	ldd	r14, Y+1	; 0x01
    3e38:	fa 80       	ldd	r15, Y+2	; 0x02
    3e3a:	c7 01       	movw	r24, r14
    3e3c:	bf 01       	movw	r22, r30
    3e3e:	0e 94 c4 08 	call	0x1188	; 0x1188 <ld_clust>
    3e42:	dc 01       	movw	r26, r24
    3e44:	cb 01       	movw	r24, r22
    3e46:	f7 01       	movw	r30, r14
    3e48:	86 8b       	std	Z+22, r24	; 0x16
    3e4a:	97 8b       	std	Z+23, r25	; 0x17
    3e4c:	a0 8f       	std	Z+24, r26	; 0x18
    3e4e:	b1 8f       	std	Z+25, r27	; 0x19
    3e50:	03 c0       	rjmp	.+6      	; 0x3e58 <f_chdir+0x94>
				else
					res = FR_NO_PATH;		/* Reached but a file */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    3e52:	84 30       	cpi	r24, 0x04	; 4
    3e54:	09 f4       	brne	.+2      	; 0x3e58 <f_chdir+0x94>
    3e56:	15 e0       	ldi	r17, 0x05	; 5
	}

	LEAVE_FF(dj.fs, res);
}
    3e58:	81 2f       	mov	r24, r17
    3e5a:	a4 96       	adiw	r28, 0x24	; 36
    3e5c:	0f b6       	in	r0, 0x3f	; 63
    3e5e:	f8 94       	cli
    3e60:	de bf       	out	0x3e, r29	; 62
    3e62:	0f be       	out	0x3f, r0	; 63
    3e64:	cd bf       	out	0x3d, r28	; 61
    3e66:	df 91       	pop	r29
    3e68:	cf 91       	pop	r28
    3e6a:	1f 91       	pop	r17
    3e6c:	ff 90       	pop	r15
    3e6e:	ef 90       	pop	r14
    3e70:	08 95       	ret
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
				else
					res = FR_NO_PATH;		/* Reached but a file */
    3e72:	15 e0       	ldi	r17, 0x05	; 5
    3e74:	f1 cf       	rjmp	.-30     	; 0x3e58 <f_chdir+0x94>

00003e76 <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
    3e76:	2f 92       	push	r2
    3e78:	3f 92       	push	r3
    3e7a:	4f 92       	push	r4
    3e7c:	5f 92       	push	r5
    3e7e:	6f 92       	push	r6
    3e80:	7f 92       	push	r7
    3e82:	8f 92       	push	r8
    3e84:	9f 92       	push	r9
    3e86:	af 92       	push	r10
    3e88:	bf 92       	push	r11
    3e8a:	cf 92       	push	r12
    3e8c:	df 92       	push	r13
    3e8e:	ef 92       	push	r14
    3e90:	ff 92       	push	r15
    3e92:	0f 93       	push	r16
    3e94:	1f 93       	push	r17
    3e96:	cf 93       	push	r28
    3e98:	df 93       	push	r29
    3e9a:	00 d0       	rcall	.+0      	; 0x3e9c <f_lseek+0x26>
    3e9c:	00 d0       	rcall	.+0      	; 0x3e9e <f_lseek+0x28>
    3e9e:	00 d0       	rcall	.+0      	; 0x3ea0 <f_lseek+0x2a>
    3ea0:	cd b7       	in	r28, 0x3d	; 61
    3ea2:	de b7       	in	r29, 0x3e	; 62
    3ea4:	9e 83       	std	Y+6, r25	; 0x06
    3ea6:	8d 83       	std	Y+5, r24	; 0x05
    3ea8:	6a 01       	movw	r12, r20
    3eaa:	7b 01       	movw	r14, r22
	FRESULT res;


	res = validate(fp);					/* Check validity of the object */
    3eac:	0e 94 84 09 	call	0x1308	; 0x1308 <validate>
    3eb0:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3eb2:	88 23       	and	r24, r24
    3eb4:	09 f0       	breq	.+2      	; 0x3eb8 <f_lseek+0x42>
    3eb6:	e6 c1       	rjmp	.+972    	; 0x4284 <f_lseek+0x40e>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
    3eb8:	ad 81       	ldd	r26, Y+5	; 0x05
    3eba:	be 81       	ldd	r27, Y+6	; 0x06
    3ebc:	14 96       	adiw	r26, 0x04	; 4
    3ebe:	2c 91       	ld	r18, X
    3ec0:	14 97       	sbiw	r26, 0x04	; 4
    3ec2:	22 23       	and	r18, r18
    3ec4:	0c f4       	brge	.+2      	; 0x3ec8 <f_lseek+0x52>
    3ec6:	dd c1       	rjmp	.+954    	; 0x4282 <f_lseek+0x40c>

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    3ec8:	1a 96       	adiw	r26, 0x0a	; 10
    3eca:	8d 91       	ld	r24, X+
    3ecc:	9d 91       	ld	r25, X+
    3ece:	0d 90       	ld	r0, X+
    3ed0:	bc 91       	ld	r27, X
    3ed2:	a0 2d       	mov	r26, r0
    3ed4:	8c 15       	cp	r24, r12
    3ed6:	9d 05       	cpc	r25, r13
    3ed8:	ae 05       	cpc	r26, r14
    3eda:	bf 05       	cpc	r27, r15
    3edc:	20 f4       	brcc	.+8      	; 0x3ee6 <f_lseek+0x70>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
    3ede:	21 fd       	sbrc	r18, 1
    3ee0:	02 c0       	rjmp	.+4      	; 0x3ee6 <f_lseek+0x70>
#endif
			) ofs = fp->fsize;
    3ee2:	6c 01       	movw	r12, r24
    3ee4:	7d 01       	movw	r14, r26

		ifptr = fp->fptr;
    3ee6:	ed 81       	ldd	r30, Y+5	; 0x05
    3ee8:	fe 81       	ldd	r31, Y+6	; 0x06
    3eea:	46 81       	ldd	r20, Z+6	; 0x06
    3eec:	57 81       	ldd	r21, Z+7	; 0x07
    3eee:	60 85       	ldd	r22, Z+8	; 0x08
    3ef0:	71 85       	ldd	r23, Z+9	; 0x09
		fp->fptr = nsect = 0;
    3ef2:	16 82       	std	Z+6, r1	; 0x06
    3ef4:	17 82       	std	Z+7, r1	; 0x07
    3ef6:	10 86       	std	Z+8, r1	; 0x08
    3ef8:	11 86       	std	Z+9, r1	; 0x09
		if (ofs) {
    3efa:	c1 14       	cp	r12, r1
    3efc:	d1 04       	cpc	r13, r1
    3efe:	e1 04       	cpc	r14, r1
    3f00:	f1 04       	cpc	r15, r1
    3f02:	09 f4       	brne	.+2      	; 0x3f06 <f_lseek+0x90>
    3f04:	bf c1       	rjmp	.+894    	; 0x4284 <f_lseek+0x40e>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    3f06:	20 80       	ld	r2, Z
    3f08:	31 80       	ldd	r3, Z+1	; 0x01
    3f0a:	f1 01       	movw	r30, r2
    3f0c:	82 81       	ldd	r24, Z+2	; 0x02
    3f0e:	90 e0       	ldi	r25, 0x00	; 0
    3f10:	a0 e0       	ldi	r26, 0x00	; 0
    3f12:	b0 e0       	ldi	r27, 0x00	; 0
    3f14:	4c 01       	movw	r8, r24
    3f16:	5d 01       	movw	r10, r26
    3f18:	07 2e       	mov	r0, r23
    3f1a:	79 e0       	ldi	r23, 0x09	; 9
    3f1c:	88 0c       	add	r8, r8
    3f1e:	99 1c       	adc	r9, r9
    3f20:	aa 1c       	adc	r10, r10
    3f22:	bb 1c       	adc	r11, r11
    3f24:	7a 95       	dec	r23
    3f26:	d1 f7       	brne	.-12     	; 0x3f1c <f_lseek+0xa6>
    3f28:	70 2d       	mov	r23, r0
			if (ifptr > 0 &&
    3f2a:	41 15       	cp	r20, r1
    3f2c:	51 05       	cpc	r21, r1
    3f2e:	61 05       	cpc	r22, r1
    3f30:	71 05       	cpc	r23, r1
    3f32:	f1 f1       	breq	.+124    	; 0x3fb0 <f_lseek+0x13a>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
    3f34:	2a 01       	movw	r4, r20
    3f36:	3b 01       	movw	r6, r22
    3f38:	08 94       	sec
    3f3a:	41 08       	sbc	r4, r1
    3f3c:	51 08       	sbc	r5, r1
    3f3e:	61 08       	sbc	r6, r1
    3f40:	71 08       	sbc	r7, r1
    3f42:	c7 01       	movw	r24, r14
    3f44:	b6 01       	movw	r22, r12
    3f46:	61 50       	subi	r22, 0x01	; 1
    3f48:	70 40       	sbci	r23, 0x00	; 0
    3f4a:	80 40       	sbci	r24, 0x00	; 0
    3f4c:	90 40       	sbci	r25, 0x00	; 0
    3f4e:	a5 01       	movw	r20, r10
    3f50:	94 01       	movw	r18, r8
    3f52:	0e 94 0c 2a 	call	0x5418	; 0x5418 <__udivmodsi4>
    3f56:	29 83       	std	Y+1, r18	; 0x01
    3f58:	3a 83       	std	Y+2, r19	; 0x02
    3f5a:	4b 83       	std	Y+3, r20	; 0x03
    3f5c:	5c 83       	std	Y+4, r21	; 0x04
    3f5e:	c3 01       	movw	r24, r6
    3f60:	b2 01       	movw	r22, r4
    3f62:	a5 01       	movw	r20, r10
    3f64:	94 01       	movw	r18, r8
    3f66:	0e 94 0c 2a 	call	0x5418	; 0x5418 <__udivmodsi4>

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
    3f6a:	89 81       	ldd	r24, Y+1	; 0x01
    3f6c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f6e:	ab 81       	ldd	r26, Y+3	; 0x03
    3f70:	bc 81       	ldd	r27, Y+4	; 0x04
    3f72:	82 17       	cp	r24, r18
    3f74:	93 07       	cpc	r25, r19
    3f76:	a4 07       	cpc	r26, r20
    3f78:	b5 07       	cpc	r27, r21
    3f7a:	d0 f0       	brcs	.+52     	; 0x3fb0 <f_lseek+0x13a>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    3f7c:	88 27       	eor	r24, r24
    3f7e:	99 27       	eor	r25, r25
    3f80:	dc 01       	movw	r26, r24
    3f82:	88 19       	sub	r24, r8
    3f84:	99 09       	sbc	r25, r9
    3f86:	aa 09       	sbc	r26, r10
    3f88:	bb 09       	sbc	r27, r11
    3f8a:	84 21       	and	r24, r4
    3f8c:	95 21       	and	r25, r5
    3f8e:	a6 21       	and	r26, r6
    3f90:	b7 21       	and	r27, r7
    3f92:	ed 81       	ldd	r30, Y+5	; 0x05
    3f94:	fe 81       	ldd	r31, Y+6	; 0x06
    3f96:	86 83       	std	Z+6, r24	; 0x06
    3f98:	97 83       	std	Z+7, r25	; 0x07
    3f9a:	a0 87       	std	Z+8, r26	; 0x08
    3f9c:	b1 87       	std	Z+9, r27	; 0x09
				ofs -= fp->fptr;
    3f9e:	c8 1a       	sub	r12, r24
    3fa0:	d9 0a       	sbc	r13, r25
    3fa2:	ea 0a       	sbc	r14, r26
    3fa4:	fb 0a       	sbc	r15, r27
				clst = fp->clust;
    3fa6:	42 89       	ldd	r20, Z+18	; 0x12
    3fa8:	53 89       	ldd	r21, Z+19	; 0x13
    3faa:	64 89       	ldd	r22, Z+20	; 0x14
    3fac:	75 89       	ldd	r23, Z+21	; 0x15
    3fae:	42 c0       	rjmp	.+132    	; 0x4034 <f_lseek+0x1be>
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
    3fb0:	ad 81       	ldd	r26, Y+5	; 0x05
    3fb2:	be 81       	ldd	r27, Y+6	; 0x06
    3fb4:	1e 96       	adiw	r26, 0x0e	; 14
    3fb6:	4d 91       	ld	r20, X+
    3fb8:	5d 91       	ld	r21, X+
    3fba:	6d 91       	ld	r22, X+
    3fbc:	7c 91       	ld	r23, X
    3fbe:	51 97       	sbiw	r26, 0x11	; 17
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
    3fc0:	41 15       	cp	r20, r1
    3fc2:	51 05       	cpc	r21, r1
    3fc4:	61 05       	cpc	r22, r1
    3fc6:	71 05       	cpc	r23, r1
    3fc8:	69 f5       	brne	.+90     	; 0x4024 <f_lseek+0x1ae>
					clst = create_chain(fp->fs, 0);
    3fca:	c1 01       	movw	r24, r2
    3fcc:	40 e0       	ldi	r20, 0x00	; 0
    3fce:	50 e0       	ldi	r21, 0x00	; 0
    3fd0:	ba 01       	movw	r22, r20
    3fd2:	0e 94 07 13 	call	0x260e	; 0x260e <create_chain>
    3fd6:	ab 01       	movw	r20, r22
    3fd8:	bc 01       	movw	r22, r24
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    3fda:	41 30       	cpi	r20, 0x01	; 1
    3fdc:	51 05       	cpc	r21, r1
    3fde:	61 05       	cpc	r22, r1
    3fe0:	71 05       	cpc	r23, r1
    3fe2:	39 f4       	brne	.+14     	; 0x3ff2 <f_lseek+0x17c>
    3fe4:	ed 81       	ldd	r30, Y+5	; 0x05
    3fe6:	fe 81       	ldd	r31, Y+6	; 0x06
    3fe8:	84 81       	ldd	r24, Z+4	; 0x04
    3fea:	80 68       	ori	r24, 0x80	; 128
    3fec:	84 83       	std	Z+4, r24	; 0x04
    3fee:	12 e0       	ldi	r17, 0x02	; 2
    3ff0:	49 c1       	rjmp	.+658    	; 0x4284 <f_lseek+0x40e>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3ff2:	4f 3f       	cpi	r20, 0xFF	; 255
    3ff4:	ff ef       	ldi	r31, 0xFF	; 255
    3ff6:	5f 07       	cpc	r21, r31
    3ff8:	ff ef       	ldi	r31, 0xFF	; 255
    3ffa:	6f 07       	cpc	r22, r31
    3ffc:	ff ef       	ldi	r31, 0xFF	; 255
    3ffe:	7f 07       	cpc	r23, r31
    4000:	59 f4       	brne	.+22     	; 0x4018 <f_lseek+0x1a2>
    4002:	ad 81       	ldd	r26, Y+5	; 0x05
    4004:	be 81       	ldd	r27, Y+6	; 0x06
    4006:	14 96       	adiw	r26, 0x04	; 4
    4008:	8c 91       	ld	r24, X
    400a:	14 97       	sbiw	r26, 0x04	; 4
    400c:	80 68       	ori	r24, 0x80	; 128
    400e:	14 96       	adiw	r26, 0x04	; 4
    4010:	8c 93       	st	X, r24
    4012:	14 97       	sbiw	r26, 0x04	; 4
    4014:	11 e0       	ldi	r17, 0x01	; 1
    4016:	36 c1       	rjmp	.+620    	; 0x4284 <f_lseek+0x40e>
					fp->sclust = clst;
    4018:	ed 81       	ldd	r30, Y+5	; 0x05
    401a:	fe 81       	ldd	r31, Y+6	; 0x06
    401c:	46 87       	std	Z+14, r20	; 0x0e
    401e:	57 87       	std	Z+15, r21	; 0x0f
    4020:	60 8b       	std	Z+16, r22	; 0x10
    4022:	71 8b       	std	Z+17, r23	; 0x11
				}
#endif
				fp->clust = clst;
    4024:	ad 81       	ldd	r26, Y+5	; 0x05
    4026:	be 81       	ldd	r27, Y+6	; 0x06
    4028:	52 96       	adiw	r26, 0x12	; 18
    402a:	4d 93       	st	X+, r20
    402c:	5d 93       	st	X+, r21
    402e:	6d 93       	st	X+, r22
    4030:	7c 93       	st	X, r23
    4032:	55 97       	sbiw	r26, 0x15	; 21
			}
			if (clst != 0) {
    4034:	41 15       	cp	r20, r1
    4036:	51 05       	cpc	r21, r1
    4038:	61 05       	cpc	r22, r1
    403a:	71 05       	cpc	r23, r1
    403c:	09 f4       	brne	.+2      	; 0x4040 <f_lseek+0x1ca>
    403e:	aa c0       	rjmp	.+340    	; 0x4194 <f_lseek+0x31e>
				while (ofs > bcs) {						/* Cluster following loop */
    4040:	8c 14       	cp	r8, r12
    4042:	9d 04       	cpc	r9, r13
    4044:	ae 04       	cpc	r10, r14
    4046:	bf 04       	cpc	r11, r15
    4048:	08 f0       	brcs	.+2      	; 0x404c <f_lseek+0x1d6>
    404a:	68 c0       	rjmp	.+208    	; 0x411c <f_lseek+0x2a6>
    404c:	4d 80       	ldd	r4, Y+5	; 0x05
    404e:	5e 80       	ldd	r5, Y+6	; 0x06
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    4050:	f2 01       	movw	r30, r4
    4052:	84 81       	ldd	r24, Z+4	; 0x04
    4054:	81 ff       	sbrs	r24, 1
    4056:	0c c0       	rjmp	.+24     	; 0x4070 <f_lseek+0x1fa>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
    4058:	80 81       	ld	r24, Z
    405a:	91 81       	ldd	r25, Z+1	; 0x01
    405c:	0e 94 07 13 	call	0x260e	; 0x260e <create_chain>
    4060:	ab 01       	movw	r20, r22
    4062:	bc 01       	movw	r22, r24
						if (clst == 0) {				/* When disk gets full, clip file size */
    4064:	41 15       	cp	r20, r1
    4066:	51 05       	cpc	r21, r1
    4068:	61 05       	cpc	r22, r1
    406a:	71 05       	cpc	r23, r1
    406c:	39 f4       	brne	.+14     	; 0x407c <f_lseek+0x206>
    406e:	52 c0       	rjmp	.+164    	; 0x4114 <f_lseek+0x29e>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    4070:	80 81       	ld	r24, Z
    4072:	91 81       	ldd	r25, Z+1	; 0x01
    4074:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <get_fat>
    4078:	ab 01       	movw	r20, r22
    407a:	bc 01       	movw	r22, r24
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    407c:	4f 3f       	cpi	r20, 0xFF	; 255
    407e:	bf ef       	ldi	r27, 0xFF	; 255
    4080:	5b 07       	cpc	r21, r27
    4082:	bf ef       	ldi	r27, 0xFF	; 255
    4084:	6b 07       	cpc	r22, r27
    4086:	bf ef       	ldi	r27, 0xFF	; 255
    4088:	7b 07       	cpc	r23, r27
    408a:	41 f4       	brne	.+16     	; 0x409c <f_lseek+0x226>
    408c:	5e 82       	std	Y+6, r5	; 0x06
    408e:	4d 82       	std	Y+5, r4	; 0x05
    4090:	f2 01       	movw	r30, r4
    4092:	84 81       	ldd	r24, Z+4	; 0x04
    4094:	80 68       	ori	r24, 0x80	; 128
    4096:	84 83       	std	Z+4, r24	; 0x04
    4098:	11 e0       	ldi	r17, 0x01	; 1
    409a:	f4 c0       	rjmp	.+488    	; 0x4284 <f_lseek+0x40e>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    409c:	42 30       	cpi	r20, 0x02	; 2
    409e:	51 05       	cpc	r21, r1
    40a0:	61 05       	cpc	r22, r1
    40a2:	71 05       	cpc	r23, r1
    40a4:	60 f0       	brcs	.+24     	; 0x40be <f_lseek+0x248>
    40a6:	d2 01       	movw	r26, r4
    40a8:	ed 91       	ld	r30, X+
    40aa:	fc 91       	ld	r31, X
    40ac:	82 8d       	ldd	r24, Z+26	; 0x1a
    40ae:	93 8d       	ldd	r25, Z+27	; 0x1b
    40b0:	a4 8d       	ldd	r26, Z+28	; 0x1c
    40b2:	b5 8d       	ldd	r27, Z+29	; 0x1d
    40b4:	48 17       	cp	r20, r24
    40b6:	59 07       	cpc	r21, r25
    40b8:	6a 07       	cpc	r22, r26
    40ba:	7b 07       	cpc	r23, r27
    40bc:	40 f0       	brcs	.+16     	; 0x40ce <f_lseek+0x258>
    40be:	5e 82       	std	Y+6, r5	; 0x06
    40c0:	4d 82       	std	Y+5, r4	; 0x05
    40c2:	f2 01       	movw	r30, r4
    40c4:	84 81       	ldd	r24, Z+4	; 0x04
    40c6:	80 68       	ori	r24, 0x80	; 128
    40c8:	84 83       	std	Z+4, r24	; 0x04
    40ca:	12 e0       	ldi	r17, 0x02	; 2
    40cc:	db c0       	rjmp	.+438    	; 0x4284 <f_lseek+0x40e>
					fp->clust = clst;
    40ce:	d2 01       	movw	r26, r4
    40d0:	52 96       	adiw	r26, 0x12	; 18
    40d2:	4d 93       	st	X+, r20
    40d4:	5d 93       	st	X+, r21
    40d6:	6d 93       	st	X+, r22
    40d8:	7c 93       	st	X, r23
    40da:	55 97       	sbiw	r26, 0x15	; 21
					fp->fptr += bcs;
    40dc:	16 96       	adiw	r26, 0x06	; 6
    40de:	8d 91       	ld	r24, X+
    40e0:	9d 91       	ld	r25, X+
    40e2:	0d 90       	ld	r0, X+
    40e4:	bc 91       	ld	r27, X
    40e6:	a0 2d       	mov	r26, r0
    40e8:	88 0d       	add	r24, r8
    40ea:	99 1d       	adc	r25, r9
    40ec:	aa 1d       	adc	r26, r10
    40ee:	bb 1d       	adc	r27, r11
    40f0:	f2 01       	movw	r30, r4
    40f2:	86 83       	std	Z+6, r24	; 0x06
    40f4:	97 83       	std	Z+7, r25	; 0x07
    40f6:	a0 87       	std	Z+8, r26	; 0x08
    40f8:	b1 87       	std	Z+9, r27	; 0x09
					ofs -= bcs;
    40fa:	c8 18       	sub	r12, r8
    40fc:	d9 08       	sbc	r13, r9
    40fe:	ea 08       	sbc	r14, r10
    4100:	fb 08       	sbc	r15, r11
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
    4102:	8c 14       	cp	r8, r12
    4104:	9d 04       	cpc	r9, r13
    4106:	ae 04       	cpc	r10, r14
    4108:	bf 04       	cpc	r11, r15
    410a:	08 f4       	brcc	.+2      	; 0x410e <f_lseek+0x298>
    410c:	a1 cf       	rjmp	.-190    	; 0x4050 <f_lseek+0x1da>
    410e:	5e 82       	std	Y+6, r5	; 0x06
    4110:	4d 82       	std	Y+5, r4	; 0x05
    4112:	04 c0       	rjmp	.+8      	; 0x411c <f_lseek+0x2a6>
    4114:	5e 82       	std	Y+6, r5	; 0x06
    4116:	4d 82       	std	Y+5, r4	; 0x05
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
						if (clst == 0) {				/* When disk gets full, clip file size */
							ofs = bcs; break;
    4118:	75 01       	movw	r14, r10
    411a:	64 01       	movw	r12, r8
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
    411c:	ed 81       	ldd	r30, Y+5	; 0x05
    411e:	fe 81       	ldd	r31, Y+6	; 0x06
    4120:	86 81       	ldd	r24, Z+6	; 0x06
    4122:	97 81       	ldd	r25, Z+7	; 0x07
    4124:	a0 85       	ldd	r26, Z+8	; 0x08
    4126:	b1 85       	ldd	r27, Z+9	; 0x09
    4128:	8c 0d       	add	r24, r12
    412a:	9d 1d       	adc	r25, r13
    412c:	ae 1d       	adc	r26, r14
    412e:	bf 1d       	adc	r27, r15
    4130:	86 83       	std	Z+6, r24	; 0x06
    4132:	97 83       	std	Z+7, r25	; 0x07
    4134:	a0 87       	std	Z+8, r26	; 0x08
    4136:	b1 87       	std	Z+9, r27	; 0x09
				if (ofs % SS(fp->fs)) {
    4138:	d7 01       	movw	r26, r14
    413a:	c6 01       	movw	r24, r12
    413c:	91 70       	andi	r25, 0x01	; 1
    413e:	a0 70       	andi	r26, 0x00	; 0
    4140:	b0 70       	andi	r27, 0x00	; 0
    4142:	00 97       	sbiw	r24, 0x00	; 0
    4144:	a1 05       	cpc	r26, r1
    4146:	b1 05       	cpc	r27, r1
    4148:	49 f1       	breq	.+82     	; 0x419c <f_lseek+0x326>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    414a:	80 81       	ld	r24, Z
    414c:	91 81       	ldd	r25, Z+1	; 0x01
    414e:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <clust2sect>
    4152:	dc 01       	movw	r26, r24
    4154:	cb 01       	movw	r24, r22
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    4156:	00 97       	sbiw	r24, 0x00	; 0
    4158:	a1 05       	cpc	r26, r1
    415a:	b1 05       	cpc	r27, r1
    415c:	59 f4       	brne	.+22     	; 0x4174 <f_lseek+0x2fe>
    415e:	ad 81       	ldd	r26, Y+5	; 0x05
    4160:	be 81       	ldd	r27, Y+6	; 0x06
    4162:	14 96       	adiw	r26, 0x04	; 4
    4164:	8c 91       	ld	r24, X
    4166:	14 97       	sbiw	r26, 0x04	; 4
    4168:	80 68       	ori	r24, 0x80	; 128
    416a:	14 96       	adiw	r26, 0x04	; 4
    416c:	8c 93       	st	X, r24
    416e:	14 97       	sbiw	r26, 0x04	; 4
    4170:	12 e0       	ldi	r17, 0x02	; 2
    4172:	88 c0       	rjmp	.+272    	; 0x4284 <f_lseek+0x40e>
					nsect += ofs / SS(fp->fs);
    4174:	46 01       	movw	r8, r12
    4176:	57 01       	movw	r10, r14
    4178:	07 2e       	mov	r0, r23
    417a:	79 e0       	ldi	r23, 0x09	; 9
    417c:	b6 94       	lsr	r11
    417e:	a7 94       	ror	r10
    4180:	97 94       	ror	r9
    4182:	87 94       	ror	r8
    4184:	7a 95       	dec	r23
    4186:	d1 f7       	brne	.-12     	; 0x417c <f_lseek+0x306>
    4188:	70 2d       	mov	r23, r0
    418a:	88 0e       	add	r8, r24
    418c:	99 1e       	adc	r9, r25
    418e:	aa 1e       	adc	r10, r26
    4190:	bb 1e       	adc	r11, r27
    4192:	07 c0       	rjmp	.+14     	; 0x41a2 <f_lseek+0x32c>
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
    4194:	88 24       	eor	r8, r8
    4196:	99 24       	eor	r9, r9
    4198:	54 01       	movw	r10, r8
    419a:	03 c0       	rjmp	.+6      	; 0x41a2 <f_lseek+0x32c>
    419c:	88 24       	eor	r8, r8
    419e:	99 24       	eor	r9, r9
    41a0:	54 01       	movw	r10, r8
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
					nsect += ofs / SS(fp->fs);
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    41a2:	ed 81       	ldd	r30, Y+5	; 0x05
    41a4:	fe 81       	ldd	r31, Y+6	; 0x06
    41a6:	86 81       	ldd	r24, Z+6	; 0x06
    41a8:	97 81       	ldd	r25, Z+7	; 0x07
    41aa:	a0 85       	ldd	r26, Z+8	; 0x08
    41ac:	b1 85       	ldd	r27, Z+9	; 0x09
    41ae:	91 70       	andi	r25, 0x01	; 1
    41b0:	a0 70       	andi	r26, 0x00	; 0
    41b2:	b0 70       	andi	r27, 0x00	; 0
    41b4:	00 97       	sbiw	r24, 0x00	; 0
    41b6:	a1 05       	cpc	r26, r1
    41b8:	b1 05       	cpc	r27, r1
    41ba:	09 f4       	brne	.+2      	; 0x41be <f_lseek+0x348>
    41bc:	4b c0       	rjmp	.+150    	; 0x4254 <f_lseek+0x3de>
    41be:	c6 88       	ldd	r12, Z+22	; 0x16
    41c0:	d7 88       	ldd	r13, Z+23	; 0x17
    41c2:	e0 8c       	ldd	r14, Z+24	; 0x18
    41c4:	f1 8c       	ldd	r15, Z+25	; 0x19
    41c6:	c8 14       	cp	r12, r8
    41c8:	d9 04       	cpc	r13, r9
    41ca:	ea 04       	cpc	r14, r10
    41cc:	fb 04       	cpc	r15, r11
    41ce:	09 f4       	brne	.+2      	; 0x41d2 <f_lseek+0x35c>
    41d0:	41 c0       	rjmp	.+130    	; 0x4254 <f_lseek+0x3de>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
    41d2:	84 81       	ldd	r24, Z+4	; 0x04
    41d4:	86 ff       	sbrs	r24, 6
    41d6:	1f c0       	rjmp	.+62     	; 0x4216 <f_lseek+0x3a0>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    41d8:	01 90       	ld	r0, Z+
    41da:	f0 81       	ld	r31, Z
    41dc:	e0 2d       	mov	r30, r0
    41de:	6d 81       	ldd	r22, Y+5	; 0x05
    41e0:	7e 81       	ldd	r23, Y+6	; 0x06
    41e2:	60 5e       	subi	r22, 0xE0	; 224
    41e4:	7f 4f       	sbci	r23, 0xFF	; 255
    41e6:	81 81       	ldd	r24, Z+1	; 0x01
    41e8:	a7 01       	movw	r20, r14
    41ea:	96 01       	movw	r18, r12
    41ec:	01 e0       	ldi	r16, 0x01	; 1
    41ee:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    41f2:	88 23       	and	r24, r24
    41f4:	59 f0       	breq	.+22     	; 0x420c <f_lseek+0x396>
					ABORT(fp->fs, FR_DISK_ERR);
    41f6:	ad 81       	ldd	r26, Y+5	; 0x05
    41f8:	be 81       	ldd	r27, Y+6	; 0x06
    41fa:	14 96       	adiw	r26, 0x04	; 4
    41fc:	8c 91       	ld	r24, X
    41fe:	14 97       	sbiw	r26, 0x04	; 4
    4200:	80 68       	ori	r24, 0x80	; 128
    4202:	14 96       	adiw	r26, 0x04	; 4
    4204:	8c 93       	st	X, r24
    4206:	14 97       	sbiw	r26, 0x04	; 4
    4208:	11 e0       	ldi	r17, 0x01	; 1
    420a:	3c c0       	rjmp	.+120    	; 0x4284 <f_lseek+0x40e>
				fp->flag &= ~FA__DIRTY;
    420c:	ed 81       	ldd	r30, Y+5	; 0x05
    420e:	fe 81       	ldd	r31, Y+6	; 0x06
    4210:	84 81       	ldd	r24, Z+4	; 0x04
    4212:	8f 7b       	andi	r24, 0xBF	; 191
    4214:	84 83       	std	Z+4, r24	; 0x04
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
    4216:	ad 81       	ldd	r26, Y+5	; 0x05
    4218:	be 81       	ldd	r27, Y+6	; 0x06
    421a:	ed 91       	ld	r30, X+
    421c:	fc 91       	ld	r31, X
    421e:	11 97       	sbiw	r26, 0x01	; 1
    4220:	bd 01       	movw	r22, r26
    4222:	60 5e       	subi	r22, 0xE0	; 224
    4224:	7f 4f       	sbci	r23, 0xFF	; 255
    4226:	81 81       	ldd	r24, Z+1	; 0x01
    4228:	a5 01       	movw	r20, r10
    422a:	94 01       	movw	r18, r8
    422c:	01 e0       	ldi	r16, 0x01	; 1
    422e:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    4232:	88 23       	and	r24, r24
    4234:	39 f0       	breq	.+14     	; 0x4244 <f_lseek+0x3ce>
				ABORT(fp->fs, FR_DISK_ERR);
    4236:	ed 81       	ldd	r30, Y+5	; 0x05
    4238:	fe 81       	ldd	r31, Y+6	; 0x06
    423a:	84 81       	ldd	r24, Z+4	; 0x04
    423c:	80 68       	ori	r24, 0x80	; 128
    423e:	84 83       	std	Z+4, r24	; 0x04
    4240:	11 e0       	ldi	r17, 0x01	; 1
    4242:	20 c0       	rjmp	.+64     	; 0x4284 <f_lseek+0x40e>
#endif
			fp->dsect = nsect;
    4244:	ad 81       	ldd	r26, Y+5	; 0x05
    4246:	be 81       	ldd	r27, Y+6	; 0x06
    4248:	56 96       	adiw	r26, 0x16	; 22
    424a:	8d 92       	st	X+, r8
    424c:	9d 92       	st	X+, r9
    424e:	ad 92       	st	X+, r10
    4250:	bc 92       	st	X, r11
    4252:	59 97       	sbiw	r26, 0x19	; 25
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
    4254:	ed 81       	ldd	r30, Y+5	; 0x05
    4256:	fe 81       	ldd	r31, Y+6	; 0x06
    4258:	86 81       	ldd	r24, Z+6	; 0x06
    425a:	97 81       	ldd	r25, Z+7	; 0x07
    425c:	a0 85       	ldd	r26, Z+8	; 0x08
    425e:	b1 85       	ldd	r27, Z+9	; 0x09
    4260:	42 85       	ldd	r20, Z+10	; 0x0a
    4262:	53 85       	ldd	r21, Z+11	; 0x0b
    4264:	64 85       	ldd	r22, Z+12	; 0x0c
    4266:	75 85       	ldd	r23, Z+13	; 0x0d
    4268:	48 17       	cp	r20, r24
    426a:	59 07       	cpc	r21, r25
    426c:	6a 07       	cpc	r22, r26
    426e:	7b 07       	cpc	r23, r27
    4270:	48 f4       	brcc	.+18     	; 0x4284 <f_lseek+0x40e>
			fp->fsize = fp->fptr;
    4272:	82 87       	std	Z+10, r24	; 0x0a
    4274:	93 87       	std	Z+11, r25	; 0x0b
    4276:	a4 87       	std	Z+12, r26	; 0x0c
    4278:	b5 87       	std	Z+13, r27	; 0x0d
			fp->flag |= FA__WRITTEN;
    427a:	84 81       	ldd	r24, Z+4	; 0x04
    427c:	80 62       	ori	r24, 0x20	; 32
    427e:	84 83       	std	Z+4, r24	; 0x04
    4280:	01 c0       	rjmp	.+2      	; 0x4284 <f_lseek+0x40e>


	res = validate(fp);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)			/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    4282:	12 e0       	ldi	r17, 0x02	; 2
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
    4284:	81 2f       	mov	r24, r17
    4286:	26 96       	adiw	r28, 0x06	; 6
    4288:	0f b6       	in	r0, 0x3f	; 63
    428a:	f8 94       	cli
    428c:	de bf       	out	0x3e, r29	; 62
    428e:	0f be       	out	0x3f, r0	; 63
    4290:	cd bf       	out	0x3d, r28	; 61
    4292:	df 91       	pop	r29
    4294:	cf 91       	pop	r28
    4296:	1f 91       	pop	r17
    4298:	0f 91       	pop	r16
    429a:	ff 90       	pop	r15
    429c:	ef 90       	pop	r14
    429e:	df 90       	pop	r13
    42a0:	cf 90       	pop	r12
    42a2:	bf 90       	pop	r11
    42a4:	af 90       	pop	r10
    42a6:	9f 90       	pop	r9
    42a8:	8f 90       	pop	r8
    42aa:	7f 90       	pop	r7
    42ac:	6f 90       	pop	r6
    42ae:	5f 90       	pop	r5
    42b0:	4f 90       	pop	r4
    42b2:	3f 90       	pop	r3
    42b4:	2f 90       	pop	r2
    42b6:	08 95       	ret

000042b8 <f_opendir>:

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const TCHAR *path	/* Pointer to the directory path */
)
{
    42b8:	ef 92       	push	r14
    42ba:	ff 92       	push	r15
    42bc:	0f 93       	push	r16
    42be:	1f 93       	push	r17
    42c0:	cf 93       	push	r28
    42c2:	df 93       	push	r29
    42c4:	cd b7       	in	r28, 0x3d	; 61
    42c6:	de b7       	in	r29, 0x3e	; 62
    42c8:	2e 97       	sbiw	r28, 0x0e	; 14
    42ca:	0f b6       	in	r0, 0x3f	; 63
    42cc:	f8 94       	cli
    42ce:	de bf       	out	0x3e, r29	; 62
    42d0:	0f be       	out	0x3f, r0	; 63
    42d2:	cd bf       	out	0x3d, r28	; 61
    42d4:	8c 01       	movw	r16, r24
    42d6:	7e 87       	std	Y+14, r23	; 0x0e
    42d8:	6d 87       	std	Y+13, r22	; 0x0d
	FRESULT res;
	FATFS *fs;
	DEF_NAMEBUF;


	if (!dj) return FR_INVALID_OBJECT;
    42da:	00 97       	sbiw	r24, 0x00	; 0
    42dc:	09 f4       	brne	.+2      	; 0x42e0 <f_opendir+0x28>
    42de:	4c c0       	rjmp	.+152    	; 0x4378 <f_opendir+0xc0>

	res = chk_mounted(&path, &dj->fs, 0);
    42e0:	ce 01       	movw	r24, r28
    42e2:	0d 96       	adiw	r24, 0x0d	; 13
    42e4:	b8 01       	movw	r22, r16
    42e6:	40 e0       	ldi	r20, 0x00	; 0
    42e8:	0e 94 41 0a 	call	0x1482	; 0x1482 <chk_mounted>
	fs = dj->fs;
    42ec:	d8 01       	movw	r26, r16
    42ee:	ed 90       	ld	r14, X+
    42f0:	fc 90       	ld	r15, X
    42f2:	11 97       	sbiw	r26, 0x01	; 1
	if (res == FR_OK) {
    42f4:	88 23       	and	r24, r24
    42f6:	e1 f5       	brne	.+120    	; 0x4370 <f_opendir+0xb8>
		INIT_BUF(*dj);
    42f8:	ce 01       	movw	r24, r28
    42fa:	01 96       	adiw	r24, 0x01	; 1
    42fc:	55 96       	adiw	r26, 0x15	; 21
    42fe:	9c 93       	st	X, r25
    4300:	8e 93       	st	-X, r24
    4302:	54 97       	sbiw	r26, 0x14	; 20
		res = follow_path(dj, path);			/* Follow the path to the directory */
    4304:	6d 85       	ldd	r22, Y+13	; 0x0d
    4306:	7e 85       	ldd	r23, Y+14	; 0x0e
    4308:	c8 01       	movw	r24, r16
    430a:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <follow_path>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
    430e:	88 23       	and	r24, r24
    4310:	11 f5       	brne	.+68     	; 0x4356 <f_opendir+0x9e>
			if (dj->dir) {						/* It is not the root dir */
    4312:	d8 01       	movw	r26, r16
    4314:	52 96       	adiw	r26, 0x12	; 18
    4316:	ed 91       	ld	r30, X+
    4318:	fc 91       	ld	r31, X
    431a:	53 97       	sbiw	r26, 0x13	; 19
    431c:	30 97       	sbiw	r30, 0x00	; 0
    431e:	71 f0       	breq	.+28     	; 0x433c <f_opendir+0x84>
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
    4320:	83 85       	ldd	r24, Z+11	; 0x0b
    4322:	84 ff       	sbrs	r24, 4
    4324:	1b c0       	rjmp	.+54     	; 0x435c <f_opendir+0xa4>
					dj->sclust = ld_clust(fs, dj->dir);
    4326:	c7 01       	movw	r24, r14
    4328:	bf 01       	movw	r22, r30
    432a:	0e 94 c4 08 	call	0x1188	; 0x1188 <ld_clust>
    432e:	dc 01       	movw	r26, r24
    4330:	cb 01       	movw	r24, r22
    4332:	f8 01       	movw	r30, r16
    4334:	86 83       	std	Z+6, r24	; 0x06
    4336:	97 83       	std	Z+7, r25	; 0x07
    4338:	a0 87       	std	Z+8, r26	; 0x08
    433a:	b1 87       	std	Z+9, r27	; 0x09
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dj->id = fs->id;
    433c:	d7 01       	movw	r26, r14
    433e:	16 96       	adiw	r26, 0x06	; 6
    4340:	8d 91       	ld	r24, X+
    4342:	9c 91       	ld	r25, X
    4344:	17 97       	sbiw	r26, 0x07	; 7
    4346:	f8 01       	movw	r30, r16
    4348:	93 83       	std	Z+3, r25	; 0x03
    434a:	82 83       	std	Z+2, r24	; 0x02
				res = dir_sdi(dj, 0);			/* Rewind dir */
    434c:	c8 01       	movw	r24, r16
    434e:	60 e0       	ldi	r22, 0x00	; 0
    4350:	70 e0       	ldi	r23, 0x00	; 0
    4352:	0e 94 15 11 	call	0x222a	; 0x222a <dir_sdi>
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    4356:	84 30       	cpi	r24, 0x04	; 4
    4358:	11 f4       	brne	.+4      	; 0x435e <f_opendir+0xa6>
    435a:	04 c0       	rjmp	.+8      	; 0x4364 <f_opendir+0xac>
		if (res == FR_OK) {						/* Follow completed */
			if (dj->dir) {						/* It is not the root dir */
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
					dj->sclust = ld_clust(fs, dj->dir);
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
    435c:	85 e0       	ldi	r24, 0x05	; 5
				dj->id = fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
    435e:	88 23       	and	r24, r24
    4360:	61 f0       	breq	.+24     	; 0x437a <f_opendir+0xc2>
    4362:	01 c0       	rjmp	.+2      	; 0x4366 <f_opendir+0xae>
			if (res == FR_OK) {
				dj->id = fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    4364:	85 e0       	ldi	r24, 0x05	; 5
		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
    4366:	d8 01       	movw	r26, r16
    4368:	11 96       	adiw	r26, 0x01	; 1
    436a:	1c 92       	st	X, r1
    436c:	1e 92       	st	-X, r1
    436e:	05 c0       	rjmp	.+10     	; 0x437a <f_opendir+0xc2>
	} else {
		dj->fs = 0;
    4370:	f8 01       	movw	r30, r16
    4372:	11 82       	std	Z+1, r1	; 0x01
    4374:	10 82       	st	Z, r1
    4376:	01 c0       	rjmp	.+2      	; 0x437a <f_opendir+0xc2>
	FRESULT res;
	FATFS *fs;
	DEF_NAMEBUF;


	if (!dj) return FR_INVALID_OBJECT;
    4378:	89 e0       	ldi	r24, 0x09	; 9
	} else {
		dj->fs = 0;
	}

	LEAVE_FF(fs, res);
}
    437a:	2e 96       	adiw	r28, 0x0e	; 14
    437c:	0f b6       	in	r0, 0x3f	; 63
    437e:	f8 94       	cli
    4380:	de bf       	out	0x3e, r29	; 62
    4382:	0f be       	out	0x3f, r0	; 63
    4384:	cd bf       	out	0x3d, r28	; 61
    4386:	df 91       	pop	r29
    4388:	cf 91       	pop	r28
    438a:	1f 91       	pop	r17
    438c:	0f 91       	pop	r16
    438e:	ff 90       	pop	r15
    4390:	ef 90       	pop	r14
    4392:	08 95       	ret

00004394 <f_readdir>:

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
    4394:	cf 92       	push	r12
    4396:	df 92       	push	r13
    4398:	ef 92       	push	r14
    439a:	ff 92       	push	r15
    439c:	1f 93       	push	r17
    439e:	cf 93       	push	r28
    43a0:	df 93       	push	r29
    43a2:	cd b7       	in	r28, 0x3d	; 61
    43a4:	de b7       	in	r29, 0x3e	; 62
    43a6:	2c 97       	sbiw	r28, 0x0c	; 12
    43a8:	0f b6       	in	r0, 0x3f	; 63
    43aa:	f8 94       	cli
    43ac:	de bf       	out	0x3e, r29	; 62
    43ae:	0f be       	out	0x3f, r0	; 63
    43b0:	cd bf       	out	0x3d, r28	; 61
    43b2:	7c 01       	movw	r14, r24
    43b4:	6b 01       	movw	r12, r22
	FRESULT res;
	DEF_NAMEBUF;


	res = validate(dj);						/* Check validity of the object */
    43b6:	0e 94 84 09 	call	0x1308	; 0x1308 <validate>
    43ba:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    43bc:	88 23       	and	r24, r24
    43be:	81 f5       	brne	.+96     	; 0x4420 <f_readdir+0x8c>
		if (!fno) {
    43c0:	c1 14       	cp	r12, r1
    43c2:	d1 04       	cpc	r13, r1
    43c4:	39 f4       	brne	.+14     	; 0x43d4 <f_readdir+0x40>
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
    43c6:	c7 01       	movw	r24, r14
    43c8:	60 e0       	ldi	r22, 0x00	; 0
    43ca:	70 e0       	ldi	r23, 0x00	; 0
    43cc:	0e 94 15 11 	call	0x222a	; 0x222a <dir_sdi>
    43d0:	18 2f       	mov	r17, r24
    43d2:	26 c0       	rjmp	.+76     	; 0x4420 <f_readdir+0x8c>
		} else {
			INIT_BUF(*dj);
    43d4:	ce 01       	movw	r24, r28
    43d6:	01 96       	adiw	r24, 0x01	; 1
    43d8:	f7 01       	movw	r30, r14
    43da:	95 8b       	std	Z+21, r25	; 0x15
    43dc:	84 8b       	std	Z+20, r24	; 0x14
			res = dir_read(dj);				/* Read an directory item */
    43de:	c7 01       	movw	r24, r14
    43e0:	0e 94 f8 17 	call	0x2ff0	; 0x2ff0 <dir_read>
			if (res == FR_NO_FILE) {		/* Reached end of dir */
    43e4:	84 30       	cpi	r24, 0x04	; 4
    43e6:	31 f4       	brne	.+12     	; 0x43f4 <f_readdir+0x60>
				dj->sect = 0;
    43e8:	f7 01       	movw	r30, r14
    43ea:	16 86       	std	Z+14, r1	; 0x0e
    43ec:	17 86       	std	Z+15, r1	; 0x0f
    43ee:	10 8a       	std	Z+16, r1	; 0x10
    43f0:	11 8a       	std	Z+17, r1	; 0x11
    43f2:	02 c0       	rjmp	.+4      	; 0x43f8 <f_readdir+0x64>
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
    43f4:	88 23       	and	r24, r24
    43f6:	89 f4       	brne	.+34     	; 0x441a <f_readdir+0x86>
				get_fileinfo(dj, fno);		/* Get the object information */
    43f8:	c7 01       	movw	r24, r14
    43fa:	b6 01       	movw	r22, r12
    43fc:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <get_fileinfo>
				res = dir_next(dj, 0);		/* Increment index for next */
    4400:	c7 01       	movw	r24, r14
    4402:	60 e0       	ldi	r22, 0x00	; 0
    4404:	70 e0       	ldi	r23, 0x00	; 0
    4406:	0e 94 29 14 	call	0x2852	; 0x2852 <dir_next>
				if (res == FR_NO_FILE) {
    440a:	84 30       	cpi	r24, 0x04	; 4
    440c:	41 f4       	brne	.+16     	; 0x441e <f_readdir+0x8a>
					dj->sect = 0;
    440e:	f7 01       	movw	r30, r14
    4410:	16 86       	std	Z+14, r1	; 0x0e
    4412:	17 86       	std	Z+15, r1	; 0x0f
    4414:	10 8a       	std	Z+16, r1	; 0x10
    4416:	11 8a       	std	Z+17, r1	; 0x11
    4418:	03 c0       	rjmp	.+6      	; 0x4420 <f_readdir+0x8c>
	if (res == FR_OK) {
		if (!fno) {
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
		} else {
			INIT_BUF(*dj);
			res = dir_read(dj);				/* Read an directory item */
    441a:	18 2f       	mov	r17, r24
    441c:	01 c0       	rjmp	.+2      	; 0x4420 <f_readdir+0x8c>
				dj->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj, 0);		/* Increment index for next */
    441e:	18 2f       	mov	r17, r24
			FREE_BUF();
		}
	}

	LEAVE_FF(dj->fs, res);
}
    4420:	81 2f       	mov	r24, r17
    4422:	2c 96       	adiw	r28, 0x0c	; 12
    4424:	0f b6       	in	r0, 0x3f	; 63
    4426:	f8 94       	cli
    4428:	de bf       	out	0x3e, r29	; 62
    442a:	0f be       	out	0x3f, r0	; 63
    442c:	cd bf       	out	0x3d, r28	; 61
    442e:	df 91       	pop	r29
    4430:	cf 91       	pop	r28
    4432:	1f 91       	pop	r17
    4434:	ff 90       	pop	r15
    4436:	ef 90       	pop	r14
    4438:	df 90       	pop	r13
    443a:	cf 90       	pop	r12
    443c:	08 95       	ret

0000443e <f_stat>:

FRESULT f_stat (
	const TCHAR *path,	/* Pointer to the file path */
	FILINFO *fno		/* Pointer to file information to return */
)
{
    443e:	ef 92       	push	r14
    4440:	ff 92       	push	r15
    4442:	1f 93       	push	r17
    4444:	cf 93       	push	r28
    4446:	df 93       	push	r29
    4448:	cd b7       	in	r28, 0x3d	; 61
    444a:	de b7       	in	r29, 0x3e	; 62
    444c:	a4 97       	sbiw	r28, 0x24	; 36
    444e:	0f b6       	in	r0, 0x3f	; 63
    4450:	f8 94       	cli
    4452:	de bf       	out	0x3e, r29	; 62
    4454:	0f be       	out	0x3f, r0	; 63
    4456:	cd bf       	out	0x3d, r28	; 61
    4458:	9c a3       	lds	r25, 0x5c
    445a:	8b a3       	lds	r24, 0x5b
    445c:	7b 01       	movw	r14, r22
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
    445e:	ce 01       	movw	r24, r28
    4460:	83 96       	adiw	r24, 0x23	; 35
    4462:	be 01       	movw	r22, r28
    4464:	6f 5f       	subi	r22, 0xFF	; 255
    4466:	7f 4f       	sbci	r23, 0xFF	; 255
    4468:	40 e0       	ldi	r20, 0x00	; 0
    446a:	0e 94 41 0a 	call	0x1482	; 0x1482 <chk_mounted>
    446e:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    4470:	88 23       	and	r24, r24
    4472:	c1 f4       	brne	.+48     	; 0x44a4 <f_stat+0x66>
		INIT_BUF(dj);
    4474:	ce 01       	movw	r24, r28
    4476:	47 96       	adiw	r24, 0x17	; 23
    4478:	9e 8b       	std	Y+22, r25	; 0x16
    447a:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    447c:	6b a1       	lds	r22, 0x4b
    447e:	7c a1       	lds	r23, 0x4c
    4480:	ce 01       	movw	r24, r28
    4482:	01 96       	adiw	r24, 0x01	; 1
    4484:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <follow_path>
    4488:	18 2f       	mov	r17, r24
		if (res == FR_OK) {				/* Follow completed */
    448a:	88 23       	and	r24, r24
    448c:	59 f4       	brne	.+22     	; 0x44a4 <f_stat+0x66>
			if (dj.dir)		/* Found an object */
    448e:	8b 89       	ldd	r24, Y+19	; 0x13
    4490:	9c 89       	ldd	r25, Y+20	; 0x14
    4492:	00 97       	sbiw	r24, 0x00	; 0
    4494:	31 f0       	breq	.+12     	; 0x44a2 <f_stat+0x64>
				get_fileinfo(&dj, fno);
    4496:	ce 01       	movw	r24, r28
    4498:	01 96       	adiw	r24, 0x01	; 1
    449a:	b7 01       	movw	r22, r14
    449c:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <get_fileinfo>
    44a0:	01 c0       	rjmp	.+2      	; 0x44a4 <f_stat+0x66>
			else			/* It is root dir */
				res = FR_INVALID_NAME;
    44a2:	16 e0       	ldi	r17, 0x06	; 6
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    44a4:	81 2f       	mov	r24, r17
    44a6:	a4 96       	adiw	r28, 0x24	; 36
    44a8:	0f b6       	in	r0, 0x3f	; 63
    44aa:	f8 94       	cli
    44ac:	de bf       	out	0x3e, r29	; 62
    44ae:	0f be       	out	0x3f, r0	; 63
    44b0:	cd bf       	out	0x3d, r28	; 61
    44b2:	df 91       	pop	r29
    44b4:	cf 91       	pop	r28
    44b6:	1f 91       	pop	r17
    44b8:	ff 90       	pop	r15
    44ba:	ef 90       	pop	r14
    44bc:	08 95       	ret

000044be <f_getfree>:
FRESULT f_getfree (
	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
)
{
    44be:	2f 92       	push	r2
    44c0:	3f 92       	push	r3
    44c2:	4f 92       	push	r4
    44c4:	5f 92       	push	r5
    44c6:	6f 92       	push	r6
    44c8:	7f 92       	push	r7
    44ca:	8f 92       	push	r8
    44cc:	9f 92       	push	r9
    44ce:	af 92       	push	r10
    44d0:	bf 92       	push	r11
    44d2:	cf 92       	push	r12
    44d4:	df 92       	push	r13
    44d6:	ef 92       	push	r14
    44d8:	ff 92       	push	r15
    44da:	0f 93       	push	r16
    44dc:	1f 93       	push	r17
    44de:	cf 93       	push	r28
    44e0:	df 93       	push	r29
    44e2:	cd b7       	in	r28, 0x3d	; 61
    44e4:	de b7       	in	r29, 0x3e	; 62
    44e6:	2c 97       	sbiw	r28, 0x0c	; 12
    44e8:	0f b6       	in	r0, 0x3f	; 63
    44ea:	f8 94       	cli
    44ec:	de bf       	out	0x3e, r29	; 62
    44ee:	0f be       	out	0x3f, r0	; 63
    44f0:	cd bf       	out	0x3d, r28	; 61
    44f2:	9a 83       	std	Y+2, r25	; 0x02
    44f4:	89 83       	std	Y+1, r24	; 0x01
    44f6:	78 87       	std	Y+8, r23	; 0x08
    44f8:	6f 83       	std	Y+7, r22	; 0x07
    44fa:	8a 01       	movw	r16, r20
	UINT i;
	BYTE fat, *p;


	/* Get drive number */
	res = chk_mounted(&path, fatfs, 0);
    44fc:	ce 01       	movw	r24, r28
    44fe:	01 96       	adiw	r24, 0x01	; 1
    4500:	ba 01       	movw	r22, r20
    4502:	40 e0       	ldi	r20, 0x00	; 0
    4504:	0e 94 41 0a 	call	0x1482	; 0x1482 <chk_mounted>
    4508:	b8 2e       	mov	r11, r24
	fs = *fatfs;
    450a:	d8 01       	movw	r26, r16
    450c:	8d 90       	ld	r8, X+
    450e:	9c 90       	ld	r9, X
    4510:	11 97       	sbiw	r26, 0x01	; 1
	if (res == FR_OK) {
    4512:	88 23       	and	r24, r24
    4514:	09 f0       	breq	.+2      	; 0x4518 <f_getfree+0x5a>
    4516:	03 c1       	rjmp	.+518    	; 0x471e <f_getfree+0x260>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
    4518:	f4 01       	movw	r30, r8
    451a:	86 85       	ldd	r24, Z+14	; 0x0e
    451c:	97 85       	ldd	r25, Z+15	; 0x0f
    451e:	a0 89       	ldd	r26, Z+16	; 0x10
    4520:	b1 89       	ldd	r27, Z+17	; 0x11
    4522:	c2 8c       	ldd	r12, Z+26	; 0x1a
    4524:	d3 8c       	ldd	r13, Z+27	; 0x1b
    4526:	e4 8c       	ldd	r14, Z+28	; 0x1c
    4528:	f5 8c       	ldd	r15, Z+29	; 0x1d
    452a:	b7 01       	movw	r22, r14
    452c:	a6 01       	movw	r20, r12
    452e:	42 50       	subi	r20, 0x02	; 2
    4530:	50 40       	sbci	r21, 0x00	; 0
    4532:	60 40       	sbci	r22, 0x00	; 0
    4534:	70 40       	sbci	r23, 0x00	; 0
    4536:	48 17       	cp	r20, r24
    4538:	59 07       	cpc	r21, r25
    453a:	6a 07       	cpc	r22, r26
    453c:	7b 07       	cpc	r23, r27
    453e:	38 f0       	brcs	.+14     	; 0x454e <f_getfree+0x90>
			*nclst = fs->free_clust;
    4540:	ef 81       	ldd	r30, Y+7	; 0x07
    4542:	f8 85       	ldd	r31, Y+8	; 0x08
    4544:	80 83       	st	Z, r24
    4546:	91 83       	std	Z+1, r25	; 0x01
    4548:	a2 83       	std	Z+2, r26	; 0x02
    454a:	b3 83       	std	Z+3, r27	; 0x03
    454c:	e8 c0       	rjmp	.+464    	; 0x471e <f_getfree+0x260>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
    454e:	a0 80       	ld	r10, Z
			n = 0;
			if (fat == FS_FAT12) {
    4550:	b1 e0       	ldi	r27, 0x01	; 1
    4552:	ab 16       	cp	r10, r27
    4554:	d9 f5       	brne	.+118    	; 0x45cc <f_getfree+0x10e>
    4556:	cc 24       	eor	r12, r12
    4558:	dd 24       	eor	r13, r13
    455a:	76 01       	movw	r14, r12
    455c:	68 94       	set
    455e:	c1 f8       	bld	r12, 1
    4560:	44 24       	eor	r4, r4
    4562:	55 24       	eor	r5, r5
    4564:	32 01       	movw	r6, r4
				clst = 2;
				do {
					stat = get_fat(fs, clst);
    4566:	c4 01       	movw	r24, r8
    4568:	b7 01       	movw	r22, r14
    456a:	a6 01       	movw	r20, r12
    456c:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <get_fat>
    4570:	dc 01       	movw	r26, r24
    4572:	cb 01       	movw	r24, r22
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
    4574:	8f 3f       	cpi	r24, 0xFF	; 255
    4576:	ef ef       	ldi	r30, 0xFF	; 255
    4578:	9e 07       	cpc	r25, r30
    457a:	ef ef       	ldi	r30, 0xFF	; 255
    457c:	ae 07       	cpc	r26, r30
    457e:	ef ef       	ldi	r30, 0xFF	; 255
    4580:	be 07       	cpc	r27, r30
    4582:	09 f4       	brne	.+2      	; 0x4586 <f_getfree+0xc8>
    4584:	b0 c0       	rjmp	.+352    	; 0x46e6 <f_getfree+0x228>
					if (stat == 1) { res = FR_INT_ERR; break; }
    4586:	81 30       	cpi	r24, 0x01	; 1
    4588:	91 05       	cpc	r25, r1
    458a:	a1 05       	cpc	r26, r1
    458c:	b1 05       	cpc	r27, r1
    458e:	09 f4       	brne	.+2      	; 0x4592 <f_getfree+0xd4>
    4590:	ad c0       	rjmp	.+346    	; 0x46ec <f_getfree+0x22e>
					if (stat == 0) n++;
    4592:	00 97       	sbiw	r24, 0x00	; 0
    4594:	a1 05       	cpc	r26, r1
    4596:	b1 05       	cpc	r27, r1
    4598:	29 f4       	brne	.+10     	; 0x45a4 <f_getfree+0xe6>
    459a:	08 94       	sec
    459c:	41 1c       	adc	r4, r1
    459e:	51 1c       	adc	r5, r1
    45a0:	61 1c       	adc	r6, r1
    45a2:	71 1c       	adc	r7, r1
				} while (++clst < fs->n_fatent);
    45a4:	08 94       	sec
    45a6:	c1 1c       	adc	r12, r1
    45a8:	d1 1c       	adc	r13, r1
    45aa:	e1 1c       	adc	r14, r1
    45ac:	f1 1c       	adc	r15, r1
    45ae:	f4 01       	movw	r30, r8
    45b0:	82 8d       	ldd	r24, Z+26	; 0x1a
    45b2:	93 8d       	ldd	r25, Z+27	; 0x1b
    45b4:	a4 8d       	ldd	r26, Z+28	; 0x1c
    45b6:	b5 8d       	ldd	r27, Z+29	; 0x1d
    45b8:	c8 16       	cp	r12, r24
    45ba:	d9 06       	cpc	r13, r25
    45bc:	ea 06       	cpc	r14, r26
    45be:	fb 06       	cpc	r15, r27
    45c0:	90 f2       	brcs	.-92     	; 0x4566 <f_getfree+0xa8>
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
    45c2:	46 86       	std	Z+14, r4	; 0x0e
    45c4:	57 86       	std	Z+15, r5	; 0x0f
    45c6:	60 8a       	std	Z+16, r6	; 0x10
    45c8:	71 8a       	std	Z+17, r7	; 0x11
    45ca:	a2 c0       	rjmp	.+324    	; 0x4710 <f_getfree+0x252>
					if (stat == 1) { res = FR_INT_ERR; break; }
					if (stat == 0) n++;
				} while (++clst < fs->n_fatent);
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
    45cc:	82 a1       	lds	r24, 0x42
    45ce:	93 a1       	lds	r25, 0x43
    45d0:	a4 a1       	lds	r26, 0x44
    45d2:	b5 a1       	lds	r27, 0x45
    45d4:	8b 83       	std	Y+3, r24	; 0x03
    45d6:	9c 83       	std	Y+4, r25	; 0x04
    45d8:	ad 83       	std	Y+5, r26	; 0x05
    45da:	be 83       	std	Y+6, r27	; 0x06
				i = 0; p = 0;
    45dc:	e0 e0       	ldi	r30, 0x00	; 0
    45de:	f0 e0       	ldi	r31, 0x00	; 0
    45e0:	00 e0       	ldi	r16, 0x00	; 0
    45e2:	10 e0       	ldi	r17, 0x00	; 0
    45e4:	98 01       	movw	r18, r16
		if (fs->free_clust <= fs->n_fatent - 2) {
			*nclst = fs->free_clust;
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
			n = 0;
    45e6:	44 24       	eor	r4, r4
    45e8:	55 24       	eor	r5, r5
    45ea:	32 01       	movw	r6, r4
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
    45ec:	a4 01       	movw	r20, r8
    45ee:	4e 5c       	subi	r20, 0xCE	; 206
    45f0:	5f 4f       	sbci	r21, 0xFF	; 255
    45f2:	5c 87       	std	Y+12, r21	; 0x0c
    45f4:	4b 87       	std	Y+11, r20	; 0x0b
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
    45f6:	01 15       	cp	r16, r1
    45f8:	11 05       	cpc	r17, r1
    45fa:	21 05       	cpc	r18, r1
    45fc:	31 05       	cpc	r19, r1
    45fe:	d9 f4       	brne	.+54     	; 0x4636 <f_getfree+0x178>
						res = move_window(fs, sect++);
    4600:	c4 01       	movw	r24, r8
    4602:	4b 81       	ldd	r20, Y+3	; 0x03
    4604:	5c 81       	ldd	r21, Y+4	; 0x04
    4606:	6d 81       	ldd	r22, Y+5	; 0x05
    4608:	7e 81       	ldd	r23, Y+6	; 0x06
    460a:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
						if (res != FR_OK) break;
    460e:	88 23       	and	r24, r24
    4610:	09 f0       	breq	.+2      	; 0x4614 <f_getfree+0x156>
    4612:	70 c0       	rjmp	.+224    	; 0x46f4 <f_getfree+0x236>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
    4614:	8b 81       	ldd	r24, Y+3	; 0x03
    4616:	9c 81       	ldd	r25, Y+4	; 0x04
    4618:	ad 81       	ldd	r26, Y+5	; 0x05
    461a:	be 81       	ldd	r27, Y+6	; 0x06
    461c:	01 96       	adiw	r24, 0x01	; 1
    461e:	a1 1d       	adc	r26, r1
    4620:	b1 1d       	adc	r27, r1
    4622:	8b 83       	std	Y+3, r24	; 0x03
    4624:	9c 83       	std	Y+4, r25	; 0x04
    4626:	ad 83       	std	Y+5, r26	; 0x05
    4628:	be 83       	std	Y+6, r27	; 0x06
						if (res != FR_OK) break;
						p = fs->win;
    462a:	eb 85       	ldd	r30, Y+11	; 0x0b
    462c:	fc 85       	ldd	r31, Y+12	; 0x0c
						i = SS(fs);
    462e:	00 e0       	ldi	r16, 0x00	; 0
    4630:	12 e0       	ldi	r17, 0x02	; 2
    4632:	20 e0       	ldi	r18, 0x00	; 0
    4634:	30 e0       	ldi	r19, 0x00	; 0
					}
					if (fat == FS_FAT16) {
    4636:	92 e0       	ldi	r25, 0x02	; 2
    4638:	a9 16       	cp	r10, r25
    463a:	b1 f4       	brne	.+44     	; 0x4668 <f_getfree+0x1aa>
						if (LD_WORD(p) == 0) n++;
    463c:	a1 81       	ldd	r26, Z+1	; 0x01
    463e:	aa 87       	std	Y+10, r26	; 0x0a
    4640:	19 86       	std	Y+9, r1	; 0x09
    4642:	80 81       	ld	r24, Z
    4644:	90 e0       	ldi	r25, 0x00	; 0
    4646:	49 85       	ldd	r20, Y+9	; 0x09
    4648:	5a 85       	ldd	r21, Y+10	; 0x0a
    464a:	84 2b       	or	r24, r20
    464c:	95 2b       	or	r25, r21
    464e:	00 97       	sbiw	r24, 0x00	; 0
    4650:	29 f4       	brne	.+10     	; 0x465c <f_getfree+0x19e>
    4652:	08 94       	sec
    4654:	41 1c       	adc	r4, r1
    4656:	51 1c       	adc	r5, r1
    4658:	61 1c       	adc	r6, r1
    465a:	71 1c       	adc	r7, r1
						p += 2; i -= 2;
    465c:	32 96       	adiw	r30, 0x02	; 2
    465e:	02 50       	subi	r16, 0x02	; 2
    4660:	10 40       	sbci	r17, 0x00	; 0
    4662:	20 40       	sbci	r18, 0x00	; 0
    4664:	30 40       	sbci	r19, 0x00	; 0
    4666:	33 c0       	rjmp	.+102    	; 0x46ce <f_getfree+0x210>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
    4668:	83 81       	ldd	r24, Z+3	; 0x03
    466a:	90 e0       	ldi	r25, 0x00	; 0
    466c:	a0 e0       	ldi	r26, 0x00	; 0
    466e:	b0 e0       	ldi	r27, 0x00	; 0
    4670:	78 2f       	mov	r23, r24
    4672:	66 27       	eor	r22, r22
    4674:	55 27       	eor	r21, r21
    4676:	44 27       	eor	r20, r20
    4678:	82 81       	ldd	r24, Z+2	; 0x02
    467a:	90 e0       	ldi	r25, 0x00	; 0
    467c:	a0 e0       	ldi	r26, 0x00	; 0
    467e:	b0 e0       	ldi	r27, 0x00	; 0
    4680:	dc 01       	movw	r26, r24
    4682:	99 27       	eor	r25, r25
    4684:	88 27       	eor	r24, r24
    4686:	48 2b       	or	r20, r24
    4688:	59 2b       	or	r21, r25
    468a:	6a 2b       	or	r22, r26
    468c:	7b 2b       	or	r23, r27
    468e:	80 81       	ld	r24, Z
    4690:	90 e0       	ldi	r25, 0x00	; 0
    4692:	a0 e0       	ldi	r26, 0x00	; 0
    4694:	b0 e0       	ldi	r27, 0x00	; 0
    4696:	84 2b       	or	r24, r20
    4698:	95 2b       	or	r25, r21
    469a:	a6 2b       	or	r26, r22
    469c:	b7 2b       	or	r27, r23
    469e:	31 80       	ldd	r3, Z+1	; 0x01
    46a0:	22 24       	eor	r2, r2
    46a2:	a1 01       	movw	r20, r2
    46a4:	60 e0       	ldi	r22, 0x00	; 0
    46a6:	70 e0       	ldi	r23, 0x00	; 0
    46a8:	84 2b       	or	r24, r20
    46aa:	95 2b       	or	r25, r21
    46ac:	a6 2b       	or	r26, r22
    46ae:	b7 2b       	or	r27, r23
    46b0:	bf 70       	andi	r27, 0x0F	; 15
    46b2:	00 97       	sbiw	r24, 0x00	; 0
    46b4:	a1 05       	cpc	r26, r1
    46b6:	b1 05       	cpc	r27, r1
    46b8:	29 f4       	brne	.+10     	; 0x46c4 <f_getfree+0x206>
    46ba:	08 94       	sec
    46bc:	41 1c       	adc	r4, r1
    46be:	51 1c       	adc	r5, r1
    46c0:	61 1c       	adc	r6, r1
    46c2:	71 1c       	adc	r7, r1
						p += 4; i -= 4;
    46c4:	34 96       	adiw	r30, 0x04	; 4
    46c6:	04 50       	subi	r16, 0x04	; 4
    46c8:	10 40       	sbci	r17, 0x00	; 0
    46ca:	20 40       	sbci	r18, 0x00	; 0
    46cc:	30 40       	sbci	r19, 0x00	; 0
					}
				} while (--clst);
    46ce:	08 94       	sec
    46d0:	c1 08       	sbc	r12, r1
    46d2:	d1 08       	sbc	r13, r1
    46d4:	e1 08       	sbc	r14, r1
    46d6:	f1 08       	sbc	r15, r1
    46d8:	c1 14       	cp	r12, r1
    46da:	d1 04       	cpc	r13, r1
    46dc:	e1 04       	cpc	r14, r1
    46de:	f1 04       	cpc	r15, r1
    46e0:	09 f0       	breq	.+2      	; 0x46e4 <f_getfree+0x226>
    46e2:	89 cf       	rjmp	.-238    	; 0x45f6 <f_getfree+0x138>
    46e4:	08 c0       	rjmp	.+16     	; 0x46f6 <f_getfree+0x238>
			n = 0;
			if (fat == FS_FAT12) {
				clst = 2;
				do {
					stat = get_fat(fs, clst);
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
    46e6:	bb 24       	eor	r11, r11
    46e8:	b3 94       	inc	r11
    46ea:	05 c0       	rjmp	.+10     	; 0x46f6 <f_getfree+0x238>
					if (stat == 1) { res = FR_INT_ERR; break; }
    46ec:	bb 24       	eor	r11, r11
    46ee:	68 94       	set
    46f0:	b1 f8       	bld	r11, 1
    46f2:	01 c0       	rjmp	.+2      	; 0x46f6 <f_getfree+0x238>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
    46f4:	b8 2e       	mov	r11, r24
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
    46f6:	d4 01       	movw	r26, r8
    46f8:	1e 96       	adiw	r26, 0x0e	; 14
    46fa:	4d 92       	st	X+, r4
    46fc:	5d 92       	st	X+, r5
    46fe:	6d 92       	st	X+, r6
    4700:	7c 92       	st	X, r7
    4702:	51 97       	sbiw	r26, 0x11	; 17
			if (fat == FS_FAT32) fs->fsi_flag = 1;
    4704:	b3 e0       	ldi	r27, 0x03	; 3
    4706:	ab 16       	cp	r10, r27
    4708:	19 f4       	brne	.+6      	; 0x4710 <f_getfree+0x252>
    470a:	81 e0       	ldi	r24, 0x01	; 1
    470c:	f4 01       	movw	r30, r8
    470e:	85 83       	std	Z+5, r24	; 0x05
			*nclst = n;
    4710:	af 81       	ldd	r26, Y+7	; 0x07
    4712:	b8 85       	ldd	r27, Y+8	; 0x08
    4714:	4d 92       	st	X+, r4
    4716:	5d 92       	st	X+, r5
    4718:	6d 92       	st	X+, r6
    471a:	7c 92       	st	X, r7
    471c:	13 97       	sbiw	r26, 0x03	; 3
		}
	}
	LEAVE_FF(fs, res);
}
    471e:	8b 2d       	mov	r24, r11
    4720:	2c 96       	adiw	r28, 0x0c	; 12
    4722:	0f b6       	in	r0, 0x3f	; 63
    4724:	f8 94       	cli
    4726:	de bf       	out	0x3e, r29	; 62
    4728:	0f be       	out	0x3f, r0	; 63
    472a:	cd bf       	out	0x3d, r28	; 61
    472c:	df 91       	pop	r29
    472e:	cf 91       	pop	r28
    4730:	1f 91       	pop	r17
    4732:	0f 91       	pop	r16
    4734:	ff 90       	pop	r15
    4736:	ef 90       	pop	r14
    4738:	df 90       	pop	r13
    473a:	cf 90       	pop	r12
    473c:	bf 90       	pop	r11
    473e:	af 90       	pop	r10
    4740:	9f 90       	pop	r9
    4742:	8f 90       	pop	r8
    4744:	7f 90       	pop	r7
    4746:	6f 90       	pop	r6
    4748:	5f 90       	pop	r5
    474a:	4f 90       	pop	r4
    474c:	3f 90       	pop	r3
    474e:	2f 90       	pop	r2
    4750:	08 95       	ret

00004752 <f_truncate>:
/*-----------------------------------------------------------------------*/

FRESULT f_truncate (
	FIL *fp		/* Pointer to the file object */
)
{
    4752:	cf 92       	push	r12
    4754:	df 92       	push	r13
    4756:	ef 92       	push	r14
    4758:	ff 92       	push	r15
    475a:	0f 93       	push	r16
    475c:	1f 93       	push	r17
    475e:	cf 93       	push	r28
    4760:	df 93       	push	r29
    4762:	ec 01       	movw	r28, r24
	FRESULT res;
	DWORD ncl;


	if (!fp) return FR_INVALID_OBJECT;
    4764:	00 97       	sbiw	r24, 0x00	; 0
    4766:	09 f4       	brne	.+2      	; 0x476a <f_truncate+0x18>
    4768:	69 c0       	rjmp	.+210    	; 0x483c <f_truncate+0xea>

	res = validate(fp);						/* Check validity of the object */
    476a:	0e 94 84 09 	call	0x1308	; 0x1308 <validate>
	if (res == FR_OK) {
    476e:	88 23       	and	r24, r24
    4770:	09 f0       	breq	.+2      	; 0x4774 <f_truncate+0x22>
    4772:	65 c0       	rjmp	.+202    	; 0x483e <f_truncate+0xec>
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
    4774:	9c 81       	ldd	r25, Y+4	; 0x04
    4776:	99 23       	and	r25, r25
    4778:	24 f0       	brlt	.+8      	; 0x4782 <f_truncate+0x30>
			res = FR_INT_ERR;
		} else {
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
    477a:	91 fd       	sbrc	r25, 1
    477c:	69 c0       	rjmp	.+210    	; 0x4850 <f_truncate+0xfe>
				res = FR_DENIED;
    477e:	87 e0       	ldi	r24, 0x07	; 7
    4780:	5e c0       	rjmp	.+188    	; 0x483e <f_truncate+0xec>
	if (!fp) return FR_INVALID_OBJECT;

	res = validate(fp);						/* Check validity of the object */
	if (res == FR_OK) {
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
			res = FR_INT_ERR;
    4782:	82 e0       	ldi	r24, 0x02	; 2
    4784:	5c c0       	rjmp	.+184    	; 0x483e <f_truncate+0xec>
				res = FR_DENIED;
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
    4786:	4a 87       	std	Y+10, r20	; 0x0a
    4788:	5b 87       	std	Y+11, r21	; 0x0b
    478a:	6c 87       	std	Y+12, r22	; 0x0c
    478c:	7d 87       	std	Y+13, r23	; 0x0d
			fp->flag |= FA__WRITTEN;
    478e:	8c 81       	ldd	r24, Y+4	; 0x04
    4790:	80 62       	ori	r24, 0x20	; 32
    4792:	8c 83       	std	Y+4, r24	; 0x04
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
    4794:	41 15       	cp	r20, r1
    4796:	51 05       	cpc	r21, r1
    4798:	61 05       	cpc	r22, r1
    479a:	71 05       	cpc	r23, r1
    479c:	69 f4       	brne	.+26     	; 0x47b8 <f_truncate+0x66>
				res = remove_chain(fp->fs, fp->sclust);
    479e:	4e 85       	ldd	r20, Y+14	; 0x0e
    47a0:	5f 85       	ldd	r21, Y+15	; 0x0f
    47a2:	68 89       	ldd	r22, Y+16	; 0x10
    47a4:	79 89       	ldd	r23, Y+17	; 0x11
    47a6:	88 81       	ld	r24, Y
    47a8:	99 81       	ldd	r25, Y+1	; 0x01
    47aa:	0e 94 28 18 	call	0x3050	; 0x3050 <remove_chain>
				fp->sclust = 0;
    47ae:	1e 86       	std	Y+14, r1	; 0x0e
    47b0:	1f 86       	std	Y+15, r1	; 0x0f
    47b2:	18 8a       	std	Y+16, r1	; 0x10
    47b4:	19 8a       	std	Y+17, r1	; 0x11
    47b6:	3c c0       	rjmp	.+120    	; 0x4830 <f_truncate+0xde>
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
    47b8:	4a 89       	ldd	r20, Y+18	; 0x12
    47ba:	5b 89       	ldd	r21, Y+19	; 0x13
    47bc:	6c 89       	ldd	r22, Y+20	; 0x14
    47be:	7d 89       	ldd	r23, Y+21	; 0x15
    47c0:	88 81       	ld	r24, Y
    47c2:	99 81       	ldd	r25, Y+1	; 0x01
    47c4:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <get_fat>
    47c8:	6b 01       	movw	r12, r22
    47ca:	7c 01       	movw	r14, r24
				res = FR_OK;
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
    47cc:	81 e0       	ldi	r24, 0x01	; 1
    47ce:	c8 16       	cp	r12, r24
    47d0:	d1 04       	cpc	r13, r1
    47d2:	e1 04       	cpc	r14, r1
    47d4:	f1 04       	cpc	r15, r1
    47d6:	09 f4       	brne	.+2      	; 0x47da <f_truncate+0x88>
    47d8:	4a c0       	rjmp	.+148    	; 0x486e <f_truncate+0x11c>
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
				res = remove_chain(fp->fs, fp->sclust);
				fp->sclust = 0;
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
				res = FR_OK;
    47da:	81 e0       	ldi	r24, 0x01	; 1
    47dc:	9f ef       	ldi	r25, 0xFF	; 255
    47de:	c9 16       	cp	r12, r25
    47e0:	9f ef       	ldi	r25, 0xFF	; 255
    47e2:	d9 06       	cpc	r13, r25
    47e4:	9f ef       	ldi	r25, 0xFF	; 255
    47e6:	e9 06       	cpc	r14, r25
    47e8:	9f ef       	ldi	r25, 0xFF	; 255
    47ea:	f9 06       	cpc	r15, r25
    47ec:	09 f0       	breq	.+2      	; 0x47f0 <f_truncate+0x9e>
    47ee:	80 e0       	ldi	r24, 0x00	; 0
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
				if (res == FR_OK && ncl < fp->fs->n_fatent) {
    47f0:	88 23       	and	r24, r24
    47f2:	01 f5       	brne	.+64     	; 0x4834 <f_truncate+0xe2>
    47f4:	e8 81       	ld	r30, Y
    47f6:	f9 81       	ldd	r31, Y+1	; 0x01
    47f8:	42 8d       	ldd	r20, Z+26	; 0x1a
    47fa:	53 8d       	ldd	r21, Z+27	; 0x1b
    47fc:	64 8d       	ldd	r22, Z+28	; 0x1c
    47fe:	75 8d       	ldd	r23, Z+29	; 0x1d
    4800:	c4 16       	cp	r12, r20
    4802:	d5 06       	cpc	r13, r21
    4804:	e6 06       	cpc	r14, r22
    4806:	f7 06       	cpc	r15, r23
    4808:	d0 f4       	brcc	.+52     	; 0x483e <f_truncate+0xec>
					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
    480a:	4a 89       	ldd	r20, Y+18	; 0x12
    480c:	5b 89       	ldd	r21, Y+19	; 0x13
    480e:	6c 89       	ldd	r22, Y+20	; 0x14
    4810:	7d 89       	ldd	r23, Y+21	; 0x15
    4812:	cf 01       	movw	r24, r30
    4814:	0f ef       	ldi	r16, 0xFF	; 255
    4816:	1f ef       	ldi	r17, 0xFF	; 255
    4818:	2f ef       	ldi	r18, 0xFF	; 255
    481a:	3f e0       	ldi	r19, 0x0F	; 15
    481c:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <put_fat>
					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
    4820:	88 23       	and	r24, r24
    4822:	41 f4       	brne	.+16     	; 0x4834 <f_truncate+0xe2>
    4824:	88 81       	ld	r24, Y
    4826:	99 81       	ldd	r25, Y+1	; 0x01
    4828:	b7 01       	movw	r22, r14
    482a:	a6 01       	movw	r20, r12
    482c:	0e 94 28 18 	call	0x3050	; 0x3050 <remove_chain>
				}
			}
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
    4830:	88 23       	and	r24, r24
    4832:	29 f0       	breq	.+10     	; 0x483e <f_truncate+0xec>
    4834:	9c 81       	ldd	r25, Y+4	; 0x04
    4836:	90 68       	ori	r25, 0x80	; 128
    4838:	9c 83       	std	Y+4, r25	; 0x04
    483a:	01 c0       	rjmp	.+2      	; 0x483e <f_truncate+0xec>
{
	FRESULT res;
	DWORD ncl;


	if (!fp) return FR_INVALID_OBJECT;
    483c:	89 e0       	ldi	r24, 0x09	; 9
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
	}

	LEAVE_FF(fp->fs, res);
}
    483e:	df 91       	pop	r29
    4840:	cf 91       	pop	r28
    4842:	1f 91       	pop	r17
    4844:	0f 91       	pop	r16
    4846:	ff 90       	pop	r15
    4848:	ef 90       	pop	r14
    484a:	df 90       	pop	r13
    484c:	cf 90       	pop	r12
    484e:	08 95       	ret
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
				res = FR_DENIED;
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
    4850:	4e 81       	ldd	r20, Y+6	; 0x06
    4852:	5f 81       	ldd	r21, Y+7	; 0x07
    4854:	68 85       	ldd	r22, Y+8	; 0x08
    4856:	79 85       	ldd	r23, Y+9	; 0x09
    4858:	0a 85       	ldd	r16, Y+10	; 0x0a
    485a:	1b 85       	ldd	r17, Y+11	; 0x0b
    485c:	2c 85       	ldd	r18, Y+12	; 0x0c
    485e:	3d 85       	ldd	r19, Y+13	; 0x0d
    4860:	40 17       	cp	r20, r16
    4862:	51 07       	cpc	r21, r17
    4864:	62 07       	cpc	r22, r18
    4866:	73 07       	cpc	r23, r19
    4868:	08 f4       	brcc	.+2      	; 0x486c <f_truncate+0x11a>
    486a:	8d cf       	rjmp	.-230    	; 0x4786 <f_truncate+0x34>
    486c:	e8 cf       	rjmp	.-48     	; 0x483e <f_truncate+0xec>
				fp->sclust = 0;
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
				res = FR_OK;
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
    486e:	82 e0       	ldi	r24, 0x02	; 2
    4870:	e1 cf       	rjmp	.-62     	; 0x4834 <f_truncate+0xe2>

00004872 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR *path		/* Pointer to the file or directory path */
)
{
    4872:	cf 92       	push	r12
    4874:	df 92       	push	r13
    4876:	ef 92       	push	r14
    4878:	ff 92       	push	r15
    487a:	1f 93       	push	r17
    487c:	cf 93       	push	r28
    487e:	df 93       	push	r29
    4880:	cd b7       	in	r28, 0x3d	; 61
    4882:	de b7       	in	r29, 0x3e	; 62
    4884:	ea 97       	sbiw	r28, 0x3a	; 58
    4886:	0f b6       	in	r0, 0x3f	; 63
    4888:	f8 94       	cli
    488a:	de bf       	out	0x3e, r29	; 62
    488c:	0f be       	out	0x3f, r0	; 63
    488e:	cd bf       	out	0x3d, r28	; 61
    4890:	9a af       	sts	0x7a, r25
    4892:	89 af       	sts	0x79, r24
	BYTE *dir;
	DWORD dclst;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4894:	ce 01       	movw	r24, r28
    4896:	c9 96       	adiw	r24, 0x39	; 57
    4898:	be 01       	movw	r22, r28
    489a:	6f 5f       	subi	r22, 0xFF	; 255
    489c:	7f 4f       	sbci	r23, 0xFF	; 255
    489e:	41 e0       	ldi	r20, 0x01	; 1
    48a0:	0e 94 41 0a 	call	0x1482	; 0x1482 <chk_mounted>
	if (res == FR_OK) {
    48a4:	88 23       	and	r24, r24
    48a6:	09 f0       	breq	.+2      	; 0x48aa <f_unlink+0x38>
    48a8:	63 c0       	rjmp	.+198    	; 0x4970 <f_unlink+0xfe>
		INIT_BUF(dj);
    48aa:	ce 01       	movw	r24, r28
    48ac:	8d 96       	adiw	r24, 0x2d	; 45
    48ae:	9e 8b       	std	Y+22, r25	; 0x16
    48b0:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the file path */
    48b2:	69 ad       	sts	0x69, r22
    48b4:	7a ad       	sts	0x6a, r23
    48b6:	ce 01       	movw	r24, r28
    48b8:	01 96       	adiw	r24, 0x01	; 1
    48ba:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <follow_path>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    48be:	88 23       	and	r24, r24
    48c0:	09 f0       	breq	.+2      	; 0x48c4 <f_unlink+0x52>
    48c2:	56 c0       	rjmp	.+172    	; 0x4970 <f_unlink+0xfe>
    48c4:	ed 89       	ldd	r30, Y+21	; 0x15
    48c6:	fe 89       	ldd	r31, Y+22	; 0x16
    48c8:	83 85       	ldd	r24, Z+11	; 0x0b
    48ca:	85 ff       	sbrs	r24, 5
    48cc:	5f c0       	rjmp	.+190    	; 0x498c <f_unlink+0x11a>
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
    48ce:	86 e0       	ldi	r24, 0x06	; 6
    48d0:	4f c0       	rjmp	.+158    	; 0x4970 <f_unlink+0xfe>
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
    48d2:	fb 01       	movw	r30, r22
    48d4:	13 85       	ldd	r17, Z+11	; 0x0b
    48d6:	10 ff       	sbrs	r17, 0
    48d8:	60 c0       	rjmp	.+192    	; 0x499a <f_unlink+0x128>
					res = FR_DENIED;		/* Cannot remove R/O object */
    48da:	87 e0       	ldi	r24, 0x07	; 7
    48dc:	49 c0       	rjmp	.+146    	; 0x4970 <f_unlink+0xfe>
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
    48de:	86 e0       	ldi	r24, 0x06	; 6
    48e0:	47 c0       	rjmp	.+142    	; 0x4970 <f_unlink+0xfe>
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = ld_clust(dj.fs, dir);
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
				if (dclst < 2) {
    48e2:	f2 e0       	ldi	r31, 0x02	; 2
    48e4:	cf 16       	cp	r12, r31
    48e6:	d1 04       	cpc	r13, r1
    48e8:	e1 04       	cpc	r14, r1
    48ea:	f1 04       	cpc	r15, r1
    48ec:	08 f4       	brcc	.+2      	; 0x48f0 <f_unlink+0x7e>
    48ee:	5e c0       	rjmp	.+188    	; 0x49ac <f_unlink+0x13a>
					res = FR_INT_ERR;
				} else {
					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
    48f0:	ce 01       	movw	r24, r28
    48f2:	47 96       	adiw	r24, 0x17	; 23
    48f4:	be 01       	movw	r22, r28
    48f6:	6f 5f       	subi	r22, 0xFF	; 255
    48f8:	7f 4f       	sbci	r23, 0xFF	; 255
    48fa:	26 e1       	ldi	r18, 0x16	; 22
    48fc:	30 e0       	ldi	r19, 0x00	; 0
    48fe:	40 e0       	ldi	r20, 0x00	; 0
    4900:	50 e0       	ldi	r21, 0x00	; 0
    4902:	0e 94 9e 08 	call	0x113c	; 0x113c <mem_cpy>
					sdj.sclust = dclst;
    4906:	cd 8e       	std	Y+29, r12	; 0x1d
    4908:	de 8e       	std	Y+30, r13	; 0x1e
    490a:	ef 8e       	std	Y+31, r14	; 0x1f
    490c:	f8 a2       	lds	r31, 0x98
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
    490e:	ce 01       	movw	r24, r28
    4910:	47 96       	adiw	r24, 0x17	; 23
    4912:	62 e0       	ldi	r22, 0x02	; 2
    4914:	70 e0       	ldi	r23, 0x00	; 0
    4916:	0e 94 15 11 	call	0x222a	; 0x222a <dir_sdi>
					if (res == FR_OK) {
    491a:	88 23       	and	r24, r24
    491c:	49 f5       	brne	.+82     	; 0x4970 <f_unlink+0xfe>
						res = dir_read(&sdj);
    491e:	ce 01       	movw	r24, r28
    4920:	47 96       	adiw	r24, 0x17	; 23
    4922:	0e 94 f8 17 	call	0x2ff0	; 0x2ff0 <dir_read>
						if (res == FR_OK		/* Not empty dir */
    4926:	88 23       	and	r24, r24
    4928:	71 f0       	breq	.+28     	; 0x4946 <f_unlink+0xd4>
#if _FS_RPATH
						|| dclst == dj.fs->cdir	/* Current dir */
    492a:	e9 81       	ldd	r30, Y+1	; 0x01
    492c:	fa 81       	ldd	r31, Y+2	; 0x02
    492e:	46 89       	ldd	r20, Z+22	; 0x16
    4930:	57 89       	ldd	r21, Z+23	; 0x17
    4932:	60 8d       	ldd	r22, Z+24	; 0x18
    4934:	71 8d       	ldd	r23, Z+25	; 0x19
    4936:	4c 15       	cp	r20, r12
    4938:	5d 05       	cpc	r21, r13
    493a:	6e 05       	cpc	r22, r14
    493c:	7f 05       	cpc	r23, r15
    493e:	29 f0       	breq	.+10     	; 0x494a <f_unlink+0xd8>
#endif
						) res = FR_DENIED;
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
    4940:	84 30       	cpi	r24, 0x04	; 4
    4942:	b1 f1       	breq	.+108    	; 0x49b0 <f_unlink+0x13e>
    4944:	15 c0       	rjmp	.+42     	; 0x4970 <f_unlink+0xfe>
					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
					sdj.sclust = dclst;
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
					if (res == FR_OK) {
						res = dir_read(&sdj);
						if (res == FR_OK		/* Not empty dir */
    4946:	87 e0       	ldi	r24, 0x07	; 7
    4948:	13 c0       	rjmp	.+38     	; 0x4970 <f_unlink+0xfe>
#if _FS_RPATH
						|| dclst == dj.fs->cdir	/* Current dir */
    494a:	87 e0       	ldi	r24, 0x07	; 7
    494c:	11 c0       	rjmp	.+34     	; 0x4970 <f_unlink+0xfe>
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
				if (res == FR_OK) {
					if (dclst)				/* Remove the cluster chain if exist */
    494e:	c1 14       	cp	r12, r1
    4950:	d1 04       	cpc	r13, r1
    4952:	e1 04       	cpc	r14, r1
    4954:	f1 04       	cpc	r15, r1
    4956:	41 f0       	breq	.+16     	; 0x4968 <f_unlink+0xf6>
						res = remove_chain(dj.fs, dclst);
    4958:	89 81       	ldd	r24, Y+1	; 0x01
    495a:	9a 81       	ldd	r25, Y+2	; 0x02
    495c:	b7 01       	movw	r22, r14
    495e:	a6 01       	movw	r20, r12
    4960:	0e 94 28 18 	call	0x3050	; 0x3050 <remove_chain>
					if (res == FR_OK) res = sync(dj.fs);
    4964:	88 23       	and	r24, r24
    4966:	21 f4       	brne	.+8      	; 0x4970 <f_unlink+0xfe>
    4968:	89 81       	ldd	r24, Y+1	; 0x01
    496a:	9a 81       	ldd	r25, Y+2	; 0x02
    496c:	0e 94 16 0f 	call	0x1e2c	; 0x1e2c <sync>
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(dj.fs, res);
}
    4970:	ea 96       	adiw	r28, 0x3a	; 58
    4972:	0f b6       	in	r0, 0x3f	; 63
    4974:	f8 94       	cli
    4976:	de bf       	out	0x3e, r29	; 62
    4978:	0f be       	out	0x3f, r0	; 63
    497a:	cd bf       	out	0x3d, r28	; 61
    497c:	df 91       	pop	r29
    497e:	cf 91       	pop	r28
    4980:	1f 91       	pop	r17
    4982:	ff 90       	pop	r15
    4984:	ef 90       	pop	r14
    4986:	df 90       	pop	r13
    4988:	cf 90       	pop	r12
    498a:	08 95       	ret
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
    498c:	6b 89       	ldd	r22, Y+19	; 0x13
    498e:	7c 89       	ldd	r23, Y+20	; 0x14
			if (!dir) {
    4990:	61 15       	cp	r22, r1
    4992:	71 05       	cpc	r23, r1
    4994:	09 f0       	breq	.+2      	; 0x4998 <f_unlink+0x126>
    4996:	9d cf       	rjmp	.-198    	; 0x48d2 <f_unlink+0x60>
    4998:	a2 cf       	rjmp	.-188    	; 0x48de <f_unlink+0x6c>
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = ld_clust(dj.fs, dir);
    499a:	89 81       	ldd	r24, Y+1	; 0x01
    499c:	9a 81       	ldd	r25, Y+2	; 0x02
    499e:	0e 94 c4 08 	call	0x1188	; 0x1188 <ld_clust>
    49a2:	6b 01       	movw	r12, r22
    49a4:	7c 01       	movw	r14, r24
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
    49a6:	14 fd       	sbrc	r17, 4
    49a8:	9c cf       	rjmp	.-200    	; 0x48e2 <f_unlink+0x70>
    49aa:	02 c0       	rjmp	.+4      	; 0x49b0 <f_unlink+0x13e>
				if (dclst < 2) {
					res = FR_INT_ERR;
    49ac:	82 e0       	ldi	r24, 0x02	; 2
    49ae:	e0 cf       	rjmp	.-64     	; 0x4970 <f_unlink+0xfe>
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
    49b0:	ce 01       	movw	r24, r28
    49b2:	01 96       	adiw	r24, 0x01	; 1
    49b4:	0e 94 da 11 	call	0x23b4	; 0x23b4 <dir_remove>
				if (res == FR_OK) {
    49b8:	88 23       	and	r24, r24
    49ba:	49 f2       	breq	.-110    	; 0x494e <f_unlink+0xdc>
    49bc:	d9 cf       	rjmp	.-78     	; 0x4970 <f_unlink+0xfe>

000049be <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR *path		/* Pointer to the directory path */
)
{
    49be:	2f 92       	push	r2
    49c0:	3f 92       	push	r3
    49c2:	4f 92       	push	r4
    49c4:	5f 92       	push	r5
    49c6:	6f 92       	push	r6
    49c8:	7f 92       	push	r7
    49ca:	8f 92       	push	r8
    49cc:	9f 92       	push	r9
    49ce:	af 92       	push	r10
    49d0:	bf 92       	push	r11
    49d2:	cf 92       	push	r12
    49d4:	df 92       	push	r13
    49d6:	ef 92       	push	r14
    49d8:	ff 92       	push	r15
    49da:	0f 93       	push	r16
    49dc:	1f 93       	push	r17
    49de:	cf 93       	push	r28
    49e0:	df 93       	push	r29
    49e2:	cd b7       	in	r28, 0x3d	; 61
    49e4:	de b7       	in	r29, 0x3e	; 62
    49e6:	a8 97       	sbiw	r28, 0x28	; 40
    49e8:	0f b6       	in	r0, 0x3f	; 63
    49ea:	f8 94       	cli
    49ec:	de bf       	out	0x3e, r29	; 62
    49ee:	0f be       	out	0x3f, r0	; 63
    49f0:	cd bf       	out	0x3d, r28	; 61
    49f2:	9c a3       	lds	r25, 0x5c
    49f4:	8b a3       	lds	r24, 0x5b
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tim = get_fattime();
    49f6:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <get_fattime>
    49fa:	6b 01       	movw	r12, r22
    49fc:	7c 01       	movw	r14, r24
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    49fe:	ce 01       	movw	r24, r28
    4a00:	83 96       	adiw	r24, 0x23	; 35
    4a02:	be 01       	movw	r22, r28
    4a04:	6f 5f       	subi	r22, 0xFF	; 255
    4a06:	7f 4f       	sbci	r23, 0xFF	; 255
    4a08:	41 e0       	ldi	r20, 0x01	; 1
    4a0a:	0e 94 41 0a 	call	0x1482	; 0x1482 <chk_mounted>
    4a0e:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    4a10:	88 23       	and	r24, r24
    4a12:	09 f0       	breq	.+2      	; 0x4a16 <f_mkdir+0x58>
    4a14:	f6 c0       	rjmp	.+492    	; 0x4c02 <f_mkdir+0x244>
		INIT_BUF(dj);
    4a16:	ce 01       	movw	r24, r28
    4a18:	47 96       	adiw	r24, 0x17	; 23
    4a1a:	9e 8b       	std	Y+22, r25	; 0x16
    4a1c:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);			/* Follow the file path */
    4a1e:	6b a1       	lds	r22, 0x4b
    4a20:	7c a1       	lds	r23, 0x4c
    4a22:	ce 01       	movw	r24, r28
    4a24:	01 96       	adiw	r24, 0x01	; 1
    4a26:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <follow_path>
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
    4a2a:	88 23       	and	r24, r24
    4a2c:	49 f0       	breq	.+18     	; 0x4a40 <f_mkdir+0x82>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
    4a2e:	84 30       	cpi	r24, 0x04	; 4
    4a30:	41 f4       	brne	.+16     	; 0x4a42 <f_mkdir+0x84>
    4a32:	ed 89       	ldd	r30, Y+21	; 0x15
    4a34:	fe 89       	ldd	r31, Y+22	; 0x16
    4a36:	83 85       	ldd	r24, Z+11	; 0x0b
    4a38:	85 ff       	sbrs	r24, 5
    4a3a:	fd c0       	rjmp	.+506    	; 0x4c36 <f_mkdir+0x278>
			res = FR_INVALID_NAME;
    4a3c:	86 e0       	ldi	r24, 0x06	; 6
    4a3e:	01 c0       	rjmp	.+2      	; 0x4a42 <f_mkdir+0x84>

	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
    4a40:	88 e0       	ldi	r24, 0x08	; 8
				ST_DWORD(dir+DIR_WrtTime, tim);
				st_clust(dir, dcl);
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
    4a42:	18 2f       	mov	r17, r24
    4a44:	de c0       	rjmp	.+444    	; 0x4c02 <f_mkdir+0x244>
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
			if (dcl == 1) res = FR_INT_ERR;
    4a46:	81 e0       	ldi	r24, 0x01	; 1
    4a48:	48 16       	cp	r4, r24
    4a4a:	51 04       	cpc	r5, r1
    4a4c:	61 04       	cpc	r6, r1
    4a4e:	71 04       	cpc	r7, r1
    4a50:	09 f4       	brne	.+2      	; 0x4a54 <f_mkdir+0x96>
    4a52:	01 c1       	rjmp	.+514    	; 0x4c56 <f_mkdir+0x298>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
    4a54:	ef ef       	ldi	r30, 0xFF	; 255
    4a56:	4e 16       	cp	r4, r30
    4a58:	ef ef       	ldi	r30, 0xFF	; 255
    4a5a:	5e 06       	cpc	r5, r30
    4a5c:	ef ef       	ldi	r30, 0xFF	; 255
    4a5e:	6e 06       	cpc	r6, r30
    4a60:	ef ef       	ldi	r30, 0xFF	; 255
    4a62:	7e 06       	cpc	r7, r30
    4a64:	09 f4       	brne	.+2      	; 0x4a68 <f_mkdir+0xaa>
    4a66:	f9 c0       	rjmp	.+498    	; 0x4c5a <f_mkdir+0x29c>
    4a68:	01 c0       	rjmp	.+2      	; 0x4a6c <f_mkdir+0xae>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
    4a6a:	17 e0       	ldi	r17, 0x07	; 7
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
			if (res == FR_OK)					/* Flush FAT */
    4a6c:	11 23       	and	r17, r17
    4a6e:	09 f0       	breq	.+2      	; 0x4a72 <f_mkdir+0xb4>
    4a70:	a8 c0       	rjmp	.+336    	; 0x4bc2 <f_mkdir+0x204>
				res = move_window(dj.fs, 0);
    4a72:	89 81       	ldd	r24, Y+1	; 0x01
    4a74:	9a 81       	ldd	r25, Y+2	; 0x02
    4a76:	40 e0       	ldi	r20, 0x00	; 0
    4a78:	50 e0       	ldi	r21, 0x00	; 0
    4a7a:	ba 01       	movw	r22, r20
    4a7c:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
    4a80:	18 2f       	mov	r17, r24
			if (res == FR_OK) {					/* Initialize the new directory table */
    4a82:	88 23       	and	r24, r24
    4a84:	09 f0       	breq	.+2      	; 0x4a88 <f_mkdir+0xca>
    4a86:	9d c0       	rjmp	.+314    	; 0x4bc2 <f_mkdir+0x204>
				dsc = clust2sect(dj.fs, dcl);
    4a88:	09 81       	ldd	r16, Y+1	; 0x01
    4a8a:	1a 81       	ldd	r17, Y+2	; 0x02
    4a8c:	c8 01       	movw	r24, r16
    4a8e:	b3 01       	movw	r22, r6
    4a90:	a2 01       	movw	r20, r4
    4a92:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <clust2sect>
    4a96:	4b 01       	movw	r8, r22
    4a98:	5c 01       	movw	r10, r24
				dir = dj.fs->win;
    4a9a:	0f 2e       	mov	r0, r31
    4a9c:	f2 e3       	ldi	r31, 0x32	; 50
    4a9e:	2f 2e       	mov	r2, r31
    4aa0:	33 24       	eor	r3, r3
    4aa2:	f0 2d       	mov	r31, r0
    4aa4:	20 0e       	add	r2, r16
    4aa6:	31 1e       	adc	r3, r17
				mem_set(dir, 0, SS(dj.fs));
    4aa8:	c1 01       	movw	r24, r2
    4aaa:	60 e0       	ldi	r22, 0x00	; 0
    4aac:	70 e0       	ldi	r23, 0x00	; 0
    4aae:	20 e0       	ldi	r18, 0x00	; 0
    4ab0:	32 e0       	ldi	r19, 0x02	; 2
    4ab2:	40 e0       	ldi	r20, 0x00	; 0
    4ab4:	50 e0       	ldi	r21, 0x00	; 0
    4ab6:	0e 94 b3 08 	call	0x1166	; 0x1166 <mem_set>
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
    4aba:	c1 01       	movw	r24, r2
    4abc:	60 e2       	ldi	r22, 0x20	; 32
    4abe:	70 e0       	ldi	r23, 0x00	; 0
    4ac0:	2b e0       	ldi	r18, 0x0B	; 11
    4ac2:	30 e0       	ldi	r19, 0x00	; 0
    4ac4:	40 e0       	ldi	r20, 0x00	; 0
    4ac6:	50 e0       	ldi	r21, 0x00	; 0
    4ac8:	0e 94 b3 08 	call	0x1166	; 0x1166 <mem_set>
				dir[DIR_Name] = '.';
    4acc:	8e e2       	ldi	r24, 0x2E	; 46
    4ace:	f8 01       	movw	r30, r16
    4ad0:	82 ab       	sts	0x52, r24
				dir[DIR_Attr] = AM_DIR;
    4ad2:	80 e1       	ldi	r24, 0x10	; 16
    4ad4:	85 af       	sts	0x75, r24
				ST_DWORD(dir+DIR_WrtTime, tim);
    4ad6:	cd a2       	lds	r28, 0x9d
    4ad8:	e8 5b       	subi	r30, 0xB8	; 184
    4ada:	ff 4f       	sbci	r31, 0xFF	; 255
    4adc:	c0 82       	st	Z, r12
    4ade:	8d 2d       	mov	r24, r13
    4ae0:	99 27       	eor	r25, r25
    4ae2:	8e a3       	lds	r24, 0x5e
    4ae4:	f8 01       	movw	r30, r16
    4ae6:	e7 5b       	subi	r30, 0xB7	; 183
    4ae8:	ff 4f       	sbci	r31, 0xFF	; 255
    4aea:	80 83       	st	Z, r24
    4aec:	c7 01       	movw	r24, r14
    4aee:	aa 27       	eor	r26, r26
    4af0:	bb 27       	eor	r27, r27
    4af2:	8f a3       	lds	r24, 0x5f
    4af4:	f8 01       	movw	r30, r16
    4af6:	e6 5b       	subi	r30, 0xB6	; 182
    4af8:	ff 4f       	sbci	r31, 0xFF	; 255
    4afa:	80 83       	st	Z, r24
    4afc:	cf 2c       	mov	r12, r15
    4afe:	dd 24       	eor	r13, r13
    4b00:	ee 24       	eor	r14, r14
    4b02:	ff 24       	eor	r15, r15
    4b04:	c8 a6       	lds	r28, 0xb8
    4b06:	f8 01       	movw	r30, r16
    4b08:	e5 5b       	subi	r30, 0xB5	; 181
    4b0a:	ff 4f       	sbci	r31, 0xFF	; 255
    4b0c:	c0 82       	st	Z, r12
				st_clust(dir, dcl);
    4b0e:	c1 01       	movw	r24, r2
    4b10:	b3 01       	movw	r22, r6
    4b12:	a2 01       	movw	r20, r4
    4b14:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <st_clust>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
    4b18:	0f 2e       	mov	r0, r31
    4b1a:	f2 e5       	ldi	r31, 0x52	; 82
    4b1c:	cf 2e       	mov	r12, r31
    4b1e:	dd 24       	eor	r13, r13
    4b20:	f0 2d       	mov	r31, r0
    4b22:	c0 0e       	add	r12, r16
    4b24:	d1 1e       	adc	r13, r17
    4b26:	c6 01       	movw	r24, r12
    4b28:	b1 01       	movw	r22, r2
    4b2a:	20 e2       	ldi	r18, 0x20	; 32
    4b2c:	30 e0       	ldi	r19, 0x00	; 0
    4b2e:	40 e0       	ldi	r20, 0x00	; 0
    4b30:	50 e0       	ldi	r21, 0x00	; 0
    4b32:	0e 94 9e 08 	call	0x113c	; 0x113c <mem_cpy>
				dir[33] = '.'; pcl = dj.sclust;
    4b36:	f8 01       	movw	r30, r16
    4b38:	ed 5a       	subi	r30, 0xAD	; 173
    4b3a:	ff 4f       	sbci	r31, 0xFF	; 255
    4b3c:	8e e2       	ldi	r24, 0x2E	; 46
    4b3e:	80 83       	st	Z, r24
    4b40:	4f 81       	ldd	r20, Y+7	; 0x07
    4b42:	58 85       	ldd	r21, Y+8	; 0x08
    4b44:	69 85       	ldd	r22, Y+9	; 0x09
    4b46:	7a 85       	ldd	r23, Y+10	; 0x0a
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
    4b48:	e9 81       	ldd	r30, Y+1	; 0x01
    4b4a:	fa 81       	ldd	r31, Y+2	; 0x02
    4b4c:	80 81       	ld	r24, Z
    4b4e:	83 30       	cpi	r24, 0x03	; 3
    4b50:	61 f4       	brne	.+24     	; 0x4b6a <f_mkdir+0x1ac>
    4b52:	86 a1       	lds	r24, 0x46
    4b54:	97 a1       	lds	r25, 0x47
    4b56:	a0 a5       	lds	r26, 0x60
    4b58:	b1 a5       	lds	r27, 0x61
    4b5a:	84 17       	cp	r24, r20
    4b5c:	95 07       	cpc	r25, r21
    4b5e:	a6 07       	cpc	r26, r22
    4b60:	b7 07       	cpc	r27, r23
    4b62:	19 f4       	brne	.+6      	; 0x4b6a <f_mkdir+0x1ac>
					pcl = 0;
    4b64:	40 e0       	ldi	r20, 0x00	; 0
    4b66:	50 e0       	ldi	r21, 0x00	; 0
    4b68:	ba 01       	movw	r22, r20
				st_clust(dir+SZ_DIR, pcl);
    4b6a:	c6 01       	movw	r24, r12
    4b6c:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <st_clust>
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
    4b70:	e9 81       	ldd	r30, Y+1	; 0x01
    4b72:	fa 81       	ldd	r31, Y+2	; 0x02
    4b74:	02 81       	ldd	r16, Z+2	; 0x02
    4b76:	00 23       	and	r16, r16
    4b78:	09 f4       	brne	.+2      	; 0x4b7c <f_mkdir+0x1be>
    4b7a:	71 c0       	rjmp	.+226    	; 0x4c5e <f_mkdir+0x2a0>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
    4b7c:	cc 24       	eor	r12, r12
    4b7e:	c3 94       	inc	r12
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
    4b80:	89 81       	ldd	r24, Y+1	; 0x01
    4b82:	9a 81       	ldd	r25, Y+2	; 0x02
    4b84:	fc 01       	movw	r30, r24
    4b86:	86 a6       	lds	r24, 0xb6
    4b88:	97 a6       	lds	r25, 0xb7
    4b8a:	a0 aa       	sts	0x90, r26
    4b8c:	b1 aa       	sts	0x91, r27
    4b8e:	08 94       	sec
    4b90:	81 1c       	adc	r8, r1
    4b92:	91 1c       	adc	r9, r1
    4b94:	a1 1c       	adc	r10, r1
    4b96:	b1 1c       	adc	r11, r1
					dj.fs->wflag = 1;
    4b98:	c4 82       	std	Z+4, r12	; 0x04
					res = move_window(dj.fs, 0);
    4b9a:	40 e0       	ldi	r20, 0x00	; 0
    4b9c:	50 e0       	ldi	r21, 0x00	; 0
    4b9e:	ba 01       	movw	r22, r20
    4ba0:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
    4ba4:	18 2f       	mov	r17, r24
					if (res != FR_OK) break;
    4ba6:	88 23       	and	r24, r24
    4ba8:	61 f4       	brne	.+24     	; 0x4bc2 <f_mkdir+0x204>
					mem_set(dir, 0, SS(dj.fs));
    4baa:	c1 01       	movw	r24, r2
    4bac:	60 e0       	ldi	r22, 0x00	; 0
    4bae:	70 e0       	ldi	r23, 0x00	; 0
    4bb0:	20 e0       	ldi	r18, 0x00	; 0
    4bb2:	32 e0       	ldi	r19, 0x02	; 2
    4bb4:	40 e0       	ldi	r20, 0x00	; 0
    4bb6:	50 e0       	ldi	r21, 0x00	; 0
    4bb8:	0e 94 b3 08 	call	0x1166	; 0x1166 <mem_set>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
    4bbc:	01 50       	subi	r16, 0x01	; 1
    4bbe:	01 f7       	brne	.-64     	; 0x4b80 <f_mkdir+0x1c2>
    4bc0:	4e c0       	rjmp	.+156    	; 0x4c5e <f_mkdir+0x2a0>
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
    4bc2:	89 81       	ldd	r24, Y+1	; 0x01
    4bc4:	9a 81       	ldd	r25, Y+2	; 0x02
    4bc6:	b3 01       	movw	r22, r6
    4bc8:	a2 01       	movw	r20, r4
    4bca:	0e 94 28 18 	call	0x3050	; 0x3050 <remove_chain>
    4bce:	19 c0       	rjmp	.+50     	; 0x4c02 <f_mkdir+0x244>
			} else {
				dir = dj.dir;
    4bd0:	eb 89       	ldd	r30, Y+19	; 0x13
    4bd2:	fc 89       	ldd	r31, Y+20	; 0x14
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
    4bd4:	80 e1       	ldi	r24, 0x10	; 16
    4bd6:	83 87       	std	Z+11, r24	; 0x0b
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
    4bd8:	8d a1       	lds	r24, 0x4d
    4bda:	86 8b       	std	Z+22, r24	; 0x16
    4bdc:	8e a1       	lds	r24, 0x4e
    4bde:	87 8b       	std	Z+23, r24	; 0x17
    4be0:	8f a1       	lds	r24, 0x4f
    4be2:	80 8f       	std	Z+24, r24	; 0x18
    4be4:	88 a5       	lds	r24, 0x68
    4be6:	81 8f       	std	Z+25, r24	; 0x19
				st_clust(dir, dcl);					/* Table start cluster */
    4be8:	cf 01       	movw	r24, r30
    4bea:	b3 01       	movw	r22, r6
    4bec:	a2 01       	movw	r20, r4
    4bee:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <st_clust>
				dj.fs->wflag = 1;
    4bf2:	89 81       	ldd	r24, Y+1	; 0x01
    4bf4:	9a 81       	ldd	r25, Y+2	; 0x02
    4bf6:	21 e0       	ldi	r18, 0x01	; 1
    4bf8:	fc 01       	movw	r30, r24
    4bfa:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    4bfc:	0e 94 16 0f 	call	0x1e2c	; 0x1e2c <sync>
    4c00:	18 2f       	mov	r17, r24
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    4c02:	81 2f       	mov	r24, r17
    4c04:	a8 96       	adiw	r28, 0x28	; 40
    4c06:	0f b6       	in	r0, 0x3f	; 63
    4c08:	f8 94       	cli
    4c0a:	de bf       	out	0x3e, r29	; 62
    4c0c:	0f be       	out	0x3f, r0	; 63
    4c0e:	cd bf       	out	0x3d, r28	; 61
    4c10:	df 91       	pop	r29
    4c12:	cf 91       	pop	r28
    4c14:	1f 91       	pop	r17
    4c16:	0f 91       	pop	r16
    4c18:	ff 90       	pop	r15
    4c1a:	ef 90       	pop	r14
    4c1c:	df 90       	pop	r13
    4c1e:	cf 90       	pop	r12
    4c20:	bf 90       	pop	r11
    4c22:	af 90       	pop	r10
    4c24:	9f 90       	pop	r9
    4c26:	8f 90       	pop	r8
    4c28:	7f 90       	pop	r7
    4c2a:	6f 90       	pop	r6
    4c2c:	5f 90       	pop	r5
    4c2e:	4f 90       	pop	r4
    4c30:	3f 90       	pop	r3
    4c32:	2f 90       	pop	r2
    4c34:	08 95       	ret
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
    4c36:	89 81       	ldd	r24, Y+1	; 0x01
    4c38:	9a 81       	ldd	r25, Y+2	; 0x02
    4c3a:	40 e0       	ldi	r20, 0x00	; 0
    4c3c:	50 e0       	ldi	r21, 0x00	; 0
    4c3e:	ba 01       	movw	r22, r20
    4c40:	0e 94 07 13 	call	0x260e	; 0x260e <create_chain>
    4c44:	2b 01       	movw	r4, r22
    4c46:	3c 01       	movw	r6, r24
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
    4c48:	61 15       	cp	r22, r1
    4c4a:	71 05       	cpc	r23, r1
    4c4c:	81 05       	cpc	r24, r1
    4c4e:	91 05       	cpc	r25, r1
    4c50:	09 f4       	brne	.+2      	; 0x4c54 <f_mkdir+0x296>
    4c52:	0b cf       	rjmp	.-490    	; 0x4a6a <f_mkdir+0xac>
    4c54:	f8 ce       	rjmp	.-528    	; 0x4a46 <f_mkdir+0x88>
			if (dcl == 1) res = FR_INT_ERR;
    4c56:	12 e0       	ldi	r17, 0x02	; 2
    4c58:	b4 cf       	rjmp	.-152    	; 0x4bc2 <f_mkdir+0x204>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
    4c5a:	11 e0       	ldi	r17, 0x01	; 1
    4c5c:	b2 cf       	rjmp	.-156    	; 0x4bc2 <f_mkdir+0x204>
					res = move_window(dj.fs, 0);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
    4c5e:	ce 01       	movw	r24, r28
    4c60:	01 96       	adiw	r24, 0x01	; 1
    4c62:	0e 94 97 17 	call	0x2f2e	; 0x2f2e <dir_register>
    4c66:	18 2f       	mov	r17, r24
			if (res != FR_OK) {
    4c68:	88 23       	and	r24, r24
    4c6a:	09 f4       	brne	.+2      	; 0x4c6e <f_mkdir+0x2b0>
    4c6c:	b1 cf       	rjmp	.-158    	; 0x4bd0 <f_mkdir+0x212>
    4c6e:	a9 cf       	rjmp	.-174    	; 0x4bc2 <f_mkdir+0x204>

00004c70 <f_chmod>:
FRESULT f_chmod (
	const TCHAR *path,	/* Pointer to the file path */
	BYTE value,			/* Attribute bits */
	BYTE mask			/* Attribute mask to change */
)
{
    4c70:	0f 93       	push	r16
    4c72:	1f 93       	push	r17
    4c74:	cf 93       	push	r28
    4c76:	df 93       	push	r29
    4c78:	cd b7       	in	r28, 0x3d	; 61
    4c7a:	de b7       	in	r29, 0x3e	; 62
    4c7c:	a4 97       	sbiw	r28, 0x24	; 36
    4c7e:	0f b6       	in	r0, 0x3f	; 63
    4c80:	f8 94       	cli
    4c82:	de bf       	out	0x3e, r29	; 62
    4c84:	0f be       	out	0x3f, r0	; 63
    4c86:	cd bf       	out	0x3d, r28	; 61
    4c88:	9c a3       	lds	r25, 0x5c
    4c8a:	8b a3       	lds	r24, 0x5b
    4c8c:	06 2f       	mov	r16, r22
    4c8e:	14 2f       	mov	r17, r20
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4c90:	ce 01       	movw	r24, r28
    4c92:	83 96       	adiw	r24, 0x23	; 35
    4c94:	be 01       	movw	r22, r28
    4c96:	6f 5f       	subi	r22, 0xFF	; 255
    4c98:	7f 4f       	sbci	r23, 0xFF	; 255
    4c9a:	41 e0       	ldi	r20, 0x01	; 1
    4c9c:	0e 94 41 0a 	call	0x1482	; 0x1482 <chk_mounted>
	if (res == FR_OK) {
    4ca0:	88 23       	and	r24, r24
    4ca2:	29 f5       	brne	.+74     	; 0x4cee <f_chmod+0x7e>
		INIT_BUF(dj);
    4ca4:	ce 01       	movw	r24, r28
    4ca6:	47 96       	adiw	r24, 0x17	; 23
    4ca8:	9e 8b       	std	Y+22, r25	; 0x16
    4caa:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the file path */
    4cac:	6b a1       	lds	r22, 0x4b
    4cae:	7c a1       	lds	r23, 0x4c
    4cb0:	ce 01       	movw	r24, r28
    4cb2:	01 96       	adiw	r24, 0x01	; 1
    4cb4:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <follow_path>
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    4cb8:	88 23       	and	r24, r24
    4cba:	c9 f4       	brne	.+50     	; 0x4cee <f_chmod+0x7e>
    4cbc:	ed 89       	ldd	r30, Y+21	; 0x15
    4cbe:	fe 89       	ldd	r31, Y+22	; 0x16
    4cc0:	83 85       	ldd	r24, Z+11	; 0x0b
    4cc2:	85 ff       	sbrs	r24, 5
    4cc4:	1f c0       	rjmp	.+62     	; 0x4d04 <f_chmod+0x94>
			res = FR_INVALID_NAME;
    4cc6:	86 e0       	ldi	r24, 0x06	; 6
    4cc8:	12 c0       	rjmp	.+36     	; 0x4cee <f_chmod+0x7e>
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
			} else {						/* File or sub directory */
				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
    4cca:	17 72       	andi	r17, 0x27	; 39
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
    4ccc:	91 2f       	mov	r25, r17
    4cce:	90 95       	com	r25
    4cd0:	83 85       	ldd	r24, Z+11	; 0x0b
    4cd2:	89 23       	and	r24, r25
    4cd4:	01 23       	and	r16, r17
    4cd6:	18 2f       	mov	r17, r24
    4cd8:	10 2b       	or	r17, r16
    4cda:	13 87       	std	Z+11, r17	; 0x0b
				dj.fs->wflag = 1;
    4cdc:	89 81       	ldd	r24, Y+1	; 0x01
    4cde:	9a 81       	ldd	r25, Y+2	; 0x02
    4ce0:	21 e0       	ldi	r18, 0x01	; 1
    4ce2:	fc 01       	movw	r30, r24
    4ce4:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    4ce6:	0e 94 16 0f 	call	0x1e2c	; 0x1e2c <sync>
    4cea:	01 c0       	rjmp	.+2      	; 0x4cee <f_chmod+0x7e>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
    4cec:	86 e0       	ldi	r24, 0x06	; 6
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
    4cee:	a4 96       	adiw	r28, 0x24	; 36
    4cf0:	0f b6       	in	r0, 0x3f	; 63
    4cf2:	f8 94       	cli
    4cf4:	de bf       	out	0x3e, r29	; 62
    4cf6:	0f be       	out	0x3f, r0	; 63
    4cf8:	cd bf       	out	0x3d, r28	; 61
    4cfa:	df 91       	pop	r29
    4cfc:	cf 91       	pop	r28
    4cfe:	1f 91       	pop	r17
    4d00:	0f 91       	pop	r16
    4d02:	08 95       	ret
		res = follow_path(&dj, path);		/* Follow the file path */
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
    4d04:	eb 89       	ldd	r30, Y+19	; 0x13
    4d06:	fc 89       	ldd	r31, Y+20	; 0x14
			if (!dir) {						/* Is it a root directory? */
    4d08:	30 97       	sbiw	r30, 0x00	; 0
    4d0a:	f9 f6       	brne	.-66     	; 0x4cca <f_chmod+0x5a>
    4d0c:	ef cf       	rjmp	.-34     	; 0x4cec <f_chmod+0x7c>

00004d0e <f_utime>:

FRESULT f_utime (
	const TCHAR *path,	/* Pointer to the file/directory name */
	const FILINFO *fno	/* Pointer to the time stamp to be set */
)
{
    4d0e:	0f 93       	push	r16
    4d10:	1f 93       	push	r17
    4d12:	cf 93       	push	r28
    4d14:	df 93       	push	r29
    4d16:	cd b7       	in	r28, 0x3d	; 61
    4d18:	de b7       	in	r29, 0x3e	; 62
    4d1a:	a4 97       	sbiw	r28, 0x24	; 36
    4d1c:	0f b6       	in	r0, 0x3f	; 63
    4d1e:	f8 94       	cli
    4d20:	de bf       	out	0x3e, r29	; 62
    4d22:	0f be       	out	0x3f, r0	; 63
    4d24:	cd bf       	out	0x3d, r28	; 61
    4d26:	9c a3       	lds	r25, 0x5c
    4d28:	8b a3       	lds	r24, 0x5b
    4d2a:	8b 01       	movw	r16, r22
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4d2c:	ce 01       	movw	r24, r28
    4d2e:	83 96       	adiw	r24, 0x23	; 35
    4d30:	be 01       	movw	r22, r28
    4d32:	6f 5f       	subi	r22, 0xFF	; 255
    4d34:	7f 4f       	sbci	r23, 0xFF	; 255
    4d36:	41 e0       	ldi	r20, 0x01	; 1
    4d38:	0e 94 41 0a 	call	0x1482	; 0x1482 <chk_mounted>
	if (res == FR_OK) {
    4d3c:	88 23       	and	r24, r24
    4d3e:	61 f5       	brne	.+88     	; 0x4d98 <f_utime+0x8a>
		INIT_BUF(dj);
    4d40:	ce 01       	movw	r24, r28
    4d42:	47 96       	adiw	r24, 0x17	; 23
    4d44:	9e 8b       	std	Y+22, r25	; 0x16
    4d46:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    4d48:	6b a1       	lds	r22, 0x4b
    4d4a:	7c a1       	lds	r23, 0x4c
    4d4c:	ce 01       	movw	r24, r28
    4d4e:	01 96       	adiw	r24, 0x01	; 1
    4d50:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <follow_path>
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    4d54:	88 23       	and	r24, r24
    4d56:	01 f5       	brne	.+64     	; 0x4d98 <f_utime+0x8a>
    4d58:	ed 89       	ldd	r30, Y+21	; 0x15
    4d5a:	fe 89       	ldd	r31, Y+22	; 0x16
    4d5c:	83 85       	ldd	r24, Z+11	; 0x0b
    4d5e:	85 ff       	sbrs	r24, 5
    4d60:	26 c0       	rjmp	.+76     	; 0x4dae <f_utime+0xa0>
			res = FR_INVALID_NAME;
    4d62:	86 e0       	ldi	r24, 0x06	; 6
    4d64:	19 c0       	rjmp	.+50     	; 0x4d98 <f_utime+0x8a>
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {					/* Root directory */
				res = FR_INVALID_NAME;
			} else {					/* File or sub-directory */
				ST_WORD(dir+DIR_WrtTime, fno->ftime);
    4d66:	d8 01       	movw	r26, r16
    4d68:	16 96       	adiw	r26, 0x06	; 6
    4d6a:	8c 91       	ld	r24, X
    4d6c:	16 97       	sbiw	r26, 0x06	; 6
    4d6e:	86 8b       	std	Z+22, r24	; 0x16
    4d70:	17 96       	adiw	r26, 0x07	; 7
    4d72:	8c 91       	ld	r24, X
    4d74:	17 97       	sbiw	r26, 0x07	; 7
    4d76:	87 8b       	std	Z+23, r24	; 0x17
				ST_WORD(dir+DIR_WrtDate, fno->fdate);
    4d78:	14 96       	adiw	r26, 0x04	; 4
    4d7a:	8c 91       	ld	r24, X
    4d7c:	14 97       	sbiw	r26, 0x04	; 4
    4d7e:	80 8f       	std	Z+24, r24	; 0x18
    4d80:	15 96       	adiw	r26, 0x05	; 5
    4d82:	8c 91       	ld	r24, X
    4d84:	81 8f       	std	Z+25, r24	; 0x19
				dj.fs->wflag = 1;
    4d86:	89 81       	ldd	r24, Y+1	; 0x01
    4d88:	9a 81       	ldd	r25, Y+2	; 0x02
    4d8a:	21 e0       	ldi	r18, 0x01	; 1
    4d8c:	fc 01       	movw	r30, r24
    4d8e:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    4d90:	0e 94 16 0f 	call	0x1e2c	; 0x1e2c <sync>
    4d94:	01 c0       	rjmp	.+2      	; 0x4d98 <f_utime+0x8a>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {					/* Root directory */
				res = FR_INVALID_NAME;
    4d96:	86 e0       	ldi	r24, 0x06	; 6
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
    4d98:	a4 96       	adiw	r28, 0x24	; 36
    4d9a:	0f b6       	in	r0, 0x3f	; 63
    4d9c:	f8 94       	cli
    4d9e:	de bf       	out	0x3e, r29	; 62
    4da0:	0f be       	out	0x3f, r0	; 63
    4da2:	cd bf       	out	0x3d, r28	; 61
    4da4:	df 91       	pop	r29
    4da6:	cf 91       	pop	r28
    4da8:	1f 91       	pop	r17
    4daa:	0f 91       	pop	r16
    4dac:	08 95       	ret
		res = follow_path(&dj, path);	/* Follow the file path */
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
    4dae:	eb 89       	ldd	r30, Y+19	; 0x13
    4db0:	fc 89       	ldd	r31, Y+20	; 0x14
			if (!dir) {					/* Root directory */
    4db2:	30 97       	sbiw	r30, 0x00	; 0
    4db4:	c1 f6       	brne	.-80     	; 0x4d66 <f_utime+0x58>
    4db6:	ef cf       	rjmp	.-34     	; 0x4d96 <f_utime+0x88>

00004db8 <f_rename>:

FRESULT f_rename (
	const TCHAR *path_old,	/* Pointer to the old name */
	const TCHAR *path_new	/* Pointer to the new name */
)
{
    4db8:	ef 92       	push	r14
    4dba:	ff 92       	push	r15
    4dbc:	0f 93       	push	r16
    4dbe:	1f 93       	push	r17
    4dc0:	cf 93       	push	r28
    4dc2:	df 93       	push	r29
    4dc4:	cd b7       	in	r28, 0x3d	; 61
    4dc6:	de b7       	in	r29, 0x3e	; 62
    4dc8:	cf 54       	subi	r28, 0x4F	; 79
    4dca:	d0 40       	sbci	r29, 0x00	; 0
    4dcc:	0f b6       	in	r0, 0x3f	; 63
    4dce:	f8 94       	cli
    4dd0:	de bf       	out	0x3e, r29	; 62
    4dd2:	0f be       	out	0x3f, r0	; 63
    4dd4:	cd bf       	out	0x3d, r28	; 61
    4dd6:	60 96       	adiw	r28, 0x10	; 16
    4dd8:	9f af       	sts	0x7f, r25
    4dda:	8e af       	sts	0x7e, r24
    4ddc:	60 97       	sbiw	r28, 0x10	; 16
    4dde:	8b 01       	movw	r16, r22
	BYTE buf[21], *dir;
	DWORD dw;
	DEF_NAMEBUF;


	res = chk_mounted(&path_old, &djo.fs, 1);
    4de0:	ce 01       	movw	r24, r28
    4de2:	82 5b       	subi	r24, 0xB2	; 178
    4de4:	9f 4f       	sbci	r25, 0xFF	; 255
    4de6:	be 01       	movw	r22, r28
    4de8:	6f 5f       	subi	r22, 0xFF	; 255
    4dea:	7f 4f       	sbci	r23, 0xFF	; 255
    4dec:	41 e0       	ldi	r20, 0x01	; 1
    4dee:	0e 94 41 0a 	call	0x1482	; 0x1482 <chk_mounted>
	if (res == FR_OK) {
    4df2:	88 23       	and	r24, r24
    4df4:	09 f0       	breq	.+2      	; 0x4df8 <f_rename+0x40>
    4df6:	b7 c0       	rjmp	.+366    	; 0x4f66 <f_rename+0x1ae>
		djn.fs = djo.fs;
    4df8:	89 81       	ldd	r24, Y+1	; 0x01
    4dfa:	9a 81       	ldd	r25, Y+2	; 0x02
    4dfc:	98 8f       	std	Y+24, r25	; 0x18
    4dfe:	8f 8b       	std	Y+23, r24	; 0x17
		INIT_BUF(djo);
    4e00:	ce 01       	movw	r24, r28
    4e02:	8e 5b       	subi	r24, 0xBE	; 190
    4e04:	9f 4f       	sbci	r25, 0xFF	; 255
    4e06:	9e 8b       	std	Y+22, r25	; 0x16
    4e08:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&djo, path_old);		/* Check old object */
    4e0a:	60 96       	adiw	r28, 0x10	; 16
    4e0c:	6e ad       	sts	0x6e, r22
    4e0e:	7f ad       	sts	0x6f, r23
    4e10:	60 97       	sbiw	r28, 0x10	; 16
    4e12:	ce 01       	movw	r24, r28
    4e14:	01 96       	adiw	r24, 0x01	; 1
    4e16:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <follow_path>
		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
    4e1a:	88 23       	and	r24, r24
    4e1c:	09 f0       	breq	.+2      	; 0x4e20 <f_rename+0x68>
    4e1e:	a3 c0       	rjmp	.+326    	; 0x4f66 <f_rename+0x1ae>
    4e20:	ed 89       	ldd	r30, Y+21	; 0x15
    4e22:	fe 89       	ldd	r31, Y+22	; 0x16
    4e24:	83 85       	ldd	r24, Z+11	; 0x0b
    4e26:	85 ff       	sbrs	r24, 5
    4e28:	ac c0       	rjmp	.+344    	; 0x4f82 <f_rename+0x1ca>
			res = FR_INVALID_NAME;
    4e2a:	86 e0       	ldi	r24, 0x06	; 6
    4e2c:	9c c0       	rjmp	.+312    	; 0x4f66 <f_rename+0x1ae>
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
    4e2e:	65 5f       	subi	r22, 0xF5	; 245
    4e30:	7f 4f       	sbci	r23, 0xFF	; 255
    4e32:	ce 01       	movw	r24, r28
    4e34:	8d 96       	adiw	r24, 0x2d	; 45
    4e36:	25 e1       	ldi	r18, 0x15	; 21
    4e38:	30 e0       	ldi	r19, 0x00	; 0
    4e3a:	40 e0       	ldi	r20, 0x00	; 0
    4e3c:	50 e0       	ldi	r21, 0x00	; 0
    4e3e:	0e 94 9e 08 	call	0x113c	; 0x113c <mem_cpy>
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
    4e42:	ce 01       	movw	r24, r28
    4e44:	47 96       	adiw	r24, 0x17	; 23
    4e46:	be 01       	movw	r22, r28
    4e48:	6f 5f       	subi	r22, 0xFF	; 255
    4e4a:	7f 4f       	sbci	r23, 0xFF	; 255
    4e4c:	26 e1       	ldi	r18, 0x16	; 22
    4e4e:	30 e0       	ldi	r19, 0x00	; 0
    4e50:	40 e0       	ldi	r20, 0x00	; 0
    4e52:	50 e0       	ldi	r21, 0x00	; 0
    4e54:	0e 94 9e 08 	call	0x113c	; 0x113c <mem_cpy>
				res = follow_path(&djn, path_new);
    4e58:	ce 01       	movw	r24, r28
    4e5a:	47 96       	adiw	r24, 0x17	; 23
    4e5c:	b8 01       	movw	r22, r16
    4e5e:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <follow_path>
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
    4e62:	88 23       	and	r24, r24
    4e64:	09 f4       	brne	.+2      	; 0x4e68 <f_rename+0xb0>
    4e66:	7c c0       	rjmp	.+248    	; 0x4f60 <f_rename+0x1a8>
				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
    4e68:	84 30       	cpi	r24, 0x04	; 4
    4e6a:	09 f0       	breq	.+2      	; 0x4e6e <f_rename+0xb6>
    4e6c:	7c c0       	rjmp	.+248    	; 0x4f66 <f_rename+0x1ae>
/* Start critical section that an interruption or error can cause cross-link */
					res = dir_register(&djn);			/* Register the new entry */
    4e6e:	ce 01       	movw	r24, r28
    4e70:	47 96       	adiw	r24, 0x17	; 23
    4e72:	0e 94 97 17 	call	0x2f2e	; 0x2f2e <dir_register>
					if (res == FR_OK) {
    4e76:	88 23       	and	r24, r24
    4e78:	09 f0       	breq	.+2      	; 0x4e7c <f_rename+0xc4>
    4e7a:	75 c0       	rjmp	.+234    	; 0x4f66 <f_rename+0x1ae>
						dir = djn.dir;					/* Copy object information except for name */
    4e7c:	09 a5       	lds	r16, 0x69
    4e7e:	1a a5       	lds	r17, 0x6a
						mem_cpy(dir+13, buf+2, 19);
    4e80:	c8 01       	movw	r24, r16
    4e82:	0d 96       	adiw	r24, 0x0d	; 13
    4e84:	be 01       	movw	r22, r28
    4e86:	61 5d       	subi	r22, 0xD1	; 209
    4e88:	7f 4f       	sbci	r23, 0xFF	; 255
    4e8a:	23 e1       	ldi	r18, 0x13	; 19
    4e8c:	30 e0       	ldi	r19, 0x00	; 0
    4e8e:	40 e0       	ldi	r20, 0x00	; 0
    4e90:	50 e0       	ldi	r21, 0x00	; 0
    4e92:	0e 94 9e 08 	call	0x113c	; 0x113c <mem_cpy>
						dir[DIR_Attr] = buf[0] | AM_ARC;
    4e96:	8d a5       	lds	r24, 0x6d
    4e98:	80 62       	ori	r24, 0x20	; 32
    4e9a:	f8 01       	movw	r30, r16
    4e9c:	83 87       	std	Z+11, r24	; 0x0b
						djo.fs->wflag = 1;
    4e9e:	e9 80       	ldd	r14, Y+1	; 0x01
    4ea0:	fa 80       	ldd	r15, Y+2	; 0x02
    4ea2:	81 e0       	ldi	r24, 0x01	; 1
    4ea4:	f7 01       	movw	r30, r14
    4ea6:	84 83       	std	Z+4, r24	; 0x04
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
    4ea8:	4f 81       	ldd	r20, Y+7	; 0x07
    4eaa:	58 85       	ldd	r21, Y+8	; 0x08
    4eac:	69 85       	ldd	r22, Y+9	; 0x09
    4eae:	7a 85       	ldd	r23, Y+10	; 0x0a
    4eb0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4eb2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4eb4:	af 8d       	ldd	r26, Y+31	; 0x1f
    4eb6:	b8 a1       	lds	r27, 0x48
    4eb8:	48 17       	cp	r20, r24
    4eba:	59 07       	cpc	r21, r25
    4ebc:	6a 07       	cpc	r22, r26
    4ebe:	7b 07       	cpc	r23, r27
    4ec0:	09 f4       	brne	.+2      	; 0x4ec4 <f_rename+0x10c>
    4ec2:	43 c0       	rjmp	.+134    	; 0x4f4a <f_rename+0x192>
    4ec4:	f8 01       	movw	r30, r16
    4ec6:	83 85       	ldd	r24, Z+11	; 0x0b
    4ec8:	84 ff       	sbrs	r24, 4
    4eca:	3f c0       	rjmp	.+126    	; 0x4f4a <f_rename+0x192>
							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
    4ecc:	c7 01       	movw	r24, r14
    4ece:	b8 01       	movw	r22, r16
    4ed0:	0e 94 c4 08 	call	0x1188	; 0x1188 <ld_clust>
    4ed4:	ab 01       	movw	r20, r22
    4ed6:	bc 01       	movw	r22, r24
    4ed8:	c7 01       	movw	r24, r14
    4eda:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <clust2sect>
    4ede:	ab 01       	movw	r20, r22
    4ee0:	bc 01       	movw	r22, r24
							if (!dw) {
    4ee2:	41 15       	cp	r20, r1
    4ee4:	51 05       	cpc	r21, r1
    4ee6:	61 05       	cpc	r22, r1
    4ee8:	71 05       	cpc	r23, r1
    4eea:	09 f4       	brne	.+2      	; 0x4eee <f_rename+0x136>
    4eec:	51 c0       	rjmp	.+162    	; 0x4f90 <f_rename+0x1d8>
								res = FR_INT_ERR;
							} else {
								res = move_window(djo.fs, dw);
    4eee:	c7 01       	movw	r24, r14
    4ef0:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <move_window>
								dir = djo.fs->win+SZ_DIR;	/* .. entry */
    4ef4:	e9 81       	ldd	r30, Y+1	; 0x01
    4ef6:	fa 81       	ldd	r31, Y+2	; 0x02
								if (res == FR_OK && dir[1] == '.') {
    4ef8:	88 23       	and	r24, r24
    4efa:	a9 f5       	brne	.+106    	; 0x4f66 <f_rename+0x1ae>
    4efc:	df 01       	movw	r26, r30
    4efe:	ad 5a       	subi	r26, 0xAD	; 173
    4f00:	bf 4f       	sbci	r27, 0xFF	; 255
    4f02:	8c 91       	ld	r24, X
    4f04:	8e 32       	cpi	r24, 0x2E	; 46
    4f06:	09 f5       	brne	.+66     	; 0x4f4a <f_rename+0x192>
									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
    4f08:	80 81       	ld	r24, Z
    4f0a:	83 30       	cpi	r24, 0x03	; 3
    4f0c:	69 f4       	brne	.+26     	; 0x4f28 <f_rename+0x170>
    4f0e:	4d 8d       	ldd	r20, Y+29	; 0x1d
    4f10:	5e 8d       	ldd	r21, Y+30	; 0x1e
    4f12:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4f14:	78 a1       	lds	r23, 0x48
    4f16:	86 a1       	lds	r24, 0x46
    4f18:	97 a1       	lds	r25, 0x47
    4f1a:	a0 a5       	lds	r26, 0x60
    4f1c:	b1 a5       	lds	r27, 0x61
    4f1e:	48 17       	cp	r20, r24
    4f20:	59 07       	cpc	r21, r25
    4f22:	6a 07       	cpc	r22, r26
    4f24:	7b 07       	cpc	r23, r27
    4f26:	29 f0       	breq	.+10     	; 0x4f32 <f_rename+0x17a>
    4f28:	4d 8d       	ldd	r20, Y+29	; 0x1d
    4f2a:	5e 8d       	ldd	r21, Y+30	; 0x1e
    4f2c:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4f2e:	78 a1       	lds	r23, 0x48
    4f30:	03 c0       	rjmp	.+6      	; 0x4f38 <f_rename+0x180>
    4f32:	40 e0       	ldi	r20, 0x00	; 0
    4f34:	50 e0       	ldi	r21, 0x00	; 0
    4f36:	ba 01       	movw	r22, r20
									st_clust(dir, dw);
    4f38:	cf 01       	movw	r24, r30
    4f3a:	8e 5a       	subi	r24, 0xAE	; 174
    4f3c:	9f 4f       	sbci	r25, 0xFF	; 255
    4f3e:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <st_clust>
									djo.fs->wflag = 1;
    4f42:	e9 81       	ldd	r30, Y+1	; 0x01
    4f44:	fa 81       	ldd	r31, Y+2	; 0x02
    4f46:	81 e0       	ldi	r24, 0x01	; 1
    4f48:	84 83       	std	Z+4, r24	; 0x04
								}
							}
						}
						if (res == FR_OK) {
							res = dir_remove(&djo);		/* Remove old entry */
    4f4a:	ce 01       	movw	r24, r28
    4f4c:	01 96       	adiw	r24, 0x01	; 1
    4f4e:	0e 94 da 11 	call	0x23b4	; 0x23b4 <dir_remove>
							if (res == FR_OK)
    4f52:	88 23       	and	r24, r24
    4f54:	41 f4       	brne	.+16     	; 0x4f66 <f_rename+0x1ae>
								res = sync(djo.fs);
    4f56:	89 81       	ldd	r24, Y+1	; 0x01
    4f58:	9a 81       	ldd	r25, Y+2	; 0x02
    4f5a:	0e 94 16 0f 	call	0x1e2c	; 0x1e2c <sync>
    4f5e:	03 c0       	rjmp	.+6      	; 0x4f66 <f_rename+0x1ae>
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
				res = follow_path(&djn, path_new);
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
    4f60:	88 e0       	ldi	r24, 0x08	; 8
    4f62:	01 c0       	rjmp	.+2      	; 0x4f66 <f_rename+0x1ae>
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
    4f64:	84 e0       	ldi	r24, 0x04	; 4
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(djo.fs, res);
}
    4f66:	c1 5b       	subi	r28, 0xB1	; 177
    4f68:	df 4f       	sbci	r29, 0xFF	; 255
    4f6a:	0f b6       	in	r0, 0x3f	; 63
    4f6c:	f8 94       	cli
    4f6e:	de bf       	out	0x3e, r29	; 62
    4f70:	0f be       	out	0x3f, r0	; 63
    4f72:	cd bf       	out	0x3d, r28	; 61
    4f74:	df 91       	pop	r29
    4f76:	cf 91       	pop	r28
    4f78:	1f 91       	pop	r17
    4f7a:	0f 91       	pop	r16
    4f7c:	ff 90       	pop	r15
    4f7e:	ef 90       	pop	r14
    4f80:	08 95       	ret
			res = FR_INVALID_NAME;
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
    4f82:	6b 89       	ldd	r22, Y+19	; 0x13
    4f84:	7c 89       	ldd	r23, Y+20	; 0x14
    4f86:	61 15       	cp	r22, r1
    4f88:	71 05       	cpc	r23, r1
    4f8a:	09 f0       	breq	.+2      	; 0x4f8e <f_rename+0x1d6>
    4f8c:	50 cf       	rjmp	.-352    	; 0x4e2e <f_rename+0x76>
    4f8e:	ea cf       	rjmp	.-44     	; 0x4f64 <f_rename+0x1ac>
						dir[DIR_Attr] = buf[0] | AM_ARC;
						djo.fs->wflag = 1;
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
							if (!dw) {
								res = FR_INT_ERR;
    4f90:	82 e0       	ldi	r24, 0x02	; 2
    4f92:	e9 cf       	rjmp	.-46     	; 0x4f66 <f_rename+0x1ae>

00004f94 <InitSCCB>:
Function: Initial the SCCB port in AVR
-----------------------------------------------
*/
void InitSCCB(void)
{
	SCCB_DDR|=(1<<SCCB_SIO_C)|(1<<SCCB_SIO_D);  //|(1<<FIFO_WEN)|(1<<FIFO_nRRST)|(1<<FIFO_RCLK);
    4f94:	8a b1       	in	r24, 0x0a	; 10
    4f96:	83 60       	ori	r24, 0x03	; 3
    4f98:	8a b9       	out	0x0a, r24	; 10
	SCCB_PORT|=(1<<SCCB_SIO_C)|(1<<SCCB_SIO_D);
    4f9a:	8b b1       	in	r24, 0x0b	; 11
    4f9c:	83 60       	ori	r24, 0x03	; 3
    4f9e:	8b b9       	out	0x0b, r24	; 11
}
    4fa0:	08 95       	ret

00004fa2 <startSCCB>:
Function: Generate the start phase for SCCB following the datasheet
-----------------------------------------------
*/
void startSCCB(void)
{
	SIO_D_SET;     
    4fa2:	59 9a       	sbi	0x0b, 1	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    4fa4:	8b e2       	ldi	r24, 0x2B	; 43
    4fa6:	91 e0       	ldi	r25, 0x01	; 1
    4fa8:	01 97       	sbiw	r24, 0x01	; 1
    4faa:	f1 f7       	brne	.-4      	; 0x4fa8 <startSCCB+0x6>
    4fac:	00 c0       	rjmp	.+0      	; 0x4fae <startSCCB+0xc>
    4fae:	00 00       	nop
    _delay_us(100);

    SIO_C_SET;
    4fb0:	58 9a       	sbi	0x0b, 0	; 11
    4fb2:	8b e2       	ldi	r24, 0x2B	; 43
    4fb4:	91 e0       	ldi	r25, 0x01	; 1
    4fb6:	01 97       	sbiw	r24, 0x01	; 1
    4fb8:	f1 f7       	brne	.-4      	; 0x4fb6 <startSCCB+0x14>
    4fba:	00 c0       	rjmp	.+0      	; 0x4fbc <startSCCB+0x1a>
    4fbc:	00 00       	nop
    _delay_us(100);
 
    SIO_D_CLR;
    4fbe:	59 98       	cbi	0x0b, 1	; 11
    4fc0:	8b e2       	ldi	r24, 0x2B	; 43
    4fc2:	91 e0       	ldi	r25, 0x01	; 1
    4fc4:	01 97       	sbiw	r24, 0x01	; 1
    4fc6:	f1 f7       	brne	.-4      	; 0x4fc4 <startSCCB+0x22>
    4fc8:	00 c0       	rjmp	.+0      	; 0x4fca <startSCCB+0x28>
    4fca:	00 00       	nop
    _delay_us(100);

    SIO_C_CLR;
    4fcc:	58 98       	cbi	0x0b, 0	; 11
    4fce:	8b e2       	ldi	r24, 0x2B	; 43
    4fd0:	91 e0       	ldi	r25, 0x01	; 1
    4fd2:	01 97       	sbiw	r24, 0x01	; 1
    4fd4:	f1 f7       	brne	.-4      	; 0x4fd2 <startSCCB+0x30>
    4fd6:	00 c0       	rjmp	.+0      	; 0x4fd8 <startSCCB+0x36>
    4fd8:	00 00       	nop
    _delay_us(100);


}
    4fda:	08 95       	ret

00004fdc <stopSCCB>:
Function: Generate the stop phase of SCCB following the datasheet
-----------------------------------------------
*/
void stopSCCB(void)
{
	SIO_D_CLR;
    4fdc:	59 98       	cbi	0x0b, 1	; 11
    4fde:	8b e2       	ldi	r24, 0x2B	; 43
    4fe0:	91 e0       	ldi	r25, 0x01	; 1
    4fe2:	01 97       	sbiw	r24, 0x01	; 1
    4fe4:	f1 f7       	brne	.-4      	; 0x4fe2 <stopSCCB+0x6>
    4fe6:	00 c0       	rjmp	.+0      	; 0x4fe8 <stopSCCB+0xc>
    4fe8:	00 00       	nop
    _delay_us(100);
 
    SIO_C_SET;
    4fea:	58 9a       	sbi	0x0b, 0	; 11
    4fec:	8b e2       	ldi	r24, 0x2B	; 43
    4fee:	91 e0       	ldi	r25, 0x01	; 1
    4ff0:	01 97       	sbiw	r24, 0x01	; 1
    4ff2:	f1 f7       	brne	.-4      	; 0x4ff0 <stopSCCB+0x14>
    4ff4:	00 c0       	rjmp	.+0      	; 0x4ff6 <stopSCCB+0x1a>
    4ff6:	00 00       	nop
    _delay_us(100);
  

    SIO_D_SET;
    4ff8:	59 9a       	sbi	0x0b, 1	; 11
    4ffa:	8b e2       	ldi	r24, 0x2B	; 43
    4ffc:	91 e0       	ldi	r25, 0x01	; 1
    4ffe:	01 97       	sbiw	r24, 0x01	; 1
    5000:	f1 f7       	brne	.-4      	; 0x4ffe <stopSCCB+0x22>
    5002:	00 c0       	rjmp	.+0      	; 0x5004 <stopSCCB+0x28>
    5004:	00 00       	nop
    _delay_us(100);
 //   SCCB_DDR&= ~(SCCB_SIO_D);

}
    5006:	08 95       	ret

00005008 <noAck>:
-----------------------------------------------
*/
void noAck(void)
{
	
	SIO_D_SET;
    5008:	59 9a       	sbi	0x0b, 1	; 11
    500a:	8b e2       	ldi	r24, 0x2B	; 43
    500c:	91 e0       	ldi	r25, 0x01	; 1
    500e:	01 97       	sbiw	r24, 0x01	; 1
    5010:	f1 f7       	brne	.-4      	; 0x500e <noAck+0x6>
    5012:	00 c0       	rjmp	.+0      	; 0x5014 <noAck+0xc>
    5014:	00 00       	nop
	_delay_us(100);
	
	SIO_C_SET;
    5016:	58 9a       	sbi	0x0b, 0	; 11
    5018:	8b e2       	ldi	r24, 0x2B	; 43
    501a:	91 e0       	ldi	r25, 0x01	; 1
    501c:	01 97       	sbiw	r24, 0x01	; 1
    501e:	f1 f7       	brne	.-4      	; 0x501c <noAck+0x14>
    5020:	00 c0       	rjmp	.+0      	; 0x5022 <noAck+0x1a>
    5022:	00 00       	nop
	_delay_us(100);
	
	SIO_C_CLR;
    5024:	58 98       	cbi	0x0b, 0	; 11
    5026:	8b e2       	ldi	r24, 0x2B	; 43
    5028:	91 e0       	ldi	r25, 0x01	; 1
    502a:	01 97       	sbiw	r24, 0x01	; 1
    502c:	f1 f7       	brne	.-4      	; 0x502a <noAck+0x22>
    502e:	00 c0       	rjmp	.+0      	; 0x5030 <noAck+0x28>
    5030:	00 00       	nop
	_delay_us(100);
	
	SIO_D_CLR;
    5032:	59 98       	cbi	0x0b, 1	; 11
    5034:	8b e2       	ldi	r24, 0x2B	; 43
    5036:	91 e0       	ldi	r25, 0x01	; 1
    5038:	01 97       	sbiw	r24, 0x01	; 1
    503a:	f1 f7       	brne	.-4      	; 0x5038 <noAck+0x30>
    503c:	00 c0       	rjmp	.+0      	; 0x503e <noAck+0x36>
    503e:	00 00       	nop
	_delay_us(100);

}
    5040:	08 95       	ret

00005042 <SCCBwriteByte>:
-----------------------------------------------
Function: Write one Byte data through SCCB
-----------------------------------------------
*/
unsigned char SCCBwriteByte(unsigned char m_data)
{
    5042:	20 e0       	ldi	r18, 0x00	; 0
    5044:	30 e0       	ldi	r19, 0x00	; 0
	unsigned char j,tem;

	for(j=0;j<8;j++)
	{
		if((m_data<<j)&0x80)
    5046:	90 e0       	ldi	r25, 0x00	; 0
    5048:	ac 01       	movw	r20, r24
    504a:	02 2e       	mov	r0, r18
    504c:	02 c0       	rjmp	.+4      	; 0x5052 <SCCBwriteByte+0x10>
    504e:	44 0f       	add	r20, r20
    5050:	55 1f       	adc	r21, r21
    5052:	0a 94       	dec	r0
    5054:	e2 f7       	brpl	.-8      	; 0x504e <SCCBwriteByte+0xc>
    5056:	47 ff       	sbrs	r20, 7
    5058:	02 c0       	rjmp	.+4      	; 0x505e <SCCBwriteByte+0x1c>
		{
			SIO_D_SET;
    505a:	59 9a       	sbi	0x0b, 1	; 11
    505c:	01 c0       	rjmp	.+2      	; 0x5060 <SCCBwriteByte+0x1e>
		}
		else
		{
			SIO_D_CLR;
    505e:	59 98       	cbi	0x0b, 1	; 11
    5060:	eb e2       	ldi	r30, 0x2B	; 43
    5062:	f1 e0       	ldi	r31, 0x01	; 1
    5064:	31 97       	sbiw	r30, 0x01	; 1
    5066:	f1 f7       	brne	.-4      	; 0x5064 <SCCBwriteByte+0x22>
    5068:	00 c0       	rjmp	.+0      	; 0x506a <SCCBwriteByte+0x28>
    506a:	00 00       	nop
		}
		_delay_us(100);
		SIO_C_SET;
    506c:	58 9a       	sbi	0x0b, 0	; 11
    506e:	eb e2       	ldi	r30, 0x2B	; 43
    5070:	f1 e0       	ldi	r31, 0x01	; 1
    5072:	31 97       	sbiw	r30, 0x01	; 1
    5074:	f1 f7       	brne	.-4      	; 0x5072 <SCCBwriteByte+0x30>
    5076:	00 c0       	rjmp	.+0      	; 0x5078 <SCCBwriteByte+0x36>
    5078:	00 00       	nop
		_delay_us(100);
		SIO_C_CLR;
    507a:	58 98       	cbi	0x0b, 0	; 11
    507c:	eb e2       	ldi	r30, 0x2B	; 43
    507e:	f1 e0       	ldi	r31, 0x01	; 1
    5080:	31 97       	sbiw	r30, 0x01	; 1
    5082:	f1 f7       	brne	.-4      	; 0x5080 <SCCBwriteByte+0x3e>
    5084:	00 c0       	rjmp	.+0      	; 0x5086 <SCCBwriteByte+0x44>
    5086:	00 00       	nop
    5088:	2f 5f       	subi	r18, 0xFF	; 255
    508a:	3f 4f       	sbci	r19, 0xFF	; 255
*/
unsigned char SCCBwriteByte(unsigned char m_data)
{
	unsigned char j,tem;

	for(j=0;j<8;j++)
    508c:	28 30       	cpi	r18, 0x08	; 8
    508e:	31 05       	cpc	r19, r1
    5090:	d9 f6       	brne	.-74     	; 0x5048 <SCCBwriteByte+0x6>
    5092:	8b e2       	ldi	r24, 0x2B	; 43
    5094:	91 e0       	ldi	r25, 0x01	; 1
    5096:	01 97       	sbiw	r24, 0x01	; 1
    5098:	f1 f7       	brne	.-4      	; 0x5096 <SCCBwriteByte+0x54>
    509a:	00 c0       	rjmp	.+0      	; 0x509c <SCCBwriteByte+0x5a>
    509c:	00 00       	nop
		_delay_us(100);

	}
	_delay_us(100);
	
	SIO_D_IN;	//Set SDA as input
    509e:	51 98       	cbi	0x0a, 1	; 10
    50a0:	eb e2       	ldi	r30, 0x2B	; 43
    50a2:	f1 e0       	ldi	r31, 0x01	; 1
    50a4:	31 97       	sbiw	r30, 0x01	; 1
    50a6:	f1 f7       	brne	.-4      	; 0x50a4 <SCCBwriteByte+0x62>
    50a8:	00 c0       	rjmp	.+0      	; 0x50aa <SCCBwriteByte+0x68>
    50aa:	00 00       	nop
	_delay_us(100);
	SIO_C_SET;
    50ac:	58 9a       	sbi	0x0b, 0	; 11
    50ae:	87 eb       	ldi	r24, 0xB7	; 183
    50b0:	9b e0       	ldi	r25, 0x0B	; 11
    50b2:	01 97       	sbiw	r24, 0x01	; 1
    50b4:	f1 f7       	brne	.-4      	; 0x50b2 <SCCBwriteByte+0x70>
    50b6:	00 c0       	rjmp	.+0      	; 0x50b8 <SCCBwriteByte+0x76>
    50b8:	00 00       	nop
	_delay_us(1000);
	if(SIO_D_STATE)
    50ba:	99 b1       	in	r25, 0x09	; 9
	}
	else
	{
		tem=1;   //SDA=0 send succeed, reture 1
	}
	SIO_C_CLR;
    50bc:	58 98       	cbi	0x0b, 0	; 11
    50be:	eb e2       	ldi	r30, 0x2B	; 43
    50c0:	f1 e0       	ldi	r31, 0x01	; 1
    50c2:	31 97       	sbiw	r30, 0x01	; 1
    50c4:	f1 f7       	brne	.-4      	; 0x50c2 <SCCBwriteByte+0x80>
    50c6:	00 c0       	rjmp	.+0      	; 0x50c8 <SCCBwriteByte+0x86>
    50c8:	00 00       	nop
	_delay_us(100);	
    SIO_D_OUT;	//Set SDA as output
    50ca:	51 9a       	sbi	0x0a, 1	; 10
	_delay_us(100);
	SIO_C_SET;
	_delay_us(1000);
	if(SIO_D_STATE)
	{
		tem=0;   //SDA=1 send fail, return 0
    50cc:	81 e0       	ldi	r24, 0x01	; 1
    50ce:	91 fd       	sbrc	r25, 1
    50d0:	80 e0       	ldi	r24, 0x00	; 0
	SIO_C_CLR;
	_delay_us(100);	
    SIO_D_OUT;	//Set SDA as output

	return(tem);  
}
    50d2:	08 95       	ret

000050d4 <SCCBreadByte>:
unsigned char SCCBreadByte(void)
{
	unsigned char read,j;
	read=0x00;
	
	SIO_D_IN;/*SDA*/
    50d4:	51 98       	cbi	0x0a, 1	; 10
    50d6:	8b e2       	ldi	r24, 0x2B	; 43
    50d8:	91 e0       	ldi	r25, 0x01	; 1
    50da:	01 97       	sbiw	r24, 0x01	; 1
    50dc:	f1 f7       	brne	.-4      	; 0x50da <SCCBreadByte+0x6>
    50de:	00 c0       	rjmp	.+0      	; 0x50e0 <SCCBreadByte+0xc>
    50e0:	00 00       	nop
    50e2:	98 e0       	ldi	r25, 0x08	; 8
-----------------------------------------------
*/
unsigned char SCCBreadByte(void)
{
	unsigned char read,j;
	read=0x00;
    50e4:	80 e0       	ldi	r24, 0x00	; 0
    50e6:	eb e2       	ldi	r30, 0x2B	; 43
    50e8:	f1 e0       	ldi	r31, 0x01	; 1
    50ea:	31 97       	sbiw	r30, 0x01	; 1
    50ec:	f1 f7       	brne	.-4      	; 0x50ea <SCCBreadByte+0x16>
    50ee:	00 c0       	rjmp	.+0      	; 0x50f0 <SCCBreadByte+0x1c>
    50f0:	00 00       	nop
	SIO_D_IN;/*SDA*/
	_delay_us(100);
	for(j=8;j>0;j--) //8
	{		     
		_delay_us(100);
		SIO_C_SET;
    50f2:	58 9a       	sbi	0x0b, 0	; 11
    50f4:	eb e2       	ldi	r30, 0x2B	; 43
    50f6:	f1 e0       	ldi	r31, 0x01	; 1
    50f8:	31 97       	sbiw	r30, 0x01	; 1
    50fa:	f1 f7       	brne	.-4      	; 0x50f8 <SCCBreadByte+0x24>
    50fc:	00 c0       	rjmp	.+0      	; 0x50fe <SCCBreadByte+0x2a>
    50fe:	00 00       	nop
		_delay_us(100);
		read=read<<1;
    5100:	88 0f       	add	r24, r24
		if(SIO_D_STATE) 
    5102:	49 99       	sbic	0x09, 1	; 9
		{
			read=read+1;
    5104:	8f 5f       	subi	r24, 0xFF	; 255
		}
		SIO_C_CLR;
    5106:	58 98       	cbi	0x0b, 0	; 11
    5108:	eb e2       	ldi	r30, 0x2B	; 43
    510a:	f1 e0       	ldi	r31, 0x01	; 1
    510c:	31 97       	sbiw	r30, 0x01	; 1
    510e:	f1 f7       	brne	.-4      	; 0x510c <SCCBreadByte+0x38>
    5110:	00 c0       	rjmp	.+0      	; 0x5112 <SCCBreadByte+0x3e>
    5112:	00 00       	nop
    5114:	91 50       	subi	r25, 0x01	; 1
	unsigned char read,j;
	read=0x00;
	
	SIO_D_IN;/*SDA*/
	_delay_us(100);
	for(j=8;j>0;j--) //8
    5116:	39 f7       	brne	.-50     	; 0x50e6 <SCCBreadByte+0x12>
		}
		SIO_C_CLR;
		_delay_us(100);
	}	
	return(read);
}
    5118:	08 95       	ret

0000511a <TWI_Master_Initialise>:
		DDRC = 0x00;
		PORTC = (1 << PC0) | (1 << PC1);
	#else
		#pragma message("External I2C Pull Ups Required.")
	#endif
	TWBR = TWI_TWBR;                                  // Set bit rate register (Baudrate). Defined in header file.
    511a:	84 e3       	ldi	r24, 0x34	; 52
    511c:	80 93 b8 00 	sts	0x00B8, r24
	// TWSR = TWI_TWPS;                                  // Not used. Driver presumes prescaler to be 00.
	TWDR = 0xFF;                                      // Default content = SDA released.
    5120:	8f ef       	ldi	r24, 0xFF	; 255
    5122:	80 93 bb 00 	sts	0x00BB, r24
	TWCR =	(1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
    5126:	84 e0       	ldi	r24, 0x04	; 4
    5128:	80 93 bc 00 	sts	0x00BC, r24
			(0<<TWIE)|(0<<TWINT)|                      // Disable Interupt.
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests.
			(0<<TWWC);                                 //
}    
    512c:	08 95       	ret

0000512e <TWI_Transceiver_Busy>:
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
    512e:	80 91 bc 00 	lds	r24, 0x00BC
}
    5132:	81 70       	andi	r24, 0x01	; 1
    5134:	08 95       	ret

00005136 <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
    5136:	0e 94 97 28 	call	0x512e	; 0x512e <TWI_Transceiver_Busy>
    513a:	88 23       	and	r24, r24
    513c:	e1 f7       	brne	.-8      	; 0x5136 <TWI_Get_State_Info>
  return ( TWI_state );                         // Return error state.
}
    513e:	80 91 f4 02 	lds	r24, 0x02F4
    5142:	08 95       	ret

00005144 <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
    5144:	0f 93       	push	r16
    5146:	1f 93       	push	r17
    5148:	cf 93       	push	r28
    514a:	8c 01       	movw	r16, r24
    514c:	c6 2f       	mov	r28, r22
  unsigned char temp;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    514e:	0e 94 97 28 	call	0x512e	; 0x512e <TWI_Transceiver_Busy>
    5152:	88 23       	and	r24, r24
    5154:	e1 f7       	brne	.-8      	; 0x514e <TWI_Start_Transceiver_With_Data+0xa>

  TWI_msgSize = msgSize;                        // Number of data to transmit.
    5156:	c0 93 ff 02 	sts	0x02FF, r28
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
    515a:	f8 01       	movw	r30, r16
    515c:	80 81       	ld	r24, Z
    515e:	80 93 00 03 	sts	0x0300, r24
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
    5162:	80 fd       	sbrc	r24, 0
    5164:	0c c0       	rjmp	.+24     	; 0x517e <TWI_Start_Transceiver_With_Data+0x3a>
  {
    for ( temp = 1; temp < msgSize; temp++ )
    5166:	c2 30       	cpi	r28, 0x02	; 2
    5168:	50 f0       	brcs	.+20     	; 0x517e <TWI_Start_Transceiver_With_Data+0x3a>
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    516a:	d8 01       	movw	r26, r16
    516c:	11 96       	adiw	r26, 0x01	; 1

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    516e:	e1 e0       	ldi	r30, 0x01	; 1
    5170:	f3 e0       	ldi	r31, 0x03	; 3
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    5172:	81 e0       	ldi	r24, 0x01	; 1
  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
      TWI_buf[ temp ] = msg[ temp ];
    5174:	9d 91       	ld	r25, X+
    5176:	91 93       	st	Z+, r25

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    5178:	8f 5f       	subi	r24, 0xFF	; 255
    517a:	8c 17       	cp	r24, r28
    517c:	d9 f7       	brne	.-10     	; 0x5174 <TWI_Start_Transceiver_With_Data+0x30>
      TWI_buf[ temp ] = msg[ temp ];
  }
  TWI_statusReg.all = 0;      
    517e:	10 92 fe 02 	sts	0x02FE, r1
  TWI_state         = TWI_NO_STATE ;
    5182:	88 ef       	ldi	r24, 0xF8	; 248
    5184:	80 93 f4 02 	sts	0x02F4, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    5188:	85 ea       	ldi	r24, 0xA5	; 165
    518a:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    518e:	cf 91       	pop	r28
    5190:	1f 91       	pop	r17
    5192:	0f 91       	pop	r16
    5194:	08 95       	ret

00005196 <TWI_Start_Transceiver>:
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    5196:	0e 94 97 28 	call	0x512e	; 0x512e <TWI_Transceiver_Busy>
    519a:	88 23       	and	r24, r24
    519c:	e1 f7       	brne	.-8      	; 0x5196 <TWI_Start_Transceiver>
  TWI_statusReg.all = 0;      
    519e:	10 92 fe 02 	sts	0x02FE, r1
  TWI_state         = TWI_NO_STATE ;
    51a2:	88 ef       	ldi	r24, 0xF8	; 248
    51a4:	80 93 f4 02 	sts	0x02F4, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    51a8:	85 ea       	ldi	r24, 0xA5	; 165
    51aa:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    51ae:	08 95       	ret

000051b0 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    51b0:	1f 93       	push	r17
    51b2:	cf 93       	push	r28
    51b4:	df 93       	push	r29
    51b6:	d8 2f       	mov	r29, r24
    51b8:	19 2f       	mov	r17, r25
    51ba:	c6 2f       	mov	r28, r22
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    51bc:	0e 94 97 28 	call	0x512e	; 0x512e <TWI_Transceiver_Busy>
    51c0:	88 23       	and	r24, r24
    51c2:	e1 f7       	brne	.-8      	; 0x51bc <TWI_Get_Data_From_Transceiver+0xc>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    51c4:	80 91 fe 02 	lds	r24, 0x02FE
    51c8:	80 ff       	sbrs	r24, 0
    51ca:	0d c0       	rjmp	.+26     	; 0x51e6 <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    51cc:	cc 23       	and	r28, r28
    51ce:	59 f0       	breq	.+22     	; 0x51e6 <TWI_Get_Data_From_Transceiver+0x36>
    51d0:	a0 e0       	ldi	r26, 0x00	; 0
    51d2:	b3 e0       	ldi	r27, 0x03	; 3
    51d4:	9d 2f       	mov	r25, r29
    51d6:	ed 2f       	mov	r30, r29
    51d8:	f1 2f       	mov	r31, r17
    {
      msg[ i ] = TWI_buf[ i ];
    51da:	8d 91       	ld	r24, X+
    51dc:	81 93       	st	Z+, r24

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    51de:	8e 2f       	mov	r24, r30
    51e0:	89 1b       	sub	r24, r25
    51e2:	8c 17       	cp	r24, r28
    51e4:	d0 f3       	brcs	.-12     	; 0x51da <TWI_Get_Data_From_Transceiver+0x2a>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    51e6:	80 91 fe 02 	lds	r24, 0x02FE
}
    51ea:	81 70       	andi	r24, 0x01	; 1
    51ec:	df 91       	pop	r29
    51ee:	cf 91       	pop	r28
    51f0:	1f 91       	pop	r17
    51f2:	08 95       	ret

000051f4 <__vector_26>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/

ISR(TWI_vect)
{
    51f4:	1f 92       	push	r1
    51f6:	0f 92       	push	r0
    51f8:	0f b6       	in	r0, 0x3f	; 63
    51fa:	0f 92       	push	r0
    51fc:	11 24       	eor	r1, r1
    51fe:	2f 93       	push	r18
    5200:	3f 93       	push	r19
    5202:	8f 93       	push	r24
    5204:	9f 93       	push	r25
    5206:	ef 93       	push	r30
    5208:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    520a:	80 91 b9 00 	lds	r24, 0x00B9
    520e:	88 32       	cpi	r24, 0x28	; 40
    5210:	d1 f0       	breq	.+52     	; 0x5246 <__vector_26+0x52>
    5212:	89 32       	cpi	r24, 0x29	; 41
    5214:	40 f4       	brcc	.+16     	; 0x5226 <__vector_26+0x32>
    5216:	80 31       	cpi	r24, 0x10	; 16
    5218:	a1 f0       	breq	.+40     	; 0x5242 <__vector_26+0x4e>
    521a:	88 31       	cpi	r24, 0x18	; 24
    521c:	a1 f0       	breq	.+40     	; 0x5246 <__vector_26+0x52>
    521e:	88 30       	cpi	r24, 0x08	; 8
    5220:	09 f0       	breq	.+2      	; 0x5224 <__vector_26+0x30>
    5222:	61 c0       	rjmp	.+194    	; 0x52e6 <__vector_26+0xf2>
    5224:	0e c0       	rjmp	.+28     	; 0x5242 <__vector_26+0x4e>
    5226:	80 34       	cpi	r24, 0x40	; 64
    5228:	b9 f1       	breq	.+110    	; 0x5298 <__vector_26+0xa4>
    522a:	81 34       	cpi	r24, 0x41	; 65
    522c:	20 f4       	brcc	.+8      	; 0x5236 <__vector_26+0x42>
    522e:	88 33       	cpi	r24, 0x38	; 56
    5230:	09 f0       	breq	.+2      	; 0x5234 <__vector_26+0x40>
    5232:	59 c0       	rjmp	.+178    	; 0x52e6 <__vector_26+0xf2>
    5234:	54 c0       	rjmp	.+168    	; 0x52de <__vector_26+0xea>
    5236:	80 35       	cpi	r24, 0x50	; 80
    5238:	19 f1       	breq	.+70     	; 0x5280 <__vector_26+0x8c>
    523a:	88 35       	cpi	r24, 0x58	; 88
    523c:	09 f0       	breq	.+2      	; 0x5240 <__vector_26+0x4c>
    523e:	53 c0       	rjmp	.+166    	; 0x52e6 <__vector_26+0xf2>
    5240:	3d c0       	rjmp	.+122    	; 0x52bc <__vector_26+0xc8>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    5242:	10 92 04 03 	sts	0x0304, r1
    case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    5246:	80 91 04 03 	lds	r24, 0x0304
    524a:	90 91 ff 02 	lds	r25, 0x02FF
    524e:	89 17       	cp	r24, r25
    5250:	70 f4       	brcc	.+28     	; 0x526e <__vector_26+0x7a>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    5252:	e8 2f       	mov	r30, r24
    5254:	f0 e0       	ldi	r31, 0x00	; 0
    5256:	e0 50       	subi	r30, 0x00	; 0
    5258:	fd 4f       	sbci	r31, 0xFD	; 253
    525a:	90 81       	ld	r25, Z
    525c:	90 93 bb 00 	sts	0x00BB, r25
    5260:	8f 5f       	subi	r24, 0xFF	; 255
    5262:	80 93 04 03 	sts	0x0304, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    5266:	85 e8       	ldi	r24, 0x85	; 133
    5268:	80 93 bc 00 	sts	0x00BC, r24
    526c:	43 c0       	rjmp	.+134    	; 0x52f4 <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    526e:	80 91 fe 02 	lds	r24, 0x02FE
    5272:	81 60       	ori	r24, 0x01	; 1
    5274:	80 93 fe 02 	sts	0x02FE, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    5278:	84 e9       	ldi	r24, 0x94	; 148
    527a:	80 93 bc 00 	sts	0x00BC, r24
    527e:	3a c0       	rjmp	.+116    	; 0x52f4 <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    5280:	80 91 04 03 	lds	r24, 0x0304
    5284:	90 91 bb 00 	lds	r25, 0x00BB
    5288:	e8 2f       	mov	r30, r24
    528a:	f0 e0       	ldi	r31, 0x00	; 0
    528c:	e0 50       	subi	r30, 0x00	; 0
    528e:	fd 4f       	sbci	r31, 0xFD	; 253
    5290:	90 83       	st	Z, r25
    5292:	8f 5f       	subi	r24, 0xFF	; 255
    5294:	80 93 04 03 	sts	0x0304, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    5298:	20 91 04 03 	lds	r18, 0x0304
    529c:	30 e0       	ldi	r19, 0x00	; 0
    529e:	80 91 ff 02 	lds	r24, 0x02FF
    52a2:	90 e0       	ldi	r25, 0x00	; 0
    52a4:	01 97       	sbiw	r24, 0x01	; 1
    52a6:	28 17       	cp	r18, r24
    52a8:	39 07       	cpc	r19, r25
    52aa:	24 f4       	brge	.+8      	; 0x52b4 <__vector_26+0xc0>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    52ac:	85 ec       	ldi	r24, 0xC5	; 197
    52ae:	80 93 bc 00 	sts	0x00BC, r24
    52b2:	20 c0       	rjmp	.+64     	; 0x52f4 <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    52b4:	85 e8       	ldi	r24, 0x85	; 133
    52b6:	80 93 bc 00 	sts	0x00BC, r24
    52ba:	1c c0       	rjmp	.+56     	; 0x52f4 <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    52bc:	80 91 bb 00 	lds	r24, 0x00BB
    52c0:	e0 91 04 03 	lds	r30, 0x0304
    52c4:	f0 e0       	ldi	r31, 0x00	; 0
    52c6:	e0 50       	subi	r30, 0x00	; 0
    52c8:	fd 4f       	sbci	r31, 0xFD	; 253
    52ca:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    52cc:	80 91 fe 02 	lds	r24, 0x02FE
    52d0:	81 60       	ori	r24, 0x01	; 1
    52d2:	80 93 fe 02 	sts	0x02FE, r24
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    52d6:	84 e9       	ldi	r24, 0x94	; 148
    52d8:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    52dc:	0b c0       	rjmp	.+22     	; 0x52f4 <__vector_26+0x100>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    52de:	85 ea       	ldi	r24, 0xA5	; 165
    52e0:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    52e4:	07 c0       	rjmp	.+14     	; 0x52f4 <__vector_26+0x100>
    case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
//    case TWI_NO_STATE              // No relevant state information available; TWINT = 0
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    52e6:	80 91 b9 00 	lds	r24, 0x00B9
    52ea:	80 93 f4 02 	sts	0x02F4, r24
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    52ee:	84 e0       	ldi	r24, 0x04	; 4
    52f0:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    52f4:	ff 91       	pop	r31
    52f6:	ef 91       	pop	r30
    52f8:	9f 91       	pop	r25
    52fa:	8f 91       	pop	r24
    52fc:	3f 91       	pop	r19
    52fe:	2f 91       	pop	r18
    5300:	0f 90       	pop	r0
    5302:	0f be       	out	0x3f, r0	; 63
    5304:	0f 90       	pop	r0
    5306:	1f 90       	pop	r1
    5308:	18 95       	reti

0000530a <USART0_Init>:

void USART0_Init()
{
	uint16_t ubrr = UBBR;
	//Set baud rate
	UBRR0H = (unsigned char)(ubrr >>8);
    530a:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (unsigned char)ubrr ;
    530e:	8c e0       	ldi	r24, 0x0C	; 12
    5310:	80 93 c4 00 	sts	0x00C4, r24
	//Enable receiver and transmitter
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    5314:	88 e1       	ldi	r24, 0x18	; 24
    5316:	80 93 c1 00 	sts	0x00C1, r24
	
	UCSR0C = 0x06; //set asynchronous, no parity, one stop bit, 8 bit transfer.
    531a:	86 e0       	ldi	r24, 0x06	; 6
    531c:	80 93 c2 00 	sts	0x00C2, r24
	
	//UCSR0B |= (1 << RXCIE0) | (1 << TXCIE0); //set RX and TX interrupt on
}
    5320:	08 95       	ret

00005322 <Usart_SendChar>:
void Usart_SendChar(char data) 
{
    // Wait for empty transmit buffer
    while ( !(UCSR0A & (1 << UDRE0)) );
    5322:	e0 ec       	ldi	r30, 0xC0	; 192
    5324:	f0 e0       	ldi	r31, 0x00	; 0
    5326:	90 81       	ld	r25, Z
    5328:	95 ff       	sbrs	r25, 5
    532a:	fd cf       	rjmp	.-6      	; 0x5326 <Usart_SendChar+0x4>
    // Start transmission
    UDR0 = data; 
    532c:	80 93 c6 00 	sts	0x00C6, r24
}
    5330:	08 95       	ret

00005332 <Usart_Receive>:
unsigned char Usart_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
    5332:	e0 ec       	ldi	r30, 0xC0	; 192
    5334:	f0 e0       	ldi	r31, 0x00	; 0
    5336:	80 81       	ld	r24, Z
    5338:	88 23       	and	r24, r24
    533a:	ec f7       	brge	.-6      	; 0x5336 <Usart_Receive+0x4>
	;
	/* Get and return received data from buffer */
	//Usart_SendChar(UDR0);
	return UDR0;
    533c:	80 91 c6 00 	lds	r24, 0x00C6
}
    5340:	08 95       	ret

00005342 <Usart_printf>:
//to use this copy the following as a global- 
//		static FILE mystdout = FDEV_SETUP_STREAM(Usart_printf, NULL, _FDEV_SETUP_WRITE);
// and add this line at the beginning of main:
//		stdout = &mystdout;
//	stdio.h must be used.
int Usart_printf(char var, FILE *stream) {
    5342:	cf 93       	push	r28
    5344:	c8 2f       	mov	r28, r24
    // translate \n to \r for br@y++ terminal
    if (var == '\n') Usart_SendChar('\r');
    5346:	8a 30       	cpi	r24, 0x0A	; 10
    5348:	19 f4       	brne	.+6      	; 0x5350 <Usart_printf+0xe>
    534a:	8d e0       	ldi	r24, 0x0D	; 13
    534c:	0e 94 91 29 	call	0x5322	; 0x5322 <Usart_SendChar>
    Usart_SendChar(var);
    5350:	8c 2f       	mov	r24, r28
    5352:	0e 94 91 29 	call	0x5322	; 0x5322 <Usart_SendChar>
    return 0;
}
    5356:	80 e0       	ldi	r24, 0x00	; 0
    5358:	90 e0       	ldi	r25, 0x00	; 0
    535a:	cf 91       	pop	r28
    535c:	08 95       	ret

0000535e <Usart_get_line>:

void Usart_get_line (char *buff, int len)
{
    535e:	ef 92       	push	r14
    5360:	ff 92       	push	r15
    5362:	0f 93       	push	r16
    5364:	1f 93       	push	r17
    5366:	cf 93       	push	r28
    5368:	df 93       	push	r29
    536a:	7c 01       	movw	r14, r24
	cli();
    536c:	f8 94       	cli
	char c;
	int i = 0;
    536e:	c0 e0       	ldi	r28, 0x00	; 0
    5370:	d0 e0       	ldi	r29, 0x00	; 0
		if ((c == '\b') && i) {
			i--;
			Usart_SendChar(c);
			continue;
		}
		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    5372:	8b 01       	movw	r16, r22
    5374:	01 50       	subi	r16, 0x01	; 1
    5376:	10 40       	sbci	r17, 0x00	; 0
	char c;
	int i = 0;


	for (;;) {
		c = Usart_Receive();
    5378:	0e 94 99 29 	call	0x5332	; 0x5332 <Usart_Receive>
		if (c == '\r') break;
    537c:	8d 30       	cpi	r24, 0x0D	; 13
    537e:	a9 f0       	breq	.+42     	; 0x53aa <Usart_get_line+0x4c>
		if ((c == '\b') && i) {
    5380:	88 30       	cpi	r24, 0x08	; 8
    5382:	31 f4       	brne	.+12     	; 0x5390 <Usart_get_line+0x32>
    5384:	20 97       	sbiw	r28, 0x00	; 0
    5386:	c1 f3       	breq	.-16     	; 0x5378 <Usart_get_line+0x1a>
			i--;
    5388:	21 97       	sbiw	r28, 0x01	; 1
			Usart_SendChar(c);
    538a:	0e 94 91 29 	call	0x5322	; 0x5322 <Usart_SendChar>
			continue;
    538e:	f4 cf       	rjmp	.-24     	; 0x5378 <Usart_get_line+0x1a>
		}
		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    5390:	80 32       	cpi	r24, 0x20	; 32
    5392:	90 f3       	brcs	.-28     	; 0x5378 <Usart_get_line+0x1a>
    5394:	c0 17       	cp	r28, r16
    5396:	d1 07       	cpc	r29, r17
    5398:	7c f7       	brge	.-34     	; 0x5378 <Usart_get_line+0x1a>
			buff[i++] = c;
    539a:	f7 01       	movw	r30, r14
    539c:	ec 0f       	add	r30, r28
    539e:	fd 1f       	adc	r31, r29
    53a0:	80 83       	st	Z, r24
    53a2:	21 96       	adiw	r28, 0x01	; 1
			Usart_SendChar(c);
    53a4:	0e 94 91 29 	call	0x5322	; 0x5322 <Usart_SendChar>
    53a8:	e7 cf       	rjmp	.-50     	; 0x5378 <Usart_get_line+0x1a>
		}
	}
	buff[i] = 0;
    53aa:	ce 0d       	add	r28, r14
    53ac:	df 1d       	adc	r29, r15
    53ae:	18 82       	st	Y, r1
	Usart_SendChar('\n');
    53b0:	8a e0       	ldi	r24, 0x0A	; 10
    53b2:	0e 94 91 29 	call	0x5322	; 0x5322 <Usart_SendChar>
	sei();
    53b6:	78 94       	sei
}
    53b8:	df 91       	pop	r29
    53ba:	cf 91       	pop	r28
    53bc:	1f 91       	pop	r17
    53be:	0f 91       	pop	r16
    53c0:	ff 90       	pop	r15
    53c2:	ef 90       	pop	r14
    53c4:	08 95       	ret

000053c6 <USART0_Senduint16>:
void USART0_Senduint16 (uint16_t Data)
{
    53c6:	cf 93       	push	r28
    53c8:	c8 2f       	mov	r28, r24
	Usart_SendChar(Data >> 8);
    53ca:	89 2f       	mov	r24, r25
    53cc:	0e 94 91 29 	call	0x5322	; 0x5322 <Usart_SendChar>
	Usart_SendChar(Data & 0xFF);
    53d0:	8c 2f       	mov	r24, r28
    53d2:	0e 94 91 29 	call	0x5322	; 0x5322 <Usart_SendChar>
    53d6:	cf 91       	pop	r28
    53d8:	08 95       	ret

000053da <__mulsi3>:
    53da:	62 9f       	mul	r22, r18
    53dc:	d0 01       	movw	r26, r0
    53de:	73 9f       	mul	r23, r19
    53e0:	f0 01       	movw	r30, r0
    53e2:	82 9f       	mul	r24, r18
    53e4:	e0 0d       	add	r30, r0
    53e6:	f1 1d       	adc	r31, r1
    53e8:	64 9f       	mul	r22, r20
    53ea:	e0 0d       	add	r30, r0
    53ec:	f1 1d       	adc	r31, r1
    53ee:	92 9f       	mul	r25, r18
    53f0:	f0 0d       	add	r31, r0
    53f2:	83 9f       	mul	r24, r19
    53f4:	f0 0d       	add	r31, r0
    53f6:	74 9f       	mul	r23, r20
    53f8:	f0 0d       	add	r31, r0
    53fa:	65 9f       	mul	r22, r21
    53fc:	f0 0d       	add	r31, r0
    53fe:	99 27       	eor	r25, r25
    5400:	72 9f       	mul	r23, r18
    5402:	b0 0d       	add	r27, r0
    5404:	e1 1d       	adc	r30, r1
    5406:	f9 1f       	adc	r31, r25
    5408:	63 9f       	mul	r22, r19
    540a:	b0 0d       	add	r27, r0
    540c:	e1 1d       	adc	r30, r1
    540e:	f9 1f       	adc	r31, r25
    5410:	bd 01       	movw	r22, r26
    5412:	cf 01       	movw	r24, r30
    5414:	11 24       	eor	r1, r1
    5416:	08 95       	ret

00005418 <__udivmodsi4>:
    5418:	a1 e2       	ldi	r26, 0x21	; 33
    541a:	1a 2e       	mov	r1, r26
    541c:	aa 1b       	sub	r26, r26
    541e:	bb 1b       	sub	r27, r27
    5420:	fd 01       	movw	r30, r26
    5422:	0d c0       	rjmp	.+26     	; 0x543e <__udivmodsi4_ep>

00005424 <__udivmodsi4_loop>:
    5424:	aa 1f       	adc	r26, r26
    5426:	bb 1f       	adc	r27, r27
    5428:	ee 1f       	adc	r30, r30
    542a:	ff 1f       	adc	r31, r31
    542c:	a2 17       	cp	r26, r18
    542e:	b3 07       	cpc	r27, r19
    5430:	e4 07       	cpc	r30, r20
    5432:	f5 07       	cpc	r31, r21
    5434:	20 f0       	brcs	.+8      	; 0x543e <__udivmodsi4_ep>
    5436:	a2 1b       	sub	r26, r18
    5438:	b3 0b       	sbc	r27, r19
    543a:	e4 0b       	sbc	r30, r20
    543c:	f5 0b       	sbc	r31, r21

0000543e <__udivmodsi4_ep>:
    543e:	66 1f       	adc	r22, r22
    5440:	77 1f       	adc	r23, r23
    5442:	88 1f       	adc	r24, r24
    5444:	99 1f       	adc	r25, r25
    5446:	1a 94       	dec	r1
    5448:	69 f7       	brne	.-38     	; 0x5424 <__udivmodsi4_loop>
    544a:	60 95       	com	r22
    544c:	70 95       	com	r23
    544e:	80 95       	com	r24
    5450:	90 95       	com	r25
    5452:	9b 01       	movw	r18, r22
    5454:	ac 01       	movw	r20, r24
    5456:	bd 01       	movw	r22, r26
    5458:	cf 01       	movw	r24, r30
    545a:	08 95       	ret

0000545c <puts>:
    545c:	0f 93       	push	r16
    545e:	1f 93       	push	r17
    5460:	cf 93       	push	r28
    5462:	df 93       	push	r29
    5464:	8c 01       	movw	r16, r24
    5466:	e0 91 92 0d 	lds	r30, 0x0D92
    546a:	f0 91 93 0d 	lds	r31, 0x0D93
    546e:	83 81       	ldd	r24, Z+3	; 0x03
    5470:	81 ff       	sbrs	r24, 1
    5472:	1a c0       	rjmp	.+52     	; 0x54a8 <puts+0x4c>
    5474:	c0 e0       	ldi	r28, 0x00	; 0
    5476:	d0 e0       	ldi	r29, 0x00	; 0
    5478:	05 c0       	rjmp	.+10     	; 0x5484 <puts+0x28>
    547a:	09 95       	icall
    547c:	00 97       	sbiw	r24, 0x00	; 0
    547e:	11 f0       	breq	.+4      	; 0x5484 <puts+0x28>
    5480:	cf ef       	ldi	r28, 0xFF	; 255
    5482:	df ef       	ldi	r29, 0xFF	; 255
    5484:	f8 01       	movw	r30, r16
    5486:	81 91       	ld	r24, Z+
    5488:	8f 01       	movw	r16, r30
    548a:	60 91 92 0d 	lds	r22, 0x0D92
    548e:	70 91 93 0d 	lds	r23, 0x0D93
    5492:	db 01       	movw	r26, r22
    5494:	18 96       	adiw	r26, 0x08	; 8
    5496:	ed 91       	ld	r30, X+
    5498:	fc 91       	ld	r31, X
    549a:	19 97       	sbiw	r26, 0x09	; 9
    549c:	88 23       	and	r24, r24
    549e:	69 f7       	brne	.-38     	; 0x547a <puts+0x1e>
    54a0:	8a e0       	ldi	r24, 0x0A	; 10
    54a2:	09 95       	icall
    54a4:	00 97       	sbiw	r24, 0x00	; 0
    54a6:	11 f0       	breq	.+4      	; 0x54ac <puts+0x50>
    54a8:	cf ef       	ldi	r28, 0xFF	; 255
    54aa:	df ef       	ldi	r29, 0xFF	; 255
    54ac:	ce 01       	movw	r24, r28
    54ae:	df 91       	pop	r29
    54b0:	cf 91       	pop	r28
    54b2:	1f 91       	pop	r17
    54b4:	0f 91       	pop	r16
    54b6:	08 95       	ret

000054b8 <_exit>:
    54b8:	f8 94       	cli

000054ba <__stop_program>:
    54ba:	ff cf       	rjmp	.-2      	; 0x54ba <__stop_program>
