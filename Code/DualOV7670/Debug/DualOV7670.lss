
DualOV7670.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000320  00800100  00005c80  00005d14  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005c80  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000ac2  00800420  00800420  00006034  2**0
                  ALLOC
  3 .stab         00000c84  00000000  00000000  00006034  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001b6  00000000  00000000  00006cb8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000260  00000000  00000000  00006e70  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000053ed  00000000  00000000  000070d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000142f  00000000  00000000  0000c4bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000020ad  00000000  00000000  0000d8ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000010e8  00000000  00000000  0000f99c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000bab  00000000  00000000  00010a84  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006b0d  00000000  00000000  0001162f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000138  00000000  00000000  0001813c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 82 05 	jmp	0xb04	; 0xb04 <__vector_1>
       8:	0c 94 ad 05 	jmp	0xb5a	; 0xb5a <__vector_2>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 c5 07 	jmp	0xf8a	; 0xf8a <__vector_16>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 33 2a 	jmp	0x5466	; 0x5466 <__vector_26>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d0 e1       	ldi	r29, 0x10	; 16
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	14 e0       	ldi	r17, 0x04	; 4
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	e0 e8       	ldi	r30, 0x80	; 128
      90:	fc e5       	ldi	r31, 0x5C	; 92
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	a0 32       	cpi	r26, 0x20	; 32
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	1e e0       	ldi	r17, 0x0E	; 14
      a0:	a0 e2       	ldi	r26, 0x20	; 32
      a2:	b4 e0       	ldi	r27, 0x04	; 4
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	a2 3e       	cpi	r26, 0xE2	; 226
      aa:	b1 07       	cpc	r27, r17
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <main>
      b2:	0c 94 3e 2e 	jmp	0x5c7c	; 0x5c7c <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <WriteBMPHeader>:
										};



FRESULT WriteBMPHeader(FIL *File)
{
      ba:	0f 93       	push	r16
      bc:	1f 93       	push	r17
      be:	cf 93       	push	r28
      c0:	df 93       	push	r29
      c2:	00 d0       	rcall	.+0      	; 0xc4 <WriteBMPHeader+0xa>
      c4:	00 d0       	rcall	.+0      	; 0xc6 <WriteBMPHeader+0xc>
      c6:	cd b7       	in	r28, 0x3d	; 61
      c8:	de b7       	in	r29, 0x3e	; 62
      ca:	8c 01       	movw	r16, r24
	uint32_t p;
	FRESULT f; 
	
	f_lseek(File, 0);
      cc:	40 e0       	ldi	r20, 0x00	; 0
      ce:	50 e0       	ldi	r21, 0x00	; 0
      d0:	ba 01       	movw	r22, r20
      d2:	0e 94 df 20 	call	0x41be	; 0x41be <f_lseek>
	f = f_write(File, BMPHeader, BMPHEADERSIZE, &p);
      d6:	c8 01       	movw	r24, r16
      d8:	60 e0       	ldi	r22, 0x00	; 0
      da:	71 e0       	ldi	r23, 0x01	; 1
      dc:	2e e0       	ldi	r18, 0x0E	; 14
      de:	30 e0       	ldi	r19, 0x00	; 0
      e0:	40 e0       	ldi	r20, 0x00	; 0
      e2:	50 e0       	ldi	r21, 0x00	; 0
      e4:	8e 01       	movw	r16, r28
      e6:	0f 5f       	subi	r16, 0xFF	; 255
      e8:	1f 4f       	sbci	r17, 0xFF	; 255
      ea:	0e 94 ba 1d 	call	0x3b74	; 0x3b74 <f_write>
	
	return f;
}
      ee:	0f 90       	pop	r0
      f0:	0f 90       	pop	r0
      f2:	0f 90       	pop	r0
      f4:	0f 90       	pop	r0
      f6:	df 91       	pop	r29
      f8:	cf 91       	pop	r28
      fa:	1f 91       	pop	r17
      fc:	0f 91       	pop	r16
      fe:	08 95       	ret

00000100 <WriteDIBHeader>:

FRESULT WriteDIBHeader(FIL *File)
{
     100:	0f 93       	push	r16
     102:	1f 93       	push	r17
     104:	cf 93       	push	r28
     106:	df 93       	push	r29
     108:	00 d0       	rcall	.+0      	; 0x10a <WriteDIBHeader+0xa>
     10a:	00 d0       	rcall	.+0      	; 0x10c <WriteDIBHeader+0xc>
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
     110:	8c 01       	movw	r16, r24
	uint32_t p;
	FRESULT f;
	
	f_lseek(File, BMPHEADERSIZE);//place just after the bitmap header
     112:	4e e0       	ldi	r20, 0x0E	; 14
     114:	50 e0       	ldi	r21, 0x00	; 0
     116:	60 e0       	ldi	r22, 0x00	; 0
     118:	70 e0       	ldi	r23, 0x00	; 0
     11a:	0e 94 df 20 	call	0x41be	; 0x41be <f_lseek>
	f = f_write(File, DIBHead, DIBHEADERSIZE, &p);
     11e:	c8 01       	movw	r24, r16
     120:	6e e0       	ldi	r22, 0x0E	; 14
     122:	71 e0       	ldi	r23, 0x01	; 1
     124:	2c e7       	ldi	r18, 0x7C	; 124
     126:	30 e0       	ldi	r19, 0x00	; 0
     128:	40 e0       	ldi	r20, 0x00	; 0
     12a:	50 e0       	ldi	r21, 0x00	; 0
     12c:	8e 01       	movw	r16, r28
     12e:	0f 5f       	subi	r16, 0xFF	; 255
     130:	1f 4f       	sbci	r17, 0xFF	; 255
     132:	0e 94 ba 1d 	call	0x3b74	; 0x3b74 <f_write>
	return f;
}
     136:	0f 90       	pop	r0
     138:	0f 90       	pop	r0
     13a:	0f 90       	pop	r0
     13c:	0f 90       	pop	r0
     13e:	df 91       	pop	r29
     140:	cf 91       	pop	r28
     142:	1f 91       	pop	r17
     144:	0f 91       	pop	r16
     146:	08 95       	ret

00000148 <IO_Init>:
#include "Config.h"
#include <avr/io.h>
void IO_Init(void)
{
	//initialise timer 0 to interrupt every 10 ms
	TIMSK0 |= (1 << OCIE0A);
     148:	ee e6       	ldi	r30, 0x6E	; 110
     14a:	f0 e0       	ldi	r31, 0x00	; 0
     14c:	80 81       	ld	r24, Z
     14e:	82 60       	ori	r24, 0x02	; 2
     150:	80 83       	st	Z, r24
	TCCR0A |= (1 << WGM01);
     152:	84 b5       	in	r24, 0x24	; 36
     154:	82 60       	ori	r24, 0x02	; 2
     156:	84 bd       	out	0x24, r24	; 36
	OCR0A = 117; //10ms interrupt at 12MHz
     158:	85 e7       	ldi	r24, 0x75	; 117
     15a:	87 bd       	out	0x27, r24	; 39
	TCCR0B |= (1 << CS02) | (1 << CS00);
     15c:	85 b5       	in	r24, 0x25	; 37
     15e:	85 60       	ori	r24, 0x05	; 5
     160:	85 bd       	out	0x25, r24	; 37
	
	
	DDRA = 0x00;
     162:	11 b8       	out	0x01, r1	; 1
	//PORTB = 0xBF;
	DDRC = 0xFC;
     164:	8c ef       	ldi	r24, 0xFC	; 252
     166:	87 b9       	out	0x07, r24	; 7
	DDRD = 0xF2;
     168:	82 ef       	ldi	r24, 0xF2	; 242
     16a:	8a b9       	out	0x0a, r24	; 10
	
	
	
	//set int0 and int1 to trigger on falling edge
	EIMSK = (1 << INT0) | (1 << INT1);				//Enable INT0 and INT1
     16c:	83 e0       	ldi	r24, 0x03	; 3
     16e:	8d bb       	out	0x1d, r24	; 29
	EICRA = (1 << ISC01) | (1 << ISC11);			//Trigger INT0 and INT1 on the falling edge
     170:	8a e0       	ldi	r24, 0x0A	; 10
     172:	80 93 69 00 	sts	0x0069, r24
     176:	08 95       	ret

00000178 <power_off>:
}

static
void power_off (void)
{
	SPCR = 0;				/* Disable SPI function */
     178:	1c bc       	out	0x2c, r1	; 44
// 	DDRB  &= ~0b00110111;	/* Set SCK/MOSI/CS as hi-z, INS#/WP as pull-up */
// 	PORTB &= ~0b00000111;
// 	PORTB |=  0b00110000;


	PORTB = ~0b00010000;      // SS high
     17a:	8f ee       	ldi	r24, 0xEF	; 239
     17c:	85 b9       	out	0x05, r24	; 5
	DDRB =  ~(uint8_t)0b10110000;      // !SS,SCK and MOSI outputs
     17e:	8f e4       	ldi	r24, 0x4F	; 79
     180:	84 b9       	out	0x04, r24	; 4
// 	{	/* Remove this block if no socket power control */
// 		PORTE |= _BV(7);		/* Socket power off (PE7=high) */
// 		for (Timer1 = 20; Timer1; );	/* Wait for 20ms */
// 	}
}
     182:	08 95       	ret

00000184 <xchg_spi>:
static
BYTE xchg_spi (		/* Returns received data */
	BYTE dat		/* Data to be sent */
)
{
	SPDR = dat;
     184:	8e bd       	out	0x2e, r24	; 46
	loop_until_bit_is_set(SPSR, SPIF);
     186:	0d b4       	in	r0, 0x2d	; 45
     188:	07 fe       	sbrs	r0, 7
     18a:	fd cf       	rjmp	.-6      	; 0x186 <xchg_spi+0x2>
	return SPDR;
     18c:	8e b5       	in	r24, 0x2e	; 46
}
     18e:	08 95       	ret

00000190 <wait_ready>:
int wait_ready (void)	/* 1:OK, 0:Timeout */
{
	BYTE d;


	Timer2 = 50;	/* Wait for ready in timeout of 500ms */
     190:	82 e3       	ldi	r24, 0x32	; 50
     192:	80 93 20 04 	sts	0x0420, r24
	do
		d = xchg_spi(0xFF);
     196:	8f ef       	ldi	r24, 0xFF	; 255
     198:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	while (d != 0xFF && Timer2);
     19c:	8f 3f       	cpi	r24, 0xFF	; 255
     19e:	21 f0       	breq	.+8      	; 0x1a8 <wait_ready+0x18>
     1a0:	90 91 20 04 	lds	r25, 0x0420
     1a4:	99 23       	and	r25, r25
     1a6:	b9 f7       	brne	.-18     	; 0x196 <wait_ready+0x6>

	return (d == 0xFF) ? 1 : 0;
     1a8:	21 e0       	ldi	r18, 0x01	; 1
     1aa:	30 e0       	ldi	r19, 0x00	; 0
     1ac:	8f 3f       	cpi	r24, 0xFF	; 255
     1ae:	11 f0       	breq	.+4      	; 0x1b4 <wait_ready+0x24>
     1b0:	20 e0       	ldi	r18, 0x00	; 0
     1b2:	30 e0       	ldi	r19, 0x00	; 0
}
     1b4:	82 2f       	mov	r24, r18
     1b6:	93 2f       	mov	r25, r19
     1b8:	08 95       	ret

000001ba <deselect>:
/*-----------------------------------------------------------------------*/

static
void deselect (void)
{
	CS_HIGH();
     1ba:	2c 9a       	sbi	0x05, 4	; 5
	xchg_spi(0xFF);	/* Dummy clock (force DO hi-z for multiple slave SPI) */
     1bc:	8f ef       	ldi	r24, 0xFF	; 255
     1be:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
}
     1c2:	08 95       	ret

000001c4 <select>:
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:Successful, 0:Timeout */
{
	CS_LOW();
     1c4:	2c 98       	cbi	0x05, 4	; 5
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */
     1c6:	8f ef       	ldi	r24, 0xFF	; 255
     1c8:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>

	if (wait_ready()) return 1;	/* OK */
     1cc:	0e 94 c8 00 	call	0x190	; 0x190 <wait_ready>
     1d0:	00 97       	sbiw	r24, 0x00	; 0
     1d2:	29 f4       	brne	.+10     	; 0x1de <select+0x1a>
	deselect();
     1d4:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
	return 0;	/* Timeout */
     1d8:	80 e0       	ldi	r24, 0x00	; 0
     1da:	90 e0       	ldi	r25, 0x00	; 0
     1dc:	08 95       	ret
int select (void)	/* 1:Successful, 0:Timeout */
{
	CS_LOW();
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */

	if (wait_ready()) return 1;	/* OK */
     1de:	81 e0       	ldi	r24, 0x01	; 1
     1e0:	90 e0       	ldi	r25, 0x00	; 0
	deselect();
	return 0;	/* Timeout */
}
     1e2:	08 95       	ret

000001e4 <rcvr_datablock>:
static
int rcvr_datablock (
	BYTE *buff,			/* Data buffer to store received data */
	UINT btr			/* Byte count (must be multiple of 4) */
)
{
     1e4:	cf 92       	push	r12
     1e6:	df 92       	push	r13
     1e8:	ef 92       	push	r14
     1ea:	ff 92       	push	r15
     1ec:	cf 93       	push	r28
     1ee:	df 93       	push	r29
     1f0:	ec 01       	movw	r28, r24
     1f2:	6a 01       	movw	r12, r20
     1f4:	7b 01       	movw	r14, r22
	BYTE token;


	Timer1 = 20;
     1f6:	84 e1       	ldi	r24, 0x14	; 20
     1f8:	80 93 21 04 	sts	0x0421, r24
	do {							/* Wait for data packet in timeout of 200ms */
		token = xchg_spi(0xFF);
     1fc:	8f ef       	ldi	r24, 0xFF	; 255
     1fe:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	} while ((token == 0xFF) && Timer1);
     202:	8f 3f       	cpi	r24, 0xFF	; 255
     204:	39 f4       	brne	.+14     	; 0x214 <rcvr_datablock+0x30>
     206:	80 91 21 04 	lds	r24, 0x0421
     20a:	88 23       	and	r24, r24
     20c:	b9 f7       	brne	.-18     	; 0x1fc <rcvr_datablock+0x18>
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */
     20e:	80 e0       	ldi	r24, 0x00	; 0
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	28 c0       	rjmp	.+80     	; 0x264 <rcvr_datablock+0x80>
     214:	8e 3f       	cpi	r24, 0xFE	; 254
     216:	21 f5       	brne	.+72     	; 0x260 <rcvr_datablock+0x7c>
	BYTE *p,	/* Data buffer */
	UINT cnt	/* Size of data block */
)
{
	do {
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
     218:	8f ef       	ldi	r24, 0xFF	; 255
     21a:	8e bd       	out	0x2e, r24	; 46
     21c:	0d b4       	in	r0, 0x2d	; 45
     21e:	07 fe       	sbrs	r0, 7
     220:	fd cf       	rjmp	.-6      	; 0x21c <rcvr_datablock+0x38>
     222:	9e b5       	in	r25, 0x2e	; 46
     224:	98 83       	st	Y, r25
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
     226:	8e bd       	out	0x2e, r24	; 46
     228:	0d b4       	in	r0, 0x2d	; 45
     22a:	07 fe       	sbrs	r0, 7
     22c:	fd cf       	rjmp	.-6      	; 0x228 <rcvr_datablock+0x44>
     22e:	9e b5       	in	r25, 0x2e	; 46
     230:	99 83       	std	Y+1, r25	; 0x01
/*-----------------------------------------------------------------------*/
/* Receive a data packet from MMC                                        */
/*-----------------------------------------------------------------------*/

static
int rcvr_datablock (
     232:	22 96       	adiw	r28, 0x02	; 2
)
{
	do {
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
	} while (cnt -= 2);
     234:	2e ef       	ldi	r18, 0xFE	; 254
     236:	3f ef       	ldi	r19, 0xFF	; 255
     238:	4f ef       	ldi	r20, 0xFF	; 255
     23a:	5f ef       	ldi	r21, 0xFF	; 255
     23c:	c2 0e       	add	r12, r18
     23e:	d3 1e       	adc	r13, r19
     240:	e4 1e       	adc	r14, r20
     242:	f5 1e       	adc	r15, r21
     244:	c1 14       	cp	r12, r1
     246:	d1 04       	cpc	r13, r1
     248:	e1 04       	cpc	r14, r1
     24a:	f1 04       	cpc	r15, r1
     24c:	31 f7       	brne	.-52     	; 0x21a <rcvr_datablock+0x36>
		token = xchg_spi(0xFF);
	} while ((token == 0xFF) && Timer1);
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */

	rcvr_spi_multi(buff, btr);		/* Receive the data block into buffer */
	xchg_spi(0xFF);					/* Discard CRC */
     24e:	8f ef       	ldi	r24, 0xFF	; 255
     250:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi(0xFF);
     254:	8f ef       	ldi	r24, 0xFF	; 255
     256:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>

	return 1;						/* Return with success */
     25a:	81 e0       	ldi	r24, 0x01	; 1
     25c:	90 e0       	ldi	r25, 0x00	; 0
     25e:	02 c0       	rjmp	.+4      	; 0x264 <rcvr_datablock+0x80>

	Timer1 = 20;
	do {							/* Wait for data packet in timeout of 200ms */
		token = xchg_spi(0xFF);
	} while ((token == 0xFF) && Timer1);
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */
     260:	80 e0       	ldi	r24, 0x00	; 0
     262:	90 e0       	ldi	r25, 0x00	; 0
	rcvr_spi_multi(buff, btr);		/* Receive the data block into buffer */
	xchg_spi(0xFF);					/* Discard CRC */
	xchg_spi(0xFF);

	return 1;						/* Return with success */
}
     264:	df 91       	pop	r29
     266:	cf 91       	pop	r28
     268:	ff 90       	pop	r15
     26a:	ef 90       	pop	r14
     26c:	df 90       	pop	r13
     26e:	cf 90       	pop	r12
     270:	08 95       	ret

00000272 <xmit_datablock>:
static
int xmit_datablock (
	const BYTE *buff,	/* 512 byte data block to be transmitted */
	BYTE token			/* Data/Stop token */
)
{
     272:	1f 93       	push	r17
     274:	cf 93       	push	r28
     276:	df 93       	push	r29
     278:	ec 01       	movw	r28, r24
     27a:	16 2f       	mov	r17, r22
	BYTE resp;


	if (!wait_ready()) return 0;
     27c:	0e 94 c8 00 	call	0x190	; 0x190 <wait_ready>
     280:	00 97       	sbiw	r24, 0x00	; 0
     282:	41 f1       	breq	.+80     	; 0x2d4 <xmit_datablock+0x62>

	xchg_spi(token);					/* Xmit data token */
     284:	81 2f       	mov	r24, r17
     286:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	if (token != 0xFD) {	/* Is data token */
     28a:	1d 3f       	cpi	r17, 0xFD	; 253
     28c:	31 f1       	breq	.+76     	; 0x2da <xmit_datablock+0x68>
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     28e:	ce 01       	movw	r24, r28
     290:	80 50       	subi	r24, 0x00	; 0
     292:	9e 4f       	sbci	r25, 0xFE	; 254
	const BYTE *p,	/* Data block to be sent */
	UINT cnt		/* Size of data block */
)
{
	do {
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     294:	28 81       	ld	r18, Y
     296:	2e bd       	out	0x2e, r18	; 46
     298:	0d b4       	in	r0, 0x2d	; 45
     29a:	07 fe       	sbrs	r0, 7
     29c:	fd cf       	rjmp	.-6      	; 0x298 <xmit_datablock+0x26>
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     29e:	29 81       	ldd	r18, Y+1	; 0x01
     2a0:	2e bd       	out	0x2e, r18	; 46
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     2a2:	22 96       	adiw	r28, 0x02	; 2
	UINT cnt		/* Size of data block */
)
{
	do {
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     2a4:	0d b4       	in	r0, 0x2d	; 45
     2a6:	07 fe       	sbrs	r0, 7
     2a8:	fd cf       	rjmp	.-6      	; 0x2a4 <xmit_datablock+0x32>
	} while (cnt -= 2);
     2aa:	8c 17       	cp	r24, r28
     2ac:	9d 07       	cpc	r25, r29
     2ae:	91 f7       	brne	.-28     	; 0x294 <xmit_datablock+0x22>
	if (!wait_ready()) return 0;

	xchg_spi(token);					/* Xmit data token */
	if (token != 0xFD) {	/* Is data token */
		xmit_spi_multi(buff, 512);		/* Xmit the data block to the MMC */
		xchg_spi(0xFF);					/* CRC (Dummy) */
     2b0:	8f ef       	ldi	r24, 0xFF	; 255
     2b2:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
		xchg_spi(0xFF);
     2b6:	8f ef       	ldi	r24, 0xFF	; 255
     2b8:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
		resp = xchg_spi(0xFF);			/* Reveive data response */
     2bc:	8f ef       	ldi	r24, 0xFF	; 255
     2be:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
     2c2:	8f 71       	andi	r24, 0x1F	; 31
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     2c4:	21 e0       	ldi	r18, 0x01	; 1
     2c6:	30 e0       	ldi	r19, 0x00	; 0
     2c8:	85 30       	cpi	r24, 0x05	; 5
     2ca:	11 f0       	breq	.+4      	; 0x2d0 <xmit_datablock+0x5e>
     2cc:	20 e0       	ldi	r18, 0x00	; 0
     2ce:	30 e0       	ldi	r19, 0x00	; 0
)
{
	BYTE resp;


	if (!wait_ready()) return 0;
     2d0:	c9 01       	movw	r24, r18
     2d2:	05 c0       	rjmp	.+10     	; 0x2de <xmit_datablock+0x6c>
     2d4:	80 e0       	ldi	r24, 0x00	; 0
     2d6:	90 e0       	ldi	r25, 0x00	; 0
     2d8:	02 c0       	rjmp	.+4      	; 0x2de <xmit_datablock+0x6c>
		resp = xchg_spi(0xFF);			/* Reveive data response */
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
			return 0;
	}

	return 1;
     2da:	81 e0       	ldi	r24, 0x01	; 1
     2dc:	90 e0       	ldi	r25, 0x00	; 0
}
     2de:	df 91       	pop	r29
     2e0:	cf 91       	pop	r28
     2e2:	1f 91       	pop	r17
     2e4:	08 95       	ret

000002e6 <send_cmd>:
static
BYTE send_cmd (		/* Returns R1 resp (bit7==1:Send failed) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
     2e6:	ff 92       	push	r15
     2e8:	0f 93       	push	r16
     2ea:	1f 93       	push	r17
     2ec:	cf 93       	push	r28
     2ee:	df 93       	push	r29
     2f0:	c8 2f       	mov	r28, r24
     2f2:	d4 2f       	mov	r29, r20
     2f4:	15 2f       	mov	r17, r21
     2f6:	06 2f       	mov	r16, r22
     2f8:	f7 2e       	mov	r15, r23
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
     2fa:	88 23       	and	r24, r24
     2fc:	4c f4       	brge	.+18     	; 0x310 <send_cmd+0x2a>
		cmd &= 0x7F;
		res = send_cmd(CMD55, 0);
     2fe:	87 e3       	ldi	r24, 0x37	; 55
     300:	40 e0       	ldi	r20, 0x00	; 0
     302:	50 e0       	ldi	r21, 0x00	; 0
     304:	ba 01       	movw	r22, r20
     306:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
		if (res > 1) return res;
     30a:	82 30       	cpi	r24, 0x02	; 2
     30c:	68 f5       	brcc	.+90     	; 0x368 <send_cmd+0x82>
{
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
     30e:	cf 77       	andi	r28, 0x7F	; 127
		res = send_cmd(CMD55, 0);
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	deselect();
     310:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
	if (!select()) return 0xFF;
     314:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <select>
     318:	00 97       	sbiw	r24, 0x00	; 0
     31a:	29 f1       	breq	.+74     	; 0x366 <send_cmd+0x80>

	/* Send command packet */
	xchg_spi(0x40 | cmd);				/* Start + Command index */
     31c:	8c 2f       	mov	r24, r28
     31e:	80 64       	ori	r24, 0x40	; 64
     320:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
     324:	8f 2d       	mov	r24, r15
     326:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
     32a:	80 2f       	mov	r24, r16
     32c:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
     330:	81 2f       	mov	r24, r17
     332:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
     336:	8d 2f       	mov	r24, r29
     338:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) + Stop */
     33c:	cc 23       	and	r28, r28
     33e:	f1 f0       	breq	.+60     	; 0x37c <send_cmd+0x96>
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) Stop */
     340:	c8 30       	cpi	r28, 0x08	; 8
     342:	c1 f0       	breq	.+48     	; 0x374 <send_cmd+0x8e>
	xchg_spi(n);
     344:	81 e0       	ldi	r24, 0x01	; 1
     346:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>

	/* Receive command response */
	if (cmd == CMD12) xchg_spi(0xFF);		/* Skip a stuff byte when stop reading */
     34a:	cc 30       	cpi	r28, 0x0C	; 12
     34c:	19 f4       	brne	.+6      	; 0x354 <send_cmd+0x6e>
     34e:	8f ef       	ldi	r24, 0xFF	; 255
     350:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
static
BYTE send_cmd (		/* Returns R1 resp (bit7==1:Send failed) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
     354:	ca e0       	ldi	r28, 0x0A	; 10

	/* Receive command response */
	if (cmd == CMD12) xchg_spi(0xFF);		/* Skip a stuff byte when stop reading */
	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do
		res = xchg_spi(0xFF);
     356:	8f ef       	ldi	r24, 0xFF	; 255
     358:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	while ((res & 0x80) && --n);
     35c:	88 23       	and	r24, r24
     35e:	24 f4       	brge	.+8      	; 0x368 <send_cmd+0x82>
     360:	c1 50       	subi	r28, 0x01	; 1
     362:	c9 f7       	brne	.-14     	; 0x356 <send_cmd+0x70>
     364:	01 c0       	rjmp	.+2      	; 0x368 <send_cmd+0x82>
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	deselect();
	if (!select()) return 0xFF;
     366:	8f ef       	ldi	r24, 0xFF	; 255
	do
		res = xchg_spi(0xFF);
	while ((res & 0x80) && --n);

	return res;			/* Return with the response value */
}
     368:	df 91       	pop	r29
     36a:	cf 91       	pop	r28
     36c:	1f 91       	pop	r17
     36e:	0f 91       	pop	r16
     370:	ff 90       	pop	r15
     372:	08 95       	ret
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) + Stop */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) Stop */
	xchg_spi(n);
     374:	87 e8       	ldi	r24, 0x87	; 135
     376:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     37a:	ec cf       	rjmp	.-40     	; 0x354 <send_cmd+0x6e>
     37c:	85 e9       	ldi	r24, 0x95	; 149
     37e:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     382:	e8 cf       	rjmp	.-48     	; 0x354 <send_cmd+0x6e>

00000384 <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
     384:	cf 92       	push	r12
     386:	df 92       	push	r13
     388:	ef 92       	push	r14
     38a:	ff 92       	push	r15
     38c:	0f 93       	push	r16
     38e:	1f 93       	push	r17
     390:	cf 93       	push	r28
     392:	df 93       	push	r29
     394:	00 d0       	rcall	.+0      	; 0x396 <disk_initialize+0x12>
     396:	00 d0       	rcall	.+0      	; 0x398 <disk_initialize+0x14>
     398:	cd b7       	in	r28, 0x3d	; 61
     39a:	de b7       	in	r29, 0x3e	; 62
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only single drive */
     39c:	88 23       	and	r24, r24
     39e:	09 f0       	breq	.+2      	; 0x3a2 <disk_initialize+0x1e>
     3a0:	a8 c0       	rjmp	.+336    	; 0x4f2 <disk_initialize+0x16e>
	power_off();						/* Turn off the socket power to reset the card */
     3a2:	0e 94 bc 00 	call	0x178	; 0x178 <power_off>
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
     3a6:	80 91 8a 01 	lds	r24, 0x018A
     3aa:	81 ff       	sbrs	r24, 1
     3ac:	03 c0       	rjmp	.+6      	; 0x3b4 <disk_initialize+0x30>
     3ae:	80 91 8a 01 	lds	r24, 0x018A
     3b2:	a0 c0       	rjmp	.+320    	; 0x4f4 <disk_initialize+0x170>
	// Configure for: PB4 - /SS
	//                PB5 - MOSI
	//                PB6 - MISO
	//                PB7 - SCK

	PORTB = 0b00010000;      // SS high
     3b4:	80 e1       	ldi	r24, 0x10	; 16
     3b6:	85 b9       	out	0x05, r24	; 5
	DDRB =  0b10110000;      // !SS,SCK and MOSI outputs
     3b8:	80 eb       	ldi	r24, 0xB0	; 176
     3ba:	84 b9       	out	0x04, r24	; 4

	/* Set MOSI and SCK output, all others input */
	//DDR_SPI = (1<<DD_MOSI)|(1<<DD_SCK);
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
     3bc:	81 e5       	ldi	r24, 0x51	; 81
     3be:	8c bd       	out	0x2c, r24	; 44

	if (drv) return STA_NOINIT;			/* Supports only single drive */
	power_off();						/* Turn off the socket power to reset the card */
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
	power_on();							/* Turn on the socket power */
	FCLK_SLOW();
     3c0:	82 e5       	ldi	r24, 0x52	; 82
     3c2:	8c bd       	out	0x2c, r24	; 44
     3c4:	0a e0       	ldi	r16, 0x0A	; 10
	for (n = 10; n; n--) xchg_spi(0xFF);	/* 80 dummy clocks */
     3c6:	8f ef       	ldi	r24, 0xFF	; 255
     3c8:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     3cc:	01 50       	subi	r16, 0x01	; 1
     3ce:	d9 f7       	brne	.-10     	; 0x3c6 <disk_initialize+0x42>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
     3d0:	80 e0       	ldi	r24, 0x00	; 0
     3d2:	40 e0       	ldi	r20, 0x00	; 0
     3d4:	50 e0       	ldi	r21, 0x00	; 0
     3d6:	ba 01       	movw	r22, r20
     3d8:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     3dc:	81 30       	cpi	r24, 0x01	; 1
     3de:	09 f0       	breq	.+2      	; 0x3e2 <disk_initialize+0x5e>
     3e0:	9c c0       	rjmp	.+312    	; 0x51a <disk_initialize+0x196>
		Timer1 = 100;						/* Initialization timeout of 1000 msec */
     3e2:	84 e6       	ldi	r24, 0x64	; 100
     3e4:	80 93 21 04 	sts	0x0421, r24
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
     3e8:	88 e0       	ldi	r24, 0x08	; 8
     3ea:	4a ea       	ldi	r20, 0xAA	; 170
     3ec:	51 e0       	ldi	r21, 0x01	; 1
     3ee:	60 e0       	ldi	r22, 0x00	; 0
     3f0:	70 e0       	ldi	r23, 0x00	; 0
     3f2:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     3f6:	81 30       	cpi	r24, 0x01	; 1
     3f8:	09 f0       	breq	.+2      	; 0x3fc <disk_initialize+0x78>
     3fa:	42 c0       	rjmp	.+132    	; 0x480 <disk_initialize+0xfc>
     3fc:	6e 01       	movw	r12, r28
     3fe:	08 94       	sec
     400:	c1 1c       	adc	r12, r1
     402:	d1 1c       	adc	r13, r1

/*-----------------------------------------------------------------------*/
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
     404:	8e 01       	movw	r16, r28
     406:	0b 5f       	subi	r16, 0xFB	; 251
     408:	1f 4f       	sbci	r17, 0xFF	; 255
     40a:	76 01       	movw	r14, r12

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		Timer1 = 100;						/* Initialization timeout of 1000 msec */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);		/* Get trailing return value of R7 resp */
     40c:	8f ef       	ldi	r24, 0xFF	; 255
     40e:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     412:	f7 01       	movw	r30, r14
     414:	81 93       	st	Z+, r24
     416:	7f 01       	movw	r14, r30
     418:	e0 17       	cp	r30, r16
     41a:	f1 07       	cpc	r31, r17
     41c:	b9 f7       	brne	.-18     	; 0x40c <disk_initialize+0x88>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	81 30       	cpi	r24, 0x01	; 1
     422:	09 f0       	breq	.+2      	; 0x426 <disk_initialize+0xa2>
     424:	7a c0       	rjmp	.+244    	; 0x51a <disk_initialize+0x196>
     426:	8c 81       	ldd	r24, Y+4	; 0x04
     428:	8a 3a       	cpi	r24, 0xAA	; 170
     42a:	09 f0       	breq	.+2      	; 0x42e <disk_initialize+0xaa>
     42c:	76 c0       	rjmp	.+236    	; 0x51a <disk_initialize+0x196>
				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
     42e:	80 91 21 04 	lds	r24, 0x0421
     432:	88 23       	and	r24, r24
     434:	49 f0       	breq	.+18     	; 0x448 <disk_initialize+0xc4>
     436:	89 ea       	ldi	r24, 0xA9	; 169
     438:	40 e0       	ldi	r20, 0x00	; 0
     43a:	50 e0       	ldi	r21, 0x00	; 0
     43c:	60 e0       	ldi	r22, 0x00	; 0
     43e:	70 e4       	ldi	r23, 0x40	; 64
     440:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     444:	88 23       	and	r24, r24
     446:	99 f7       	brne	.-26     	; 0x42e <disk_initialize+0xaa>
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
     448:	80 91 21 04 	lds	r24, 0x0421
     44c:	88 23       	and	r24, r24
     44e:	09 f4       	brne	.+2      	; 0x452 <disk_initialize+0xce>
     450:	64 c0       	rjmp	.+200    	; 0x51a <disk_initialize+0x196>
     452:	8a e3       	ldi	r24, 0x3A	; 58
     454:	40 e0       	ldi	r20, 0x00	; 0
     456:	50 e0       	ldi	r21, 0x00	; 0
     458:	ba 01       	movw	r22, r20
     45a:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     45e:	88 23       	and	r24, r24
     460:	09 f0       	breq	.+2      	; 0x464 <disk_initialize+0xe0>
     462:	5b c0       	rjmp	.+182    	; 0x51a <disk_initialize+0x196>
     464:	04 e0       	ldi	r16, 0x04	; 4
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
     466:	8f ef       	ldi	r24, 0xFF	; 255
     468:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     46c:	f6 01       	movw	r30, r12
     46e:	81 93       	st	Z+, r24
     470:	6f 01       	movw	r12, r30
     472:	01 50       	subi	r16, 0x01	; 1
     474:	c1 f7       	brne	.-16     	; 0x466 <disk_initialize+0xe2>
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
     476:	89 81       	ldd	r24, Y+1	; 0x01
     478:	86 fd       	sbrc	r24, 6
     47a:	49 c0       	rjmp	.+146    	; 0x50e <disk_initialize+0x18a>
     47c:	84 e0       	ldi	r24, 0x04	; 4
     47e:	48 c0       	rjmp	.+144    	; 0x510 <disk_initialize+0x18c>
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
     480:	89 ea       	ldi	r24, 0xA9	; 169
     482:	40 e0       	ldi	r20, 0x00	; 0
     484:	50 e0       	ldi	r21, 0x00	; 0
     486:	ba 01       	movw	r22, r20
     488:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     48c:	82 30       	cpi	r24, 0x02	; 2
     48e:	18 f4       	brcc	.+6      	; 0x496 <disk_initialize+0x112>
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
     490:	12 e0       	ldi	r17, 0x02	; 2
     492:	09 ea       	ldi	r16, 0xA9	; 169
     494:	02 c0       	rjmp	.+4      	; 0x49a <disk_initialize+0x116>
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
     496:	11 e0       	ldi	r17, 0x01	; 1
     498:	01 e0       	ldi	r16, 0x01	; 1
			}
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
     49a:	80 91 21 04 	lds	r24, 0x0421
     49e:	88 23       	and	r24, r24
     4a0:	41 f0       	breq	.+16     	; 0x4b2 <disk_initialize+0x12e>
     4a2:	80 2f       	mov	r24, r16
     4a4:	40 e0       	ldi	r20, 0x00	; 0
     4a6:	50 e0       	ldi	r21, 0x00	; 0
     4a8:	ba 01       	movw	r22, r20
     4aa:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     4ae:	88 23       	and	r24, r24
     4b0:	a1 f7       	brne	.-24     	; 0x49a <disk_initialize+0x116>
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
     4b2:	80 91 21 04 	lds	r24, 0x0421
     4b6:	88 23       	and	r24, r24
     4b8:	81 f1       	breq	.+96     	; 0x51a <disk_initialize+0x196>
     4ba:	80 e1       	ldi	r24, 0x10	; 16
     4bc:	40 e0       	ldi	r20, 0x00	; 0
     4be:	52 e0       	ldi	r21, 0x02	; 2
     4c0:	60 e0       	ldi	r22, 0x00	; 0
     4c2:	70 e0       	ldi	r23, 0x00	; 0
     4c4:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     4c8:	88 23       	and	r24, r24
     4ca:	39 f5       	brne	.+78     	; 0x51a <disk_initialize+0x196>
				ty = 0;
		}
	}
	CardType = ty;
     4cc:	10 93 22 04 	sts	0x0422, r17
	deselect();
     4d0:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>

	if (ty) {			/* Initialization succeded */
     4d4:	11 23       	and	r17, r17
     4d6:	41 f0       	breq	.+16     	; 0x4e8 <disk_initialize+0x164>
		Stat &= ~STA_NOINIT;		/* Clear STA_NOINIT */
     4d8:	80 91 8a 01 	lds	r24, 0x018A
     4dc:	8e 7f       	andi	r24, 0xFE	; 254
     4de:	80 93 8a 01 	sts	0x018A, r24
		FCLK_FAST();
     4e2:	80 e5       	ldi	r24, 0x50	; 80
     4e4:	8c bd       	out	0x2c, r24	; 44
     4e6:	02 c0       	rjmp	.+4      	; 0x4ec <disk_initialize+0x168>
	} else {			/* Initialization failed */
		power_off();
     4e8:	0e 94 bc 00 	call	0x178	; 0x178 <power_off>
	}

	return Stat;
     4ec:	80 91 8a 01 	lds	r24, 0x018A
     4f0:	01 c0       	rjmp	.+2      	; 0x4f4 <disk_initialize+0x170>
)
{
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only single drive */
     4f2:	81 e0       	ldi	r24, 0x01	; 1
	} else {			/* Initialization failed */
		power_off();
	}

	return Stat;
}
     4f4:	0f 90       	pop	r0
     4f6:	0f 90       	pop	r0
     4f8:	0f 90       	pop	r0
     4fa:	0f 90       	pop	r0
     4fc:	df 91       	pop	r29
     4fe:	cf 91       	pop	r28
     500:	1f 91       	pop	r17
     502:	0f 91       	pop	r16
     504:	ff 90       	pop	r15
     506:	ef 90       	pop	r14
     508:	df 90       	pop	r13
     50a:	cf 90       	pop	r12
     50c:	08 95       	ret
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);		/* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
     50e:	8c e0       	ldi	r24, 0x0C	; 12
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
     510:	80 93 22 04 	sts	0x0422, r24
	deselect();
     514:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
     518:	df cf       	rjmp	.-66     	; 0x4d8 <disk_initialize+0x154>
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
     51a:	10 92 22 04 	sts	0x0422, r1
	deselect();
     51e:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
     522:	e2 cf       	rjmp	.-60     	; 0x4e8 <disk_initialize+0x164>

00000524 <disk_status>:

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
     524:	88 23       	and	r24, r24
     526:	19 f4       	brne	.+6      	; 0x52e <disk_status+0xa>
	return Stat;
     528:	80 91 8a 01 	lds	r24, 0x018A
     52c:	08 95       	ret

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
     52e:	81 e0       	ldi	r24, 0x01	; 1
	return Stat;
}
     530:	08 95       	ret

00000532 <disk_read>:
	BYTE drv,			/* Physical drive nmuber (0) */
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
     532:	0f 93       	push	r16
     534:	cf 93       	push	r28
     536:	df 93       	push	r29
     538:	eb 01       	movw	r28, r22
	if (drv || !count) return RES_PARERR;
     53a:	88 23       	and	r24, r24
     53c:	09 f0       	breq	.+2      	; 0x540 <disk_read+0xe>
     53e:	4a c0       	rjmp	.+148    	; 0x5d4 <disk_read+0xa2>
     540:	00 23       	and	r16, r16
     542:	09 f4       	brne	.+2      	; 0x546 <disk_read+0x14>
     544:	49 c0       	rjmp	.+146    	; 0x5d8 <disk_read+0xa6>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     546:	80 91 8a 01 	lds	r24, 0x018A
     54a:	80 fd       	sbrc	r24, 0
     54c:	47 c0       	rjmp	.+142    	; 0x5dc <disk_read+0xaa>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
     54e:	80 91 22 04 	lds	r24, 0x0422
     552:	83 fd       	sbrc	r24, 3
     554:	09 c0       	rjmp	.+18     	; 0x568 <disk_read+0x36>
     556:	01 2e       	mov	r0, r17
     558:	19 e0       	ldi	r17, 0x09	; 9
     55a:	22 0f       	add	r18, r18
     55c:	33 1f       	adc	r19, r19
     55e:	44 1f       	adc	r20, r20
     560:	55 1f       	adc	r21, r21
     562:	1a 95       	dec	r17
     564:	d1 f7       	brne	.-12     	; 0x55a <disk_read+0x28>
     566:	10 2d       	mov	r17, r0

	if (count == 1) {	/* Single block read */
     568:	01 30       	cpi	r16, 0x01	; 1
     56a:	89 f4       	brne	.+34     	; 0x58e <disk_read+0x5c>
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
     56c:	81 e1       	ldi	r24, 0x11	; 17
     56e:	ba 01       	movw	r22, r20
     570:	a9 01       	movw	r20, r18
     572:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     576:	88 23       	and	r24, r24
     578:	31 f5       	brne	.+76     	; 0x5c6 <disk_read+0x94>
			&& rcvr_datablock(buff, 512))
     57a:	ce 01       	movw	r24, r28
     57c:	40 e0       	ldi	r20, 0x00	; 0
     57e:	52 e0       	ldi	r21, 0x02	; 2
     580:	60 e0       	ldi	r22, 0x00	; 0
     582:	70 e0       	ldi	r23, 0x00	; 0
     584:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     588:	00 97       	sbiw	r24, 0x00	; 0
     58a:	e1 f4       	brne	.+56     	; 0x5c4 <disk_read+0x92>
     58c:	1c c0       	rjmp	.+56     	; 0x5c6 <disk_read+0x94>
			count = 0;
	}
	else {				/* Multiple block read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
     58e:	82 e1       	ldi	r24, 0x12	; 18
     590:	ba 01       	movw	r22, r20
     592:	a9 01       	movw	r20, r18
     594:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     598:	88 23       	and	r24, r24
     59a:	a9 f4       	brne	.+42     	; 0x5c6 <disk_read+0x94>
			do {
				if (!rcvr_datablock(buff, 512)) break;
     59c:	ce 01       	movw	r24, r28
     59e:	40 e0       	ldi	r20, 0x00	; 0
     5a0:	52 e0       	ldi	r21, 0x02	; 2
     5a2:	60 e0       	ldi	r22, 0x00	; 0
     5a4:	70 e0       	ldi	r23, 0x00	; 0
     5a6:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     5aa:	00 97       	sbiw	r24, 0x00	; 0
     5ac:	21 f0       	breq	.+8      	; 0x5b6 <disk_read+0x84>
				buff += 512;
     5ae:	c0 50       	subi	r28, 0x00	; 0
     5b0:	de 4f       	sbci	r29, 0xFE	; 254
			} while (--count);
     5b2:	01 50       	subi	r16, 0x01	; 1
     5b4:	99 f7       	brne	.-26     	; 0x59c <disk_read+0x6a>
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
     5b6:	8c e0       	ldi	r24, 0x0C	; 12
     5b8:	40 e0       	ldi	r20, 0x00	; 0
     5ba:	50 e0       	ldi	r21, 0x00	; 0
     5bc:	ba 01       	movw	r22, r20
     5be:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     5c2:	01 c0       	rjmp	.+2      	; 0x5c6 <disk_read+0x94>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */

	if (count == 1) {	/* Single block read */
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
			&& rcvr_datablock(buff, 512))
			count = 0;
     5c4:	00 e0       	ldi	r16, 0x00	; 0
				buff += 512;
			} while (--count);
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
		}
	}
	deselect();
     5c6:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>

	return count ? RES_ERROR : RES_OK;
     5ca:	81 e0       	ldi	r24, 0x01	; 1
     5cc:	00 23       	and	r16, r16
     5ce:	39 f4       	brne	.+14     	; 0x5de <disk_read+0xac>
     5d0:	80 e0       	ldi	r24, 0x00	; 0
     5d2:	05 c0       	rjmp	.+10     	; 0x5de <disk_read+0xac>
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
	if (drv || !count) return RES_PARERR;
     5d4:	84 e0       	ldi	r24, 0x04	; 4
     5d6:	03 c0       	rjmp	.+6      	; 0x5de <disk_read+0xac>
     5d8:	84 e0       	ldi	r24, 0x04	; 4
     5da:	01 c0       	rjmp	.+2      	; 0x5de <disk_read+0xac>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     5dc:	83 e0       	ldi	r24, 0x03	; 3
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
     5de:	df 91       	pop	r29
     5e0:	cf 91       	pop	r28
     5e2:	0f 91       	pop	r16
     5e4:	08 95       	ret

000005e6 <disk_write>:
	BYTE drv,			/* Physical drive nmuber (0) */
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
     5e6:	cf 92       	push	r12
     5e8:	df 92       	push	r13
     5ea:	ef 92       	push	r14
     5ec:	ff 92       	push	r15
     5ee:	0f 93       	push	r16
     5f0:	cf 93       	push	r28
     5f2:	df 93       	push	r29
     5f4:	eb 01       	movw	r28, r22
     5f6:	69 01       	movw	r12, r18
     5f8:	7a 01       	movw	r14, r20
	if (drv || !count) return RES_PARERR;
     5fa:	88 23       	and	r24, r24
     5fc:	09 f0       	breq	.+2      	; 0x600 <disk_write+0x1a>
     5fe:	57 c0       	rjmp	.+174    	; 0x6ae <disk_write+0xc8>
     600:	00 23       	and	r16, r16
     602:	09 f4       	brne	.+2      	; 0x606 <disk_write+0x20>
     604:	56 c0       	rjmp	.+172    	; 0x6b2 <disk_write+0xcc>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     606:	80 91 8a 01 	lds	r24, 0x018A
     60a:	80 fd       	sbrc	r24, 0
     60c:	54 c0       	rjmp	.+168    	; 0x6b6 <disk_write+0xd0>
	if (Stat & STA_PROTECT) return RES_WRPRT;
     60e:	80 91 8a 01 	lds	r24, 0x018A
     612:	82 fd       	sbrc	r24, 2
     614:	52 c0       	rjmp	.+164    	; 0x6ba <disk_write+0xd4>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
     616:	80 91 22 04 	lds	r24, 0x0422
     61a:	90 e0       	ldi	r25, 0x00	; 0
     61c:	83 fd       	sbrc	r24, 3
     61e:	09 c0       	rjmp	.+18     	; 0x632 <disk_write+0x4c>
     620:	0b 2e       	mov	r0, r27
     622:	b9 e0       	ldi	r27, 0x09	; 9
     624:	cc 0c       	add	r12, r12
     626:	dd 1c       	adc	r13, r13
     628:	ee 1c       	adc	r14, r14
     62a:	ff 1c       	adc	r15, r15
     62c:	ba 95       	dec	r27
     62e:	d1 f7       	brne	.-12     	; 0x624 <disk_write+0x3e>
     630:	b0 2d       	mov	r27, r0

	if (count == 1) {	/* Single block write */
     632:	01 30       	cpi	r16, 0x01	; 1
     634:	71 f4       	brne	.+28     	; 0x652 <disk_write+0x6c>
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
     636:	88 e1       	ldi	r24, 0x18	; 24
     638:	b7 01       	movw	r22, r14
     63a:	a6 01       	movw	r20, r12
     63c:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     640:	88 23       	and	r24, r24
     642:	71 f5       	brne	.+92     	; 0x6a0 <disk_write+0xba>
			&& xmit_datablock(buff, 0xFE))
     644:	ce 01       	movw	r24, r28
     646:	6e ef       	ldi	r22, 0xFE	; 254
     648:	0e 94 39 01 	call	0x272	; 0x272 <xmit_datablock>
     64c:	00 97       	sbiw	r24, 0x00	; 0
     64e:	29 f5       	brne	.+74     	; 0x69a <disk_write+0xb4>
     650:	27 c0       	rjmp	.+78     	; 0x6a0 <disk_write+0xba>
			count = 0;
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
     652:	86 70       	andi	r24, 0x06	; 6
     654:	90 70       	andi	r25, 0x00	; 0
     656:	00 97       	sbiw	r24, 0x00	; 0
     658:	39 f0       	breq	.+14     	; 0x668 <disk_write+0x82>
     65a:	40 2f       	mov	r20, r16
     65c:	50 e0       	ldi	r21, 0x00	; 0
     65e:	60 e0       	ldi	r22, 0x00	; 0
     660:	70 e0       	ldi	r23, 0x00	; 0
     662:	87 e9       	ldi	r24, 0x97	; 151
     664:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
     668:	89 e1       	ldi	r24, 0x19	; 25
     66a:	b7 01       	movw	r22, r14
     66c:	a6 01       	movw	r20, r12
     66e:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     672:	88 23       	and	r24, r24
     674:	a9 f4       	brne	.+42     	; 0x6a0 <disk_write+0xba>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
     676:	ce 01       	movw	r24, r28
     678:	6c ef       	ldi	r22, 0xFC	; 252
     67a:	0e 94 39 01 	call	0x272	; 0x272 <xmit_datablock>
     67e:	00 97       	sbiw	r24, 0x00	; 0
     680:	21 f0       	breq	.+8      	; 0x68a <disk_write+0xa4>
				buff += 512;
     682:	c0 50       	subi	r28, 0x00	; 0
     684:	de 4f       	sbci	r29, 0xFE	; 254
			} while (--count);
     686:	01 50       	subi	r16, 0x01	; 1
     688:	b1 f7       	brne	.-20     	; 0x676 <disk_write+0x90>
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
     68a:	80 e0       	ldi	r24, 0x00	; 0
     68c:	90 e0       	ldi	r25, 0x00	; 0
     68e:	6d ef       	ldi	r22, 0xFD	; 253
     690:	0e 94 39 01 	call	0x272	; 0x272 <xmit_datablock>
     694:	00 97       	sbiw	r24, 0x00	; 0
     696:	19 f0       	breq	.+6      	; 0x69e <disk_write+0xb8>
     698:	03 c0       	rjmp	.+6      	; 0x6a0 <disk_write+0xba>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */

	if (count == 1) {	/* Single block write */
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
			&& xmit_datablock(buff, 0xFE))
			count = 0;
     69a:	00 e0       	ldi	r16, 0x00	; 0
     69c:	01 c0       	rjmp	.+2      	; 0x6a0 <disk_write+0xba>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
				buff += 512;
			} while (--count);
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
				count = 1;
     69e:	01 e0       	ldi	r16, 0x01	; 1
		}
	}
	deselect();
     6a0:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>

	return count ? RES_ERROR : RES_OK;
     6a4:	81 e0       	ldi	r24, 0x01	; 1
     6a6:	00 23       	and	r16, r16
     6a8:	49 f4       	brne	.+18     	; 0x6bc <disk_write+0xd6>
     6aa:	80 e0       	ldi	r24, 0x00	; 0
     6ac:	07 c0       	rjmp	.+14     	; 0x6bc <disk_write+0xd6>
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
	if (drv || !count) return RES_PARERR;
     6ae:	84 e0       	ldi	r24, 0x04	; 4
     6b0:	05 c0       	rjmp	.+10     	; 0x6bc <disk_write+0xd6>
     6b2:	84 e0       	ldi	r24, 0x04	; 4
     6b4:	03 c0       	rjmp	.+6      	; 0x6bc <disk_write+0xd6>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     6b6:	83 e0       	ldi	r24, 0x03	; 3
     6b8:	01 c0       	rjmp	.+2      	; 0x6bc <disk_write+0xd6>
	if (Stat & STA_PROTECT) return RES_WRPRT;
     6ba:	82 e0       	ldi	r24, 0x02	; 2
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
     6bc:	df 91       	pop	r29
     6be:	cf 91       	pop	r28
     6c0:	0f 91       	pop	r16
     6c2:	ff 90       	pop	r15
     6c4:	ef 90       	pop	r14
     6c6:	df 90       	pop	r13
     6c8:	cf 90       	pop	r12
     6ca:	08 95       	ret

000006cc <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
     6cc:	ef 92       	push	r14
     6ce:	ff 92       	push	r15
     6d0:	0f 93       	push	r16
     6d2:	1f 93       	push	r17
     6d4:	cf 93       	push	r28
     6d6:	df 93       	push	r29
     6d8:	cd b7       	in	r28, 0x3d	; 61
     6da:	de b7       	in	r29, 0x3e	; 62
     6dc:	60 97       	sbiw	r28, 0x10	; 16
     6de:	0f b6       	in	r0, 0x3f	; 63
     6e0:	f8 94       	cli
     6e2:	de bf       	out	0x3e, r29	; 62
     6e4:	0f be       	out	0x3f, r0	; 63
     6e6:	cd bf       	out	0x3d, r28	; 61
     6e8:	7a 01       	movw	r14, r20
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	DWORD csize;


	if (drv) return RES_PARERR;
     6ea:	88 23       	and	r24, r24
     6ec:	09 f0       	breq	.+2      	; 0x6f0 <disk_ioctl+0x24>
     6ee:	da c1       	rjmp	.+948    	; 0xaa4 <disk_ioctl+0x3d8>

	res = RES_ERROR;

	if (ctrl == CTRL_POWER) {
     6f0:	65 30       	cpi	r22, 0x05	; 5
     6f2:	89 f4       	brne	.+34     	; 0x716 <disk_ioctl+0x4a>
		switch (ptr[0]) {
     6f4:	fa 01       	movw	r30, r20
     6f6:	80 81       	ld	r24, Z
     6f8:	88 23       	and	r24, r24
     6fa:	21 f0       	breq	.+8      	; 0x704 <disk_ioctl+0x38>
     6fc:	81 30       	cpi	r24, 0x01	; 1
     6fe:	09 f0       	breq	.+2      	; 0x702 <disk_ioctl+0x36>
     700:	d3 c1       	rjmp	.+934    	; 0xaa8 <disk_ioctl+0x3dc>
     702:	04 c0       	rjmp	.+8      	; 0x70c <disk_ioctl+0x40>
		case 0:		/* Sub control code (POWER_OFF) */
			power_off();		/* Power off */
     704:	0e 94 bc 00 	call	0x178	; 0x178 <power_off>
			res = RES_OK;
     708:	00 e0       	ldi	r16, 0x00	; 0
			break;
     70a:	d1 c1       	rjmp	.+930    	; 0xaae <disk_ioctl+0x3e2>
		case 1:		/* Sub control code (POWER_GET) */
			ptr[1] = (BYTE)power_status();
     70c:	81 e0       	ldi	r24, 0x01	; 1
     70e:	fa 01       	movw	r30, r20
     710:	81 83       	std	Z+1, r24	; 0x01
			res = RES_OK;
     712:	00 e0       	ldi	r16, 0x00	; 0
			break;
     714:	cc c1       	rjmp	.+920    	; 0xaae <disk_ioctl+0x3e2>
		default :
			res = RES_PARERR;
		}
	}
	else {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
     716:	80 91 8a 01 	lds	r24, 0x018A
     71a:	80 fd       	sbrc	r24, 0
     71c:	c7 c1       	rjmp	.+910    	; 0xaac <disk_ioctl+0x3e0>

		switch (ctrl) {
     71e:	6a 30       	cpi	r22, 0x0A	; 10
     720:	09 f4       	brne	.+2      	; 0x724 <disk_ioctl+0x58>
     722:	44 c1       	rjmp	.+648    	; 0x9ac <disk_ioctl+0x2e0>
     724:	6b 30       	cpi	r22, 0x0B	; 11
     726:	58 f4       	brcc	.+22     	; 0x73e <disk_ioctl+0x72>
     728:	61 30       	cpi	r22, 0x01	; 1
     72a:	f9 f0       	breq	.+62     	; 0x76a <disk_ioctl+0x9e>
     72c:	61 30       	cpi	r22, 0x01	; 1
     72e:	a0 f0       	brcs	.+40     	; 0x758 <disk_ioctl+0x8c>
     730:	62 30       	cpi	r22, 0x02	; 2
     732:	09 f4       	brne	.+2      	; 0x736 <disk_ioctl+0x6a>
     734:	98 c0       	rjmp	.+304    	; 0x866 <disk_ioctl+0x19a>
     736:	63 30       	cpi	r22, 0x03	; 3
     738:	09 f0       	breq	.+2      	; 0x73c <disk_ioctl+0x70>
     73a:	94 c1       	rjmp	.+808    	; 0xa64 <disk_ioctl+0x398>
     73c:	9b c0       	rjmp	.+310    	; 0x874 <disk_ioctl+0x1a8>
     73e:	6c 30       	cpi	r22, 0x0C	; 12
     740:	09 f4       	brne	.+2      	; 0x744 <disk_ioctl+0x78>
     742:	4f c1       	rjmp	.+670    	; 0x9e2 <disk_ioctl+0x316>
     744:	6c 30       	cpi	r22, 0x0C	; 12
     746:	08 f4       	brcc	.+2      	; 0x74a <disk_ioctl+0x7e>
     748:	37 c1       	rjmp	.+622    	; 0x9b8 <disk_ioctl+0x2ec>
     74a:	6d 30       	cpi	r22, 0x0D	; 13
     74c:	09 f4       	brne	.+2      	; 0x750 <disk_ioctl+0x84>
     74e:	5e c1       	rjmp	.+700    	; 0xa0c <disk_ioctl+0x340>
     750:	6e 30       	cpi	r22, 0x0E	; 14
     752:	09 f0       	breq	.+2      	; 0x756 <disk_ioctl+0x8a>
     754:	87 c1       	rjmp	.+782    	; 0xa64 <disk_ioctl+0x398>
     756:	70 c1       	rjmp	.+736    	; 0xa38 <disk_ioctl+0x36c>
		case CTRL_SYNC :		/* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
			if (select()) {
     758:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <select>
     75c:	00 97       	sbiw	r24, 0x00	; 0
     75e:	09 f4       	brne	.+2      	; 0x762 <disk_ioctl+0x96>
     760:	83 c1       	rjmp	.+774    	; 0xa68 <disk_ioctl+0x39c>
				deselect();
     762:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
				res = RES_OK;
     766:	00 e0       	ldi	r16, 0x00	; 0
     768:	9a c1       	rjmp	.+820    	; 0xa9e <disk_ioctl+0x3d2>
			}
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
     76a:	89 e0       	ldi	r24, 0x09	; 9
     76c:	40 e0       	ldi	r20, 0x00	; 0
     76e:	50 e0       	ldi	r21, 0x00	; 0
     770:	ba 01       	movw	r22, r20
     772:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     776:	88 23       	and	r24, r24
     778:	09 f0       	breq	.+2      	; 0x77c <disk_ioctl+0xb0>
     77a:	78 c1       	rjmp	.+752    	; 0xa6c <disk_ioctl+0x3a0>
     77c:	ce 01       	movw	r24, r28
     77e:	01 96       	adiw	r24, 0x01	; 1
     780:	40 e1       	ldi	r20, 0x10	; 16
     782:	50 e0       	ldi	r21, 0x00	; 0
     784:	60 e0       	ldi	r22, 0x00	; 0
     786:	70 e0       	ldi	r23, 0x00	; 0
     788:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     78c:	00 97       	sbiw	r24, 0x00	; 0
     78e:	09 f4       	brne	.+2      	; 0x792 <disk_ioctl+0xc6>
     790:	6f c1       	rjmp	.+734    	; 0xa70 <disk_ioctl+0x3a4>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
     792:	89 81       	ldd	r24, Y+1	; 0x01
     794:	82 95       	swap	r24
     796:	86 95       	lsr	r24
     798:	86 95       	lsr	r24
     79a:	83 70       	andi	r24, 0x03	; 3
     79c:	81 30       	cpi	r24, 0x01	; 1
     79e:	51 f5       	brne	.+84     	; 0x7f4 <disk_ioctl+0x128>
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
     7a0:	48 85       	ldd	r20, Y+8	; 0x08
     7a2:	50 e0       	ldi	r21, 0x00	; 0
     7a4:	60 e0       	ldi	r22, 0x00	; 0
     7a6:	70 e0       	ldi	r23, 0x00	; 0
     7a8:	4f 73       	andi	r20, 0x3F	; 63
     7aa:	50 70       	andi	r21, 0x00	; 0
     7ac:	60 70       	andi	r22, 0x00	; 0
     7ae:	70 70       	andi	r23, 0x00	; 0
     7b0:	ba 01       	movw	r22, r20
     7b2:	55 27       	eor	r21, r21
     7b4:	44 27       	eor	r20, r20
     7b6:	4f 5f       	subi	r20, 0xFF	; 255
     7b8:	5f 4f       	sbci	r21, 0xFF	; 255
     7ba:	6f 4f       	sbci	r22, 0xFF	; 255
     7bc:	7f 4f       	sbci	r23, 0xFF	; 255
     7be:	99 85       	ldd	r25, Y+9	; 0x09
     7c0:	80 e0       	ldi	r24, 0x00	; 0
     7c2:	2a 85       	ldd	r18, Y+10	; 0x0a
     7c4:	82 0f       	add	r24, r18
     7c6:	91 1d       	adc	r25, r1
     7c8:	a0 e0       	ldi	r26, 0x00	; 0
     7ca:	b0 e0       	ldi	r27, 0x00	; 0
     7cc:	84 0f       	add	r24, r20
     7ce:	95 1f       	adc	r25, r21
     7d0:	a6 1f       	adc	r26, r22
     7d2:	b7 1f       	adc	r27, r23
					*(DWORD*)buff = csize << 10;
     7d4:	07 2e       	mov	r0, r23
     7d6:	7a e0       	ldi	r23, 0x0A	; 10
     7d8:	88 0f       	add	r24, r24
     7da:	99 1f       	adc	r25, r25
     7dc:	aa 1f       	adc	r26, r26
     7de:	bb 1f       	adc	r27, r27
     7e0:	7a 95       	dec	r23
     7e2:	d1 f7       	brne	.-12     	; 0x7d8 <disk_ioctl+0x10c>
     7e4:	70 2d       	mov	r23, r0
     7e6:	f7 01       	movw	r30, r14
     7e8:	80 83       	st	Z, r24
     7ea:	91 83       	std	Z+1, r25	; 0x01
     7ec:	a2 83       	std	Z+2, r26	; 0x02
     7ee:	b3 83       	std	Z+3, r27	; 0x03
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = csize << (n - 9);
				}
				res = RES_OK;
     7f0:	00 e0       	ldi	r16, 0x00	; 0
     7f2:	55 c1       	rjmp	.+682    	; 0xa9e <disk_ioctl+0x3d2>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = csize << 10;
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
     7f4:	29 85       	ldd	r18, Y+9	; 0x09
     7f6:	22 95       	swap	r18
     7f8:	26 95       	lsr	r18
     7fa:	26 95       	lsr	r18
     7fc:	23 70       	andi	r18, 0x03	; 3
     7fe:	88 85       	ldd	r24, Y+8	; 0x08
     800:	90 e0       	ldi	r25, 0x00	; 0
     802:	88 0f       	add	r24, r24
     804:	99 1f       	adc	r25, r25
     806:	88 0f       	add	r24, r24
     808:	99 1f       	adc	r25, r25
     80a:	82 0f       	add	r24, r18
     80c:	91 1d       	adc	r25, r1
     80e:	01 96       	adiw	r24, 0x01	; 1
     810:	2f 81       	ldd	r18, Y+7	; 0x07
     812:	30 e0       	ldi	r19, 0x00	; 0
     814:	23 70       	andi	r18, 0x03	; 3
     816:	30 70       	andi	r19, 0x00	; 0
     818:	32 2f       	mov	r19, r18
     81a:	22 27       	eor	r18, r18
     81c:	33 0f       	add	r19, r19
     81e:	33 0f       	add	r19, r19
     820:	82 0f       	add	r24, r18
     822:	93 1f       	adc	r25, r19
     824:	ac 01       	movw	r20, r24
     826:	60 e0       	ldi	r22, 0x00	; 0
     828:	70 e0       	ldi	r23, 0x00	; 0
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = csize << 10;
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
     82a:	9e 81       	ldd	r25, Y+6	; 0x06
     82c:	9f 70       	andi	r25, 0x0F	; 15
     82e:	8b 85       	ldd	r24, Y+11	; 0x0b
     830:	88 1f       	adc	r24, r24
     832:	88 27       	eor	r24, r24
     834:	88 1f       	adc	r24, r24
     836:	98 0f       	add	r25, r24
     838:	9e 5f       	subi	r25, 0xFE	; 254
     83a:	8a 85       	ldd	r24, Y+10	; 0x0a
     83c:	83 70       	andi	r24, 0x03	; 3
     83e:	88 0f       	add	r24, r24
     840:	89 0f       	add	r24, r25
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = csize << (n - 9);
     842:	90 e0       	ldi	r25, 0x00	; 0
     844:	09 97       	sbiw	r24, 0x09	; 9
     846:	8a 01       	movw	r16, r20
     848:	9b 01       	movw	r18, r22
     84a:	04 c0       	rjmp	.+8      	; 0x854 <disk_ioctl+0x188>
     84c:	00 0f       	add	r16, r16
     84e:	11 1f       	adc	r17, r17
     850:	22 1f       	adc	r18, r18
     852:	33 1f       	adc	r19, r19
     854:	8a 95       	dec	r24
     856:	d2 f7       	brpl	.-12     	; 0x84c <disk_ioctl+0x180>
     858:	f7 01       	movw	r30, r14
     85a:	00 83       	st	Z, r16
     85c:	11 83       	std	Z+1, r17	; 0x01
     85e:	22 83       	std	Z+2, r18	; 0x02
     860:	33 83       	std	Z+3, r19	; 0x03
				}
				res = RES_OK;
     862:	00 e0       	ldi	r16, 0x00	; 0
     864:	1c c1       	rjmp	.+568    	; 0xa9e <disk_ioctl+0x3d2>
			}
			break;

		case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
			*(WORD*)buff = 512;
     866:	80 e0       	ldi	r24, 0x00	; 0
     868:	92 e0       	ldi	r25, 0x02	; 2
     86a:	fa 01       	movw	r30, r20
     86c:	91 83       	std	Z+1, r25	; 0x01
     86e:	80 83       	st	Z, r24
			res = RES_OK;
     870:	00 e0       	ldi	r16, 0x00	; 0
			break;
     872:	15 c1       	rjmp	.+554    	; 0xa9e <disk_ioctl+0x3d2>

		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
			if (CardType & CT_SD2) {	/* SDv2? */
     874:	00 91 22 04 	lds	r16, 0x0422
     878:	02 ff       	sbrs	r16, 2
     87a:	31 c0       	rjmp	.+98     	; 0x8de <disk_ioctl+0x212>
				if (send_cmd(ACMD13, 0) == 0) {	/* Read SD status */
     87c:	8d e8       	ldi	r24, 0x8D	; 141
     87e:	40 e0       	ldi	r20, 0x00	; 0
     880:	50 e0       	ldi	r21, 0x00	; 0
     882:	ba 01       	movw	r22, r20
     884:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     888:	88 23       	and	r24, r24
     88a:	09 f0       	breq	.+2      	; 0x88e <disk_ioctl+0x1c2>
     88c:	f3 c0       	rjmp	.+486    	; 0xa74 <disk_ioctl+0x3a8>
					xchg_spi(0xFF);
     88e:	8f ef       	ldi	r24, 0xFF	; 255
     890:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
					if (rcvr_datablock(csd, 16)) {				/* Read partial block */
     894:	ce 01       	movw	r24, r28
     896:	01 96       	adiw	r24, 0x01	; 1
     898:	40 e1       	ldi	r20, 0x10	; 16
     89a:	50 e0       	ldi	r21, 0x00	; 0
     89c:	60 e0       	ldi	r22, 0x00	; 0
     89e:	70 e0       	ldi	r23, 0x00	; 0
     8a0:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     8a4:	00 97       	sbiw	r24, 0x00	; 0
     8a6:	09 f4       	brne	.+2      	; 0x8aa <disk_ioctl+0x1de>
     8a8:	e7 c0       	rjmp	.+462    	; 0xa78 <disk_ioctl+0x3ac>
     8aa:	00 e3       	ldi	r16, 0x30	; 48
						for (n = 64 - 16; n; n--) xchg_spi(0xFF);	/* Purge trailing data */
     8ac:	8f ef       	ldi	r24, 0xFF	; 255
     8ae:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     8b2:	01 50       	subi	r16, 0x01	; 1
     8b4:	d9 f7       	brne	.-10     	; 0x8ac <disk_ioctl+0x1e0>
						*(DWORD*)buff = 16UL << (csd[10] >> 4);
     8b6:	2b 85       	ldd	r18, Y+11	; 0x0b
     8b8:	22 95       	swap	r18
     8ba:	2f 70       	andi	r18, 0x0F	; 15
     8bc:	80 e1       	ldi	r24, 0x10	; 16
     8be:	90 e0       	ldi	r25, 0x00	; 0
     8c0:	a0 e0       	ldi	r26, 0x00	; 0
     8c2:	b0 e0       	ldi	r27, 0x00	; 0
     8c4:	04 c0       	rjmp	.+8      	; 0x8ce <disk_ioctl+0x202>
     8c6:	88 0f       	add	r24, r24
     8c8:	99 1f       	adc	r25, r25
     8ca:	aa 1f       	adc	r26, r26
     8cc:	bb 1f       	adc	r27, r27
     8ce:	2a 95       	dec	r18
     8d0:	d2 f7       	brpl	.-12     	; 0x8c6 <disk_ioctl+0x1fa>
     8d2:	f7 01       	movw	r30, r14
     8d4:	80 83       	st	Z, r24
     8d6:	91 83       	std	Z+1, r25	; 0x01
     8d8:	a2 83       	std	Z+2, r26	; 0x02
     8da:	b3 83       	std	Z+3, r27	; 0x03
     8dc:	e0 c0       	rjmp	.+448    	; 0xa9e <disk_ioctl+0x3d2>
						res = RES_OK;
					}
				}
			} else {					/* SDv1 or MMCv3 */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
     8de:	89 e0       	ldi	r24, 0x09	; 9
     8e0:	40 e0       	ldi	r20, 0x00	; 0
     8e2:	50 e0       	ldi	r21, 0x00	; 0
     8e4:	ba 01       	movw	r22, r20
     8e6:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     8ea:	88 23       	and	r24, r24
     8ec:	09 f0       	breq	.+2      	; 0x8f0 <disk_ioctl+0x224>
     8ee:	c6 c0       	rjmp	.+396    	; 0xa7c <disk_ioctl+0x3b0>
     8f0:	ce 01       	movw	r24, r28
     8f2:	01 96       	adiw	r24, 0x01	; 1
     8f4:	40 e1       	ldi	r20, 0x10	; 16
     8f6:	50 e0       	ldi	r21, 0x00	; 0
     8f8:	60 e0       	ldi	r22, 0x00	; 0
     8fa:	70 e0       	ldi	r23, 0x00	; 0
     8fc:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     900:	00 97       	sbiw	r24, 0x00	; 0
     902:	09 f4       	brne	.+2      	; 0x906 <disk_ioctl+0x23a>
     904:	bd c0       	rjmp	.+378    	; 0xa80 <disk_ioctl+0x3b4>
					if (CardType & CT_SD1) {	/* SDv1 */
     906:	01 ff       	sbrs	r16, 1
     908:	25 c0       	rjmp	.+74     	; 0x954 <disk_ioctl+0x288>
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
     90a:	8c 85       	ldd	r24, Y+12	; 0x0c
     90c:	88 1f       	adc	r24, r24
     90e:	88 27       	eor	r24, r24
     910:	88 1f       	adc	r24, r24
     912:	90 e0       	ldi	r25, 0x00	; 0
     914:	01 96       	adiw	r24, 0x01	; 1
     916:	2b 85       	ldd	r18, Y+11	; 0x0b
     918:	30 e0       	ldi	r19, 0x00	; 0
     91a:	2f 73       	andi	r18, 0x3F	; 63
     91c:	30 70       	andi	r19, 0x00	; 0
     91e:	22 0f       	add	r18, r18
     920:	33 1f       	adc	r19, r19
     922:	28 0f       	add	r18, r24
     924:	39 1f       	adc	r19, r25
     926:	8e 85       	ldd	r24, Y+14	; 0x0e
     928:	82 95       	swap	r24
     92a:	86 95       	lsr	r24
     92c:	86 95       	lsr	r24
     92e:	83 70       	andi	r24, 0x03	; 3
     930:	90 e0       	ldi	r25, 0x00	; 0
     932:	01 97       	sbiw	r24, 0x01	; 1
     934:	89 01       	movw	r16, r18
     936:	02 c0       	rjmp	.+4      	; 0x93c <disk_ioctl+0x270>
     938:	00 0f       	add	r16, r16
     93a:	11 1f       	adc	r17, r17
     93c:	8a 95       	dec	r24
     93e:	e2 f7       	brpl	.-8      	; 0x938 <disk_ioctl+0x26c>
     940:	c8 01       	movw	r24, r16
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	f7 01       	movw	r30, r14
     948:	80 83       	st	Z, r24
     94a:	91 83       	std	Z+1, r25	; 0x01
     94c:	a2 83       	std	Z+2, r26	; 0x02
     94e:	b3 83       	std	Z+3, r27	; 0x03
					} else {					/* MMCv3 */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
					}
					res = RES_OK;
     950:	00 e0       	ldi	r16, 0x00	; 0
     952:	a5 c0       	rjmp	.+330    	; 0xa9e <disk_ioctl+0x3d2>
			} else {					/* SDv1 or MMCv3 */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
					if (CardType & CT_SD1) {	/* SDv1 */
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
					} else {					/* MMCv3 */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
     954:	8c 85       	ldd	r24, Y+12	; 0x0c
     956:	48 2f       	mov	r20, r24
     958:	50 e0       	ldi	r21, 0x00	; 0
     95a:	43 70       	andi	r20, 0x03	; 3
     95c:	50 70       	andi	r21, 0x00	; 0
     95e:	44 0f       	add	r20, r20
     960:	55 1f       	adc	r21, r21
     962:	44 0f       	add	r20, r20
     964:	55 1f       	adc	r21, r21
     966:	44 0f       	add	r20, r20
     968:	55 1f       	adc	r21, r21
     96a:	82 95       	swap	r24
     96c:	86 95       	lsr	r24
     96e:	87 70       	andi	r24, 0x07	; 7
     970:	48 0f       	add	r20, r24
     972:	51 1d       	adc	r21, r1
     974:	4f 5f       	subi	r20, 0xFF	; 255
     976:	5f 4f       	sbci	r21, 0xFF	; 255
     978:	2b 85       	ldd	r18, Y+11	; 0x0b
     97a:	30 e0       	ldi	r19, 0x00	; 0
     97c:	2c 77       	andi	r18, 0x7C	; 124
     97e:	30 70       	andi	r19, 0x00	; 0
     980:	35 95       	asr	r19
     982:	27 95       	ror	r18
     984:	35 95       	asr	r19
     986:	27 95       	ror	r18
     988:	2f 5f       	subi	r18, 0xFF	; 255
     98a:	3f 4f       	sbci	r19, 0xFF	; 255
     98c:	42 9f       	mul	r20, r18
     98e:	c0 01       	movw	r24, r0
     990:	43 9f       	mul	r20, r19
     992:	90 0d       	add	r25, r0
     994:	52 9f       	mul	r21, r18
     996:	90 0d       	add	r25, r0
     998:	11 24       	eor	r1, r1
     99a:	a0 e0       	ldi	r26, 0x00	; 0
     99c:	b0 e0       	ldi	r27, 0x00	; 0
     99e:	f7 01       	movw	r30, r14
     9a0:	80 83       	st	Z, r24
     9a2:	91 83       	std	Z+1, r25	; 0x01
     9a4:	a2 83       	std	Z+2, r26	; 0x02
     9a6:	b3 83       	std	Z+3, r27	; 0x03
					}
					res = RES_OK;
     9a8:	00 e0       	ldi	r16, 0x00	; 0
     9aa:	79 c0       	rjmp	.+242    	; 0xa9e <disk_ioctl+0x3d2>
				}
			}
			break;

		case MMC_GET_TYPE :		/* Get card type flags (1 byte) */
			*ptr = CardType;
     9ac:	80 91 22 04 	lds	r24, 0x0422
     9b0:	fa 01       	movw	r30, r20
     9b2:	80 83       	st	Z, r24
			res = RES_OK;
     9b4:	00 e0       	ldi	r16, 0x00	; 0
			break;
     9b6:	73 c0       	rjmp	.+230    	; 0xa9e <disk_ioctl+0x3d2>

		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
     9b8:	89 e0       	ldi	r24, 0x09	; 9
     9ba:	40 e0       	ldi	r20, 0x00	; 0
     9bc:	50 e0       	ldi	r21, 0x00	; 0
     9be:	ba 01       	movw	r22, r20
     9c0:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     9c4:	88 23       	and	r24, r24
     9c6:	09 f0       	breq	.+2      	; 0x9ca <disk_ioctl+0x2fe>
     9c8:	5d c0       	rjmp	.+186    	; 0xa84 <disk_ioctl+0x3b8>
				&& rcvr_datablock(ptr, 16))
     9ca:	c7 01       	movw	r24, r14
     9cc:	40 e1       	ldi	r20, 0x10	; 16
     9ce:	50 e0       	ldi	r21, 0x00	; 0
     9d0:	60 e0       	ldi	r22, 0x00	; 0
     9d2:	70 e0       	ldi	r23, 0x00	; 0
     9d4:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     9d8:	00 97       	sbiw	r24, 0x00	; 0
     9da:	09 f0       	breq	.+2      	; 0x9de <disk_ioctl+0x312>
     9dc:	55 c0       	rjmp	.+170    	; 0xa88 <disk_ioctl+0x3bc>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     9de:	01 e0       	ldi	r16, 0x01	; 1
     9e0:	5e c0       	rjmp	.+188    	; 0xa9e <disk_ioctl+0x3d2>
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
			break;

		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
     9e2:	8a e0       	ldi	r24, 0x0A	; 10
     9e4:	40 e0       	ldi	r20, 0x00	; 0
     9e6:	50 e0       	ldi	r21, 0x00	; 0
     9e8:	ba 01       	movw	r22, r20
     9ea:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     9ee:	88 23       	and	r24, r24
     9f0:	09 f0       	breq	.+2      	; 0x9f4 <disk_ioctl+0x328>
     9f2:	4c c0       	rjmp	.+152    	; 0xa8c <disk_ioctl+0x3c0>
				&& rcvr_datablock(ptr, 16))
     9f4:	c7 01       	movw	r24, r14
     9f6:	40 e1       	ldi	r20, 0x10	; 16
     9f8:	50 e0       	ldi	r21, 0x00	; 0
     9fa:	60 e0       	ldi	r22, 0x00	; 0
     9fc:	70 e0       	ldi	r23, 0x00	; 0
     9fe:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     a02:	00 97       	sbiw	r24, 0x00	; 0
     a04:	09 f0       	breq	.+2      	; 0xa08 <disk_ioctl+0x33c>
     a06:	44 c0       	rjmp	.+136    	; 0xa90 <disk_ioctl+0x3c4>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a08:	01 e0       	ldi	r16, 0x01	; 1
     a0a:	49 c0       	rjmp	.+146    	; 0xa9e <disk_ioctl+0x3d2>
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
			break;

		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
			if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
     a0c:	8a e3       	ldi	r24, 0x3A	; 58
     a0e:	40 e0       	ldi	r20, 0x00	; 0
     a10:	50 e0       	ldi	r21, 0x00	; 0
     a12:	ba 01       	movw	r22, r20
     a14:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     a18:	88 23       	and	r24, r24
     a1a:	e1 f5       	brne	.+120    	; 0xa94 <disk_ioctl+0x3c8>
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
/*-----------------------------------------------------------------------*/

#if _USE_IOCTL
DRESULT disk_ioctl (
     a1c:	87 01       	movw	r16, r14
     a1e:	0c 5f       	subi	r16, 0xFC	; 252
     a20:	1f 4f       	sbci	r17, 0xFF	; 255
				res = RES_OK;
			break;

		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
			if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
				for (n = 4; n; n--) *ptr++ = xchg_spi(0xFF);
     a22:	8f ef       	ldi	r24, 0xFF	; 255
     a24:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     a28:	f7 01       	movw	r30, r14
     a2a:	81 93       	st	Z+, r24
     a2c:	7f 01       	movw	r14, r30
     a2e:	e0 17       	cp	r30, r16
     a30:	f1 07       	cpc	r31, r17
     a32:	b9 f7       	brne	.-18     	; 0xa22 <disk_ioctl+0x356>
				res = RES_OK;
     a34:	00 e0       	ldi	r16, 0x00	; 0
     a36:	33 c0       	rjmp	.+102    	; 0xa9e <disk_ioctl+0x3d2>
			}
			break;

		case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
			if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
     a38:	8d e8       	ldi	r24, 0x8D	; 141
     a3a:	40 e0       	ldi	r20, 0x00	; 0
     a3c:	50 e0       	ldi	r21, 0x00	; 0
     a3e:	ba 01       	movw	r22, r20
     a40:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     a44:	88 23       	and	r24, r24
     a46:	41 f5       	brne	.+80     	; 0xa98 <disk_ioctl+0x3cc>
				xchg_spi(0xFF);
     a48:	8f ef       	ldi	r24, 0xFF	; 255
     a4a:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
				if (rcvr_datablock(ptr, 64))
     a4e:	c7 01       	movw	r24, r14
     a50:	40 e4       	ldi	r20, 0x40	; 64
     a52:	50 e0       	ldi	r21, 0x00	; 0
     a54:	60 e0       	ldi	r22, 0x00	; 0
     a56:	70 e0       	ldi	r23, 0x00	; 0
     a58:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     a5c:	00 97       	sbiw	r24, 0x00	; 0
     a5e:	f1 f4       	brne	.+60     	; 0xa9c <disk_ioctl+0x3d0>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a60:	01 e0       	ldi	r16, 0x01	; 1
     a62:	1d c0       	rjmp	.+58     	; 0xa9e <disk_ioctl+0x3d2>
					res = RES_OK;
			}
			break;

		default:
			res = RES_PARERR;
     a64:	04 e0       	ldi	r16, 0x04	; 4
     a66:	1b c0       	rjmp	.+54     	; 0xa9e <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a68:	01 e0       	ldi	r16, 0x01	; 1
     a6a:	19 c0       	rjmp	.+50     	; 0xa9e <disk_ioctl+0x3d2>
     a6c:	01 e0       	ldi	r16, 0x01	; 1
     a6e:	17 c0       	rjmp	.+46     	; 0xa9e <disk_ioctl+0x3d2>
     a70:	01 e0       	ldi	r16, 0x01	; 1
     a72:	15 c0       	rjmp	.+42     	; 0xa9e <disk_ioctl+0x3d2>
     a74:	01 e0       	ldi	r16, 0x01	; 1
     a76:	13 c0       	rjmp	.+38     	; 0xa9e <disk_ioctl+0x3d2>
     a78:	01 e0       	ldi	r16, 0x01	; 1
     a7a:	11 c0       	rjmp	.+34     	; 0xa9e <disk_ioctl+0x3d2>
     a7c:	01 e0       	ldi	r16, 0x01	; 1
     a7e:	0f c0       	rjmp	.+30     	; 0xa9e <disk_ioctl+0x3d2>
     a80:	01 e0       	ldi	r16, 0x01	; 1
     a82:	0d c0       	rjmp	.+26     	; 0xa9e <disk_ioctl+0x3d2>
     a84:	01 e0       	ldi	r16, 0x01	; 1
     a86:	0b c0       	rjmp	.+22     	; 0xa9e <disk_ioctl+0x3d2>
			break;

		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
     a88:	00 e0       	ldi	r16, 0x00	; 0
     a8a:	09 c0       	rjmp	.+18     	; 0xa9e <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a8c:	01 e0       	ldi	r16, 0x01	; 1
     a8e:	07 c0       	rjmp	.+14     	; 0xa9e <disk_ioctl+0x3d2>
			break;

		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
     a90:	00 e0       	ldi	r16, 0x00	; 0
     a92:	05 c0       	rjmp	.+10     	; 0xa9e <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a94:	01 e0       	ldi	r16, 0x01	; 1
     a96:	03 c0       	rjmp	.+6      	; 0xa9e <disk_ioctl+0x3d2>
     a98:	01 e0       	ldi	r16, 0x01	; 1
     a9a:	01 c0       	rjmp	.+2      	; 0xa9e <disk_ioctl+0x3d2>

		case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
			if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
				xchg_spi(0xFF);
				if (rcvr_datablock(ptr, 64))
					res = RES_OK;
     a9c:	00 e0       	ldi	r16, 0x00	; 0

		default:
			res = RES_PARERR;
		}

		deselect();
     a9e:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
     aa2:	05 c0       	rjmp	.+10     	; 0xaae <disk_ioctl+0x3e2>
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	DWORD csize;


	if (drv) return RES_PARERR;
     aa4:	04 e0       	ldi	r16, 0x04	; 4
     aa6:	03 c0       	rjmp	.+6      	; 0xaae <disk_ioctl+0x3e2>
		case 1:		/* Sub control code (POWER_GET) */
			ptr[1] = (BYTE)power_status();
			res = RES_OK;
			break;
		default :
			res = RES_PARERR;
     aa8:	04 e0       	ldi	r16, 0x04	; 4
     aaa:	01 c0       	rjmp	.+2      	; 0xaae <disk_ioctl+0x3e2>
		}
	}
	else {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
     aac:	03 e0       	ldi	r16, 0x03	; 3

		deselect();
	}

	return res;
}
     aae:	80 2f       	mov	r24, r16
     ab0:	60 96       	adiw	r28, 0x10	; 16
     ab2:	0f b6       	in	r0, 0x3f	; 63
     ab4:	f8 94       	cli
     ab6:	de bf       	out	0x3e, r29	; 62
     ab8:	0f be       	out	0x3f, r0	; 63
     aba:	cd bf       	out	0x3d, r28	; 61
     abc:	df 91       	pop	r29
     abe:	cf 91       	pop	r28
     ac0:	1f 91       	pop	r17
     ac2:	0f 91       	pop	r16
     ac4:	ff 90       	pop	r15
     ac6:	ef 90       	pop	r14
     ac8:	08 95       	ret

00000aca <disk_timerproc>:
void disk_timerproc (void)
{
	BYTE n, s;


	n = Timer1;				/* 100Hz decrement timer */
     aca:	80 91 21 04 	lds	r24, 0x0421
	if (n) Timer1 = --n;
     ace:	88 23       	and	r24, r24
     ad0:	19 f0       	breq	.+6      	; 0xad8 <disk_timerproc+0xe>
     ad2:	81 50       	subi	r24, 0x01	; 1
     ad4:	80 93 21 04 	sts	0x0421, r24
	n = Timer2;
     ad8:	80 91 20 04 	lds	r24, 0x0420
	if (n) Timer2 = --n;
     adc:	88 23       	and	r24, r24
     ade:	19 f0       	breq	.+6      	; 0xae6 <disk_timerproc+0x1c>
     ae0:	81 50       	subi	r24, 0x01	; 1
     ae2:	80 93 20 04 	sts	0x0420, r24

	s = Stat;
     ae6:	80 91 8a 01 	lds	r24, 0x018A

	if (SOCKWP)				/* Write protected */
     aea:	18 9b       	sbis	0x03, 0	; 3
     aec:	02 c0       	rjmp	.+4      	; 0xaf2 <disk_timerproc+0x28>
		s |= STA_PROTECT;
     aee:	84 60       	ori	r24, 0x04	; 4
     af0:	01 c0       	rjmp	.+2      	; 0xaf4 <disk_timerproc+0x2a>
	else					/* Write enabled */
		s &= ~STA_PROTECT;
     af2:	8b 7f       	andi	r24, 0xFB	; 251

	if (SOCKINS)			/* Card inserted */
     af4:	19 99       	sbic	0x03, 1	; 3
     af6:	02 c0       	rjmp	.+4      	; 0xafc <disk_timerproc+0x32>
		s &= ~STA_NODISK;
     af8:	8d 7f       	andi	r24, 0xFD	; 253
     afa:	01 c0       	rjmp	.+2      	; 0xafe <disk_timerproc+0x34>
	else					/* Socket empty */
		s |= (STA_NODISK | STA_NOINIT);
     afc:	83 60       	ori	r24, 0x03	; 3

	Stat = s;				/* Update MMC status */
     afe:	80 93 8a 01 	sts	0x018A, r24
}
     b02:	08 95       	ret

00000b04 <__vector_1>:



//ISR for controlling WEN.
ISR(INT0_vect)
{
     b04:	1f 92       	push	r1
     b06:	0f 92       	push	r0
     b08:	0f b6       	in	r0, 0x3f	; 63
     b0a:	0f 92       	push	r0
     b0c:	11 24       	eor	r1, r1
     b0e:	8f 93       	push	r24
	//printf("ISR INT0 Entered\n");
	if (VSYNC_0_Count==1)//start a frame read
     b10:	80 91 2f 04 	lds	r24, 0x042F
     b14:	81 30       	cpi	r24, 0x01	; 1
     b16:	39 f4       	brne	.+14     	; 0xb26 <__vector_1+0x22>
	{
		FIFO_WEN_0_SET;
     b18:	5e 9a       	sbi	0x0b, 6	; 11
		VSYNC_0_Count++;
     b1a:	80 91 2f 04 	lds	r24, 0x042F
     b1e:	8f 5f       	subi	r24, 0xFF	; 255
     b20:	80 93 2f 04 	sts	0x042F, r24
     b24:	14 c0       	rjmp	.+40     	; 0xb4e <__vector_1+0x4a>
	}
	else if (VSYNC_0_Count==2)//end a frame read
     b26:	80 91 2f 04 	lds	r24, 0x042F
     b2a:	82 30       	cpi	r24, 0x02	; 2
     b2c:	39 f4       	brne	.+14     	; 0xb3c <__vector_1+0x38>
	{
		FIFO_WEN_0_CLR;
     b2e:	5e 98       	cbi	0x0b, 6	; 11
		VSYNC_0_Count++;
     b30:	80 91 2f 04 	lds	r24, 0x042F
     b34:	8f 5f       	subi	r24, 0xFF	; 255
     b36:	80 93 2f 04 	sts	0x042F, r24
     b3a:	09 c0       	rjmp	.+18     	; 0xb4e <__vector_1+0x4a>
	}
	else if(VSYNC_0_Count == 3)
     b3c:	80 91 2f 04 	lds	r24, 0x042F
     b40:	83 30       	cpi	r24, 0x03	; 3
     b42:	11 f4       	brne	.+4      	; 0xb48 <__vector_1+0x44>
	{
		FIFO_WEN_0_CLR;
     b44:	5e 98       	cbi	0x0b, 6	; 11
     b46:	03 c0       	rjmp	.+6      	; 0xb4e <__vector_1+0x4a>
	}
	else
	{
		FIFO_WEN_0_CLR
     b48:	5e 98       	cbi	0x0b, 6	; 11
		VSYNC_0_Count = 0;//wait for a read to be started
     b4a:	10 92 2f 04 	sts	0x042F, r1
	}
}
     b4e:	8f 91       	pop	r24
     b50:	0f 90       	pop	r0
     b52:	0f be       	out	0x3f, r0	; 63
     b54:	0f 90       	pop	r0
     b56:	1f 90       	pop	r1
     b58:	18 95       	reti

00000b5a <__vector_2>:
//ISR for controlling WEN.
ISR(INT1_vect)
{
     b5a:	1f 92       	push	r1
     b5c:	0f 92       	push	r0
     b5e:	0f b6       	in	r0, 0x3f	; 63
     b60:	0f 92       	push	r0
     b62:	11 24       	eor	r1, r1
     b64:	8f 93       	push	r24
	//printf("ISR INT1 Entered\n");
	if (VSYNC_1_Count==1)//start a frame read
     b66:	80 91 70 0c 	lds	r24, 0x0C70
     b6a:	81 30       	cpi	r24, 0x01	; 1
     b6c:	39 f4       	brne	.+14     	; 0xb7c <__vector_2+0x22>
	{
		FIFO_WEN_1_SET;
     b6e:	44 9a       	sbi	0x08, 4	; 8
		VSYNC_1_Count++;
     b70:	80 91 70 0c 	lds	r24, 0x0C70
     b74:	8f 5f       	subi	r24, 0xFF	; 255
     b76:	80 93 70 0c 	sts	0x0C70, r24
     b7a:	14 c0       	rjmp	.+40     	; 0xba4 <__vector_2+0x4a>
	}
	else if (VSYNC_1_Count==2)//end a frame read
     b7c:	80 91 70 0c 	lds	r24, 0x0C70
     b80:	82 30       	cpi	r24, 0x02	; 2
     b82:	39 f4       	brne	.+14     	; 0xb92 <__vector_2+0x38>
	{
		FIFO_WEN_1_CLR;
     b84:	44 98       	cbi	0x08, 4	; 8
		VSYNC_1_Count++;
     b86:	80 91 70 0c 	lds	r24, 0x0C70
     b8a:	8f 5f       	subi	r24, 0xFF	; 255
     b8c:	80 93 70 0c 	sts	0x0C70, r24
     b90:	09 c0       	rjmp	.+18     	; 0xba4 <__vector_2+0x4a>
	}
	else if(VSYNC_1_Count == 3)
     b92:	80 91 70 0c 	lds	r24, 0x0C70
     b96:	83 30       	cpi	r24, 0x03	; 3
     b98:	11 f4       	brne	.+4      	; 0xb9e <__vector_2+0x44>
	{
		FIFO_WEN_1_CLR;
     b9a:	44 98       	cbi	0x08, 4	; 8
     b9c:	03 c0       	rjmp	.+6      	; 0xba4 <__vector_2+0x4a>
	}
	else
	{
		FIFO_WEN_1_CLR
     b9e:	44 98       	cbi	0x08, 4	; 8
		VSYNC_1_Count = 0;//wait for a read to be started
     ba0:	10 92 70 0c 	sts	0x0C70, r1
	}
}
     ba4:	8f 91       	pop	r24
     ba6:	0f 90       	pop	r0
     ba8:	0f be       	out	0x3f, r0	; 63
     baa:	0f 90       	pop	r0
     bac:	1f 90       	pop	r1
     bae:	18 95       	reti

00000bb0 <wrOV7670Reg>:

//Write Register Method
unsigned char wrOV7670Reg(unsigned char regID, unsigned char regDat)
{
     bb0:	cf 93       	push	r28
     bb2:	df 93       	push	r29
     bb4:	00 d0       	rcall	.+0      	; 0xbb6 <wrOV7670Reg+0x6>
     bb6:	00 d0       	rcall	.+0      	; 0xbb8 <wrOV7670Reg+0x8>
     bb8:	cd b7       	in	r28, 0x3d	; 61
     bba:	de b7       	in	r29, 0x3e	; 62
	/*	I2C Traffic Generated:
	 *	S | OV_7670 + W | A | RegID | A | Data | A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE];
	messageBuf[0] = (OV7670_ADDR  <<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consit of General Call code or the TWI slave address.
     bbc:	92 e4       	ldi	r25, 0x42	; 66
     bbe:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for commands.
     bc0:	8a 83       	std	Y+2, r24	; 0x02
	messageBuf[2] = regDat;                        // The second byte is used for the data.
     bc2:	6b 83       	std	Y+3, r22	; 0x03
	TWI_Start_Transceiver_With_Data( messageBuf, 3 );
     bc4:	ce 01       	movw	r24, r28
     bc6:	01 96       	adiw	r24, 0x01	; 1
     bc8:	63 e0       	ldi	r22, 0x03	; 3
     bca:	0e 94 db 29 	call	0x53b6	; 0x53b6 <TWI_Start_Transceiver_With_Data>
	
	while(TWI_Transceiver_Busy()) ; //Wait for transceiver to clear
     bce:	0e 94 d0 29 	call	0x53a0	; 0x53a0 <TWI_Transceiver_Busy>
     bd2:	88 23       	and	r24, r24
     bd4:	e1 f7       	brne	.-8      	; 0xbce <wrOV7670Reg+0x1e>
	
	return TWI_statusReg.lastTransOK;
     bd6:	80 91 28 04 	lds	r24, 0x0428
}
     bda:	81 70       	andi	r24, 0x01	; 1
     bdc:	0f 90       	pop	r0
     bde:	0f 90       	pop	r0
     be0:	0f 90       	pop	r0
     be2:	0f 90       	pop	r0
     be4:	df 91       	pop	r29
     be6:	cf 91       	pop	r28
     be8:	08 95       	ret

00000bea <rdOV7670Reg>:

//Read Register Method
unsigned char rdOV7670Reg(unsigned char regID, unsigned char *regDat)
{
     bea:	0f 93       	push	r16
     bec:	1f 93       	push	r17
     bee:	cf 93       	push	r28
     bf0:	df 93       	push	r29
     bf2:	00 d0       	rcall	.+0      	; 0xbf4 <rdOV7670Reg+0xa>
     bf4:	00 d0       	rcall	.+0      	; 0xbf6 <rdOV7670Reg+0xc>
     bf6:	cd b7       	in	r28, 0x3d	; 61
     bf8:	de b7       	in	r29, 0x3e	; 62
     bfa:	8b 01       	movw	r16, r22
	 *	S	|	OV_ADDR + W	| A | RegID | A | P |
	 *	S	|	OV_ADDR + R | A | Data	|~A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE]; //Initialise a buffer
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
     bfc:	92 e4       	ldi	r25, 0x42	; 66
     bfe:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for Address Pointer.
     c00:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
     c02:	ce 01       	movw	r24, r28
     c04:	01 96       	adiw	r24, 0x01	; 1
     c06:	62 e0       	ldi	r22, 0x02	; 2
     c08:	0e 94 db 29 	call	0x53b6	; 0x53b6 <TWI_Start_Transceiver_With_Data>
	
	// Request/collect the data from the Slave
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
     c0c:	83 e4       	ldi	r24, 0x43	; 67
     c0e:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );              
     c10:	ce 01       	movw	r24, r28
     c12:	01 96       	adiw	r24, 0x01	; 1
     c14:	62 e0       	ldi	r22, 0x02	; 2
     c16:	0e 94 db 29 	call	0x53b6	; 0x53b6 <TWI_Start_Transceiver_With_Data>
    
	// Get the received data from the transceiver buffer
	TWI_Get_Data_From_Transceiver( messageBuf, 2 );
     c1a:	ce 01       	movw	r24, r28
     c1c:	01 96       	adiw	r24, 0x01	; 1
     c1e:	62 e0       	ldi	r22, 0x02	; 2
     c20:	0e 94 11 2a 	call	0x5422	; 0x5422 <TWI_Get_Data_From_Transceiver>
	*regDat = messageBuf[1];       
     c24:	8a 81       	ldd	r24, Y+2	; 0x02
     c26:	f8 01       	movw	r30, r16
     c28:	80 83       	st	Z, r24
	return TWI_statusReg.lastTransOK;
     c2a:	80 91 28 04 	lds	r24, 0x0428
}
     c2e:	81 70       	andi	r24, 0x01	; 1
     c30:	0f 90       	pop	r0
     c32:	0f 90       	pop	r0
     c34:	0f 90       	pop	r0
     c36:	0f 90       	pop	r0
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	1f 91       	pop	r17
     c3e:	0f 91       	pop	r16
     c40:	08 95       	ret

00000c42 <OV7670_init>:


unsigned char OV7670_init()
{
     c42:	0f 93       	push	r16
     c44:	1f 93       	push	r17
     c46:	cf 93       	push	r28
     c48:	df 93       	push	r29
	uint8_t i = 0;
	if(0==wrOV7670Reg(OV_COM7, 0x80)) //Reset Camera
     c4a:	82 e1       	ldi	r24, 0x12	; 18
     c4c:	60 e8       	ldi	r22, 0x80	; 128
     c4e:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <wrOV7670Reg>
     c52:	88 23       	and	r24, r24
     c54:	f1 f0       	breq	.+60     	; 0xc92 <OV7670_init+0x50>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     c56:	8f e2       	ldi	r24, 0x2F	; 47
     c58:	95 e7       	ldi	r25, 0x75	; 117
     c5a:	01 97       	sbiw	r24, 0x01	; 1
     c5c:	f1 f7       	brne	.-4      	; 0xc5a <OV7670_init+0x18>
     c5e:	00 c0       	rjmp	.+0      	; 0xc60 <OV7670_init+0x1e>
     c60:	00 00       	nop
     c62:	cc e8       	ldi	r28, 0x8C	; 140
     c64:	d1 e0       	ldi	r29, 0x01	; 1
	*regDat = messageBuf[1];       
	return TWI_statusReg.lastTransOK;
}


unsigned char OV7670_init()
     c66:	0a ed       	ldi	r16, 0xDA	; 218
     c68:	12 e0       	ldi	r17, 0x02	; 2
     c6a:	fe 01       	movw	r30, r28
     c6c:	31 97       	sbiw	r30, 0x01	; 1
		return 1;
	}
	_delay_ms(10);
	for(i=0; i<SETTINGS_LENGTH; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
     c6e:	80 81       	ld	r24, Z
     c70:	68 81       	ld	r22, Y
     c72:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <wrOV7670Reg>
     c76:	88 23       	and	r24, r24
     c78:	71 f0       	breq	.+28     	; 0xc96 <OV7670_init+0x54>
     c7a:	87 eb       	ldi	r24, 0xB7	; 183
     c7c:	9b e0       	ldi	r25, 0x0B	; 11
     c7e:	01 97       	sbiw	r24, 0x01	; 1
     c80:	f1 f7       	brne	.-4      	; 0xc7e <OV7670_init+0x3c>
     c82:	00 c0       	rjmp	.+0      	; 0xc84 <OV7670_init+0x42>
     c84:	00 00       	nop
     c86:	22 96       	adiw	r28, 0x02	; 2
	if(0==wrOV7670Reg(OV_COM7, 0x80)) //Reset Camera
	{
		return 1;
	}
	_delay_ms(10);
	for(i=0; i<SETTINGS_LENGTH; i++)
     c88:	c0 17       	cp	r28, r16
     c8a:	d1 07       	cpc	r29, r17
     c8c:	71 f7       	brne	.-36     	; 0xc6a <OV7670_init+0x28>
			return 1;
		}
		_delay_ms(1);
	}
	
	return 0;
     c8e:	80 e0       	ldi	r24, 0x00	; 0
     c90:	03 c0       	rjmp	.+6      	; 0xc98 <OV7670_init+0x56>
unsigned char OV7670_init()
{
	uint8_t i = 0;
	if(0==wrOV7670Reg(OV_COM7, 0x80)) //Reset Camera
	{
		return 1;
     c92:	81 e0       	ldi	r24, 0x01	; 1
     c94:	01 c0       	rjmp	.+2      	; 0xc98 <OV7670_init+0x56>
	_delay_ms(10);
	for(i=0; i<SETTINGS_LENGTH; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
		{
			return 1;
     c96:	81 e0       	ldi	r24, 0x01	; 1
		}
		_delay_ms(1);
	}
	
	return 0;
}
     c98:	df 91       	pop	r29
     c9a:	cf 91       	pop	r28
     c9c:	1f 91       	pop	r17
     c9e:	0f 91       	pop	r16
     ca0:	08 95       	ret

00000ca2 <FIFO_init>:

void FIFO_init( void )
{
	//disable both outputs
	FIFO_nOE_0_SET;
     ca2:	46 9a       	sbi	0x08, 6	; 8
	FIFO_nOE_1_SET;
     ca4:	47 9a       	sbi	0x08, 7	; 8
	//Reset Buffer 0
	FIFO_WRST_0_CLR;
     ca6:	5f 98       	cbi	0x0b, 7	; 11
	FIFO_RCLK_0_CLR;
     ca8:	5c 98       	cbi	0x0b, 4	; 11
	//FIFO_nOE_0_CLR;
	FIFO_nRRST_0_SET;
     caa:	5d 9a       	sbi	0x0b, 5	; 11
	FIFO_WEN_0_CLR;
     cac:	5e 98       	cbi	0x0b, 6	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     cae:	88 e2       	ldi	r24, 0x28	; 40
     cb0:	8a 95       	dec	r24
     cb2:	f1 f7       	brne	.-4      	; 0xcb0 <FIFO_init+0xe>
	_delay_us(10);
	FIFO_RCLK_0_SET;
     cb4:	5c 9a       	sbi	0x0b, 4	; 11
     cb6:	88 e2       	ldi	r24, 0x28	; 40
     cb8:	8a 95       	dec	r24
     cba:	f1 f7       	brne	.-4      	; 0xcb8 <FIFO_init+0x16>
	_delay_us(10);
	FIFO_RCLK_0_CLR;
     cbc:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_0_CLR;
     cbe:	5d 98       	cbi	0x0b, 5	; 11
     cc0:	88 e2       	ldi	r24, 0x28	; 40
     cc2:	8a 95       	dec	r24
     cc4:	f1 f7       	brne	.-4      	; 0xcc2 <FIFO_init+0x20>
	_delay_us(10);
	FIFO_RCLK_0_SET;
     cc6:	5c 9a       	sbi	0x0b, 4	; 11
     cc8:	88 e2       	ldi	r24, 0x28	; 40
     cca:	8a 95       	dec	r24
     ccc:	f1 f7       	brne	.-4      	; 0xcca <FIFO_init+0x28>
	_delay_us(10);
	FIFO_RCLK_0_CLR;
     cce:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_0_SET;
     cd0:	5d 9a       	sbi	0x0b, 5	; 11
     cd2:	88 e2       	ldi	r24, 0x28	; 40
     cd4:	8a 95       	dec	r24
     cd6:	f1 f7       	brne	.-4      	; 0xcd4 <FIFO_init+0x32>
	_delay_us(10);
	FIFO_WRST_0_SET;
     cd8:	5f 9a       	sbi	0x0b, 7	; 11
	
	//Reset Buffer 1
	FIFO_WRST_1_CLR;
     cda:	45 98       	cbi	0x08, 5	; 8
	FIFO_RCLK_1_CLR;
     cdc:	42 98       	cbi	0x08, 2	; 8
	//FIFO_nOE_1_CLR;
	FIFO_nRRST_1_SET;
     cde:	43 9a       	sbi	0x08, 3	; 8
	FIFO_WEN_1_CLR;
     ce0:	44 98       	cbi	0x08, 4	; 8
     ce2:	88 e2       	ldi	r24, 0x28	; 40
     ce4:	8a 95       	dec	r24
     ce6:	f1 f7       	brne	.-4      	; 0xce4 <FIFO_init+0x42>
	_delay_us(10);
	FIFO_RCLK_1_SET;
     ce8:	42 9a       	sbi	0x08, 2	; 8
     cea:	88 e2       	ldi	r24, 0x28	; 40
     cec:	8a 95       	dec	r24
     cee:	f1 f7       	brne	.-4      	; 0xcec <FIFO_init+0x4a>
	_delay_us(10);
	FIFO_RCLK_1_CLR;
     cf0:	42 98       	cbi	0x08, 2	; 8
	FIFO_nRRST_1_CLR;
     cf2:	43 98       	cbi	0x08, 3	; 8
     cf4:	88 e2       	ldi	r24, 0x28	; 40
     cf6:	8a 95       	dec	r24
     cf8:	f1 f7       	brne	.-4      	; 0xcf6 <FIFO_init+0x54>
	_delay_us(10);
	FIFO_RCLK_1_SET;
     cfa:	42 9a       	sbi	0x08, 2	; 8
     cfc:	88 e2       	ldi	r24, 0x28	; 40
     cfe:	8a 95       	dec	r24
     d00:	f1 f7       	brne	.-4      	; 0xcfe <FIFO_init+0x5c>
	_delay_us(10);
	FIFO_RCLK_1_CLR;
     d02:	42 98       	cbi	0x08, 2	; 8
	FIFO_nRRST_1_SET;
     d04:	43 9a       	sbi	0x08, 3	; 8
     d06:	88 e2       	ldi	r24, 0x28	; 40
     d08:	8a 95       	dec	r24
     d0a:	f1 f7       	brne	.-4      	; 0xd08 <FIFO_init+0x66>
	_delay_us(10);
	FIFO_WRST_1_SET;
     d0c:	45 9a       	sbi	0x08, 5	; 8

}
     d0e:	08 95       	ret

00000d10 <FIFO_TO_AVR>:
//Write one pixel in AVR
uint16_t FIFO_TO_AVR(uint8_t ID)
{
	uint16_t data = 0;
	
	DDRA = 0;
     d10:	11 b8       	out	0x01, r1	; 1
	if(ID == 1)
     d12:	81 30       	cpi	r24, 0x01	; 1
     d14:	61 f4       	brne	.+24     	; 0xd2e <FIFO_TO_AVR+0x1e>
	{
		FIFO_RCLK_1_SET;
     d16:	42 9a       	sbi	0x08, 2	; 8
		data = PINA;
     d18:	80 b1       	in	r24, 0x00	; 0
		FIFO_RCLK_1_CLR;
     d1a:	42 98       	cbi	0x08, 2	; 8
		data <<= 8;
     d1c:	38 2f       	mov	r19, r24
     d1e:	20 e0       	ldi	r18, 0x00	; 0
		FIFO_RCLK_1_SET;
     d20:	42 9a       	sbi	0x08, 2	; 8
		data |= PINA;
     d22:	80 b1       	in	r24, 0x00	; 0
     d24:	90 e0       	ldi	r25, 0x00	; 0
     d26:	82 2b       	or	r24, r18
     d28:	93 2b       	or	r25, r19
		FIFO_RCLK_1_CLR;
     d2a:	42 98       	cbi	0x08, 2	; 8
     d2c:	08 95       	ret
	}		
	else
	{	
		FIFO_RCLK_0_SET;
     d2e:	5c 9a       	sbi	0x0b, 4	; 11
		data = PINA;
     d30:	80 b1       	in	r24, 0x00	; 0
		FIFO_RCLK_0_CLR;
     d32:	5c 98       	cbi	0x0b, 4	; 11
		data <<= 8;
     d34:	38 2f       	mov	r19, r24
     d36:	20 e0       	ldi	r18, 0x00	; 0
		FIFO_RCLK_0_SET;
     d38:	5c 9a       	sbi	0x0b, 4	; 11
		data |= PINA;
     d3a:	80 b1       	in	r24, 0x00	; 0
     d3c:	90 e0       	ldi	r25, 0x00	; 0
     d3e:	82 2b       	or	r24, r18
     d40:	93 2b       	or	r25, r19
		FIFO_RCLK_0_CLR;
     d42:	5c 98       	cbi	0x0b, 4	; 11
	}		
	return(data);
}
     d44:	08 95       	ret

00000d46 <FIFO_Reset>:


//Resets both pointers
void FIFO_Reset(uint8_t CameraID)
{
	FIFO_nOE_0_SET;	
     d46:	46 9a       	sbi	0x08, 6	; 8
	FIFO_nOE_1_SET;
     d48:	47 9a       	sbi	0x08, 7	; 8
	if(CameraID == 0)
     d4a:	88 23       	and	r24, r24
     d4c:	39 f4       	brne	.+14     	; 0xd5c <FIFO_Reset+0x16>
	{
		FIFO_WRST_0_CLR;
     d4e:	5f 98       	cbi	0x0b, 7	; 11
		FIFO_nRRST_0_CLR;
     d50:	5d 98       	cbi	0x0b, 5	; 11
		FIFO_RCLK_0_SET;
     d52:	5c 9a       	sbi	0x0b, 4	; 11
		FIFO_RCLK_0_CLR;
     d54:	5c 98       	cbi	0x0b, 4	; 11
		FIFO_nRRST_0_SET;
     d56:	5d 9a       	sbi	0x0b, 5	; 11
		FIFO_WRST_0_SET;
     d58:	5f 9a       	sbi	0x0b, 7	; 11
     d5a:	08 95       	ret
	}
	else
	{
		FIFO_WRST_1_CLR;
     d5c:	45 98       	cbi	0x08, 5	; 8
		FIFO_nRRST_1_CLR;
     d5e:	43 98       	cbi	0x08, 3	; 8
		FIFO_RCLK_1_SET;
     d60:	42 9a       	sbi	0x08, 2	; 8
		FIFO_RCLK_1_CLR;
     d62:	42 98       	cbi	0x08, 2	; 8
		FIFO_nRRST_1_SET;
     d64:	43 9a       	sbi	0x08, 3	; 8
		FIFO_WRST_1_SET;
     d66:	45 9a       	sbi	0x08, 5	; 8
     d68:	08 95       	ret

00000d6a <LoadImagesToBuffer>:
	}
	
}
void LoadImagesToBuffer()
{
	VSYNC_0_Count = 0;
     d6a:	10 92 2f 04 	sts	0x042F, r1
	VSYNC_1_Count = 0;
     d6e:	10 92 70 0c 	sts	0x0C70, r1
	FIFO_Reset(0);
     d72:	80 e0       	ldi	r24, 0x00	; 0
     d74:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
	FIFO_Reset(1);
     d78:	81 e0       	ldi	r24, 0x01	; 1
     d7a:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
	VSYNC_0_Count = 1;
     d7e:	81 e0       	ldi	r24, 0x01	; 1
     d80:	80 93 2f 04 	sts	0x042F, r24
	VSYNC_1_Count = 1;
     d84:	80 93 70 0c 	sts	0x0C70, r24
	
}
     d88:	08 95       	ret

00000d8a <GetImageIfAvailiable>:
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
{
     d8a:	2f 92       	push	r2
     d8c:	3f 92       	push	r3
     d8e:	4f 92       	push	r4
     d90:	5f 92       	push	r5
     d92:	6f 92       	push	r6
     d94:	7f 92       	push	r7
     d96:	8f 92       	push	r8
     d98:	9f 92       	push	r9
     d9a:	af 92       	push	r10
     d9c:	bf 92       	push	r11
     d9e:	cf 92       	push	r12
     da0:	df 92       	push	r13
     da2:	ff 92       	push	r15
     da4:	0f 93       	push	r16
     da6:	1f 93       	push	r17
     da8:	cf 93       	push	r28
     daa:	df 93       	push	r29
     dac:	00 d0       	rcall	.+0      	; 0xdae <GetImageIfAvailiable+0x24>
     dae:	00 d0       	rcall	.+0      	; 0xdb0 <GetImageIfAvailiable+0x26>
     db0:	cd b7       	in	r28, 0x3d	; 61
     db2:	de b7       	in	r29, 0x3e	; 62
     db4:	3c 01       	movw	r6, r24
     db6:	f6 2e       	mov	r15, r22

	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
     db8:	66 23       	and	r22, r22
     dba:	31 f4       	brne	.+12     	; 0xdc8 <GetImageIfAvailiable+0x3e>
     dbc:	80 91 2f 04 	lds	r24, 0x042F
     dc0:	83 30       	cpi	r24, 0x03	; 3
     dc2:	69 f0       	breq	.+26     	; 0xdde <GetImageIfAvailiable+0x54>
		FIFO_nOE_1_SET;
		return 0;
	}
	else
	{
		return 2;
     dc4:	82 e0       	ldi	r24, 0x02	; 2
     dc6:	78 c0       	rjmp	.+240    	; 0xeb8 <GetImageIfAvailiable+0x12e>
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
{

	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
     dc8:	81 e0       	ldi	r24, 0x01	; 1
     dca:	68 17       	cp	r22, r24
     dcc:	09 f0       	breq	.+2      	; 0xdd0 <GetImageIfAvailiable+0x46>
     dce:	73 c0       	rjmp	.+230    	; 0xeb6 <GetImageIfAvailiable+0x12c>
		((CameraID == 1) && (VSYNC_1_Count == 3)) )
     dd0:	80 91 70 0c 	lds	r24, 0x0C70
     dd4:	83 30       	cpi	r24, 0x03	; 3
     dd6:	09 f4       	brne	.+2      	; 0xdda <GetImageIfAvailiable+0x50>
     dd8:	85 c0       	rjmp	.+266    	; 0xee4 <GetImageIfAvailiable+0x15a>
		FIFO_nOE_1_SET;
		return 0;
	}
	else
	{
		return 2;
     dda:	82 e0       	ldi	r24, 0x02	; 2
     ddc:	6d c0       	rjmp	.+218    	; 0xeb8 <GetImageIfAvailiable+0x12e>
	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
		((CameraID == 1) && (VSYNC_1_Count == 3)) )
	{
		
		//Write Bitmap Headers
		WriteBMPHeader(File);
     dde:	c3 01       	movw	r24, r6
     de0:	0e 94 5d 00 	call	0xba	; 0xba <WriteBMPHeader>
		WriteDIBHeader(File);
     de4:	c3 01       	movw	r24, r6
     de6:	0e 94 80 00 	call	0x100	; 0x100 <WriteDIBHeader>
		if (CameraID == 0)
		{
			//Enable output of Camera 0
			FIFO_nOE_0_CLR;
     dea:	46 98       	cbi	0x08, 6	; 8
			//Reset Read Pointer
			FIFO_nRRST_0_CLR;
     dec:	5d 98       	cbi	0x0b, 5	; 11
			FIFO_RCLK_0_SET;
     dee:	5c 9a       	sbi	0x0b, 4	; 11
			FIFO_RCLK_0_CLR;
     df0:	5c 98       	cbi	0x0b, 4	; 11
			FIFO_nRRST_0_SET;
     df2:	5d 9a       	sbi	0x0b, 5	; 11
	VSYNC_0_Count = 1;
	VSYNC_1_Count = 1;
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
{
     df4:	0f 2e       	mov	r0, r31
     df6:	fa e8       	ldi	r31, 0x8A	; 138
     df8:	8f 2e       	mov	r8, r31
     dfa:	f0 e0       	ldi	r31, 0x00	; 0
     dfc:	9f 2e       	mov	r9, r31
     dfe:	f0 e0       	ldi	r31, 0x00	; 0
     e00:	af 2e       	mov	r10, r31
     e02:	f0 e0       	ldi	r31, 0x00	; 0
     e04:	bf 2e       	mov	r11, r31
     e06:	f0 2d       	mov	r31, r0
		uint32_t pointer;
		uint16_t Temp;
		uint32_t p;
		FRESULT fr;
		//for(j = HEIGHT; j>0; j--)
		for(j = 0; j < HEIGHT; j++)
     e08:	0f 2e       	mov	r0, r31
     e0a:	f1 e7       	ldi	r31, 0x71	; 113
     e0c:	4f 2e       	mov	r4, r31
     e0e:	f8 e0       	ldi	r31, 0x08	; 8
     e10:	5f 2e       	mov	r5, r31
     e12:	f0 2d       	mov	r31, r0
	FIFO_Reset(1);
	VSYNC_0_Count = 1;
	VSYNC_1_Count = 1;
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
     e14:	0f 2e       	mov	r0, r31
     e16:	f1 ef       	ldi	r31, 0xF1	; 241
     e18:	cf 2e       	mov	r12, r31
     e1a:	fa e0       	ldi	r31, 0x0A	; 10
     e1c:	df 2e       	mov	r13, r31
     e1e:	f0 2d       	mov	r31, r0
				Buff[pointer++] = (uint8_t)(Temp >> 8);
				Buff[pointer++] = (uint8_t)Temp;
			}
			pointer = (uint32_t)j * (uint32_t)WIDTH * 2 + BMPHEADERSIZE + DIBHEADERSIZE;
			f_lseek(File, pointer);
			fr = f_write(File, Buff, WIDTH * 2, &p);
     e20:	0f 2e       	mov	r0, r31
     e22:	f0 e7       	ldi	r31, 0x70	; 112
     e24:	2f 2e       	mov	r2, r31
     e26:	f8 e0       	ldi	r31, 0x08	; 8
     e28:	3f 2e       	mov	r3, r31
     e2a:	f0 2d       	mov	r31, r0
     e2c:	3b c0       	rjmp	.+118    	; 0xea4 <GetImageIfAvailiable+0x11a>
		for(j = 0; j < HEIGHT; j++)
		{
			pointer = 0;
			for(i = 0; i < WIDTH; i++)
			{
				Temp = FIFO_TO_AVR(CameraID);
     e2e:	8f 2d       	mov	r24, r15
     e30:	0e 94 88 06 	call	0xd10	; 0xd10 <FIFO_TO_AVR>
	FIFO_Reset(1);
	VSYNC_0_Count = 1;
	VSYNC_1_Count = 1;
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
     e34:	f8 01       	movw	r30, r16
     e36:	31 97       	sbiw	r30, 0x01	; 1
			for(i = 0; i < WIDTH; i++)
			{
				Temp = FIFO_TO_AVR(CameraID);
				//USART0_Senduint16(Temp);
				
				Buff[pointer++] = (uint8_t)(Temp >> 8);
     e38:	90 83       	st	Z, r25
				Buff[pointer++] = (uint8_t)Temp;
     e3a:	d8 01       	movw	r26, r16
     e3c:	8c 93       	st	X, r24
     e3e:	0e 5f       	subi	r16, 0xFE	; 254
     e40:	1f 4f       	sbci	r17, 0xFF	; 255
		FRESULT fr;
		//for(j = HEIGHT; j>0; j--)
		for(j = 0; j < HEIGHT; j++)
		{
			pointer = 0;
			for(i = 0; i < WIDTH; i++)
     e42:	0c 15       	cp	r16, r12
     e44:	1d 05       	cpc	r17, r13
     e46:	99 f7       	brne	.-26     	; 0xe2e <GetImageIfAvailiable+0xa4>
				
				Buff[pointer++] = (uint8_t)(Temp >> 8);
				Buff[pointer++] = (uint8_t)Temp;
			}
			pointer = (uint32_t)j * (uint32_t)WIDTH * 2 + BMPHEADERSIZE + DIBHEADERSIZE;
			f_lseek(File, pointer);
     e48:	c3 01       	movw	r24, r6
     e4a:	b5 01       	movw	r22, r10
     e4c:	a4 01       	movw	r20, r8
     e4e:	0e 94 df 20 	call	0x41be	; 0x41be <f_lseek>
			fr = f_write(File, Buff, WIDTH * 2, &p);
     e52:	c3 01       	movw	r24, r6
     e54:	b1 01       	movw	r22, r2
     e56:	20 e8       	ldi	r18, 0x80	; 128
     e58:	32 e0       	ldi	r19, 0x02	; 2
     e5a:	40 e0       	ldi	r20, 0x00	; 0
     e5c:	50 e0       	ldi	r21, 0x00	; 0
     e5e:	8e 01       	movw	r16, r28
     e60:	0f 5f       	subi	r16, 0xFF	; 255
     e62:	1f 4f       	sbci	r17, 0xFF	; 255
     e64:	0e 94 ba 1d 	call	0x3b74	; 0x3b74 <f_write>
			if(fr != FR_OK)
     e68:	88 23       	and	r24, r24
     e6a:	59 f0       	breq	.+22     	; 0xe82 <GetImageIfAvailiable+0xf8>
			{
				//printf("Write Fail.\n");
				VSYNC_0_Count = 0;
     e6c:	10 92 2f 04 	sts	0x042F, r1
				VSYNC_1_Count = 0;
     e70:	10 92 70 0c 	sts	0x0C70, r1
				FIFO_Reset(CameraID);
     e74:	8f 2d       	mov	r24, r15
     e76:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
				FIFO_nOE_0_SET;
     e7a:	46 9a       	sbi	0x08, 6	; 8
				FIFO_nOE_1_SET;
     e7c:	47 9a       	sbi	0x08, 7	; 8
				return 1;
     e7e:	81 e0       	ldi	r24, 0x01	; 1
     e80:	1b c0       	rjmp	.+54     	; 0xeb8 <GetImageIfAvailiable+0x12e>
     e82:	80 e8       	ldi	r24, 0x80	; 128
     e84:	92 e0       	ldi	r25, 0x02	; 2
     e86:	a0 e0       	ldi	r26, 0x00	; 0
     e88:	b0 e0       	ldi	r27, 0x00	; 0
     e8a:	88 0e       	add	r8, r24
     e8c:	99 1e       	adc	r9, r25
     e8e:	aa 1e       	adc	r10, r26
     e90:	bb 1e       	adc	r11, r27
		uint32_t pointer;
		uint16_t Temp;
		uint32_t p;
		FRESULT fr;
		//for(j = HEIGHT; j>0; j--)
		for(j = 0; j < HEIGHT; j++)
     e92:	9a e8       	ldi	r25, 0x8A	; 138
     e94:	89 16       	cp	r8, r25
     e96:	98 e5       	ldi	r25, 0x58	; 88
     e98:	99 06       	cpc	r9, r25
     e9a:	92 e0       	ldi	r25, 0x02	; 2
     e9c:	a9 06       	cpc	r10, r25
     e9e:	90 e0       	ldi	r25, 0x00	; 0
     ea0:	b9 06       	cpc	r11, r25
     ea2:	11 f0       	breq	.+4      	; 0xea8 <GetImageIfAvailiable+0x11e>
     ea4:	82 01       	movw	r16, r4
     ea6:	c3 cf       	rjmp	.-122    	; 0xe2e <GetImageIfAvailiable+0xa4>
				FIFO_nOE_0_SET;
				FIFO_nOE_1_SET;
				return 1;
			}
		}
		FIFO_Reset(CameraID);
     ea8:	8f 2d       	mov	r24, r15
     eaa:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
		//fr = f_close(File);
		FIFO_nOE_0_SET;
     eae:	46 9a       	sbi	0x08, 6	; 8
		FIFO_nOE_1_SET;
     eb0:	47 9a       	sbi	0x08, 7	; 8
		return 0;
     eb2:	80 e0       	ldi	r24, 0x00	; 0
     eb4:	01 c0       	rjmp	.+2      	; 0xeb8 <GetImageIfAvailiable+0x12e>
	}
	else
	{
		return 2;
     eb6:	82 e0       	ldi	r24, 0x02	; 2
	}
}
     eb8:	0f 90       	pop	r0
     eba:	0f 90       	pop	r0
     ebc:	0f 90       	pop	r0
     ebe:	0f 90       	pop	r0
     ec0:	df 91       	pop	r29
     ec2:	cf 91       	pop	r28
     ec4:	1f 91       	pop	r17
     ec6:	0f 91       	pop	r16
     ec8:	ff 90       	pop	r15
     eca:	df 90       	pop	r13
     ecc:	cf 90       	pop	r12
     ece:	bf 90       	pop	r11
     ed0:	af 90       	pop	r10
     ed2:	9f 90       	pop	r9
     ed4:	8f 90       	pop	r8
     ed6:	7f 90       	pop	r7
     ed8:	6f 90       	pop	r6
     eda:	5f 90       	pop	r5
     edc:	4f 90       	pop	r4
     ede:	3f 90       	pop	r3
     ee0:	2f 90       	pop	r2
     ee2:	08 95       	ret
	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
		((CameraID == 1) && (VSYNC_1_Count == 3)) )
	{
		
		//Write Bitmap Headers
		WriteBMPHeader(File);
     ee4:	c3 01       	movw	r24, r6
     ee6:	0e 94 5d 00 	call	0xba	; 0xba <WriteBMPHeader>
		WriteDIBHeader(File);
     eea:	c3 01       	movw	r24, r6
     eec:	0e 94 80 00 	call	0x100	; 0x100 <WriteDIBHeader>
			FIFO_nRRST_0_SET;
		}		
		else 
		{
			//Enable output of Camera 0
			FIFO_nOE_1_CLR;
     ef0:	47 98       	cbi	0x08, 7	; 8
			//Reset Read Pointer
			FIFO_nRRST_1_CLR;
     ef2:	43 98       	cbi	0x08, 3	; 8
			FIFO_RCLK_1_SET;
     ef4:	42 9a       	sbi	0x08, 2	; 8
			FIFO_RCLK_1_CLR;
     ef6:	42 98       	cbi	0x08, 2	; 8
			FIFO_nRRST_1_SET;
     ef8:	43 9a       	sbi	0x08, 3	; 8
     efa:	7c cf       	rjmp	.-264    	; 0xdf4 <GetImageIfAvailiable+0x6a>

00000efc <UI_LEDs>:
#define STATUS_Exit_Bad		0x80

#define Button_Capture		0
#define Button_Exit			3
unsigned char UI_LEDs(uint8_t LED)
{
     efc:	cf 93       	push	r28
     efe:	df 93       	push	r29
     f00:	00 d0       	rcall	.+0      	; 0xf02 <UI_LEDs+0x6>
     f02:	00 d0       	rcall	.+0      	; 0xf04 <UI_LEDs+0x8>
     f04:	cd b7       	in	r28, 0x3d	; 61
     f06:	de b7       	in	r29, 0x3e	; 62
	unsigned char mesbuf[TWI_BUFFER_SIZE];
	mesbuf[0] = (0x15 << TWI_ADR_BITS) | (FALSE << TWI_READ_BIT);
     f08:	9a e2       	ldi	r25, 0x2A	; 42
     f0a:	99 83       	std	Y+1, r25	; 0x01
	mesbuf[1] = 0x10;
     f0c:	90 e1       	ldi	r25, 0x10	; 16
     f0e:	9a 83       	std	Y+2, r25	; 0x02
	mesbuf[2] = LED;
     f10:	8b 83       	std	Y+3, r24	; 0x03
	TWI_Start_Transceiver_With_Data(mesbuf, 3);
     f12:	ce 01       	movw	r24, r28
     f14:	01 96       	adiw	r24, 0x01	; 1
     f16:	63 e0       	ldi	r22, 0x03	; 3
     f18:	0e 94 db 29 	call	0x53b6	; 0x53b6 <TWI_Start_Transceiver_With_Data>
	while(TWI_Transceiver_Busy())	;
     f1c:	0e 94 d0 29 	call	0x53a0	; 0x53a0 <TWI_Transceiver_Busy>
     f20:	88 23       	and	r24, r24
     f22:	e1 f7       	brne	.-8      	; 0xf1c <UI_LEDs+0x20>
	return TWI_statusReg.lastTransOK;
     f24:	80 91 28 04 	lds	r24, 0x0428
}
     f28:	81 70       	andi	r24, 0x01	; 1
     f2a:	0f 90       	pop	r0
     f2c:	0f 90       	pop	r0
     f2e:	0f 90       	pop	r0
     f30:	0f 90       	pop	r0
     f32:	df 91       	pop	r29
     f34:	cf 91       	pop	r28
     f36:	08 95       	ret

00000f38 <UI_Buttons>:
unsigned char UI_Buttons()
{
     f38:	cf 93       	push	r28
     f3a:	df 93       	push	r29
     f3c:	00 d0       	rcall	.+0      	; 0xf3e <UI_Buttons+0x6>
     f3e:	00 d0       	rcall	.+0      	; 0xf40 <UI_Buttons+0x8>
     f40:	cd b7       	in	r28, 0x3d	; 61
     f42:	de b7       	in	r29, 0x3e	; 62
	unsigned char messageBuf[TWI_BUFFER_SIZE]; //Initialise a buffer
	messageBuf[0] = (0x15<<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
     f44:	8a e2       	ldi	r24, 0x2A	; 42
     f46:	89 83       	std	Y+1, r24	; 0x01
	messageBuf[1] = 0x20;             // The first byte is used for the command
     f48:	80 e2       	ldi	r24, 0x20	; 32
     f4a:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
     f4c:	ce 01       	movw	r24, r28
     f4e:	01 96       	adiw	r24, 0x01	; 1
     f50:	62 e0       	ldi	r22, 0x02	; 2
     f52:	0e 94 db 29 	call	0x53b6	; 0x53b6 <TWI_Start_Transceiver_With_Data>
     f56:	8d ee       	ldi	r24, 0xED	; 237
     f58:	92 e0       	ldi	r25, 0x02	; 2
     f5a:	01 97       	sbiw	r24, 0x01	; 1
     f5c:	f1 f7       	brne	.-4      	; 0xf5a <UI_Buttons+0x22>
     f5e:	00 c0       	rjmp	.+0      	; 0xf60 <UI_Buttons+0x28>
     f60:	00 00       	nop
	_delay_us(250);
	// Request/collect the data from the Slave
	messageBuf[0] = (0x15<<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
     f62:	8b e2       	ldi	r24, 0x2B	; 43
     f64:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
     f66:	ce 01       	movw	r24, r28
     f68:	01 96       	adiw	r24, 0x01	; 1
     f6a:	62 e0       	ldi	r22, 0x02	; 2
     f6c:	0e 94 db 29 	call	0x53b6	; 0x53b6 <TWI_Start_Transceiver_With_Data>
	
	// Get the received data from the transceiver buffer
	TWI_Get_Data_From_Transceiver( messageBuf, 2 );
     f70:	ce 01       	movw	r24, r28
     f72:	01 96       	adiw	r24, 0x01	; 1
     f74:	62 e0       	ldi	r22, 0x02	; 2
     f76:	0e 94 11 2a 	call	0x5422	; 0x5422 <TWI_Get_Data_From_Transceiver>
	return messageBuf[1];
}
     f7a:	8a 81       	ldd	r24, Y+2	; 0x02
     f7c:	0f 90       	pop	r0
     f7e:	0f 90       	pop	r0
     f80:	0f 90       	pop	r0
     f82:	0f 90       	pop	r0
     f84:	df 91       	pop	r29
     f86:	cf 91       	pop	r28
     f88:	08 95       	ret

00000f8a <__vector_16>:
ISR(TIMER0_COMPA_vect)
{
     f8a:	1f 92       	push	r1
     f8c:	0f 92       	push	r0
     f8e:	0f b6       	in	r0, 0x3f	; 63
     f90:	0f 92       	push	r0
     f92:	11 24       	eor	r1, r1
     f94:	2f 93       	push	r18
     f96:	3f 93       	push	r19
     f98:	4f 93       	push	r20
     f9a:	5f 93       	push	r21
     f9c:	6f 93       	push	r22
     f9e:	7f 93       	push	r23
     fa0:	8f 93       	push	r24
     fa2:	9f 93       	push	r25
     fa4:	af 93       	push	r26
     fa6:	bf 93       	push	r27
     fa8:	ef 93       	push	r30
     faa:	ff 93       	push	r31
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
     fac:	0e 94 65 05 	call	0xaca	; 0xaca <disk_timerproc>
// 	if(!TWI_statusReg.lastTransOK) //if the last TWI transmission failed, reset the protocol
// 		TWI_Start_Transceiver();
// 	if(!TWI_Transceiver_Busy())
// 		UI_LEDs(StatusReg);
}
     fb0:	ff 91       	pop	r31
     fb2:	ef 91       	pop	r30
     fb4:	bf 91       	pop	r27
     fb6:	af 91       	pop	r26
     fb8:	9f 91       	pop	r25
     fba:	8f 91       	pop	r24
     fbc:	7f 91       	pop	r23
     fbe:	6f 91       	pop	r22
     fc0:	5f 91       	pop	r21
     fc2:	4f 91       	pop	r20
     fc4:	3f 91       	pop	r19
     fc6:	2f 91       	pop	r18
     fc8:	0f 90       	pop	r0
     fca:	0f be       	out	0x3f, r0	; 63
     fcc:	0f 90       	pop	r0
     fce:	1f 90       	pop	r1
     fd0:	18 95       	reti

00000fd2 <main>:
int main(void)
{
     fd2:	2f 92       	push	r2
     fd4:	3f 92       	push	r3
     fd6:	4f 92       	push	r4
     fd8:	5f 92       	push	r5
     fda:	6f 92       	push	r6
     fdc:	7f 92       	push	r7
     fde:	8f 92       	push	r8
     fe0:	9f 92       	push	r9
     fe2:	af 92       	push	r10
     fe4:	bf 92       	push	r11
     fe6:	df 92       	push	r13
     fe8:	ef 92       	push	r14
     fea:	ff 92       	push	r15
     fec:	0f 93       	push	r16
     fee:	1f 93       	push	r17
     ff0:	cf 93       	push	r28
     ff2:	df 93       	push	r29
     ff4:	00 d0       	rcall	.+0      	; 0xff6 <main+0x24>
     ff6:	00 d0       	rcall	.+0      	; 0xff8 <main+0x26>
     ff8:	cd b7       	in	r28, 0x3d	; 61
     ffa:	de b7       	in	r29, 0x3e	; 62
	unsigned long int a = 0;
     ffc:	19 82       	std	Y+1, r1	; 0x01
     ffe:	1a 82       	std	Y+2, r1	; 0x02
    1000:	1b 82       	std	Y+3, r1	; 0x03
    1002:	1c 82       	std	Y+4, r1	; 0x04
	uint8_t b = 0;
	FRESULT fr;
	uint8_t PhotoCount = 0;
	TWI_Master_Initialise();
    1004:	0e 94 c6 29 	call	0x538c	; 0x538c <TWI_Master_Initialise>
	IO_Init();
    1008:	0e 94 a4 00 	call	0x148	; 0x148 <IO_Init>
	sei();
    100c:	78 94       	sei
	PCA9542A_Init();
    100e:	0e 94 6e 29 	call	0x52dc	; 0x52dc <PCA9542A_Init>

	StatusReg = STATUS_OKAY;
    1012:	81 e0       	ldi	r24, 0x01	; 1
    1014:	80 93 b9 0e 	sts	0x0EB9, r24
	UI_LEDs(StatusReg);
    1018:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
	

	fr = f_mount(0, &Fatfs[0]);
    101c:	80 e0       	ldi	r24, 0x00	; 0
    101e:	61 e7       	ldi	r22, 0x71	; 113
    1020:	7c e0       	ldi	r23, 0x0C	; 12
    1022:	0e 94 4e 1a 	call	0x349c	; 0x349c <f_mount>
	if(fr != FR_OK)
    1026:	88 23       	and	r24, r24
    1028:	49 f0       	breq	.+18     	; 0x103c <main+0x6a>
	{
		StatusReg |= (STATUS_Exit_Bad);
    102a:	80 91 b9 0e 	lds	r24, 0x0EB9
    102e:	80 68       	ori	r24, 0x80	; 128
		StatusReg &= ~(STATUS_OKAY);
    1030:	8e 7f       	andi	r24, 0xFE	; 254
    1032:	80 93 b9 0e 	sts	0x0EB9, r24
		UI_LEDs(StatusReg);
    1036:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
		return 0;
    103a:	0c c2       	rjmp	.+1048   	; 0x1454 <__stack+0x355>
	}
	else
		StatusReg |= STATUS_SDOkay;
    103c:	80 91 b9 0e 	lds	r24, 0x0EB9
    1040:	82 60       	ori	r24, 0x02	; 2
    1042:	80 93 b9 0e 	sts	0x0EB9, r24
	UI_LEDs(StatusReg);
    1046:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
	
	fr = f_open(&Files[0], "/log.txt", FA_WRITE|FA_CREATE_ALWAYS);
    104a:	80 e3       	ldi	r24, 0x30	; 48
    104c:	94 e0       	ldi	r25, 0x04	; 4
    104e:	69 ed       	ldi	r22, 0xD9	; 217
    1050:	72 e0       	ldi	r23, 0x02	; 2
    1052:	4a e0       	ldi	r20, 0x0A	; 10
    1054:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <f_open>
	if(fr != FR_OK)
    1058:	88 23       	and	r24, r24
    105a:	49 f0       	breq	.+18     	; 0x106e <main+0x9c>
	{
		StatusReg |= (STATUS_Exit_Bad);
    105c:	80 91 b9 0e 	lds	r24, 0x0EB9
    1060:	80 68       	ori	r24, 0x80	; 128
		StatusReg &= ~(1<<STATUS_SDOkay) | (1<<STATUS_OKAY);
    1062:	8b 7f       	andi	r24, 0xFB	; 251
    1064:	80 93 b9 0e 	sts	0x0EB9, r24
		UI_LEDs(StatusReg);
    1068:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
		return 0;
    106c:	f3 c1       	rjmp	.+998    	; 0x1454 <__stack+0x355>
	}		
	UI_LEDs(StatusReg);
    106e:	80 91 b9 0e 	lds	r24, 0x0EB9
    1072:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
	
	f_close(&Files[0]);
    1076:	00 e3       	ldi	r16, 0x30	; 48
    1078:	14 e0       	ldi	r17, 0x04	; 4
    107a:	c8 01       	movw	r24, r16
    107c:	0e 94 73 20 	call	0x40e6	; 0x40e6 <f_close>
	f_open(&Files[0], "/log.txt", FA_WRITE);
    1080:	c8 01       	movw	r24, r16
    1082:	69 ed       	ldi	r22, 0xD9	; 217
    1084:	72 e0       	ldi	r23, 0x02	; 2
    1086:	42 e0       	ldi	r20, 0x02	; 2
    1088:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <f_open>
	//stdout = &mystdout;
	b = MCUSR;
    108c:	84 b7       	in	r24, 0x34	; 52
	MCUSR = 0;
    108e:	14 be       	out	0x34, r1	; 52
	f_write(&Files[0],"Il Matto Dual Camera\n", sizeof("Il Matto Dual Camera\n"), &a);
    1090:	c8 01       	movw	r24, r16
    1092:	62 ee       	ldi	r22, 0xE2	; 226
    1094:	72 e0       	ldi	r23, 0x02	; 2
    1096:	26 e1       	ldi	r18, 0x16	; 22
    1098:	30 e0       	ldi	r19, 0x00	; 0
    109a:	40 e0       	ldi	r20, 0x00	; 0
    109c:	50 e0       	ldi	r21, 0x00	; 0
    109e:	8e 01       	movw	r16, r28
    10a0:	0f 5f       	subi	r16, 0xFF	; 255
    10a2:	1f 4f       	sbci	r17, 0xFF	; 255
    10a4:	0e 94 ba 1d 	call	0x3b74	; 0x3b74 <f_write>

	/*f_write(&Files[0], "System Startup Complete.\n", 26, &a);*/
	
	PCA9542A_SetChannel(CH1);
    10a8:	85 e0       	ldi	r24, 0x05	; 5
    10aa:	0e 94 8a 29 	call	0x5314	; 0x5314 <PCA9542A_SetChannel>
	b = OV7670_init();
    10ae:	0e 94 21 06 	call	0xc42	; 0xc42 <OV7670_init>
    10b2:	08 2f       	mov	r16, r24
	if(b == 0)
    10b4:	88 23       	and	r24, r24
    10b6:	29 f4       	brne	.+10     	; 0x10c2 <main+0xf0>
		StatusReg |= STATUS_CAM1Okay;
    10b8:	80 91 b9 0e 	lds	r24, 0x0EB9
    10bc:	88 60       	ori	r24, 0x08	; 8
    10be:	80 93 b9 0e 	sts	0x0EB9, r24
	PCA9542A_SetChannel(NO_SELECT);
    10c2:	80 e0       	ldi	r24, 0x00	; 0
    10c4:	0e 94 8a 29 	call	0x5314	; 0x5314 <PCA9542A_SetChannel>
	UI_LEDs(StatusReg);
    10c8:	80 91 b9 0e 	lds	r24, 0x0EB9
    10cc:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
	sprintf(Buff, "OV7670_1 Initialise result : %d\n", b);
    10d0:	00 d0       	rcall	.+0      	; 0x10d2 <main+0x100>
    10d2:	00 d0       	rcall	.+0      	; 0x10d4 <main+0x102>
    10d4:	00 d0       	rcall	.+0      	; 0x10d6 <main+0x104>
    10d6:	ed b7       	in	r30, 0x3d	; 61
    10d8:	fe b7       	in	r31, 0x3e	; 62
    10da:	31 96       	adiw	r30, 0x01	; 1
    10dc:	0f 2e       	mov	r0, r31
    10de:	f0 e7       	ldi	r31, 0x70	; 112
    10e0:	ef 2e       	mov	r14, r31
    10e2:	f8 e0       	ldi	r31, 0x08	; 8
    10e4:	ff 2e       	mov	r15, r31
    10e6:	f0 2d       	mov	r31, r0
    10e8:	ad b7       	in	r26, 0x3d	; 61
    10ea:	be b7       	in	r27, 0x3e	; 62
    10ec:	12 96       	adiw	r26, 0x02	; 2
    10ee:	fc 92       	st	X, r15
    10f0:	ee 92       	st	-X, r14
    10f2:	11 97       	sbiw	r26, 0x01	; 1
    10f4:	88 ef       	ldi	r24, 0xF8	; 248
    10f6:	92 e0       	ldi	r25, 0x02	; 2
    10f8:	93 83       	std	Z+3, r25	; 0x03
    10fa:	82 83       	std	Z+2, r24	; 0x02
    10fc:	04 83       	std	Z+4, r16	; 0x04
    10fe:	15 82       	std	Z+5, r1	; 0x05
    1100:	0e 94 67 2b 	call	0x56ce	; 0x56ce <sprintf>
	f_write(&Files[0], &Buff, 33, &a);
    1104:	8d b7       	in	r24, 0x3d	; 61
    1106:	9e b7       	in	r25, 0x3e	; 62
    1108:	06 96       	adiw	r24, 0x06	; 6
    110a:	0f b6       	in	r0, 0x3f	; 63
    110c:	f8 94       	cli
    110e:	9e bf       	out	0x3e, r25	; 62
    1110:	0f be       	out	0x3f, r0	; 63
    1112:	8d bf       	out	0x3d, r24	; 61
    1114:	80 e3       	ldi	r24, 0x30	; 48
    1116:	94 e0       	ldi	r25, 0x04	; 4
    1118:	b7 01       	movw	r22, r14
    111a:	21 e2       	ldi	r18, 0x21	; 33
    111c:	30 e0       	ldi	r19, 0x00	; 0
    111e:	40 e0       	ldi	r20, 0x00	; 0
    1120:	50 e0       	ldi	r21, 0x00	; 0
    1122:	8e 01       	movw	r16, r28
    1124:	0f 5f       	subi	r16, 0xFF	; 255
    1126:	1f 4f       	sbci	r17, 0xFF	; 255
    1128:	0e 94 ba 1d 	call	0x3b74	; 0x3b74 <f_write>
	
	PCA9542A_SetChannel(CH0);
    112c:	84 e0       	ldi	r24, 0x04	; 4
    112e:	0e 94 8a 29 	call	0x5314	; 0x5314 <PCA9542A_SetChannel>
	b = OV7670_init();
    1132:	0e 94 21 06 	call	0xc42	; 0xc42 <OV7670_init>
    1136:	08 2f       	mov	r16, r24
	if(b == 0)
    1138:	88 23       	and	r24, r24
    113a:	29 f4       	brne	.+10     	; 0x1146 <__stack+0x47>
		StatusReg |= STATUS_CAM0Okay;
    113c:	80 91 b9 0e 	lds	r24, 0x0EB9
    1140:	84 60       	ori	r24, 0x04	; 4
    1142:	80 93 b9 0e 	sts	0x0EB9, r24
	UI_LEDs(StatusReg);
    1146:	80 91 b9 0e 	lds	r24, 0x0EB9
    114a:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
	PCA9542A_SetChannel(NO_SELECT);
    114e:	80 e0       	ldi	r24, 0x00	; 0
    1150:	0e 94 8a 29 	call	0x5314	; 0x5314 <PCA9542A_SetChannel>
	sprintf(Buff, "OV7670_0 Initialise result : %d\n", b);
    1154:	00 d0       	rcall	.+0      	; 0x1156 <__stack+0x57>
    1156:	00 d0       	rcall	.+0      	; 0x1158 <__stack+0x59>
    1158:	00 d0       	rcall	.+0      	; 0x115a <__stack+0x5b>
    115a:	ed b7       	in	r30, 0x3d	; 61
    115c:	fe b7       	in	r31, 0x3e	; 62
    115e:	31 96       	adiw	r30, 0x01	; 1
    1160:	0f 2e       	mov	r0, r31
    1162:	f0 e7       	ldi	r31, 0x70	; 112
    1164:	ef 2e       	mov	r14, r31
    1166:	f8 e0       	ldi	r31, 0x08	; 8
    1168:	ff 2e       	mov	r15, r31
    116a:	f0 2d       	mov	r31, r0
    116c:	ad b7       	in	r26, 0x3d	; 61
    116e:	be b7       	in	r27, 0x3e	; 62
    1170:	12 96       	adiw	r26, 0x02	; 2
    1172:	fc 92       	st	X, r15
    1174:	ee 92       	st	-X, r14
    1176:	11 97       	sbiw	r26, 0x01	; 1
    1178:	89 e1       	ldi	r24, 0x19	; 25
    117a:	93 e0       	ldi	r25, 0x03	; 3
    117c:	93 83       	std	Z+3, r25	; 0x03
    117e:	82 83       	std	Z+2, r24	; 0x02
    1180:	04 83       	std	Z+4, r16	; 0x04
    1182:	15 82       	std	Z+5, r1	; 0x05
    1184:	0e 94 67 2b 	call	0x56ce	; 0x56ce <sprintf>
	f_write(&Files[0], &Buff, 33, &a);
    1188:	8d b7       	in	r24, 0x3d	; 61
    118a:	9e b7       	in	r25, 0x3e	; 62
    118c:	06 96       	adiw	r24, 0x06	; 6
    118e:	0f b6       	in	r0, 0x3f	; 63
    1190:	f8 94       	cli
    1192:	9e bf       	out	0x3e, r25	; 62
    1194:	0f be       	out	0x3f, r0	; 63
    1196:	8d bf       	out	0x3d, r24	; 61
    1198:	80 e3       	ldi	r24, 0x30	; 48
    119a:	94 e0       	ldi	r25, 0x04	; 4
    119c:	b7 01       	movw	r22, r14
    119e:	21 e2       	ldi	r18, 0x21	; 33
    11a0:	30 e0       	ldi	r19, 0x00	; 0
    11a2:	40 e0       	ldi	r20, 0x00	; 0
    11a4:	50 e0       	ldi	r21, 0x00	; 0
    11a6:	8e 01       	movw	r16, r28
    11a8:	0f 5f       	subi	r16, 0xFF	; 255
    11aa:	1f 4f       	sbci	r17, 0xFF	; 255
    11ac:	0e 94 ba 1d 	call	0x3b74	; 0x3b74 <f_write>
	FIFO_init();
    11b0:	0e 94 51 06 	call	0xca2	; 0xca2 <FIFO_init>

	//f_close(&Files[0]);
	StatusReg |= STATUS_READY;
    11b4:	80 91 b9 0e 	lds	r24, 0x0EB9
    11b8:	80 61       	ori	r24, 0x10	; 16
    11ba:	80 93 b9 0e 	sts	0x0EB9, r24
	UI_LEDs(StatusReg);
    11be:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    11c2:	8f eb       	ldi	r24, 0xBF	; 191
    11c4:	97 e2       	ldi	r25, 0x27	; 39
    11c6:	a9 e0       	ldi	r26, 0x09	; 9
    11c8:	81 50       	subi	r24, 0x01	; 1
    11ca:	90 40       	sbci	r25, 0x00	; 0
    11cc:	a0 40       	sbci	r26, 0x00	; 0
    11ce:	e1 f7       	brne	.-8      	; 0x11c8 <__stack+0xc9>
    11d0:	00 c0       	rjmp	.+0      	; 0x11d2 <__stack+0xd3>
    11d2:	00 00       	nop
    {
		Input = (~UI_Buttons() & 0x0F);//Data is received negative
		if(Input)//if a button has been pressed
		{
			_delay_ms(250);
			sprintf(Buff, "Button Received : %d\n", Input);
    11d4:	47 01       	movw	r8, r14
    11d6:	0f 2e       	mov	r0, r31
    11d8:	fa e3       	ldi	r31, 0x3A	; 58
    11da:	6f 2e       	mov	r6, r31
    11dc:	f3 e0       	ldi	r31, 0x03	; 3
    11de:	7f 2e       	mov	r7, r31
    11e0:	f0 2d       	mov	r31, r0
			f_write(&Files[0], Buff, 21, &a);
    11e2:	0f 2e       	mov	r0, r31
    11e4:	f0 e3       	ldi	r31, 0x30	; 48
    11e6:	af 2e       	mov	r10, r31
    11e8:	f4 e0       	ldi	r31, 0x04	; 4
    11ea:	bf 2e       	mov	r11, r31
    11ec:	f0 2d       	mov	r31, r0
					LoadImagesToBuffer();//Load both images
					
					//Create Bitmap for image 0
					//PSTR("Image_r.bmp");
					
					f_open(&Files[1], "Image_r.bmp", FA_CREATE_ALWAYS | FA_WRITE);
    11ee:	0f 2e       	mov	r0, r31
    11f0:	f0 e5       	ldi	r31, 0x50	; 80
    11f2:	ef 2e       	mov	r14, r31
    11f4:	f6 e0       	ldi	r31, 0x06	; 6
    11f6:	ff 2e       	mov	r15, r31
    11f8:	f0 2d       	mov	r31, r0
    11fa:	0f 2e       	mov	r0, r31
    11fc:	f5 e6       	ldi	r31, 0x65	; 101
    11fe:	4f 2e       	mov	r4, r31
    1200:	f3 e0       	ldi	r31, 0x03	; 3
    1202:	5f 2e       	mov	r5, r31
    1204:	f0 2d       	mov	r31, r0
					f_lseek(&Files[1], 0);
					f_close(&Files[1]);
					f_write(&Files[0], "Extended image0 file.\n", 22, &a);
					
					//Create Bitmap for image 1
					f_open(&Files[1],"image_l.bmp", FA_CREATE_ALWAYS | FA_WRITE);
    1206:	0f 2e       	mov	r0, r31
    1208:	fe e9       	ldi	r31, 0x9E	; 158
    120a:	2f 2e       	mov	r2, r31
    120c:	f3 e0       	ldi	r31, 0x03	; 3
    120e:	3f 2e       	mov	r3, r31
    1210:	f0 2d       	mov	r31, r0
	_delay_ms(250);
	uint8_t Input;

    while(1)
    {
		Input = (~UI_Buttons() & 0x0F);//Data is received negative
    1212:	0e 94 9c 07 	call	0xf38	; 0xf38 <UI_Buttons>
    1216:	80 95       	com	r24
    1218:	0f 2e       	mov	r0, r31
    121a:	ff e0       	ldi	r31, 0x0F	; 15
    121c:	df 2e       	mov	r13, r31
    121e:	f0 2d       	mov	r31, r0
    1220:	d8 22       	and	r13, r24
		if(Input)//if a button has been pressed
    1222:	09 f4       	brne	.+2      	; 0x1226 <__stack+0x127>
    1224:	06 c1       	rjmp	.+524    	; 0x1432 <__stack+0x333>
    1226:	8f eb       	ldi	r24, 0xBF	; 191
    1228:	97 e2       	ldi	r25, 0x27	; 39
    122a:	a9 e0       	ldi	r26, 0x09	; 9
    122c:	81 50       	subi	r24, 0x01	; 1
    122e:	90 40       	sbci	r25, 0x00	; 0
    1230:	a0 40       	sbci	r26, 0x00	; 0
    1232:	e1 f7       	brne	.-8      	; 0x122c <__stack+0x12d>
    1234:	00 c0       	rjmp	.+0      	; 0x1236 <__stack+0x137>
    1236:	00 00       	nop
		{
			_delay_ms(250);
			sprintf(Buff, "Button Received : %d\n", Input);
    1238:	00 d0       	rcall	.+0      	; 0x123a <__stack+0x13b>
    123a:	00 d0       	rcall	.+0      	; 0x123c <__stack+0x13d>
    123c:	00 d0       	rcall	.+0      	; 0x123e <__stack+0x13f>
    123e:	ed b7       	in	r30, 0x3d	; 61
    1240:	fe b7       	in	r31, 0x3e	; 62
    1242:	31 96       	adiw	r30, 0x01	; 1
    1244:	ad b7       	in	r26, 0x3d	; 61
    1246:	be b7       	in	r27, 0x3e	; 62
    1248:	12 96       	adiw	r26, 0x02	; 2
    124a:	9c 92       	st	X, r9
    124c:	8e 92       	st	-X, r8
    124e:	11 97       	sbiw	r26, 0x01	; 1
    1250:	73 82       	std	Z+3, r7	; 0x03
    1252:	62 82       	std	Z+2, r6	; 0x02
    1254:	d4 82       	std	Z+4, r13	; 0x04
    1256:	15 82       	std	Z+5, r1	; 0x05
    1258:	0e 94 67 2b 	call	0x56ce	; 0x56ce <sprintf>
			f_write(&Files[0], Buff, 21, &a);
    125c:	8d b7       	in	r24, 0x3d	; 61
    125e:	9e b7       	in	r25, 0x3e	; 62
    1260:	06 96       	adiw	r24, 0x06	; 6
    1262:	0f b6       	in	r0, 0x3f	; 63
    1264:	f8 94       	cli
    1266:	9e bf       	out	0x3e, r25	; 62
    1268:	0f be       	out	0x3f, r0	; 63
    126a:	8d bf       	out	0x3d, r24	; 61
    126c:	c5 01       	movw	r24, r10
    126e:	b4 01       	movw	r22, r8
    1270:	25 e1       	ldi	r18, 0x15	; 21
    1272:	30 e0       	ldi	r19, 0x00	; 0
    1274:	40 e0       	ldi	r20, 0x00	; 0
    1276:	50 e0       	ldi	r21, 0x00	; 0
    1278:	8e 01       	movw	r16, r28
    127a:	0f 5f       	subi	r16, 0xFF	; 255
    127c:	1f 4f       	sbci	r17, 0xFF	; 255
    127e:	0e 94 ba 1d 	call	0x3b74	; 0x3b74 <f_write>
			
			StatusReg&= ~(STATUS_READY);//no longer ready
    1282:	80 91 b9 0e 	lds	r24, 0x0EB9
    1286:	8f 7e       	andi	r24, 0xEF	; 239
    1288:	80 93 b9 0e 	sts	0x0EB9, r24
			
			switch(Input)
    128c:	91 e0       	ldi	r25, 0x01	; 1
    128e:	d9 16       	cp	r13, r25
    1290:	29 f0       	breq	.+10     	; 0x129c <__stack+0x19d>
    1292:	a8 e0       	ldi	r26, 0x08	; 8
    1294:	da 16       	cp	r13, r26
    1296:	09 f0       	breq	.+2      	; 0x129a <__stack+0x19b>
    1298:	bc cf       	rjmp	.-136    	; 0x1212 <__stack+0x113>
    129a:	b0 c0       	rjmp	.+352    	; 0x13fc <__stack+0x2fd>
			{
				case (1<<Button_Capture):
					StatusReg |= STATUS_CAPTURING;
    129c:	80 62       	ori	r24, 0x20	; 32
    129e:	80 93 b9 0e 	sts	0x0EB9, r24
					UI_LEDs(StatusReg);
    12a2:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
					//Reset both buffers
					FIFO_Reset(0);
    12a6:	80 e0       	ldi	r24, 0x00	; 0
    12a8:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
					FIFO_Reset(1);
    12ac:	81 e0       	ldi	r24, 0x01	; 1
    12ae:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
					f_write(&Files[0], "Capturing Images...\n", 20, &a);
    12b2:	c5 01       	movw	r24, r10
    12b4:	60 e5       	ldi	r22, 0x50	; 80
    12b6:	73 e0       	ldi	r23, 0x03	; 3
    12b8:	24 e1       	ldi	r18, 0x14	; 20
    12ba:	30 e0       	ldi	r19, 0x00	; 0
    12bc:	40 e0       	ldi	r20, 0x00	; 0
    12be:	50 e0       	ldi	r21, 0x00	; 0
    12c0:	8e 01       	movw	r16, r28
    12c2:	0f 5f       	subi	r16, 0xFF	; 255
    12c4:	1f 4f       	sbci	r17, 0xFF	; 255
    12c6:	0e 94 ba 1d 	call	0x3b74	; 0x3b74 <f_write>
					LoadImagesToBuffer();//Load both images
    12ca:	0e 94 b5 06 	call	0xd6a	; 0xd6a <LoadImagesToBuffer>
					
					//Create Bitmap for image 0
					//PSTR("Image_r.bmp");
					
					f_open(&Files[1], "Image_r.bmp", FA_CREATE_ALWAYS | FA_WRITE);
    12ce:	c7 01       	movw	r24, r14
    12d0:	b2 01       	movw	r22, r4
    12d2:	4a e0       	ldi	r20, 0x0A	; 10
    12d4:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <f_open>
					f_write(&Files[0], "Created image0 file.\n", 22, &a);
    12d8:	c5 01       	movw	r24, r10
    12da:	61 e7       	ldi	r22, 0x71	; 113
    12dc:	73 e0       	ldi	r23, 0x03	; 3
    12de:	26 e1       	ldi	r18, 0x16	; 22
    12e0:	30 e0       	ldi	r19, 0x00	; 0
    12e2:	40 e0       	ldi	r20, 0x00	; 0
    12e4:	50 e0       	ldi	r21, 0x00	; 0
    12e6:	8e 01       	movw	r16, r28
    12e8:	0f 5f       	subi	r16, 0xFF	; 255
    12ea:	1f 4f       	sbci	r17, 0xFF	; 255
    12ec:	0e 94 ba 1d 	call	0x3b74	; 0x3b74 <f_write>
					f_lseek(&Files[1], BMPFileSize);
    12f0:	c7 01       	movw	r24, r14
    12f2:	4a e8       	ldi	r20, 0x8A	; 138
    12f4:	58 e5       	ldi	r21, 0x58	; 88
    12f6:	62 e0       	ldi	r22, 0x02	; 2
    12f8:	70 e0       	ldi	r23, 0x00	; 0
    12fa:	0e 94 df 20 	call	0x41be	; 0x41be <f_lseek>
					f_lseek(&Files[1], 0);
    12fe:	c7 01       	movw	r24, r14
    1300:	40 e0       	ldi	r20, 0x00	; 0
    1302:	50 e0       	ldi	r21, 0x00	; 0
    1304:	ba 01       	movw	r22, r20
    1306:	0e 94 df 20 	call	0x41be	; 0x41be <f_lseek>
					f_close(&Files[1]);
    130a:	c7 01       	movw	r24, r14
    130c:	0e 94 73 20 	call	0x40e6	; 0x40e6 <f_close>
					f_write(&Files[0], "Extended image0 file.\n", 22, &a);
    1310:	c5 01       	movw	r24, r10
    1312:	67 e8       	ldi	r22, 0x87	; 135
    1314:	73 e0       	ldi	r23, 0x03	; 3
    1316:	26 e1       	ldi	r18, 0x16	; 22
    1318:	30 e0       	ldi	r19, 0x00	; 0
    131a:	40 e0       	ldi	r20, 0x00	; 0
    131c:	50 e0       	ldi	r21, 0x00	; 0
    131e:	8e 01       	movw	r16, r28
    1320:	0f 5f       	subi	r16, 0xFF	; 255
    1322:	1f 4f       	sbci	r17, 0xFF	; 255
    1324:	0e 94 ba 1d 	call	0x3b74	; 0x3b74 <f_write>
					
					//Create Bitmap for image 1
					f_open(&Files[1],"image_l.bmp", FA_CREATE_ALWAYS | FA_WRITE);
    1328:	c7 01       	movw	r24, r14
    132a:	b1 01       	movw	r22, r2
    132c:	4a e0       	ldi	r20, 0x0A	; 10
    132e:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <f_open>
					f_write(&Files[0], "Created image1 file.\n", 22, &a);
    1332:	c5 01       	movw	r24, r10
    1334:	6a ea       	ldi	r22, 0xAA	; 170
    1336:	73 e0       	ldi	r23, 0x03	; 3
    1338:	26 e1       	ldi	r18, 0x16	; 22
    133a:	30 e0       	ldi	r19, 0x00	; 0
    133c:	40 e0       	ldi	r20, 0x00	; 0
    133e:	50 e0       	ldi	r21, 0x00	; 0
    1340:	8e 01       	movw	r16, r28
    1342:	0f 5f       	subi	r16, 0xFF	; 255
    1344:	1f 4f       	sbci	r17, 0xFF	; 255
    1346:	0e 94 ba 1d 	call	0x3b74	; 0x3b74 <f_write>
					f_lseek(&Files[1], BMPFileSize);
    134a:	c7 01       	movw	r24, r14
    134c:	4a e8       	ldi	r20, 0x8A	; 138
    134e:	58 e5       	ldi	r21, 0x58	; 88
    1350:	62 e0       	ldi	r22, 0x02	; 2
    1352:	70 e0       	ldi	r23, 0x00	; 0
    1354:	0e 94 df 20 	call	0x41be	; 0x41be <f_lseek>
					f_lseek(&Files[1], 0);
    1358:	c7 01       	movw	r24, r14
    135a:	40 e0       	ldi	r20, 0x00	; 0
    135c:	50 e0       	ldi	r21, 0x00	; 0
    135e:	ba 01       	movw	r22, r20
    1360:	0e 94 df 20 	call	0x41be	; 0x41be <f_lseek>
					f_close(&Files[1]);
    1364:	c7 01       	movw	r24, r14
    1366:	0e 94 73 20 	call	0x40e6	; 0x40e6 <f_close>
					f_write(&Files[0], "Extended image1 file.\n", 22, &a);
    136a:	c5 01       	movw	r24, r10
    136c:	60 ec       	ldi	r22, 0xC0	; 192
    136e:	73 e0       	ldi	r23, 0x03	; 3
    1370:	26 e1       	ldi	r18, 0x16	; 22
    1372:	30 e0       	ldi	r19, 0x00	; 0
    1374:	40 e0       	ldi	r20, 0x00	; 0
    1376:	50 e0       	ldi	r21, 0x00	; 0
    1378:	8e 01       	movw	r16, r28
    137a:	0f 5f       	subi	r16, 0xFF	; 255
    137c:	1f 4f       	sbci	r17, 0xFF	; 255
    137e:	0e 94 ba 1d 	call	0x3b74	; 0x3b74 <f_write>
					//Get image 0
					f_open(&Files[1], "Image_r.bmp", FA_WRITE);
    1382:	c7 01       	movw	r24, r14
    1384:	b2 01       	movw	r22, r4
    1386:	42 e0       	ldi	r20, 0x02	; 2
    1388:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <f_open>
					while (2 == GetImageIfAvailiable(&Files[1], 0))	;
    138c:	c7 01       	movw	r24, r14
    138e:	60 e0       	ldi	r22, 0x00	; 0
    1390:	0e 94 c5 06 	call	0xd8a	; 0xd8a <GetImageIfAvailiable>
    1394:	82 30       	cpi	r24, 0x02	; 2
    1396:	d1 f3       	breq	.-12     	; 0x138c <__stack+0x28d>
					f_close(&Files[1]);
    1398:	c7 01       	movw	r24, r14
    139a:	0e 94 73 20 	call	0x40e6	; 0x40e6 <f_close>
					f_write(&Files[0], "Captured image0.\n", 17, &a);
    139e:	c5 01       	movw	r24, r10
    13a0:	67 ed       	ldi	r22, 0xD7	; 215
    13a2:	73 e0       	ldi	r23, 0x03	; 3
    13a4:	21 e1       	ldi	r18, 0x11	; 17
    13a6:	30 e0       	ldi	r19, 0x00	; 0
    13a8:	40 e0       	ldi	r20, 0x00	; 0
    13aa:	50 e0       	ldi	r21, 0x00	; 0
    13ac:	8e 01       	movw	r16, r28
    13ae:	0f 5f       	subi	r16, 0xFF	; 255
    13b0:	1f 4f       	sbci	r17, 0xFF	; 255
    13b2:	0e 94 ba 1d 	call	0x3b74	; 0x3b74 <f_write>
					//get image 1
					f_open(&Files[1], "image_l.bmp", FA_WRITE);
    13b6:	c7 01       	movw	r24, r14
    13b8:	b1 01       	movw	r22, r2
    13ba:	42 e0       	ldi	r20, 0x02	; 2
    13bc:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <f_open>
					while (2 == GetImageIfAvailiable(&Files[1], 1))	;
    13c0:	c7 01       	movw	r24, r14
    13c2:	61 e0       	ldi	r22, 0x01	; 1
    13c4:	0e 94 c5 06 	call	0xd8a	; 0xd8a <GetImageIfAvailiable>
    13c8:	82 30       	cpi	r24, 0x02	; 2
    13ca:	d1 f3       	breq	.-12     	; 0x13c0 <__stack+0x2c1>
					f_close(&Files[1]);
    13cc:	c7 01       	movw	r24, r14
    13ce:	0e 94 73 20 	call	0x40e6	; 0x40e6 <f_close>
					f_write(&Files[0], "Captured image1.\n", 17, &a);
    13d2:	c5 01       	movw	r24, r10
    13d4:	69 ee       	ldi	r22, 0xE9	; 233
    13d6:	73 e0       	ldi	r23, 0x03	; 3
    13d8:	21 e1       	ldi	r18, 0x11	; 17
    13da:	30 e0       	ldi	r19, 0x00	; 0
    13dc:	40 e0       	ldi	r20, 0x00	; 0
    13de:	50 e0       	ldi	r21, 0x00	; 0
    13e0:	8e 01       	movw	r16, r28
    13e2:	0f 5f       	subi	r16, 0xFF	; 255
    13e4:	1f 4f       	sbci	r17, 0xFF	; 255
    13e6:	0e 94 ba 1d 	call	0x3b74	; 0x3b74 <f_write>
					StatusReg |= STATUS_READY;
    13ea:	80 91 b9 0e 	lds	r24, 0x0EB9
    13ee:	80 61       	ori	r24, 0x10	; 16
					StatusReg &= ~STATUS_CAPTURING;
    13f0:	8f 7d       	andi	r24, 0xDF	; 223
    13f2:	80 93 b9 0e 	sts	0x0EB9, r24
					UI_LEDs(StatusReg);
    13f6:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
					break;//break case(1<<ButtonCapture)
    13fa:	0b cf       	rjmp	.-490    	; 0x1212 <__stack+0x113>
					
				case (1<<Button_Exit):
					f_write(&Files[0], "\nSystem Exiting...\n",19 ,&a);
    13fc:	0f 2e       	mov	r0, r31
    13fe:	f0 e3       	ldi	r31, 0x30	; 48
    1400:	ef 2e       	mov	r14, r31
    1402:	f4 e0       	ldi	r31, 0x04	; 4
    1404:	ff 2e       	mov	r15, r31
    1406:	f0 2d       	mov	r31, r0
    1408:	c7 01       	movw	r24, r14
    140a:	6b ef       	ldi	r22, 0xFB	; 251
    140c:	73 e0       	ldi	r23, 0x03	; 3
    140e:	23 e1       	ldi	r18, 0x13	; 19
    1410:	30 e0       	ldi	r19, 0x00	; 0
    1412:	40 e0       	ldi	r20, 0x00	; 0
    1414:	50 e0       	ldi	r21, 0x00	; 0
    1416:	8e 01       	movw	r16, r28
    1418:	0f 5f       	subi	r16, 0xFF	; 255
    141a:	1f 4f       	sbci	r17, 0xFF	; 255
    141c:	0e 94 ba 1d 	call	0x3b74	; 0x3b74 <f_write>
					f_close(&Files[0]);//close log file
    1420:	c7 01       	movw	r24, r14
    1422:	0e 94 73 20 	call	0x40e6	; 0x40e6 <f_close>
					
					StatusReg = 0x41;
    1426:	81 e4       	ldi	r24, 0x41	; 65
    1428:	80 93 b9 0e 	sts	0x0EB9, r24
					UI_LEDs(StatusReg);
    142c:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
					return 0;//Q
    1430:	11 c0       	rjmp	.+34     	; 0x1454 <__stack+0x355>
			}//End switch
		}//End if(Input)
		else
		{
			StatusReg |= STATUS_READY;
    1432:	80 91 b9 0e 	lds	r24, 0x0EB9
    1436:	80 61       	ori	r24, 0x10	; 16
    1438:	80 93 b9 0e 	sts	0x0EB9, r24
			UI_LEDs(StatusReg);
    143c:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
    1440:	8f eb       	ldi	r24, 0xBF	; 191
    1442:	97 e2       	ldi	r25, 0x27	; 39
    1444:	a9 e0       	ldi	r26, 0x09	; 9
    1446:	81 50       	subi	r24, 0x01	; 1
    1448:	90 40       	sbci	r25, 0x00	; 0
    144a:	a0 40       	sbci	r26, 0x00	; 0
    144c:	e1 f7       	brne	.-8      	; 0x1446 <__stack+0x347>
    144e:	00 c0       	rjmp	.+0      	; 0x1450 <__stack+0x351>
    1450:	00 00       	nop
    1452:	df ce       	rjmp	.-578    	; 0x1212 <__stack+0x113>
			_delay_ms(250);//wait
		}//end else(Input)					
    }//End while(1)
    1454:	80 e0       	ldi	r24, 0x00	; 0
    1456:	90 e0       	ldi	r25, 0x00	; 0
    1458:	0f 90       	pop	r0
    145a:	0f 90       	pop	r0
    145c:	0f 90       	pop	r0
    145e:	0f 90       	pop	r0
    1460:	df 91       	pop	r29
    1462:	cf 91       	pop	r28
    1464:	1f 91       	pop	r17
    1466:	0f 91       	pop	r16
    1468:	ff 90       	pop	r15
    146a:	ef 90       	pop	r14
    146c:	df 90       	pop	r13
    146e:	bf 90       	pop	r11
    1470:	af 90       	pop	r10
    1472:	9f 90       	pop	r9
    1474:	8f 90       	pop	r8
    1476:	7f 90       	pop	r7
    1478:	6f 90       	pop	r6
    147a:	5f 90       	pop	r5
    147c:	4f 90       	pop	r4
    147e:	3f 90       	pop	r3
    1480:	2f 90       	pop	r2
    1482:	08 95       	ret

00001484 <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
    1484:	e6 2f       	mov	r30, r22
    1486:	f7 2f       	mov	r31, r23
    1488:	ba 01       	movw	r22, r20
    148a:	a9 01       	movw	r20, r18
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
    148c:	41 15       	cp	r20, r1
    148e:	51 05       	cpc	r21, r1
    1490:	61 05       	cpc	r22, r1
    1492:	71 05       	cpc	r23, r1
    1494:	59 f0       	breq	.+22     	; 0x14ac <mem_cpy+0x28>
    1496:	ae 2f       	mov	r26, r30
    1498:	bf 2f       	mov	r27, r31
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    149a:	e8 2f       	mov	r30, r24
    149c:	f9 2f       	mov	r31, r25
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
    149e:	8d 91       	ld	r24, X+
    14a0:	81 93       	st	Z+, r24
    14a2:	41 50       	subi	r20, 0x01	; 1
    14a4:	50 40       	sbci	r21, 0x00	; 0
    14a6:	60 40       	sbci	r22, 0x00	; 0
    14a8:	70 40       	sbci	r23, 0x00	; 0
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
    14aa:	c9 f7       	brne	.-14     	; 0x149e <mem_cpy+0x1a>
    14ac:	08 95       	ret

000014ae <mem_set>:
		*d++ = *s++;
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
    14ae:	a6 2f       	mov	r26, r22
    14b0:	ba 01       	movw	r22, r20
    14b2:	a9 01       	movw	r20, r18
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    14b4:	41 15       	cp	r20, r1
    14b6:	51 05       	cpc	r21, r1
    14b8:	61 05       	cpc	r22, r1
    14ba:	71 05       	cpc	r23, r1
    14bc:	41 f0       	breq	.+16     	; 0x14ce <mem_set+0x20>
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    14be:	e8 2f       	mov	r30, r24
    14c0:	f9 2f       	mov	r31, r25

	while (cnt--)
		*d++ = (BYTE)val;
    14c2:	a1 93       	st	Z+, r26
    14c4:	41 50       	subi	r20, 0x01	; 1
    14c6:	50 40       	sbci	r21, 0x00	; 0
    14c8:	60 40       	sbci	r22, 0x00	; 0
    14ca:	70 40       	sbci	r23, 0x00	; 0
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    14cc:	d1 f7       	brne	.-12     	; 0x14c2 <mem_set+0x14>
    14ce:	08 95       	ret

000014d0 <ld_clust>:
static
DWORD ld_clust (
	FATFS *fs,	/* Pointer to the fs object */
	BYTE *dir	/* Pointer to the directory entry */
)
{
    14d0:	0f 93       	push	r16
    14d2:	1f 93       	push	r17
    14d4:	dc 01       	movw	r26, r24
    14d6:	fb 01       	movw	r30, r22
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
    14d8:	93 8d       	ldd	r25, Z+27	; 0x1b
    14da:	80 e0       	ldi	r24, 0x00	; 0
    14dc:	02 8d       	ldd	r16, Z+26	; 0x1a
    14de:	10 e0       	ldi	r17, 0x00	; 0
    14e0:	08 2b       	or	r16, r24
    14e2:	19 2b       	or	r17, r25
    14e4:	20 e0       	ldi	r18, 0x00	; 0
    14e6:	30 e0       	ldi	r19, 0x00	; 0
	if (fs->fs_type == FS_FAT32)
    14e8:	8c 91       	ld	r24, X
    14ea:	83 30       	cpi	r24, 0x03	; 3
    14ec:	79 f4       	brne	.+30     	; 0x150c <ld_clust+0x3c>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
    14ee:	55 89       	ldd	r21, Z+21	; 0x15
    14f0:	40 e0       	ldi	r20, 0x00	; 0
    14f2:	84 89       	ldd	r24, Z+20	; 0x14
    14f4:	90 e0       	ldi	r25, 0x00	; 0
    14f6:	84 2b       	or	r24, r20
    14f8:	95 2b       	or	r25, r21
    14fa:	a0 e0       	ldi	r26, 0x00	; 0
    14fc:	b0 e0       	ldi	r27, 0x00	; 0
    14fe:	dc 01       	movw	r26, r24
    1500:	99 27       	eor	r25, r25
    1502:	88 27       	eor	r24, r24
    1504:	08 2b       	or	r16, r24
    1506:	19 2b       	or	r17, r25
    1508:	2a 2b       	or	r18, r26
    150a:	3b 2b       	or	r19, r27

	return cl;
}
    150c:	60 2f       	mov	r22, r16
    150e:	71 2f       	mov	r23, r17
    1510:	82 2f       	mov	r24, r18
    1512:	93 2f       	mov	r25, r19
    1514:	1f 91       	pop	r17
    1516:	0f 91       	pop	r16
    1518:	08 95       	ret

0000151a <st_clust>:
static
void st_clust (
	BYTE *dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
    151a:	fc 01       	movw	r30, r24
	ST_WORD(dir+DIR_FstClusLO, cl);
    151c:	42 8f       	std	Z+26, r20	; 0x1a
    151e:	53 8f       	std	Z+27, r21	; 0x1b
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
    1520:	ab 01       	movw	r20, r22
    1522:	66 27       	eor	r22, r22
    1524:	77 27       	eor	r23, r23
    1526:	44 8b       	std	Z+20, r20	; 0x14
    1528:	55 8b       	std	Z+21, r21	; 0x15
}
    152a:	08 95       	ret

0000152c <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to the file information to be filled */
)
{
    152c:	ef 92       	push	r14
    152e:	ff 92       	push	r15
    1530:	0f 93       	push	r16
    1532:	1f 93       	push	r17
    1534:	cf 93       	push	r28
    1536:	df 93       	push	r29
    1538:	fc 01       	movw	r30, r24
    153a:	7b 01       	movw	r14, r22
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
    153c:	8b 01       	movw	r16, r22
    153e:	07 5f       	subi	r16, 0xF7	; 247
    1540:	1f 4f       	sbci	r17, 0xFF	; 255
	if (dj->sect) {
    1542:	86 85       	ldd	r24, Z+14	; 0x0e
    1544:	97 85       	ldd	r25, Z+15	; 0x0f
    1546:	a0 89       	ldd	r26, Z+16	; 0x10
    1548:	b1 89       	ldd	r27, Z+17	; 0x11
    154a:	00 97       	sbiw	r24, 0x00	; 0
    154c:	a1 05       	cpc	r26, r1
    154e:	b1 05       	cpc	r27, r1
    1550:	09 f4       	brne	.+2      	; 0x1554 <get_fileinfo+0x28>
    1552:	65 c0       	rjmp	.+202    	; 0x161e <get_fileinfo+0xf2>
		dir = dj->dir;
    1554:	c2 89       	ldd	r28, Z+18	; 0x12
    1556:	d3 89       	ldd	r29, Z+19	; 0x13
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
    1558:	28 81       	ld	r18, Y
			if (c == ' ') break;
    155a:	20 32       	cpi	r18, 0x20	; 32
    155c:	99 f0       	breq	.+38     	; 0x1584 <get_fileinfo+0x58>
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
    155e:	de 01       	movw	r26, r28
    1560:	11 96       	adiw	r26, 0x01	; 1
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
    1562:	f8 01       	movw	r30, r16
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
    1564:	80 e0       	ldi	r24, 0x00	; 0
    1566:	90 e0       	ldi	r25, 0x00	; 0
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
    1568:	35 ee       	ldi	r19, 0xE5	; 229
    156a:	04 c0       	rjmp	.+8      	; 0x1574 <get_fileinfo+0x48>
	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
    156c:	2d 91       	ld	r18, X+
    156e:	01 96       	adiw	r24, 0x01	; 1
			if (c == ' ') break;
    1570:	20 32       	cpi	r18, 0x20	; 32
    1572:	41 f0       	breq	.+16     	; 0x1584 <get_fileinfo+0x58>
			if (c == NDDE) c = (TCHAR)DDE;
    1574:	25 30       	cpi	r18, 0x05	; 5
    1576:	09 f4       	brne	.+2      	; 0x157a <get_fileinfo+0x4e>
    1578:	23 2f       	mov	r18, r19
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
    157a:	21 93       	st	Z+, r18
    157c:	8f 01       	movw	r16, r30

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
    157e:	87 30       	cpi	r24, 0x07	; 7
    1580:	91 05       	cpc	r25, r1
    1582:	a1 f7       	brne	.-24     	; 0x156c <get_fileinfo+0x40>
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
    1584:	88 85       	ldd	r24, Y+8	; 0x08
    1586:	80 32       	cpi	r24, 0x20	; 32
    1588:	81 f0       	breq	.+32     	; 0x15aa <get_fileinfo+0x7e>
			*p++ = '.';
    158a:	8e e2       	ldi	r24, 0x2E	; 46
    158c:	f8 01       	movw	r30, r16
    158e:	80 83       	st	Z, r24
			for (i = 8; i < 11; i++) {
				c = dir[i];
    1590:	88 85       	ldd	r24, Y+8	; 0x08
				if (c == ' ') break;
    1592:	80 32       	cpi	r24, 0x20	; 32
    1594:	09 f0       	breq	.+2      	; 0x1598 <get_fileinfo+0x6c>
    1596:	4c c0       	rjmp	.+152    	; 0x1630 <get_fileinfo+0x104>
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
    1598:	0f 5f       	subi	r16, 0xFF	; 255
    159a:	1f 4f       	sbci	r17, 0xFF	; 255
    159c:	06 c0       	rjmp	.+12     	; 0x15aa <get_fileinfo+0x7e>
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
    159e:	8c 01       	movw	r16, r24
    15a0:	04 c0       	rjmp	.+8      	; 0x15aa <get_fileinfo+0x7e>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    15a2:	f8 01       	movw	r30, r16
    15a4:	23 83       	std	Z+3, r18	; 0x03
    15a6:	0c 5f       	subi	r16, 0xFC	; 252
    15a8:	1f 4f       	sbci	r17, 0xFF	; 255
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
    15aa:	8b 85       	ldd	r24, Y+11	; 0x0b
    15ac:	f7 01       	movw	r30, r14
    15ae:	80 87       	std	Z+8, r24	; 0x08
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
    15b0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    15b2:	90 e0       	ldi	r25, 0x00	; 0
    15b4:	a0 e0       	ldi	r26, 0x00	; 0
    15b6:	b0 e0       	ldi	r27, 0x00	; 0
    15b8:	b8 2f       	mov	r27, r24
    15ba:	aa 27       	eor	r26, r26
    15bc:	99 27       	eor	r25, r25
    15be:	88 27       	eor	r24, r24
    15c0:	4e 8d       	ldd	r20, Y+30	; 0x1e
    15c2:	50 e0       	ldi	r21, 0x00	; 0
    15c4:	60 e0       	ldi	r22, 0x00	; 0
    15c6:	70 e0       	ldi	r23, 0x00	; 0
    15c8:	ba 01       	movw	r22, r20
    15ca:	55 27       	eor	r21, r21
    15cc:	44 27       	eor	r20, r20
    15ce:	48 2b       	or	r20, r24
    15d0:	59 2b       	or	r21, r25
    15d2:	6a 2b       	or	r22, r26
    15d4:	7b 2b       	or	r23, r27
    15d6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    15d8:	90 e0       	ldi	r25, 0x00	; 0
    15da:	a0 e0       	ldi	r26, 0x00	; 0
    15dc:	b0 e0       	ldi	r27, 0x00	; 0
    15de:	48 2b       	or	r20, r24
    15e0:	59 2b       	or	r21, r25
    15e2:	6a 2b       	or	r22, r26
    15e4:	7b 2b       	or	r23, r27
    15e6:	9d 8d       	ldd	r25, Y+29	; 0x1d
    15e8:	80 e0       	ldi	r24, 0x00	; 0
    15ea:	a0 e0       	ldi	r26, 0x00	; 0
    15ec:	b0 e0       	ldi	r27, 0x00	; 0
    15ee:	84 2b       	or	r24, r20
    15f0:	95 2b       	or	r25, r21
    15f2:	a6 2b       	or	r26, r22
    15f4:	b7 2b       	or	r27, r23
    15f6:	80 83       	st	Z, r24
    15f8:	91 83       	std	Z+1, r25	; 0x01
    15fa:	a2 83       	std	Z+2, r26	; 0x02
    15fc:	b3 83       	std	Z+3, r27	; 0x03
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
    15fe:	39 8d       	ldd	r19, Y+25	; 0x19
    1600:	20 e0       	ldi	r18, 0x00	; 0
    1602:	88 8d       	ldd	r24, Y+24	; 0x18
    1604:	90 e0       	ldi	r25, 0x00	; 0
    1606:	82 2b       	or	r24, r18
    1608:	93 2b       	or	r25, r19
    160a:	95 83       	std	Z+5, r25	; 0x05
    160c:	84 83       	std	Z+4, r24	; 0x04
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
    160e:	9f 89       	ldd	r25, Y+23	; 0x17
    1610:	80 e0       	ldi	r24, 0x00	; 0
    1612:	2e 89       	ldd	r18, Y+22	; 0x16
    1614:	30 e0       	ldi	r19, 0x00	; 0
    1616:	82 2b       	or	r24, r18
    1618:	93 2b       	or	r25, r19
    161a:	97 83       	std	Z+7, r25	; 0x07
    161c:	86 83       	std	Z+6, r24	; 0x06
	}
	*p = 0;		/* Terminate SFN str by a \0 */
    161e:	f8 01       	movw	r30, r16
    1620:	10 82       	st	Z, r1
			}
		}
		tp[i] = 0;	/* Terminate the LFN str by a \0 */
	}
#endif
}
    1622:	df 91       	pop	r29
    1624:	cf 91       	pop	r28
    1626:	1f 91       	pop	r17
    1628:	0f 91       	pop	r16
    162a:	ff 90       	pop	r15
    162c:	ef 90       	pop	r14
    162e:	08 95       	ret
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    1630:	f8 01       	movw	r30, r16
    1632:	81 83       	std	Z+1, r24	; 0x01
    1634:	c8 01       	movw	r24, r16
    1636:	02 96       	adiw	r24, 0x02	; 2
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
    1638:	29 85       	ldd	r18, Y+9	; 0x09
				if (c == ' ') break;
    163a:	20 32       	cpi	r18, 0x20	; 32
    163c:	09 f4       	brne	.+2      	; 0x1640 <get_fileinfo+0x114>
    163e:	af cf       	rjmp	.-162    	; 0x159e <get_fileinfo+0x72>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    1640:	22 83       	std	Z+2, r18	; 0x02
    1642:	c8 01       	movw	r24, r16
    1644:	03 96       	adiw	r24, 0x03	; 3
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
    1646:	2a 85       	ldd	r18, Y+10	; 0x0a
				if (c == ' ') break;
    1648:	20 32       	cpi	r18, 0x20	; 32
    164a:	09 f0       	breq	.+2      	; 0x164e <get_fileinfo+0x122>
    164c:	aa cf       	rjmp	.-172    	; 0x15a2 <get_fileinfo+0x76>
    164e:	a7 cf       	rjmp	.-178    	; 0x159e <get_fileinfo+0x72>

00001650 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
    1650:	dc 01       	movw	r26, r24
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
    1652:	ed 91       	ld	r30, X+
    1654:	fc 91       	ld	r31, X
    1656:	11 97       	sbiw	r26, 0x01	; 1
    1658:	30 97       	sbiw	r30, 0x00	; 0
    165a:	99 f0       	breq	.+38     	; 0x1682 <validate+0x32>
    165c:	80 81       	ld	r24, Z
    165e:	88 23       	and	r24, r24
    1660:	91 f0       	breq	.+36     	; 0x1686 <validate+0x36>
    1662:	26 81       	ldd	r18, Z+6	; 0x06
    1664:	37 81       	ldd	r19, Z+7	; 0x07
    1666:	12 96       	adiw	r26, 0x02	; 2
    1668:	8d 91       	ld	r24, X+
    166a:	9c 91       	ld	r25, X
    166c:	13 97       	sbiw	r26, 0x03	; 3
    166e:	28 17       	cp	r18, r24
    1670:	39 07       	cpc	r19, r25
    1672:	59 f4       	brne	.+22     	; 0x168a <validate+0x3a>
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
    1674:	81 81       	ldd	r24, Z+1	; 0x01
    1676:	0e 94 92 02 	call	0x524	; 0x524 <disk_status>
    167a:	80 ff       	sbrs	r24, 0
    167c:	08 c0       	rjmp	.+16     	; 0x168e <validate+0x3e>
		return FR_NOT_READY;
    167e:	83 e0       	ldi	r24, 0x03	; 3
    1680:	08 95       	ret
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
		return FR_INVALID_OBJECT;
    1682:	89 e0       	ldi	r24, 0x09	; 9
    1684:	08 95       	ret
    1686:	89 e0       	ldi	r24, 0x09	; 9
    1688:	08 95       	ret
    168a:	89 e0       	ldi	r24, 0x09	; 9
    168c:	08 95       	ret
	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
    168e:	80 e0       	ldi	r24, 0x00	; 0
}
    1690:	08 95       	ret

00001692 <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    1692:	0f 93       	push	r16
    1694:	cf 93       	push	r28
    1696:	df 93       	push	r29
    1698:	ec 01       	movw	r28, r24
    169a:	9a 01       	movw	r18, r20
    169c:	ab 01       	movw	r20, r22
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    169e:	bc 01       	movw	r22, r24
    16a0:	6e 5c       	subi	r22, 0xCE	; 206
    16a2:	7f 4f       	sbci	r23, 0xFF	; 255
    16a4:	89 81       	ldd	r24, Y+1	; 0x01
    16a6:	01 e0       	ldi	r16, 0x01	; 1
    16a8:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    16ac:	88 23       	and	r24, r24
    16ae:	09 f0       	breq	.+2      	; 0x16b2 <check_fs+0x20>
    16b0:	83 c0       	rjmp	.+262    	; 0x17b8 <check_fs+0x126>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    16b2:	fe 01       	movw	r30, r28
    16b4:	ef 5c       	subi	r30, 0xCF	; 207
    16b6:	fd 4f       	sbci	r31, 0xFD	; 253
    16b8:	90 81       	ld	r25, Z
    16ba:	80 e0       	ldi	r24, 0x00	; 0
    16bc:	fe 01       	movw	r30, r28
    16be:	e0 5d       	subi	r30, 0xD0	; 208
    16c0:	fd 4f       	sbci	r31, 0xFD	; 253
    16c2:	20 81       	ld	r18, Z
    16c4:	30 e0       	ldi	r19, 0x00	; 0
    16c6:	82 2b       	or	r24, r18
    16c8:	93 2b       	or	r25, r19
    16ca:	2a ea       	ldi	r18, 0xAA	; 170
    16cc:	85 35       	cpi	r24, 0x55	; 85
    16ce:	92 07       	cpc	r25, r18
    16d0:	09 f0       	breq	.+2      	; 0x16d4 <check_fs+0x42>
    16d2:	74 c0       	rjmp	.+232    	; 0x17bc <check_fs+0x12a>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    16d4:	fe 01       	movw	r30, r28
    16d6:	e5 59       	subi	r30, 0x95	; 149
    16d8:	ff 4f       	sbci	r31, 0xFF	; 255
    16da:	80 81       	ld	r24, Z
    16dc:	90 e0       	ldi	r25, 0x00	; 0
    16de:	a0 e0       	ldi	r26, 0x00	; 0
    16e0:	b0 e0       	ldi	r27, 0x00	; 0
    16e2:	b8 2f       	mov	r27, r24
    16e4:	aa 27       	eor	r26, r26
    16e6:	99 27       	eor	r25, r25
    16e8:	88 27       	eor	r24, r24
    16ea:	fe 01       	movw	r30, r28
    16ec:	e6 59       	subi	r30, 0x96	; 150
    16ee:	ff 4f       	sbci	r31, 0xFF	; 255
    16f0:	40 81       	ld	r20, Z
    16f2:	50 e0       	ldi	r21, 0x00	; 0
    16f4:	60 e0       	ldi	r22, 0x00	; 0
    16f6:	70 e0       	ldi	r23, 0x00	; 0
    16f8:	ba 01       	movw	r22, r20
    16fa:	55 27       	eor	r21, r21
    16fc:	44 27       	eor	r20, r20
    16fe:	48 2b       	or	r20, r24
    1700:	59 2b       	or	r21, r25
    1702:	6a 2b       	or	r22, r26
    1704:	7b 2b       	or	r23, r27
    1706:	fe 01       	movw	r30, r28
    1708:	e8 59       	subi	r30, 0x98	; 152
    170a:	ff 4f       	sbci	r31, 0xFF	; 255
    170c:	80 81       	ld	r24, Z
    170e:	90 e0       	ldi	r25, 0x00	; 0
    1710:	a0 e0       	ldi	r26, 0x00	; 0
    1712:	b0 e0       	ldi	r27, 0x00	; 0
    1714:	48 2b       	or	r20, r24
    1716:	59 2b       	or	r21, r25
    1718:	6a 2b       	or	r22, r26
    171a:	7b 2b       	or	r23, r27
    171c:	fe 01       	movw	r30, r28
    171e:	e7 59       	subi	r30, 0x97	; 151
    1720:	ff 4f       	sbci	r31, 0xFF	; 255
    1722:	90 81       	ld	r25, Z
    1724:	80 e0       	ldi	r24, 0x00	; 0
    1726:	a0 e0       	ldi	r26, 0x00	; 0
    1728:	b0 e0       	ldi	r27, 0x00	; 0
    172a:	48 2b       	or	r20, r24
    172c:	59 2b       	or	r21, r25
    172e:	6a 2b       	or	r22, r26
    1730:	7b 2b       	or	r23, r27
    1732:	70 70       	andi	r23, 0x00	; 0
    1734:	46 34       	cpi	r20, 0x46	; 70
    1736:	81 e4       	ldi	r24, 0x41	; 65
    1738:	58 07       	cpc	r21, r24
    173a:	84 e5       	ldi	r24, 0x54	; 84
    173c:	68 07       	cpc	r22, r24
    173e:	80 e0       	ldi	r24, 0x00	; 0
    1740:	78 07       	cpc	r23, r24
    1742:	f1 f1       	breq	.+124    	; 0x17c0 <check_fs+0x12e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    1744:	fe 01       	movw	r30, r28
    1746:	e9 57       	subi	r30, 0x79	; 121
    1748:	ff 4f       	sbci	r31, 0xFF	; 255
    174a:	80 81       	ld	r24, Z
    174c:	90 e0       	ldi	r25, 0x00	; 0
    174e:	a0 e0       	ldi	r26, 0x00	; 0
    1750:	b0 e0       	ldi	r27, 0x00	; 0
    1752:	b8 2f       	mov	r27, r24
    1754:	aa 27       	eor	r26, r26
    1756:	99 27       	eor	r25, r25
    1758:	88 27       	eor	r24, r24
    175a:	fe 01       	movw	r30, r28
    175c:	ea 57       	subi	r30, 0x7A	; 122
    175e:	ff 4f       	sbci	r31, 0xFF	; 255
    1760:	40 81       	ld	r20, Z
    1762:	50 e0       	ldi	r21, 0x00	; 0
    1764:	60 e0       	ldi	r22, 0x00	; 0
    1766:	70 e0       	ldi	r23, 0x00	; 0
    1768:	ba 01       	movw	r22, r20
    176a:	55 27       	eor	r21, r21
    176c:	44 27       	eor	r20, r20
    176e:	48 2b       	or	r20, r24
    1770:	59 2b       	or	r21, r25
    1772:	6a 2b       	or	r22, r26
    1774:	7b 2b       	or	r23, r27
    1776:	fe 01       	movw	r30, r28
    1778:	ec 57       	subi	r30, 0x7C	; 124
    177a:	ff 4f       	sbci	r31, 0xFF	; 255
    177c:	80 81       	ld	r24, Z
    177e:	90 e0       	ldi	r25, 0x00	; 0
    1780:	a0 e0       	ldi	r26, 0x00	; 0
    1782:	b0 e0       	ldi	r27, 0x00	; 0
    1784:	48 2b       	or	r20, r24
    1786:	59 2b       	or	r21, r25
    1788:	6a 2b       	or	r22, r26
    178a:	7b 2b       	or	r23, r27
    178c:	cb 57       	subi	r28, 0x7B	; 123
    178e:	df 4f       	sbci	r29, 0xFF	; 255
    1790:	98 81       	ld	r25, Y
    1792:	80 e0       	ldi	r24, 0x00	; 0
    1794:	a0 e0       	ldi	r26, 0x00	; 0
    1796:	b0 e0       	ldi	r27, 0x00	; 0
    1798:	48 2b       	or	r20, r24
    179a:	59 2b       	or	r21, r25
    179c:	6a 2b       	or	r22, r26
    179e:	7b 2b       	or	r23, r27
    17a0:	70 70       	andi	r23, 0x00	; 0
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
    17a2:	81 e0       	ldi	r24, 0x01	; 1
    17a4:	46 34       	cpi	r20, 0x46	; 70
    17a6:	91 e4       	ldi	r25, 0x41	; 65
    17a8:	59 07       	cpc	r21, r25
    17aa:	94 e5       	ldi	r25, 0x54	; 84
    17ac:	69 07       	cpc	r22, r25
    17ae:	90 e0       	ldi	r25, 0x00	; 0
    17b0:	79 07       	cpc	r23, r25
    17b2:	39 f4       	brne	.+14     	; 0x17c2 <check_fs+0x130>
    17b4:	80 e0       	ldi	r24, 0x00	; 0
    17b6:	05 c0       	rjmp	.+10     	; 0x17c2 <check_fs+0x130>
    17b8:	83 e0       	ldi	r24, 0x03	; 3
    17ba:	03 c0       	rjmp	.+6      	; 0x17c2 <check_fs+0x130>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
    17bc:	82 e0       	ldi	r24, 0x02	; 2
    17be:	01 c0       	rjmp	.+2      	; 0x17c2 <check_fs+0x130>

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;
    17c0:	80 e0       	ldi	r24, 0x00	; 0
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
    17c2:	df 91       	pop	r29
    17c4:	cf 91       	pop	r28
    17c6:	0f 91       	pop	r16
    17c8:	08 95       	ret

000017ca <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
    17ca:	2f 92       	push	r2
    17cc:	3f 92       	push	r3
    17ce:	4f 92       	push	r4
    17d0:	5f 92       	push	r5
    17d2:	6f 92       	push	r6
    17d4:	7f 92       	push	r7
    17d6:	8f 92       	push	r8
    17d8:	9f 92       	push	r9
    17da:	af 92       	push	r10
    17dc:	bf 92       	push	r11
    17de:	cf 92       	push	r12
    17e0:	df 92       	push	r13
    17e2:	ef 92       	push	r14
    17e4:	ff 92       	push	r15
    17e6:	0f 93       	push	r16
    17e8:	1f 93       	push	r17
    17ea:	cf 93       	push	r28
    17ec:	df 93       	push	r29
    17ee:	cd b7       	in	r28, 0x3d	; 61
    17f0:	de b7       	in	r29, 0x3e	; 62
    17f2:	60 97       	sbiw	r28, 0x10	; 16
    17f4:	0f b6       	in	r0, 0x3f	; 63
    17f6:	f8 94       	cli
    17f8:	de bf       	out	0x3e, r29	; 62
    17fa:	0f be       	out	0x3f, r0	; 63
    17fc:	cd bf       	out	0x3d, r28	; 61
    17fe:	8b 01       	movw	r16, r22
    1800:	d4 2e       	mov	r13, r20
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
    1802:	dc 01       	movw	r26, r24
    1804:	ed 91       	ld	r30, X+
    1806:	fc 91       	ld	r31, X
    1808:	11 97       	sbiw	r26, 0x01	; 1
	FATFS *fs;


	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
    180a:	40 81       	ld	r20, Z
    180c:	50 e0       	ldi	r21, 0x00	; 0
    180e:	40 53       	subi	r20, 0x30	; 48
    1810:	50 40       	sbci	r21, 0x00	; 0
    1812:	66 27       	eor	r22, r22
    1814:	57 fd       	sbrc	r21, 7
    1816:	60 95       	com	r22
    1818:	76 2f       	mov	r23, r22
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    181a:	4a 30       	cpi	r20, 0x0A	; 10
    181c:	51 05       	cpc	r21, r1
    181e:	61 05       	cpc	r22, r1
    1820:	71 05       	cpc	r23, r1
    1822:	48 f4       	brcc	.+18     	; 0x1836 <chk_mounted+0x6c>
    1824:	81 81       	ldd	r24, Z+1	; 0x01
    1826:	8a 33       	cpi	r24, 0x3A	; 58
    1828:	31 f4       	brne	.+12     	; 0x1836 <chk_mounted+0x6c>
		p += 2; *path = p;				/* Return pointer to the path name */
    182a:	cf 01       	movw	r24, r30
    182c:	02 96       	adiw	r24, 0x02	; 2
    182e:	11 96       	adiw	r26, 0x01	; 1
    1830:	9c 93       	st	X, r25
    1832:	8e 93       	st	-X, r24
    1834:	05 c0       	rjmp	.+10     	; 0x1840 <chk_mounted+0x76>
	} else {							/* No drive number is given */
#if _FS_RPATH
		vol = CurrVol;					/* Use current drive */
    1836:	40 91 25 04 	lds	r20, 0x0425
    183a:	50 e0       	ldi	r21, 0x00	; 0
    183c:	60 e0       	ldi	r22, 0x00	; 0
    183e:	70 e0       	ldi	r23, 0x00	; 0
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
    1840:	f8 01       	movw	r30, r16
    1842:	11 82       	std	Z+1, r1	; 0x01
    1844:	10 82       	st	Z, r1
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    1846:	41 15       	cp	r20, r1
    1848:	51 05       	cpc	r21, r1
    184a:	61 05       	cpc	r22, r1
    184c:	71 05       	cpc	r23, r1
    184e:	09 f0       	breq	.+2      	; 0x1852 <chk_mounted+0x88>
    1850:	a3 c3       	rjmp	.+1862   	; 0x1f98 <chk_mounted+0x7ce>
		return FR_INVALID_DRIVE;
	fs = FatFs[vol];					/* Get corresponding file system object */
    1852:	e0 90 23 04 	lds	r14, 0x0423
    1856:	f0 90 24 04 	lds	r15, 0x0424
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    185a:	e1 14       	cp	r14, r1
    185c:	f1 04       	cpc	r15, r1
    185e:	09 f4       	brne	.+2      	; 0x1862 <chk_mounted+0x98>
    1860:	9d c3       	rjmp	.+1850   	; 0x1f9c <chk_mounted+0x7d2>

	ENTER_FF(fs);						/* Lock file system */

	*rfs = fs;							/* Return pointer to the corresponding file system object */
    1862:	f1 82       	std	Z+1, r15	; 0x01
    1864:	e0 82       	st	Z, r14
	if (fs->fs_type) {					/* If the volume has been mounted */
    1866:	d7 01       	movw	r26, r14
    1868:	8c 91       	ld	r24, X
    186a:	88 23       	and	r24, r24
    186c:	69 f0       	breq	.+26     	; 0x1888 <chk_mounted+0xbe>
		stat = disk_status(fs->drv);
    186e:	11 96       	adiw	r26, 0x01	; 1
    1870:	8c 91       	ld	r24, X
    1872:	0e 94 92 02 	call	0x524	; 0x524 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    1876:	80 fd       	sbrc	r24, 0
    1878:	07 c0       	rjmp	.+14     	; 0x1888 <chk_mounted+0xbe>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
    187a:	dd 20       	and	r13, r13
    187c:	09 f4       	brne	.+2      	; 0x1880 <chk_mounted+0xb6>
    187e:	90 c3       	rjmp	.+1824   	; 0x1fa0 <chk_mounted+0x7d6>
    1880:	82 fd       	sbrc	r24, 2
    1882:	90 c3       	rjmp	.+1824   	; 0x1fa4 <chk_mounted+0x7da>
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
    1884:	80 e0       	ldi	r24, 0x00	; 0
    1886:	af c3       	rjmp	.+1886   	; 0x1fe6 <chk_mounted+0x81c>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
    1888:	f7 01       	movw	r30, r14
    188a:	10 82       	st	Z, r1
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    188c:	11 82       	std	Z+1, r1	; 0x01
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
    188e:	80 e0       	ldi	r24, 0x00	; 0
    1890:	0e 94 c2 01 	call	0x384	; 0x384 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    1894:	80 fd       	sbrc	r24, 0
    1896:	88 c3       	rjmp	.+1808   	; 0x1fa8 <chk_mounted+0x7de>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    1898:	dd 20       	and	r13, r13
    189a:	11 f0       	breq	.+4      	; 0x18a0 <chk_mounted+0xd6>
    189c:	82 fd       	sbrc	r24, 2
    189e:	86 c3       	rjmp	.+1804   	; 0x1fac <chk_mounted+0x7e2>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    18a0:	c7 01       	movw	r24, r14
    18a2:	40 e0       	ldi	r20, 0x00	; 0
    18a4:	50 e0       	ldi	r21, 0x00	; 0
    18a6:	ba 01       	movw	r22, r20
    18a8:	0e 94 49 0b 	call	0x1692	; 0x1692 <check_fs>
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    18ac:	81 30       	cpi	r24, 0x01	; 1
    18ae:	e9 f5       	brne	.+122    	; 0x192a <chk_mounted+0x160>
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
    18b0:	f7 01       	movw	r30, r14
    18b2:	ec 50       	subi	r30, 0x0C	; 12
    18b4:	fe 4f       	sbci	r31, 0xFE	; 254
    18b6:	80 81       	ld	r24, Z
    18b8:	88 23       	and	r24, r24
    18ba:	09 f4       	brne	.+2      	; 0x18be <chk_mounted+0xf4>
    18bc:	79 c3       	rjmp	.+1778   	; 0x1fb0 <chk_mounted+0x7e6>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    18be:	f7 01       	movw	r30, r14
    18c0:	e5 50       	subi	r30, 0x05	; 5
    18c2:	fe 4f       	sbci	r31, 0xFE	; 254
    18c4:	80 81       	ld	r24, Z
    18c6:	90 e0       	ldi	r25, 0x00	; 0
    18c8:	a0 e0       	ldi	r26, 0x00	; 0
    18ca:	b0 e0       	ldi	r27, 0x00	; 0
    18cc:	b8 2f       	mov	r27, r24
    18ce:	aa 27       	eor	r26, r26
    18d0:	99 27       	eor	r25, r25
    18d2:	88 27       	eor	r24, r24
    18d4:	f7 01       	movw	r30, r14
    18d6:	e6 50       	subi	r30, 0x06	; 6
    18d8:	fe 4f       	sbci	r31, 0xFE	; 254
    18da:	40 81       	ld	r20, Z
    18dc:	50 e0       	ldi	r21, 0x00	; 0
    18de:	60 e0       	ldi	r22, 0x00	; 0
    18e0:	70 e0       	ldi	r23, 0x00	; 0
    18e2:	ba 01       	movw	r22, r20
    18e4:	55 27       	eor	r21, r21
    18e6:	44 27       	eor	r20, r20
    18e8:	84 2b       	or	r24, r20
    18ea:	95 2b       	or	r25, r21
    18ec:	a6 2b       	or	r26, r22
    18ee:	b7 2b       	or	r27, r23
    18f0:	f7 01       	movw	r30, r14
    18f2:	e8 50       	subi	r30, 0x08	; 8
    18f4:	fe 4f       	sbci	r31, 0xFE	; 254
    18f6:	40 81       	ld	r20, Z
    18f8:	50 e0       	ldi	r21, 0x00	; 0
    18fa:	60 e0       	ldi	r22, 0x00	; 0
    18fc:	70 e0       	ldi	r23, 0x00	; 0
    18fe:	48 2b       	or	r20, r24
    1900:	59 2b       	or	r21, r25
    1902:	6a 2b       	or	r22, r26
    1904:	7b 2b       	or	r23, r27
    1906:	f7 01       	movw	r30, r14
    1908:	e7 50       	subi	r30, 0x07	; 7
    190a:	fe 4f       	sbci	r31, 0xFE	; 254
    190c:	90 81       	ld	r25, Z
    190e:	80 e0       	ldi	r24, 0x00	; 0
    1910:	4c 01       	movw	r8, r24
    1912:	aa 24       	eor	r10, r10
    1914:	bb 24       	eor	r11, r11
    1916:	84 2a       	or	r8, r20
    1918:	95 2a       	or	r9, r21
    191a:	a6 2a       	or	r10, r22
    191c:	b7 2a       	or	r11, r23
			fmt = check_fs(fs, bsect);		/* Check the partition */
    191e:	c7 01       	movw	r24, r14
    1920:	b5 01       	movw	r22, r10
    1922:	a4 01       	movw	r20, r8
    1924:	0e 94 49 0b 	call	0x1692	; 0x1692 <check_fs>
    1928:	03 c0       	rjmp	.+6      	; 0x1930 <chk_mounted+0x166>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    192a:	88 24       	eor	r8, r8
    192c:	99 24       	eor	r9, r9
    192e:	54 01       	movw	r10, r8
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    1930:	83 30       	cpi	r24, 0x03	; 3
    1932:	09 f4       	brne	.+2      	; 0x1936 <chk_mounted+0x16c>
    1934:	3f c3       	rjmp	.+1662   	; 0x1fb4 <chk_mounted+0x7ea>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    1936:	88 23       	and	r24, r24
    1938:	09 f0       	breq	.+2      	; 0x193c <chk_mounted+0x172>
    193a:	3e c3       	rjmp	.+1660   	; 0x1fb8 <chk_mounted+0x7ee>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    193c:	d7 01       	movw	r26, r14
    193e:	de 96       	adiw	r26, 0x3e	; 62
    1940:	9c 91       	ld	r25, X
    1942:	de 97       	sbiw	r26, 0x3e	; 62
    1944:	80 e0       	ldi	r24, 0x00	; 0
    1946:	dd 96       	adiw	r26, 0x3d	; 61
    1948:	2c 91       	ld	r18, X
    194a:	dd 97       	sbiw	r26, 0x3d	; 61
    194c:	30 e0       	ldi	r19, 0x00	; 0
    194e:	82 2b       	or	r24, r18
    1950:	93 2b       	or	r25, r19
    1952:	b2 e0       	ldi	r27, 0x02	; 2
    1954:	80 30       	cpi	r24, 0x00	; 0
    1956:	9b 07       	cpc	r25, r27
    1958:	09 f0       	breq	.+2      	; 0x195c <chk_mounted+0x192>
    195a:	30 c3       	rjmp	.+1632   	; 0x1fbc <chk_mounted+0x7f2>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    195c:	f7 01       	movw	r30, r14
    195e:	e7 5b       	subi	r30, 0xB7	; 183
    1960:	ff 4f       	sbci	r31, 0xFF	; 255
    1962:	30 81       	ld	r19, Z
    1964:	20 e0       	ldi	r18, 0x00	; 0
    1966:	f7 01       	movw	r30, r14
    1968:	e8 5b       	subi	r30, 0xB8	; 184
    196a:	ff 4f       	sbci	r31, 0xFF	; 255
    196c:	80 81       	ld	r24, Z
    196e:	90 e0       	ldi	r25, 0x00	; 0
    1970:	82 2b       	or	r24, r18
    1972:	93 2b       	or	r25, r19
    1974:	2c 01       	movw	r4, r24
    1976:	66 24       	eor	r6, r6
    1978:	77 24       	eor	r7, r7
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    197a:	41 14       	cp	r4, r1
    197c:	51 04       	cpc	r5, r1
    197e:	61 04       	cpc	r6, r1
    1980:	71 04       	cpc	r7, r1
    1982:	89 f5       	brne	.+98     	; 0x19e6 <chk_mounted+0x21c>
    1984:	f7 01       	movw	r30, r14
    1986:	e7 5a       	subi	r30, 0xA7	; 167
    1988:	ff 4f       	sbci	r31, 0xFF	; 255
    198a:	40 81       	ld	r20, Z
    198c:	50 e0       	ldi	r21, 0x00	; 0
    198e:	60 e0       	ldi	r22, 0x00	; 0
    1990:	70 e0       	ldi	r23, 0x00	; 0
    1992:	74 2f       	mov	r23, r20
    1994:	66 27       	eor	r22, r22
    1996:	55 27       	eor	r21, r21
    1998:	44 27       	eor	r20, r20
    199a:	f7 01       	movw	r30, r14
    199c:	e8 5a       	subi	r30, 0xA8	; 168
    199e:	ff 4f       	sbci	r31, 0xFF	; 255
    19a0:	80 81       	ld	r24, Z
    19a2:	90 e0       	ldi	r25, 0x00	; 0
    19a4:	a0 e0       	ldi	r26, 0x00	; 0
    19a6:	b0 e0       	ldi	r27, 0x00	; 0
    19a8:	dc 01       	movw	r26, r24
    19aa:	99 27       	eor	r25, r25
    19ac:	88 27       	eor	r24, r24
    19ae:	48 2b       	or	r20, r24
    19b0:	59 2b       	or	r21, r25
    19b2:	6a 2b       	or	r22, r26
    19b4:	7b 2b       	or	r23, r27
    19b6:	f7 01       	movw	r30, r14
    19b8:	ea 5a       	subi	r30, 0xAA	; 170
    19ba:	ff 4f       	sbci	r31, 0xFF	; 255
    19bc:	80 81       	ld	r24, Z
    19be:	90 e0       	ldi	r25, 0x00	; 0
    19c0:	a0 e0       	ldi	r26, 0x00	; 0
    19c2:	b0 e0       	ldi	r27, 0x00	; 0
    19c4:	48 2b       	or	r20, r24
    19c6:	59 2b       	or	r21, r25
    19c8:	6a 2b       	or	r22, r26
    19ca:	7b 2b       	or	r23, r27
    19cc:	f7 01       	movw	r30, r14
    19ce:	e9 5a       	subi	r30, 0xA9	; 169
    19d0:	ff 4f       	sbci	r31, 0xFF	; 255
    19d2:	90 81       	ld	r25, Z
    19d4:	80 e0       	ldi	r24, 0x00	; 0
    19d6:	a0 e0       	ldi	r26, 0x00	; 0
    19d8:	b0 e0       	ldi	r27, 0x00	; 0
    19da:	2a 01       	movw	r4, r20
    19dc:	3b 01       	movw	r6, r22
    19de:	48 2a       	or	r4, r24
    19e0:	59 2a       	or	r5, r25
    19e2:	6a 2a       	or	r6, r26
    19e4:	7b 2a       	or	r7, r27
	fs->fsize = fasize;
    19e6:	f7 01       	movw	r30, r14
    19e8:	46 8e       	std	Z+30, r4	; 0x1e
    19ea:	57 8e       	std	Z+31, r5	; 0x1f
    19ec:	60 a2       	lds	r22, 0x90
    19ee:	71 a2       	lds	r23, 0x91

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    19f0:	ee 5b       	subi	r30, 0xBE	; 190
    19f2:	ff 4f       	sbci	r31, 0xFF	; 255
    19f4:	c0 80       	ld	r12, Z
    19f6:	d7 01       	movw	r26, r14
    19f8:	13 96       	adiw	r26, 0x03	; 3
    19fa:	cc 92       	st	X, r12
    19fc:	13 97       	sbiw	r26, 0x03	; 3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    19fe:	8c 2d       	mov	r24, r12
    1a00:	81 50       	subi	r24, 0x01	; 1
    1a02:	82 30       	cpi	r24, 0x02	; 2
    1a04:	08 f0       	brcs	.+2      	; 0x1a08 <chk_mounted+0x23e>
    1a06:	dc c2       	rjmp	.+1464   	; 0x1fc0 <chk_mounted+0x7f6>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    1a08:	df 96       	adiw	r26, 0x3f	; 63
    1a0a:	dc 90       	ld	r13, X
    1a0c:	df 97       	sbiw	r26, 0x3f	; 63
    1a0e:	12 96       	adiw	r26, 0x02	; 2
    1a10:	dc 92       	st	X, r13
    1a12:	12 97       	sbiw	r26, 0x02	; 2
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    1a14:	dd 20       	and	r13, r13
    1a16:	09 f4       	brne	.+2      	; 0x1a1a <chk_mounted+0x250>
    1a18:	d5 c2       	rjmp	.+1450   	; 0x1fc4 <chk_mounted+0x7fa>
    1a1a:	8d 2d       	mov	r24, r13
    1a1c:	90 e0       	ldi	r25, 0x00	; 0
    1a1e:	9c 01       	movw	r18, r24
    1a20:	21 50       	subi	r18, 0x01	; 1
    1a22:	30 40       	sbci	r19, 0x00	; 0
    1a24:	82 23       	and	r24, r18
    1a26:	93 23       	and	r25, r19
    1a28:	00 97       	sbiw	r24, 0x00	; 0
    1a2a:	09 f0       	breq	.+2      	; 0x1a2e <chk_mounted+0x264>
    1a2c:	cd c2       	rjmp	.+1434   	; 0x1fc8 <chk_mounted+0x7fe>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    1a2e:	f7 01       	movw	r30, r14
    1a30:	ec 5b       	subi	r30, 0xBC	; 188
    1a32:	ff 4f       	sbci	r31, 0xFF	; 255
    1a34:	30 81       	ld	r19, Z
    1a36:	20 e0       	ldi	r18, 0x00	; 0
    1a38:	f7 01       	movw	r30, r14
    1a3a:	ed 5b       	subi	r30, 0xBD	; 189
    1a3c:	ff 4f       	sbci	r31, 0xFF	; 255
    1a3e:	80 81       	ld	r24, Z
    1a40:	90 e0       	ldi	r25, 0x00	; 0
    1a42:	19 01       	movw	r2, r18
    1a44:	28 2a       	or	r2, r24
    1a46:	39 2a       	or	r3, r25
    1a48:	f7 01       	movw	r30, r14
    1a4a:	31 86       	std	Z+9, r3	; 0x09
    1a4c:	20 86       	std	Z+8, r2	; 0x08
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    1a4e:	c1 01       	movw	r24, r2
    1a50:	8f 70       	andi	r24, 0x0F	; 15
    1a52:	90 70       	andi	r25, 0x00	; 0
    1a54:	00 97       	sbiw	r24, 0x00	; 0
    1a56:	09 f0       	breq	.+2      	; 0x1a5a <chk_mounted+0x290>
    1a58:	b9 c2       	rjmp	.+1394   	; 0x1fcc <chk_mounted+0x802>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    1a5a:	ea 5b       	subi	r30, 0xBA	; 186
    1a5c:	ff 4f       	sbci	r31, 0xFF	; 255
    1a5e:	30 81       	ld	r19, Z
    1a60:	20 e0       	ldi	r18, 0x00	; 0
    1a62:	f7 01       	movw	r30, r14
    1a64:	eb 5b       	subi	r30, 0xBB	; 187
    1a66:	ff 4f       	sbci	r31, 0xFF	; 255
    1a68:	80 81       	ld	r24, Z
    1a6a:	90 e0       	ldi	r25, 0x00	; 0
    1a6c:	82 2b       	or	r24, r18
    1a6e:	93 2b       	or	r25, r19
    1a70:	8c 01       	movw	r16, r24
    1a72:	20 e0       	ldi	r18, 0x00	; 0
    1a74:	30 e0       	ldi	r19, 0x00	; 0
    1a76:	09 83       	std	Y+1, r16	; 0x01
    1a78:	1a 83       	std	Y+2, r17	; 0x02
    1a7a:	2b 83       	std	Y+3, r18	; 0x03
    1a7c:	3c 83       	std	Y+4, r19	; 0x04
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    1a7e:	01 15       	cp	r16, r1
    1a80:	11 05       	cpc	r17, r1
    1a82:	21 05       	cpc	r18, r1
    1a84:	31 05       	cpc	r19, r1
    1a86:	a9 f5       	brne	.+106    	; 0x1af2 <chk_mounted+0x328>
    1a88:	f7 01       	movw	r30, r14
    1a8a:	eb 5a       	subi	r30, 0xAB	; 171
    1a8c:	ff 4f       	sbci	r31, 0xFF	; 255
    1a8e:	80 81       	ld	r24, Z
    1a90:	90 e0       	ldi	r25, 0x00	; 0
    1a92:	a0 e0       	ldi	r26, 0x00	; 0
    1a94:	b0 e0       	ldi	r27, 0x00	; 0
    1a96:	78 2f       	mov	r23, r24
    1a98:	66 27       	eor	r22, r22
    1a9a:	55 27       	eor	r21, r21
    1a9c:	44 27       	eor	r20, r20
    1a9e:	f7 01       	movw	r30, r14
    1aa0:	ec 5a       	subi	r30, 0xAC	; 172
    1aa2:	ff 4f       	sbci	r31, 0xFF	; 255
    1aa4:	80 81       	ld	r24, Z
    1aa6:	90 e0       	ldi	r25, 0x00	; 0
    1aa8:	a0 e0       	ldi	r26, 0x00	; 0
    1aaa:	b0 e0       	ldi	r27, 0x00	; 0
    1aac:	dc 01       	movw	r26, r24
    1aae:	99 27       	eor	r25, r25
    1ab0:	88 27       	eor	r24, r24
    1ab2:	48 2b       	or	r20, r24
    1ab4:	59 2b       	or	r21, r25
    1ab6:	6a 2b       	or	r22, r26
    1ab8:	7b 2b       	or	r23, r27
    1aba:	f7 01       	movw	r30, r14
    1abc:	ee 5a       	subi	r30, 0xAE	; 174
    1abe:	ff 4f       	sbci	r31, 0xFF	; 255
    1ac0:	80 81       	ld	r24, Z
    1ac2:	90 e0       	ldi	r25, 0x00	; 0
    1ac4:	a0 e0       	ldi	r26, 0x00	; 0
    1ac6:	b0 e0       	ldi	r27, 0x00	; 0
    1ac8:	48 2b       	or	r20, r24
    1aca:	59 2b       	or	r21, r25
    1acc:	6a 2b       	or	r22, r26
    1ace:	7b 2b       	or	r23, r27
    1ad0:	f7 01       	movw	r30, r14
    1ad2:	ed 5a       	subi	r30, 0xAD	; 173
    1ad4:	ff 4f       	sbci	r31, 0xFF	; 255
    1ad6:	90 81       	ld	r25, Z
    1ad8:	80 e0       	ldi	r24, 0x00	; 0
    1ada:	a0 e0       	ldi	r26, 0x00	; 0
    1adc:	b0 e0       	ldi	r27, 0x00	; 0
    1ade:	8a 01       	movw	r16, r20
    1ae0:	9b 01       	movw	r18, r22
    1ae2:	08 2b       	or	r16, r24
    1ae4:	19 2b       	or	r17, r25
    1ae6:	2a 2b       	or	r18, r26
    1ae8:	3b 2b       	or	r19, r27
    1aea:	09 83       	std	Y+1, r16	; 0x01
    1aec:	1a 83       	std	Y+2, r17	; 0x02
    1aee:	2b 83       	std	Y+3, r18	; 0x03
    1af0:	3c 83       	std	Y+4, r19	; 0x04

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    1af2:	f7 01       	movw	r30, r14
    1af4:	ef 5b       	subi	r30, 0xBF	; 191
    1af6:	ff 4f       	sbci	r31, 0xFF	; 255
    1af8:	30 81       	ld	r19, Z
    1afa:	20 e0       	ldi	r18, 0x00	; 0
    1afc:	f7 01       	movw	r30, r14
    1afe:	e0 5c       	subi	r30, 0xC0	; 192
    1b00:	ff 4f       	sbci	r31, 0xFF	; 255
    1b02:	80 81       	ld	r24, Z
    1b04:	90 e0       	ldi	r25, 0x00	; 0
    1b06:	89 01       	movw	r16, r18
    1b08:	08 2b       	or	r16, r24
    1b0a:	19 2b       	or	r17, r25
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    1b0c:	01 15       	cp	r16, r1
    1b0e:	11 05       	cpc	r17, r1
    1b10:	09 f4       	brne	.+2      	; 0x1b14 <chk_mounted+0x34a>
    1b12:	5e c2       	rjmp	.+1212   	; 0x1fd0 <chk_mounted+0x806>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
    1b14:	2c 2d       	mov	r18, r12
    1b16:	30 e0       	ldi	r19, 0x00	; 0
    1b18:	40 e0       	ldi	r20, 0x00	; 0
    1b1a:	50 e0       	ldi	r21, 0x00	; 0
    1b1c:	c3 01       	movw	r24, r6
    1b1e:	b2 01       	movw	r22, r4
    1b20:	0e 94 26 2b 	call	0x564c	; 0x564c <__mulsi3>
    1b24:	6d 87       	std	Y+13, r22	; 0x0d
    1b26:	7e 87       	std	Y+14, r23	; 0x0e
    1b28:	8f 87       	std	Y+15, r24	; 0x0f
    1b2a:	98 8b       	std	Y+16, r25	; 0x10

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    1b2c:	98 01       	movw	r18, r16
    1b2e:	40 e0       	ldi	r20, 0x00	; 0
    1b30:	50 e0       	ldi	r21, 0x00	; 0
    1b32:	29 87       	std	Y+9, r18	; 0x09
    1b34:	3a 87       	std	Y+10, r19	; 0x0a
    1b36:	4b 87       	std	Y+11, r20	; 0x0b
    1b38:	5c 87       	std	Y+12, r21	; 0x0c
    1b3a:	c1 01       	movw	r24, r2
    1b3c:	92 95       	swap	r25
    1b3e:	82 95       	swap	r24
    1b40:	8f 70       	andi	r24, 0x0F	; 15
    1b42:	89 27       	eor	r24, r25
    1b44:	9f 70       	andi	r25, 0x0F	; 15
    1b46:	89 27       	eor	r24, r25
    1b48:	a0 e0       	ldi	r26, 0x00	; 0
    1b4a:	b0 e0       	ldi	r27, 0x00	; 0
    1b4c:	82 0f       	add	r24, r18
    1b4e:	93 1f       	adc	r25, r19
    1b50:	a4 1f       	adc	r26, r20
    1b52:	b5 1f       	adc	r27, r21
    1b54:	0d 85       	ldd	r16, Y+13	; 0x0d
    1b56:	1e 85       	ldd	r17, Y+14	; 0x0e
    1b58:	2f 85       	ldd	r18, Y+15	; 0x0f
    1b5a:	38 89       	ldd	r19, Y+16	; 0x10
    1b5c:	08 0f       	add	r16, r24
    1b5e:	19 1f       	adc	r17, r25
    1b60:	2a 1f       	adc	r18, r26
    1b62:	3b 1f       	adc	r19, r27
    1b64:	0d 83       	std	Y+5, r16	; 0x05
    1b66:	1e 83       	std	Y+6, r17	; 0x06
    1b68:	2f 83       	std	Y+7, r18	; 0x07
    1b6a:	38 87       	std	Y+8, r19	; 0x08
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    1b6c:	89 81       	ldd	r24, Y+1	; 0x01
    1b6e:	9a 81       	ldd	r25, Y+2	; 0x02
    1b70:	ab 81       	ldd	r26, Y+3	; 0x03
    1b72:	bc 81       	ldd	r27, Y+4	; 0x04
    1b74:	80 17       	cp	r24, r16
    1b76:	91 07       	cpc	r25, r17
    1b78:	a2 07       	cpc	r26, r18
    1b7a:	b3 07       	cpc	r27, r19
    1b7c:	08 f4       	brcc	.+2      	; 0x1b80 <chk_mounted+0x3b6>
    1b7e:	2a c2       	rjmp	.+1108   	; 0x1fd4 <chk_mounted+0x80a>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    1b80:	bc 01       	movw	r22, r24
    1b82:	cd 01       	movw	r24, r26
    1b84:	60 1b       	sub	r22, r16
    1b86:	71 0b       	sbc	r23, r17
    1b88:	82 0b       	sbc	r24, r18
    1b8a:	93 0b       	sbc	r25, r19
    1b8c:	2d 2d       	mov	r18, r13
    1b8e:	30 e0       	ldi	r19, 0x00	; 0
    1b90:	40 e0       	ldi	r20, 0x00	; 0
    1b92:	50 e0       	ldi	r21, 0x00	; 0
    1b94:	0e 94 45 2b 	call	0x568a	; 0x568a <__udivmodsi4>
    1b98:	89 01       	movw	r16, r18
    1b9a:	9a 01       	movw	r18, r20
    1b9c:	d9 01       	movw	r26, r18
    1b9e:	c8 01       	movw	r24, r16
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    1ba0:	01 15       	cp	r16, r1
    1ba2:	11 05       	cpc	r17, r1
    1ba4:	21 05       	cpc	r18, r1
    1ba6:	31 05       	cpc	r19, r1
    1ba8:	09 f4       	brne	.+2      	; 0x1bac <chk_mounted+0x3e2>
    1baa:	16 c2       	rjmp	.+1068   	; 0x1fd8 <chk_mounted+0x80e>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    1bac:	06 3f       	cpi	r16, 0xF6	; 246
    1bae:	ef e0       	ldi	r30, 0x0F	; 15
    1bb0:	1e 07       	cpc	r17, r30
    1bb2:	e0 e0       	ldi	r30, 0x00	; 0
    1bb4:	2e 07       	cpc	r18, r30
    1bb6:	e0 e0       	ldi	r30, 0x00	; 0
    1bb8:	3e 07       	cpc	r19, r30
    1bba:	18 f4       	brcc	.+6      	; 0x1bc2 <chk_mounted+0x3f8>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
    1bbc:	dd 24       	eor	r13, r13
    1bbe:	d3 94       	inc	r13
    1bc0:	03 c0       	rjmp	.+6      	; 0x1bc8 <chk_mounted+0x3fe>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    1bc2:	dd 24       	eor	r13, r13
    1bc4:	68 94       	set
    1bc6:	d1 f8       	bld	r13, 1
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    1bc8:	86 3f       	cpi	r24, 0xF6	; 246
    1bca:	ff ef       	ldi	r31, 0xFF	; 255
    1bcc:	9f 07       	cpc	r25, r31
    1bce:	f0 e0       	ldi	r31, 0x00	; 0
    1bd0:	af 07       	cpc	r26, r31
    1bd2:	f0 e0       	ldi	r31, 0x00	; 0
    1bd4:	bf 07       	cpc	r27, r31
    1bd6:	08 f0       	brcs	.+2      	; 0x1bda <chk_mounted+0x410>
    1bd8:	1f c2       	rjmp	.+1086   	; 0x2018 <chk_mounted+0x84e>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    1bda:	b9 01       	movw	r22, r18
    1bdc:	a8 01       	movw	r20, r16
    1bde:	4e 5f       	subi	r20, 0xFE	; 254
    1be0:	5f 4f       	sbci	r21, 0xFF	; 255
    1be2:	6f 4f       	sbci	r22, 0xFF	; 255
    1be4:	7f 4f       	sbci	r23, 0xFF	; 255
    1be6:	d7 01       	movw	r26, r14
    1be8:	5a 96       	adiw	r26, 0x1a	; 26
    1bea:	4d 93       	st	X+, r20
    1bec:	5d 93       	st	X+, r21
    1bee:	6d 93       	st	X+, r22
    1bf0:	7c 93       	st	X, r23
    1bf2:	5d 97       	sbiw	r26, 0x1d	; 29
	fs->database = bsect + sysect;						/* Data start sector */
    1bf4:	8d 81       	ldd	r24, Y+5	; 0x05
    1bf6:	9e 81       	ldd	r25, Y+6	; 0x06
    1bf8:	af 81       	ldd	r26, Y+7	; 0x07
    1bfa:	b8 85       	ldd	r27, Y+8	; 0x08
    1bfc:	88 0d       	add	r24, r8
    1bfe:	99 1d       	adc	r25, r9
    1c00:	aa 1d       	adc	r26, r10
    1c02:	bb 1d       	adc	r27, r11
    1c04:	f7 01       	movw	r30, r14
    1c06:	82 a7       	lds	r24, 0x72
    1c08:	93 a7       	lds	r25, 0x73
    1c0a:	a4 a7       	lds	r26, 0x74
    1c0c:	b5 a7       	lds	r27, 0x75
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    1c0e:	89 85       	ldd	r24, Y+9	; 0x09
    1c10:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c12:	ab 85       	ldd	r26, Y+11	; 0x0b
    1c14:	bc 85       	ldd	r27, Y+12	; 0x0c
    1c16:	88 0d       	add	r24, r8
    1c18:	99 1d       	adc	r25, r9
    1c1a:	aa 1d       	adc	r26, r10
    1c1c:	bb 1d       	adc	r27, r11
    1c1e:	82 a3       	lds	r24, 0x52
    1c20:	93 a3       	lds	r25, 0x53
    1c22:	a4 a3       	lds	r26, 0x54
    1c24:	b5 a3       	lds	r27, 0x55
	if (fmt == FS_FAT32) {
    1c26:	f3 e0       	ldi	r31, 0x03	; 3
    1c28:	df 16       	cp	r13, r31
    1c2a:	09 f0       	breq	.+2      	; 0x1c2e <chk_mounted+0x464>
    1c2c:	41 c0       	rjmp	.+130    	; 0x1cb0 <chk_mounted+0x4e6>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    1c2e:	21 14       	cp	r2, r1
    1c30:	31 04       	cpc	r3, r1
    1c32:	09 f0       	breq	.+2      	; 0x1c36 <chk_mounted+0x46c>
    1c34:	d3 c1       	rjmp	.+934    	; 0x1fdc <chk_mounted+0x812>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    1c36:	f7 01       	movw	r30, r14
    1c38:	ef 59       	subi	r30, 0x9F	; 159
    1c3a:	ff 4f       	sbci	r31, 0xFF	; 255
    1c3c:	80 81       	ld	r24, Z
    1c3e:	90 e0       	ldi	r25, 0x00	; 0
    1c40:	a0 e0       	ldi	r26, 0x00	; 0
    1c42:	b0 e0       	ldi	r27, 0x00	; 0
    1c44:	38 2f       	mov	r19, r24
    1c46:	22 27       	eor	r18, r18
    1c48:	11 27       	eor	r17, r17
    1c4a:	00 27       	eor	r16, r16
    1c4c:	f7 01       	movw	r30, r14
    1c4e:	e0 5a       	subi	r30, 0xA0	; 160
    1c50:	ff 4f       	sbci	r31, 0xFF	; 255
    1c52:	80 81       	ld	r24, Z
    1c54:	90 e0       	ldi	r25, 0x00	; 0
    1c56:	a0 e0       	ldi	r26, 0x00	; 0
    1c58:	b0 e0       	ldi	r27, 0x00	; 0
    1c5a:	dc 01       	movw	r26, r24
    1c5c:	99 27       	eor	r25, r25
    1c5e:	88 27       	eor	r24, r24
    1c60:	08 2b       	or	r16, r24
    1c62:	19 2b       	or	r17, r25
    1c64:	2a 2b       	or	r18, r26
    1c66:	3b 2b       	or	r19, r27
    1c68:	f7 01       	movw	r30, r14
    1c6a:	e2 5a       	subi	r30, 0xA2	; 162
    1c6c:	ff 4f       	sbci	r31, 0xFF	; 255
    1c6e:	80 81       	ld	r24, Z
    1c70:	90 e0       	ldi	r25, 0x00	; 0
    1c72:	a0 e0       	ldi	r26, 0x00	; 0
    1c74:	b0 e0       	ldi	r27, 0x00	; 0
    1c76:	08 2b       	or	r16, r24
    1c78:	19 2b       	or	r17, r25
    1c7a:	2a 2b       	or	r18, r26
    1c7c:	3b 2b       	or	r19, r27
    1c7e:	f7 01       	movw	r30, r14
    1c80:	e1 5a       	subi	r30, 0xA1	; 161
    1c82:	ff 4f       	sbci	r31, 0xFF	; 255
    1c84:	90 81       	ld	r25, Z
    1c86:	80 e0       	ldi	r24, 0x00	; 0
    1c88:	a0 e0       	ldi	r26, 0x00	; 0
    1c8a:	b0 e0       	ldi	r27, 0x00	; 0
    1c8c:	80 2b       	or	r24, r16
    1c8e:	91 2b       	or	r25, r17
    1c90:	a2 2b       	or	r26, r18
    1c92:	b3 2b       	or	r27, r19
    1c94:	f7 01       	movw	r30, r14
    1c96:	86 a3       	lds	r24, 0x56
    1c98:	97 a3       	lds	r25, 0x57
    1c9a:	a0 a7       	lds	r26, 0x70
    1c9c:	b1 a7       	lds	r27, 0x71
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    1c9e:	44 0f       	add	r20, r20
    1ca0:	55 1f       	adc	r21, r21
    1ca2:	66 1f       	adc	r22, r22
    1ca4:	77 1f       	adc	r23, r23
    1ca6:	44 0f       	add	r20, r20
    1ca8:	55 1f       	adc	r21, r21
    1caa:	66 1f       	adc	r22, r22
    1cac:	77 1f       	adc	r23, r23
    1cae:	2f c0       	rjmp	.+94     	; 0x1d0e <chk_mounted+0x544>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    1cb0:	21 14       	cp	r2, r1
    1cb2:	31 04       	cpc	r3, r1
    1cb4:	09 f4       	brne	.+2      	; 0x1cb8 <chk_mounted+0x4ee>
    1cb6:	94 c1       	rjmp	.+808    	; 0x1fe0 <chk_mounted+0x816>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    1cb8:	0d 85       	ldd	r16, Y+13	; 0x0d
    1cba:	1e 85       	ldd	r17, Y+14	; 0x0e
    1cbc:	2f 85       	ldd	r18, Y+15	; 0x0f
    1cbe:	38 89       	ldd	r19, Y+16	; 0x10
    1cc0:	80 0f       	add	r24, r16
    1cc2:	91 1f       	adc	r25, r17
    1cc4:	a2 1f       	adc	r26, r18
    1cc6:	b3 1f       	adc	r27, r19
    1cc8:	f7 01       	movw	r30, r14
    1cca:	86 a3       	lds	r24, 0x56
    1ccc:	97 a3       	lds	r25, 0x57
    1cce:	a0 a7       	lds	r26, 0x70
    1cd0:	b1 a7       	lds	r27, 0x71
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    1cd2:	f2 e0       	ldi	r31, 0x02	; 2
    1cd4:	df 16       	cp	r13, r31
    1cd6:	29 f4       	brne	.+10     	; 0x1ce2 <chk_mounted+0x518>
    1cd8:	44 0f       	add	r20, r20
    1cda:	55 1f       	adc	r21, r21
    1cdc:	66 1f       	adc	r22, r22
    1cde:	77 1f       	adc	r23, r23
    1ce0:	16 c0       	rjmp	.+44     	; 0x1d0e <chk_mounted+0x544>
    1ce2:	db 01       	movw	r26, r22
    1ce4:	ca 01       	movw	r24, r20
    1ce6:	88 0f       	add	r24, r24
    1ce8:	99 1f       	adc	r25, r25
    1cea:	aa 1f       	adc	r26, r26
    1cec:	bb 1f       	adc	r27, r27
    1cee:	84 0f       	add	r24, r20
    1cf0:	95 1f       	adc	r25, r21
    1cf2:	a6 1f       	adc	r26, r22
    1cf4:	b7 1f       	adc	r27, r23
    1cf6:	b6 95       	lsr	r27
    1cf8:	a7 95       	ror	r26
    1cfa:	97 95       	ror	r25
    1cfc:	87 95       	ror	r24
    1cfe:	41 70       	andi	r20, 0x01	; 1
    1d00:	50 70       	andi	r21, 0x00	; 0
    1d02:	60 70       	andi	r22, 0x00	; 0
    1d04:	70 70       	andi	r23, 0x00	; 0
    1d06:	48 0f       	add	r20, r24
    1d08:	59 1f       	adc	r21, r25
    1d0a:	6a 1f       	adc	r22, r26
    1d0c:	7b 1f       	adc	r23, r27
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    1d0e:	db 01       	movw	r26, r22
    1d10:	ca 01       	movw	r24, r20
    1d12:	81 50       	subi	r24, 0x01	; 1
    1d14:	9e 4f       	sbci	r25, 0xFE	; 254
    1d16:	af 4f       	sbci	r26, 0xFF	; 255
    1d18:	bf 4f       	sbci	r27, 0xFF	; 255
    1d1a:	07 2e       	mov	r0, r23
    1d1c:	79 e0       	ldi	r23, 0x09	; 9
    1d1e:	b6 95       	lsr	r27
    1d20:	a7 95       	ror	r26
    1d22:	97 95       	ror	r25
    1d24:	87 95       	ror	r24
    1d26:	7a 95       	dec	r23
    1d28:	d1 f7       	brne	.-12     	; 0x1d1e <chk_mounted+0x554>
    1d2a:	70 2d       	mov	r23, r0
    1d2c:	48 16       	cp	r4, r24
    1d2e:	59 06       	cpc	r5, r25
    1d30:	6a 06       	cpc	r6, r26
    1d32:	7b 06       	cpc	r7, r27
    1d34:	08 f4       	brcc	.+2      	; 0x1d38 <chk_mounted+0x56e>
    1d36:	56 c1       	rjmp	.+684    	; 0x1fe4 <chk_mounted+0x81a>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
    1d38:	8f ef       	ldi	r24, 0xFF	; 255
    1d3a:	9f ef       	ldi	r25, 0xFF	; 255
    1d3c:	dc 01       	movw	r26, r24
    1d3e:	f7 01       	movw	r30, r14
    1d40:	86 87       	std	Z+14, r24	; 0x0e
    1d42:	97 87       	std	Z+15, r25	; 0x0f
    1d44:	a0 8b       	std	Z+16, r26	; 0x10
    1d46:	b1 8b       	std	Z+17, r27	; 0x11
	fs->last_clust = 0;
    1d48:	12 86       	std	Z+10, r1	; 0x0a
    1d4a:	13 86       	std	Z+11, r1	; 0x0b
    1d4c:	14 86       	std	Z+12, r1	; 0x0c
    1d4e:	15 86       	std	Z+13, r1	; 0x0d

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
    1d50:	b3 e0       	ldi	r27, 0x03	; 3
    1d52:	db 16       	cp	r13, r27
    1d54:	09 f0       	breq	.+2      	; 0x1d58 <chk_mounted+0x58e>
    1d56:	03 c1       	rjmp	.+518    	; 0x1f5e <chk_mounted+0x794>
	 	fs->fsi_flag = 0;
    1d58:	15 82       	std	Z+5, r1	; 0x05
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
    1d5a:	ed 59       	subi	r30, 0x9D	; 157
    1d5c:	ff 4f       	sbci	r31, 0xFF	; 255
    1d5e:	30 81       	ld	r19, Z
    1d60:	20 e0       	ldi	r18, 0x00	; 0
    1d62:	f7 01       	movw	r30, r14
    1d64:	ee 59       	subi	r30, 0x9E	; 158
    1d66:	ff 4f       	sbci	r31, 0xFF	; 255
    1d68:	80 81       	ld	r24, Z
    1d6a:	90 e0       	ldi	r25, 0x00	; 0
    1d6c:	82 2b       	or	r24, r18
    1d6e:	93 2b       	or	r25, r19
    1d70:	a0 e0       	ldi	r26, 0x00	; 0
    1d72:	b0 e0       	ldi	r27, 0x00	; 0
    1d74:	a5 01       	movw	r20, r10
    1d76:	94 01       	movw	r18, r8
    1d78:	28 0f       	add	r18, r24
    1d7a:	39 1f       	adc	r19, r25
    1d7c:	4a 1f       	adc	r20, r26
    1d7e:	5b 1f       	adc	r21, r27
    1d80:	d7 01       	movw	r26, r14
    1d82:	52 96       	adiw	r26, 0x12	; 18
    1d84:	2d 93       	st	X+, r18
    1d86:	3d 93       	st	X+, r19
    1d88:	4d 93       	st	X+, r20
    1d8a:	5c 93       	st	X, r21
    1d8c:	55 97       	sbiw	r26, 0x15	; 21
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    1d8e:	b7 01       	movw	r22, r14
    1d90:	6e 5c       	subi	r22, 0xCE	; 206
    1d92:	7f 4f       	sbci	r23, 0xFF	; 255
    1d94:	11 96       	adiw	r26, 0x01	; 1
    1d96:	8c 91       	ld	r24, X
    1d98:	01 e0       	ldi	r16, 0x01	; 1
    1d9a:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    1d9e:	88 23       	and	r24, r24
    1da0:	09 f0       	breq	.+2      	; 0x1da4 <chk_mounted+0x5da>
    1da2:	dd c0       	rjmp	.+442    	; 0x1f5e <chk_mounted+0x794>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
    1da4:	f7 01       	movw	r30, r14
    1da6:	ef 5c       	subi	r30, 0xCF	; 207
    1da8:	fd 4f       	sbci	r31, 0xFD	; 253
    1daa:	30 81       	ld	r19, Z
    1dac:	20 e0       	ldi	r18, 0x00	; 0
    1dae:	f7 01       	movw	r30, r14
    1db0:	e0 5d       	subi	r30, 0xD0	; 208
    1db2:	fd 4f       	sbci	r31, 0xFD	; 253
    1db4:	80 81       	ld	r24, Z
    1db6:	90 e0       	ldi	r25, 0x00	; 0
    1db8:	82 2b       	or	r24, r18
    1dba:	93 2b       	or	r25, r19

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    1dbc:	ba ea       	ldi	r27, 0xAA	; 170
    1dbe:	85 35       	cpi	r24, 0x55	; 85
    1dc0:	9b 07       	cpc	r25, r27
    1dc2:	09 f0       	breq	.+2      	; 0x1dc6 <chk_mounted+0x5fc>
    1dc4:	cc c0       	rjmp	.+408    	; 0x1f5e <chk_mounted+0x794>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
    1dc6:	f7 01       	movw	r30, r14
    1dc8:	45 a9       	sts	0x45, r20
    1dca:	50 e0       	ldi	r21, 0x00	; 0
    1dcc:	60 e0       	ldi	r22, 0x00	; 0
    1dce:	70 e0       	ldi	r23, 0x00	; 0
    1dd0:	74 2f       	mov	r23, r20
    1dd2:	66 27       	eor	r22, r22
    1dd4:	55 27       	eor	r21, r21
    1dd6:	44 27       	eor	r20, r20
    1dd8:	84 a9       	sts	0x44, r24
    1dda:	90 e0       	ldi	r25, 0x00	; 0
    1ddc:	a0 e0       	ldi	r26, 0x00	; 0
    1dde:	b0 e0       	ldi	r27, 0x00	; 0
    1de0:	dc 01       	movw	r26, r24
    1de2:	99 27       	eor	r25, r25
    1de4:	88 27       	eor	r24, r24
    1de6:	48 2b       	or	r20, r24
    1de8:	59 2b       	or	r21, r25
    1dea:	6a 2b       	or	r22, r26
    1dec:	7b 2b       	or	r23, r27
    1dee:	82 a9       	sts	0x42, r24
    1df0:	90 e0       	ldi	r25, 0x00	; 0
    1df2:	a0 e0       	ldi	r26, 0x00	; 0
    1df4:	b0 e0       	ldi	r27, 0x00	; 0
    1df6:	48 2b       	or	r20, r24
    1df8:	59 2b       	or	r21, r25
    1dfa:	6a 2b       	or	r22, r26
    1dfc:	7b 2b       	or	r23, r27
    1dfe:	93 a9       	sts	0x43, r25
    1e00:	80 e0       	ldi	r24, 0x00	; 0
    1e02:	a0 e0       	ldi	r26, 0x00	; 0
    1e04:	b0 e0       	ldi	r27, 0x00	; 0
    1e06:	84 2b       	or	r24, r20
    1e08:	95 2b       	or	r25, r21
    1e0a:	a6 2b       	or	r26, r22
    1e0c:	b7 2b       	or	r27, r23
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
    1e0e:	82 35       	cpi	r24, 0x52	; 82
    1e10:	f2 e5       	ldi	r31, 0x52	; 82
    1e12:	9f 07       	cpc	r25, r31
    1e14:	f1 e6       	ldi	r31, 0x61	; 97
    1e16:	af 07       	cpc	r26, r31
    1e18:	f1 e4       	ldi	r31, 0x41	; 65
    1e1a:	bf 07       	cpc	r27, r31
    1e1c:	09 f0       	breq	.+2      	; 0x1e20 <chk_mounted+0x656>
    1e1e:	9f c0       	rjmp	.+318    	; 0x1f5e <chk_mounted+0x794>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
    1e20:	f7 01       	movw	r30, r14
    1e22:	e7 5e       	subi	r30, 0xE7	; 231
    1e24:	fd 4f       	sbci	r31, 0xFD	; 253
    1e26:	80 81       	ld	r24, Z
    1e28:	90 e0       	ldi	r25, 0x00	; 0
    1e2a:	a0 e0       	ldi	r26, 0x00	; 0
    1e2c:	b0 e0       	ldi	r27, 0x00	; 0
    1e2e:	b8 2f       	mov	r27, r24
    1e30:	aa 27       	eor	r26, r26
    1e32:	99 27       	eor	r25, r25
    1e34:	88 27       	eor	r24, r24
    1e36:	f7 01       	movw	r30, r14
    1e38:	e8 5e       	subi	r30, 0xE8	; 232
    1e3a:	fd 4f       	sbci	r31, 0xFD	; 253
    1e3c:	40 81       	ld	r20, Z
    1e3e:	50 e0       	ldi	r21, 0x00	; 0
    1e40:	60 e0       	ldi	r22, 0x00	; 0
    1e42:	70 e0       	ldi	r23, 0x00	; 0
    1e44:	ba 01       	movw	r22, r20
    1e46:	55 27       	eor	r21, r21
    1e48:	44 27       	eor	r20, r20
    1e4a:	84 2b       	or	r24, r20
    1e4c:	95 2b       	or	r25, r21
    1e4e:	a6 2b       	or	r26, r22
    1e50:	b7 2b       	or	r27, r23
    1e52:	f7 01       	movw	r30, r14
    1e54:	ea 5e       	subi	r30, 0xEA	; 234
    1e56:	fd 4f       	sbci	r31, 0xFD	; 253
    1e58:	40 81       	ld	r20, Z
    1e5a:	50 e0       	ldi	r21, 0x00	; 0
    1e5c:	60 e0       	ldi	r22, 0x00	; 0
    1e5e:	70 e0       	ldi	r23, 0x00	; 0
    1e60:	48 2b       	or	r20, r24
    1e62:	59 2b       	or	r21, r25
    1e64:	6a 2b       	or	r22, r26
    1e66:	7b 2b       	or	r23, r27
    1e68:	f7 01       	movw	r30, r14
    1e6a:	e9 5e       	subi	r30, 0xE9	; 233
    1e6c:	fd 4f       	sbci	r31, 0xFD	; 253
    1e6e:	90 81       	ld	r25, Z
    1e70:	80 e0       	ldi	r24, 0x00	; 0
    1e72:	a0 e0       	ldi	r26, 0x00	; 0
    1e74:	b0 e0       	ldi	r27, 0x00	; 0
    1e76:	84 2b       	or	r24, r20
    1e78:	95 2b       	or	r25, r21
    1e7a:	a6 2b       	or	r26, r22
    1e7c:	b7 2b       	or	r27, r23
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
    1e7e:	82 37       	cpi	r24, 0x72	; 114
    1e80:	02 e7       	ldi	r16, 0x72	; 114
    1e82:	90 07       	cpc	r25, r16
    1e84:	01 e4       	ldi	r16, 0x41	; 65
    1e86:	a0 07       	cpc	r26, r16
    1e88:	01 e6       	ldi	r16, 0x61	; 97
    1e8a:	b0 07       	cpc	r27, r16
    1e8c:	09 f0       	breq	.+2      	; 0x1e90 <chk_mounted+0x6c6>
    1e8e:	67 c0       	rjmp	.+206    	; 0x1f5e <chk_mounted+0x794>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
    1e90:	f7 01       	movw	r30, r14
    1e92:	ef 5d       	subi	r30, 0xDF	; 223
    1e94:	fd 4f       	sbci	r31, 0xFD	; 253
    1e96:	80 81       	ld	r24, Z
    1e98:	90 e0       	ldi	r25, 0x00	; 0
    1e9a:	a0 e0       	ldi	r26, 0x00	; 0
    1e9c:	b0 e0       	ldi	r27, 0x00	; 0
    1e9e:	b8 2f       	mov	r27, r24
    1ea0:	aa 27       	eor	r26, r26
    1ea2:	99 27       	eor	r25, r25
    1ea4:	88 27       	eor	r24, r24
    1ea6:	f7 01       	movw	r30, r14
    1ea8:	e0 5e       	subi	r30, 0xE0	; 224
    1eaa:	fd 4f       	sbci	r31, 0xFD	; 253
    1eac:	40 81       	ld	r20, Z
    1eae:	50 e0       	ldi	r21, 0x00	; 0
    1eb0:	60 e0       	ldi	r22, 0x00	; 0
    1eb2:	70 e0       	ldi	r23, 0x00	; 0
    1eb4:	ba 01       	movw	r22, r20
    1eb6:	55 27       	eor	r21, r21
    1eb8:	44 27       	eor	r20, r20
    1eba:	84 2b       	or	r24, r20
    1ebc:	95 2b       	or	r25, r21
    1ebe:	a6 2b       	or	r26, r22
    1ec0:	b7 2b       	or	r27, r23
    1ec2:	f7 01       	movw	r30, r14
    1ec4:	e2 5e       	subi	r30, 0xE2	; 226
    1ec6:	fd 4f       	sbci	r31, 0xFD	; 253
    1ec8:	40 81       	ld	r20, Z
    1eca:	50 e0       	ldi	r21, 0x00	; 0
    1ecc:	60 e0       	ldi	r22, 0x00	; 0
    1ece:	70 e0       	ldi	r23, 0x00	; 0
    1ed0:	48 2b       	or	r20, r24
    1ed2:	59 2b       	or	r21, r25
    1ed4:	6a 2b       	or	r22, r26
    1ed6:	7b 2b       	or	r23, r27
    1ed8:	f7 01       	movw	r30, r14
    1eda:	e1 5e       	subi	r30, 0xE1	; 225
    1edc:	fd 4f       	sbci	r31, 0xFD	; 253
    1ede:	90 81       	ld	r25, Z
    1ee0:	80 e0       	ldi	r24, 0x00	; 0
    1ee2:	a0 e0       	ldi	r26, 0x00	; 0
    1ee4:	b0 e0       	ldi	r27, 0x00	; 0
    1ee6:	84 2b       	or	r24, r20
    1ee8:	95 2b       	or	r25, r21
    1eea:	a6 2b       	or	r26, r22
    1eec:	b7 2b       	or	r27, r23
    1eee:	f7 01       	movw	r30, r14
    1ef0:	82 87       	std	Z+10, r24	; 0x0a
    1ef2:	93 87       	std	Z+11, r25	; 0x0b
    1ef4:	a4 87       	std	Z+12, r26	; 0x0c
    1ef6:	b5 87       	std	Z+13, r27	; 0x0d
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
    1ef8:	e3 5e       	subi	r30, 0xE3	; 227
    1efa:	fd 4f       	sbci	r31, 0xFD	; 253
    1efc:	80 81       	ld	r24, Z
    1efe:	90 e0       	ldi	r25, 0x00	; 0
    1f00:	a0 e0       	ldi	r26, 0x00	; 0
    1f02:	b0 e0       	ldi	r27, 0x00	; 0
    1f04:	b8 2f       	mov	r27, r24
    1f06:	aa 27       	eor	r26, r26
    1f08:	99 27       	eor	r25, r25
    1f0a:	88 27       	eor	r24, r24
    1f0c:	f7 01       	movw	r30, r14
    1f0e:	e4 5e       	subi	r30, 0xE4	; 228
    1f10:	fd 4f       	sbci	r31, 0xFD	; 253
    1f12:	40 81       	ld	r20, Z
    1f14:	50 e0       	ldi	r21, 0x00	; 0
    1f16:	60 e0       	ldi	r22, 0x00	; 0
    1f18:	70 e0       	ldi	r23, 0x00	; 0
    1f1a:	ba 01       	movw	r22, r20
    1f1c:	55 27       	eor	r21, r21
    1f1e:	44 27       	eor	r20, r20
    1f20:	84 2b       	or	r24, r20
    1f22:	95 2b       	or	r25, r21
    1f24:	a6 2b       	or	r26, r22
    1f26:	b7 2b       	or	r27, r23
    1f28:	f7 01       	movw	r30, r14
    1f2a:	e6 5e       	subi	r30, 0xE6	; 230
    1f2c:	fd 4f       	sbci	r31, 0xFD	; 253
    1f2e:	40 81       	ld	r20, Z
    1f30:	50 e0       	ldi	r21, 0x00	; 0
    1f32:	60 e0       	ldi	r22, 0x00	; 0
    1f34:	70 e0       	ldi	r23, 0x00	; 0
    1f36:	48 2b       	or	r20, r24
    1f38:	59 2b       	or	r21, r25
    1f3a:	6a 2b       	or	r22, r26
    1f3c:	7b 2b       	or	r23, r27
    1f3e:	f7 01       	movw	r30, r14
    1f40:	e5 5e       	subi	r30, 0xE5	; 229
    1f42:	fd 4f       	sbci	r31, 0xFD	; 253
    1f44:	90 81       	ld	r25, Z
    1f46:	80 e0       	ldi	r24, 0x00	; 0
    1f48:	a0 e0       	ldi	r26, 0x00	; 0
    1f4a:	b0 e0       	ldi	r27, 0x00	; 0
    1f4c:	84 2b       	or	r24, r20
    1f4e:	95 2b       	or	r25, r21
    1f50:	a6 2b       	or	r26, r22
    1f52:	b7 2b       	or	r27, r23
    1f54:	f7 01       	movw	r30, r14
    1f56:	86 87       	std	Z+14, r24	; 0x0e
    1f58:	97 87       	std	Z+15, r25	; 0x0f
    1f5a:	a0 8b       	std	Z+16, r26	; 0x10
    1f5c:	b1 8b       	std	Z+17, r27	; 0x11
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
    1f5e:	d7 01       	movw	r26, r14
    1f60:	dc 92       	st	X, r13
	fs->id = ++Fsid;		/* File system mount ID */
    1f62:	80 91 26 04 	lds	r24, 0x0426
    1f66:	90 91 27 04 	lds	r25, 0x0427
    1f6a:	01 96       	adiw	r24, 0x01	; 1
    1f6c:	90 93 27 04 	sts	0x0427, r25
    1f70:	80 93 26 04 	sts	0x0426, r24
    1f74:	17 96       	adiw	r26, 0x07	; 7
    1f76:	9c 93       	st	X, r25
    1f78:	8e 93       	st	-X, r24
    1f7a:	16 97       	sbiw	r26, 0x06	; 6
	fs->winsect = 0;		/* Invalidate sector cache */
    1f7c:	f7 01       	movw	r30, r14
    1f7e:	16 a6       	lds	r17, 0xb6
    1f80:	17 a6       	lds	r17, 0xb7
    1f82:	10 aa       	sts	0x90, r17
    1f84:	11 aa       	sts	0x91, r17
	fs->wflag = 0;
    1f86:	14 82       	std	Z+4, r1	; 0x04
#if _FS_RPATH
	fs->cdir = 0;			/* Current directory (root dir) */
    1f88:	56 96       	adiw	r26, 0x16	; 22
    1f8a:	1d 92       	st	X+, r1
    1f8c:	1d 92       	st	X+, r1
    1f8e:	1d 92       	st	X+, r1
    1f90:	1c 92       	st	X, r1
    1f92:	59 97       	sbiw	r26, 0x19	; 25
#endif
#if _FS_LOCK				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
    1f94:	80 e0       	ldi	r24, 0x00	; 0
    1f96:	27 c0       	rjmp	.+78     	; 0x1fe6 <chk_mounted+0x81c>
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
    1f98:	8b e0       	ldi	r24, 0x0B	; 11
    1f9a:	25 c0       	rjmp	.+74     	; 0x1fe6 <chk_mounted+0x81c>
	fs = FatFs[vol];					/* Get corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    1f9c:	8c e0       	ldi	r24, 0x0C	; 12
    1f9e:	23 c0       	rjmp	.+70     	; 0x1fe6 <chk_mounted+0x81c>
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
    1fa0:	80 e0       	ldi	r24, 0x00	; 0
    1fa2:	21 c0       	rjmp	.+66     	; 0x1fe6 <chk_mounted+0x81c>
	*rfs = fs;							/* Return pointer to the corresponding file system object */
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
    1fa4:	8a e0       	ldi	r24, 0x0A	; 10
    1fa6:	1f c0       	rjmp	.+62     	; 0x1fe6 <chk_mounted+0x81c>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
    1fa8:	83 e0       	ldi	r24, 0x03	; 3
    1faa:	1d c0       	rjmp	.+58     	; 0x1fe6 <chk_mounted+0x81c>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
    1fac:	8a e0       	ldi	r24, 0x0A	; 10
    1fae:	1b c0       	rjmp	.+54     	; 0x1fe6 <chk_mounted+0x81c>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    1fb0:	8d e0       	ldi	r24, 0x0D	; 13
    1fb2:	19 c0       	rjmp	.+50     	; 0x1fe6 <chk_mounted+0x81c>
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    1fb4:	81 e0       	ldi	r24, 0x01	; 1
    1fb6:	17 c0       	rjmp	.+46     	; 0x1fe6 <chk_mounted+0x81c>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    1fb8:	8d e0       	ldi	r24, 0x0D	; 13
    1fba:	15 c0       	rjmp	.+42     	; 0x1fe6 <chk_mounted+0x81c>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;
    1fbc:	8d e0       	ldi	r24, 0x0D	; 13
    1fbe:	13 c0       	rjmp	.+38     	; 0x1fe6 <chk_mounted+0x81c>
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    1fc0:	8d e0       	ldi	r24, 0x0D	; 13
    1fc2:	11 c0       	rjmp	.+34     	; 0x1fe6 <chk_mounted+0x81c>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    1fc4:	8d e0       	ldi	r24, 0x0D	; 13
    1fc6:	0f c0       	rjmp	.+30     	; 0x1fe6 <chk_mounted+0x81c>
    1fc8:	8d e0       	ldi	r24, 0x0D	; 13
    1fca:	0d c0       	rjmp	.+26     	; 0x1fe6 <chk_mounted+0x81c>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    1fcc:	8d e0       	ldi	r24, 0x0D	; 13
    1fce:	0b c0       	rjmp	.+22     	; 0x1fe6 <chk_mounted+0x81c>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    1fd0:	8d e0       	ldi	r24, 0x0D	; 13
    1fd2:	09 c0       	rjmp	.+18     	; 0x1fe6 <chk_mounted+0x81c>

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    1fd4:	8d e0       	ldi	r24, 0x0D	; 13
    1fd6:	07 c0       	rjmp	.+14     	; 0x1fe6 <chk_mounted+0x81c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    1fd8:	8d e0       	ldi	r24, 0x0D	; 13
    1fda:	05 c0       	rjmp	.+10     	; 0x1fe6 <chk_mounted+0x81c>
	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    1fdc:	8d e0       	ldi	r24, 0x0D	; 13
    1fde:	03 c0       	rjmp	.+6      	; 0x1fe6 <chk_mounted+0x81c>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    1fe0:	8d e0       	ldi	r24, 0x0D	; 13
    1fe2:	01 c0       	rjmp	.+2      	; 0x1fe6 <chk_mounted+0x81c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;
    1fe4:	8d e0       	ldi	r24, 0x0D	; 13
#if _FS_LOCK				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
}
    1fe6:	60 96       	adiw	r28, 0x10	; 16
    1fe8:	0f b6       	in	r0, 0x3f	; 63
    1fea:	f8 94       	cli
    1fec:	de bf       	out	0x3e, r29	; 62
    1fee:	0f be       	out	0x3f, r0	; 63
    1ff0:	cd bf       	out	0x3d, r28	; 61
    1ff2:	df 91       	pop	r29
    1ff4:	cf 91       	pop	r28
    1ff6:	1f 91       	pop	r17
    1ff8:	0f 91       	pop	r16
    1ffa:	ff 90       	pop	r15
    1ffc:	ef 90       	pop	r14
    1ffe:	df 90       	pop	r13
    2000:	cf 90       	pop	r12
    2002:	bf 90       	pop	r11
    2004:	af 90       	pop	r10
    2006:	9f 90       	pop	r9
    2008:	8f 90       	pop	r8
    200a:	7f 90       	pop	r7
    200c:	6f 90       	pop	r6
    200e:	5f 90       	pop	r5
    2010:	4f 90       	pop	r4
    2012:	3f 90       	pop	r3
    2014:	2f 90       	pop	r2
    2016:	08 95       	ret
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    2018:	b9 01       	movw	r22, r18
    201a:	a8 01       	movw	r20, r16
    201c:	4e 5f       	subi	r20, 0xFE	; 254
    201e:	5f 4f       	sbci	r21, 0xFF	; 255
    2020:	6f 4f       	sbci	r22, 0xFF	; 255
    2022:	7f 4f       	sbci	r23, 0xFF	; 255
    2024:	f7 01       	movw	r30, r14
    2026:	42 8f       	std	Z+26, r20	; 0x1a
    2028:	53 8f       	std	Z+27, r21	; 0x1b
    202a:	64 8f       	std	Z+28, r22	; 0x1c
    202c:	75 8f       	std	Z+29, r23	; 0x1d
	fs->database = bsect + sysect;						/* Data start sector */
    202e:	8d 81       	ldd	r24, Y+5	; 0x05
    2030:	9e 81       	ldd	r25, Y+6	; 0x06
    2032:	af 81       	ldd	r26, Y+7	; 0x07
    2034:	b8 85       	ldd	r27, Y+8	; 0x08
    2036:	88 0d       	add	r24, r8
    2038:	99 1d       	adc	r25, r9
    203a:	aa 1d       	adc	r26, r10
    203c:	bb 1d       	adc	r27, r11
    203e:	82 a7       	lds	r24, 0x72
    2040:	93 a7       	lds	r25, 0x73
    2042:	a4 a7       	lds	r26, 0x74
    2044:	b5 a7       	lds	r27, 0x75
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    2046:	89 85       	ldd	r24, Y+9	; 0x09
    2048:	9a 85       	ldd	r25, Y+10	; 0x0a
    204a:	ab 85       	ldd	r26, Y+11	; 0x0b
    204c:	bc 85       	ldd	r27, Y+12	; 0x0c
    204e:	88 0d       	add	r24, r8
    2050:	99 1d       	adc	r25, r9
    2052:	aa 1d       	adc	r26, r10
    2054:	bb 1d       	adc	r27, r11
    2056:	82 a3       	lds	r24, 0x52
    2058:	93 a3       	lds	r25, 0x53
    205a:	a4 a3       	lds	r26, 0x54
    205c:	b5 a3       	lds	r27, 0x55
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    205e:	0f 2e       	mov	r0, r31
    2060:	f3 e0       	ldi	r31, 0x03	; 3
    2062:	df 2e       	mov	r13, r31
    2064:	f0 2d       	mov	r31, r0
    2066:	e3 cd       	rjmp	.-1082   	; 0x1c2e <chk_mounted+0x464>

00002068 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
    2068:	4f 92       	push	r4
    206a:	5f 92       	push	r5
    206c:	6f 92       	push	r6
    206e:	7f 92       	push	r7
    2070:	8f 92       	push	r8
    2072:	9f 92       	push	r9
    2074:	af 92       	push	r10
    2076:	bf 92       	push	r11
    2078:	cf 92       	push	r12
    207a:	df 92       	push	r13
    207c:	ef 92       	push	r14
    207e:	ff 92       	push	r15
    2080:	0f 93       	push	r16
    2082:	cf 93       	push	r28
    2084:	5c 01       	movw	r10, r24
    2086:	2a 01       	movw	r4, r20
    2088:	3b 01       	movw	r6, r22
	DWORD wsect;


	wsect = fs->winsect;
    208a:	fc 01       	movw	r30, r24
    208c:	c6 a4       	lds	r28, 0xa6
    208e:	d7 a4       	lds	r29, 0xa7
    2090:	e0 a8       	sts	0x00, r30
    2092:	f1 a8       	sts	0x81, r31
	if (wsect != sector) {	/* Changed current window */
    2094:	c4 16       	cp	r12, r20
    2096:	d5 06       	cpc	r13, r21
    2098:	e6 06       	cpc	r14, r22
    209a:	f7 06       	cpc	r15, r23
    209c:	09 f4       	brne	.+2      	; 0x20a0 <move_window+0x38>
    209e:	54 c0       	rjmp	.+168    	; 0x2148 <move_window+0xe0>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
    20a0:	84 81       	ldd	r24, Z+4	; 0x04
    20a2:	88 23       	and	r24, r24
    20a4:	d1 f1       	breq	.+116    	; 0x211a <move_window+0xb2>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    20a6:	0f 2e       	mov	r0, r31
    20a8:	f2 e3       	ldi	r31, 0x32	; 50
    20aa:	8f 2e       	mov	r8, r31
    20ac:	99 24       	eor	r9, r9
    20ae:	f0 2d       	mov	r31, r0
    20b0:	8a 0c       	add	r8, r10
    20b2:	9b 1c       	adc	r9, r11
    20b4:	81 81       	ldd	r24, Z+1	; 0x01
    20b6:	b4 01       	movw	r22, r8
    20b8:	a7 01       	movw	r20, r14
    20ba:	96 01       	movw	r18, r12
    20bc:	01 e0       	ldi	r16, 0x01	; 1
    20be:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    20c2:	88 23       	and	r24, r24
    20c4:	09 f0       	breq	.+2      	; 0x20c8 <move_window+0x60>
    20c6:	42 c0       	rjmp	.+132    	; 0x214c <move_window+0xe4>
				return FR_DISK_ERR;
			fs->wflag = 0;
    20c8:	f5 01       	movw	r30, r10
    20ca:	14 82       	std	Z+4, r1	; 0x04
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    20cc:	46 8d       	ldd	r20, Z+30	; 0x1e
    20ce:	57 8d       	ldd	r21, Z+31	; 0x1f
    20d0:	60 a1       	lds	r22, 0x40
    20d2:	71 a1       	lds	r23, 0x41
    20d4:	82 a1       	lds	r24, 0x42
    20d6:	93 a1       	lds	r25, 0x43
    20d8:	a4 a1       	lds	r26, 0x44
    20da:	b5 a1       	lds	r27, 0x45
    20dc:	84 0f       	add	r24, r20
    20de:	95 1f       	adc	r25, r21
    20e0:	a6 1f       	adc	r26, r22
    20e2:	b7 1f       	adc	r27, r23
    20e4:	c8 16       	cp	r12, r24
    20e6:	d9 06       	cpc	r13, r25
    20e8:	ea 06       	cpc	r14, r26
    20ea:	fb 06       	cpc	r15, r27
    20ec:	b0 f4       	brcc	.+44     	; 0x211a <move_window+0xb2>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    20ee:	c3 81       	ldd	r28, Z+3	; 0x03
    20f0:	c2 30       	cpi	r28, 0x02	; 2
    20f2:	98 f0       	brcs	.+38     	; 0x211a <move_window+0xb2>
					wsect += fs->fsize;
    20f4:	f5 01       	movw	r30, r10
    20f6:	86 8d       	ldd	r24, Z+30	; 0x1e
    20f8:	97 8d       	ldd	r25, Z+31	; 0x1f
    20fa:	a0 a1       	lds	r26, 0x40
    20fc:	b1 a1       	lds	r27, 0x41
    20fe:	c8 0e       	add	r12, r24
    2100:	d9 1e       	adc	r13, r25
    2102:	ea 1e       	adc	r14, r26
    2104:	fb 1e       	adc	r15, r27
					disk_write(fs->drv, fs->win, wsect, 1);
    2106:	81 81       	ldd	r24, Z+1	; 0x01
    2108:	b4 01       	movw	r22, r8
    210a:	a7 01       	movw	r20, r14
    210c:	96 01       	movw	r18, r12
    210e:	01 e0       	ldi	r16, 0x01	; 1
    2110:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    2114:	c1 50       	subi	r28, 0x01	; 1
    2116:	c1 30       	cpi	r28, 0x01	; 1
    2118:	69 f7       	brne	.-38     	; 0x20f4 <move_window+0x8c>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
    211a:	41 14       	cp	r4, r1
    211c:	51 04       	cpc	r5, r1
    211e:	61 04       	cpc	r6, r1
    2120:	71 04       	cpc	r7, r1
    2122:	b1 f0       	breq	.+44     	; 0x2150 <move_window+0xe8>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    2124:	b5 01       	movw	r22, r10
    2126:	6e 5c       	subi	r22, 0xCE	; 206
    2128:	7f 4f       	sbci	r23, 0xFF	; 255
    212a:	f5 01       	movw	r30, r10
    212c:	81 81       	ldd	r24, Z+1	; 0x01
    212e:	a3 01       	movw	r20, r6
    2130:	92 01       	movw	r18, r4
    2132:	01 e0       	ldi	r16, 0x01	; 1
    2134:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    2138:	88 23       	and	r24, r24
    213a:	61 f4       	brne	.+24     	; 0x2154 <move_window+0xec>
				return FR_DISK_ERR;
			fs->winsect = sector;
    213c:	f5 01       	movw	r30, r10
    213e:	46 a6       	lds	r20, 0xb6
    2140:	57 a6       	lds	r21, 0xb7
    2142:	60 aa       	sts	0x90, r22
    2144:	71 aa       	sts	0x91, r23
    2146:	07 c0       	rjmp	.+14     	; 0x2156 <move_window+0xee>
		}
	}

	return FR_OK;
    2148:	80 e0       	ldi	r24, 0x00	; 0
    214a:	05 c0       	rjmp	.+10     	; 0x2156 <move_window+0xee>
	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
    214c:	81 e0       	ldi	r24, 0x01	; 1
    214e:	03 c0       	rjmp	.+6      	; 0x2156 <move_window+0xee>
				return FR_DISK_ERR;
			fs->winsect = sector;
		}
	}

	return FR_OK;
    2150:	80 e0       	ldi	r24, 0x00	; 0
    2152:	01 c0       	rjmp	.+2      	; 0x2156 <move_window+0xee>
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
    2154:	81 e0       	ldi	r24, 0x01	; 1
			fs->winsect = sector;
		}
	}

	return FR_OK;
}
    2156:	cf 91       	pop	r28
    2158:	0f 91       	pop	r16
    215a:	ff 90       	pop	r15
    215c:	ef 90       	pop	r14
    215e:	df 90       	pop	r13
    2160:	cf 90       	pop	r12
    2162:	bf 90       	pop	r11
    2164:	af 90       	pop	r10
    2166:	9f 90       	pop	r9
    2168:	8f 90       	pop	r8
    216a:	7f 90       	pop	r7
    216c:	6f 90       	pop	r6
    216e:	5f 90       	pop	r5
    2170:	4f 90       	pop	r4
    2172:	08 95       	ret

00002174 <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
    2174:	ef 92       	push	r14
    2176:	ff 92       	push	r15
    2178:	0f 93       	push	r16
    217a:	1f 93       	push	r17
    217c:	cf 93       	push	r28
    217e:	7c 01       	movw	r14, r24
	FRESULT res;


	res = move_window(fs, 0);
    2180:	40 e0       	ldi	r20, 0x00	; 0
    2182:	50 e0       	ldi	r21, 0x00	; 0
    2184:	ba 01       	movw	r22, r20
    2186:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
    218a:	c8 2f       	mov	r28, r24
	if (res == FR_OK) {
    218c:	88 23       	and	r24, r24
    218e:	09 f0       	breq	.+2      	; 0x2192 <sync+0x1e>
    2190:	78 c0       	rjmp	.+240    	; 0x2282 <sync+0x10e>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    2192:	f7 01       	movw	r30, r14
    2194:	80 81       	ld	r24, Z
    2196:	83 30       	cpi	r24, 0x03	; 3
    2198:	09 f0       	breq	.+2      	; 0x219c <sync+0x28>
    219a:	6a c0       	rjmp	.+212    	; 0x2270 <sync+0xfc>
    219c:	85 81       	ldd	r24, Z+5	; 0x05
    219e:	88 23       	and	r24, r24
    21a0:	09 f4       	brne	.+2      	; 0x21a4 <sync+0x30>
    21a2:	66 c0       	rjmp	.+204    	; 0x2270 <sync+0xfc>
			fs->winsect = 0;
    21a4:	16 a6       	lds	r17, 0xb6
    21a6:	17 a6       	lds	r17, 0xb7
    21a8:	10 aa       	sts	0x90, r17
    21aa:	11 aa       	sts	0x91, r17
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
    21ac:	87 01       	movw	r16, r14
    21ae:	0e 5c       	subi	r16, 0xCE	; 206
    21b0:	1f 4f       	sbci	r17, 0xFF	; 255
    21b2:	c8 01       	movw	r24, r16
    21b4:	60 e0       	ldi	r22, 0x00	; 0
    21b6:	70 e0       	ldi	r23, 0x00	; 0
    21b8:	20 e0       	ldi	r18, 0x00	; 0
    21ba:	32 e0       	ldi	r19, 0x02	; 2
    21bc:	40 e0       	ldi	r20, 0x00	; 0
    21be:	50 e0       	ldi	r21, 0x00	; 0
    21c0:	0e 94 57 0a 	call	0x14ae	; 0x14ae <mem_set>
			ST_WORD(fs->win+BS_55AA, 0xAA55);
    21c4:	f7 01       	movw	r30, r14
    21c6:	e0 5d       	subi	r30, 0xD0	; 208
    21c8:	fd 4f       	sbci	r31, 0xFD	; 253
    21ca:	85 e5       	ldi	r24, 0x55	; 85
    21cc:	80 83       	st	Z, r24
    21ce:	f7 01       	movw	r30, r14
    21d0:	ef 5c       	subi	r30, 0xCF	; 207
    21d2:	fd 4f       	sbci	r31, 0xFD	; 253
    21d4:	8a ea       	ldi	r24, 0xAA	; 170
    21d6:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    21d8:	82 e5       	ldi	r24, 0x52	; 82
    21da:	f7 01       	movw	r30, r14
    21dc:	82 ab       	sts	0x52, r24
    21de:	83 ab       	sts	0x53, r24
    21e0:	81 e6       	ldi	r24, 0x61	; 97
    21e2:	84 ab       	sts	0x54, r24
    21e4:	91 e4       	ldi	r25, 0x41	; 65
    21e6:	95 ab       	sts	0x55, r25
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    21e8:	ea 5e       	subi	r30, 0xEA	; 234
    21ea:	fd 4f       	sbci	r31, 0xFD	; 253
    21ec:	22 e7       	ldi	r18, 0x72	; 114
    21ee:	20 83       	st	Z, r18
    21f0:	f7 01       	movw	r30, r14
    21f2:	e9 5e       	subi	r30, 0xE9	; 233
    21f4:	fd 4f       	sbci	r31, 0xFD	; 253
    21f6:	20 83       	st	Z, r18
    21f8:	f7 01       	movw	r30, r14
    21fa:	e8 5e       	subi	r30, 0xE8	; 232
    21fc:	fd 4f       	sbci	r31, 0xFD	; 253
    21fe:	90 83       	st	Z, r25
    2200:	f7 01       	movw	r30, r14
    2202:	e7 5e       	subi	r30, 0xE7	; 231
    2204:	fd 4f       	sbci	r31, 0xFD	; 253
    2206:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    2208:	f7 01       	movw	r30, r14
    220a:	36 85       	ldd	r19, Z+14	; 0x0e
    220c:	27 85       	ldd	r18, Z+15	; 0x0f
    220e:	90 89       	ldd	r25, Z+16	; 0x10
    2210:	81 89       	ldd	r24, Z+17	; 0x11
    2212:	e6 5e       	subi	r30, 0xE6	; 230
    2214:	fd 4f       	sbci	r31, 0xFD	; 253
    2216:	30 83       	st	Z, r19
    2218:	f7 01       	movw	r30, r14
    221a:	e5 5e       	subi	r30, 0xE5	; 229
    221c:	fd 4f       	sbci	r31, 0xFD	; 253
    221e:	20 83       	st	Z, r18
    2220:	f7 01       	movw	r30, r14
    2222:	e4 5e       	subi	r30, 0xE4	; 228
    2224:	fd 4f       	sbci	r31, 0xFD	; 253
    2226:	90 83       	st	Z, r25
    2228:	f7 01       	movw	r30, r14
    222a:	e3 5e       	subi	r30, 0xE3	; 227
    222c:	fd 4f       	sbci	r31, 0xFD	; 253
    222e:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    2230:	f7 01       	movw	r30, r14
    2232:	32 85       	ldd	r19, Z+10	; 0x0a
    2234:	23 85       	ldd	r18, Z+11	; 0x0b
    2236:	94 85       	ldd	r25, Z+12	; 0x0c
    2238:	85 85       	ldd	r24, Z+13	; 0x0d
    223a:	e2 5e       	subi	r30, 0xE2	; 226
    223c:	fd 4f       	sbci	r31, 0xFD	; 253
    223e:	30 83       	st	Z, r19
    2240:	f7 01       	movw	r30, r14
    2242:	e1 5e       	subi	r30, 0xE1	; 225
    2244:	fd 4f       	sbci	r31, 0xFD	; 253
    2246:	20 83       	st	Z, r18
    2248:	f7 01       	movw	r30, r14
    224a:	e0 5e       	subi	r30, 0xE0	; 224
    224c:	fd 4f       	sbci	r31, 0xFD	; 253
    224e:	90 83       	st	Z, r25
    2250:	f7 01       	movw	r30, r14
    2252:	ef 5d       	subi	r30, 0xDF	; 223
    2254:	fd 4f       	sbci	r31, 0xFD	; 253
    2256:	80 83       	st	Z, r24
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    2258:	f7 01       	movw	r30, r14
    225a:	22 89       	ldd	r18, Z+18	; 0x12
    225c:	33 89       	ldd	r19, Z+19	; 0x13
    225e:	44 89       	ldd	r20, Z+20	; 0x14
    2260:	55 89       	ldd	r21, Z+21	; 0x15
    2262:	81 81       	ldd	r24, Z+1	; 0x01
    2264:	b8 01       	movw	r22, r16
    2266:	01 e0       	ldi	r16, 0x01	; 1
    2268:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
			fs->fsi_flag = 0;
    226c:	f7 01       	movw	r30, r14
    226e:	15 82       	std	Z+5, r1	; 0x05
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    2270:	f7 01       	movw	r30, r14
    2272:	81 81       	ldd	r24, Z+1	; 0x01
    2274:	60 e0       	ldi	r22, 0x00	; 0
    2276:	40 e0       	ldi	r20, 0x00	; 0
    2278:	50 e0       	ldi	r21, 0x00	; 0
    227a:	0e 94 66 03 	call	0x6cc	; 0x6cc <disk_ioctl>
    227e:	81 11       	cpse	r24, r1
			res = FR_DISK_ERR;
    2280:	c1 e0       	ldi	r28, 0x01	; 1
	}

	return res;
}
    2282:	8c 2f       	mov	r24, r28
    2284:	cf 91       	pop	r28
    2286:	1f 91       	pop	r17
    2288:	0f 91       	pop	r16
    228a:	ff 90       	pop	r15
    228c:	ef 90       	pop	r14
    228e:	08 95       	ret

00002290 <get_fattime>:
#include "diskio.h"		/* Declarations of low level disk I/O functions */

DWORD get_fattime( void )
{
	return 0;
}
    2290:	60 e0       	ldi	r22, 0x00	; 0
    2292:	70 e0       	ldi	r23, 0x00	; 0
    2294:	cb 01       	movw	r24, r22
    2296:	08 95       	ret

00002298 <clust2sect>:

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
    2298:	0f 93       	push	r16
    229a:	1f 93       	push	r17
    229c:	cf 93       	push	r28
    229e:	df 93       	push	r29
    22a0:	ec 01       	movw	r28, r24
    22a2:	db 01       	movw	r26, r22
    22a4:	ca 01       	movw	r24, r20
	clst -= 2;
    22a6:	02 97       	sbiw	r24, 0x02	; 2
    22a8:	a1 09       	sbc	r26, r1
    22aa:	b1 09       	sbc	r27, r1
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    22ac:	4a 8d       	ldd	r20, Y+26	; 0x1a
    22ae:	5b 8d       	ldd	r21, Y+27	; 0x1b
    22b0:	6c 8d       	ldd	r22, Y+28	; 0x1c
    22b2:	7d 8d       	ldd	r23, Y+29	; 0x1d
    22b4:	42 50       	subi	r20, 0x02	; 2
    22b6:	50 40       	sbci	r21, 0x00	; 0
    22b8:	60 40       	sbci	r22, 0x00	; 0
    22ba:	70 40       	sbci	r23, 0x00	; 0
    22bc:	84 17       	cp	r24, r20
    22be:	95 07       	cpc	r25, r21
    22c0:	a6 07       	cpc	r26, r22
    22c2:	b7 07       	cpc	r27, r23
    22c4:	98 f4       	brcc	.+38     	; 0x22ec <clust2sect+0x54>
	return clst * fs->csize + fs->database;
    22c6:	2a 81       	ldd	r18, Y+2	; 0x02
    22c8:	30 e0       	ldi	r19, 0x00	; 0
    22ca:	40 e0       	ldi	r20, 0x00	; 0
    22cc:	50 e0       	ldi	r21, 0x00	; 0
    22ce:	bc 01       	movw	r22, r24
    22d0:	cd 01       	movw	r24, r26
    22d2:	0e 94 26 2b 	call	0x564c	; 0x564c <__mulsi3>
    22d6:	8b 01       	movw	r16, r22
    22d8:	9c 01       	movw	r18, r24
    22da:	8a a5       	lds	r24, 0x6a
    22dc:	9b a5       	lds	r25, 0x6b
    22de:	ac a5       	lds	r26, 0x6c
    22e0:	bd a5       	lds	r27, 0x6d
    22e2:	08 0f       	add	r16, r24
    22e4:	19 1f       	adc	r17, r25
    22e6:	2a 1f       	adc	r18, r26
    22e8:	3b 1f       	adc	r19, r27
    22ea:	03 c0       	rjmp	.+6      	; 0x22f2 <clust2sect+0x5a>
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    22ec:	00 e0       	ldi	r16, 0x00	; 0
    22ee:	10 e0       	ldi	r17, 0x00	; 0
    22f0:	98 01       	movw	r18, r16
	return clst * fs->csize + fs->database;
}
    22f2:	60 2f       	mov	r22, r16
    22f4:	71 2f       	mov	r23, r17
    22f6:	82 2f       	mov	r24, r18
    22f8:	93 2f       	mov	r25, r19
    22fa:	df 91       	pop	r29
    22fc:	cf 91       	pop	r28
    22fe:	1f 91       	pop	r17
    2300:	0f 91       	pop	r16
    2302:	08 95       	ret

00002304 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
    2304:	8f 92       	push	r8
    2306:	9f 92       	push	r9
    2308:	af 92       	push	r10
    230a:	bf 92       	push	r11
    230c:	cf 92       	push	r12
    230e:	df 92       	push	r13
    2310:	ef 92       	push	r14
    2312:	ff 92       	push	r15
    2314:	0f 93       	push	r16
    2316:	1f 93       	push	r17
    2318:	cf 93       	push	r28
    231a:	df 93       	push	r29
    231c:	ec 01       	movw	r28, r24
    231e:	6a 01       	movw	r12, r20
    2320:	7b 01       	movw	r14, r22
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
    2322:	42 30       	cpi	r20, 0x02	; 2
    2324:	51 05       	cpc	r21, r1
    2326:	61 05       	cpc	r22, r1
    2328:	71 05       	cpc	r23, r1
    232a:	08 f4       	brcc	.+2      	; 0x232e <get_fat+0x2a>
    232c:	f4 c0       	rjmp	.+488    	; 0x2516 <get_fat+0x212>
    232e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2330:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2332:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2334:	bd 8d       	ldd	r27, Y+29	; 0x1d
    2336:	48 17       	cp	r20, r24
    2338:	59 07       	cpc	r21, r25
    233a:	6a 07       	cpc	r22, r26
    233c:	7b 07       	cpc	r23, r27
    233e:	08 f0       	brcs	.+2      	; 0x2342 <get_fat+0x3e>
    2340:	ef c0       	rjmp	.+478    	; 0x2520 <get_fat+0x21c>
		return 1;

	switch (fs->fs_type) {
    2342:	88 81       	ld	r24, Y
    2344:	82 30       	cpi	r24, 0x02	; 2
    2346:	09 f4       	brne	.+2      	; 0x234a <get_fat+0x46>
    2348:	81 c0       	rjmp	.+258    	; 0x244c <get_fat+0x148>
    234a:	83 30       	cpi	r24, 0x03	; 3
    234c:	09 f4       	brne	.+2      	; 0x2350 <get_fat+0x4c>
    234e:	a0 c0       	rjmp	.+320    	; 0x2490 <get_fat+0x18c>
    2350:	81 30       	cpi	r24, 0x01	; 1
    2352:	09 f0       	breq	.+2      	; 0x2356 <get_fat+0x52>
    2354:	ea c0       	rjmp	.+468    	; 0x252a <get_fat+0x226>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
    2356:	4a 01       	movw	r8, r20
    2358:	5b 01       	movw	r10, r22
    235a:	b6 94       	lsr	r11
    235c:	a7 94       	ror	r10
    235e:	97 94       	ror	r9
    2360:	87 94       	ror	r8
    2362:	84 0e       	add	r8, r20
    2364:	95 1e       	adc	r9, r21
    2366:	a6 1e       	adc	r10, r22
    2368:	b7 1e       	adc	r11, r23
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    236a:	b5 01       	movw	r22, r10
    236c:	a4 01       	movw	r20, r8
    236e:	03 2e       	mov	r0, r19
    2370:	39 e0       	ldi	r19, 0x09	; 9
    2372:	76 95       	lsr	r23
    2374:	67 95       	ror	r22
    2376:	57 95       	ror	r21
    2378:	47 95       	ror	r20
    237a:	3a 95       	dec	r19
    237c:	d1 f7       	brne	.-12     	; 0x2372 <get_fat+0x6e>
    237e:	30 2d       	mov	r19, r0
    2380:	8a a1       	lds	r24, 0x4a
    2382:	9b a1       	lds	r25, 0x4b
    2384:	ac a1       	lds	r26, 0x4c
    2386:	bd a1       	lds	r27, 0x4d
    2388:	48 0f       	add	r20, r24
    238a:	59 1f       	adc	r21, r25
    238c:	6a 1f       	adc	r22, r26
    238e:	7b 1f       	adc	r23, r27
    2390:	ce 01       	movw	r24, r28
    2392:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
    2396:	88 23       	and	r24, r24
    2398:	09 f0       	breq	.+2      	; 0x239c <get_fat+0x98>
    239a:	cb c0       	rjmp	.+406    	; 0x2532 <get_fat+0x22e>
		wc = fs->win[bc % SS(fs)]; bc++;
    239c:	d5 01       	movw	r26, r10
    239e:	c4 01       	movw	r24, r8
    23a0:	91 70       	andi	r25, 0x01	; 1
    23a2:	a0 70       	andi	r26, 0x00	; 0
    23a4:	b0 70       	andi	r27, 0x00	; 0
    23a6:	fe 01       	movw	r30, r28
    23a8:	e8 0f       	add	r30, r24
    23aa:	f9 1f       	adc	r31, r25
    23ac:	12 a9       	sts	0x42, r17
    23ae:	08 94       	sec
    23b0:	81 1c       	adc	r8, r1
    23b2:	91 1c       	adc	r9, r1
    23b4:	a1 1c       	adc	r10, r1
    23b6:	b1 1c       	adc	r11, r1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    23b8:	b5 01       	movw	r22, r10
    23ba:	a4 01       	movw	r20, r8
    23bc:	03 2e       	mov	r0, r19
    23be:	39 e0       	ldi	r19, 0x09	; 9
    23c0:	76 95       	lsr	r23
    23c2:	67 95       	ror	r22
    23c4:	57 95       	ror	r21
    23c6:	47 95       	ror	r20
    23c8:	3a 95       	dec	r19
    23ca:	d1 f7       	brne	.-12     	; 0x23c0 <get_fat+0xbc>
    23cc:	30 2d       	mov	r19, r0
    23ce:	8a a1       	lds	r24, 0x4a
    23d0:	9b a1       	lds	r25, 0x4b
    23d2:	ac a1       	lds	r26, 0x4c
    23d4:	bd a1       	lds	r27, 0x4d
    23d6:	48 0f       	add	r20, r24
    23d8:	59 1f       	adc	r21, r25
    23da:	6a 1f       	adc	r22, r26
    23dc:	7b 1f       	adc	r23, r27
    23de:	ce 01       	movw	r24, r28
    23e0:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
    23e4:	88 23       	and	r24, r24
    23e6:	09 f0       	breq	.+2      	; 0x23ea <get_fat+0xe6>
    23e8:	a8 c0       	rjmp	.+336    	; 0x253a <get_fat+0x236>

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
    23ea:	41 2f       	mov	r20, r17
    23ec:	50 e0       	ldi	r21, 0x00	; 0
    23ee:	60 e0       	ldi	r22, 0x00	; 0
    23f0:	70 e0       	ldi	r23, 0x00	; 0
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
    23f2:	8f ef       	ldi	r24, 0xFF	; 255
    23f4:	91 e0       	ldi	r25, 0x01	; 1
    23f6:	a0 e0       	ldi	r26, 0x00	; 0
    23f8:	b0 e0       	ldi	r27, 0x00	; 0
    23fa:	88 22       	and	r8, r24
    23fc:	99 22       	and	r9, r25
    23fe:	aa 22       	and	r10, r26
    2400:	bb 22       	and	r11, r27
    2402:	fe 01       	movw	r30, r28
    2404:	e8 0d       	add	r30, r8
    2406:	f9 1d       	adc	r31, r9
    2408:	92 a9       	sts	0x42, r25
    240a:	80 e0       	ldi	r24, 0x00	; 0
    240c:	8c 01       	movw	r16, r24
    240e:	22 27       	eor	r18, r18
    2410:	17 fd       	sbrc	r17, 7
    2412:	20 95       	com	r18
    2414:	32 2f       	mov	r19, r18
    2416:	40 2b       	or	r20, r16
    2418:	51 2b       	or	r21, r17
    241a:	62 2b       	or	r22, r18
    241c:	73 2b       	or	r23, r19
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    241e:	91 e0       	ldi	r25, 0x01	; 1
    2420:	c9 22       	and	r12, r25
    2422:	dd 24       	eor	r13, r13
    2424:	c1 14       	cp	r12, r1
    2426:	d1 04       	cpc	r13, r1
    2428:	59 f0       	breq	.+22     	; 0x2440 <get_fat+0x13c>
    242a:	8a 01       	movw	r16, r20
    242c:	9b 01       	movw	r18, r22
    242e:	68 94       	set
    2430:	13 f8       	bld	r1, 3
    2432:	36 95       	lsr	r19
    2434:	27 95       	ror	r18
    2436:	17 95       	ror	r17
    2438:	07 95       	ror	r16
    243a:	16 94       	lsr	r1
    243c:	d1 f7       	brne	.-12     	; 0x2432 <get_fat+0x12e>
    243e:	88 c0       	rjmp	.+272    	; 0x2550 <get_fat+0x24c>
    2440:	8a 01       	movw	r16, r20
    2442:	9b 01       	movw	r18, r22
    2444:	1f 70       	andi	r17, 0x0F	; 15
    2446:	20 70       	andi	r18, 0x00	; 0
    2448:	30 70       	andi	r19, 0x00	; 0
    244a:	82 c0       	rjmp	.+260    	; 0x2550 <get_fat+0x24c>

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    244c:	45 2f       	mov	r20, r21
    244e:	56 2f       	mov	r21, r22
    2450:	67 2f       	mov	r22, r23
    2452:	77 27       	eor	r23, r23
    2454:	8a a1       	lds	r24, 0x4a
    2456:	9b a1       	lds	r25, 0x4b
    2458:	ac a1       	lds	r26, 0x4c
    245a:	bd a1       	lds	r27, 0x4d
    245c:	48 0f       	add	r20, r24
    245e:	59 1f       	adc	r21, r25
    2460:	6a 1f       	adc	r22, r26
    2462:	7b 1f       	adc	r23, r27
    2464:	ce 01       	movw	r24, r28
    2466:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
    246a:	88 23       	and	r24, r24
    246c:	09 f0       	breq	.+2      	; 0x2470 <get_fat+0x16c>
    246e:	69 c0       	rjmp	.+210    	; 0x2542 <get_fat+0x23e>
		p = &fs->win[clst * 2 % SS(fs)];
    2470:	f6 01       	movw	r30, r12
    2472:	ee 0f       	add	r30, r30
    2474:	ff 1f       	adc	r31, r31
    2476:	f1 70       	andi	r31, 0x01	; 1
		return LD_WORD(p);
    2478:	ce 0f       	add	r28, r30
    247a:	df 1f       	adc	r29, r31
    247c:	9b a9       	sts	0x4b, r25
    247e:	80 e0       	ldi	r24, 0x00	; 0
    2480:	0a a9       	sts	0x4a, r16
    2482:	10 e0       	ldi	r17, 0x00	; 0
    2484:	80 2b       	or	r24, r16
    2486:	91 2b       	or	r25, r17
    2488:	8c 01       	movw	r16, r24
    248a:	20 e0       	ldi	r18, 0x00	; 0
    248c:	30 e0       	ldi	r19, 0x00	; 0
    248e:	60 c0       	rjmp	.+192    	; 0x2550 <get_fat+0x24c>

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    2490:	68 94       	set
    2492:	16 f8       	bld	r1, 6
    2494:	76 95       	lsr	r23
    2496:	67 95       	ror	r22
    2498:	57 95       	ror	r21
    249a:	47 95       	ror	r20
    249c:	16 94       	lsr	r1
    249e:	d1 f7       	brne	.-12     	; 0x2494 <get_fat+0x190>
    24a0:	8a a1       	lds	r24, 0x4a
    24a2:	9b a1       	lds	r25, 0x4b
    24a4:	ac a1       	lds	r26, 0x4c
    24a6:	bd a1       	lds	r27, 0x4d
    24a8:	48 0f       	add	r20, r24
    24aa:	59 1f       	adc	r21, r25
    24ac:	6a 1f       	adc	r22, r26
    24ae:	7b 1f       	adc	r23, r27
    24b0:	ce 01       	movw	r24, r28
    24b2:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
    24b6:	88 23       	and	r24, r24
    24b8:	09 f0       	breq	.+2      	; 0x24bc <get_fat+0x1b8>
    24ba:	47 c0       	rjmp	.+142    	; 0x254a <get_fat+0x246>
		p = &fs->win[clst * 4 % SS(fs)];
    24bc:	f6 01       	movw	r30, r12
    24be:	ee 0f       	add	r30, r30
    24c0:	ff 1f       	adc	r31, r31
    24c2:	ee 0f       	add	r30, r30
    24c4:	ff 1f       	adc	r31, r31
    24c6:	f1 70       	andi	r31, 0x01	; 1
		return LD_DWORD(p) & 0x0FFFFFFF;
    24c8:	ce 0f       	add	r28, r30
    24ca:	df 1f       	adc	r29, r31
    24cc:	0d a9       	sts	0x4d, r16
    24ce:	10 e0       	ldi	r17, 0x00	; 0
    24d0:	20 e0       	ldi	r18, 0x00	; 0
    24d2:	30 e0       	ldi	r19, 0x00	; 0
    24d4:	30 2f       	mov	r19, r16
    24d6:	22 27       	eor	r18, r18
    24d8:	11 27       	eor	r17, r17
    24da:	00 27       	eor	r16, r16
    24dc:	8c a9       	sts	0x4c, r24
    24de:	90 e0       	ldi	r25, 0x00	; 0
    24e0:	a0 e0       	ldi	r26, 0x00	; 0
    24e2:	b0 e0       	ldi	r27, 0x00	; 0
    24e4:	dc 01       	movw	r26, r24
    24e6:	99 27       	eor	r25, r25
    24e8:	88 27       	eor	r24, r24
    24ea:	08 2b       	or	r16, r24
    24ec:	19 2b       	or	r17, r25
    24ee:	2a 2b       	or	r18, r26
    24f0:	3b 2b       	or	r19, r27
    24f2:	8a a9       	sts	0x4a, r24
    24f4:	90 e0       	ldi	r25, 0x00	; 0
    24f6:	a0 e0       	ldi	r26, 0x00	; 0
    24f8:	b0 e0       	ldi	r27, 0x00	; 0
    24fa:	08 2b       	or	r16, r24
    24fc:	19 2b       	or	r17, r25
    24fe:	2a 2b       	or	r18, r26
    2500:	3b 2b       	or	r19, r27
    2502:	9b a9       	sts	0x4b, r25
    2504:	80 e0       	ldi	r24, 0x00	; 0
    2506:	a0 e0       	ldi	r26, 0x00	; 0
    2508:	b0 e0       	ldi	r27, 0x00	; 0
    250a:	08 2b       	or	r16, r24
    250c:	19 2b       	or	r17, r25
    250e:	2a 2b       	or	r18, r26
    2510:	3b 2b       	or	r19, r27
    2512:	3f 70       	andi	r19, 0x0F	; 15
    2514:	1d c0       	rjmp	.+58     	; 0x2550 <get_fat+0x24c>
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;
    2516:	01 e0       	ldi	r16, 0x01	; 1
    2518:	10 e0       	ldi	r17, 0x00	; 0
    251a:	20 e0       	ldi	r18, 0x00	; 0
    251c:	30 e0       	ldi	r19, 0x00	; 0
    251e:	18 c0       	rjmp	.+48     	; 0x2550 <get_fat+0x24c>
    2520:	01 e0       	ldi	r16, 0x01	; 1
    2522:	10 e0       	ldi	r17, 0x00	; 0
    2524:	20 e0       	ldi	r18, 0x00	; 0
    2526:	30 e0       	ldi	r19, 0x00	; 0
    2528:	13 c0       	rjmp	.+38     	; 0x2550 <get_fat+0x24c>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    252a:	0f ef       	ldi	r16, 0xFF	; 255
    252c:	1f ef       	ldi	r17, 0xFF	; 255
    252e:	98 01       	movw	r18, r16
    2530:	0f c0       	rjmp	.+30     	; 0x2550 <get_fat+0x24c>
    2532:	0f ef       	ldi	r16, 0xFF	; 255
    2534:	1f ef       	ldi	r17, 0xFF	; 255
    2536:	98 01       	movw	r18, r16
    2538:	0b c0       	rjmp	.+22     	; 0x2550 <get_fat+0x24c>
    253a:	0f ef       	ldi	r16, 0xFF	; 255
    253c:	1f ef       	ldi	r17, 0xFF	; 255
    253e:	98 01       	movw	r18, r16
    2540:	07 c0       	rjmp	.+14     	; 0x2550 <get_fat+0x24c>
    2542:	0f ef       	ldi	r16, 0xFF	; 255
    2544:	1f ef       	ldi	r17, 0xFF	; 255
    2546:	98 01       	movw	r18, r16
    2548:	03 c0       	rjmp	.+6      	; 0x2550 <get_fat+0x24c>
    254a:	0f ef       	ldi	r16, 0xFF	; 255
    254c:	1f ef       	ldi	r17, 0xFF	; 255
    254e:	98 01       	movw	r18, r16
}
    2550:	60 2f       	mov	r22, r16
    2552:	71 2f       	mov	r23, r17
    2554:	82 2f       	mov	r24, r18
    2556:	93 2f       	mov	r25, r19
    2558:	df 91       	pop	r29
    255a:	cf 91       	pop	r28
    255c:	1f 91       	pop	r17
    255e:	0f 91       	pop	r16
    2560:	ff 90       	pop	r15
    2562:	ef 90       	pop	r14
    2564:	df 90       	pop	r13
    2566:	cf 90       	pop	r12
    2568:	bf 90       	pop	r11
    256a:	af 90       	pop	r10
    256c:	9f 90       	pop	r9
    256e:	8f 90       	pop	r8
    2570:	08 95       	ret

00002572 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Index of directory table */
)
{
    2572:	ef 92       	push	r14
    2574:	ff 92       	push	r15
    2576:	0f 93       	push	r16
    2578:	1f 93       	push	r17
    257a:	cf 93       	push	r28
    257c:	df 93       	push	r29
    257e:	ec 01       	movw	r28, r24
    2580:	8b 01       	movw	r16, r22
	DWORD clst;
	WORD ic;


	dj->index = idx;
    2582:	7d 83       	std	Y+5, r23	; 0x05
    2584:	6c 83       	std	Y+4, r22	; 0x04
	clst = dj->sclust;
    2586:	4e 81       	ldd	r20, Y+6	; 0x06
    2588:	5f 81       	ldd	r21, Y+7	; 0x07
    258a:	68 85       	ldd	r22, Y+8	; 0x08
    258c:	79 85       	ldd	r23, Y+9	; 0x09
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    258e:	41 30       	cpi	r20, 0x01	; 1
    2590:	51 05       	cpc	r21, r1
    2592:	61 05       	cpc	r22, r1
    2594:	71 05       	cpc	r23, r1
    2596:	09 f4       	brne	.+2      	; 0x259a <dir_sdi+0x28>
    2598:	9f c0       	rjmp	.+318    	; 0x26d8 <dir_sdi+0x166>
    259a:	e8 81       	ld	r30, Y
    259c:	f9 81       	ldd	r31, Y+1	; 0x01
    259e:	82 8d       	ldd	r24, Z+26	; 0x1a
    25a0:	93 8d       	ldd	r25, Z+27	; 0x1b
    25a2:	a4 8d       	ldd	r26, Z+28	; 0x1c
    25a4:	b5 8d       	ldd	r27, Z+29	; 0x1d
    25a6:	48 17       	cp	r20, r24
    25a8:	59 07       	cpc	r21, r25
    25aa:	6a 07       	cpc	r22, r26
    25ac:	7b 07       	cpc	r23, r27
    25ae:	08 f0       	brcs	.+2      	; 0x25b2 <dir_sdi+0x40>
    25b0:	95 c0       	rjmp	.+298    	; 0x26dc <dir_sdi+0x16a>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    25b2:	41 15       	cp	r20, r1
    25b4:	51 05       	cpc	r21, r1
    25b6:	61 05       	cpc	r22, r1
    25b8:	71 05       	cpc	r23, r1
    25ba:	69 f5       	brne	.+90     	; 0x2616 <dir_sdi+0xa4>
    25bc:	80 81       	ld	r24, Z
    25be:	83 30       	cpi	r24, 0x03	; 3
    25c0:	49 f4       	brne	.+18     	; 0x25d4 <dir_sdi+0x62>
		clst = dj->fs->dirbase;
    25c2:	46 a1       	lds	r20, 0x46
    25c4:	57 a1       	lds	r21, 0x47
    25c6:	60 a5       	lds	r22, 0x60
    25c8:	71 a5       	lds	r23, 0x61

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    25ca:	41 15       	cp	r20, r1
    25cc:	51 05       	cpc	r21, r1
    25ce:	61 05       	cpc	r22, r1
    25d0:	71 05       	cpc	r23, r1
    25d2:	09 f5       	brne	.+66     	; 0x2616 <dir_sdi+0xa4>
		dj->clust = clst;
    25d4:	1a 86       	std	Y+10, r1	; 0x0a
    25d6:	1b 86       	std	Y+11, r1	; 0x0b
    25d8:	1c 86       	std	Y+12, r1	; 0x0c
    25da:	1d 86       	std	Y+13, r1	; 0x0d
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    25dc:	80 85       	ldd	r24, Z+8	; 0x08
    25de:	91 85       	ldd	r25, Z+9	; 0x09
    25e0:	08 17       	cp	r16, r24
    25e2:	19 07       	cpc	r17, r25
    25e4:	08 f0       	brcs	.+2      	; 0x25e8 <dir_sdi+0x76>
    25e6:	7c c0       	rjmp	.+248    	; 0x26e0 <dir_sdi+0x16e>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    25e8:	c8 01       	movw	r24, r16
    25ea:	92 95       	swap	r25
    25ec:	82 95       	swap	r24
    25ee:	8f 70       	andi	r24, 0x0F	; 15
    25f0:	89 27       	eor	r24, r25
    25f2:	9f 70       	andi	r25, 0x0F	; 15
    25f4:	89 27       	eor	r24, r25
    25f6:	ac 01       	movw	r20, r24
    25f8:	60 e0       	ldi	r22, 0x00	; 0
    25fa:	70 e0       	ldi	r23, 0x00	; 0
    25fc:	86 a1       	lds	r24, 0x46
    25fe:	97 a1       	lds	r25, 0x47
    2600:	a0 a5       	lds	r26, 0x60
    2602:	b1 a5       	lds	r27, 0x61
    2604:	84 0f       	add	r24, r20
    2606:	95 1f       	adc	r25, r21
    2608:	a6 1f       	adc	r26, r22
    260a:	b7 1f       	adc	r27, r23
    260c:	8e 87       	std	Y+14, r24	; 0x0e
    260e:	9f 87       	std	Y+15, r25	; 0x0f
    2610:	a8 8b       	std	Y+16, r26	; 0x10
    2612:	b9 8b       	std	Y+17, r27	; 0x11
    2614:	4e c0       	rjmp	.+156    	; 0x26b2 <dir_sdi+0x140>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    2616:	82 81       	ldd	r24, Z+2	; 0x02
    2618:	90 e0       	ldi	r25, 0x00	; 0
    261a:	7c 01       	movw	r14, r24
    261c:	ee 0c       	add	r14, r14
    261e:	ff 1c       	adc	r15, r15
    2620:	ee 0c       	add	r14, r14
    2622:	ff 1c       	adc	r15, r15
    2624:	ee 0c       	add	r14, r14
    2626:	ff 1c       	adc	r15, r15
    2628:	ee 0c       	add	r14, r14
    262a:	ff 1c       	adc	r15, r15
		while (idx >= ic) {	/* Follow cluster chain */
    262c:	0e 15       	cp	r16, r14
    262e:	1f 05       	cpc	r17, r15
    2630:	28 f1       	brcs	.+74     	; 0x267c <dir_sdi+0x10a>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    2632:	88 81       	ld	r24, Y
    2634:	99 81       	ldd	r25, Y+1	; 0x01
    2636:	0e 94 82 11 	call	0x2304	; 0x2304 <get_fat>
    263a:	ab 01       	movw	r20, r22
    263c:	bc 01       	movw	r22, r24
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    263e:	4f 3f       	cpi	r20, 0xFF	; 255
    2640:	8f ef       	ldi	r24, 0xFF	; 255
    2642:	58 07       	cpc	r21, r24
    2644:	8f ef       	ldi	r24, 0xFF	; 255
    2646:	68 07       	cpc	r22, r24
    2648:	8f ef       	ldi	r24, 0xFF	; 255
    264a:	78 07       	cpc	r23, r24
    264c:	09 f4       	brne	.+2      	; 0x2650 <dir_sdi+0xde>
    264e:	4a c0       	rjmp	.+148    	; 0x26e4 <dir_sdi+0x172>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    2650:	42 30       	cpi	r20, 0x02	; 2
    2652:	51 05       	cpc	r21, r1
    2654:	61 05       	cpc	r22, r1
    2656:	71 05       	cpc	r23, r1
    2658:	08 f4       	brcc	.+2      	; 0x265c <dir_sdi+0xea>
    265a:	46 c0       	rjmp	.+140    	; 0x26e8 <dir_sdi+0x176>
    265c:	e8 81       	ld	r30, Y
    265e:	f9 81       	ldd	r31, Y+1	; 0x01
    2660:	82 8d       	ldd	r24, Z+26	; 0x1a
    2662:	93 8d       	ldd	r25, Z+27	; 0x1b
    2664:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2666:	b5 8d       	ldd	r27, Z+29	; 0x1d
    2668:	48 17       	cp	r20, r24
    266a:	59 07       	cpc	r21, r25
    266c:	6a 07       	cpc	r22, r26
    266e:	7b 07       	cpc	r23, r27
    2670:	e8 f5       	brcc	.+122    	; 0x26ec <dir_sdi+0x17a>
				return FR_INT_ERR;
			idx -= ic;
    2672:	0e 19       	sub	r16, r14
    2674:	1f 09       	sbc	r17, r15
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
    2676:	0e 15       	cp	r16, r14
    2678:	1f 05       	cpc	r17, r15
    267a:	d8 f6       	brcc	.-74     	; 0x2632 <dir_sdi+0xc0>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
    267c:	4a 87       	std	Y+10, r20	; 0x0a
    267e:	5b 87       	std	Y+11, r21	; 0x0b
    2680:	6c 87       	std	Y+12, r22	; 0x0c
    2682:	7d 87       	std	Y+13, r23	; 0x0d
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    2684:	88 81       	ld	r24, Y
    2686:	99 81       	ldd	r25, Y+1	; 0x01
    2688:	0e 94 4c 11 	call	0x2298	; 0x2298 <clust2sect>
    268c:	ab 01       	movw	r20, r22
    268e:	bc 01       	movw	r22, r24
    2690:	c8 01       	movw	r24, r16
    2692:	92 95       	swap	r25
    2694:	82 95       	swap	r24
    2696:	8f 70       	andi	r24, 0x0F	; 15
    2698:	89 27       	eor	r24, r25
    269a:	9f 70       	andi	r25, 0x0F	; 15
    269c:	89 27       	eor	r24, r25
    269e:	a0 e0       	ldi	r26, 0x00	; 0
    26a0:	b0 e0       	ldi	r27, 0x00	; 0
    26a2:	84 0f       	add	r24, r20
    26a4:	95 1f       	adc	r25, r21
    26a6:	a6 1f       	adc	r26, r22
    26a8:	b7 1f       	adc	r27, r23
    26aa:	8e 87       	std	Y+14, r24	; 0x0e
    26ac:	9f 87       	std	Y+15, r25	; 0x0f
    26ae:	a8 8b       	std	Y+16, r26	; 0x10
    26b0:	b9 8b       	std	Y+17, r27	; 0x11
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    26b2:	88 81       	ld	r24, Y
    26b4:	99 81       	ldd	r25, Y+1	; 0x01
    26b6:	c2 96       	adiw	r24, 0x32	; 50
    26b8:	0f 70       	andi	r16, 0x0F	; 15
    26ba:	10 70       	andi	r17, 0x00	; 0
    26bc:	00 0f       	add	r16, r16
    26be:	11 1f       	adc	r17, r17
    26c0:	02 95       	swap	r16
    26c2:	12 95       	swap	r17
    26c4:	10 7f       	andi	r17, 0xF0	; 240
    26c6:	10 27       	eor	r17, r16
    26c8:	00 7f       	andi	r16, 0xF0	; 240
    26ca:	10 27       	eor	r17, r16
    26cc:	80 0f       	add	r24, r16
    26ce:	91 1f       	adc	r25, r17
    26d0:	9b 8b       	std	Y+19, r25	; 0x13
    26d2:	8a 8b       	std	Y+18, r24	; 0x12

	return FR_OK;	/* Seek succeeded */
    26d4:	80 e0       	ldi	r24, 0x00	; 0
    26d6:	0b c0       	rjmp	.+22     	; 0x26ee <dir_sdi+0x17c>


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
    26d8:	82 e0       	ldi	r24, 0x02	; 2
    26da:	09 c0       	rjmp	.+18     	; 0x26ee <dir_sdi+0x17c>
    26dc:	82 e0       	ldi	r24, 0x02	; 2
    26de:	07 c0       	rjmp	.+14     	; 0x26ee <dir_sdi+0x17c>
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
    26e0:	82 e0       	ldi	r24, 0x02	; 2
    26e2:	05 c0       	rjmp	.+10     	; 0x26ee <dir_sdi+0x17c>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    26e4:	81 e0       	ldi	r24, 0x01	; 1
    26e6:	03 c0       	rjmp	.+6      	; 0x26ee <dir_sdi+0x17c>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
    26e8:	82 e0       	ldi	r24, 0x02	; 2
    26ea:	01 c0       	rjmp	.+2      	; 0x26ee <dir_sdi+0x17c>
    26ec:	82 e0       	ldi	r24, 0x02	; 2
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
    26ee:	df 91       	pop	r29
    26f0:	cf 91       	pop	r28
    26f2:	1f 91       	pop	r17
    26f4:	0f 91       	pop	r16
    26f6:	ff 90       	pop	r15
    26f8:	ef 90       	pop	r14
    26fa:	08 95       	ret

000026fc <dir_remove>:
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
	DIR *dj				/* Directory object pointing the entry to be removed */
)
{
    26fc:	cf 93       	push	r28
    26fe:	df 93       	push	r29
    2700:	ec 01       	movw	r28, r24
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
	}

#else			/* Non LFN configuration */
	res = dir_sdi(dj, dj->index);
    2702:	6c 81       	ldd	r22, Y+4	; 0x04
    2704:	7d 81       	ldd	r23, Y+5	; 0x05
    2706:	0e 94 b9 12 	call	0x2572	; 0x2572 <dir_sdi>
	if (res == FR_OK) {
    270a:	88 23       	and	r24, r24
    270c:	91 f4       	brne	.+36     	; 0x2732 <dir_remove+0x36>
		res = move_window(dj->fs, dj->sect);
    270e:	4e 85       	ldd	r20, Y+14	; 0x0e
    2710:	5f 85       	ldd	r21, Y+15	; 0x0f
    2712:	68 89       	ldd	r22, Y+16	; 0x10
    2714:	79 89       	ldd	r23, Y+17	; 0x11
    2716:	88 81       	ld	r24, Y
    2718:	99 81       	ldd	r25, Y+1	; 0x01
    271a:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
		if (res == FR_OK) {
    271e:	88 23       	and	r24, r24
    2720:	41 f4       	brne	.+16     	; 0x2732 <dir_remove+0x36>
			*dj->dir = DDE;			/* Mark the entry "deleted" */
    2722:	ea 89       	ldd	r30, Y+18	; 0x12
    2724:	fb 89       	ldd	r31, Y+19	; 0x13
    2726:	95 ee       	ldi	r25, 0xE5	; 229
    2728:	90 83       	st	Z, r25
			dj->fs->wflag = 1;
    272a:	e8 81       	ld	r30, Y
    272c:	f9 81       	ldd	r31, Y+1	; 0x01
    272e:	91 e0       	ldi	r25, 0x01	; 1
    2730:	94 83       	std	Z+4, r25	; 0x04
		}
	}
#endif

	return res;
}
    2732:	df 91       	pop	r29
    2734:	cf 91       	pop	r28
    2736:	08 95       	ret

00002738 <put_fat>:
FRESULT put_fat (
	FATFS *fs,	/* File system object */
	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
	DWORD val	/* New value to mark the cluster */
)
{
    2738:	4f 92       	push	r4
    273a:	5f 92       	push	r5
    273c:	6f 92       	push	r6
    273e:	7f 92       	push	r7
    2740:	8f 92       	push	r8
    2742:	9f 92       	push	r9
    2744:	af 92       	push	r10
    2746:	bf 92       	push	r11
    2748:	cf 92       	push	r12
    274a:	df 92       	push	r13
    274c:	ef 92       	push	r14
    274e:	ff 92       	push	r15
    2750:	0f 93       	push	r16
    2752:	1f 93       	push	r17
    2754:	cf 93       	push	r28
    2756:	df 93       	push	r29
    2758:	ec 01       	movw	r28, r24
    275a:	6a 01       	movw	r12, r20
    275c:	7b 01       	movw	r14, r22
    275e:	48 01       	movw	r8, r16
    2760:	59 01       	movw	r10, r18
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    2762:	42 30       	cpi	r20, 0x02	; 2
    2764:	51 05       	cpc	r21, r1
    2766:	61 05       	cpc	r22, r1
    2768:	71 05       	cpc	r23, r1
    276a:	08 f4       	brcc	.+2      	; 0x276e <put_fat+0x36>
    276c:	e0 c0       	rjmp	.+448    	; 0x292e <put_fat+0x1f6>
    276e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2770:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2772:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2774:	bd 8d       	ldd	r27, Y+29	; 0x1d
    2776:	48 17       	cp	r20, r24
    2778:	59 07       	cpc	r21, r25
    277a:	6a 07       	cpc	r22, r26
    277c:	7b 07       	cpc	r23, r27
    277e:	08 f0       	brcs	.+2      	; 0x2782 <put_fat+0x4a>
    2780:	d8 c0       	rjmp	.+432    	; 0x2932 <put_fat+0x1fa>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
    2782:	88 81       	ld	r24, Y
    2784:	82 30       	cpi	r24, 0x02	; 2
    2786:	09 f4       	brne	.+2      	; 0x278a <put_fat+0x52>
    2788:	80 c0       	rjmp	.+256    	; 0x288a <put_fat+0x152>
    278a:	83 30       	cpi	r24, 0x03	; 3
    278c:	09 f4       	brne	.+2      	; 0x2790 <put_fat+0x58>
    278e:	98 c0       	rjmp	.+304    	; 0x28c0 <put_fat+0x188>
    2790:	81 30       	cpi	r24, 0x01	; 1
    2792:	09 f0       	breq	.+2      	; 0x2796 <put_fat+0x5e>
    2794:	c8 c0       	rjmp	.+400    	; 0x2926 <put_fat+0x1ee>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
    2796:	db 01       	movw	r26, r22
    2798:	ca 01       	movw	r24, r20
    279a:	b6 95       	lsr	r27
    279c:	a7 95       	ror	r26
    279e:	97 95       	ror	r25
    27a0:	87 95       	ror	r24
    27a2:	2c 01       	movw	r4, r24
    27a4:	3d 01       	movw	r6, r26
    27a6:	44 0e       	add	r4, r20
    27a8:	55 1e       	adc	r5, r21
    27aa:	66 1e       	adc	r6, r22
    27ac:	77 1e       	adc	r7, r23
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    27ae:	b3 01       	movw	r22, r6
    27b0:	a2 01       	movw	r20, r4
    27b2:	03 2e       	mov	r0, r19
    27b4:	39 e0       	ldi	r19, 0x09	; 9
    27b6:	76 95       	lsr	r23
    27b8:	67 95       	ror	r22
    27ba:	57 95       	ror	r21
    27bc:	47 95       	ror	r20
    27be:	3a 95       	dec	r19
    27c0:	d1 f7       	brne	.-12     	; 0x27b6 <put_fat+0x7e>
    27c2:	30 2d       	mov	r19, r0
    27c4:	8a a1       	lds	r24, 0x4a
    27c6:	9b a1       	lds	r25, 0x4b
    27c8:	ac a1       	lds	r26, 0x4c
    27ca:	bd a1       	lds	r27, 0x4d
    27cc:	48 0f       	add	r20, r24
    27ce:	59 1f       	adc	r21, r25
    27d0:	6a 1f       	adc	r22, r26
    27d2:	7b 1f       	adc	r23, r27
    27d4:	ce 01       	movw	r24, r28
    27d6:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
			if (res != FR_OK) break;
    27da:	88 23       	and	r24, r24
    27dc:	09 f0       	breq	.+2      	; 0x27e0 <put_fat+0xa8>
    27de:	a4 c0       	rjmp	.+328    	; 0x2928 <put_fat+0x1f0>
			p = &fs->win[bc % SS(fs)];
    27e0:	c2 01       	movw	r24, r4
    27e2:	91 70       	andi	r25, 0x01	; 1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    27e4:	31 e0       	ldi	r19, 0x01	; 1
    27e6:	c3 22       	and	r12, r19
    27e8:	dd 24       	eor	r13, r13
    27ea:	c1 14       	cp	r12, r1
    27ec:	d1 04       	cpc	r13, r1
    27ee:	51 f0       	breq	.+20     	; 0x2804 <put_fat+0xcc>
    27f0:	fe 01       	movw	r30, r28
    27f2:	e8 0f       	add	r30, r24
    27f4:	f9 1f       	adc	r31, r25
    27f6:	22 a9       	sts	0x42, r18
    27f8:	2f 70       	andi	r18, 0x0F	; 15
    27fa:	38 2d       	mov	r19, r8
    27fc:	32 95       	swap	r19
    27fe:	30 7f       	andi	r19, 0xF0	; 240
    2800:	23 2b       	or	r18, r19
    2802:	01 c0       	rjmp	.+2      	; 0x2806 <put_fat+0xce>
    2804:	28 2d       	mov	r18, r8
    2806:	fe 01       	movw	r30, r28
    2808:	e8 0f       	add	r30, r24
    280a:	f9 1f       	adc	r31, r25
    280c:	22 ab       	sts	0x52, r18
			bc++;
    280e:	08 94       	sec
    2810:	41 1c       	adc	r4, r1
    2812:	51 1c       	adc	r5, r1
    2814:	61 1c       	adc	r6, r1
    2816:	71 1c       	adc	r7, r1
			fs->wflag = 1;
    2818:	81 e0       	ldi	r24, 0x01	; 1
    281a:	8c 83       	std	Y+4, r24	; 0x04
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    281c:	b3 01       	movw	r22, r6
    281e:	a2 01       	movw	r20, r4
    2820:	03 2e       	mov	r0, r19
    2822:	39 e0       	ldi	r19, 0x09	; 9
    2824:	76 95       	lsr	r23
    2826:	67 95       	ror	r22
    2828:	57 95       	ror	r21
    282a:	47 95       	ror	r20
    282c:	3a 95       	dec	r19
    282e:	d1 f7       	brne	.-12     	; 0x2824 <put_fat+0xec>
    2830:	30 2d       	mov	r19, r0
    2832:	8a a1       	lds	r24, 0x4a
    2834:	9b a1       	lds	r25, 0x4b
    2836:	ac a1       	lds	r26, 0x4c
    2838:	bd a1       	lds	r27, 0x4d
    283a:	48 0f       	add	r20, r24
    283c:	59 1f       	adc	r21, r25
    283e:	6a 1f       	adc	r22, r26
    2840:	7b 1f       	adc	r23, r27
    2842:	ce 01       	movw	r24, r28
    2844:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
			if (res != FR_OK) break;
    2848:	88 23       	and	r24, r24
    284a:	09 f0       	breq	.+2      	; 0x284e <put_fat+0x116>
    284c:	6d c0       	rjmp	.+218    	; 0x2928 <put_fat+0x1f0>
			p = &fs->win[bc % SS(fs)];
    284e:	ef ef       	ldi	r30, 0xFF	; 255
    2850:	f1 e0       	ldi	r31, 0x01	; 1
    2852:	4e 22       	and	r4, r30
    2854:	5f 22       	and	r5, r31
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    2856:	c1 14       	cp	r12, r1
    2858:	d1 04       	cpc	r13, r1
    285a:	49 f0       	breq	.+18     	; 0x286e <put_fat+0x136>
    285c:	68 94       	set
    285e:	13 f8       	bld	r1, 3
    2860:	b6 94       	lsr	r11
    2862:	a7 94       	ror	r10
    2864:	97 94       	ror	r9
    2866:	87 94       	ror	r8
    2868:	16 94       	lsr	r1
    286a:	d1 f7       	brne	.-12     	; 0x2860 <put_fat+0x128>
    286c:	09 c0       	rjmp	.+18     	; 0x2880 <put_fat+0x148>
    286e:	fe 01       	movw	r30, r28
    2870:	e4 0d       	add	r30, r4
    2872:	f5 1d       	adc	r31, r5
    2874:	22 a9       	sts	0x42, r18
    2876:	20 7f       	andi	r18, 0xF0	; 240
    2878:	99 2d       	mov	r25, r9
    287a:	9f 70       	andi	r25, 0x0F	; 15
    287c:	82 2e       	mov	r8, r18
    287e:	89 2a       	or	r8, r25
    2880:	4c 0e       	add	r4, r28
    2882:	5d 1e       	adc	r5, r29
    2884:	f2 01       	movw	r30, r4
    2886:	82 aa       	sts	0x92, r24
			break;
    2888:	4f c0       	rjmp	.+158    	; 0x2928 <put_fat+0x1f0>

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    288a:	45 2f       	mov	r20, r21
    288c:	56 2f       	mov	r21, r22
    288e:	67 2f       	mov	r22, r23
    2890:	77 27       	eor	r23, r23
    2892:	8a a1       	lds	r24, 0x4a
    2894:	9b a1       	lds	r25, 0x4b
    2896:	ac a1       	lds	r26, 0x4c
    2898:	bd a1       	lds	r27, 0x4d
    289a:	48 0f       	add	r20, r24
    289c:	59 1f       	adc	r21, r25
    289e:	6a 1f       	adc	r22, r26
    28a0:	7b 1f       	adc	r23, r27
    28a2:	ce 01       	movw	r24, r28
    28a4:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
			if (res != FR_OK) break;
    28a8:	88 23       	and	r24, r24
    28aa:	09 f0       	breq	.+2      	; 0x28ae <put_fat+0x176>
    28ac:	3d c0       	rjmp	.+122    	; 0x2928 <put_fat+0x1f0>
			p = &fs->win[clst * 2 % SS(fs)];
    28ae:	f6 01       	movw	r30, r12
    28b0:	ee 0f       	add	r30, r30
    28b2:	ff 1f       	adc	r31, r31
    28b4:	f1 70       	andi	r31, 0x01	; 1
			ST_WORD(p, (WORD)val);
    28b6:	ec 0f       	add	r30, r28
    28b8:	fd 1f       	adc	r31, r29
    28ba:	82 aa       	sts	0x92, r24
    28bc:	93 aa       	sts	0x93, r25
			break;
    28be:	34 c0       	rjmp	.+104    	; 0x2928 <put_fat+0x1f0>

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    28c0:	68 94       	set
    28c2:	16 f8       	bld	r1, 6
    28c4:	76 95       	lsr	r23
    28c6:	67 95       	ror	r22
    28c8:	57 95       	ror	r21
    28ca:	47 95       	ror	r20
    28cc:	16 94       	lsr	r1
    28ce:	d1 f7       	brne	.-12     	; 0x28c4 <put_fat+0x18c>
    28d0:	8a a1       	lds	r24, 0x4a
    28d2:	9b a1       	lds	r25, 0x4b
    28d4:	ac a1       	lds	r26, 0x4c
    28d6:	bd a1       	lds	r27, 0x4d
    28d8:	48 0f       	add	r20, r24
    28da:	59 1f       	adc	r21, r25
    28dc:	6a 1f       	adc	r22, r26
    28de:	7b 1f       	adc	r23, r27
    28e0:	ce 01       	movw	r24, r28
    28e2:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
			if (res != FR_OK) break;
    28e6:	88 23       	and	r24, r24
    28e8:	f9 f4       	brne	.+62     	; 0x2928 <put_fat+0x1f0>
			p = &fs->win[clst * 4 % SS(fs)];
    28ea:	96 01       	movw	r18, r12
    28ec:	22 0f       	add	r18, r18
    28ee:	33 1f       	adc	r19, r19
    28f0:	22 0f       	add	r18, r18
    28f2:	33 1f       	adc	r19, r19
    28f4:	31 70       	andi	r19, 0x01	; 1
			val |= LD_DWORD(p) & 0xF0000000;
    28f6:	fe 01       	movw	r30, r28
    28f8:	e2 0f       	add	r30, r18
    28fa:	f3 1f       	adc	r31, r19
    28fc:	45 a9       	sts	0x45, r20
    28fe:	50 e0       	ldi	r21, 0x00	; 0
    2900:	60 e0       	ldi	r22, 0x00	; 0
    2902:	70 e0       	ldi	r23, 0x00	; 0
    2904:	74 2f       	mov	r23, r20
    2906:	66 27       	eor	r22, r22
    2908:	55 27       	eor	r21, r21
    290a:	44 27       	eor	r20, r20
    290c:	40 70       	andi	r20, 0x00	; 0
    290e:	50 70       	andi	r21, 0x00	; 0
    2910:	60 70       	andi	r22, 0x00	; 0
    2912:	70 7f       	andi	r23, 0xF0	; 240
    2914:	48 29       	or	r20, r8
    2916:	59 29       	or	r21, r9
    2918:	6a 29       	or	r22, r10
    291a:	7b 29       	or	r23, r11
			ST_DWORD(p, val);
    291c:	42 ab       	sts	0x52, r20
    291e:	53 ab       	sts	0x53, r21
    2920:	64 ab       	sts	0x54, r22
    2922:	75 ab       	sts	0x55, r23
			break;
    2924:	01 c0       	rjmp	.+2      	; 0x2928 <put_fat+0x1f0>

		default :
			res = FR_INT_ERR;
    2926:	82 e0       	ldi	r24, 0x02	; 2
		}
		fs->wflag = 1;
    2928:	91 e0       	ldi	r25, 0x01	; 1
    292a:	9c 83       	std	Y+4, r25	; 0x04
    292c:	03 c0       	rjmp	.+6      	; 0x2934 <put_fat+0x1fc>
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
    292e:	82 e0       	ldi	r24, 0x02	; 2
    2930:	01 c0       	rjmp	.+2      	; 0x2934 <put_fat+0x1fc>
    2932:	82 e0       	ldi	r24, 0x02	; 2
		}
		fs->wflag = 1;
	}

	return res;
}
    2934:	df 91       	pop	r29
    2936:	cf 91       	pop	r28
    2938:	1f 91       	pop	r17
    293a:	0f 91       	pop	r16
    293c:	ff 90       	pop	r15
    293e:	ef 90       	pop	r14
    2940:	df 90       	pop	r13
    2942:	cf 90       	pop	r12
    2944:	bf 90       	pop	r11
    2946:	af 90       	pop	r10
    2948:	9f 90       	pop	r9
    294a:	8f 90       	pop	r8
    294c:	7f 90       	pop	r7
    294e:	6f 90       	pop	r6
    2950:	5f 90       	pop	r5
    2952:	4f 90       	pop	r4
    2954:	08 95       	ret

00002956 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
    2956:	2f 92       	push	r2
    2958:	3f 92       	push	r3
    295a:	4f 92       	push	r4
    295c:	5f 92       	push	r5
    295e:	6f 92       	push	r6
    2960:	7f 92       	push	r7
    2962:	8f 92       	push	r8
    2964:	9f 92       	push	r9
    2966:	af 92       	push	r10
    2968:	bf 92       	push	r11
    296a:	cf 92       	push	r12
    296c:	df 92       	push	r13
    296e:	ef 92       	push	r14
    2970:	ff 92       	push	r15
    2972:	0f 93       	push	r16
    2974:	1f 93       	push	r17
    2976:	cf 93       	push	r28
    2978:	df 93       	push	r29
    297a:	00 d0       	rcall	.+0      	; 0x297c <create_chain+0x26>
    297c:	00 d0       	rcall	.+0      	; 0x297e <create_chain+0x28>
    297e:	cd b7       	in	r28, 0x3d	; 61
    2980:	de b7       	in	r29, 0x3e	; 62
    2982:	1c 01       	movw	r2, r24
    2984:	49 83       	std	Y+1, r20	; 0x01
    2986:	5a 83       	std	Y+2, r21	; 0x02
    2988:	6b 83       	std	Y+3, r22	; 0x03
    298a:	7c 83       	std	Y+4, r23	; 0x04
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
    298c:	41 15       	cp	r20, r1
    298e:	51 05       	cpc	r21, r1
    2990:	61 05       	cpc	r22, r1
    2992:	71 05       	cpc	r23, r1
    2994:	c1 f4       	brne	.+48     	; 0x29c6 <create_chain+0x70>
		scl = fs->last_clust;			/* Get suggested start point */
    2996:	dc 01       	movw	r26, r24
    2998:	1a 96       	adiw	r26, 0x0a	; 10
    299a:	8d 90       	ld	r8, X+
    299c:	9d 90       	ld	r9, X+
    299e:	ad 90       	ld	r10, X+
    29a0:	bc 90       	ld	r11, X
    29a2:	1d 97       	sbiw	r26, 0x0d	; 13
		if (!scl || scl >= fs->n_fatent) scl = 1;
    29a4:	81 14       	cp	r8, r1
    29a6:	91 04       	cpc	r9, r1
    29a8:	a1 04       	cpc	r10, r1
    29aa:	b1 04       	cpc	r11, r1
    29ac:	51 f1       	breq	.+84     	; 0x2a02 <create_chain+0xac>
    29ae:	5a 96       	adiw	r26, 0x1a	; 26
    29b0:	8d 91       	ld	r24, X+
    29b2:	9d 91       	ld	r25, X+
    29b4:	0d 90       	ld	r0, X+
    29b6:	bc 91       	ld	r27, X
    29b8:	a0 2d       	mov	r26, r0
    29ba:	88 16       	cp	r8, r24
    29bc:	99 06       	cpc	r9, r25
    29be:	aa 06       	cpc	r10, r26
    29c0:	bb 06       	cpc	r11, r27
    29c2:	20 f5       	brcc	.+72     	; 0x2a0c <create_chain+0xb6>
    29c4:	27 c0       	rjmp	.+78     	; 0x2a14 <create_chain+0xbe>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
    29c6:	49 81       	ldd	r20, Y+1	; 0x01
    29c8:	5a 81       	ldd	r21, Y+2	; 0x02
    29ca:	6b 81       	ldd	r22, Y+3	; 0x03
    29cc:	7c 81       	ldd	r23, Y+4	; 0x04
    29ce:	0e 94 82 11 	call	0x2304	; 0x2304 <get_fat>
    29d2:	8b 01       	movw	r16, r22
    29d4:	9c 01       	movw	r18, r24
		if (cs < 2) return 1;			/* It is an invalid cluster */
    29d6:	62 30       	cpi	r22, 0x02	; 2
    29d8:	71 05       	cpc	r23, r1
    29da:	81 05       	cpc	r24, r1
    29dc:	91 05       	cpc	r25, r1
    29de:	08 f4       	brcc	.+2      	; 0x29e2 <create_chain+0x8c>
    29e0:	ad c0       	rjmp	.+346    	; 0x2b3c <create_chain+0x1e6>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    29e2:	f1 01       	movw	r30, r2
    29e4:	82 8d       	ldd	r24, Z+26	; 0x1a
    29e6:	93 8d       	ldd	r25, Z+27	; 0x1b
    29e8:	a4 8d       	ldd	r26, Z+28	; 0x1c
    29ea:	b5 8d       	ldd	r27, Z+29	; 0x1d
    29ec:	08 17       	cp	r16, r24
    29ee:	19 07       	cpc	r17, r25
    29f0:	2a 07       	cpc	r18, r26
    29f2:	3b 07       	cpc	r19, r27
    29f4:	08 f4       	brcc	.+2      	; 0x29f8 <create_chain+0xa2>
    29f6:	b6 c0       	rjmp	.+364    	; 0x2b64 <create_chain+0x20e>
		scl = clst;
    29f8:	89 80       	ldd	r8, Y+1	; 0x01
    29fa:	9a 80       	ldd	r9, Y+2	; 0x02
    29fc:	ab 80       	ldd	r10, Y+3	; 0x03
    29fe:	bc 80       	ldd	r11, Y+4	; 0x04
    2a00:	09 c0       	rjmp	.+18     	; 0x2a14 <create_chain+0xbe>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
    2a02:	88 24       	eor	r8, r8
    2a04:	99 24       	eor	r9, r9
    2a06:	54 01       	movw	r10, r8
    2a08:	83 94       	inc	r8
    2a0a:	04 c0       	rjmp	.+8      	; 0x2a14 <create_chain+0xbe>
    2a0c:	88 24       	eor	r8, r8
    2a0e:	99 24       	eor	r9, r9
    2a10:	54 01       	movw	r10, r8
    2a12:	83 94       	inc	r8
		if (cs < 2) return 1;			/* It is an invalid cluster */
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
    2a14:	75 01       	movw	r14, r10
    2a16:	64 01       	movw	r12, r8
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
    2a18:	44 24       	eor	r4, r4
    2a1a:	55 24       	eor	r5, r5
    2a1c:	32 01       	movw	r6, r4
    2a1e:	68 94       	set
    2a20:	41 f8       	bld	r4, 1
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
    2a22:	08 94       	sec
    2a24:	c1 1c       	adc	r12, r1
    2a26:	d1 1c       	adc	r13, r1
    2a28:	e1 1c       	adc	r14, r1
    2a2a:	f1 1c       	adc	r15, r1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
    2a2c:	f1 01       	movw	r30, r2
    2a2e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a30:	93 8d       	ldd	r25, Z+27	; 0x1b
    2a32:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2a34:	b5 8d       	ldd	r27, Z+29	; 0x1d
    2a36:	c8 16       	cp	r12, r24
    2a38:	d9 06       	cpc	r13, r25
    2a3a:	ea 06       	cpc	r14, r26
    2a3c:	fb 06       	cpc	r15, r27
    2a3e:	48 f0       	brcs	.+18     	; 0x2a52 <create_chain+0xfc>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
    2a40:	f2 e0       	ldi	r31, 0x02	; 2
    2a42:	8f 16       	cp	r8, r31
    2a44:	91 04       	cpc	r9, r1
    2a46:	a1 04       	cpc	r10, r1
    2a48:	b1 04       	cpc	r11, r1
    2a4a:	08 f4       	brcc	.+2      	; 0x2a4e <create_chain+0xf8>
    2a4c:	7c c0       	rjmp	.+248    	; 0x2b46 <create_chain+0x1f0>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
    2a4e:	73 01       	movw	r14, r6
    2a50:	62 01       	movw	r12, r4
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
    2a52:	c1 01       	movw	r24, r2
    2a54:	b7 01       	movw	r22, r14
    2a56:	a6 01       	movw	r20, r12
    2a58:	0e 94 82 11 	call	0x2304	; 0x2304 <get_fat>
    2a5c:	8b 01       	movw	r16, r22
    2a5e:	9c 01       	movw	r18, r24
		if (cs == 0) break;				/* Found a free cluster */
    2a60:	61 15       	cp	r22, r1
    2a62:	71 05       	cpc	r23, r1
    2a64:	81 05       	cpc	r24, r1
    2a66:	91 05       	cpc	r25, r1
    2a68:	a9 f0       	breq	.+42     	; 0x2a94 <create_chain+0x13e>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    2a6a:	0f 3f       	cpi	r16, 0xFF	; 255
    2a6c:	8f ef       	ldi	r24, 0xFF	; 255
    2a6e:	18 07       	cpc	r17, r24
    2a70:	8f ef       	ldi	r24, 0xFF	; 255
    2a72:	28 07       	cpc	r18, r24
    2a74:	8f ef       	ldi	r24, 0xFF	; 255
    2a76:	38 07       	cpc	r19, r24
    2a78:	09 f4       	brne	.+2      	; 0x2a7c <create_chain+0x126>
    2a7a:	74 c0       	rjmp	.+232    	; 0x2b64 <create_chain+0x20e>
    2a7c:	01 30       	cpi	r16, 0x01	; 1
    2a7e:	11 05       	cpc	r17, r1
    2a80:	21 05       	cpc	r18, r1
    2a82:	31 05       	cpc	r19, r1
    2a84:	09 f4       	brne	.+2      	; 0x2a88 <create_chain+0x132>
    2a86:	6e c0       	rjmp	.+220    	; 0x2b64 <create_chain+0x20e>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
    2a88:	c8 14       	cp	r12, r8
    2a8a:	d9 04       	cpc	r13, r9
    2a8c:	ea 04       	cpc	r14, r10
    2a8e:	fb 04       	cpc	r15, r11
    2a90:	41 f6       	brne	.-112    	; 0x2a22 <create_chain+0xcc>
    2a92:	5d c0       	rjmp	.+186    	; 0x2b4e <create_chain+0x1f8>
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
    2a94:	8c 2c       	mov	r8, r12
    2a96:	4d 2c       	mov	r4, r13
    2a98:	be 2c       	mov	r11, r14
    2a9a:	af 2c       	mov	r10, r15
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    2a9c:	c1 01       	movw	r24, r2
    2a9e:	4c 2d       	mov	r20, r12
    2aa0:	5d 2d       	mov	r21, r13
    2aa2:	6e 2d       	mov	r22, r14
    2aa4:	7f 2d       	mov	r23, r15
    2aa6:	0f ef       	ldi	r16, 0xFF	; 255
    2aa8:	1f ef       	ldi	r17, 0xFF	; 255
    2aaa:	2f ef       	ldi	r18, 0xFF	; 255
    2aac:	3f e0       	ldi	r19, 0x0F	; 15
    2aae:	0e 94 9c 13 	call	0x2738	; 0x2738 <put_fat>
	if (res == FR_OK && clst != 0) {
    2ab2:	88 23       	and	r24, r24
    2ab4:	e9 f5       	brne	.+122    	; 0x2b30 <create_chain+0x1da>
    2ab6:	89 81       	ldd	r24, Y+1	; 0x01
    2ab8:	9a 81       	ldd	r25, Y+2	; 0x02
    2aba:	ab 81       	ldd	r26, Y+3	; 0x03
    2abc:	bc 81       	ldd	r27, Y+4	; 0x04
    2abe:	00 97       	sbiw	r24, 0x00	; 0
    2ac0:	a1 05       	cpc	r26, r1
    2ac2:	b1 05       	cpc	r27, r1
    2ac4:	69 f0       	breq	.+26     	; 0x2ae0 <create_chain+0x18a>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    2ac6:	c1 01       	movw	r24, r2
    2ac8:	49 81       	ldd	r20, Y+1	; 0x01
    2aca:	5a 81       	ldd	r21, Y+2	; 0x02
    2acc:	6b 81       	ldd	r22, Y+3	; 0x03
    2ace:	7c 81       	ldd	r23, Y+4	; 0x04
    2ad0:	0c 2d       	mov	r16, r12
    2ad2:	1d 2d       	mov	r17, r13
    2ad4:	2e 2d       	mov	r18, r14
    2ad6:	3f 2d       	mov	r19, r15
    2ad8:	0e 94 9c 13 	call	0x2738	; 0x2738 <put_fat>
	}
	if (res == FR_OK) {
    2adc:	88 23       	and	r24, r24
    2ade:	41 f5       	brne	.+80     	; 0x2b30 <create_chain+0x1da>
		fs->last_clust = ncl;			/* Update FSINFO */
    2ae0:	d1 01       	movw	r26, r2
    2ae2:	1a 96       	adiw	r26, 0x0a	; 10
    2ae4:	8c 92       	st	X, r8
    2ae6:	1a 97       	sbiw	r26, 0x0a	; 10
    2ae8:	1b 96       	adiw	r26, 0x0b	; 11
    2aea:	4c 92       	st	X, r4
    2aec:	1b 97       	sbiw	r26, 0x0b	; 11
    2aee:	1c 96       	adiw	r26, 0x0c	; 12
    2af0:	bc 92       	st	X, r11
    2af2:	1c 97       	sbiw	r26, 0x0c	; 12
    2af4:	1d 96       	adiw	r26, 0x0d	; 13
    2af6:	ac 92       	st	X, r10
    2af8:	1d 97       	sbiw	r26, 0x0d	; 13
		if (fs->free_clust != 0xFFFFFFFF) {
    2afa:	1e 96       	adiw	r26, 0x0e	; 14
    2afc:	8d 91       	ld	r24, X+
    2afe:	9d 91       	ld	r25, X+
    2b00:	0d 90       	ld	r0, X+
    2b02:	bc 91       	ld	r27, X
    2b04:	a0 2d       	mov	r26, r0
    2b06:	8f 3f       	cpi	r24, 0xFF	; 255
    2b08:	ef ef       	ldi	r30, 0xFF	; 255
    2b0a:	9e 07       	cpc	r25, r30
    2b0c:	ef ef       	ldi	r30, 0xFF	; 255
    2b0e:	ae 07       	cpc	r26, r30
    2b10:	ef ef       	ldi	r30, 0xFF	; 255
    2b12:	be 07       	cpc	r27, r30
    2b14:	01 f1       	breq	.+64     	; 0x2b56 <create_chain+0x200>
			fs->free_clust--;
    2b16:	01 97       	sbiw	r24, 0x01	; 1
    2b18:	a1 09       	sbc	r26, r1
    2b1a:	b1 09       	sbc	r27, r1
    2b1c:	f1 01       	movw	r30, r2
    2b1e:	86 87       	std	Z+14, r24	; 0x0e
    2b20:	97 87       	std	Z+15, r25	; 0x0f
    2b22:	a0 8b       	std	Z+16, r26	; 0x10
    2b24:	b1 8b       	std	Z+17, r27	; 0x11
			fs->fsi_flag = 1;
    2b26:	81 e0       	ldi	r24, 0x01	; 1
    2b28:	85 83       	std	Z+5, r24	; 0x05
    2b2a:	97 01       	movw	r18, r14
    2b2c:	86 01       	movw	r16, r12
    2b2e:	1a c0       	rjmp	.+52     	; 0x2b64 <create_chain+0x20e>
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    2b30:	81 30       	cpi	r24, 0x01	; 1
    2b32:	a1 f4       	brne	.+40     	; 0x2b5c <create_chain+0x206>
    2b34:	0f ef       	ldi	r16, 0xFF	; 255
    2b36:	1f ef       	ldi	r17, 0xFF	; 255
    2b38:	98 01       	movw	r18, r16
    2b3a:	14 c0       	rjmp	.+40     	; 0x2b64 <create_chain+0x20e>
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* It is an invalid cluster */
    2b3c:	01 e0       	ldi	r16, 0x01	; 1
    2b3e:	10 e0       	ldi	r17, 0x00	; 0
    2b40:	20 e0       	ldi	r18, 0x00	; 0
    2b42:	30 e0       	ldi	r19, 0x00	; 0
    2b44:	0f c0       	rjmp	.+30     	; 0x2b64 <create_chain+0x20e>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
    2b46:	00 e0       	ldi	r16, 0x00	; 0
    2b48:	10 e0       	ldi	r17, 0x00	; 0
    2b4a:	98 01       	movw	r18, r16
    2b4c:	0b c0       	rjmp	.+22     	; 0x2b64 <create_chain+0x20e>
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
    2b4e:	00 e0       	ldi	r16, 0x00	; 0
    2b50:	10 e0       	ldi	r17, 0x00	; 0
    2b52:	98 01       	movw	r18, r16
    2b54:	07 c0       	rjmp	.+14     	; 0x2b64 <create_chain+0x20e>
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
    2b56:	97 01       	movw	r18, r14
    2b58:	86 01       	movw	r16, r12
    2b5a:	04 c0       	rjmp	.+8      	; 0x2b64 <create_chain+0x20e>
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    2b5c:	01 e0       	ldi	r16, 0x01	; 1
    2b5e:	10 e0       	ldi	r17, 0x00	; 0
    2b60:	20 e0       	ldi	r18, 0x00	; 0
    2b62:	30 e0       	ldi	r19, 0x00	; 0
	}

	return ncl;		/* Return new cluster number or error code */
}
    2b64:	60 2f       	mov	r22, r16
    2b66:	71 2f       	mov	r23, r17
    2b68:	82 2f       	mov	r24, r18
    2b6a:	93 2f       	mov	r25, r19
    2b6c:	0f 90       	pop	r0
    2b6e:	0f 90       	pop	r0
    2b70:	0f 90       	pop	r0
    2b72:	0f 90       	pop	r0
    2b74:	df 91       	pop	r29
    2b76:	cf 91       	pop	r28
    2b78:	1f 91       	pop	r17
    2b7a:	0f 91       	pop	r16
    2b7c:	ff 90       	pop	r15
    2b7e:	ef 90       	pop	r14
    2b80:	df 90       	pop	r13
    2b82:	cf 90       	pop	r12
    2b84:	bf 90       	pop	r11
    2b86:	af 90       	pop	r10
    2b88:	9f 90       	pop	r9
    2b8a:	8f 90       	pop	r8
    2b8c:	7f 90       	pop	r7
    2b8e:	6f 90       	pop	r6
    2b90:	5f 90       	pop	r5
    2b92:	4f 90       	pop	r4
    2b94:	3f 90       	pop	r3
    2b96:	2f 90       	pop	r2
    2b98:	08 95       	ret

00002b9a <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
    2b9a:	8f 92       	push	r8
    2b9c:	9f 92       	push	r9
    2b9e:	af 92       	push	r10
    2ba0:	bf 92       	push	r11
    2ba2:	cf 92       	push	r12
    2ba4:	df 92       	push	r13
    2ba6:	ef 92       	push	r14
    2ba8:	ff 92       	push	r15
    2baa:	0f 93       	push	r16
    2bac:	1f 93       	push	r17
    2bae:	cf 93       	push	r28
    2bb0:	df 93       	push	r29
    2bb2:	8c 01       	movw	r16, r24
    2bb4:	eb 01       	movw	r28, r22
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
    2bb6:	dc 01       	movw	r26, r24
    2bb8:	14 96       	adiw	r26, 0x04	; 4
    2bba:	ed 90       	ld	r14, X+
    2bbc:	fc 90       	ld	r15, X
    2bbe:	15 97       	sbiw	r26, 0x05	; 5
    2bc0:	08 94       	sec
    2bc2:	e1 1c       	adc	r14, r1
    2bc4:	f1 1c       	adc	r15, r1
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    2bc6:	e1 14       	cp	r14, r1
    2bc8:	f1 04       	cpc	r15, r1
    2bca:	09 f4       	brne	.+2      	; 0x2bce <dir_next+0x34>
    2bcc:	0b c1       	rjmp	.+534    	; 0x2de4 <dir_next+0x24a>
    2bce:	1e 96       	adiw	r26, 0x0e	; 14
    2bd0:	8d 91       	ld	r24, X+
    2bd2:	9d 91       	ld	r25, X+
    2bd4:	0d 90       	ld	r0, X+
    2bd6:	bc 91       	ld	r27, X
    2bd8:	a0 2d       	mov	r26, r0
    2bda:	00 97       	sbiw	r24, 0x00	; 0
    2bdc:	a1 05       	cpc	r26, r1
    2bde:	b1 05       	cpc	r27, r1
    2be0:	09 f4       	brne	.+2      	; 0x2be4 <dir_next+0x4a>
    2be2:	02 c1       	rjmp	.+516    	; 0x2de8 <dir_next+0x24e>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    2be4:	0f 2e       	mov	r0, r31
    2be6:	ff e0       	ldi	r31, 0x0F	; 15
    2be8:	cf 2e       	mov	r12, r31
    2bea:	dd 24       	eor	r13, r13
    2bec:	f0 2d       	mov	r31, r0
    2bee:	ce 20       	and	r12, r14
    2bf0:	df 20       	and	r13, r15
    2bf2:	c1 14       	cp	r12, r1
    2bf4:	d1 04       	cpc	r13, r1
    2bf6:	09 f0       	breq	.+2      	; 0x2bfa <dir_next+0x60>
    2bf8:	da c0       	rjmp	.+436    	; 0x2dae <dir_next+0x214>
		dj->sect++;					/* Next sector */
    2bfa:	01 96       	adiw	r24, 0x01	; 1
    2bfc:	a1 1d       	adc	r26, r1
    2bfe:	b1 1d       	adc	r27, r1
    2c00:	f8 01       	movw	r30, r16
    2c02:	86 87       	std	Z+14, r24	; 0x0e
    2c04:	97 87       	std	Z+15, r25	; 0x0f
    2c06:	a0 8b       	std	Z+16, r26	; 0x10
    2c08:	b1 8b       	std	Z+17, r27	; 0x11

		if (dj->clust == 0) {	/* Static table */
    2c0a:	42 85       	ldd	r20, Z+10	; 0x0a
    2c0c:	53 85       	ldd	r21, Z+11	; 0x0b
    2c0e:	64 85       	ldd	r22, Z+12	; 0x0c
    2c10:	75 85       	ldd	r23, Z+13	; 0x0d
    2c12:	41 15       	cp	r20, r1
    2c14:	51 05       	cpc	r21, r1
    2c16:	61 05       	cpc	r22, r1
    2c18:	71 05       	cpc	r23, r1
    2c1a:	51 f4       	brne	.+20     	; 0x2c30 <dir_next+0x96>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    2c1c:	01 90       	ld	r0, Z+
    2c1e:	f0 81       	ld	r31, Z
    2c20:	e0 2d       	mov	r30, r0
    2c22:	80 85       	ldd	r24, Z+8	; 0x08
    2c24:	91 85       	ldd	r25, Z+9	; 0x09
    2c26:	e8 16       	cp	r14, r24
    2c28:	f9 06       	cpc	r15, r25
    2c2a:	08 f0       	brcs	.+2      	; 0x2c2e <dir_next+0x94>
    2c2c:	df c0       	rjmp	.+446    	; 0x2dec <dir_next+0x252>
    2c2e:	bf c0       	rjmp	.+382    	; 0x2dae <dir_next+0x214>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    2c30:	01 90       	ld	r0, Z+
    2c32:	f0 81       	ld	r31, Z
    2c34:	e0 2d       	mov	r30, r0
    2c36:	82 81       	ldd	r24, Z+2	; 0x02
    2c38:	90 e0       	ldi	r25, 0x00	; 0
    2c3a:	01 97       	sbiw	r24, 0x01	; 1
    2c3c:	97 01       	movw	r18, r14
    2c3e:	32 95       	swap	r19
    2c40:	22 95       	swap	r18
    2c42:	2f 70       	andi	r18, 0x0F	; 15
    2c44:	23 27       	eor	r18, r19
    2c46:	3f 70       	andi	r19, 0x0F	; 15
    2c48:	23 27       	eor	r18, r19
    2c4a:	82 23       	and	r24, r18
    2c4c:	93 23       	and	r25, r19
    2c4e:	00 97       	sbiw	r24, 0x00	; 0
    2c50:	09 f0       	breq	.+2      	; 0x2c54 <dir_next+0xba>
    2c52:	ad c0       	rjmp	.+346    	; 0x2dae <dir_next+0x214>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    2c54:	cf 01       	movw	r24, r30
    2c56:	0e 94 82 11 	call	0x2304	; 0x2304 <get_fat>
    2c5a:	4b 01       	movw	r8, r22
    2c5c:	5c 01       	movw	r10, r24
				if (clst <= 1) return FR_INT_ERR;
    2c5e:	62 30       	cpi	r22, 0x02	; 2
    2c60:	71 05       	cpc	r23, r1
    2c62:	81 05       	cpc	r24, r1
    2c64:	91 05       	cpc	r25, r1
    2c66:	08 f4       	brcc	.+2      	; 0x2c6a <dir_next+0xd0>
    2c68:	c3 c0       	rjmp	.+390    	; 0x2df0 <dir_next+0x256>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2c6a:	6f 3f       	cpi	r22, 0xFF	; 255
    2c6c:	ef ef       	ldi	r30, 0xFF	; 255
    2c6e:	7e 07       	cpc	r23, r30
    2c70:	ef ef       	ldi	r30, 0xFF	; 255
    2c72:	8e 07       	cpc	r24, r30
    2c74:	ef ef       	ldi	r30, 0xFF	; 255
    2c76:	9e 07       	cpc	r25, r30
    2c78:	09 f4       	brne	.+2      	; 0x2c7c <dir_next+0xe2>
    2c7a:	bc c0       	rjmp	.+376    	; 0x2df4 <dir_next+0x25a>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    2c7c:	d8 01       	movw	r26, r16
    2c7e:	ed 91       	ld	r30, X+
    2c80:	fc 91       	ld	r31, X
    2c82:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c84:	93 8d       	ldd	r25, Z+27	; 0x1b
    2c86:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2c88:	b5 8d       	ldd	r27, Z+29	; 0x1d
    2c8a:	88 16       	cp	r8, r24
    2c8c:	99 06       	cpc	r9, r25
    2c8e:	aa 06       	cpc	r10, r26
    2c90:	bb 06       	cpc	r11, r27
    2c92:	08 f4       	brcc	.+2      	; 0x2c96 <dir_next+0xfc>
    2c94:	7a c0       	rjmp	.+244    	; 0x2d8a <dir_next+0x1f0>
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    2c96:	20 97       	sbiw	r28, 0x00	; 0
    2c98:	09 f4       	brne	.+2      	; 0x2c9c <dir_next+0x102>
    2c9a:	ae c0       	rjmp	.+348    	; 0x2df8 <dir_next+0x25e>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
    2c9c:	d8 01       	movw	r26, r16
    2c9e:	1a 96       	adiw	r26, 0x0a	; 10
    2ca0:	4d 91       	ld	r20, X+
    2ca2:	5d 91       	ld	r21, X+
    2ca4:	6d 91       	ld	r22, X+
    2ca6:	7c 91       	ld	r23, X
    2ca8:	1d 97       	sbiw	r26, 0x0d	; 13
    2caa:	cf 01       	movw	r24, r30
    2cac:	0e 94 ab 14 	call	0x2956	; 0x2956 <create_chain>
    2cb0:	4b 01       	movw	r8, r22
    2cb2:	5c 01       	movw	r10, r24
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    2cb4:	61 15       	cp	r22, r1
    2cb6:	71 05       	cpc	r23, r1
    2cb8:	81 05       	cpc	r24, r1
    2cba:	91 05       	cpc	r25, r1
    2cbc:	09 f4       	brne	.+2      	; 0x2cc0 <dir_next+0x126>
    2cbe:	9e c0       	rjmp	.+316    	; 0x2dfc <dir_next+0x262>
					if (clst == 1) return FR_INT_ERR;
    2cc0:	61 30       	cpi	r22, 0x01	; 1
    2cc2:	71 05       	cpc	r23, r1
    2cc4:	81 05       	cpc	r24, r1
    2cc6:	91 05       	cpc	r25, r1
    2cc8:	09 f4       	brne	.+2      	; 0x2ccc <dir_next+0x132>
    2cca:	9a c0       	rjmp	.+308    	; 0x2e00 <dir_next+0x266>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2ccc:	6f 3f       	cpi	r22, 0xFF	; 255
    2cce:	ef ef       	ldi	r30, 0xFF	; 255
    2cd0:	7e 07       	cpc	r23, r30
    2cd2:	ef ef       	ldi	r30, 0xFF	; 255
    2cd4:	8e 07       	cpc	r24, r30
    2cd6:	ef ef       	ldi	r30, 0xFF	; 255
    2cd8:	9e 07       	cpc	r25, r30
    2cda:	09 f4       	brne	.+2      	; 0x2cde <dir_next+0x144>
    2cdc:	93 c0       	rjmp	.+294    	; 0x2e04 <dir_next+0x26a>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    2cde:	d8 01       	movw	r26, r16
    2ce0:	8d 91       	ld	r24, X+
    2ce2:	9c 91       	ld	r25, X
    2ce4:	40 e0       	ldi	r20, 0x00	; 0
    2ce6:	50 e0       	ldi	r21, 0x00	; 0
    2ce8:	ba 01       	movw	r22, r20
    2cea:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
    2cee:	88 23       	and	r24, r24
    2cf0:	09 f0       	breq	.+2      	; 0x2cf4 <dir_next+0x15a>
    2cf2:	8a c0       	rjmp	.+276    	; 0x2e08 <dir_next+0x26e>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
    2cf4:	f8 01       	movw	r30, r16
    2cf6:	80 81       	ld	r24, Z
    2cf8:	91 81       	ldd	r25, Z+1	; 0x01
    2cfa:	c2 96       	adiw	r24, 0x32	; 50
    2cfc:	60 e0       	ldi	r22, 0x00	; 0
    2cfe:	70 e0       	ldi	r23, 0x00	; 0
    2d00:	20 e0       	ldi	r18, 0x00	; 0
    2d02:	32 e0       	ldi	r19, 0x02	; 2
    2d04:	40 e0       	ldi	r20, 0x00	; 0
    2d06:	50 e0       	ldi	r21, 0x00	; 0
    2d08:	0e 94 57 0a 	call	0x14ae	; 0x14ae <mem_set>
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    2d0c:	d8 01       	movw	r26, r16
    2d0e:	cd 91       	ld	r28, X+
    2d10:	dc 91       	ld	r29, X
    2d12:	ce 01       	movw	r24, r28
    2d14:	b5 01       	movw	r22, r10
    2d16:	a4 01       	movw	r20, r8
    2d18:	0e 94 4c 11 	call	0x2298	; 0x2298 <clust2sect>
    2d1c:	dc 01       	movw	r26, r24
    2d1e:	cb 01       	movw	r24, r22
    2d20:	8e a7       	lds	r24, 0x7e
    2d22:	9f a7       	lds	r25, 0x7f
    2d24:	a8 ab       	sts	0x58, r26
    2d26:	b9 ab       	sts	0x59, r27
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2d28:	c0 e0       	ldi	r28, 0x00	; 0
						dj->fs->wflag = 1;
    2d2a:	d1 e0       	ldi	r29, 0x01	; 1
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2d2c:	1b c0       	rjmp	.+54     	; 0x2d64 <dir_next+0x1ca>
						dj->fs->wflag = 1;
    2d2e:	d4 83       	std	Z+4, r29	; 0x04
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    2d30:	f8 01       	movw	r30, r16
    2d32:	80 81       	ld	r24, Z
    2d34:	91 81       	ldd	r25, Z+1	; 0x01
    2d36:	40 e0       	ldi	r20, 0x00	; 0
    2d38:	50 e0       	ldi	r21, 0x00	; 0
    2d3a:	ba 01       	movw	r22, r20
    2d3c:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
    2d40:	88 23       	and	r24, r24
    2d42:	09 f0       	breq	.+2      	; 0x2d46 <dir_next+0x1ac>
    2d44:	63 c0       	rjmp	.+198    	; 0x2e0c <dir_next+0x272>
						dj->fs->winsect++;
    2d46:	d8 01       	movw	r26, r16
    2d48:	ed 91       	ld	r30, X+
    2d4a:	fc 91       	ld	r31, X
    2d4c:	86 a5       	lds	r24, 0x66
    2d4e:	97 a5       	lds	r25, 0x67
    2d50:	a0 a9       	sts	0x40, r26
    2d52:	b1 a9       	sts	0x41, r27
    2d54:	01 96       	adiw	r24, 0x01	; 1
    2d56:	a1 1d       	adc	r26, r1
    2d58:	b1 1d       	adc	r27, r1
    2d5a:	86 a7       	lds	r24, 0x76
    2d5c:	97 a7       	lds	r25, 0x77
    2d5e:	a0 ab       	sts	0x50, r26
    2d60:	b1 ab       	sts	0x51, r27
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2d62:	cf 5f       	subi	r28, 0xFF	; 255
    2d64:	d8 01       	movw	r26, r16
    2d66:	ed 91       	ld	r30, X+
    2d68:	fc 91       	ld	r31, X
    2d6a:	11 97       	sbiw	r26, 0x01	; 1
    2d6c:	82 81       	ldd	r24, Z+2	; 0x02
    2d6e:	c8 17       	cp	r28, r24
    2d70:	f0 f2       	brcs	.-68     	; 0x2d2e <dir_next+0x194>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
    2d72:	86 a5       	lds	r24, 0x66
    2d74:	97 a5       	lds	r25, 0x67
    2d76:	a0 a9       	sts	0x40, r26
    2d78:	b1 a9       	sts	0x41, r27
    2d7a:	8c 1b       	sub	r24, r28
    2d7c:	91 09       	sbc	r25, r1
    2d7e:	a1 09       	sbc	r26, r1
    2d80:	b1 09       	sbc	r27, r1
    2d82:	86 a7       	lds	r24, 0x76
    2d84:	97 a7       	lds	r25, 0x77
    2d86:	a0 ab       	sts	0x50, r26
    2d88:	b1 ab       	sts	0x51, r27
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
    2d8a:	f8 01       	movw	r30, r16
    2d8c:	82 86       	std	Z+10, r8	; 0x0a
    2d8e:	93 86       	std	Z+11, r9	; 0x0b
    2d90:	a4 86       	std	Z+12, r10	; 0x0c
    2d92:	b5 86       	std	Z+13, r11	; 0x0d
				dj->sect = clust2sect(dj->fs, clst);
    2d94:	80 81       	ld	r24, Z
    2d96:	91 81       	ldd	r25, Z+1	; 0x01
    2d98:	b5 01       	movw	r22, r10
    2d9a:	a4 01       	movw	r20, r8
    2d9c:	0e 94 4c 11 	call	0x2298	; 0x2298 <clust2sect>
    2da0:	dc 01       	movw	r26, r24
    2da2:	cb 01       	movw	r24, r22
    2da4:	f8 01       	movw	r30, r16
    2da6:	86 87       	std	Z+14, r24	; 0x0e
    2da8:	97 87       	std	Z+15, r25	; 0x0f
    2daa:	a0 8b       	std	Z+16, r26	; 0x10
    2dac:	b1 8b       	std	Z+17, r27	; 0x11
			}
		}
	}

	dj->index = i;
    2dae:	d8 01       	movw	r26, r16
    2db0:	15 96       	adiw	r26, 0x05	; 5
    2db2:	fc 92       	st	X, r15
    2db4:	ee 92       	st	-X, r14
    2db6:	14 97       	sbiw	r26, 0x04	; 4
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    2db8:	8d 91       	ld	r24, X+
    2dba:	9c 91       	ld	r25, X
    2dbc:	11 97       	sbiw	r26, 0x01	; 1
    2dbe:	c2 96       	adiw	r24, 0x32	; 50
    2dc0:	cc 0c       	add	r12, r12
    2dc2:	dd 1c       	adc	r13, r13
    2dc4:	cc 0c       	add	r12, r12
    2dc6:	dd 1c       	adc	r13, r13
    2dc8:	cc 0c       	add	r12, r12
    2dca:	dd 1c       	adc	r13, r13
    2dcc:	cc 0c       	add	r12, r12
    2dce:	dd 1c       	adc	r13, r13
    2dd0:	cc 0c       	add	r12, r12
    2dd2:	dd 1c       	adc	r13, r13
    2dd4:	8c 0d       	add	r24, r12
    2dd6:	9d 1d       	adc	r25, r13
    2dd8:	53 96       	adiw	r26, 0x13	; 19
    2dda:	9c 93       	st	X, r25
    2ddc:	8e 93       	st	-X, r24
    2dde:	52 97       	sbiw	r26, 0x12	; 18

	return FR_OK;
    2de0:	80 e0       	ldi	r24, 0x00	; 0
    2de2:	15 c0       	rjmp	.+42     	; 0x2e0e <dir_next+0x274>


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
    2de4:	84 e0       	ldi	r24, 0x04	; 4
    2de6:	13 c0       	rjmp	.+38     	; 0x2e0e <dir_next+0x274>
    2de8:	84 e0       	ldi	r24, 0x04	; 4
    2dea:	11 c0       	rjmp	.+34     	; 0x2e0e <dir_next+0x274>
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
    2dec:	84 e0       	ldi	r24, 0x04	; 4
    2dee:	0f c0       	rjmp	.+30     	; 0x2e0e <dir_next+0x274>
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
    2df0:	82 e0       	ldi	r24, 0x02	; 2
    2df2:	0d c0       	rjmp	.+26     	; 0x2e0e <dir_next+0x274>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2df4:	81 e0       	ldi	r24, 0x01	; 1
    2df6:	0b c0       	rjmp	.+22     	; 0x2e0e <dir_next+0x274>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    2df8:	84 e0       	ldi	r24, 0x04	; 4
    2dfa:	09 c0       	rjmp	.+18     	; 0x2e0e <dir_next+0x274>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    2dfc:	87 e0       	ldi	r24, 0x07	; 7
    2dfe:	07 c0       	rjmp	.+14     	; 0x2e0e <dir_next+0x274>
					if (clst == 1) return FR_INT_ERR;
    2e00:	82 e0       	ldi	r24, 0x02	; 2
    2e02:	05 c0       	rjmp	.+10     	; 0x2e0e <dir_next+0x274>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2e04:	81 e0       	ldi	r24, 0x01	; 1
    2e06:	03 c0       	rjmp	.+6      	; 0x2e0e <dir_next+0x274>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    2e08:	81 e0       	ldi	r24, 0x01	; 1
    2e0a:	01 c0       	rjmp	.+2      	; 0x2e0e <dir_next+0x274>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    2e0c:	81 e0       	ldi	r24, 0x01	; 1

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
}
    2e0e:	df 91       	pop	r29
    2e10:	cf 91       	pop	r28
    2e12:	1f 91       	pop	r17
    2e14:	0f 91       	pop	r16
    2e16:	ff 90       	pop	r15
    2e18:	ef 90       	pop	r14
    2e1a:	df 90       	pop	r13
    2e1c:	cf 90       	pop	r12
    2e1e:	bf 90       	pop	r11
    2e20:	af 90       	pop	r10
    2e22:	9f 90       	pop	r9
    2e24:	8f 90       	pop	r8
    2e26:	08 95       	ret

00002e28 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
    2e28:	2f 92       	push	r2
    2e2a:	3f 92       	push	r3
    2e2c:	4f 92       	push	r4
    2e2e:	5f 92       	push	r5
    2e30:	6f 92       	push	r6
    2e32:	7f 92       	push	r7
    2e34:	8f 92       	push	r8
    2e36:	9f 92       	push	r9
    2e38:	af 92       	push	r10
    2e3a:	bf 92       	push	r11
    2e3c:	cf 92       	push	r12
    2e3e:	df 92       	push	r13
    2e40:	ef 92       	push	r14
    2e42:	ff 92       	push	r15
    2e44:	0f 93       	push	r16
    2e46:	1f 93       	push	r17
    2e48:	cf 93       	push	r28
    2e4a:	df 93       	push	r29
    2e4c:	cd b7       	in	r28, 0x3d	; 61
    2e4e:	de b7       	in	r29, 0x3e	; 62
    2e50:	2b 97       	sbiw	r28, 0x0b	; 11
    2e52:	0f b6       	in	r0, 0x3f	; 63
    2e54:	f8 94       	cli
    2e56:	de bf       	out	0x3e, r29	; 62
    2e58:	0f be       	out	0x3f, r0	; 63
    2e5a:	cd bf       	out	0x3d, r28	; 61
    2e5c:	8c 01       	movw	r16, r24
    2e5e:	2b 01       	movw	r4, r22
	FRESULT res;
	BYTE *dir, ns;


#if _FS_RPATH
	if (*path == '/' || *path == '\\') { /* There is a heading separator */
    2e60:	db 01       	movw	r26, r22
    2e62:	8c 91       	ld	r24, X
    2e64:	8f 32       	cpi	r24, 0x2F	; 47
    2e66:	11 f0       	breq	.+4      	; 0x2e6c <follow_path+0x44>
    2e68:	8c 35       	cpi	r24, 0x5C	; 92
    2e6a:	49 f4       	brne	.+18     	; 0x2e7e <follow_path+0x56>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
    2e6c:	08 94       	sec
    2e6e:	41 1c       	adc	r4, r1
    2e70:	51 1c       	adc	r5, r1
    2e72:	f8 01       	movw	r30, r16
    2e74:	16 82       	std	Z+6, r1	; 0x06
    2e76:	17 82       	std	Z+7, r1	; 0x07
    2e78:	10 86       	std	Z+8, r1	; 0x08
    2e7a:	11 86       	std	Z+9, r1	; 0x09
    2e7c:	0c c0       	rjmp	.+24     	; 0x2e96 <follow_path+0x6e>
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
    2e7e:	d8 01       	movw	r26, r16
    2e80:	ed 91       	ld	r30, X+
    2e82:	fc 91       	ld	r31, X
    2e84:	86 89       	ldd	r24, Z+22	; 0x16
    2e86:	97 89       	ldd	r25, Z+23	; 0x17
    2e88:	a0 8d       	ldd	r26, Z+24	; 0x18
    2e8a:	b1 8d       	ldd	r27, Z+25	; 0x19
    2e8c:	f8 01       	movw	r30, r16
    2e8e:	86 83       	std	Z+6, r24	; 0x06
    2e90:	97 83       	std	Z+7, r25	; 0x07
    2e92:	a0 87       	std	Z+8, r26	; 0x08
    2e94:	b1 87       	std	Z+9, r27	; 0x09
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    2e96:	d2 01       	movw	r26, r4
    2e98:	8c 91       	ld	r24, X
    2e9a:	80 32       	cpi	r24, 0x20	; 32
    2e9c:	48 f4       	brcc	.+18     	; 0x2eb0 <follow_path+0x88>
		res = dir_sdi(dj, 0);
    2e9e:	c8 01       	movw	r24, r16
    2ea0:	60 e0       	ldi	r22, 0x00	; 0
    2ea2:	70 e0       	ldi	r23, 0x00	; 0
    2ea4:	0e 94 b9 12 	call	0x2572	; 0x2572 <dir_sdi>
		dj->dir = 0;
    2ea8:	f8 01       	movw	r30, r16
    2eaa:	13 8a       	std	Z+19, r1	; 0x13
    2eac:	12 8a       	std	Z+18, r1	; 0x12
    2eae:	a5 c1       	rjmp	.+842    	; 0x31fa <follow_path+0x3d2>
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    2eb0:	f8 e0       	ldi	r31, 0x08	; 8
    2eb2:	fa 83       	std	Y+2, r31	; 0x02
    2eb4:	1b 82       	std	Y+3, r1	; 0x03
    2eb6:	1c 82       	std	Y+4, r1	; 0x04
    2eb8:	1d 82       	std	Y+5, r1	; 0x05
    2eba:	2b e0       	ldi	r18, 0x0B	; 11
    2ebc:	2e 83       	std	Y+6, r18	; 0x06
    2ebe:	1f 82       	std	Y+7, r1	; 0x07
    2ec0:	18 86       	std	Y+8, r1	; 0x08
    2ec2:	19 86       	std	Y+9, r1	; 0x09
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
		res = dir_sdi(dj, 0);
		dj->dir = 0;
    2ec4:	f2 01       	movw	r30, r4
    2ec6:	9f 01       	movw	r18, r30
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    2ec8:	81 91       	ld	r24, Z+
    2eca:	8f 32       	cpi	r24, 0x2F	; 47
    2ecc:	e1 f3       	breq	.-8      	; 0x2ec6 <follow_path+0x9e>
    2ece:	8c 35       	cpi	r24, 0x5C	; 92
    2ed0:	d1 f3       	breq	.-12     	; 0x2ec6 <follow_path+0x9e>
    2ed2:	3b 87       	std	Y+11, r19	; 0x0b
    2ed4:	2a 87       	std	Y+10, r18	; 0x0a
	sfn = dj->fn;
    2ed6:	d8 01       	movw	r26, r16
    2ed8:	54 96       	adiw	r26, 0x14	; 20
    2eda:	2d 90       	ld	r2, X+
    2edc:	3c 90       	ld	r3, X
    2ede:	55 97       	sbiw	r26, 0x15	; 21
	mem_set(sfn, ' ', 11);
    2ee0:	c1 01       	movw	r24, r2
    2ee2:	60 e2       	ldi	r22, 0x20	; 32
    2ee4:	70 e0       	ldi	r23, 0x00	; 0
    2ee6:	2b e0       	ldi	r18, 0x0B	; 11
    2ee8:	30 e0       	ldi	r19, 0x00	; 0
    2eea:	40 e0       	ldi	r20, 0x00	; 0
    2eec:	50 e0       	ldi	r21, 0x00	; 0
    2eee:	0e 94 57 0a 	call	0x14ae	; 0x14ae <mem_set>
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
    2ef2:	ea 85       	ldd	r30, Y+10	; 0x0a
    2ef4:	fb 85       	ldd	r31, Y+11	; 0x0b
    2ef6:	80 81       	ld	r24, Z
    2ef8:	8e 32       	cpi	r24, 0x2E	; 46
    2efa:	89 f5       	brne	.+98     	; 0x2f5e <follow_path+0x136>
		for (;;) {
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
    2efc:	ee e2       	ldi	r30, 0x2E	; 46
    2efe:	d1 01       	movw	r26, r2
    2f00:	ec 93       	st	X, r30
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2f02:	aa 85       	ldd	r26, Y+10	; 0x0a
    2f04:	bb 85       	ldd	r27, Y+11	; 0x0b
    2f06:	11 96       	adiw	r26, 0x01	; 1
    2f08:	2c 91       	ld	r18, X
    2f0a:	11 97       	sbiw	r26, 0x01	; 1
			if (c != '.' || si >= 3) break;
    2f0c:	2e 32       	cpi	r18, 0x2E	; 46
    2f0e:	61 f4       	brne	.+24     	; 0x2f28 <follow_path+0x100>
			sfn[i++] = c;
    2f10:	f1 01       	movw	r30, r2
    2f12:	21 83       	std	Z+1, r18	; 0x01
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2f14:	12 96       	adiw	r26, 0x02	; 2
    2f16:	2c 91       	ld	r18, X
    2f18:	12 97       	sbiw	r26, 0x02	; 2
			if (c != '.' || si >= 3) break;
    2f1a:	2e 32       	cpi	r18, 0x2E	; 46
    2f1c:	71 f0       	breq	.+28     	; 0x2f3a <follow_path+0x112>
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2f1e:	83 e0       	ldi	r24, 0x03	; 3
    2f20:	90 e0       	ldi	r25, 0x00	; 0
    2f22:	a0 e0       	ldi	r26, 0x00	; 0
    2f24:	b0 e0       	ldi	r27, 0x00	; 0
    2f26:	04 c0       	rjmp	.+8      	; 0x2f30 <follow_path+0x108>
    2f28:	82 e0       	ldi	r24, 0x02	; 2
    2f2a:	90 e0       	ldi	r25, 0x00	; 0
    2f2c:	a0 e0       	ldi	r26, 0x00	; 0
    2f2e:	b0 e0       	ldi	r27, 0x00	; 0
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    2f30:	2f 32       	cpi	r18, 0x2F	; 47
    2f32:	59 f0       	breq	.+22     	; 0x2f4a <follow_path+0x122>
    2f34:	2c 35       	cpi	r18, 0x5C	; 92
    2f36:	49 f0       	breq	.+18     	; 0x2f4a <follow_path+0x122>
    2f38:	04 c0       	rjmp	.+8      	; 0x2f42 <follow_path+0x11a>
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2f3a:	83 e0       	ldi	r24, 0x03	; 3
    2f3c:	90 e0       	ldi	r25, 0x00	; 0
    2f3e:	a0 e0       	ldi	r26, 0x00	; 0
    2f40:	b0 e0       	ldi	r27, 0x00	; 0
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    2f42:	21 32       	cpi	r18, 0x21	; 33
    2f44:	08 f0       	brcs	.+2      	; 0x2f48 <follow_path+0x120>
    2f46:	48 c1       	rjmp	.+656    	; 0x31d8 <follow_path+0x3b0>
    2f48:	71 c1       	rjmp	.+738    	; 0x322c <follow_path+0x404>
		*path = &p[si];									/* Return pointer to the next segment */
    2f4a:	4a 84       	ldd	r4, Y+10	; 0x0a
    2f4c:	5b 84       	ldd	r5, Y+11	; 0x0b
    2f4e:	48 0e       	add	r4, r24
    2f50:	59 1e       	adc	r5, r25
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
    2f52:	80 e2       	ldi	r24, 0x20	; 32
    2f54:	d1 01       	movw	r26, r2
    2f56:	1b 96       	adiw	r26, 0x0b	; 11
    2f58:	8c 93       	st	X, r24
    2f5a:	1b 97       	sbiw	r26, 0x0b	; 11
    2f5c:	74 c1       	rjmp	.+744    	; 0x3246 <follow_path+0x41e>
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
    2f5e:	cc 24       	eor	r12, r12
    2f60:	dd 24       	eor	r13, r13
    2f62:	76 01       	movw	r14, r12
    2f64:	40 e0       	ldi	r20, 0x00	; 0
    2f66:	50 e0       	ldi	r21, 0x00	; 0
    2f68:	ba 01       	movw	r22, r20
    2f6a:	88 24       	eor	r8, r8
    2f6c:	99 24       	eor	r9, r9
    2f6e:	54 01       	movw	r10, r8
    2f70:	68 94       	set
    2f72:	83 f8       	bld	r8, 3
    2f74:	19 82       	std	Y+1, r1	; 0x01
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    2f76:	ea 85       	ldd	r30, Y+10	; 0x0a
    2f78:	fb 85       	ldd	r31, Y+11	; 0x0b
    2f7a:	e4 0f       	add	r30, r20
    2f7c:	f5 1f       	adc	r31, r21
    2f7e:	20 81       	ld	r18, Z
    2f80:	2a 01       	movw	r4, r20
    2f82:	3b 01       	movw	r6, r22
    2f84:	08 94       	sec
    2f86:	41 1c       	adc	r4, r1
    2f88:	51 1c       	adc	r5, r1
    2f8a:	61 1c       	adc	r6, r1
    2f8c:	71 1c       	adc	r7, r1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    2f8e:	21 32       	cpi	r18, 0x21	; 33
    2f90:	08 f4       	brcc	.+2      	; 0x2f94 <follow_path+0x16c>
    2f92:	95 c0       	rjmp	.+298    	; 0x30be <follow_path+0x296>
    2f94:	2f 32       	cpi	r18, 0x2F	; 47
    2f96:	09 f4       	brne	.+2      	; 0x2f9a <follow_path+0x172>
    2f98:	4f c1       	rjmp	.+670    	; 0x3238 <follow_path+0x410>
    2f9a:	2c 35       	cpi	r18, 0x5C	; 92
    2f9c:	09 f4       	brne	.+2      	; 0x2fa0 <follow_path+0x178>
    2f9e:	4c c1       	rjmp	.+664    	; 0x3238 <follow_path+0x410>
		if (c == '.' || i >= ni) {
    2fa0:	2e 32       	cpi	r18, 0x2E	; 46
    2fa2:	29 f0       	breq	.+10     	; 0x2fae <follow_path+0x186>
    2fa4:	c8 14       	cp	r12, r8
    2fa6:	d9 04       	cpc	r13, r9
    2fa8:	ea 04       	cpc	r14, r10
    2faa:	fb 04       	cpc	r15, r11
    2fac:	c8 f0       	brcs	.+50     	; 0x2fe0 <follow_path+0x1b8>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    2fae:	f8 e0       	ldi	r31, 0x08	; 8
    2fb0:	8f 16       	cp	r8, r31
    2fb2:	91 04       	cpc	r9, r1
    2fb4:	a1 04       	cpc	r10, r1
    2fb6:	b1 04       	cpc	r11, r1
    2fb8:	09 f0       	breq	.+2      	; 0x2fbc <follow_path+0x194>
    2fba:	10 c1       	rjmp	.+544    	; 0x31dc <follow_path+0x3b4>
    2fbc:	2e 32       	cpi	r18, 0x2E	; 46
    2fbe:	09 f0       	breq	.+2      	; 0x2fc2 <follow_path+0x19a>
    2fc0:	0f c1       	rjmp	.+542    	; 0x31e0 <follow_path+0x3b8>
			i = 8; ni = 11;
			b <<= 2; continue;
    2fc2:	29 81       	ldd	r18, Y+1	; 0x01
    2fc4:	22 0f       	add	r18, r18
    2fc6:	22 0f       	add	r18, r18
    2fc8:	29 83       	std	Y+1, r18	; 0x01
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    2fca:	b3 01       	movw	r22, r6
    2fcc:	a2 01       	movw	r20, r4
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    2fce:	ca 80       	ldd	r12, Y+2	; 0x02
    2fd0:	db 80       	ldd	r13, Y+3	; 0x03
    2fd2:	ec 80       	ldd	r14, Y+4	; 0x04
    2fd4:	fd 80       	ldd	r15, Y+5	; 0x05
    2fd6:	8e 80       	ldd	r8, Y+6	; 0x06
    2fd8:	9f 80       	ldd	r9, Y+7	; 0x07
    2fda:	a8 84       	ldd	r10, Y+8	; 0x08
    2fdc:	b9 84       	ldd	r11, Y+9	; 0x09
    2fde:	cb cf       	rjmp	.-106    	; 0x2f76 <follow_path+0x14e>
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended char? */
    2fe0:	22 23       	and	r18, r18
    2fe2:	1c f4       	brge	.+6      	; 0x2fea <follow_path+0x1c2>
			b |= 3;						/* Eliminate NT flag */
    2fe4:	89 81       	ldd	r24, Y+1	; 0x01
    2fe6:	83 60       	ori	r24, 0x03	; 3
    2fe8:	89 83       	std	Y+1, r24	; 0x01
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    2fea:	82 2f       	mov	r24, r18
    2fec:	81 58       	subi	r24, 0x81	; 129
    2fee:	8f 31       	cpi	r24, 0x1F	; 31
    2ff0:	18 f0       	brcs	.+6      	; 0x2ff8 <follow_path+0x1d0>
    2ff2:	8f 55       	subi	r24, 0x5F	; 95
    2ff4:	8d 31       	cpi	r24, 0x1D	; 29
    2ff6:	90 f5       	brcc	.+100    	; 0x305c <follow_path+0x234>
			d = (BYTE)p[si++];			/* Get 2nd byte */
    2ff8:	ea 85       	ldd	r30, Y+10	; 0x0a
    2ffa:	fb 85       	ldd	r31, Y+11	; 0x0b
    2ffc:	e4 0d       	add	r30, r4
    2ffe:	f5 1d       	adc	r31, r5
    3000:	30 81       	ld	r19, Z
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    3002:	83 2f       	mov	r24, r19
    3004:	80 54       	subi	r24, 0x40	; 64
    3006:	8f 33       	cpi	r24, 0x3F	; 63
    3008:	20 f0       	brcs	.+8      	; 0x3012 <follow_path+0x1ea>
    300a:	80 54       	subi	r24, 0x40	; 64
    300c:	8d 37       	cpi	r24, 0x7D	; 125
    300e:	08 f0       	brcs	.+2      	; 0x3012 <follow_path+0x1ea>
    3010:	e9 c0       	rjmp	.+466    	; 0x31e4 <follow_path+0x3bc>
    3012:	d5 01       	movw	r26, r10
    3014:	c4 01       	movw	r24, r8
    3016:	01 97       	sbiw	r24, 0x01	; 1
    3018:	a1 09       	sbc	r26, r1
    301a:	b1 09       	sbc	r27, r1
    301c:	c8 16       	cp	r12, r24
    301e:	d9 06       	cpc	r13, r25
    3020:	ea 06       	cpc	r14, r26
    3022:	fb 06       	cpc	r15, r27
    3024:	08 f0       	brcs	.+2      	; 0x3028 <follow_path+0x200>
    3026:	e0 c0       	rjmp	.+448    	; 0x31e8 <follow_path+0x3c0>
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
    3028:	4e 5f       	subi	r20, 0xFE	; 254
    302a:	5f 4f       	sbci	r21, 0xFF	; 255
    302c:	6f 4f       	sbci	r22, 0xFF	; 255
    302e:	7f 4f       	sbci	r23, 0xFF	; 255
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
    3030:	f1 01       	movw	r30, r2
    3032:	ec 0d       	add	r30, r12
    3034:	fd 1d       	adc	r31, r13
    3036:	20 83       	st	Z, r18
    3038:	d7 01       	movw	r26, r14
    303a:	c6 01       	movw	r24, r12
    303c:	01 96       	adiw	r24, 0x01	; 1
    303e:	a1 1d       	adc	r26, r1
    3040:	b1 1d       	adc	r27, r1
			sfn[i++] = d;
    3042:	82 0d       	add	r24, r2
    3044:	93 1d       	adc	r25, r3
    3046:	dc 01       	movw	r26, r24
    3048:	3c 93       	st	X, r19
    304a:	82 e0       	ldi	r24, 0x02	; 2
    304c:	90 e0       	ldi	r25, 0x00	; 0
    304e:	a0 e0       	ldi	r26, 0x00	; 0
    3050:	b0 e0       	ldi	r27, 0x00	; 0
    3052:	c8 0e       	add	r12, r24
    3054:	d9 1e       	adc	r13, r25
    3056:	ea 1e       	adc	r14, r26
    3058:	fb 1e       	adc	r15, r27
    305a:	8d cf       	rjmp	.-230    	; 0x2f76 <follow_path+0x14e>
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    305c:	42 2f       	mov	r20, r18
    305e:	50 e0       	ldi	r21, 0x00	; 0
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    3060:	42 32       	cpi	r20, 0x22	; 34
    3062:	51 05       	cpc	r21, r1
    3064:	09 f4       	brne	.+2      	; 0x3068 <follow_path+0x240>
    3066:	c2 c0       	rjmp	.+388    	; 0x31ec <follow_path+0x3c4>
    3068:	e0 e1       	ldi	r30, 0x10	; 16
    306a:	f4 e0       	ldi	r31, 0x04	; 4
    306c:	6a 85       	ldd	r22, Y+10	; 0x0a
    306e:	7b 85       	ldd	r23, Y+11	; 0x0b
    3070:	81 91       	ld	r24, Z+
    3072:	88 23       	and	r24, r24
    3074:	31 f0       	breq	.+12     	; 0x3082 <follow_path+0x25a>
    3076:	90 e0       	ldi	r25, 0x00	; 0
    3078:	48 17       	cp	r20, r24
    307a:	59 07       	cpc	r21, r25
    307c:	c9 f7       	brne	.-14     	; 0x3070 <follow_path+0x248>
    307e:	86 e0       	ldi	r24, 0x06	; 6
    3080:	bc c0       	rjmp	.+376    	; 0x31fa <follow_path+0x3d2>
    3082:	7b 87       	std	Y+11, r23	; 0x0b
    3084:	6a 87       	std	Y+10, r22	; 0x0a
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
    3086:	82 2f       	mov	r24, r18
    3088:	81 54       	subi	r24, 0x41	; 65
    308a:	8a 31       	cpi	r24, 0x1A	; 26
    308c:	20 f4       	brcc	.+8      	; 0x3096 <follow_path+0x26e>
				b |= 2;
    308e:	99 81       	ldd	r25, Y+1	; 0x01
    3090:	92 60       	ori	r25, 0x02	; 2
    3092:	99 83       	std	Y+1, r25	; 0x01
    3094:	08 c0       	rjmp	.+16     	; 0x30a6 <follow_path+0x27e>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
    3096:	82 2f       	mov	r24, r18
    3098:	81 56       	subi	r24, 0x61	; 97
    309a:	8a 31       	cpi	r24, 0x1A	; 26
    309c:	20 f4       	brcc	.+8      	; 0x30a6 <follow_path+0x27e>
					b |= 1; c -= 0x20;
    309e:	a9 81       	ldd	r26, Y+1	; 0x01
    30a0:	a1 60       	ori	r26, 0x01	; 1
    30a2:	a9 83       	std	Y+1, r26	; 0x01
    30a4:	20 52       	subi	r18, 0x20	; 32
				}
			}
			sfn[i++] = c;
    30a6:	f1 01       	movw	r30, r2
    30a8:	ec 0d       	add	r30, r12
    30aa:	fd 1d       	adc	r31, r13
    30ac:	20 83       	st	Z, r18
    30ae:	08 94       	sec
    30b0:	c1 1c       	adc	r12, r1
    30b2:	d1 1c       	adc	r13, r1
    30b4:	e1 1c       	adc	r14, r1
    30b6:	f1 1c       	adc	r15, r1
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    30b8:	b3 01       	movw	r22, r6
    30ba:	a2 01       	movw	r20, r4
    30bc:	5c cf       	rjmp	.-328    	; 0x2f76 <follow_path+0x14e>
    30be:	ea 85       	ldd	r30, Y+10	; 0x0a
    30c0:	fb 85       	ldd	r31, Y+11	; 0x0b
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    30c2:	4e 0e       	add	r4, r30
    30c4:	5f 1e       	adc	r5, r31
    30c6:	89 81       	ldd	r24, Y+1	; 0x01
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    30c8:	44 e0       	ldi	r20, 0x04	; 4

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    30ca:	c1 14       	cp	r12, r1
    30cc:	d1 04       	cpc	r13, r1
    30ce:	e1 04       	cpc	r14, r1
    30d0:	f1 04       	cpc	r15, r1
    30d2:	09 f4       	brne	.+2      	; 0x30d6 <follow_path+0x2ae>
    30d4:	8d c0       	rjmp	.+282    	; 0x31f0 <follow_path+0x3c8>
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    30d6:	d1 01       	movw	r26, r2
    30d8:	9c 91       	ld	r25, X
    30da:	95 3e       	cpi	r25, 0xE5	; 229
    30dc:	11 f4       	brne	.+4      	; 0x30e2 <follow_path+0x2ba>
    30de:	e5 e0       	ldi	r30, 0x05	; 5
    30e0:	ec 93       	st	X, r30

	if (ni == 8) b <<= 2;
    30e2:	f8 e0       	ldi	r31, 0x08	; 8
    30e4:	8f 16       	cp	r8, r31
    30e6:	91 04       	cpc	r9, r1
    30e8:	a1 04       	cpc	r10, r1
    30ea:	b1 04       	cpc	r11, r1
    30ec:	19 f4       	brne	.+6      	; 0x30f4 <follow_path+0x2cc>
    30ee:	88 0f       	add	r24, r24
    30f0:	88 0f       	add	r24, r24
    30f2:	89 83       	std	Y+1, r24	; 0x01
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    30f4:	29 81       	ldd	r18, Y+1	; 0x01
    30f6:	82 2f       	mov	r24, r18
    30f8:	90 e0       	ldi	r25, 0x00	; 0
    30fa:	9c 01       	movw	r18, r24
    30fc:	23 70       	andi	r18, 0x03	; 3
    30fe:	30 70       	andi	r19, 0x00	; 0
    3100:	21 30       	cpi	r18, 0x01	; 1
    3102:	31 05       	cpc	r19, r1
    3104:	09 f4       	brne	.+2      	; 0x3108 <follow_path+0x2e0>
    3106:	40 61       	ori	r20, 0x10	; 16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    3108:	8c 70       	andi	r24, 0x0C	; 12
    310a:	90 70       	andi	r25, 0x00	; 0
    310c:	84 30       	cpi	r24, 0x04	; 4
    310e:	91 05       	cpc	r25, r1
    3110:	09 f4       	brne	.+2      	; 0x3114 <follow_path+0x2ec>
    3112:	48 60       	ori	r20, 0x08	; 8

	sfn[NS] = c;		/* Store NT flag, File name is created */
    3114:	d1 01       	movw	r26, r2
    3116:	1b 96       	adiw	r26, 0x0b	; 11
    3118:	4c 93       	st	X, r20
    311a:	1b 97       	sbiw	r26, 0x0b	; 11
    311c:	94 c0       	rjmp	.+296    	; 0x3246 <follow_path+0x41e>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
    311e:	f8 01       	movw	r30, r16
    3120:	46 85       	ldd	r20, Z+14	; 0x0e
    3122:	57 85       	ldd	r21, Z+15	; 0x0f
    3124:	60 89       	ldd	r22, Z+16	; 0x10
    3126:	71 89       	ldd	r23, Z+17	; 0x11
    3128:	80 81       	ld	r24, Z
    312a:	91 81       	ldd	r25, Z+1	; 0x01
    312c:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
		if (res != FR_OK) break;
    3130:	88 23       	and	r24, r24
    3132:	31 f5       	brne	.+76     	; 0x3180 <follow_path+0x358>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    3134:	d8 01       	movw	r26, r16
    3136:	52 96       	adiw	r26, 0x12	; 18
    3138:	6d 91       	ld	r22, X+
    313a:	7c 91       	ld	r23, X
    313c:	53 97       	sbiw	r26, 0x13	; 19
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    313e:	fb 01       	movw	r30, r22
    3140:	90 81       	ld	r25, Z
    3142:	99 23       	and	r25, r25
    3144:	09 f4       	brne	.+2      	; 0x3148 <follow_path+0x320>
    3146:	90 c0       	rjmp	.+288    	; 0x3268 <follow_path+0x440>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    3148:	93 85       	ldd	r25, Z+11	; 0x0b
    314a:	93 fd       	sbrc	r25, 3
    314c:	12 c0       	rjmp	.+36     	; 0x3172 <follow_path+0x34a>
    314e:	54 96       	adiw	r26, 0x14	; 20
    3150:	4d 91       	ld	r20, X+
    3152:	5c 91       	ld	r21, X
    3154:	55 97       	sbiw	r26, 0x15	; 21
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
    3156:	9b 01       	movw	r18, r22
    3158:	25 5f       	subi	r18, 0xF5	; 245
    315a:	3f 4f       	sbci	r19, 0xFF	; 255
}

/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    315c:	da 01       	movw	r26, r20
    315e:	6b 01       	movw	r12, r22
    3160:	04 c0       	rjmp	.+8      	; 0x316a <follow_path+0x342>
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    3162:	e2 17       	cp	r30, r18
    3164:	f3 07       	cpc	r31, r19
    3166:	09 f4       	brne	.+2      	; 0x316a <follow_path+0x342>
    3168:	77 c0       	rjmp	.+238    	; 0x3258 <follow_path+0x430>
    316a:	61 91       	ld	r22, Z+
    316c:	9d 91       	ld	r25, X+
    316e:	69 17       	cp	r22, r25
    3170:	c1 f3       	breq	.-16     	; 0x3162 <follow_path+0x33a>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
    3172:	c8 01       	movw	r24, r16
    3174:	60 e0       	ldi	r22, 0x00	; 0
    3176:	70 e0       	ldi	r23, 0x00	; 0
    3178:	0e 94 cd 15 	call	0x2b9a	; 0x2b9a <dir_next>
	} while (res == FR_OK);
    317c:	88 23       	and	r24, r24
    317e:	79 f2       	breq	.-98     	; 0x311e <follow_path+0x2f6>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    3180:	d8 01       	movw	r26, r16
    3182:	54 96       	adiw	r26, 0x14	; 20
    3184:	ed 91       	ld	r30, X+
    3186:	fc 91       	ld	r31, X
    3188:	55 97       	sbiw	r26, 0x15	; 21
    318a:	93 85       	ldd	r25, Z+11	; 0x0b
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
    318c:	84 30       	cpi	r24, 0x04	; 4
    318e:	a9 f5       	brne	.+106    	; 0x31fa <follow_path+0x3d2>
				/* Object not found */
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
    3190:	95 ff       	sbrs	r25, 5
    3192:	0b c0       	rjmp	.+22     	; 0x31aa <follow_path+0x382>
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
    3194:	f8 01       	movw	r30, r16
    3196:	16 82       	std	Z+6, r1	; 0x06
    3198:	17 82       	std	Z+7, r1	; 0x07
    319a:	10 86       	std	Z+8, r1	; 0x08
    319c:	11 86       	std	Z+9, r1	; 0x09
    319e:	13 8a       	std	Z+19, r1	; 0x13
    31a0:	12 8a       	std	Z+18, r1	; 0x12
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
    31a2:	92 ff       	sbrs	r25, 2
    31a4:	8f ce       	rjmp	.-738    	; 0x2ec4 <follow_path+0x9c>
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
				/* Object not found */
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
    31a6:	80 e0       	ldi	r24, 0x00	; 0
    31a8:	28 c0       	rjmp	.+80     	; 0x31fa <follow_path+0x3d2>
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    31aa:	92 ff       	sbrs	r25, 2
    31ac:	23 c0       	rjmp	.+70     	; 0x31f4 <follow_path+0x3cc>
		dj->dir = 0;
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
    31ae:	84 e0       	ldi	r24, 0x04	; 4
    31b0:	24 c0       	rjmp	.+72     	; 0x31fa <follow_path+0x3d2>
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    31b2:	db 01       	movw	r26, r22
    31b4:	1b 96       	adiw	r26, 0x0b	; 11
    31b6:	8c 91       	ld	r24, X
    31b8:	1b 97       	sbiw	r26, 0x0b	; 11
    31ba:	84 ff       	sbrs	r24, 4
    31bc:	1d c0       	rjmp	.+58     	; 0x31f8 <follow_path+0x3d0>
				res = FR_NO_PATH; break;
			}
			dj->sclust = ld_clust(dj->fs, dir);
    31be:	f8 01       	movw	r30, r16
    31c0:	80 81       	ld	r24, Z
    31c2:	91 81       	ldd	r25, Z+1	; 0x01
    31c4:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <ld_clust>
    31c8:	dc 01       	movw	r26, r24
    31ca:	cb 01       	movw	r24, r22
    31cc:	f8 01       	movw	r30, r16
    31ce:	86 83       	std	Z+6, r24	; 0x06
    31d0:	97 83       	std	Z+7, r25	; 0x07
    31d2:	a0 87       	std	Z+8, r26	; 0x08
    31d4:	b1 87       	std	Z+9, r27	; 0x09
    31d6:	76 ce       	rjmp	.-788    	; 0x2ec4 <follow_path+0x9c>
		for (;;) {
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    31d8:	86 e0       	ldi	r24, 0x06	; 6
    31da:	0f c0       	rjmp	.+30     	; 0x31fa <follow_path+0x3d2>
#endif
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    31dc:	86 e0       	ldi	r24, 0x06	; 6
    31de:	0d c0       	rjmp	.+26     	; 0x31fa <follow_path+0x3d2>
    31e0:	86 e0       	ldi	r24, 0x06	; 6
    31e2:	0b c0       	rjmp	.+22     	; 0x31fa <follow_path+0x3d2>
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    31e4:	86 e0       	ldi	r24, 0x06	; 6
    31e6:	09 c0       	rjmp	.+18     	; 0x31fa <follow_path+0x3d2>
    31e8:	86 e0       	ldi	r24, 0x06	; 6
    31ea:	07 c0       	rjmp	.+14     	; 0x31fa <follow_path+0x3d2>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    31ec:	86 e0       	ldi	r24, 0x06	; 6
    31ee:	05 c0       	rjmp	.+10     	; 0x31fa <follow_path+0x3d2>
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    31f0:	86 e0       	ldi	r24, 0x06	; 6
    31f2:	03 c0       	rjmp	.+6      	; 0x31fa <follow_path+0x3d2>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    31f4:	85 e0       	ldi	r24, 0x05	; 5
    31f6:	01 c0       	rjmp	.+2      	; 0x31fa <follow_path+0x3d2>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
    31f8:	85 e0       	ldi	r24, 0x05	; 5
			dj->sclust = ld_clust(dj->fs, dir);
		}
	}

	return res;
}
    31fa:	2b 96       	adiw	r28, 0x0b	; 11
    31fc:	0f b6       	in	r0, 0x3f	; 63
    31fe:	f8 94       	cli
    3200:	de bf       	out	0x3e, r29	; 62
    3202:	0f be       	out	0x3f, r0	; 63
    3204:	cd bf       	out	0x3d, r28	; 61
    3206:	df 91       	pop	r29
    3208:	cf 91       	pop	r28
    320a:	1f 91       	pop	r17
    320c:	0f 91       	pop	r16
    320e:	ff 90       	pop	r15
    3210:	ef 90       	pop	r14
    3212:	df 90       	pop	r13
    3214:	cf 90       	pop	r12
    3216:	bf 90       	pop	r11
    3218:	af 90       	pop	r10
    321a:	9f 90       	pop	r9
    321c:	8f 90       	pop	r8
    321e:	7f 90       	pop	r7
    3220:	6f 90       	pop	r6
    3222:	5f 90       	pop	r5
    3224:	4f 90       	pop	r4
    3226:	3f 90       	pop	r3
    3228:	2f 90       	pop	r2
    322a:	08 95       	ret
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
		*path = &p[si];									/* Return pointer to the next segment */
    322c:	4a 84       	ldd	r4, Y+10	; 0x0a
    322e:	5b 84       	ldd	r5, Y+11	; 0x0b
    3230:	48 0e       	add	r4, r24
    3232:	59 1e       	adc	r5, r25
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
    3234:	84 e2       	ldi	r24, 0x24	; 36
    3236:	8e ce       	rjmp	.-740    	; 0x2f54 <follow_path+0x12c>
    3238:	8a 85       	ldd	r24, Y+10	; 0x0a
    323a:	9b 85       	ldd	r25, Y+11	; 0x0b
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    323c:	48 0e       	add	r4, r24
    323e:	59 1e       	adc	r5, r25
    3240:	89 81       	ldd	r24, Y+1	; 0x01
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    3242:	40 e0       	ldi	r20, 0x00	; 0
    3244:	42 cf       	rjmp	.-380    	; 0x30ca <follow_path+0x2a2>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
    3246:	c8 01       	movw	r24, r16
    3248:	60 e0       	ldi	r22, 0x00	; 0
    324a:	70 e0       	ldi	r23, 0x00	; 0
    324c:	0e 94 b9 12 	call	0x2572	; 0x2572 <dir_sdi>
	if (res != FR_OK) return res;
    3250:	88 23       	and	r24, r24
    3252:	09 f4       	brne	.+2      	; 0x3256 <follow_path+0x42e>
    3254:	64 cf       	rjmp	.-312    	; 0x311e <follow_path+0x2f6>
    3256:	94 cf       	rjmp	.-216    	; 0x3180 <follow_path+0x358>
    3258:	b6 01       	movw	r22, r12
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    325a:	da 01       	movw	r26, r20
    325c:	1b 96       	adiw	r26, 0x0b	; 11
    325e:	9c 91       	ld	r25, X
    3260:	1b 97       	sbiw	r26, 0x0b	; 11
    3262:	92 ff       	sbrs	r25, 2
    3264:	a6 cf       	rjmp	.-180    	; 0x31b2 <follow_path+0x38a>
    3266:	c9 cf       	rjmp	.-110    	; 0x31fa <follow_path+0x3d2>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    3268:	d8 01       	movw	r26, r16
    326a:	54 96       	adiw	r26, 0x14	; 20
    326c:	ed 91       	ld	r30, X+
    326e:	fc 91       	ld	r31, X
    3270:	55 97       	sbiw	r26, 0x15	; 21
    3272:	93 85       	ldd	r25, Z+11	; 0x0b
    3274:	8d cf       	rjmp	.-230    	; 0x3190 <follow_path+0x368>

00003276 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
    3276:	ef 92       	push	r14
    3278:	ff 92       	push	r15
    327a:	0f 93       	push	r16
    327c:	1f 93       	push	r17
    327e:	cf 93       	push	r28
    3280:	8c 01       	movw	r16, r24
			} while (res == FR_OK && --ne);
		}
	}

#else	/* Non LFN configuration */
	res = dir_sdi(dj, 0);
    3282:	60 e0       	ldi	r22, 0x00	; 0
    3284:	70 e0       	ldi	r23, 0x00	; 0
    3286:	0e 94 b9 12 	call	0x2572	; 0x2572 <dir_sdi>
    328a:	c8 2f       	mov	r28, r24
	if (res == FR_OK) {
    328c:	88 23       	and	r24, r24
    328e:	09 f0       	breq	.+2      	; 0x3292 <dir_register+0x1c>
    3290:	3f c0       	rjmp	.+126    	; 0x3310 <dir_register+0x9a>
		do {	/* Find a blank entry for the SFN */
			res = move_window(dj->fs, dj->sect);
    3292:	d8 01       	movw	r26, r16
    3294:	1e 96       	adiw	r26, 0x0e	; 14
    3296:	4d 91       	ld	r20, X+
    3298:	5d 91       	ld	r21, X+
    329a:	6d 91       	ld	r22, X+
    329c:	7c 91       	ld	r23, X
    329e:	51 97       	sbiw	r26, 0x11	; 17
    32a0:	8d 91       	ld	r24, X+
    32a2:	9c 91       	ld	r25, X
    32a4:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
    32a8:	c8 2f       	mov	r28, r24
			if (res != FR_OK) break;
    32aa:	88 23       	and	r24, r24
    32ac:	89 f5       	brne	.+98     	; 0x3310 <dir_register+0x9a>
			c = *dj->dir;
    32ae:	d8 01       	movw	r26, r16
    32b0:	52 96       	adiw	r26, 0x12	; 18
    32b2:	ed 91       	ld	r30, X+
    32b4:	fc 91       	ld	r31, X
    32b6:	53 97       	sbiw	r26, 0x13	; 19
    32b8:	80 81       	ld	r24, Z
			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
    32ba:	85 3e       	cpi	r24, 0xE5	; 229
    32bc:	81 f1       	breq	.+96     	; 0x331e <dir_register+0xa8>
    32be:	88 23       	and	r24, r24
    32c0:	71 f1       	breq	.+92     	; 0x331e <dir_register+0xa8>
			res = dir_next(dj, 1);			/* Next entry with table stretch */
    32c2:	c8 01       	movw	r24, r16
    32c4:	61 e0       	ldi	r22, 0x01	; 1
    32c6:	70 e0       	ldi	r23, 0x00	; 0
    32c8:	0e 94 cd 15 	call	0x2b9a	; 0x2b9a <dir_next>
    32cc:	c8 2f       	mov	r28, r24
		} while (res == FR_OK);
    32ce:	88 23       	and	r24, r24
    32d0:	01 f3       	breq	.-64     	; 0x3292 <dir_register+0x1c>
    32d2:	1e c0       	rjmp	.+60     	; 0x3310 <dir_register+0x9a>
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
    32d4:	f8 01       	movw	r30, r16
    32d6:	e2 88       	ldd	r14, Z+18	; 0x12
    32d8:	f3 88       	ldd	r15, Z+19	; 0x13
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
    32da:	c7 01       	movw	r24, r14
    32dc:	60 e0       	ldi	r22, 0x00	; 0
    32de:	70 e0       	ldi	r23, 0x00	; 0
    32e0:	20 e2       	ldi	r18, 0x20	; 32
    32e2:	30 e0       	ldi	r19, 0x00	; 0
    32e4:	40 e0       	ldi	r20, 0x00	; 0
    32e6:	50 e0       	ldi	r21, 0x00	; 0
    32e8:	0e 94 57 0a 	call	0x14ae	; 0x14ae <mem_set>
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
    32ec:	d8 01       	movw	r26, r16
    32ee:	54 96       	adiw	r26, 0x14	; 20
    32f0:	6d 91       	ld	r22, X+
    32f2:	7c 91       	ld	r23, X
    32f4:	55 97       	sbiw	r26, 0x15	; 21
    32f6:	c7 01       	movw	r24, r14
    32f8:	2b e0       	ldi	r18, 0x0B	; 11
    32fa:	30 e0       	ldi	r19, 0x00	; 0
    32fc:	40 e0       	ldi	r20, 0x00	; 0
    32fe:	50 e0       	ldi	r21, 0x00	; 0
    3300:	0e 94 42 0a 	call	0x1484	; 0x1484 <mem_cpy>
#if _USE_LFN
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dj->fs->wflag = 1;
    3304:	d8 01       	movw	r26, r16
    3306:	ed 91       	ld	r30, X+
    3308:	fc 91       	ld	r31, X
    330a:	11 97       	sbiw	r26, 0x01	; 1
    330c:	81 e0       	ldi	r24, 0x01	; 1
    330e:	84 83       	std	Z+4, r24	; 0x04
		}
	}

	return res;
}
    3310:	8c 2f       	mov	r24, r28
    3312:	cf 91       	pop	r28
    3314:	1f 91       	pop	r17
    3316:	0f 91       	pop	r16
    3318:	ff 90       	pop	r15
    331a:	ef 90       	pop	r14
    331c:	08 95       	ret
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
    331e:	f8 01       	movw	r30, r16
    3320:	46 85       	ldd	r20, Z+14	; 0x0e
    3322:	57 85       	ldd	r21, Z+15	; 0x0f
    3324:	60 89       	ldd	r22, Z+16	; 0x10
    3326:	71 89       	ldd	r23, Z+17	; 0x11
    3328:	80 81       	ld	r24, Z
    332a:	91 81       	ldd	r25, Z+1	; 0x01
    332c:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
    3330:	c8 2f       	mov	r28, r24
		if (res == FR_OK) {
    3332:	88 23       	and	r24, r24
    3334:	69 f7       	brne	.-38     	; 0x3310 <dir_register+0x9a>
    3336:	ce cf       	rjmp	.-100    	; 0x32d4 <dir_register+0x5e>

00003338 <dir_read>:
#if _FS_MINIMIZE <= 1
static
FRESULT dir_read (
	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
)
{
    3338:	cf 93       	push	r28
    333a:	df 93       	push	r29
    333c:	ec 01       	movw	r28, r24
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
    333e:	84 e0       	ldi	r24, 0x04	; 4
	while (dj->sect) {
    3340:	17 c0       	rjmp	.+46     	; 0x3370 <dir_read+0x38>
		res = move_window(dj->fs, dj->sect);
    3342:	88 81       	ld	r24, Y
    3344:	99 81       	ldd	r25, Y+1	; 0x01
    3346:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
		if (res != FR_OK) break;
    334a:	88 23       	and	r24, r24
    334c:	e1 f4       	brne	.+56     	; 0x3386 <dir_read+0x4e>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    334e:	ea 89       	ldd	r30, Y+18	; 0x12
    3350:	fb 89       	ldd	r31, Y+19	; 0x13
		c = dir[DIR_Name];
    3352:	90 81       	ld	r25, Z
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    3354:	99 23       	and	r25, r25
    3356:	f1 f0       	breq	.+60     	; 0x3394 <dir_read+0x5c>
					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    3358:	95 3e       	cpi	r25, 0xE5	; 229
    335a:	19 f0       	breq	.+6      	; 0x3362 <dir_read+0x2a>
    335c:	93 85       	ldd	r25, Z+11	; 0x0b
    335e:	93 ff       	sbrs	r25, 3
    3360:	16 c0       	rjmp	.+44     	; 0x338e <dir_read+0x56>
			break;
#endif
		res = dir_next(dj, 0);				/* Next entry */
    3362:	ce 01       	movw	r24, r28
    3364:	60 e0       	ldi	r22, 0x00	; 0
    3366:	70 e0       	ldi	r23, 0x00	; 0
    3368:	0e 94 cd 15 	call	0x2b9a	; 0x2b9a <dir_next>
		if (res != FR_OK) break;
    336c:	88 23       	and	r24, r24
    336e:	59 f4       	brne	.+22     	; 0x3386 <dir_read+0x4e>
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
    3370:	4e 85       	ldd	r20, Y+14	; 0x0e
    3372:	5f 85       	ldd	r21, Y+15	; 0x0f
    3374:	68 89       	ldd	r22, Y+16	; 0x10
    3376:	79 89       	ldd	r23, Y+17	; 0x11
    3378:	41 15       	cp	r20, r1
    337a:	51 05       	cpc	r21, r1
    337c:	61 05       	cpc	r22, r1
    337e:	71 05       	cpc	r23, r1
    3380:	01 f7       	brne	.-64     	; 0x3342 <dir_read+0xa>
#endif
		res = dir_next(dj, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
    3382:	88 23       	and	r24, r24
    3384:	21 f0       	breq	.+8      	; 0x338e <dir_read+0x56>
    3386:	1e 86       	std	Y+14, r1	; 0x0e
    3388:	1f 86       	std	Y+15, r1	; 0x0f
    338a:	18 8a       	std	Y+16, r1	; 0x10
    338c:	19 8a       	std	Y+17, r1	; 0x11

	return res;
}
    338e:	df 91       	pop	r29
    3390:	cf 91       	pop	r28
    3392:	08 95       	ret
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    3394:	84 e0       	ldi	r24, 0x04	; 4
    3396:	f7 cf       	rjmp	.-18     	; 0x3386 <dir_read+0x4e>

00003398 <remove_chain>:
static
FRESULT remove_chain (
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
    3398:	7f 92       	push	r7
    339a:	8f 92       	push	r8
    339c:	9f 92       	push	r9
    339e:	af 92       	push	r10
    33a0:	bf 92       	push	r11
    33a2:	cf 92       	push	r12
    33a4:	df 92       	push	r13
    33a6:	ef 92       	push	r14
    33a8:	ff 92       	push	r15
    33aa:	0f 93       	push	r16
    33ac:	1f 93       	push	r17
    33ae:	cf 93       	push	r28
    33b0:	df 93       	push	r29
    33b2:	ec 01       	movw	r28, r24
    33b4:	4a 01       	movw	r8, r20
    33b6:	5b 01       	movw	r10, r22
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    33b8:	42 30       	cpi	r20, 0x02	; 2
    33ba:	51 05       	cpc	r21, r1
    33bc:	61 05       	cpc	r22, r1
    33be:	71 05       	cpc	r23, r1
    33c0:	08 f4       	brcc	.+2      	; 0x33c4 <remove_chain+0x2c>
    33c2:	55 c0       	rjmp	.+170    	; 0x346e <remove_chain+0xd6>
    33c4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    33c6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    33c8:	ac 8d       	ldd	r26, Y+28	; 0x1c
    33ca:	bd 8d       	ldd	r27, Y+29	; 0x1d
    33cc:	48 17       	cp	r20, r24
    33ce:	59 07       	cpc	r21, r25
    33d0:	6a 07       	cpc	r22, r26
    33d2:	7b 07       	cpc	r23, r27
    33d4:	08 f0       	brcs	.+2      	; 0x33d8 <remove_chain+0x40>
    33d6:	4d c0       	rjmp	.+154    	; 0x3472 <remove_chain+0xda>
    33d8:	03 c0       	rjmp	.+6      	; 0x33e0 <remove_chain+0x48>
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
    33da:	46 01       	movw	r8, r12
    33dc:	57 01       	movw	r10, r14
    33de:	02 c0       	rjmp	.+4      	; 0x33e4 <remove_chain+0x4c>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
				fs->free_clust++;
				fs->fsi_flag = 1;
    33e0:	77 24       	eor	r7, r7
    33e2:	73 94       	inc	r7
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
    33e4:	ce 01       	movw	r24, r28
    33e6:	b5 01       	movw	r22, r10
    33e8:	a4 01       	movw	r20, r8
    33ea:	0e 94 82 11 	call	0x2304	; 0x2304 <get_fat>
    33ee:	6b 01       	movw	r12, r22
    33f0:	7c 01       	movw	r14, r24
			if (nxt == 0) break;				/* Empty cluster? */
    33f2:	61 15       	cp	r22, r1
    33f4:	71 05       	cpc	r23, r1
    33f6:	81 05       	cpc	r24, r1
    33f8:	91 05       	cpc	r25, r1
    33fa:	e9 f1       	breq	.+122    	; 0x3476 <remove_chain+0xde>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    33fc:	91 e0       	ldi	r25, 0x01	; 1
    33fe:	c9 16       	cp	r12, r25
    3400:	d1 04       	cpc	r13, r1
    3402:	e1 04       	cpc	r14, r1
    3404:	f1 04       	cpc	r15, r1
    3406:	c9 f1       	breq	.+114    	; 0x347a <remove_chain+0xe2>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    3408:	8f ef       	ldi	r24, 0xFF	; 255
    340a:	c8 16       	cp	r12, r24
    340c:	8f ef       	ldi	r24, 0xFF	; 255
    340e:	d8 06       	cpc	r13, r24
    3410:	8f ef       	ldi	r24, 0xFF	; 255
    3412:	e8 06       	cpc	r14, r24
    3414:	8f ef       	ldi	r24, 0xFF	; 255
    3416:	f8 06       	cpc	r15, r24
    3418:	91 f1       	breq	.+100    	; 0x347e <remove_chain+0xe6>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    341a:	ce 01       	movw	r24, r28
    341c:	b5 01       	movw	r22, r10
    341e:	a4 01       	movw	r20, r8
    3420:	00 e0       	ldi	r16, 0x00	; 0
    3422:	10 e0       	ldi	r17, 0x00	; 0
    3424:	98 01       	movw	r18, r16
    3426:	0e 94 9c 13 	call	0x2738	; 0x2738 <put_fat>
			if (res != FR_OK) break;
    342a:	88 23       	and	r24, r24
    342c:	49 f5       	brne	.+82     	; 0x3480 <remove_chain+0xe8>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    342e:	4e 85       	ldd	r20, Y+14	; 0x0e
    3430:	5f 85       	ldd	r21, Y+15	; 0x0f
    3432:	68 89       	ldd	r22, Y+16	; 0x10
    3434:	79 89       	ldd	r23, Y+17	; 0x11
    3436:	4f 3f       	cpi	r20, 0xFF	; 255
    3438:	9f ef       	ldi	r25, 0xFF	; 255
    343a:	59 07       	cpc	r21, r25
    343c:	9f ef       	ldi	r25, 0xFF	; 255
    343e:	69 07       	cpc	r22, r25
    3440:	9f ef       	ldi	r25, 0xFF	; 255
    3442:	79 07       	cpc	r23, r25
    3444:	49 f0       	breq	.+18     	; 0x3458 <remove_chain+0xc0>
				fs->free_clust++;
    3446:	4f 5f       	subi	r20, 0xFF	; 255
    3448:	5f 4f       	sbci	r21, 0xFF	; 255
    344a:	6f 4f       	sbci	r22, 0xFF	; 255
    344c:	7f 4f       	sbci	r23, 0xFF	; 255
    344e:	4e 87       	std	Y+14, r20	; 0x0e
    3450:	5f 87       	std	Y+15, r21	; 0x0f
    3452:	68 8b       	std	Y+16, r22	; 0x10
    3454:	79 8b       	std	Y+17, r23	; 0x11
				fs->fsi_flag = 1;
    3456:	7d 82       	std	Y+5, r7	; 0x05
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
    3458:	4a 8d       	ldd	r20, Y+26	; 0x1a
    345a:	5b 8d       	ldd	r21, Y+27	; 0x1b
    345c:	6c 8d       	ldd	r22, Y+28	; 0x1c
    345e:	7d 8d       	ldd	r23, Y+29	; 0x1d
    3460:	c4 16       	cp	r12, r20
    3462:	d5 06       	cpc	r13, r21
    3464:	e6 06       	cpc	r14, r22
    3466:	f7 06       	cpc	r15, r23
    3468:	08 f4       	brcc	.+2      	; 0x346c <remove_chain+0xd4>
    346a:	b7 cf       	rjmp	.-146    	; 0x33da <remove_chain+0x42>
    346c:	09 c0       	rjmp	.+18     	; 0x3480 <remove_chain+0xe8>
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
    346e:	82 e0       	ldi	r24, 0x02	; 2
    3470:	07 c0       	rjmp	.+14     	; 0x3480 <remove_chain+0xe8>
    3472:	82 e0       	ldi	r24, 0x02	; 2
    3474:	05 c0       	rjmp	.+10     	; 0x3480 <remove_chain+0xe8>

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
    3476:	80 e0       	ldi	r24, 0x00	; 0
    3478:	03 c0       	rjmp	.+6      	; 0x3480 <remove_chain+0xe8>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    347a:	82 e0       	ldi	r24, 0x02	; 2
    347c:	01 c0       	rjmp	.+2      	; 0x3480 <remove_chain+0xe8>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    347e:	81 e0       	ldi	r24, 0x01	; 1
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
    3480:	df 91       	pop	r29
    3482:	cf 91       	pop	r28
    3484:	1f 91       	pop	r17
    3486:	0f 91       	pop	r16
    3488:	ff 90       	pop	r15
    348a:	ef 90       	pop	r14
    348c:	df 90       	pop	r13
    348e:	cf 90       	pop	r12
    3490:	bf 90       	pop	r11
    3492:	af 90       	pop	r10
    3494:	9f 90       	pop	r9
    3496:	8f 90       	pop	r8
    3498:	7f 90       	pop	r7
    349a:	08 95       	ret

0000349c <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
    349c:	88 23       	and	r24, r24
    349e:	91 f4       	brne	.+36     	; 0x34c4 <f_mount+0x28>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
    34a0:	e0 91 23 04 	lds	r30, 0x0423
    34a4:	f0 91 24 04 	lds	r31, 0x0424

	if (rfs) {
    34a8:	30 97       	sbiw	r30, 0x00	; 0
    34aa:	09 f0       	breq	.+2      	; 0x34ae <f_mount+0x12>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
    34ac:	10 82       	st	Z, r1
	}

	if (fs) {
    34ae:	61 15       	cp	r22, r1
    34b0:	71 05       	cpc	r23, r1
    34b2:	11 f0       	breq	.+4      	; 0x34b8 <f_mount+0x1c>
		fs->fs_type = 0;		/* Clear new fs object */
    34b4:	fb 01       	movw	r30, r22
    34b6:	10 82       	st	Z, r1
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
    34b8:	70 93 24 04 	sts	0x0424, r23
    34bc:	60 93 23 04 	sts	0x0423, r22

	return FR_OK;
    34c0:	80 e0       	ldi	r24, 0x00	; 0
    34c2:	08 95       	ret
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
    34c4:	8b e0       	ldi	r24, 0x0B	; 11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
    34c6:	08 95       	ret

000034c8 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    34c8:	4f 92       	push	r4
    34ca:	5f 92       	push	r5
    34cc:	6f 92       	push	r6
    34ce:	7f 92       	push	r7
    34d0:	8f 92       	push	r8
    34d2:	9f 92       	push	r9
    34d4:	af 92       	push	r10
    34d6:	bf 92       	push	r11
    34d8:	cf 92       	push	r12
    34da:	df 92       	push	r13
    34dc:	ef 92       	push	r14
    34de:	ff 92       	push	r15
    34e0:	0f 93       	push	r16
    34e2:	1f 93       	push	r17
    34e4:	cf 93       	push	r28
    34e6:	df 93       	push	r29
    34e8:	cd b7       	in	r28, 0x3d	; 61
    34ea:	de b7       	in	r29, 0x3e	; 62
    34ec:	a4 97       	sbiw	r28, 0x24	; 36
    34ee:	0f b6       	in	r0, 0x3f	; 63
    34f0:	f8 94       	cli
    34f2:	de bf       	out	0x3e, r29	; 62
    34f4:	0f be       	out	0x3f, r0	; 63
    34f6:	cd bf       	out	0x3d, r28	; 61
    34f8:	7c 01       	movw	r14, r24
    34fa:	7c a3       	lds	r23, 0x5c
    34fc:	6b a3       	lds	r22, 0x5b
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    34fe:	00 97       	sbiw	r24, 0x00	; 0
    3500:	09 f4       	brne	.+2      	; 0x3504 <f_open+0x3c>
    3502:	ea c0       	rjmp	.+468    	; 0x36d8 <f_open+0x210>
	fp->fs = 0;			/* Clear file object */
    3504:	fc 01       	movw	r30, r24
    3506:	11 82       	std	Z+1, r1	; 0x01
    3508:	10 82       	st	Z, r1

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    350a:	04 2f       	mov	r16, r20
    350c:	0f 71       	andi	r16, 0x1F	; 31
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
    350e:	4e 71       	andi	r20, 0x1E	; 30
    3510:	ce 01       	movw	r24, r28
    3512:	83 96       	adiw	r24, 0x23	; 35
    3514:	be 01       	movw	r22, r28
    3516:	6f 5f       	subi	r22, 0xFF	; 255
    3518:	7f 4f       	sbci	r23, 0xFF	; 255
    351a:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <chk_mounted>
    351e:	18 2f       	mov	r17, r24
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res == FR_OK) {
    3520:	88 23       	and	r24, r24
    3522:	09 f0       	breq	.+2      	; 0x3526 <f_open+0x5e>
    3524:	da c0       	rjmp	.+436    	; 0x36da <f_open+0x212>
		INIT_BUF(dj);
    3526:	ce 01       	movw	r24, r28
    3528:	47 96       	adiw	r24, 0x17	; 23
    352a:	9e 8b       	std	Y+22, r25	; 0x16
    352c:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    352e:	6b a1       	lds	r22, 0x4b
    3530:	7c a1       	lds	r23, 0x4c
    3532:	ce 01       	movw	r24, r28
    3534:	01 96       	adiw	r24, 0x01	; 1
    3536:	0e 94 14 17 	call	0x2e28	; 0x2e28 <follow_path>
		dir = dj.dir;
    353a:	cb 88       	ldd	r12, Y+19	; 0x13
    353c:	dc 88       	ldd	r13, Y+20	; 0x14
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
    353e:	88 23       	and	r24, r24
    3540:	21 f4       	brne	.+8      	; 0x354a <f_open+0x82>
			if (!dir)	/* Current dir itself */
    3542:	c1 14       	cp	r12, r1
    3544:	d1 04       	cpc	r13, r1
    3546:	09 f4       	brne	.+2      	; 0x354a <f_open+0x82>
				res = FR_INVALID_NAME;
    3548:	86 e0       	ldi	r24, 0x06	; 6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    354a:	40 2f       	mov	r20, r16
    354c:	50 e0       	ldi	r21, 0x00	; 0
    354e:	9a 01       	movw	r18, r20
    3550:	2c 71       	andi	r18, 0x1C	; 28
    3552:	30 70       	andi	r19, 0x00	; 0
    3554:	21 15       	cp	r18, r1
    3556:	31 05       	cpc	r19, r1
    3558:	09 f4       	brne	.+2      	; 0x355c <f_open+0x94>
    355a:	5b c0       	rjmp	.+182    	; 0x3612 <f_open+0x14a>
			DWORD dw, cl;

			if (res != FR_OK) {					/* No file, create new */
    355c:	88 23       	and	r24, r24
    355e:	71 f0       	breq	.+28     	; 0x357c <f_open+0xb4>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    3560:	84 30       	cpi	r24, 0x04	; 4
    3562:	09 f0       	breq	.+2      	; 0x3566 <f_open+0x9e>
    3564:	b7 c0       	rjmp	.+366    	; 0x36d4 <f_open+0x20c>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
    3566:	ce 01       	movw	r24, r28
    3568:	01 96       	adiw	r24, 0x01	; 1
    356a:	0e 94 3b 19 	call	0x3276	; 0x3276 <dir_register>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
    356e:	cb 88       	ldd	r12, Y+19	; 0x13
    3570:	dc 88       	ldd	r13, Y+20	; 0x14
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    3572:	88 23       	and	r24, r24
    3574:	09 f0       	breq	.+2      	; 0x3578 <f_open+0xb0>
    3576:	ae c0       	rjmp	.+348    	; 0x36d4 <f_open+0x20c>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
    3578:	08 60       	ori	r16, 0x08	; 8
    357a:	07 c0       	rjmp	.+14     	; 0x358a <f_open+0xc2>
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    357c:	f6 01       	movw	r30, r12
    357e:	83 85       	ldd	r24, Z+11	; 0x0b
    3580:	81 71       	andi	r24, 0x11	; 17
    3582:	09 f0       	breq	.+2      	; 0x3586 <f_open+0xbe>
    3584:	c2 c0       	rjmp	.+388    	; 0x370a <f_open+0x242>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    3586:	02 fd       	sbrc	r16, 2
    3588:	c2 c0       	rjmp	.+388    	; 0x370e <f_open+0x246>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    358a:	03 ff       	sbrs	r16, 3
    358c:	c6 c0       	rjmp	.+396    	; 0x371a <f_open+0x252>
				dw = get_fattime();					/* Created time */
    358e:	0e 94 48 11 	call	0x2290	; 0x2290 <get_fattime>
				ST_DWORD(dir+DIR_CrtTime, dw);
    3592:	f6 01       	movw	r30, r12
    3594:	66 87       	std	Z+14, r22	; 0x0e
    3596:	77 87       	std	Z+15, r23	; 0x0f
    3598:	80 8b       	std	Z+16, r24	; 0x10
    359a:	91 8b       	std	Z+17, r25	; 0x11
				dir[DIR_Attr] = 0;					/* Reset attribute */
    359c:	13 86       	std	Z+11, r1	; 0x0b
				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
    359e:	14 8e       	std	Z+28, r1	; 0x1c
    35a0:	15 8e       	std	Z+29, r1	; 0x1d
    35a2:	16 8e       	std	Z+30, r1	; 0x1e
    35a4:	17 8e       	std	Z+31, r1	; 0x1f
				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
    35a6:	89 81       	ldd	r24, Y+1	; 0x01
    35a8:	9a 81       	ldd	r25, Y+2	; 0x02
    35aa:	b6 01       	movw	r22, r12
    35ac:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <ld_clust>
    35b0:	4b 01       	movw	r8, r22
    35b2:	5c 01       	movw	r10, r24
				st_clust(dir, 0);					/* cluster = 0 */
    35b4:	c6 01       	movw	r24, r12
    35b6:	40 e0       	ldi	r20, 0x00	; 0
    35b8:	50 e0       	ldi	r21, 0x00	; 0
    35ba:	ba 01       	movw	r22, r20
    35bc:	0e 94 8d 0a 	call	0x151a	; 0x151a <st_clust>
				dj.fs->wflag = 1;
    35c0:	e9 81       	ldd	r30, Y+1	; 0x01
    35c2:	fa 81       	ldd	r31, Y+2	; 0x02
    35c4:	81 e0       	ldi	r24, 0x01	; 1
    35c6:	84 83       	std	Z+4, r24	; 0x04
				if (cl) {							/* Remove the cluster chain if exist */
    35c8:	81 14       	cp	r8, r1
    35ca:	91 04       	cpc	r9, r1
    35cc:	a1 04       	cpc	r10, r1
    35ce:	b1 04       	cpc	r11, r1
    35d0:	09 f4       	brne	.+2      	; 0x35d4 <f_open+0x10c>
    35d2:	a3 c0       	rjmp	.+326    	; 0x371a <f_open+0x252>
					dw = dj.fs->winsect;
    35d4:	46 a4       	lds	r20, 0xa6
    35d6:	57 a4       	lds	r21, 0xa7
    35d8:	60 a8       	sts	0x00, r22
    35da:	71 a8       	sts	0x81, r23
					res = remove_chain(dj.fs, cl);
    35dc:	cf 01       	movw	r24, r30
    35de:	b5 01       	movw	r22, r10
    35e0:	a4 01       	movw	r20, r8
    35e2:	0e 94 cc 19 	call	0x3398	; 0x3398 <remove_chain>
					if (res == FR_OK) {
    35e6:	88 23       	and	r24, r24
    35e8:	09 f0       	breq	.+2      	; 0x35ec <f_open+0x124>
    35ea:	74 c0       	rjmp	.+232    	; 0x36d4 <f_open+0x20c>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    35ec:	e9 81       	ldd	r30, Y+1	; 0x01
    35ee:	fa 81       	ldd	r31, Y+2	; 0x02
    35f0:	d5 01       	movw	r26, r10
    35f2:	c4 01       	movw	r24, r8
    35f4:	01 97       	sbiw	r24, 0x01	; 1
    35f6:	a1 09       	sbc	r26, r1
    35f8:	b1 09       	sbc	r27, r1
    35fa:	82 87       	std	Z+10, r24	; 0x0a
    35fc:	93 87       	std	Z+11, r25	; 0x0b
    35fe:	a4 87       	std	Z+12, r26	; 0x0c
    3600:	b5 87       	std	Z+13, r27	; 0x0d
						res = move_window(dj.fs, dw);
    3602:	cf 01       	movw	r24, r30
    3604:	b3 01       	movw	r22, r6
    3606:	a2 01       	movw	r20, r4
    3608:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
    360c:	88 23       	and	r24, r24
    360e:	69 f0       	breq	.+26     	; 0x362a <f_open+0x162>
    3610:	61 c0       	rjmp	.+194    	; 0x36d4 <f_open+0x20c>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {						/* Follow succeeded */
    3612:	88 23       	and	r24, r24
    3614:	09 f0       	breq	.+2      	; 0x3618 <f_open+0x150>
    3616:	5e c0       	rjmp	.+188    	; 0x36d4 <f_open+0x20c>
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    3618:	f6 01       	movw	r30, r12
    361a:	83 85       	ldd	r24, Z+11	; 0x0b
    361c:	84 fd       	sbrc	r24, 4
    361e:	79 c0       	rjmp	.+242    	; 0x3712 <f_open+0x24a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    3620:	01 ff       	sbrs	r16, 1
    3622:	7b c0       	rjmp	.+246    	; 0x371a <f_open+0x252>
    3624:	80 fd       	sbrc	r24, 0
    3626:	77 c0       	rjmp	.+238    	; 0x3716 <f_open+0x24e>
    3628:	78 c0       	rjmp	.+240    	; 0x371a <f_open+0x252>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
    362a:	00 62       	ori	r16, 0x20	; 32
			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
    362c:	a9 80       	ldd	r10, Y+1	; 0x01
    362e:	ba 80       	ldd	r11, Y+2	; 0x02
    3630:	f5 01       	movw	r30, r10
    3632:	86 a5       	lds	r24, 0x66
    3634:	97 a5       	lds	r25, 0x67
    3636:	a0 a9       	sts	0x40, r26
    3638:	b1 a9       	sts	0x41, r27
    363a:	f7 01       	movw	r30, r14
    363c:	82 8f       	std	Z+26, r24	; 0x1a
    363e:	93 8f       	std	Z+27, r25	; 0x1b
    3640:	a4 8f       	std	Z+28, r26	; 0x1c
    3642:	b5 8f       	std	Z+29, r27	; 0x1d
			fp->dir_ptr = dir;
    3644:	d7 8e       	std	Z+31, r13	; 0x1f
    3646:	c6 8e       	std	Z+30, r12	; 0x1e
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
    3648:	04 83       	std	Z+4, r16	; 0x04
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
    364a:	c5 01       	movw	r24, r10
    364c:	b6 01       	movw	r22, r12
    364e:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <ld_clust>
    3652:	dc 01       	movw	r26, r24
    3654:	cb 01       	movw	r24, r22
    3656:	f7 01       	movw	r30, r14
    3658:	86 87       	std	Z+14, r24	; 0x0e
    365a:	97 87       	std	Z+15, r25	; 0x0f
    365c:	a0 8b       	std	Z+16, r26	; 0x10
    365e:	b1 8b       	std	Z+17, r27	; 0x11
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    3660:	f6 01       	movw	r30, r12
    3662:	87 8d       	ldd	r24, Z+31	; 0x1f
    3664:	90 e0       	ldi	r25, 0x00	; 0
    3666:	a0 e0       	ldi	r26, 0x00	; 0
    3668:	b0 e0       	ldi	r27, 0x00	; 0
    366a:	78 2f       	mov	r23, r24
    366c:	66 27       	eor	r22, r22
    366e:	55 27       	eor	r21, r21
    3670:	44 27       	eor	r20, r20
    3672:	86 8d       	ldd	r24, Z+30	; 0x1e
    3674:	90 e0       	ldi	r25, 0x00	; 0
    3676:	a0 e0       	ldi	r26, 0x00	; 0
    3678:	b0 e0       	ldi	r27, 0x00	; 0
    367a:	dc 01       	movw	r26, r24
    367c:	99 27       	eor	r25, r25
    367e:	88 27       	eor	r24, r24
    3680:	48 2b       	or	r20, r24
    3682:	59 2b       	or	r21, r25
    3684:	6a 2b       	or	r22, r26
    3686:	7b 2b       	or	r23, r27
    3688:	84 8d       	ldd	r24, Z+28	; 0x1c
    368a:	90 e0       	ldi	r25, 0x00	; 0
    368c:	a0 e0       	ldi	r26, 0x00	; 0
    368e:	b0 e0       	ldi	r27, 0x00	; 0
    3690:	48 2b       	or	r20, r24
    3692:	59 2b       	or	r21, r25
    3694:	6a 2b       	or	r22, r26
    3696:	7b 2b       	or	r23, r27
    3698:	95 8d       	ldd	r25, Z+29	; 0x1d
    369a:	80 e0       	ldi	r24, 0x00	; 0
    369c:	a0 e0       	ldi	r26, 0x00	; 0
    369e:	b0 e0       	ldi	r27, 0x00	; 0
    36a0:	84 2b       	or	r24, r20
    36a2:	95 2b       	or	r25, r21
    36a4:	a6 2b       	or	r26, r22
    36a6:	b7 2b       	or	r27, r23
    36a8:	f7 01       	movw	r30, r14
    36aa:	82 87       	std	Z+10, r24	; 0x0a
    36ac:	93 87       	std	Z+11, r25	; 0x0b
    36ae:	a4 87       	std	Z+12, r26	; 0x0c
    36b0:	b5 87       	std	Z+13, r27	; 0x0d
			fp->fptr = 0;						/* File pointer */
    36b2:	16 82       	std	Z+6, r1	; 0x06
    36b4:	17 82       	std	Z+7, r1	; 0x07
    36b6:	10 86       	std	Z+8, r1	; 0x08
    36b8:	11 86       	std	Z+9, r1	; 0x09
			fp->dsect = 0;
    36ba:	16 8a       	std	Z+22, r1	; 0x16
    36bc:	17 8a       	std	Z+23, r1	; 0x17
    36be:	10 8e       	std	Z+24, r1	; 0x18
    36c0:	11 8e       	std	Z+25, r1	; 0x19
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    36c2:	b1 82       	std	Z+1, r11	; 0x01
    36c4:	a0 82       	st	Z, r10
    36c6:	f5 01       	movw	r30, r10
    36c8:	86 81       	ldd	r24, Z+6	; 0x06
    36ca:	97 81       	ldd	r25, Z+7	; 0x07
    36cc:	f7 01       	movw	r30, r14
    36ce:	93 83       	std	Z+3, r25	; 0x03
    36d0:	82 83       	std	Z+2, r24	; 0x02
    36d2:	03 c0       	rjmp	.+6      	; 0x36da <f_open+0x212>
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    36d4:	18 2f       	mov	r17, r24
    36d6:	01 c0       	rjmp	.+2      	; 0x36da <f_open+0x212>
    36d8:	19 e0       	ldi	r17, 0x09	; 9
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
		}
	}

	LEAVE_FF(dj.fs, res);
}
    36da:	81 2f       	mov	r24, r17
    36dc:	a4 96       	adiw	r28, 0x24	; 36
    36de:	0f b6       	in	r0, 0x3f	; 63
    36e0:	f8 94       	cli
    36e2:	de bf       	out	0x3e, r29	; 62
    36e4:	0f be       	out	0x3f, r0	; 63
    36e6:	cd bf       	out	0x3d, r28	; 61
    36e8:	df 91       	pop	r29
    36ea:	cf 91       	pop	r28
    36ec:	1f 91       	pop	r17
    36ee:	0f 91       	pop	r16
    36f0:	ff 90       	pop	r15
    36f2:	ef 90       	pop	r14
    36f4:	df 90       	pop	r13
    36f6:	cf 90       	pop	r12
    36f8:	bf 90       	pop	r11
    36fa:	af 90       	pop	r10
    36fc:	9f 90       	pop	r9
    36fe:	8f 90       	pop	r8
    3700:	7f 90       	pop	r7
    3702:	6f 90       	pop	r6
    3704:	5f 90       	pop	r5
    3706:	4f 90       	pop	r4
    3708:	08 95       	ret
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
					res = FR_DENIED;
    370a:	87 e0       	ldi	r24, 0x07	; 7
    370c:	e3 cf       	rjmp	.-58     	; 0x36d4 <f_open+0x20c>
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
    370e:	88 e0       	ldi	r24, 0x08	; 8
    3710:	e1 cf       	rjmp	.-62     	; 0x36d4 <f_open+0x20c>
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {						/* Follow succeeded */
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
					res = FR_NO_FILE;
    3712:	84 e0       	ldi	r24, 0x04	; 4
    3714:	df cf       	rjmp	.-66     	; 0x36d4 <f_open+0x20c>
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
    3716:	87 e0       	ldi	r24, 0x07	; 7
    3718:	dd cf       	rjmp	.-70     	; 0x36d4 <f_open+0x20c>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
    371a:	03 ff       	sbrs	r16, 3
    371c:	87 cf       	rjmp	.-242    	; 0x362c <f_open+0x164>
    371e:	85 cf       	rjmp	.-246    	; 0x362a <f_open+0x162>

00003720 <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
    3720:	2f 92       	push	r2
    3722:	3f 92       	push	r3
    3724:	4f 92       	push	r4
    3726:	5f 92       	push	r5
    3728:	6f 92       	push	r6
    372a:	7f 92       	push	r7
    372c:	8f 92       	push	r8
    372e:	9f 92       	push	r9
    3730:	af 92       	push	r10
    3732:	bf 92       	push	r11
    3734:	cf 92       	push	r12
    3736:	df 92       	push	r13
    3738:	ef 92       	push	r14
    373a:	ff 92       	push	r15
    373c:	0f 93       	push	r16
    373e:	1f 93       	push	r17
    3740:	cf 93       	push	r28
    3742:	df 93       	push	r29
    3744:	cd b7       	in	r28, 0x3d	; 61
    3746:	de b7       	in	r29, 0x3e	; 62
    3748:	29 97       	sbiw	r28, 0x09	; 9
    374a:	0f b6       	in	r0, 0x3f	; 63
    374c:	f8 94       	cli
    374e:	de bf       	out	0x3e, r29	; 62
    3750:	0f be       	out	0x3f, r0	; 63
    3752:	cd bf       	out	0x3d, r28	; 61
    3754:	9c 83       	std	Y+4, r25	; 0x04
    3756:	8b 83       	std	Y+3, r24	; 0x03
    3758:	a6 2e       	mov	r10, r22
    375a:	97 2e       	mov	r9, r23
    375c:	c2 2e       	mov	r12, r18
    375e:	f3 2e       	mov	r15, r19
    3760:	e4 2e       	mov	r14, r20
    3762:	d5 2e       	mov	r13, r21
    3764:	18 01       	movw	r2, r16
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Clear read byte counter */
    3766:	d8 01       	movw	r26, r16
    3768:	1d 92       	st	X+, r1
    376a:	1d 92       	st	X+, r1
    376c:	1d 92       	st	X+, r1
    376e:	1c 92       	st	X, r1
    3770:	13 97       	sbiw	r26, 0x03	; 3

	res = validate(fp);							/* Check validity */
    3772:	0e 94 28 0b 	call	0x1650	; 0x1650 <validate>
    3776:	b8 2e       	mov	r11, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3778:	88 23       	and	r24, r24
    377a:	09 f0       	breq	.+2      	; 0x377e <f_read+0x5e>
    377c:	e1 c1       	rjmp	.+962    	; 0x3b40 <f_read+0x420>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
    377e:	eb 81       	ldd	r30, Y+3	; 0x03
    3780:	fc 81       	ldd	r31, Y+4	; 0x04
    3782:	84 81       	ldd	r24, Z+4	; 0x04
    3784:	88 23       	and	r24, r24
    3786:	0c f4       	brge	.+2      	; 0x378a <f_read+0x6a>
    3788:	d3 c1       	rjmp	.+934    	; 0x3b30 <f_read+0x410>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    378a:	80 ff       	sbrs	r24, 0
    378c:	d5 c1       	rjmp	.+938    	; 0x3b38 <f_read+0x418>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
    378e:	42 85       	ldd	r20, Z+10	; 0x0a
    3790:	53 85       	ldd	r21, Z+11	; 0x0b
    3792:	64 85       	ldd	r22, Z+12	; 0x0c
    3794:	75 85       	ldd	r23, Z+13	; 0x0d
    3796:	86 81       	ldd	r24, Z+6	; 0x06
    3798:	97 81       	ldd	r25, Z+7	; 0x07
    379a:	a0 85       	ldd	r26, Z+8	; 0x08
    379c:	b1 85       	ldd	r27, Z+9	; 0x09
    379e:	48 1b       	sub	r20, r24
    37a0:	59 0b       	sbc	r21, r25
    37a2:	6a 0b       	sbc	r22, r26
    37a4:	7b 0b       	sbc	r23, r27

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    37a6:	4c 2c       	mov	r4, r12
    37a8:	5f 2c       	mov	r5, r15
    37aa:	6e 2c       	mov	r6, r14
    37ac:	7d 2c       	mov	r7, r13
    37ae:	44 15       	cp	r20, r4
    37b0:	55 05       	cpc	r21, r5
    37b2:	66 05       	cpc	r22, r6
    37b4:	77 05       	cpc	r23, r7
    37b6:	10 f4       	brcc	.+4      	; 0x37bc <f_read+0x9c>
    37b8:	2a 01       	movw	r4, r20
    37ba:	3b 01       	movw	r6, r22
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    37bc:	41 14       	cp	r4, r1
    37be:	51 04       	cpc	r5, r1
    37c0:	61 04       	cpc	r6, r1
    37c2:	71 04       	cpc	r7, r1
    37c4:	09 f4       	brne	.+2      	; 0x37c8 <f_read+0xa8>
    37c6:	bc c1       	rjmp	.+888    	; 0x3b40 <f_read+0x420>
    37c8:	a9 82       	std	Y+1, r10	; 0x01
    37ca:	9a 82       	std	Y+2, r9	; 0x02
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    37cc:	0b 81       	ldd	r16, Y+3	; 0x03
    37ce:	1c 81       	ldd	r17, Y+4	; 0x04
    37d0:	00 5e       	subi	r16, 0xE0	; 224
    37d2:	1f 4f       	sbci	r17, 0xFF	; 255
    37d4:	1e 83       	std	Y+6, r17	; 0x06
    37d6:	0d 83       	std	Y+5, r16	; 0x05
    37d8:	bf 82       	std	Y+7, r11	; 0x07
    37da:	2b 81       	ldd	r18, Y+3	; 0x03
    37dc:	3c 81       	ldd	r19, Y+4	; 0x04
    37de:	39 87       	std	Y+9, r19	; 0x09
    37e0:	28 87       	std	Y+8, r18	; 0x08
    37e2:	3c 82       	std	Y+4, r3	; 0x04
    37e4:	2b 82       	std	Y+3, r2	; 0x03
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    37e6:	a8 85       	ldd	r26, Y+8	; 0x08
    37e8:	b9 85       	ldd	r27, Y+9	; 0x09
    37ea:	16 96       	adiw	r26, 0x06	; 6
    37ec:	4d 91       	ld	r20, X+
    37ee:	5d 91       	ld	r21, X+
    37f0:	6d 91       	ld	r22, X+
    37f2:	7c 91       	ld	r23, X
    37f4:	19 97       	sbiw	r26, 0x09	; 9
    37f6:	db 01       	movw	r26, r22
    37f8:	ca 01       	movw	r24, r20
    37fa:	91 70       	andi	r25, 0x01	; 1
    37fc:	a0 70       	andi	r26, 0x00	; 0
    37fe:	b0 70       	andi	r27, 0x00	; 0
    3800:	00 97       	sbiw	r24, 0x00	; 0
    3802:	a1 05       	cpc	r26, r1
    3804:	b1 05       	cpc	r27, r1
    3806:	09 f0       	breq	.+2      	; 0x380a <f_read+0xea>
    3808:	3f c1       	rjmp	.+638    	; 0x3a88 <f_read+0x368>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    380a:	a8 85       	ldd	r26, Y+8	; 0x08
    380c:	b9 85       	ldd	r27, Y+9	; 0x09
    380e:	ed 91       	ld	r30, X+
    3810:	fc 91       	ld	r31, X
    3812:	db 01       	movw	r26, r22
    3814:	ca 01       	movw	r24, r20
    3816:	07 2e       	mov	r0, r23
    3818:	79 e0       	ldi	r23, 0x09	; 9
    381a:	b6 95       	lsr	r27
    381c:	a7 95       	ror	r26
    381e:	97 95       	ror	r25
    3820:	87 95       	ror	r24
    3822:	7a 95       	dec	r23
    3824:	d1 f7       	brne	.-12     	; 0x381a <f_read+0xfa>
    3826:	70 2d       	mov	r23, r0
    3828:	02 81       	ldd	r16, Z+2	; 0x02
    382a:	01 50       	subi	r16, 0x01	; 1
    382c:	08 23       	and	r16, r24
			if (!csect) {						/* On the cluster boundary? */
    382e:	09 f0       	breq	.+2      	; 0x3832 <f_read+0x112>
    3830:	44 c0       	rjmp	.+136    	; 0x38ba <f_read+0x19a>
				if (fp->fptr == 0) {			/* On the top of the file? */
    3832:	41 15       	cp	r20, r1
    3834:	51 05       	cpc	r21, r1
    3836:	61 05       	cpc	r22, r1
    3838:	71 05       	cpc	r23, r1
    383a:	39 f4       	brne	.+14     	; 0x384a <f_read+0x12a>
					clst = fp->sclust;			/* Follow from the origin */
    383c:	e8 85       	ldd	r30, Y+8	; 0x08
    383e:	f9 85       	ldd	r31, Y+9	; 0x09
    3840:	86 85       	ldd	r24, Z+14	; 0x0e
    3842:	97 85       	ldd	r25, Z+15	; 0x0f
    3844:	a0 89       	ldd	r26, Z+16	; 0x10
    3846:	b1 89       	ldd	r27, Z+17	; 0x11
    3848:	0d c0       	rjmp	.+26     	; 0x3864 <f_read+0x144>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    384a:	a8 85       	ldd	r26, Y+8	; 0x08
    384c:	b9 85       	ldd	r27, Y+9	; 0x09
    384e:	52 96       	adiw	r26, 0x12	; 18
    3850:	4d 91       	ld	r20, X+
    3852:	5d 91       	ld	r21, X+
    3854:	6d 91       	ld	r22, X+
    3856:	7c 91       	ld	r23, X
    3858:	55 97       	sbiw	r26, 0x15	; 21
    385a:	cf 01       	movw	r24, r30
    385c:	0e 94 82 11 	call	0x2304	; 0x2304 <get_fat>
    3860:	dc 01       	movw	r26, r24
    3862:	cb 01       	movw	r24, r22
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    3864:	82 30       	cpi	r24, 0x02	; 2
    3866:	91 05       	cpc	r25, r1
    3868:	a1 05       	cpc	r26, r1
    386a:	b1 05       	cpc	r27, r1
    386c:	48 f4       	brcc	.+18     	; 0x3880 <f_read+0x160>
    386e:	e8 85       	ldd	r30, Y+8	; 0x08
    3870:	f9 85       	ldd	r31, Y+9	; 0x09
    3872:	84 81       	ldd	r24, Z+4	; 0x04
    3874:	80 68       	ori	r24, 0x80	; 128
    3876:	84 83       	std	Z+4, r24	; 0x04
    3878:	bb 24       	eor	r11, r11
    387a:	68 94       	set
    387c:	b1 f8       	bld	r11, 1
    387e:	60 c1       	rjmp	.+704    	; 0x3b40 <f_read+0x420>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3880:	8f 3f       	cpi	r24, 0xFF	; 255
    3882:	ff ef       	ldi	r31, 0xFF	; 255
    3884:	9f 07       	cpc	r25, r31
    3886:	ff ef       	ldi	r31, 0xFF	; 255
    3888:	af 07       	cpc	r26, r31
    388a:	ff ef       	ldi	r31, 0xFF	; 255
    388c:	bf 07       	cpc	r27, r31
    388e:	79 f4       	brne	.+30     	; 0x38ae <f_read+0x18e>
    3890:	08 85       	ldd	r16, Y+8	; 0x08
    3892:	19 85       	ldd	r17, Y+9	; 0x09
    3894:	1c 83       	std	Y+4, r17	; 0x04
    3896:	0b 83       	std	Y+3, r16	; 0x03
    3898:	d8 01       	movw	r26, r16
    389a:	14 96       	adiw	r26, 0x04	; 4
    389c:	8c 91       	ld	r24, X
    389e:	14 97       	sbiw	r26, 0x04	; 4
    38a0:	80 68       	ori	r24, 0x80	; 128
    38a2:	14 96       	adiw	r26, 0x04	; 4
    38a4:	8c 93       	st	X, r24
    38a6:	14 97       	sbiw	r26, 0x04	; 4
    38a8:	bb 24       	eor	r11, r11
    38aa:	b3 94       	inc	r11
    38ac:	49 c1       	rjmp	.+658    	; 0x3b40 <f_read+0x420>
				fp->clust = clst;				/* Update current cluster */
    38ae:	e8 85       	ldd	r30, Y+8	; 0x08
    38b0:	f9 85       	ldd	r31, Y+9	; 0x09
    38b2:	82 8b       	std	Z+18, r24	; 0x12
    38b4:	93 8b       	std	Z+19, r25	; 0x13
    38b6:	a4 8b       	std	Z+20, r26	; 0x14
    38b8:	b5 8b       	std	Z+21, r27	; 0x15
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    38ba:	a8 85       	ldd	r26, Y+8	; 0x08
    38bc:	b9 85       	ldd	r27, Y+9	; 0x09
    38be:	2d 90       	ld	r2, X+
    38c0:	3c 90       	ld	r3, X
    38c2:	11 97       	sbiw	r26, 0x01	; 1
    38c4:	52 96       	adiw	r26, 0x12	; 18
    38c6:	4d 91       	ld	r20, X+
    38c8:	5d 91       	ld	r21, X+
    38ca:	6d 91       	ld	r22, X+
    38cc:	7c 91       	ld	r23, X
    38ce:	55 97       	sbiw	r26, 0x15	; 21
    38d0:	c1 01       	movw	r24, r2
    38d2:	0e 94 4c 11 	call	0x2298	; 0x2298 <clust2sect>
    38d6:	dc 01       	movw	r26, r24
    38d8:	cb 01       	movw	r24, r22
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    38da:	00 97       	sbiw	r24, 0x00	; 0
    38dc:	a1 05       	cpc	r26, r1
    38de:	b1 05       	cpc	r27, r1
    38e0:	49 f4       	brne	.+18     	; 0x38f4 <f_read+0x1d4>
    38e2:	e8 85       	ldd	r30, Y+8	; 0x08
    38e4:	f9 85       	ldd	r31, Y+9	; 0x09
    38e6:	84 81       	ldd	r24, Z+4	; 0x04
    38e8:	80 68       	ori	r24, 0x80	; 128
    38ea:	84 83       	std	Z+4, r24	; 0x04
    38ec:	bb 24       	eor	r11, r11
    38ee:	68 94       	set
    38f0:	b1 f8       	bld	r11, 1
    38f2:	26 c1       	rjmp	.+588    	; 0x3b40 <f_read+0x420>
			sect += csect;
    38f4:	40 2f       	mov	r20, r16
    38f6:	50 e0       	ldi	r21, 0x00	; 0
    38f8:	60 e0       	ldi	r22, 0x00	; 0
    38fa:	70 e0       	ldi	r23, 0x00	; 0
    38fc:	4c 01       	movw	r8, r24
    38fe:	5d 01       	movw	r10, r26
    3900:	84 0e       	add	r8, r20
    3902:	95 1e       	adc	r9, r21
    3904:	a6 1e       	adc	r10, r22
    3906:	b7 1e       	adc	r11, r23
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    3908:	73 01       	movw	r14, r6
    390a:	62 01       	movw	r12, r4
    390c:	0b 2e       	mov	r0, r27
    390e:	b9 e0       	ldi	r27, 0x09	; 9
    3910:	f6 94       	lsr	r15
    3912:	e7 94       	ror	r14
    3914:	d7 94       	ror	r13
    3916:	c7 94       	ror	r12
    3918:	ba 95       	dec	r27
    391a:	d1 f7       	brne	.-12     	; 0x3910 <f_read+0x1f0>
    391c:	b0 2d       	mov	r27, r0
			if (cc) {							/* Read maximum contiguous sectors directly */
    391e:	c1 14       	cp	r12, r1
    3920:	d1 04       	cpc	r13, r1
    3922:	e1 04       	cpc	r14, r1
    3924:	f1 04       	cpc	r15, r1
    3926:	09 f4       	brne	.+2      	; 0x392a <f_read+0x20a>
    3928:	60 c0       	rjmp	.+192    	; 0x39ea <f_read+0x2ca>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    392a:	d1 01       	movw	r26, r2
    392c:	12 96       	adiw	r26, 0x02	; 2
    392e:	2c 91       	ld	r18, X
    3930:	d7 01       	movw	r26, r14
    3932:	c6 01       	movw	r24, r12
    3934:	84 0f       	add	r24, r20
    3936:	95 1f       	adc	r25, r21
    3938:	a6 1f       	adc	r26, r22
    393a:	b7 1f       	adc	r27, r23
    393c:	42 2f       	mov	r20, r18
    393e:	50 e0       	ldi	r21, 0x00	; 0
    3940:	60 e0       	ldi	r22, 0x00	; 0
    3942:	70 e0       	ldi	r23, 0x00	; 0
    3944:	48 17       	cp	r20, r24
    3946:	59 07       	cpc	r21, r25
    3948:	6a 07       	cpc	r22, r26
    394a:	7b 07       	cpc	r23, r27
    394c:	48 f4       	brcc	.+18     	; 0x3960 <f_read+0x240>
					cc = fp->fs->csize - csect;
    394e:	82 2f       	mov	r24, r18
    3950:	90 e0       	ldi	r25, 0x00	; 0
    3952:	80 1b       	sub	r24, r16
    3954:	91 09       	sbc	r25, r1
    3956:	6c 01       	movw	r12, r24
    3958:	ee 24       	eor	r14, r14
    395a:	d7 fc       	sbrc	r13, 7
    395c:	e0 94       	com	r14
    395e:	fe 2c       	mov	r15, r14
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    3960:	f1 01       	movw	r30, r2
    3962:	81 81       	ldd	r24, Z+1	; 0x01
    3964:	69 81       	ldd	r22, Y+1	; 0x01
    3966:	7a 81       	ldd	r23, Y+2	; 0x02
    3968:	a5 01       	movw	r20, r10
    396a:	94 01       	movw	r18, r8
    396c:	0c 2d       	mov	r16, r12
    396e:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    3972:	88 23       	and	r24, r24
    3974:	79 f0       	breq	.+30     	; 0x3994 <f_read+0x274>
    3976:	08 85       	ldd	r16, Y+8	; 0x08
    3978:	19 85       	ldd	r17, Y+9	; 0x09
    397a:	1c 83       	std	Y+4, r17	; 0x04
    397c:	0b 83       	std	Y+3, r16	; 0x03
					ABORT(fp->fs, FR_DISK_ERR);
    397e:	d8 01       	movw	r26, r16
    3980:	14 96       	adiw	r26, 0x04	; 4
    3982:	8c 91       	ld	r24, X
    3984:	14 97       	sbiw	r26, 0x04	; 4
    3986:	80 68       	ori	r24, 0x80	; 128
    3988:	14 96       	adiw	r26, 0x04	; 4
    398a:	8c 93       	st	X, r24
    398c:	14 97       	sbiw	r26, 0x04	; 4
    398e:	bb 24       	eor	r11, r11
    3990:	b3 94       	inc	r11
    3992:	d6 c0       	rjmp	.+428    	; 0x3b40 <f_read+0x420>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
    3994:	e8 85       	ldd	r30, Y+8	; 0x08
    3996:	f9 85       	ldd	r31, Y+9	; 0x09
    3998:	84 81       	ldd	r24, Z+4	; 0x04
    399a:	86 ff       	sbrs	r24, 6
    399c:	1c c0       	rjmp	.+56     	; 0x39d6 <f_read+0x2b6>
    399e:	86 89       	ldd	r24, Z+22	; 0x16
    39a0:	97 89       	ldd	r25, Z+23	; 0x17
    39a2:	a0 8d       	ldd	r26, Z+24	; 0x18
    39a4:	b1 8d       	ldd	r27, Z+25	; 0x19
    39a6:	88 19       	sub	r24, r8
    39a8:	99 09       	sbc	r25, r9
    39aa:	aa 09       	sbc	r26, r10
    39ac:	bb 09       	sbc	r27, r11
    39ae:	8c 15       	cp	r24, r12
    39b0:	9d 05       	cpc	r25, r13
    39b2:	ae 05       	cpc	r26, r14
    39b4:	bf 05       	cpc	r27, r15
    39b6:	78 f4       	brcc	.+30     	; 0x39d6 <f_read+0x2b6>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
    39b8:	98 2f       	mov	r25, r24
    39ba:	88 27       	eor	r24, r24
    39bc:	99 0f       	add	r25, r25
    39be:	09 81       	ldd	r16, Y+1	; 0x01
    39c0:	1a 81       	ldd	r17, Y+2	; 0x02
    39c2:	80 0f       	add	r24, r16
    39c4:	91 1f       	adc	r25, r17
    39c6:	6d 81       	ldd	r22, Y+5	; 0x05
    39c8:	7e 81       	ldd	r23, Y+6	; 0x06
    39ca:	20 e0       	ldi	r18, 0x00	; 0
    39cc:	32 e0       	ldi	r19, 0x02	; 2
    39ce:	40 e0       	ldi	r20, 0x00	; 0
    39d0:	50 e0       	ldi	r21, 0x00	; 0
    39d2:	0e 94 42 0a 	call	0x1484	; 0x1484 <mem_cpy>
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    39d6:	0b 2e       	mov	r0, r27
    39d8:	b9 e0       	ldi	r27, 0x09	; 9
    39da:	cc 0c       	add	r12, r12
    39dc:	dd 1c       	adc	r13, r13
    39de:	ee 1c       	adc	r14, r14
    39e0:	ff 1c       	adc	r15, r15
    39e2:	ba 95       	dec	r27
    39e4:	d1 f7       	brne	.-12     	; 0x39da <f_read+0x2ba>
    39e6:	b0 2d       	mov	r27, r0
				continue;
    39e8:	79 c0       	rjmp	.+242    	; 0x3adc <f_read+0x3bc>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
    39ea:	a8 85       	ldd	r26, Y+8	; 0x08
    39ec:	b9 85       	ldd	r27, Y+9	; 0x09
    39ee:	56 96       	adiw	r26, 0x16	; 22
    39f0:	0d 91       	ld	r16, X+
    39f2:	1d 91       	ld	r17, X+
    39f4:	2d 91       	ld	r18, X+
    39f6:	3c 91       	ld	r19, X
    39f8:	59 97       	sbiw	r26, 0x19	; 25
    39fa:	08 15       	cp	r16, r8
    39fc:	19 05       	cpc	r17, r9
    39fe:	2a 05       	cpc	r18, r10
    3a00:	3b 05       	cpc	r19, r11
    3a02:	d1 f1       	breq	.+116    	; 0x3a78 <f_read+0x358>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
    3a04:	14 96       	adiw	r26, 0x04	; 4
    3a06:	8c 91       	ld	r24, X
    3a08:	14 97       	sbiw	r26, 0x04	; 4
    3a0a:	86 ff       	sbrs	r24, 6
    3a0c:	1f c0       	rjmp	.+62     	; 0x3a4c <f_read+0x32c>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3a0e:	f1 01       	movw	r30, r2
    3a10:	81 81       	ldd	r24, Z+1	; 0x01
    3a12:	6d 81       	ldd	r22, Y+5	; 0x05
    3a14:	7e 81       	ldd	r23, Y+6	; 0x06
    3a16:	a9 01       	movw	r20, r18
    3a18:	98 01       	movw	r18, r16
    3a1a:	01 e0       	ldi	r16, 0x01	; 1
    3a1c:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    3a20:	88 23       	and	r24, r24
    3a22:	79 f0       	breq	.+30     	; 0x3a42 <f_read+0x322>
    3a24:	08 85       	ldd	r16, Y+8	; 0x08
    3a26:	19 85       	ldd	r17, Y+9	; 0x09
    3a28:	1c 83       	std	Y+4, r17	; 0x04
    3a2a:	0b 83       	std	Y+3, r16	; 0x03
						ABORT(fp->fs, FR_DISK_ERR);
    3a2c:	d8 01       	movw	r26, r16
    3a2e:	14 96       	adiw	r26, 0x04	; 4
    3a30:	8c 91       	ld	r24, X
    3a32:	14 97       	sbiw	r26, 0x04	; 4
    3a34:	80 68       	ori	r24, 0x80	; 128
    3a36:	14 96       	adiw	r26, 0x04	; 4
    3a38:	8c 93       	st	X, r24
    3a3a:	14 97       	sbiw	r26, 0x04	; 4
    3a3c:	bb 24       	eor	r11, r11
    3a3e:	b3 94       	inc	r11
    3a40:	7f c0       	rjmp	.+254    	; 0x3b40 <f_read+0x420>
					fp->flag &= ~FA__DIRTY;
    3a42:	e8 85       	ldd	r30, Y+8	; 0x08
    3a44:	f9 85       	ldd	r31, Y+9	; 0x09
    3a46:	84 81       	ldd	r24, Z+4	; 0x04
    3a48:	8f 7b       	andi	r24, 0xBF	; 191
    3a4a:	84 83       	std	Z+4, r24	; 0x04
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    3a4c:	a8 85       	ldd	r26, Y+8	; 0x08
    3a4e:	b9 85       	ldd	r27, Y+9	; 0x09
    3a50:	ed 91       	ld	r30, X+
    3a52:	fc 91       	ld	r31, X
    3a54:	81 81       	ldd	r24, Z+1	; 0x01
    3a56:	6d 81       	ldd	r22, Y+5	; 0x05
    3a58:	7e 81       	ldd	r23, Y+6	; 0x06
    3a5a:	a5 01       	movw	r20, r10
    3a5c:	94 01       	movw	r18, r8
    3a5e:	01 e0       	ldi	r16, 0x01	; 1
    3a60:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    3a64:	88 23       	and	r24, r24
    3a66:	41 f0       	breq	.+16     	; 0x3a78 <f_read+0x358>
    3a68:	e8 85       	ldd	r30, Y+8	; 0x08
    3a6a:	f9 85       	ldd	r31, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3a6c:	84 81       	ldd	r24, Z+4	; 0x04
    3a6e:	80 68       	ori	r24, 0x80	; 128
    3a70:	84 83       	std	Z+4, r24	; 0x04
    3a72:	bb 24       	eor	r11, r11
    3a74:	b3 94       	inc	r11
    3a76:	64 c0       	rjmp	.+200    	; 0x3b40 <f_read+0x420>
			}
#endif
			fp->dsect = sect;
    3a78:	a8 85       	ldd	r26, Y+8	; 0x08
    3a7a:	b9 85       	ldd	r27, Y+9	; 0x09
    3a7c:	56 96       	adiw	r26, 0x16	; 22
    3a7e:	8d 92       	st	X+, r8
    3a80:	9d 92       	st	X+, r9
    3a82:	ad 92       	st	X+, r10
    3a84:	bc 92       	st	X, r11
    3a86:	59 97       	sbiw	r26, 0x19	; 25
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    3a88:	e8 85       	ldd	r30, Y+8	; 0x08
    3a8a:	f9 85       	ldd	r31, Y+9	; 0x09
    3a8c:	46 81       	ldd	r20, Z+6	; 0x06
    3a8e:	57 81       	ldd	r21, Z+7	; 0x07
    3a90:	60 85       	ldd	r22, Z+8	; 0x08
    3a92:	71 85       	ldd	r23, Z+9	; 0x09
    3a94:	db 01       	movw	r26, r22
    3a96:	ca 01       	movw	r24, r20
    3a98:	91 70       	andi	r25, 0x01	; 1
    3a9a:	a0 70       	andi	r26, 0x00	; 0
    3a9c:	b0 70       	andi	r27, 0x00	; 0
    3a9e:	00 e0       	ldi	r16, 0x00	; 0
    3aa0:	12 e0       	ldi	r17, 0x02	; 2
    3aa2:	20 e0       	ldi	r18, 0x00	; 0
    3aa4:	30 e0       	ldi	r19, 0x00	; 0
    3aa6:	08 1b       	sub	r16, r24
    3aa8:	19 0b       	sbc	r17, r25
    3aaa:	2a 0b       	sbc	r18, r26
    3aac:	3b 0b       	sbc	r19, r27
    3aae:	73 01       	movw	r14, r6
    3ab0:	62 01       	movw	r12, r4
    3ab2:	04 15       	cp	r16, r4
    3ab4:	15 05       	cpc	r17, r5
    3ab6:	26 05       	cpc	r18, r6
    3ab8:	37 05       	cpc	r19, r7
    3aba:	10 f4       	brcc	.+4      	; 0x3ac0 <f_read+0x3a0>
    3abc:	68 01       	movw	r12, r16
    3abe:	79 01       	movw	r14, r18
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    3ac0:	ba 01       	movw	r22, r20
    3ac2:	71 70       	andi	r23, 0x01	; 1
    3ac4:	60 5e       	subi	r22, 0xE0	; 224
    3ac6:	7f 4f       	sbci	r23, 0xFF	; 255
    3ac8:	28 85       	ldd	r18, Y+8	; 0x08
    3aca:	39 85       	ldd	r19, Y+9	; 0x09
    3acc:	62 0f       	add	r22, r18
    3ace:	73 1f       	adc	r23, r19
    3ad0:	89 81       	ldd	r24, Y+1	; 0x01
    3ad2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ad4:	a7 01       	movw	r20, r14
    3ad6:	96 01       	movw	r18, r12
    3ad8:	0e 94 42 0a 	call	0x1484	; 0x1484 <mem_cpy>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    3adc:	89 81       	ldd	r24, Y+1	; 0x01
    3ade:	9a 81       	ldd	r25, Y+2	; 0x02
    3ae0:	8c 0d       	add	r24, r12
    3ae2:	9d 1d       	adc	r25, r13
    3ae4:	9a 83       	std	Y+2, r25	; 0x02
    3ae6:	89 83       	std	Y+1, r24	; 0x01
    3ae8:	e8 85       	ldd	r30, Y+8	; 0x08
    3aea:	f9 85       	ldd	r31, Y+9	; 0x09
    3aec:	86 81       	ldd	r24, Z+6	; 0x06
    3aee:	97 81       	ldd	r25, Z+7	; 0x07
    3af0:	a0 85       	ldd	r26, Z+8	; 0x08
    3af2:	b1 85       	ldd	r27, Z+9	; 0x09
    3af4:	8c 0d       	add	r24, r12
    3af6:	9d 1d       	adc	r25, r13
    3af8:	ae 1d       	adc	r26, r14
    3afa:	bf 1d       	adc	r27, r15
    3afc:	86 83       	std	Z+6, r24	; 0x06
    3afe:	97 83       	std	Z+7, r25	; 0x07
    3b00:	a0 87       	std	Z+8, r26	; 0x08
    3b02:	b1 87       	std	Z+9, r27	; 0x09
    3b04:	eb 81       	ldd	r30, Y+3	; 0x03
    3b06:	fc 81       	ldd	r31, Y+4	; 0x04
    3b08:	80 81       	ld	r24, Z
    3b0a:	91 81       	ldd	r25, Z+1	; 0x01
    3b0c:	a2 81       	ldd	r26, Z+2	; 0x02
    3b0e:	b3 81       	ldd	r27, Z+3	; 0x03
    3b10:	8c 0d       	add	r24, r12
    3b12:	9d 1d       	adc	r25, r13
    3b14:	ae 1d       	adc	r26, r14
    3b16:	bf 1d       	adc	r27, r15
    3b18:	80 83       	st	Z, r24
    3b1a:	91 83       	std	Z+1, r25	; 0x01
    3b1c:	a2 83       	std	Z+2, r26	; 0x02
    3b1e:	b3 83       	std	Z+3, r27	; 0x03
    3b20:	4c 18       	sub	r4, r12
    3b22:	5d 08       	sbc	r5, r13
    3b24:	6e 08       	sbc	r6, r14
    3b26:	7f 08       	sbc	r7, r15
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    3b28:	09 f0       	breq	.+2      	; 0x3b2c <f_read+0x40c>
    3b2a:	5d ce       	rjmp	.-838    	; 0x37e6 <f_read+0xc6>
    3b2c:	bf 80       	ldd	r11, Y+7	; 0x07
    3b2e:	08 c0       	rjmp	.+16     	; 0x3b40 <f_read+0x420>
	*br = 0;	/* Clear read byte counter */

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    3b30:	bb 24       	eor	r11, r11
    3b32:	68 94       	set
    3b34:	b1 f8       	bld	r11, 1
    3b36:	04 c0       	rjmp	.+8      	; 0x3b40 <f_read+0x420>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    3b38:	0f 2e       	mov	r0, r31
    3b3a:	f7 e0       	ldi	r31, 0x07	; 7
    3b3c:	bf 2e       	mov	r11, r31
    3b3e:	f0 2d       	mov	r31, r0
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    3b40:	8b 2d       	mov	r24, r11
    3b42:	29 96       	adiw	r28, 0x09	; 9
    3b44:	0f b6       	in	r0, 0x3f	; 63
    3b46:	f8 94       	cli
    3b48:	de bf       	out	0x3e, r29	; 62
    3b4a:	0f be       	out	0x3f, r0	; 63
    3b4c:	cd bf       	out	0x3d, r28	; 61
    3b4e:	df 91       	pop	r29
    3b50:	cf 91       	pop	r28
    3b52:	1f 91       	pop	r17
    3b54:	0f 91       	pop	r16
    3b56:	ff 90       	pop	r15
    3b58:	ef 90       	pop	r14
    3b5a:	df 90       	pop	r13
    3b5c:	cf 90       	pop	r12
    3b5e:	bf 90       	pop	r11
    3b60:	af 90       	pop	r10
    3b62:	9f 90       	pop	r9
    3b64:	8f 90       	pop	r8
    3b66:	7f 90       	pop	r7
    3b68:	6f 90       	pop	r6
    3b6a:	5f 90       	pop	r5
    3b6c:	4f 90       	pop	r4
    3b6e:	3f 90       	pop	r3
    3b70:	2f 90       	pop	r2
    3b72:	08 95       	ret

00003b74 <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
    3b74:	2f 92       	push	r2
    3b76:	3f 92       	push	r3
    3b78:	4f 92       	push	r4
    3b7a:	5f 92       	push	r5
    3b7c:	6f 92       	push	r6
    3b7e:	7f 92       	push	r7
    3b80:	8f 92       	push	r8
    3b82:	9f 92       	push	r9
    3b84:	af 92       	push	r10
    3b86:	bf 92       	push	r11
    3b88:	cf 92       	push	r12
    3b8a:	df 92       	push	r13
    3b8c:	ef 92       	push	r14
    3b8e:	ff 92       	push	r15
    3b90:	0f 93       	push	r16
    3b92:	1f 93       	push	r17
    3b94:	cf 93       	push	r28
    3b96:	df 93       	push	r29
    3b98:	cd b7       	in	r28, 0x3d	; 61
    3b9a:	de b7       	in	r29, 0x3e	; 62
    3b9c:	29 97       	sbiw	r28, 0x09	; 9
    3b9e:	0f b6       	in	r0, 0x3f	; 63
    3ba0:	f8 94       	cli
    3ba2:	de bf       	out	0x3e, r29	; 62
    3ba4:	0f be       	out	0x3f, r0	; 63
    3ba6:	cd bf       	out	0x3d, r28	; 61
    3ba8:	2c 01       	movw	r4, r24
    3baa:	c6 2e       	mov	r12, r22
    3bac:	f7 2e       	mov	r15, r23
    3bae:	49 01       	movw	r8, r18
    3bb0:	5a 01       	movw	r10, r20
    3bb2:	1a 83       	std	Y+2, r17	; 0x02
    3bb4:	09 83       	std	Y+1, r16	; 0x01
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
    3bb6:	d8 01       	movw	r26, r16
    3bb8:	1d 92       	st	X+, r1
    3bba:	1d 92       	st	X+, r1
    3bbc:	1d 92       	st	X+, r1
    3bbe:	1c 92       	st	X, r1
    3bc0:	13 97       	sbiw	r26, 0x03	; 3

	res = validate(fp);						/* Check validity */
    3bc2:	0e 94 28 0b 	call	0x1650	; 0x1650 <validate>
    3bc6:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3bc8:	88 23       	and	r24, r24
    3bca:	09 f0       	breq	.+2      	; 0x3bce <f_write+0x5a>
    3bcc:	17 c2       	rjmp	.+1070   	; 0x3ffc <f_write+0x488>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
    3bce:	f2 01       	movw	r30, r4
    3bd0:	84 81       	ldd	r24, Z+4	; 0x04
    3bd2:	88 23       	and	r24, r24
    3bd4:	0c f4       	brge	.+2      	; 0x3bd8 <f_write+0x64>
    3bd6:	0f c2       	rjmp	.+1054   	; 0x3ff6 <f_write+0x482>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    3bd8:	81 ff       	sbrs	r24, 1
    3bda:	0f c2       	rjmp	.+1054   	; 0x3ffa <f_write+0x486>
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
    3bdc:	82 85       	ldd	r24, Z+10	; 0x0a
    3bde:	93 85       	ldd	r25, Z+11	; 0x0b
    3be0:	a4 85       	ldd	r26, Z+12	; 0x0c
    3be2:	b5 85       	ldd	r27, Z+13	; 0x0d
    3be4:	b5 01       	movw	r22, r10
    3be6:	a4 01       	movw	r20, r8
    3be8:	48 0f       	add	r20, r24
    3bea:	59 1f       	adc	r21, r25
    3bec:	6a 1f       	adc	r22, r26
    3bee:	7b 1f       	adc	r23, r27
    3bf0:	48 17       	cp	r20, r24
    3bf2:	59 07       	cpc	r21, r25
    3bf4:	6a 07       	cpc	r22, r26
    3bf6:	7b 07       	cpc	r23, r27
    3bf8:	08 f4       	brcc	.+2      	; 0x3bfc <f_write+0x88>
    3bfa:	e2 c1       	rjmp	.+964    	; 0x3fc0 <f_write+0x44c>

	for ( ;  btw;							/* Repeat until all data written */
    3bfc:	81 14       	cp	r8, r1
    3bfe:	91 04       	cpc	r9, r1
    3c00:	a1 04       	cpc	r10, r1
    3c02:	b1 04       	cpc	r11, r1
    3c04:	09 f4       	brne	.+2      	; 0x3c08 <f_write+0x94>
    3c06:	dc c1       	rjmp	.+952    	; 0x3fc0 <f_write+0x44c>
    3c08:	cb 82       	std	Y+3, r12	; 0x03
    3c0a:	fc 82       	std	Y+4, r15	; 0x04
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    3c0c:	92 01       	movw	r18, r4
    3c0e:	20 5e       	subi	r18, 0xE0	; 224
    3c10:	3f 4f       	sbci	r19, 0xFF	; 255
    3c12:	3e 83       	std	Y+6, r19	; 0x06
    3c14:	2d 83       	std	Y+5, r18	; 0x05
    3c16:	1f 83       	std	Y+7, r17	; 0x07
    3c18:	59 86       	std	Y+9, r5	; 0x09
    3c1a:	48 86       	std	Y+8, r4	; 0x08
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    3c1c:	a8 85       	ldd	r26, Y+8	; 0x08
    3c1e:	b9 85       	ldd	r27, Y+9	; 0x09
    3c20:	16 96       	adiw	r26, 0x06	; 6
    3c22:	4d 91       	ld	r20, X+
    3c24:	5d 91       	ld	r21, X+
    3c26:	6d 91       	ld	r22, X+
    3c28:	7c 91       	ld	r23, X
    3c2a:	19 97       	sbiw	r26, 0x09	; 9
    3c2c:	db 01       	movw	r26, r22
    3c2e:	ca 01       	movw	r24, r20
    3c30:	91 70       	andi	r25, 0x01	; 1
    3c32:	a0 70       	andi	r26, 0x00	; 0
    3c34:	b0 70       	andi	r27, 0x00	; 0
    3c36:	00 97       	sbiw	r24, 0x00	; 0
    3c38:	a1 05       	cpc	r26, r1
    3c3a:	b1 05       	cpc	r27, r1
    3c3c:	09 f0       	breq	.+2      	; 0x3c40 <f_write+0xcc>
    3c3e:	60 c1       	rjmp	.+704    	; 0x3f00 <f_write+0x38c>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    3c40:	e8 85       	ldd	r30, Y+8	; 0x08
    3c42:	f9 85       	ldd	r31, Y+9	; 0x09
    3c44:	20 81       	ld	r18, Z
    3c46:	31 81       	ldd	r19, Z+1	; 0x01
    3c48:	db 01       	movw	r26, r22
    3c4a:	ca 01       	movw	r24, r20
    3c4c:	07 2e       	mov	r0, r23
    3c4e:	79 e0       	ldi	r23, 0x09	; 9
    3c50:	b6 95       	lsr	r27
    3c52:	a7 95       	ror	r26
    3c54:	97 95       	ror	r25
    3c56:	87 95       	ror	r24
    3c58:	7a 95       	dec	r23
    3c5a:	d1 f7       	brne	.-12     	; 0x3c50 <f_write+0xdc>
    3c5c:	70 2d       	mov	r23, r0
    3c5e:	f9 01       	movw	r30, r18
    3c60:	12 81       	ldd	r17, Z+2	; 0x02
    3c62:	11 50       	subi	r17, 0x01	; 1
    3c64:	18 23       	and	r17, r24
			if (!csect) {					/* On the cluster boundary? */
    3c66:	09 f0       	breq	.+2      	; 0x3c6a <f_write+0xf6>
    3c68:	57 c0       	rjmp	.+174    	; 0x3d18 <f_write+0x1a4>
				if (fp->fptr == 0) {		/* On the top of the file? */
    3c6a:	41 15       	cp	r20, r1
    3c6c:	51 05       	cpc	r21, r1
    3c6e:	61 05       	cpc	r22, r1
    3c70:	71 05       	cpc	r23, r1
    3c72:	c9 f4       	brne	.+50     	; 0x3ca6 <f_write+0x132>
					clst = fp->sclust;		/* Follow from the origin */
    3c74:	e8 85       	ldd	r30, Y+8	; 0x08
    3c76:	f9 85       	ldd	r31, Y+9	; 0x09
    3c78:	86 85       	ldd	r24, Z+14	; 0x0e
    3c7a:	97 85       	ldd	r25, Z+15	; 0x0f
    3c7c:	a0 89       	ldd	r26, Z+16	; 0x10
    3c7e:	b1 89       	ldd	r27, Z+17	; 0x11
					if (clst == 0)			/* When no cluster is allocated, */
    3c80:	00 97       	sbiw	r24, 0x00	; 0
    3c82:	a1 05       	cpc	r26, r1
    3c84:	b1 05       	cpc	r27, r1
    3c86:	09 f5       	brne	.+66     	; 0x3cca <f_write+0x156>
						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    3c88:	c9 01       	movw	r24, r18
    3c8a:	40 e0       	ldi	r20, 0x00	; 0
    3c8c:	50 e0       	ldi	r21, 0x00	; 0
    3c8e:	ba 01       	movw	r22, r20
    3c90:	0e 94 ab 14 	call	0x2956	; 0x2956 <create_chain>
    3c94:	dc 01       	movw	r26, r24
    3c96:	cb 01       	movw	r24, r22
    3c98:	e8 85       	ldd	r30, Y+8	; 0x08
    3c9a:	f9 85       	ldd	r31, Y+9	; 0x09
    3c9c:	86 87       	std	Z+14, r24	; 0x0e
    3c9e:	97 87       	std	Z+15, r25	; 0x0f
    3ca0:	a0 8b       	std	Z+16, r26	; 0x10
    3ca2:	b1 8b       	std	Z+17, r27	; 0x11
    3ca4:	0d c0       	rjmp	.+26     	; 0x3cc0 <f_write+0x14c>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    3ca6:	a8 85       	ldd	r26, Y+8	; 0x08
    3ca8:	b9 85       	ldd	r27, Y+9	; 0x09
    3caa:	52 96       	adiw	r26, 0x12	; 18
    3cac:	4d 91       	ld	r20, X+
    3cae:	5d 91       	ld	r21, X+
    3cb0:	6d 91       	ld	r22, X+
    3cb2:	7c 91       	ld	r23, X
    3cb4:	55 97       	sbiw	r26, 0x15	; 21
    3cb6:	c9 01       	movw	r24, r18
    3cb8:	0e 94 ab 14 	call	0x2956	; 0x2956 <create_chain>
    3cbc:	dc 01       	movw	r26, r24
    3cbe:	cb 01       	movw	r24, r22
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    3cc0:	00 97       	sbiw	r24, 0x00	; 0
    3cc2:	a1 05       	cpc	r26, r1
    3cc4:	b1 05       	cpc	r27, r1
    3cc6:	09 f4       	brne	.+2      	; 0x3cca <f_write+0x156>
    3cc8:	78 c1       	rjmp	.+752    	; 0x3fba <f_write+0x446>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    3cca:	81 30       	cpi	r24, 0x01	; 1
    3ccc:	91 05       	cpc	r25, r1
    3cce:	a1 05       	cpc	r26, r1
    3cd0:	b1 05       	cpc	r27, r1
    3cd2:	41 f4       	brne	.+16     	; 0x3ce4 <f_write+0x170>
    3cd4:	48 84       	ldd	r4, Y+8	; 0x08
    3cd6:	59 84       	ldd	r5, Y+9	; 0x09
    3cd8:	f2 01       	movw	r30, r4
    3cda:	84 81       	ldd	r24, Z+4	; 0x04
    3cdc:	80 68       	ori	r24, 0x80	; 128
    3cde:	84 83       	std	Z+4, r24	; 0x04
    3ce0:	12 e0       	ldi	r17, 0x02	; 2
    3ce2:	8c c1       	rjmp	.+792    	; 0x3ffc <f_write+0x488>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3ce4:	8f 3f       	cpi	r24, 0xFF	; 255
    3ce6:	ff ef       	ldi	r31, 0xFF	; 255
    3ce8:	9f 07       	cpc	r25, r31
    3cea:	ff ef       	ldi	r31, 0xFF	; 255
    3cec:	af 07       	cpc	r26, r31
    3cee:	ff ef       	ldi	r31, 0xFF	; 255
    3cf0:	bf 07       	cpc	r27, r31
    3cf2:	61 f4       	brne	.+24     	; 0x3d0c <f_write+0x198>
    3cf4:	48 84       	ldd	r4, Y+8	; 0x08
    3cf6:	59 84       	ldd	r5, Y+9	; 0x09
    3cf8:	d2 01       	movw	r26, r4
    3cfa:	14 96       	adiw	r26, 0x04	; 4
    3cfc:	8c 91       	ld	r24, X
    3cfe:	14 97       	sbiw	r26, 0x04	; 4
    3d00:	80 68       	ori	r24, 0x80	; 128
    3d02:	14 96       	adiw	r26, 0x04	; 4
    3d04:	8c 93       	st	X, r24
    3d06:	14 97       	sbiw	r26, 0x04	; 4
    3d08:	11 e0       	ldi	r17, 0x01	; 1
    3d0a:	78 c1       	rjmp	.+752    	; 0x3ffc <f_write+0x488>
				fp->clust = clst;			/* Update current cluster */
    3d0c:	e8 85       	ldd	r30, Y+8	; 0x08
    3d0e:	f9 85       	ldd	r31, Y+9	; 0x09
    3d10:	82 8b       	std	Z+18, r24	; 0x12
    3d12:	93 8b       	std	Z+19, r25	; 0x13
    3d14:	a4 8b       	std	Z+20, r26	; 0x14
    3d16:	b5 8b       	std	Z+21, r27	; 0x15
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
    3d18:	a8 85       	ldd	r26, Y+8	; 0x08
    3d1a:	b9 85       	ldd	r27, Y+9	; 0x09
    3d1c:	14 96       	adiw	r26, 0x04	; 4
    3d1e:	8c 91       	ld	r24, X
    3d20:	14 97       	sbiw	r26, 0x04	; 4
    3d22:	86 ff       	sbrs	r24, 6
    3d24:	21 c0       	rjmp	.+66     	; 0x3d68 <f_write+0x1f4>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3d26:	ed 91       	ld	r30, X+
    3d28:	fc 91       	ld	r31, X
    3d2a:	11 97       	sbiw	r26, 0x01	; 1
    3d2c:	56 96       	adiw	r26, 0x16	; 22
    3d2e:	2d 91       	ld	r18, X+
    3d30:	3d 91       	ld	r19, X+
    3d32:	4d 91       	ld	r20, X+
    3d34:	5c 91       	ld	r21, X
    3d36:	59 97       	sbiw	r26, 0x19	; 25
    3d38:	81 81       	ldd	r24, Z+1	; 0x01
    3d3a:	6d 81       	ldd	r22, Y+5	; 0x05
    3d3c:	7e 81       	ldd	r23, Y+6	; 0x06
    3d3e:	01 e0       	ldi	r16, 0x01	; 1
    3d40:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    3d44:	88 23       	and	r24, r24
    3d46:	41 f0       	breq	.+16     	; 0x3d58 <f_write+0x1e4>
    3d48:	48 84       	ldd	r4, Y+8	; 0x08
    3d4a:	59 84       	ldd	r5, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3d4c:	f2 01       	movw	r30, r4
    3d4e:	84 81       	ldd	r24, Z+4	; 0x04
    3d50:	80 68       	ori	r24, 0x80	; 128
    3d52:	84 83       	std	Z+4, r24	; 0x04
    3d54:	11 e0       	ldi	r17, 0x01	; 1
    3d56:	52 c1       	rjmp	.+676    	; 0x3ffc <f_write+0x488>
				fp->flag &= ~FA__DIRTY;
    3d58:	a8 85       	ldd	r26, Y+8	; 0x08
    3d5a:	b9 85       	ldd	r27, Y+9	; 0x09
    3d5c:	14 96       	adiw	r26, 0x04	; 4
    3d5e:	8c 91       	ld	r24, X
    3d60:	14 97       	sbiw	r26, 0x04	; 4
    3d62:	8f 7b       	andi	r24, 0xBF	; 191
    3d64:	14 96       	adiw	r26, 0x04	; 4
    3d66:	8c 93       	st	X, r24
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    3d68:	e8 85       	ldd	r30, Y+8	; 0x08
    3d6a:	f9 85       	ldd	r31, Y+9	; 0x09
    3d6c:	20 80       	ld	r2, Z
    3d6e:	31 80       	ldd	r3, Z+1	; 0x01
    3d70:	42 89       	ldd	r20, Z+18	; 0x12
    3d72:	53 89       	ldd	r21, Z+19	; 0x13
    3d74:	64 89       	ldd	r22, Z+20	; 0x14
    3d76:	75 89       	ldd	r23, Z+21	; 0x15
    3d78:	c1 01       	movw	r24, r2
    3d7a:	0e 94 4c 11 	call	0x2298	; 0x2298 <clust2sect>
    3d7e:	dc 01       	movw	r26, r24
    3d80:	cb 01       	movw	r24, r22
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    3d82:	00 97       	sbiw	r24, 0x00	; 0
    3d84:	a1 05       	cpc	r26, r1
    3d86:	b1 05       	cpc	r27, r1
    3d88:	61 f4       	brne	.+24     	; 0x3da2 <f_write+0x22e>
    3d8a:	48 84       	ldd	r4, Y+8	; 0x08
    3d8c:	59 84       	ldd	r5, Y+9	; 0x09
    3d8e:	d2 01       	movw	r26, r4
    3d90:	14 96       	adiw	r26, 0x04	; 4
    3d92:	8c 91       	ld	r24, X
    3d94:	14 97       	sbiw	r26, 0x04	; 4
    3d96:	80 68       	ori	r24, 0x80	; 128
    3d98:	14 96       	adiw	r26, 0x04	; 4
    3d9a:	8c 93       	st	X, r24
    3d9c:	14 97       	sbiw	r26, 0x04	; 4
    3d9e:	12 e0       	ldi	r17, 0x02	; 2
    3da0:	2d c1       	rjmp	.+602    	; 0x3ffc <f_write+0x488>
			sect += csect;
    3da2:	41 2f       	mov	r20, r17
    3da4:	50 e0       	ldi	r21, 0x00	; 0
    3da6:	60 e0       	ldi	r22, 0x00	; 0
    3da8:	70 e0       	ldi	r23, 0x00	; 0
    3daa:	2c 01       	movw	r4, r24
    3dac:	3d 01       	movw	r6, r26
    3dae:	44 0e       	add	r4, r20
    3db0:	55 1e       	adc	r5, r21
    3db2:	66 1e       	adc	r6, r22
    3db4:	77 1e       	adc	r7, r23
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    3db6:	75 01       	movw	r14, r10
    3db8:	64 01       	movw	r12, r8
    3dba:	0b 2e       	mov	r0, r27
    3dbc:	b9 e0       	ldi	r27, 0x09	; 9
    3dbe:	f6 94       	lsr	r15
    3dc0:	e7 94       	ror	r14
    3dc2:	d7 94       	ror	r13
    3dc4:	c7 94       	ror	r12
    3dc6:	ba 95       	dec	r27
    3dc8:	d1 f7       	brne	.-12     	; 0x3dbe <f_write+0x24a>
    3dca:	b0 2d       	mov	r27, r0
			if (cc) {						/* Write maximum contiguous sectors directly */
    3dcc:	c1 14       	cp	r12, r1
    3dce:	d1 04       	cpc	r13, r1
    3dd0:	e1 04       	cpc	r14, r1
    3dd2:	f1 04       	cpc	r15, r1
    3dd4:	09 f4       	brne	.+2      	; 0x3dd8 <f_write+0x264>
    3dd6:	60 c0       	rjmp	.+192    	; 0x3e98 <f_write+0x324>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    3dd8:	f1 01       	movw	r30, r2
    3dda:	22 81       	ldd	r18, Z+2	; 0x02
    3ddc:	d7 01       	movw	r26, r14
    3dde:	c6 01       	movw	r24, r12
    3de0:	84 0f       	add	r24, r20
    3de2:	95 1f       	adc	r25, r21
    3de4:	a6 1f       	adc	r26, r22
    3de6:	b7 1f       	adc	r27, r23
    3de8:	42 2f       	mov	r20, r18
    3dea:	50 e0       	ldi	r21, 0x00	; 0
    3dec:	60 e0       	ldi	r22, 0x00	; 0
    3dee:	70 e0       	ldi	r23, 0x00	; 0
    3df0:	48 17       	cp	r20, r24
    3df2:	59 07       	cpc	r21, r25
    3df4:	6a 07       	cpc	r22, r26
    3df6:	7b 07       	cpc	r23, r27
    3df8:	48 f4       	brcc	.+18     	; 0x3e0c <f_write+0x298>
					cc = fp->fs->csize - csect;
    3dfa:	82 2f       	mov	r24, r18
    3dfc:	90 e0       	ldi	r25, 0x00	; 0
    3dfe:	81 1b       	sub	r24, r17
    3e00:	91 09       	sbc	r25, r1
    3e02:	6c 01       	movw	r12, r24
    3e04:	ee 24       	eor	r14, r14
    3e06:	d7 fc       	sbrc	r13, 7
    3e08:	e0 94       	com	r14
    3e0a:	fe 2c       	mov	r15, r14
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
    3e0c:	d1 01       	movw	r26, r2
    3e0e:	11 96       	adiw	r26, 0x01	; 1
    3e10:	8c 91       	ld	r24, X
    3e12:	6b 81       	ldd	r22, Y+3	; 0x03
    3e14:	7c 81       	ldd	r23, Y+4	; 0x04
    3e16:	a3 01       	movw	r20, r6
    3e18:	92 01       	movw	r18, r4
    3e1a:	0c 2d       	mov	r16, r12
    3e1c:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    3e20:	88 23       	and	r24, r24
    3e22:	41 f0       	breq	.+16     	; 0x3e34 <f_write+0x2c0>
    3e24:	48 84       	ldd	r4, Y+8	; 0x08
    3e26:	59 84       	ldd	r5, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3e28:	f2 01       	movw	r30, r4
    3e2a:	84 81       	ldd	r24, Z+4	; 0x04
    3e2c:	80 68       	ori	r24, 0x80	; 128
    3e2e:	84 83       	std	Z+4, r24	; 0x04
    3e30:	11 e0       	ldi	r17, 0x01	; 1
    3e32:	e4 c0       	rjmp	.+456    	; 0x3ffc <f_write+0x488>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
    3e34:	e8 85       	ldd	r30, Y+8	; 0x08
    3e36:	f9 85       	ldd	r31, Y+9	; 0x09
    3e38:	86 89       	ldd	r24, Z+22	; 0x16
    3e3a:	97 89       	ldd	r25, Z+23	; 0x17
    3e3c:	a0 8d       	ldd	r26, Z+24	; 0x18
    3e3e:	b1 8d       	ldd	r27, Z+25	; 0x19
    3e40:	84 19       	sub	r24, r4
    3e42:	95 09       	sbc	r25, r5
    3e44:	a6 09       	sbc	r26, r6
    3e46:	b7 09       	sbc	r27, r7
    3e48:	8c 15       	cp	r24, r12
    3e4a:	9d 05       	cpc	r25, r13
    3e4c:	ae 05       	cpc	r26, r14
    3e4e:	bf 05       	cpc	r27, r15
    3e50:	c8 f4       	brcc	.+50     	; 0x3e84 <f_write+0x310>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
    3e52:	bc 01       	movw	r22, r24
    3e54:	76 2f       	mov	r23, r22
    3e56:	66 27       	eor	r22, r22
    3e58:	77 0f       	add	r23, r23
    3e5a:	0b 81       	ldd	r16, Y+3	; 0x03
    3e5c:	1c 81       	ldd	r17, Y+4	; 0x04
    3e5e:	60 0f       	add	r22, r16
    3e60:	71 1f       	adc	r23, r17
    3e62:	8d 81       	ldd	r24, Y+5	; 0x05
    3e64:	9e 81       	ldd	r25, Y+6	; 0x06
    3e66:	20 e0       	ldi	r18, 0x00	; 0
    3e68:	32 e0       	ldi	r19, 0x02	; 2
    3e6a:	40 e0       	ldi	r20, 0x00	; 0
    3e6c:	50 e0       	ldi	r21, 0x00	; 0
    3e6e:	0e 94 42 0a 	call	0x1484	; 0x1484 <mem_cpy>
					fp->flag &= ~FA__DIRTY;
    3e72:	a8 85       	ldd	r26, Y+8	; 0x08
    3e74:	b9 85       	ldd	r27, Y+9	; 0x09
    3e76:	14 96       	adiw	r26, 0x04	; 4
    3e78:	8c 91       	ld	r24, X
    3e7a:	14 97       	sbiw	r26, 0x04	; 4
    3e7c:	8f 7b       	andi	r24, 0xBF	; 191
    3e7e:	14 96       	adiw	r26, 0x04	; 4
    3e80:	8c 93       	st	X, r24
    3e82:	14 97       	sbiw	r26, 0x04	; 4
				}
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    3e84:	0b 2e       	mov	r0, r27
    3e86:	b9 e0       	ldi	r27, 0x09	; 9
    3e88:	cc 0c       	add	r12, r12
    3e8a:	dd 1c       	adc	r13, r13
    3e8c:	ee 1c       	adc	r14, r14
    3e8e:	ff 1c       	adc	r15, r15
    3e90:	ba 95       	dec	r27
    3e92:	d1 f7       	brne	.-12     	; 0x3e88 <f_write+0x314>
    3e94:	b0 2d       	mov	r27, r0
				continue;
    3e96:	65 c0       	rjmp	.+202    	; 0x3f62 <f_write+0x3ee>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
    3e98:	e8 85       	ldd	r30, Y+8	; 0x08
    3e9a:	f9 85       	ldd	r31, Y+9	; 0x09
    3e9c:	86 89       	ldd	r24, Z+22	; 0x16
    3e9e:	97 89       	ldd	r25, Z+23	; 0x17
    3ea0:	a0 8d       	ldd	r26, Z+24	; 0x18
    3ea2:	b1 8d       	ldd	r27, Z+25	; 0x19
    3ea4:	84 15       	cp	r24, r4
    3ea6:	95 05       	cpc	r25, r5
    3ea8:	a6 05       	cpc	r26, r6
    3eaa:	b7 05       	cpc	r27, r7
    3eac:	09 f1       	breq	.+66     	; 0x3ef0 <f_write+0x37c>
				if (fp->fptr < fp->fsize &&
    3eae:	86 81       	ldd	r24, Z+6	; 0x06
    3eb0:	97 81       	ldd	r25, Z+7	; 0x07
    3eb2:	a0 85       	ldd	r26, Z+8	; 0x08
    3eb4:	b1 85       	ldd	r27, Z+9	; 0x09
    3eb6:	42 85       	ldd	r20, Z+10	; 0x0a
    3eb8:	53 85       	ldd	r21, Z+11	; 0x0b
    3eba:	64 85       	ldd	r22, Z+12	; 0x0c
    3ebc:	75 85       	ldd	r23, Z+13	; 0x0d
    3ebe:	84 17       	cp	r24, r20
    3ec0:	95 07       	cpc	r25, r21
    3ec2:	a6 07       	cpc	r26, r22
    3ec4:	b7 07       	cpc	r27, r23
    3ec6:	a0 f4       	brcc	.+40     	; 0x3ef0 <f_write+0x37c>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    3ec8:	d1 01       	movw	r26, r2
    3eca:	11 96       	adiw	r26, 0x01	; 1
    3ecc:	8c 91       	ld	r24, X
    3ece:	6d 81       	ldd	r22, Y+5	; 0x05
    3ed0:	7e 81       	ldd	r23, Y+6	; 0x06
    3ed2:	a3 01       	movw	r20, r6
    3ed4:	92 01       	movw	r18, r4
    3ed6:	01 e0       	ldi	r16, 0x01	; 1
    3ed8:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
    3edc:	88 23       	and	r24, r24
    3ede:	41 f0       	breq	.+16     	; 0x3ef0 <f_write+0x37c>
    3ee0:	48 84       	ldd	r4, Y+8	; 0x08
    3ee2:	59 84       	ldd	r5, Y+9	; 0x09
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
    3ee4:	f2 01       	movw	r30, r4
    3ee6:	84 81       	ldd	r24, Z+4	; 0x04
    3ee8:	80 68       	ori	r24, 0x80	; 128
    3eea:	84 83       	std	Z+4, r24	; 0x04
    3eec:	11 e0       	ldi	r17, 0x01	; 1
    3eee:	86 c0       	rjmp	.+268    	; 0x3ffc <f_write+0x488>
			}
#endif
			fp->dsect = sect;
    3ef0:	a8 85       	ldd	r26, Y+8	; 0x08
    3ef2:	b9 85       	ldd	r27, Y+9	; 0x09
    3ef4:	56 96       	adiw	r26, 0x16	; 22
    3ef6:	4d 92       	st	X+, r4
    3ef8:	5d 92       	st	X+, r5
    3efa:	6d 92       	st	X+, r6
    3efc:	7c 92       	st	X, r7
    3efe:	59 97       	sbiw	r26, 0x19	; 25
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    3f00:	e8 85       	ldd	r30, Y+8	; 0x08
    3f02:	f9 85       	ldd	r31, Y+9	; 0x09
    3f04:	46 81       	ldd	r20, Z+6	; 0x06
    3f06:	57 81       	ldd	r21, Z+7	; 0x07
    3f08:	60 85       	ldd	r22, Z+8	; 0x08
    3f0a:	71 85       	ldd	r23, Z+9	; 0x09
    3f0c:	db 01       	movw	r26, r22
    3f0e:	ca 01       	movw	r24, r20
    3f10:	91 70       	andi	r25, 0x01	; 1
    3f12:	a0 70       	andi	r26, 0x00	; 0
    3f14:	b0 70       	andi	r27, 0x00	; 0
    3f16:	00 e0       	ldi	r16, 0x00	; 0
    3f18:	12 e0       	ldi	r17, 0x02	; 2
    3f1a:	20 e0       	ldi	r18, 0x00	; 0
    3f1c:	30 e0       	ldi	r19, 0x00	; 0
    3f1e:	08 1b       	sub	r16, r24
    3f20:	19 0b       	sbc	r17, r25
    3f22:	2a 0b       	sbc	r18, r26
    3f24:	3b 0b       	sbc	r19, r27
    3f26:	75 01       	movw	r14, r10
    3f28:	64 01       	movw	r12, r8
    3f2a:	08 15       	cp	r16, r8
    3f2c:	19 05       	cpc	r17, r9
    3f2e:	2a 05       	cpc	r18, r10
    3f30:	3b 05       	cpc	r19, r11
    3f32:	10 f4       	brcc	.+4      	; 0x3f38 <f_write+0x3c4>
    3f34:	68 01       	movw	r12, r16
    3f36:	79 01       	movw	r14, r18
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    3f38:	ca 01       	movw	r24, r20
    3f3a:	91 70       	andi	r25, 0x01	; 1
    3f3c:	80 96       	adiw	r24, 0x20	; 32
    3f3e:	28 85       	ldd	r18, Y+8	; 0x08
    3f40:	39 85       	ldd	r19, Y+9	; 0x09
    3f42:	82 0f       	add	r24, r18
    3f44:	93 1f       	adc	r25, r19
    3f46:	6b 81       	ldd	r22, Y+3	; 0x03
    3f48:	7c 81       	ldd	r23, Y+4	; 0x04
    3f4a:	a7 01       	movw	r20, r14
    3f4c:	96 01       	movw	r18, r12
    3f4e:	0e 94 42 0a 	call	0x1484	; 0x1484 <mem_cpy>
		fp->flag |= FA__DIRTY;
    3f52:	a8 85       	ldd	r26, Y+8	; 0x08
    3f54:	b9 85       	ldd	r27, Y+9	; 0x09
    3f56:	14 96       	adiw	r26, 0x04	; 4
    3f58:	8c 91       	ld	r24, X
    3f5a:	14 97       	sbiw	r26, 0x04	; 4
    3f5c:	80 64       	ori	r24, 0x40	; 64
    3f5e:	14 96       	adiw	r26, 0x04	; 4
    3f60:	8c 93       	st	X, r24
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    3f62:	eb 81       	ldd	r30, Y+3	; 0x03
    3f64:	fc 81       	ldd	r31, Y+4	; 0x04
    3f66:	ec 0d       	add	r30, r12
    3f68:	fd 1d       	adc	r31, r13
    3f6a:	fc 83       	std	Y+4, r31	; 0x04
    3f6c:	eb 83       	std	Y+3, r30	; 0x03
    3f6e:	e8 85       	ldd	r30, Y+8	; 0x08
    3f70:	f9 85       	ldd	r31, Y+9	; 0x09
    3f72:	86 81       	ldd	r24, Z+6	; 0x06
    3f74:	97 81       	ldd	r25, Z+7	; 0x07
    3f76:	a0 85       	ldd	r26, Z+8	; 0x08
    3f78:	b1 85       	ldd	r27, Z+9	; 0x09
    3f7a:	8c 0d       	add	r24, r12
    3f7c:	9d 1d       	adc	r25, r13
    3f7e:	ae 1d       	adc	r26, r14
    3f80:	bf 1d       	adc	r27, r15
    3f82:	86 83       	std	Z+6, r24	; 0x06
    3f84:	97 83       	std	Z+7, r25	; 0x07
    3f86:	a0 87       	std	Z+8, r26	; 0x08
    3f88:	b1 87       	std	Z+9, r27	; 0x09
    3f8a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f8c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f8e:	80 81       	ld	r24, Z
    3f90:	91 81       	ldd	r25, Z+1	; 0x01
    3f92:	a2 81       	ldd	r26, Z+2	; 0x02
    3f94:	b3 81       	ldd	r27, Z+3	; 0x03
    3f96:	8c 0d       	add	r24, r12
    3f98:	9d 1d       	adc	r25, r13
    3f9a:	ae 1d       	adc	r26, r14
    3f9c:	bf 1d       	adc	r27, r15
    3f9e:	80 83       	st	Z, r24
    3fa0:	91 83       	std	Z+1, r25	; 0x01
    3fa2:	a2 83       	std	Z+2, r26	; 0x02
    3fa4:	b3 83       	std	Z+3, r27	; 0x03
    3fa6:	8c 18       	sub	r8, r12
    3fa8:	9d 08       	sbc	r9, r13
    3faa:	ae 08       	sbc	r10, r14
    3fac:	bf 08       	sbc	r11, r15
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
    3fae:	09 f0       	breq	.+2      	; 0x3fb2 <f_write+0x43e>
    3fb0:	35 ce       	rjmp	.-918    	; 0x3c1c <f_write+0xa8>
    3fb2:	1f 81       	ldd	r17, Y+7	; 0x07
    3fb4:	48 84       	ldd	r4, Y+8	; 0x08
    3fb6:	59 84       	ldd	r5, Y+9	; 0x09
    3fb8:	03 c0       	rjmp	.+6      	; 0x3fc0 <f_write+0x44c>
    3fba:	1f 81       	ldd	r17, Y+7	; 0x07
    3fbc:	48 84       	ldd	r4, Y+8	; 0x08
    3fbe:	59 84       	ldd	r5, Y+9	; 0x09
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    3fc0:	f2 01       	movw	r30, r4
    3fc2:	86 81       	ldd	r24, Z+6	; 0x06
    3fc4:	97 81       	ldd	r25, Z+7	; 0x07
    3fc6:	a0 85       	ldd	r26, Z+8	; 0x08
    3fc8:	b1 85       	ldd	r27, Z+9	; 0x09
    3fca:	42 85       	ldd	r20, Z+10	; 0x0a
    3fcc:	53 85       	ldd	r21, Z+11	; 0x0b
    3fce:	64 85       	ldd	r22, Z+12	; 0x0c
    3fd0:	75 85       	ldd	r23, Z+13	; 0x0d
    3fd2:	48 17       	cp	r20, r24
    3fd4:	59 07       	cpc	r21, r25
    3fd6:	6a 07       	cpc	r22, r26
    3fd8:	7b 07       	cpc	r23, r27
    3fda:	20 f4       	brcc	.+8      	; 0x3fe4 <f_write+0x470>
    3fdc:	82 87       	std	Z+10, r24	; 0x0a
    3fde:	93 87       	std	Z+11, r25	; 0x0b
    3fe0:	a4 87       	std	Z+12, r26	; 0x0c
    3fe2:	b5 87       	std	Z+13, r27	; 0x0d
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    3fe4:	d2 01       	movw	r26, r4
    3fe6:	14 96       	adiw	r26, 0x04	; 4
    3fe8:	8c 91       	ld	r24, X
    3fea:	14 97       	sbiw	r26, 0x04	; 4
    3fec:	80 62       	ori	r24, 0x20	; 32
    3fee:	14 96       	adiw	r26, 0x04	; 4
    3ff0:	8c 93       	st	X, r24
    3ff2:	14 97       	sbiw	r26, 0x04	; 4

	LEAVE_FF(fp->fs, FR_OK);
    3ff4:	03 c0       	rjmp	.+6      	; 0x3ffc <f_write+0x488>
	*bw = 0;	/* Clear write byte counter */

	res = validate(fp);						/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)				/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    3ff6:	12 e0       	ldi	r17, 0x02	; 2
    3ff8:	01 c0       	rjmp	.+2      	; 0x3ffc <f_write+0x488>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    3ffa:	17 e0       	ldi	r17, 0x07	; 7

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
    3ffc:	81 2f       	mov	r24, r17
    3ffe:	29 96       	adiw	r28, 0x09	; 9
    4000:	0f b6       	in	r0, 0x3f	; 63
    4002:	f8 94       	cli
    4004:	de bf       	out	0x3e, r29	; 62
    4006:	0f be       	out	0x3f, r0	; 63
    4008:	cd bf       	out	0x3d, r28	; 61
    400a:	df 91       	pop	r29
    400c:	cf 91       	pop	r28
    400e:	1f 91       	pop	r17
    4010:	0f 91       	pop	r16
    4012:	ff 90       	pop	r15
    4014:	ef 90       	pop	r14
    4016:	df 90       	pop	r13
    4018:	cf 90       	pop	r12
    401a:	bf 90       	pop	r11
    401c:	af 90       	pop	r10
    401e:	9f 90       	pop	r9
    4020:	8f 90       	pop	r8
    4022:	7f 90       	pop	r7
    4024:	6f 90       	pop	r6
    4026:	5f 90       	pop	r5
    4028:	4f 90       	pop	r4
    402a:	3f 90       	pop	r3
    402c:	2f 90       	pop	r2
    402e:	08 95       	ret

00004030 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
    4030:	0f 93       	push	r16
    4032:	1f 93       	push	r17
    4034:	cf 93       	push	r28
    4036:	df 93       	push	r29
    4038:	ec 01       	movw	r28, r24
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
    403a:	0e 94 28 0b 	call	0x1650	; 0x1650 <validate>
	if (res == FR_OK) {
    403e:	88 23       	and	r24, r24
    4040:	09 f0       	breq	.+2      	; 0x4044 <f_sync+0x14>
    4042:	4c c0       	rjmp	.+152    	; 0x40dc <f_sync+0xac>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    4044:	9c 81       	ldd	r25, Y+4	; 0x04
    4046:	95 ff       	sbrs	r25, 5
    4048:	49 c0       	rjmp	.+146    	; 0x40dc <f_sync+0xac>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
    404a:	96 ff       	sbrs	r25, 6
    404c:	12 c0       	rjmp	.+36     	; 0x4072 <f_sync+0x42>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    404e:	e8 81       	ld	r30, Y
    4050:	f9 81       	ldd	r31, Y+1	; 0x01
    4052:	be 01       	movw	r22, r28
    4054:	60 5e       	subi	r22, 0xE0	; 224
    4056:	7f 4f       	sbci	r23, 0xFF	; 255
    4058:	2e 89       	ldd	r18, Y+22	; 0x16
    405a:	3f 89       	ldd	r19, Y+23	; 0x17
    405c:	48 8d       	ldd	r20, Y+24	; 0x18
    405e:	59 8d       	ldd	r21, Y+25	; 0x19
    4060:	81 81       	ldd	r24, Z+1	; 0x01
    4062:	01 e0       	ldi	r16, 0x01	; 1
    4064:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    4068:	88 23       	and	r24, r24
    406a:	b9 f5       	brne	.+110    	; 0x40da <f_sync+0xaa>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
    406c:	8c 81       	ldd	r24, Y+4	; 0x04
    406e:	8f 7b       	andi	r24, 0xBF	; 191
    4070:	8c 83       	std	Y+4, r24	; 0x04
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
    4072:	4a 8d       	ldd	r20, Y+26	; 0x1a
    4074:	5b 8d       	ldd	r21, Y+27	; 0x1b
    4076:	6c 8d       	ldd	r22, Y+28	; 0x1c
    4078:	7d 8d       	ldd	r23, Y+29	; 0x1d
    407a:	88 81       	ld	r24, Y
    407c:	99 81       	ldd	r25, Y+1	; 0x01
    407e:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
			if (res == FR_OK) {
    4082:	88 23       	and	r24, r24
    4084:	59 f5       	brne	.+86     	; 0x40dc <f_sync+0xac>
				dir = fp->dir_ptr;
    4086:	0e 8d       	ldd	r16, Y+30	; 0x1e
    4088:	1f 8d       	ldd	r17, Y+31	; 0x1f
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    408a:	f8 01       	movw	r30, r16
    408c:	83 85       	ldd	r24, Z+11	; 0x0b
    408e:	80 62       	ori	r24, 0x20	; 32
    4090:	83 87       	std	Z+11, r24	; 0x0b
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    4092:	8a 85       	ldd	r24, Y+10	; 0x0a
    4094:	84 8f       	std	Z+28, r24	; 0x1c
    4096:	8b 85       	ldd	r24, Y+11	; 0x0b
    4098:	85 8f       	std	Z+29, r24	; 0x1d
    409a:	8c 85       	ldd	r24, Y+12	; 0x0c
    409c:	86 8f       	std	Z+30, r24	; 0x1e
    409e:	8d 85       	ldd	r24, Y+13	; 0x0d
    40a0:	87 8f       	std	Z+31, r24	; 0x1f
				st_clust(dir, fp->sclust);					/* Update start cluster */
    40a2:	4e 85       	ldd	r20, Y+14	; 0x0e
    40a4:	5f 85       	ldd	r21, Y+15	; 0x0f
    40a6:	68 89       	ldd	r22, Y+16	; 0x10
    40a8:	79 89       	ldd	r23, Y+17	; 0x11
    40aa:	c8 01       	movw	r24, r16
    40ac:	0e 94 8d 0a 	call	0x151a	; 0x151a <st_clust>
				tim = get_fattime();						/* Update updated time */
    40b0:	0e 94 48 11 	call	0x2290	; 0x2290 <get_fattime>
				ST_DWORD(dir+DIR_WrtTime, tim);
    40b4:	f8 01       	movw	r30, r16
    40b6:	66 8b       	std	Z+22, r22	; 0x16
    40b8:	77 8b       	std	Z+23, r23	; 0x17
    40ba:	80 8f       	std	Z+24, r24	; 0x18
    40bc:	91 8f       	std	Z+25, r25	; 0x19
				ST_WORD(dir+DIR_LstAccDate, 0);
    40be:	12 8a       	std	Z+18, r1	; 0x12
    40c0:	13 8a       	std	Z+19, r1	; 0x13
				fp->flag &= ~FA__WRITTEN;
    40c2:	8c 81       	ldd	r24, Y+4	; 0x04
    40c4:	8f 7d       	andi	r24, 0xDF	; 223
    40c6:	8c 83       	std	Y+4, r24	; 0x04
				fp->fs->wflag = 1;
    40c8:	e8 81       	ld	r30, Y
    40ca:	f9 81       	ldd	r31, Y+1	; 0x01
    40cc:	81 e0       	ldi	r24, 0x01	; 1
    40ce:	84 83       	std	Z+4, r24	; 0x04
				res = sync(fp->fs);
    40d0:	88 81       	ld	r24, Y
    40d2:	99 81       	ldd	r25, Y+1	; 0x01
    40d4:	0e 94 ba 10 	call	0x2174	; 0x2174 <sync>
    40d8:	01 c0       	rjmp	.+2      	; 0x40dc <f_sync+0xac>
	if (res == FR_OK) {
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
    40da:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
    40dc:	df 91       	pop	r29
    40de:	cf 91       	pop	r28
    40e0:	1f 91       	pop	r17
    40e2:	0f 91       	pop	r16
    40e4:	08 95       	ret

000040e6 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    40e6:	cf 93       	push	r28
    40e8:	df 93       	push	r29
    40ea:	ec 01       	movw	r28, r24
#endif
		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
		LEAVE_FF(fs, res);
	}
#else
	res = f_sync(fp);		/* Flush cached data */
    40ec:	0e 94 18 20 	call	0x4030	; 0x4030 <f_sync>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    40f0:	88 23       	and	r24, r24
    40f2:	11 f4       	brne	.+4      	; 0x40f8 <f_close+0x12>
    40f4:	19 82       	std	Y+1, r1	; 0x01
    40f6:	18 82       	st	Y, r1
	return res;
#endif
}
    40f8:	df 91       	pop	r29
    40fa:	cf 91       	pop	r28
    40fc:	08 95       	ret

000040fe <f_chdrive>:

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
    40fe:	88 23       	and	r24, r24
    4100:	19 f4       	brne	.+6      	; 0x4108 <f_chdrive+0xa>

	CurrVol = drv;
    4102:	10 92 25 04 	sts	0x0425, r1

	return FR_OK;
    4106:	08 95       	ret

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
    4108:	8b e0       	ldi	r24, 0x0B	; 11

	CurrVol = drv;

	return FR_OK;
}
    410a:	08 95       	ret

0000410c <f_chdir>:


FRESULT f_chdir (
	const TCHAR *path	/* Pointer to the directory path */
)
{
    410c:	ef 92       	push	r14
    410e:	ff 92       	push	r15
    4110:	1f 93       	push	r17
    4112:	cf 93       	push	r28
    4114:	df 93       	push	r29
    4116:	cd b7       	in	r28, 0x3d	; 61
    4118:	de b7       	in	r29, 0x3e	; 62
    411a:	a4 97       	sbiw	r28, 0x24	; 36
    411c:	0f b6       	in	r0, 0x3f	; 63
    411e:	f8 94       	cli
    4120:	de bf       	out	0x3e, r29	; 62
    4122:	0f be       	out	0x3f, r0	; 63
    4124:	cd bf       	out	0x3d, r28	; 61
    4126:	9c a3       	lds	r25, 0x5c
    4128:	8b a3       	lds	r24, 0x5b
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
    412a:	ce 01       	movw	r24, r28
    412c:	83 96       	adiw	r24, 0x23	; 35
    412e:	be 01       	movw	r22, r28
    4130:	6f 5f       	subi	r22, 0xFF	; 255
    4132:	7f 4f       	sbci	r23, 0xFF	; 255
    4134:	40 e0       	ldi	r20, 0x00	; 0
    4136:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <chk_mounted>
    413a:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    413c:	88 23       	and	r24, r24
    413e:	81 f5       	brne	.+96     	; 0x41a0 <f_chdir+0x94>
		INIT_BUF(dj);
    4140:	ce 01       	movw	r24, r28
    4142:	47 96       	adiw	r24, 0x17	; 23
    4144:	9e 8b       	std	Y+22, r25	; 0x16
    4146:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the path */
    4148:	6b a1       	lds	r22, 0x4b
    414a:	7c a1       	lds	r23, 0x4c
    414c:	ce 01       	movw	r24, r28
    414e:	01 96       	adiw	r24, 0x01	; 1
    4150:	0e 94 14 17 	call	0x2e28	; 0x2e28 <follow_path>
    4154:	18 2f       	mov	r17, r24
		FREE_BUF();
		if (res == FR_OK) {					/* Follow completed */
    4156:	88 23       	and	r24, r24
    4158:	01 f5       	brne	.+64     	; 0x419a <f_chdir+0x8e>
			if (!dj.dir) {
    415a:	eb 89       	ldd	r30, Y+19	; 0x13
    415c:	fc 89       	ldd	r31, Y+20	; 0x14
    415e:	30 97       	sbiw	r30, 0x00	; 0
    4160:	59 f4       	brne	.+22     	; 0x4178 <f_chdir+0x6c>
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
    4162:	e9 81       	ldd	r30, Y+1	; 0x01
    4164:	fa 81       	ldd	r31, Y+2	; 0x02
    4166:	8f 81       	ldd	r24, Y+7	; 0x07
    4168:	98 85       	ldd	r25, Y+8	; 0x08
    416a:	a9 85       	ldd	r26, Y+9	; 0x09
    416c:	ba 85       	ldd	r27, Y+10	; 0x0a
    416e:	86 8b       	std	Z+22, r24	; 0x16
    4170:	97 8b       	std	Z+23, r25	; 0x17
    4172:	a0 8f       	std	Z+24, r26	; 0x18
    4174:	b1 8f       	std	Z+25, r27	; 0x19
    4176:	14 c0       	rjmp	.+40     	; 0x41a0 <f_chdir+0x94>
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
    4178:	83 85       	ldd	r24, Z+11	; 0x0b
    417a:	84 ff       	sbrs	r24, 4
    417c:	1e c0       	rjmp	.+60     	; 0x41ba <f_chdir+0xae>
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
    417e:	e9 80       	ldd	r14, Y+1	; 0x01
    4180:	fa 80       	ldd	r15, Y+2	; 0x02
    4182:	c7 01       	movw	r24, r14
    4184:	bf 01       	movw	r22, r30
    4186:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <ld_clust>
    418a:	dc 01       	movw	r26, r24
    418c:	cb 01       	movw	r24, r22
    418e:	f7 01       	movw	r30, r14
    4190:	86 8b       	std	Z+22, r24	; 0x16
    4192:	97 8b       	std	Z+23, r25	; 0x17
    4194:	a0 8f       	std	Z+24, r26	; 0x18
    4196:	b1 8f       	std	Z+25, r27	; 0x19
    4198:	03 c0       	rjmp	.+6      	; 0x41a0 <f_chdir+0x94>
				else
					res = FR_NO_PATH;		/* Reached but a file */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    419a:	84 30       	cpi	r24, 0x04	; 4
    419c:	09 f4       	brne	.+2      	; 0x41a0 <f_chdir+0x94>
    419e:	15 e0       	ldi	r17, 0x05	; 5
	}

	LEAVE_FF(dj.fs, res);
}
    41a0:	81 2f       	mov	r24, r17
    41a2:	a4 96       	adiw	r28, 0x24	; 36
    41a4:	0f b6       	in	r0, 0x3f	; 63
    41a6:	f8 94       	cli
    41a8:	de bf       	out	0x3e, r29	; 62
    41aa:	0f be       	out	0x3f, r0	; 63
    41ac:	cd bf       	out	0x3d, r28	; 61
    41ae:	df 91       	pop	r29
    41b0:	cf 91       	pop	r28
    41b2:	1f 91       	pop	r17
    41b4:	ff 90       	pop	r15
    41b6:	ef 90       	pop	r14
    41b8:	08 95       	ret
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
				else
					res = FR_NO_PATH;		/* Reached but a file */
    41ba:	15 e0       	ldi	r17, 0x05	; 5
    41bc:	f1 cf       	rjmp	.-30     	; 0x41a0 <f_chdir+0x94>

000041be <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
    41be:	2f 92       	push	r2
    41c0:	3f 92       	push	r3
    41c2:	4f 92       	push	r4
    41c4:	5f 92       	push	r5
    41c6:	6f 92       	push	r6
    41c8:	7f 92       	push	r7
    41ca:	8f 92       	push	r8
    41cc:	9f 92       	push	r9
    41ce:	af 92       	push	r10
    41d0:	bf 92       	push	r11
    41d2:	cf 92       	push	r12
    41d4:	df 92       	push	r13
    41d6:	ef 92       	push	r14
    41d8:	ff 92       	push	r15
    41da:	0f 93       	push	r16
    41dc:	1f 93       	push	r17
    41de:	cf 93       	push	r28
    41e0:	df 93       	push	r29
    41e2:	00 d0       	rcall	.+0      	; 0x41e4 <f_lseek+0x26>
    41e4:	00 d0       	rcall	.+0      	; 0x41e6 <f_lseek+0x28>
    41e6:	00 d0       	rcall	.+0      	; 0x41e8 <f_lseek+0x2a>
    41e8:	cd b7       	in	r28, 0x3d	; 61
    41ea:	de b7       	in	r29, 0x3e	; 62
    41ec:	9e 83       	std	Y+6, r25	; 0x06
    41ee:	8d 83       	std	Y+5, r24	; 0x05
    41f0:	6a 01       	movw	r12, r20
    41f2:	7b 01       	movw	r14, r22
	FRESULT res;


	res = validate(fp);					/* Check validity of the object */
    41f4:	0e 94 28 0b 	call	0x1650	; 0x1650 <validate>
    41f8:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    41fa:	88 23       	and	r24, r24
    41fc:	09 f0       	breq	.+2      	; 0x4200 <f_lseek+0x42>
    41fe:	e6 c1       	rjmp	.+972    	; 0x45cc <f_lseek+0x40e>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
    4200:	ad 81       	ldd	r26, Y+5	; 0x05
    4202:	be 81       	ldd	r27, Y+6	; 0x06
    4204:	14 96       	adiw	r26, 0x04	; 4
    4206:	2c 91       	ld	r18, X
    4208:	14 97       	sbiw	r26, 0x04	; 4
    420a:	22 23       	and	r18, r18
    420c:	0c f4       	brge	.+2      	; 0x4210 <f_lseek+0x52>
    420e:	dd c1       	rjmp	.+954    	; 0x45ca <f_lseek+0x40c>

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    4210:	1a 96       	adiw	r26, 0x0a	; 10
    4212:	8d 91       	ld	r24, X+
    4214:	9d 91       	ld	r25, X+
    4216:	0d 90       	ld	r0, X+
    4218:	bc 91       	ld	r27, X
    421a:	a0 2d       	mov	r26, r0
    421c:	8c 15       	cp	r24, r12
    421e:	9d 05       	cpc	r25, r13
    4220:	ae 05       	cpc	r26, r14
    4222:	bf 05       	cpc	r27, r15
    4224:	20 f4       	brcc	.+8      	; 0x422e <f_lseek+0x70>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
    4226:	21 fd       	sbrc	r18, 1
    4228:	02 c0       	rjmp	.+4      	; 0x422e <f_lseek+0x70>
#endif
			) ofs = fp->fsize;
    422a:	6c 01       	movw	r12, r24
    422c:	7d 01       	movw	r14, r26

		ifptr = fp->fptr;
    422e:	ed 81       	ldd	r30, Y+5	; 0x05
    4230:	fe 81       	ldd	r31, Y+6	; 0x06
    4232:	46 81       	ldd	r20, Z+6	; 0x06
    4234:	57 81       	ldd	r21, Z+7	; 0x07
    4236:	60 85       	ldd	r22, Z+8	; 0x08
    4238:	71 85       	ldd	r23, Z+9	; 0x09
		fp->fptr = nsect = 0;
    423a:	16 82       	std	Z+6, r1	; 0x06
    423c:	17 82       	std	Z+7, r1	; 0x07
    423e:	10 86       	std	Z+8, r1	; 0x08
    4240:	11 86       	std	Z+9, r1	; 0x09
		if (ofs) {
    4242:	c1 14       	cp	r12, r1
    4244:	d1 04       	cpc	r13, r1
    4246:	e1 04       	cpc	r14, r1
    4248:	f1 04       	cpc	r15, r1
    424a:	09 f4       	brne	.+2      	; 0x424e <f_lseek+0x90>
    424c:	bf c1       	rjmp	.+894    	; 0x45cc <f_lseek+0x40e>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    424e:	20 80       	ld	r2, Z
    4250:	31 80       	ldd	r3, Z+1	; 0x01
    4252:	f1 01       	movw	r30, r2
    4254:	82 81       	ldd	r24, Z+2	; 0x02
    4256:	90 e0       	ldi	r25, 0x00	; 0
    4258:	a0 e0       	ldi	r26, 0x00	; 0
    425a:	b0 e0       	ldi	r27, 0x00	; 0
    425c:	4c 01       	movw	r8, r24
    425e:	5d 01       	movw	r10, r26
    4260:	07 2e       	mov	r0, r23
    4262:	79 e0       	ldi	r23, 0x09	; 9
    4264:	88 0c       	add	r8, r8
    4266:	99 1c       	adc	r9, r9
    4268:	aa 1c       	adc	r10, r10
    426a:	bb 1c       	adc	r11, r11
    426c:	7a 95       	dec	r23
    426e:	d1 f7       	brne	.-12     	; 0x4264 <f_lseek+0xa6>
    4270:	70 2d       	mov	r23, r0
			if (ifptr > 0 &&
    4272:	41 15       	cp	r20, r1
    4274:	51 05       	cpc	r21, r1
    4276:	61 05       	cpc	r22, r1
    4278:	71 05       	cpc	r23, r1
    427a:	f1 f1       	breq	.+124    	; 0x42f8 <f_lseek+0x13a>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
    427c:	2a 01       	movw	r4, r20
    427e:	3b 01       	movw	r6, r22
    4280:	08 94       	sec
    4282:	41 08       	sbc	r4, r1
    4284:	51 08       	sbc	r5, r1
    4286:	61 08       	sbc	r6, r1
    4288:	71 08       	sbc	r7, r1
    428a:	c7 01       	movw	r24, r14
    428c:	b6 01       	movw	r22, r12
    428e:	61 50       	subi	r22, 0x01	; 1
    4290:	70 40       	sbci	r23, 0x00	; 0
    4292:	80 40       	sbci	r24, 0x00	; 0
    4294:	90 40       	sbci	r25, 0x00	; 0
    4296:	a5 01       	movw	r20, r10
    4298:	94 01       	movw	r18, r8
    429a:	0e 94 45 2b 	call	0x568a	; 0x568a <__udivmodsi4>
    429e:	29 83       	std	Y+1, r18	; 0x01
    42a0:	3a 83       	std	Y+2, r19	; 0x02
    42a2:	4b 83       	std	Y+3, r20	; 0x03
    42a4:	5c 83       	std	Y+4, r21	; 0x04
    42a6:	c3 01       	movw	r24, r6
    42a8:	b2 01       	movw	r22, r4
    42aa:	a5 01       	movw	r20, r10
    42ac:	94 01       	movw	r18, r8
    42ae:	0e 94 45 2b 	call	0x568a	; 0x568a <__udivmodsi4>

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
    42b2:	89 81       	ldd	r24, Y+1	; 0x01
    42b4:	9a 81       	ldd	r25, Y+2	; 0x02
    42b6:	ab 81       	ldd	r26, Y+3	; 0x03
    42b8:	bc 81       	ldd	r27, Y+4	; 0x04
    42ba:	82 17       	cp	r24, r18
    42bc:	93 07       	cpc	r25, r19
    42be:	a4 07       	cpc	r26, r20
    42c0:	b5 07       	cpc	r27, r21
    42c2:	d0 f0       	brcs	.+52     	; 0x42f8 <f_lseek+0x13a>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    42c4:	88 27       	eor	r24, r24
    42c6:	99 27       	eor	r25, r25
    42c8:	dc 01       	movw	r26, r24
    42ca:	88 19       	sub	r24, r8
    42cc:	99 09       	sbc	r25, r9
    42ce:	aa 09       	sbc	r26, r10
    42d0:	bb 09       	sbc	r27, r11
    42d2:	84 21       	and	r24, r4
    42d4:	95 21       	and	r25, r5
    42d6:	a6 21       	and	r26, r6
    42d8:	b7 21       	and	r27, r7
    42da:	ed 81       	ldd	r30, Y+5	; 0x05
    42dc:	fe 81       	ldd	r31, Y+6	; 0x06
    42de:	86 83       	std	Z+6, r24	; 0x06
    42e0:	97 83       	std	Z+7, r25	; 0x07
    42e2:	a0 87       	std	Z+8, r26	; 0x08
    42e4:	b1 87       	std	Z+9, r27	; 0x09
				ofs -= fp->fptr;
    42e6:	c8 1a       	sub	r12, r24
    42e8:	d9 0a       	sbc	r13, r25
    42ea:	ea 0a       	sbc	r14, r26
    42ec:	fb 0a       	sbc	r15, r27
				clst = fp->clust;
    42ee:	42 89       	ldd	r20, Z+18	; 0x12
    42f0:	53 89       	ldd	r21, Z+19	; 0x13
    42f2:	64 89       	ldd	r22, Z+20	; 0x14
    42f4:	75 89       	ldd	r23, Z+21	; 0x15
    42f6:	42 c0       	rjmp	.+132    	; 0x437c <f_lseek+0x1be>
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
    42f8:	ad 81       	ldd	r26, Y+5	; 0x05
    42fa:	be 81       	ldd	r27, Y+6	; 0x06
    42fc:	1e 96       	adiw	r26, 0x0e	; 14
    42fe:	4d 91       	ld	r20, X+
    4300:	5d 91       	ld	r21, X+
    4302:	6d 91       	ld	r22, X+
    4304:	7c 91       	ld	r23, X
    4306:	51 97       	sbiw	r26, 0x11	; 17
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
    4308:	41 15       	cp	r20, r1
    430a:	51 05       	cpc	r21, r1
    430c:	61 05       	cpc	r22, r1
    430e:	71 05       	cpc	r23, r1
    4310:	69 f5       	brne	.+90     	; 0x436c <f_lseek+0x1ae>
					clst = create_chain(fp->fs, 0);
    4312:	c1 01       	movw	r24, r2
    4314:	40 e0       	ldi	r20, 0x00	; 0
    4316:	50 e0       	ldi	r21, 0x00	; 0
    4318:	ba 01       	movw	r22, r20
    431a:	0e 94 ab 14 	call	0x2956	; 0x2956 <create_chain>
    431e:	ab 01       	movw	r20, r22
    4320:	bc 01       	movw	r22, r24
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    4322:	41 30       	cpi	r20, 0x01	; 1
    4324:	51 05       	cpc	r21, r1
    4326:	61 05       	cpc	r22, r1
    4328:	71 05       	cpc	r23, r1
    432a:	39 f4       	brne	.+14     	; 0x433a <f_lseek+0x17c>
    432c:	ed 81       	ldd	r30, Y+5	; 0x05
    432e:	fe 81       	ldd	r31, Y+6	; 0x06
    4330:	84 81       	ldd	r24, Z+4	; 0x04
    4332:	80 68       	ori	r24, 0x80	; 128
    4334:	84 83       	std	Z+4, r24	; 0x04
    4336:	12 e0       	ldi	r17, 0x02	; 2
    4338:	49 c1       	rjmp	.+658    	; 0x45cc <f_lseek+0x40e>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    433a:	4f 3f       	cpi	r20, 0xFF	; 255
    433c:	ff ef       	ldi	r31, 0xFF	; 255
    433e:	5f 07       	cpc	r21, r31
    4340:	ff ef       	ldi	r31, 0xFF	; 255
    4342:	6f 07       	cpc	r22, r31
    4344:	ff ef       	ldi	r31, 0xFF	; 255
    4346:	7f 07       	cpc	r23, r31
    4348:	59 f4       	brne	.+22     	; 0x4360 <f_lseek+0x1a2>
    434a:	ad 81       	ldd	r26, Y+5	; 0x05
    434c:	be 81       	ldd	r27, Y+6	; 0x06
    434e:	14 96       	adiw	r26, 0x04	; 4
    4350:	8c 91       	ld	r24, X
    4352:	14 97       	sbiw	r26, 0x04	; 4
    4354:	80 68       	ori	r24, 0x80	; 128
    4356:	14 96       	adiw	r26, 0x04	; 4
    4358:	8c 93       	st	X, r24
    435a:	14 97       	sbiw	r26, 0x04	; 4
    435c:	11 e0       	ldi	r17, 0x01	; 1
    435e:	36 c1       	rjmp	.+620    	; 0x45cc <f_lseek+0x40e>
					fp->sclust = clst;
    4360:	ed 81       	ldd	r30, Y+5	; 0x05
    4362:	fe 81       	ldd	r31, Y+6	; 0x06
    4364:	46 87       	std	Z+14, r20	; 0x0e
    4366:	57 87       	std	Z+15, r21	; 0x0f
    4368:	60 8b       	std	Z+16, r22	; 0x10
    436a:	71 8b       	std	Z+17, r23	; 0x11
				}
#endif
				fp->clust = clst;
    436c:	ad 81       	ldd	r26, Y+5	; 0x05
    436e:	be 81       	ldd	r27, Y+6	; 0x06
    4370:	52 96       	adiw	r26, 0x12	; 18
    4372:	4d 93       	st	X+, r20
    4374:	5d 93       	st	X+, r21
    4376:	6d 93       	st	X+, r22
    4378:	7c 93       	st	X, r23
    437a:	55 97       	sbiw	r26, 0x15	; 21
			}
			if (clst != 0) {
    437c:	41 15       	cp	r20, r1
    437e:	51 05       	cpc	r21, r1
    4380:	61 05       	cpc	r22, r1
    4382:	71 05       	cpc	r23, r1
    4384:	09 f4       	brne	.+2      	; 0x4388 <f_lseek+0x1ca>
    4386:	aa c0       	rjmp	.+340    	; 0x44dc <f_lseek+0x31e>
				while (ofs > bcs) {						/* Cluster following loop */
    4388:	8c 14       	cp	r8, r12
    438a:	9d 04       	cpc	r9, r13
    438c:	ae 04       	cpc	r10, r14
    438e:	bf 04       	cpc	r11, r15
    4390:	08 f0       	brcs	.+2      	; 0x4394 <f_lseek+0x1d6>
    4392:	68 c0       	rjmp	.+208    	; 0x4464 <f_lseek+0x2a6>
    4394:	4d 80       	ldd	r4, Y+5	; 0x05
    4396:	5e 80       	ldd	r5, Y+6	; 0x06
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    4398:	f2 01       	movw	r30, r4
    439a:	84 81       	ldd	r24, Z+4	; 0x04
    439c:	81 ff       	sbrs	r24, 1
    439e:	0c c0       	rjmp	.+24     	; 0x43b8 <f_lseek+0x1fa>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
    43a0:	80 81       	ld	r24, Z
    43a2:	91 81       	ldd	r25, Z+1	; 0x01
    43a4:	0e 94 ab 14 	call	0x2956	; 0x2956 <create_chain>
    43a8:	ab 01       	movw	r20, r22
    43aa:	bc 01       	movw	r22, r24
						if (clst == 0) {				/* When disk gets full, clip file size */
    43ac:	41 15       	cp	r20, r1
    43ae:	51 05       	cpc	r21, r1
    43b0:	61 05       	cpc	r22, r1
    43b2:	71 05       	cpc	r23, r1
    43b4:	39 f4       	brne	.+14     	; 0x43c4 <f_lseek+0x206>
    43b6:	52 c0       	rjmp	.+164    	; 0x445c <f_lseek+0x29e>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    43b8:	80 81       	ld	r24, Z
    43ba:	91 81       	ldd	r25, Z+1	; 0x01
    43bc:	0e 94 82 11 	call	0x2304	; 0x2304 <get_fat>
    43c0:	ab 01       	movw	r20, r22
    43c2:	bc 01       	movw	r22, r24
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    43c4:	4f 3f       	cpi	r20, 0xFF	; 255
    43c6:	bf ef       	ldi	r27, 0xFF	; 255
    43c8:	5b 07       	cpc	r21, r27
    43ca:	bf ef       	ldi	r27, 0xFF	; 255
    43cc:	6b 07       	cpc	r22, r27
    43ce:	bf ef       	ldi	r27, 0xFF	; 255
    43d0:	7b 07       	cpc	r23, r27
    43d2:	41 f4       	brne	.+16     	; 0x43e4 <f_lseek+0x226>
    43d4:	5e 82       	std	Y+6, r5	; 0x06
    43d6:	4d 82       	std	Y+5, r4	; 0x05
    43d8:	f2 01       	movw	r30, r4
    43da:	84 81       	ldd	r24, Z+4	; 0x04
    43dc:	80 68       	ori	r24, 0x80	; 128
    43de:	84 83       	std	Z+4, r24	; 0x04
    43e0:	11 e0       	ldi	r17, 0x01	; 1
    43e2:	f4 c0       	rjmp	.+488    	; 0x45cc <f_lseek+0x40e>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    43e4:	42 30       	cpi	r20, 0x02	; 2
    43e6:	51 05       	cpc	r21, r1
    43e8:	61 05       	cpc	r22, r1
    43ea:	71 05       	cpc	r23, r1
    43ec:	60 f0       	brcs	.+24     	; 0x4406 <f_lseek+0x248>
    43ee:	d2 01       	movw	r26, r4
    43f0:	ed 91       	ld	r30, X+
    43f2:	fc 91       	ld	r31, X
    43f4:	82 8d       	ldd	r24, Z+26	; 0x1a
    43f6:	93 8d       	ldd	r25, Z+27	; 0x1b
    43f8:	a4 8d       	ldd	r26, Z+28	; 0x1c
    43fa:	b5 8d       	ldd	r27, Z+29	; 0x1d
    43fc:	48 17       	cp	r20, r24
    43fe:	59 07       	cpc	r21, r25
    4400:	6a 07       	cpc	r22, r26
    4402:	7b 07       	cpc	r23, r27
    4404:	40 f0       	brcs	.+16     	; 0x4416 <f_lseek+0x258>
    4406:	5e 82       	std	Y+6, r5	; 0x06
    4408:	4d 82       	std	Y+5, r4	; 0x05
    440a:	f2 01       	movw	r30, r4
    440c:	84 81       	ldd	r24, Z+4	; 0x04
    440e:	80 68       	ori	r24, 0x80	; 128
    4410:	84 83       	std	Z+4, r24	; 0x04
    4412:	12 e0       	ldi	r17, 0x02	; 2
    4414:	db c0       	rjmp	.+438    	; 0x45cc <f_lseek+0x40e>
					fp->clust = clst;
    4416:	d2 01       	movw	r26, r4
    4418:	52 96       	adiw	r26, 0x12	; 18
    441a:	4d 93       	st	X+, r20
    441c:	5d 93       	st	X+, r21
    441e:	6d 93       	st	X+, r22
    4420:	7c 93       	st	X, r23
    4422:	55 97       	sbiw	r26, 0x15	; 21
					fp->fptr += bcs;
    4424:	16 96       	adiw	r26, 0x06	; 6
    4426:	8d 91       	ld	r24, X+
    4428:	9d 91       	ld	r25, X+
    442a:	0d 90       	ld	r0, X+
    442c:	bc 91       	ld	r27, X
    442e:	a0 2d       	mov	r26, r0
    4430:	88 0d       	add	r24, r8
    4432:	99 1d       	adc	r25, r9
    4434:	aa 1d       	adc	r26, r10
    4436:	bb 1d       	adc	r27, r11
    4438:	f2 01       	movw	r30, r4
    443a:	86 83       	std	Z+6, r24	; 0x06
    443c:	97 83       	std	Z+7, r25	; 0x07
    443e:	a0 87       	std	Z+8, r26	; 0x08
    4440:	b1 87       	std	Z+9, r27	; 0x09
					ofs -= bcs;
    4442:	c8 18       	sub	r12, r8
    4444:	d9 08       	sbc	r13, r9
    4446:	ea 08       	sbc	r14, r10
    4448:	fb 08       	sbc	r15, r11
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
    444a:	8c 14       	cp	r8, r12
    444c:	9d 04       	cpc	r9, r13
    444e:	ae 04       	cpc	r10, r14
    4450:	bf 04       	cpc	r11, r15
    4452:	08 f4       	brcc	.+2      	; 0x4456 <f_lseek+0x298>
    4454:	a1 cf       	rjmp	.-190    	; 0x4398 <f_lseek+0x1da>
    4456:	5e 82       	std	Y+6, r5	; 0x06
    4458:	4d 82       	std	Y+5, r4	; 0x05
    445a:	04 c0       	rjmp	.+8      	; 0x4464 <f_lseek+0x2a6>
    445c:	5e 82       	std	Y+6, r5	; 0x06
    445e:	4d 82       	std	Y+5, r4	; 0x05
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
						if (clst == 0) {				/* When disk gets full, clip file size */
							ofs = bcs; break;
    4460:	75 01       	movw	r14, r10
    4462:	64 01       	movw	r12, r8
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
    4464:	ed 81       	ldd	r30, Y+5	; 0x05
    4466:	fe 81       	ldd	r31, Y+6	; 0x06
    4468:	86 81       	ldd	r24, Z+6	; 0x06
    446a:	97 81       	ldd	r25, Z+7	; 0x07
    446c:	a0 85       	ldd	r26, Z+8	; 0x08
    446e:	b1 85       	ldd	r27, Z+9	; 0x09
    4470:	8c 0d       	add	r24, r12
    4472:	9d 1d       	adc	r25, r13
    4474:	ae 1d       	adc	r26, r14
    4476:	bf 1d       	adc	r27, r15
    4478:	86 83       	std	Z+6, r24	; 0x06
    447a:	97 83       	std	Z+7, r25	; 0x07
    447c:	a0 87       	std	Z+8, r26	; 0x08
    447e:	b1 87       	std	Z+9, r27	; 0x09
				if (ofs % SS(fp->fs)) {
    4480:	d7 01       	movw	r26, r14
    4482:	c6 01       	movw	r24, r12
    4484:	91 70       	andi	r25, 0x01	; 1
    4486:	a0 70       	andi	r26, 0x00	; 0
    4488:	b0 70       	andi	r27, 0x00	; 0
    448a:	00 97       	sbiw	r24, 0x00	; 0
    448c:	a1 05       	cpc	r26, r1
    448e:	b1 05       	cpc	r27, r1
    4490:	49 f1       	breq	.+82     	; 0x44e4 <f_lseek+0x326>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    4492:	80 81       	ld	r24, Z
    4494:	91 81       	ldd	r25, Z+1	; 0x01
    4496:	0e 94 4c 11 	call	0x2298	; 0x2298 <clust2sect>
    449a:	dc 01       	movw	r26, r24
    449c:	cb 01       	movw	r24, r22
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    449e:	00 97       	sbiw	r24, 0x00	; 0
    44a0:	a1 05       	cpc	r26, r1
    44a2:	b1 05       	cpc	r27, r1
    44a4:	59 f4       	brne	.+22     	; 0x44bc <f_lseek+0x2fe>
    44a6:	ad 81       	ldd	r26, Y+5	; 0x05
    44a8:	be 81       	ldd	r27, Y+6	; 0x06
    44aa:	14 96       	adiw	r26, 0x04	; 4
    44ac:	8c 91       	ld	r24, X
    44ae:	14 97       	sbiw	r26, 0x04	; 4
    44b0:	80 68       	ori	r24, 0x80	; 128
    44b2:	14 96       	adiw	r26, 0x04	; 4
    44b4:	8c 93       	st	X, r24
    44b6:	14 97       	sbiw	r26, 0x04	; 4
    44b8:	12 e0       	ldi	r17, 0x02	; 2
    44ba:	88 c0       	rjmp	.+272    	; 0x45cc <f_lseek+0x40e>
					nsect += ofs / SS(fp->fs);
    44bc:	46 01       	movw	r8, r12
    44be:	57 01       	movw	r10, r14
    44c0:	07 2e       	mov	r0, r23
    44c2:	79 e0       	ldi	r23, 0x09	; 9
    44c4:	b6 94       	lsr	r11
    44c6:	a7 94       	ror	r10
    44c8:	97 94       	ror	r9
    44ca:	87 94       	ror	r8
    44cc:	7a 95       	dec	r23
    44ce:	d1 f7       	brne	.-12     	; 0x44c4 <f_lseek+0x306>
    44d0:	70 2d       	mov	r23, r0
    44d2:	88 0e       	add	r8, r24
    44d4:	99 1e       	adc	r9, r25
    44d6:	aa 1e       	adc	r10, r26
    44d8:	bb 1e       	adc	r11, r27
    44da:	07 c0       	rjmp	.+14     	; 0x44ea <f_lseek+0x32c>
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
    44dc:	88 24       	eor	r8, r8
    44de:	99 24       	eor	r9, r9
    44e0:	54 01       	movw	r10, r8
    44e2:	03 c0       	rjmp	.+6      	; 0x44ea <f_lseek+0x32c>
    44e4:	88 24       	eor	r8, r8
    44e6:	99 24       	eor	r9, r9
    44e8:	54 01       	movw	r10, r8
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
					nsect += ofs / SS(fp->fs);
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    44ea:	ed 81       	ldd	r30, Y+5	; 0x05
    44ec:	fe 81       	ldd	r31, Y+6	; 0x06
    44ee:	86 81       	ldd	r24, Z+6	; 0x06
    44f0:	97 81       	ldd	r25, Z+7	; 0x07
    44f2:	a0 85       	ldd	r26, Z+8	; 0x08
    44f4:	b1 85       	ldd	r27, Z+9	; 0x09
    44f6:	91 70       	andi	r25, 0x01	; 1
    44f8:	a0 70       	andi	r26, 0x00	; 0
    44fa:	b0 70       	andi	r27, 0x00	; 0
    44fc:	00 97       	sbiw	r24, 0x00	; 0
    44fe:	a1 05       	cpc	r26, r1
    4500:	b1 05       	cpc	r27, r1
    4502:	09 f4       	brne	.+2      	; 0x4506 <f_lseek+0x348>
    4504:	4b c0       	rjmp	.+150    	; 0x459c <f_lseek+0x3de>
    4506:	c6 88       	ldd	r12, Z+22	; 0x16
    4508:	d7 88       	ldd	r13, Z+23	; 0x17
    450a:	e0 8c       	ldd	r14, Z+24	; 0x18
    450c:	f1 8c       	ldd	r15, Z+25	; 0x19
    450e:	c8 14       	cp	r12, r8
    4510:	d9 04       	cpc	r13, r9
    4512:	ea 04       	cpc	r14, r10
    4514:	fb 04       	cpc	r15, r11
    4516:	09 f4       	brne	.+2      	; 0x451a <f_lseek+0x35c>
    4518:	41 c0       	rjmp	.+130    	; 0x459c <f_lseek+0x3de>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
    451a:	84 81       	ldd	r24, Z+4	; 0x04
    451c:	86 ff       	sbrs	r24, 6
    451e:	1f c0       	rjmp	.+62     	; 0x455e <f_lseek+0x3a0>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    4520:	01 90       	ld	r0, Z+
    4522:	f0 81       	ld	r31, Z
    4524:	e0 2d       	mov	r30, r0
    4526:	6d 81       	ldd	r22, Y+5	; 0x05
    4528:	7e 81       	ldd	r23, Y+6	; 0x06
    452a:	60 5e       	subi	r22, 0xE0	; 224
    452c:	7f 4f       	sbci	r23, 0xFF	; 255
    452e:	81 81       	ldd	r24, Z+1	; 0x01
    4530:	a7 01       	movw	r20, r14
    4532:	96 01       	movw	r18, r12
    4534:	01 e0       	ldi	r16, 0x01	; 1
    4536:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    453a:	88 23       	and	r24, r24
    453c:	59 f0       	breq	.+22     	; 0x4554 <f_lseek+0x396>
					ABORT(fp->fs, FR_DISK_ERR);
    453e:	ad 81       	ldd	r26, Y+5	; 0x05
    4540:	be 81       	ldd	r27, Y+6	; 0x06
    4542:	14 96       	adiw	r26, 0x04	; 4
    4544:	8c 91       	ld	r24, X
    4546:	14 97       	sbiw	r26, 0x04	; 4
    4548:	80 68       	ori	r24, 0x80	; 128
    454a:	14 96       	adiw	r26, 0x04	; 4
    454c:	8c 93       	st	X, r24
    454e:	14 97       	sbiw	r26, 0x04	; 4
    4550:	11 e0       	ldi	r17, 0x01	; 1
    4552:	3c c0       	rjmp	.+120    	; 0x45cc <f_lseek+0x40e>
				fp->flag &= ~FA__DIRTY;
    4554:	ed 81       	ldd	r30, Y+5	; 0x05
    4556:	fe 81       	ldd	r31, Y+6	; 0x06
    4558:	84 81       	ldd	r24, Z+4	; 0x04
    455a:	8f 7b       	andi	r24, 0xBF	; 191
    455c:	84 83       	std	Z+4, r24	; 0x04
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
    455e:	ad 81       	ldd	r26, Y+5	; 0x05
    4560:	be 81       	ldd	r27, Y+6	; 0x06
    4562:	ed 91       	ld	r30, X+
    4564:	fc 91       	ld	r31, X
    4566:	11 97       	sbiw	r26, 0x01	; 1
    4568:	bd 01       	movw	r22, r26
    456a:	60 5e       	subi	r22, 0xE0	; 224
    456c:	7f 4f       	sbci	r23, 0xFF	; 255
    456e:	81 81       	ldd	r24, Z+1	; 0x01
    4570:	a5 01       	movw	r20, r10
    4572:	94 01       	movw	r18, r8
    4574:	01 e0       	ldi	r16, 0x01	; 1
    4576:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    457a:	88 23       	and	r24, r24
    457c:	39 f0       	breq	.+14     	; 0x458c <f_lseek+0x3ce>
				ABORT(fp->fs, FR_DISK_ERR);
    457e:	ed 81       	ldd	r30, Y+5	; 0x05
    4580:	fe 81       	ldd	r31, Y+6	; 0x06
    4582:	84 81       	ldd	r24, Z+4	; 0x04
    4584:	80 68       	ori	r24, 0x80	; 128
    4586:	84 83       	std	Z+4, r24	; 0x04
    4588:	11 e0       	ldi	r17, 0x01	; 1
    458a:	20 c0       	rjmp	.+64     	; 0x45cc <f_lseek+0x40e>
#endif
			fp->dsect = nsect;
    458c:	ad 81       	ldd	r26, Y+5	; 0x05
    458e:	be 81       	ldd	r27, Y+6	; 0x06
    4590:	56 96       	adiw	r26, 0x16	; 22
    4592:	8d 92       	st	X+, r8
    4594:	9d 92       	st	X+, r9
    4596:	ad 92       	st	X+, r10
    4598:	bc 92       	st	X, r11
    459a:	59 97       	sbiw	r26, 0x19	; 25
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
    459c:	ed 81       	ldd	r30, Y+5	; 0x05
    459e:	fe 81       	ldd	r31, Y+6	; 0x06
    45a0:	86 81       	ldd	r24, Z+6	; 0x06
    45a2:	97 81       	ldd	r25, Z+7	; 0x07
    45a4:	a0 85       	ldd	r26, Z+8	; 0x08
    45a6:	b1 85       	ldd	r27, Z+9	; 0x09
    45a8:	42 85       	ldd	r20, Z+10	; 0x0a
    45aa:	53 85       	ldd	r21, Z+11	; 0x0b
    45ac:	64 85       	ldd	r22, Z+12	; 0x0c
    45ae:	75 85       	ldd	r23, Z+13	; 0x0d
    45b0:	48 17       	cp	r20, r24
    45b2:	59 07       	cpc	r21, r25
    45b4:	6a 07       	cpc	r22, r26
    45b6:	7b 07       	cpc	r23, r27
    45b8:	48 f4       	brcc	.+18     	; 0x45cc <f_lseek+0x40e>
			fp->fsize = fp->fptr;
    45ba:	82 87       	std	Z+10, r24	; 0x0a
    45bc:	93 87       	std	Z+11, r25	; 0x0b
    45be:	a4 87       	std	Z+12, r26	; 0x0c
    45c0:	b5 87       	std	Z+13, r27	; 0x0d
			fp->flag |= FA__WRITTEN;
    45c2:	84 81       	ldd	r24, Z+4	; 0x04
    45c4:	80 62       	ori	r24, 0x20	; 32
    45c6:	84 83       	std	Z+4, r24	; 0x04
    45c8:	01 c0       	rjmp	.+2      	; 0x45cc <f_lseek+0x40e>


	res = validate(fp);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)			/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    45ca:	12 e0       	ldi	r17, 0x02	; 2
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
    45cc:	81 2f       	mov	r24, r17
    45ce:	26 96       	adiw	r28, 0x06	; 6
    45d0:	0f b6       	in	r0, 0x3f	; 63
    45d2:	f8 94       	cli
    45d4:	de bf       	out	0x3e, r29	; 62
    45d6:	0f be       	out	0x3f, r0	; 63
    45d8:	cd bf       	out	0x3d, r28	; 61
    45da:	df 91       	pop	r29
    45dc:	cf 91       	pop	r28
    45de:	1f 91       	pop	r17
    45e0:	0f 91       	pop	r16
    45e2:	ff 90       	pop	r15
    45e4:	ef 90       	pop	r14
    45e6:	df 90       	pop	r13
    45e8:	cf 90       	pop	r12
    45ea:	bf 90       	pop	r11
    45ec:	af 90       	pop	r10
    45ee:	9f 90       	pop	r9
    45f0:	8f 90       	pop	r8
    45f2:	7f 90       	pop	r7
    45f4:	6f 90       	pop	r6
    45f6:	5f 90       	pop	r5
    45f8:	4f 90       	pop	r4
    45fa:	3f 90       	pop	r3
    45fc:	2f 90       	pop	r2
    45fe:	08 95       	ret

00004600 <f_opendir>:

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const TCHAR *path	/* Pointer to the directory path */
)
{
    4600:	ef 92       	push	r14
    4602:	ff 92       	push	r15
    4604:	0f 93       	push	r16
    4606:	1f 93       	push	r17
    4608:	cf 93       	push	r28
    460a:	df 93       	push	r29
    460c:	cd b7       	in	r28, 0x3d	; 61
    460e:	de b7       	in	r29, 0x3e	; 62
    4610:	2e 97       	sbiw	r28, 0x0e	; 14
    4612:	0f b6       	in	r0, 0x3f	; 63
    4614:	f8 94       	cli
    4616:	de bf       	out	0x3e, r29	; 62
    4618:	0f be       	out	0x3f, r0	; 63
    461a:	cd bf       	out	0x3d, r28	; 61
    461c:	8c 01       	movw	r16, r24
    461e:	7e 87       	std	Y+14, r23	; 0x0e
    4620:	6d 87       	std	Y+13, r22	; 0x0d
	FRESULT res;
	FATFS *fs;
	DEF_NAMEBUF;


	if (!dj) return FR_INVALID_OBJECT;
    4622:	00 97       	sbiw	r24, 0x00	; 0
    4624:	09 f4       	brne	.+2      	; 0x4628 <f_opendir+0x28>
    4626:	4c c0       	rjmp	.+152    	; 0x46c0 <f_opendir+0xc0>

	res = chk_mounted(&path, &dj->fs, 0);
    4628:	ce 01       	movw	r24, r28
    462a:	0d 96       	adiw	r24, 0x0d	; 13
    462c:	b8 01       	movw	r22, r16
    462e:	40 e0       	ldi	r20, 0x00	; 0
    4630:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <chk_mounted>
	fs = dj->fs;
    4634:	d8 01       	movw	r26, r16
    4636:	ed 90       	ld	r14, X+
    4638:	fc 90       	ld	r15, X
    463a:	11 97       	sbiw	r26, 0x01	; 1
	if (res == FR_OK) {
    463c:	88 23       	and	r24, r24
    463e:	e1 f5       	brne	.+120    	; 0x46b8 <f_opendir+0xb8>
		INIT_BUF(*dj);
    4640:	ce 01       	movw	r24, r28
    4642:	01 96       	adiw	r24, 0x01	; 1
    4644:	55 96       	adiw	r26, 0x15	; 21
    4646:	9c 93       	st	X, r25
    4648:	8e 93       	st	-X, r24
    464a:	54 97       	sbiw	r26, 0x14	; 20
		res = follow_path(dj, path);			/* Follow the path to the directory */
    464c:	6d 85       	ldd	r22, Y+13	; 0x0d
    464e:	7e 85       	ldd	r23, Y+14	; 0x0e
    4650:	c8 01       	movw	r24, r16
    4652:	0e 94 14 17 	call	0x2e28	; 0x2e28 <follow_path>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
    4656:	88 23       	and	r24, r24
    4658:	11 f5       	brne	.+68     	; 0x469e <f_opendir+0x9e>
			if (dj->dir) {						/* It is not the root dir */
    465a:	d8 01       	movw	r26, r16
    465c:	52 96       	adiw	r26, 0x12	; 18
    465e:	ed 91       	ld	r30, X+
    4660:	fc 91       	ld	r31, X
    4662:	53 97       	sbiw	r26, 0x13	; 19
    4664:	30 97       	sbiw	r30, 0x00	; 0
    4666:	71 f0       	breq	.+28     	; 0x4684 <f_opendir+0x84>
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
    4668:	83 85       	ldd	r24, Z+11	; 0x0b
    466a:	84 ff       	sbrs	r24, 4
    466c:	1b c0       	rjmp	.+54     	; 0x46a4 <f_opendir+0xa4>
					dj->sclust = ld_clust(fs, dj->dir);
    466e:	c7 01       	movw	r24, r14
    4670:	bf 01       	movw	r22, r30
    4672:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <ld_clust>
    4676:	dc 01       	movw	r26, r24
    4678:	cb 01       	movw	r24, r22
    467a:	f8 01       	movw	r30, r16
    467c:	86 83       	std	Z+6, r24	; 0x06
    467e:	97 83       	std	Z+7, r25	; 0x07
    4680:	a0 87       	std	Z+8, r26	; 0x08
    4682:	b1 87       	std	Z+9, r27	; 0x09
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dj->id = fs->id;
    4684:	d7 01       	movw	r26, r14
    4686:	16 96       	adiw	r26, 0x06	; 6
    4688:	8d 91       	ld	r24, X+
    468a:	9c 91       	ld	r25, X
    468c:	17 97       	sbiw	r26, 0x07	; 7
    468e:	f8 01       	movw	r30, r16
    4690:	93 83       	std	Z+3, r25	; 0x03
    4692:	82 83       	std	Z+2, r24	; 0x02
				res = dir_sdi(dj, 0);			/* Rewind dir */
    4694:	c8 01       	movw	r24, r16
    4696:	60 e0       	ldi	r22, 0x00	; 0
    4698:	70 e0       	ldi	r23, 0x00	; 0
    469a:	0e 94 b9 12 	call	0x2572	; 0x2572 <dir_sdi>
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    469e:	84 30       	cpi	r24, 0x04	; 4
    46a0:	11 f4       	brne	.+4      	; 0x46a6 <f_opendir+0xa6>
    46a2:	04 c0       	rjmp	.+8      	; 0x46ac <f_opendir+0xac>
		if (res == FR_OK) {						/* Follow completed */
			if (dj->dir) {						/* It is not the root dir */
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
					dj->sclust = ld_clust(fs, dj->dir);
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
    46a4:	85 e0       	ldi	r24, 0x05	; 5
				dj->id = fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
    46a6:	88 23       	and	r24, r24
    46a8:	61 f0       	breq	.+24     	; 0x46c2 <f_opendir+0xc2>
    46aa:	01 c0       	rjmp	.+2      	; 0x46ae <f_opendir+0xae>
			if (res == FR_OK) {
				dj->id = fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    46ac:	85 e0       	ldi	r24, 0x05	; 5
		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
    46ae:	d8 01       	movw	r26, r16
    46b0:	11 96       	adiw	r26, 0x01	; 1
    46b2:	1c 92       	st	X, r1
    46b4:	1e 92       	st	-X, r1
    46b6:	05 c0       	rjmp	.+10     	; 0x46c2 <f_opendir+0xc2>
	} else {
		dj->fs = 0;
    46b8:	f8 01       	movw	r30, r16
    46ba:	11 82       	std	Z+1, r1	; 0x01
    46bc:	10 82       	st	Z, r1
    46be:	01 c0       	rjmp	.+2      	; 0x46c2 <f_opendir+0xc2>
	FRESULT res;
	FATFS *fs;
	DEF_NAMEBUF;


	if (!dj) return FR_INVALID_OBJECT;
    46c0:	89 e0       	ldi	r24, 0x09	; 9
	} else {
		dj->fs = 0;
	}

	LEAVE_FF(fs, res);
}
    46c2:	2e 96       	adiw	r28, 0x0e	; 14
    46c4:	0f b6       	in	r0, 0x3f	; 63
    46c6:	f8 94       	cli
    46c8:	de bf       	out	0x3e, r29	; 62
    46ca:	0f be       	out	0x3f, r0	; 63
    46cc:	cd bf       	out	0x3d, r28	; 61
    46ce:	df 91       	pop	r29
    46d0:	cf 91       	pop	r28
    46d2:	1f 91       	pop	r17
    46d4:	0f 91       	pop	r16
    46d6:	ff 90       	pop	r15
    46d8:	ef 90       	pop	r14
    46da:	08 95       	ret

000046dc <f_readdir>:

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
    46dc:	cf 92       	push	r12
    46de:	df 92       	push	r13
    46e0:	ef 92       	push	r14
    46e2:	ff 92       	push	r15
    46e4:	1f 93       	push	r17
    46e6:	cf 93       	push	r28
    46e8:	df 93       	push	r29
    46ea:	cd b7       	in	r28, 0x3d	; 61
    46ec:	de b7       	in	r29, 0x3e	; 62
    46ee:	2c 97       	sbiw	r28, 0x0c	; 12
    46f0:	0f b6       	in	r0, 0x3f	; 63
    46f2:	f8 94       	cli
    46f4:	de bf       	out	0x3e, r29	; 62
    46f6:	0f be       	out	0x3f, r0	; 63
    46f8:	cd bf       	out	0x3d, r28	; 61
    46fa:	7c 01       	movw	r14, r24
    46fc:	6b 01       	movw	r12, r22
	FRESULT res;
	DEF_NAMEBUF;


	res = validate(dj);						/* Check validity of the object */
    46fe:	0e 94 28 0b 	call	0x1650	; 0x1650 <validate>
    4702:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    4704:	88 23       	and	r24, r24
    4706:	81 f5       	brne	.+96     	; 0x4768 <f_readdir+0x8c>
		if (!fno) {
    4708:	c1 14       	cp	r12, r1
    470a:	d1 04       	cpc	r13, r1
    470c:	39 f4       	brne	.+14     	; 0x471c <f_readdir+0x40>
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
    470e:	c7 01       	movw	r24, r14
    4710:	60 e0       	ldi	r22, 0x00	; 0
    4712:	70 e0       	ldi	r23, 0x00	; 0
    4714:	0e 94 b9 12 	call	0x2572	; 0x2572 <dir_sdi>
    4718:	18 2f       	mov	r17, r24
    471a:	26 c0       	rjmp	.+76     	; 0x4768 <f_readdir+0x8c>
		} else {
			INIT_BUF(*dj);
    471c:	ce 01       	movw	r24, r28
    471e:	01 96       	adiw	r24, 0x01	; 1
    4720:	f7 01       	movw	r30, r14
    4722:	95 8b       	std	Z+21, r25	; 0x15
    4724:	84 8b       	std	Z+20, r24	; 0x14
			res = dir_read(dj);				/* Read an directory item */
    4726:	c7 01       	movw	r24, r14
    4728:	0e 94 9c 19 	call	0x3338	; 0x3338 <dir_read>
			if (res == FR_NO_FILE) {		/* Reached end of dir */
    472c:	84 30       	cpi	r24, 0x04	; 4
    472e:	31 f4       	brne	.+12     	; 0x473c <f_readdir+0x60>
				dj->sect = 0;
    4730:	f7 01       	movw	r30, r14
    4732:	16 86       	std	Z+14, r1	; 0x0e
    4734:	17 86       	std	Z+15, r1	; 0x0f
    4736:	10 8a       	std	Z+16, r1	; 0x10
    4738:	11 8a       	std	Z+17, r1	; 0x11
    473a:	02 c0       	rjmp	.+4      	; 0x4740 <f_readdir+0x64>
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
    473c:	88 23       	and	r24, r24
    473e:	89 f4       	brne	.+34     	; 0x4762 <f_readdir+0x86>
				get_fileinfo(dj, fno);		/* Get the object information */
    4740:	c7 01       	movw	r24, r14
    4742:	b6 01       	movw	r22, r12
    4744:	0e 94 96 0a 	call	0x152c	; 0x152c <get_fileinfo>
				res = dir_next(dj, 0);		/* Increment index for next */
    4748:	c7 01       	movw	r24, r14
    474a:	60 e0       	ldi	r22, 0x00	; 0
    474c:	70 e0       	ldi	r23, 0x00	; 0
    474e:	0e 94 cd 15 	call	0x2b9a	; 0x2b9a <dir_next>
				if (res == FR_NO_FILE) {
    4752:	84 30       	cpi	r24, 0x04	; 4
    4754:	41 f4       	brne	.+16     	; 0x4766 <f_readdir+0x8a>
					dj->sect = 0;
    4756:	f7 01       	movw	r30, r14
    4758:	16 86       	std	Z+14, r1	; 0x0e
    475a:	17 86       	std	Z+15, r1	; 0x0f
    475c:	10 8a       	std	Z+16, r1	; 0x10
    475e:	11 8a       	std	Z+17, r1	; 0x11
    4760:	03 c0       	rjmp	.+6      	; 0x4768 <f_readdir+0x8c>
	if (res == FR_OK) {
		if (!fno) {
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
		} else {
			INIT_BUF(*dj);
			res = dir_read(dj);				/* Read an directory item */
    4762:	18 2f       	mov	r17, r24
    4764:	01 c0       	rjmp	.+2      	; 0x4768 <f_readdir+0x8c>
				dj->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj, 0);		/* Increment index for next */
    4766:	18 2f       	mov	r17, r24
			FREE_BUF();
		}
	}

	LEAVE_FF(dj->fs, res);
}
    4768:	81 2f       	mov	r24, r17
    476a:	2c 96       	adiw	r28, 0x0c	; 12
    476c:	0f b6       	in	r0, 0x3f	; 63
    476e:	f8 94       	cli
    4770:	de bf       	out	0x3e, r29	; 62
    4772:	0f be       	out	0x3f, r0	; 63
    4774:	cd bf       	out	0x3d, r28	; 61
    4776:	df 91       	pop	r29
    4778:	cf 91       	pop	r28
    477a:	1f 91       	pop	r17
    477c:	ff 90       	pop	r15
    477e:	ef 90       	pop	r14
    4780:	df 90       	pop	r13
    4782:	cf 90       	pop	r12
    4784:	08 95       	ret

00004786 <f_stat>:

FRESULT f_stat (
	const TCHAR *path,	/* Pointer to the file path */
	FILINFO *fno		/* Pointer to file information to return */
)
{
    4786:	ef 92       	push	r14
    4788:	ff 92       	push	r15
    478a:	1f 93       	push	r17
    478c:	cf 93       	push	r28
    478e:	df 93       	push	r29
    4790:	cd b7       	in	r28, 0x3d	; 61
    4792:	de b7       	in	r29, 0x3e	; 62
    4794:	a4 97       	sbiw	r28, 0x24	; 36
    4796:	0f b6       	in	r0, 0x3f	; 63
    4798:	f8 94       	cli
    479a:	de bf       	out	0x3e, r29	; 62
    479c:	0f be       	out	0x3f, r0	; 63
    479e:	cd bf       	out	0x3d, r28	; 61
    47a0:	9c a3       	lds	r25, 0x5c
    47a2:	8b a3       	lds	r24, 0x5b
    47a4:	7b 01       	movw	r14, r22
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
    47a6:	ce 01       	movw	r24, r28
    47a8:	83 96       	adiw	r24, 0x23	; 35
    47aa:	be 01       	movw	r22, r28
    47ac:	6f 5f       	subi	r22, 0xFF	; 255
    47ae:	7f 4f       	sbci	r23, 0xFF	; 255
    47b0:	40 e0       	ldi	r20, 0x00	; 0
    47b2:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <chk_mounted>
    47b6:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    47b8:	88 23       	and	r24, r24
    47ba:	c1 f4       	brne	.+48     	; 0x47ec <f_stat+0x66>
		INIT_BUF(dj);
    47bc:	ce 01       	movw	r24, r28
    47be:	47 96       	adiw	r24, 0x17	; 23
    47c0:	9e 8b       	std	Y+22, r25	; 0x16
    47c2:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    47c4:	6b a1       	lds	r22, 0x4b
    47c6:	7c a1       	lds	r23, 0x4c
    47c8:	ce 01       	movw	r24, r28
    47ca:	01 96       	adiw	r24, 0x01	; 1
    47cc:	0e 94 14 17 	call	0x2e28	; 0x2e28 <follow_path>
    47d0:	18 2f       	mov	r17, r24
		if (res == FR_OK) {				/* Follow completed */
    47d2:	88 23       	and	r24, r24
    47d4:	59 f4       	brne	.+22     	; 0x47ec <f_stat+0x66>
			if (dj.dir)		/* Found an object */
    47d6:	8b 89       	ldd	r24, Y+19	; 0x13
    47d8:	9c 89       	ldd	r25, Y+20	; 0x14
    47da:	00 97       	sbiw	r24, 0x00	; 0
    47dc:	31 f0       	breq	.+12     	; 0x47ea <f_stat+0x64>
				get_fileinfo(&dj, fno);
    47de:	ce 01       	movw	r24, r28
    47e0:	01 96       	adiw	r24, 0x01	; 1
    47e2:	b7 01       	movw	r22, r14
    47e4:	0e 94 96 0a 	call	0x152c	; 0x152c <get_fileinfo>
    47e8:	01 c0       	rjmp	.+2      	; 0x47ec <f_stat+0x66>
			else			/* It is root dir */
				res = FR_INVALID_NAME;
    47ea:	16 e0       	ldi	r17, 0x06	; 6
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    47ec:	81 2f       	mov	r24, r17
    47ee:	a4 96       	adiw	r28, 0x24	; 36
    47f0:	0f b6       	in	r0, 0x3f	; 63
    47f2:	f8 94       	cli
    47f4:	de bf       	out	0x3e, r29	; 62
    47f6:	0f be       	out	0x3f, r0	; 63
    47f8:	cd bf       	out	0x3d, r28	; 61
    47fa:	df 91       	pop	r29
    47fc:	cf 91       	pop	r28
    47fe:	1f 91       	pop	r17
    4800:	ff 90       	pop	r15
    4802:	ef 90       	pop	r14
    4804:	08 95       	ret

00004806 <f_getfree>:
FRESULT f_getfree (
	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
)
{
    4806:	2f 92       	push	r2
    4808:	3f 92       	push	r3
    480a:	4f 92       	push	r4
    480c:	5f 92       	push	r5
    480e:	6f 92       	push	r6
    4810:	7f 92       	push	r7
    4812:	8f 92       	push	r8
    4814:	9f 92       	push	r9
    4816:	af 92       	push	r10
    4818:	bf 92       	push	r11
    481a:	cf 92       	push	r12
    481c:	df 92       	push	r13
    481e:	ef 92       	push	r14
    4820:	ff 92       	push	r15
    4822:	0f 93       	push	r16
    4824:	1f 93       	push	r17
    4826:	cf 93       	push	r28
    4828:	df 93       	push	r29
    482a:	cd b7       	in	r28, 0x3d	; 61
    482c:	de b7       	in	r29, 0x3e	; 62
    482e:	2c 97       	sbiw	r28, 0x0c	; 12
    4830:	0f b6       	in	r0, 0x3f	; 63
    4832:	f8 94       	cli
    4834:	de bf       	out	0x3e, r29	; 62
    4836:	0f be       	out	0x3f, r0	; 63
    4838:	cd bf       	out	0x3d, r28	; 61
    483a:	9a 83       	std	Y+2, r25	; 0x02
    483c:	89 83       	std	Y+1, r24	; 0x01
    483e:	78 87       	std	Y+8, r23	; 0x08
    4840:	6f 83       	std	Y+7, r22	; 0x07
    4842:	8a 01       	movw	r16, r20
	UINT i;
	BYTE fat, *p;


	/* Get drive number */
	res = chk_mounted(&path, fatfs, 0);
    4844:	ce 01       	movw	r24, r28
    4846:	01 96       	adiw	r24, 0x01	; 1
    4848:	ba 01       	movw	r22, r20
    484a:	40 e0       	ldi	r20, 0x00	; 0
    484c:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <chk_mounted>
    4850:	b8 2e       	mov	r11, r24
	fs = *fatfs;
    4852:	d8 01       	movw	r26, r16
    4854:	8d 90       	ld	r8, X+
    4856:	9c 90       	ld	r9, X
    4858:	11 97       	sbiw	r26, 0x01	; 1
	if (res == FR_OK) {
    485a:	88 23       	and	r24, r24
    485c:	09 f0       	breq	.+2      	; 0x4860 <f_getfree+0x5a>
    485e:	03 c1       	rjmp	.+518    	; 0x4a66 <f_getfree+0x260>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
    4860:	f4 01       	movw	r30, r8
    4862:	86 85       	ldd	r24, Z+14	; 0x0e
    4864:	97 85       	ldd	r25, Z+15	; 0x0f
    4866:	a0 89       	ldd	r26, Z+16	; 0x10
    4868:	b1 89       	ldd	r27, Z+17	; 0x11
    486a:	c2 8c       	ldd	r12, Z+26	; 0x1a
    486c:	d3 8c       	ldd	r13, Z+27	; 0x1b
    486e:	e4 8c       	ldd	r14, Z+28	; 0x1c
    4870:	f5 8c       	ldd	r15, Z+29	; 0x1d
    4872:	b7 01       	movw	r22, r14
    4874:	a6 01       	movw	r20, r12
    4876:	42 50       	subi	r20, 0x02	; 2
    4878:	50 40       	sbci	r21, 0x00	; 0
    487a:	60 40       	sbci	r22, 0x00	; 0
    487c:	70 40       	sbci	r23, 0x00	; 0
    487e:	48 17       	cp	r20, r24
    4880:	59 07       	cpc	r21, r25
    4882:	6a 07       	cpc	r22, r26
    4884:	7b 07       	cpc	r23, r27
    4886:	38 f0       	brcs	.+14     	; 0x4896 <f_getfree+0x90>
			*nclst = fs->free_clust;
    4888:	ef 81       	ldd	r30, Y+7	; 0x07
    488a:	f8 85       	ldd	r31, Y+8	; 0x08
    488c:	80 83       	st	Z, r24
    488e:	91 83       	std	Z+1, r25	; 0x01
    4890:	a2 83       	std	Z+2, r26	; 0x02
    4892:	b3 83       	std	Z+3, r27	; 0x03
    4894:	e8 c0       	rjmp	.+464    	; 0x4a66 <f_getfree+0x260>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
    4896:	a0 80       	ld	r10, Z
			n = 0;
			if (fat == FS_FAT12) {
    4898:	b1 e0       	ldi	r27, 0x01	; 1
    489a:	ab 16       	cp	r10, r27
    489c:	d9 f5       	brne	.+118    	; 0x4914 <f_getfree+0x10e>
    489e:	cc 24       	eor	r12, r12
    48a0:	dd 24       	eor	r13, r13
    48a2:	76 01       	movw	r14, r12
    48a4:	68 94       	set
    48a6:	c1 f8       	bld	r12, 1
    48a8:	44 24       	eor	r4, r4
    48aa:	55 24       	eor	r5, r5
    48ac:	32 01       	movw	r6, r4
				clst = 2;
				do {
					stat = get_fat(fs, clst);
    48ae:	c4 01       	movw	r24, r8
    48b0:	b7 01       	movw	r22, r14
    48b2:	a6 01       	movw	r20, r12
    48b4:	0e 94 82 11 	call	0x2304	; 0x2304 <get_fat>
    48b8:	dc 01       	movw	r26, r24
    48ba:	cb 01       	movw	r24, r22
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
    48bc:	8f 3f       	cpi	r24, 0xFF	; 255
    48be:	ef ef       	ldi	r30, 0xFF	; 255
    48c0:	9e 07       	cpc	r25, r30
    48c2:	ef ef       	ldi	r30, 0xFF	; 255
    48c4:	ae 07       	cpc	r26, r30
    48c6:	ef ef       	ldi	r30, 0xFF	; 255
    48c8:	be 07       	cpc	r27, r30
    48ca:	09 f4       	brne	.+2      	; 0x48ce <f_getfree+0xc8>
    48cc:	b0 c0       	rjmp	.+352    	; 0x4a2e <f_getfree+0x228>
					if (stat == 1) { res = FR_INT_ERR; break; }
    48ce:	81 30       	cpi	r24, 0x01	; 1
    48d0:	91 05       	cpc	r25, r1
    48d2:	a1 05       	cpc	r26, r1
    48d4:	b1 05       	cpc	r27, r1
    48d6:	09 f4       	brne	.+2      	; 0x48da <f_getfree+0xd4>
    48d8:	ad c0       	rjmp	.+346    	; 0x4a34 <f_getfree+0x22e>
					if (stat == 0) n++;
    48da:	00 97       	sbiw	r24, 0x00	; 0
    48dc:	a1 05       	cpc	r26, r1
    48de:	b1 05       	cpc	r27, r1
    48e0:	29 f4       	brne	.+10     	; 0x48ec <f_getfree+0xe6>
    48e2:	08 94       	sec
    48e4:	41 1c       	adc	r4, r1
    48e6:	51 1c       	adc	r5, r1
    48e8:	61 1c       	adc	r6, r1
    48ea:	71 1c       	adc	r7, r1
				} while (++clst < fs->n_fatent);
    48ec:	08 94       	sec
    48ee:	c1 1c       	adc	r12, r1
    48f0:	d1 1c       	adc	r13, r1
    48f2:	e1 1c       	adc	r14, r1
    48f4:	f1 1c       	adc	r15, r1
    48f6:	f4 01       	movw	r30, r8
    48f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    48fa:	93 8d       	ldd	r25, Z+27	; 0x1b
    48fc:	a4 8d       	ldd	r26, Z+28	; 0x1c
    48fe:	b5 8d       	ldd	r27, Z+29	; 0x1d
    4900:	c8 16       	cp	r12, r24
    4902:	d9 06       	cpc	r13, r25
    4904:	ea 06       	cpc	r14, r26
    4906:	fb 06       	cpc	r15, r27
    4908:	90 f2       	brcs	.-92     	; 0x48ae <f_getfree+0xa8>
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
    490a:	46 86       	std	Z+14, r4	; 0x0e
    490c:	57 86       	std	Z+15, r5	; 0x0f
    490e:	60 8a       	std	Z+16, r6	; 0x10
    4910:	71 8a       	std	Z+17, r7	; 0x11
    4912:	a2 c0       	rjmp	.+324    	; 0x4a58 <f_getfree+0x252>
					if (stat == 1) { res = FR_INT_ERR; break; }
					if (stat == 0) n++;
				} while (++clst < fs->n_fatent);
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
    4914:	82 a1       	lds	r24, 0x42
    4916:	93 a1       	lds	r25, 0x43
    4918:	a4 a1       	lds	r26, 0x44
    491a:	b5 a1       	lds	r27, 0x45
    491c:	8b 83       	std	Y+3, r24	; 0x03
    491e:	9c 83       	std	Y+4, r25	; 0x04
    4920:	ad 83       	std	Y+5, r26	; 0x05
    4922:	be 83       	std	Y+6, r27	; 0x06
				i = 0; p = 0;
    4924:	e0 e0       	ldi	r30, 0x00	; 0
    4926:	f0 e0       	ldi	r31, 0x00	; 0
    4928:	00 e0       	ldi	r16, 0x00	; 0
    492a:	10 e0       	ldi	r17, 0x00	; 0
    492c:	98 01       	movw	r18, r16
		if (fs->free_clust <= fs->n_fatent - 2) {
			*nclst = fs->free_clust;
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
			n = 0;
    492e:	44 24       	eor	r4, r4
    4930:	55 24       	eor	r5, r5
    4932:	32 01       	movw	r6, r4
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
    4934:	a4 01       	movw	r20, r8
    4936:	4e 5c       	subi	r20, 0xCE	; 206
    4938:	5f 4f       	sbci	r21, 0xFF	; 255
    493a:	5c 87       	std	Y+12, r21	; 0x0c
    493c:	4b 87       	std	Y+11, r20	; 0x0b
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
    493e:	01 15       	cp	r16, r1
    4940:	11 05       	cpc	r17, r1
    4942:	21 05       	cpc	r18, r1
    4944:	31 05       	cpc	r19, r1
    4946:	d9 f4       	brne	.+54     	; 0x497e <f_getfree+0x178>
						res = move_window(fs, sect++);
    4948:	c4 01       	movw	r24, r8
    494a:	4b 81       	ldd	r20, Y+3	; 0x03
    494c:	5c 81       	ldd	r21, Y+4	; 0x04
    494e:	6d 81       	ldd	r22, Y+5	; 0x05
    4950:	7e 81       	ldd	r23, Y+6	; 0x06
    4952:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
						if (res != FR_OK) break;
    4956:	88 23       	and	r24, r24
    4958:	09 f0       	breq	.+2      	; 0x495c <f_getfree+0x156>
    495a:	70 c0       	rjmp	.+224    	; 0x4a3c <f_getfree+0x236>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
    495c:	8b 81       	ldd	r24, Y+3	; 0x03
    495e:	9c 81       	ldd	r25, Y+4	; 0x04
    4960:	ad 81       	ldd	r26, Y+5	; 0x05
    4962:	be 81       	ldd	r27, Y+6	; 0x06
    4964:	01 96       	adiw	r24, 0x01	; 1
    4966:	a1 1d       	adc	r26, r1
    4968:	b1 1d       	adc	r27, r1
    496a:	8b 83       	std	Y+3, r24	; 0x03
    496c:	9c 83       	std	Y+4, r25	; 0x04
    496e:	ad 83       	std	Y+5, r26	; 0x05
    4970:	be 83       	std	Y+6, r27	; 0x06
						if (res != FR_OK) break;
						p = fs->win;
    4972:	eb 85       	ldd	r30, Y+11	; 0x0b
    4974:	fc 85       	ldd	r31, Y+12	; 0x0c
						i = SS(fs);
    4976:	00 e0       	ldi	r16, 0x00	; 0
    4978:	12 e0       	ldi	r17, 0x02	; 2
    497a:	20 e0       	ldi	r18, 0x00	; 0
    497c:	30 e0       	ldi	r19, 0x00	; 0
					}
					if (fat == FS_FAT16) {
    497e:	92 e0       	ldi	r25, 0x02	; 2
    4980:	a9 16       	cp	r10, r25
    4982:	b1 f4       	brne	.+44     	; 0x49b0 <f_getfree+0x1aa>
						if (LD_WORD(p) == 0) n++;
    4984:	a1 81       	ldd	r26, Z+1	; 0x01
    4986:	aa 87       	std	Y+10, r26	; 0x0a
    4988:	19 86       	std	Y+9, r1	; 0x09
    498a:	80 81       	ld	r24, Z
    498c:	90 e0       	ldi	r25, 0x00	; 0
    498e:	49 85       	ldd	r20, Y+9	; 0x09
    4990:	5a 85       	ldd	r21, Y+10	; 0x0a
    4992:	84 2b       	or	r24, r20
    4994:	95 2b       	or	r25, r21
    4996:	00 97       	sbiw	r24, 0x00	; 0
    4998:	29 f4       	brne	.+10     	; 0x49a4 <f_getfree+0x19e>
    499a:	08 94       	sec
    499c:	41 1c       	adc	r4, r1
    499e:	51 1c       	adc	r5, r1
    49a0:	61 1c       	adc	r6, r1
    49a2:	71 1c       	adc	r7, r1
						p += 2; i -= 2;
    49a4:	32 96       	adiw	r30, 0x02	; 2
    49a6:	02 50       	subi	r16, 0x02	; 2
    49a8:	10 40       	sbci	r17, 0x00	; 0
    49aa:	20 40       	sbci	r18, 0x00	; 0
    49ac:	30 40       	sbci	r19, 0x00	; 0
    49ae:	33 c0       	rjmp	.+102    	; 0x4a16 <f_getfree+0x210>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
    49b0:	83 81       	ldd	r24, Z+3	; 0x03
    49b2:	90 e0       	ldi	r25, 0x00	; 0
    49b4:	a0 e0       	ldi	r26, 0x00	; 0
    49b6:	b0 e0       	ldi	r27, 0x00	; 0
    49b8:	78 2f       	mov	r23, r24
    49ba:	66 27       	eor	r22, r22
    49bc:	55 27       	eor	r21, r21
    49be:	44 27       	eor	r20, r20
    49c0:	82 81       	ldd	r24, Z+2	; 0x02
    49c2:	90 e0       	ldi	r25, 0x00	; 0
    49c4:	a0 e0       	ldi	r26, 0x00	; 0
    49c6:	b0 e0       	ldi	r27, 0x00	; 0
    49c8:	dc 01       	movw	r26, r24
    49ca:	99 27       	eor	r25, r25
    49cc:	88 27       	eor	r24, r24
    49ce:	48 2b       	or	r20, r24
    49d0:	59 2b       	or	r21, r25
    49d2:	6a 2b       	or	r22, r26
    49d4:	7b 2b       	or	r23, r27
    49d6:	80 81       	ld	r24, Z
    49d8:	90 e0       	ldi	r25, 0x00	; 0
    49da:	a0 e0       	ldi	r26, 0x00	; 0
    49dc:	b0 e0       	ldi	r27, 0x00	; 0
    49de:	84 2b       	or	r24, r20
    49e0:	95 2b       	or	r25, r21
    49e2:	a6 2b       	or	r26, r22
    49e4:	b7 2b       	or	r27, r23
    49e6:	31 80       	ldd	r3, Z+1	; 0x01
    49e8:	22 24       	eor	r2, r2
    49ea:	a1 01       	movw	r20, r2
    49ec:	60 e0       	ldi	r22, 0x00	; 0
    49ee:	70 e0       	ldi	r23, 0x00	; 0
    49f0:	84 2b       	or	r24, r20
    49f2:	95 2b       	or	r25, r21
    49f4:	a6 2b       	or	r26, r22
    49f6:	b7 2b       	or	r27, r23
    49f8:	bf 70       	andi	r27, 0x0F	; 15
    49fa:	00 97       	sbiw	r24, 0x00	; 0
    49fc:	a1 05       	cpc	r26, r1
    49fe:	b1 05       	cpc	r27, r1
    4a00:	29 f4       	brne	.+10     	; 0x4a0c <f_getfree+0x206>
    4a02:	08 94       	sec
    4a04:	41 1c       	adc	r4, r1
    4a06:	51 1c       	adc	r5, r1
    4a08:	61 1c       	adc	r6, r1
    4a0a:	71 1c       	adc	r7, r1
						p += 4; i -= 4;
    4a0c:	34 96       	adiw	r30, 0x04	; 4
    4a0e:	04 50       	subi	r16, 0x04	; 4
    4a10:	10 40       	sbci	r17, 0x00	; 0
    4a12:	20 40       	sbci	r18, 0x00	; 0
    4a14:	30 40       	sbci	r19, 0x00	; 0
					}
				} while (--clst);
    4a16:	08 94       	sec
    4a18:	c1 08       	sbc	r12, r1
    4a1a:	d1 08       	sbc	r13, r1
    4a1c:	e1 08       	sbc	r14, r1
    4a1e:	f1 08       	sbc	r15, r1
    4a20:	c1 14       	cp	r12, r1
    4a22:	d1 04       	cpc	r13, r1
    4a24:	e1 04       	cpc	r14, r1
    4a26:	f1 04       	cpc	r15, r1
    4a28:	09 f0       	breq	.+2      	; 0x4a2c <f_getfree+0x226>
    4a2a:	89 cf       	rjmp	.-238    	; 0x493e <f_getfree+0x138>
    4a2c:	08 c0       	rjmp	.+16     	; 0x4a3e <f_getfree+0x238>
			n = 0;
			if (fat == FS_FAT12) {
				clst = 2;
				do {
					stat = get_fat(fs, clst);
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
    4a2e:	bb 24       	eor	r11, r11
    4a30:	b3 94       	inc	r11
    4a32:	05 c0       	rjmp	.+10     	; 0x4a3e <f_getfree+0x238>
					if (stat == 1) { res = FR_INT_ERR; break; }
    4a34:	bb 24       	eor	r11, r11
    4a36:	68 94       	set
    4a38:	b1 f8       	bld	r11, 1
    4a3a:	01 c0       	rjmp	.+2      	; 0x4a3e <f_getfree+0x238>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
    4a3c:	b8 2e       	mov	r11, r24
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
    4a3e:	d4 01       	movw	r26, r8
    4a40:	1e 96       	adiw	r26, 0x0e	; 14
    4a42:	4d 92       	st	X+, r4
    4a44:	5d 92       	st	X+, r5
    4a46:	6d 92       	st	X+, r6
    4a48:	7c 92       	st	X, r7
    4a4a:	51 97       	sbiw	r26, 0x11	; 17
			if (fat == FS_FAT32) fs->fsi_flag = 1;
    4a4c:	b3 e0       	ldi	r27, 0x03	; 3
    4a4e:	ab 16       	cp	r10, r27
    4a50:	19 f4       	brne	.+6      	; 0x4a58 <f_getfree+0x252>
    4a52:	81 e0       	ldi	r24, 0x01	; 1
    4a54:	f4 01       	movw	r30, r8
    4a56:	85 83       	std	Z+5, r24	; 0x05
			*nclst = n;
    4a58:	af 81       	ldd	r26, Y+7	; 0x07
    4a5a:	b8 85       	ldd	r27, Y+8	; 0x08
    4a5c:	4d 92       	st	X+, r4
    4a5e:	5d 92       	st	X+, r5
    4a60:	6d 92       	st	X+, r6
    4a62:	7c 92       	st	X, r7
    4a64:	13 97       	sbiw	r26, 0x03	; 3
		}
	}
	LEAVE_FF(fs, res);
}
    4a66:	8b 2d       	mov	r24, r11
    4a68:	2c 96       	adiw	r28, 0x0c	; 12
    4a6a:	0f b6       	in	r0, 0x3f	; 63
    4a6c:	f8 94       	cli
    4a6e:	de bf       	out	0x3e, r29	; 62
    4a70:	0f be       	out	0x3f, r0	; 63
    4a72:	cd bf       	out	0x3d, r28	; 61
    4a74:	df 91       	pop	r29
    4a76:	cf 91       	pop	r28
    4a78:	1f 91       	pop	r17
    4a7a:	0f 91       	pop	r16
    4a7c:	ff 90       	pop	r15
    4a7e:	ef 90       	pop	r14
    4a80:	df 90       	pop	r13
    4a82:	cf 90       	pop	r12
    4a84:	bf 90       	pop	r11
    4a86:	af 90       	pop	r10
    4a88:	9f 90       	pop	r9
    4a8a:	8f 90       	pop	r8
    4a8c:	7f 90       	pop	r7
    4a8e:	6f 90       	pop	r6
    4a90:	5f 90       	pop	r5
    4a92:	4f 90       	pop	r4
    4a94:	3f 90       	pop	r3
    4a96:	2f 90       	pop	r2
    4a98:	08 95       	ret

00004a9a <f_truncate>:
/*-----------------------------------------------------------------------*/

FRESULT f_truncate (
	FIL *fp		/* Pointer to the file object */
)
{
    4a9a:	cf 92       	push	r12
    4a9c:	df 92       	push	r13
    4a9e:	ef 92       	push	r14
    4aa0:	ff 92       	push	r15
    4aa2:	0f 93       	push	r16
    4aa4:	1f 93       	push	r17
    4aa6:	cf 93       	push	r28
    4aa8:	df 93       	push	r29
    4aaa:	ec 01       	movw	r28, r24
	FRESULT res;
	DWORD ncl;


	if (!fp) return FR_INVALID_OBJECT;
    4aac:	00 97       	sbiw	r24, 0x00	; 0
    4aae:	09 f4       	brne	.+2      	; 0x4ab2 <f_truncate+0x18>
    4ab0:	69 c0       	rjmp	.+210    	; 0x4b84 <f_truncate+0xea>

	res = validate(fp);						/* Check validity of the object */
    4ab2:	0e 94 28 0b 	call	0x1650	; 0x1650 <validate>
	if (res == FR_OK) {
    4ab6:	88 23       	and	r24, r24
    4ab8:	09 f0       	breq	.+2      	; 0x4abc <f_truncate+0x22>
    4aba:	65 c0       	rjmp	.+202    	; 0x4b86 <f_truncate+0xec>
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
    4abc:	9c 81       	ldd	r25, Y+4	; 0x04
    4abe:	99 23       	and	r25, r25
    4ac0:	24 f0       	brlt	.+8      	; 0x4aca <f_truncate+0x30>
			res = FR_INT_ERR;
		} else {
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
    4ac2:	91 fd       	sbrc	r25, 1
    4ac4:	69 c0       	rjmp	.+210    	; 0x4b98 <f_truncate+0xfe>
				res = FR_DENIED;
    4ac6:	87 e0       	ldi	r24, 0x07	; 7
    4ac8:	5e c0       	rjmp	.+188    	; 0x4b86 <f_truncate+0xec>
	if (!fp) return FR_INVALID_OBJECT;

	res = validate(fp);						/* Check validity of the object */
	if (res == FR_OK) {
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
			res = FR_INT_ERR;
    4aca:	82 e0       	ldi	r24, 0x02	; 2
    4acc:	5c c0       	rjmp	.+184    	; 0x4b86 <f_truncate+0xec>
				res = FR_DENIED;
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
    4ace:	4a 87       	std	Y+10, r20	; 0x0a
    4ad0:	5b 87       	std	Y+11, r21	; 0x0b
    4ad2:	6c 87       	std	Y+12, r22	; 0x0c
    4ad4:	7d 87       	std	Y+13, r23	; 0x0d
			fp->flag |= FA__WRITTEN;
    4ad6:	8c 81       	ldd	r24, Y+4	; 0x04
    4ad8:	80 62       	ori	r24, 0x20	; 32
    4ada:	8c 83       	std	Y+4, r24	; 0x04
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
    4adc:	41 15       	cp	r20, r1
    4ade:	51 05       	cpc	r21, r1
    4ae0:	61 05       	cpc	r22, r1
    4ae2:	71 05       	cpc	r23, r1
    4ae4:	69 f4       	brne	.+26     	; 0x4b00 <f_truncate+0x66>
				res = remove_chain(fp->fs, fp->sclust);
    4ae6:	4e 85       	ldd	r20, Y+14	; 0x0e
    4ae8:	5f 85       	ldd	r21, Y+15	; 0x0f
    4aea:	68 89       	ldd	r22, Y+16	; 0x10
    4aec:	79 89       	ldd	r23, Y+17	; 0x11
    4aee:	88 81       	ld	r24, Y
    4af0:	99 81       	ldd	r25, Y+1	; 0x01
    4af2:	0e 94 cc 19 	call	0x3398	; 0x3398 <remove_chain>
				fp->sclust = 0;
    4af6:	1e 86       	std	Y+14, r1	; 0x0e
    4af8:	1f 86       	std	Y+15, r1	; 0x0f
    4afa:	18 8a       	std	Y+16, r1	; 0x10
    4afc:	19 8a       	std	Y+17, r1	; 0x11
    4afe:	3c c0       	rjmp	.+120    	; 0x4b78 <f_truncate+0xde>
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
    4b00:	4a 89       	ldd	r20, Y+18	; 0x12
    4b02:	5b 89       	ldd	r21, Y+19	; 0x13
    4b04:	6c 89       	ldd	r22, Y+20	; 0x14
    4b06:	7d 89       	ldd	r23, Y+21	; 0x15
    4b08:	88 81       	ld	r24, Y
    4b0a:	99 81       	ldd	r25, Y+1	; 0x01
    4b0c:	0e 94 82 11 	call	0x2304	; 0x2304 <get_fat>
    4b10:	6b 01       	movw	r12, r22
    4b12:	7c 01       	movw	r14, r24
				res = FR_OK;
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
    4b14:	81 e0       	ldi	r24, 0x01	; 1
    4b16:	c8 16       	cp	r12, r24
    4b18:	d1 04       	cpc	r13, r1
    4b1a:	e1 04       	cpc	r14, r1
    4b1c:	f1 04       	cpc	r15, r1
    4b1e:	09 f4       	brne	.+2      	; 0x4b22 <f_truncate+0x88>
    4b20:	4a c0       	rjmp	.+148    	; 0x4bb6 <f_truncate+0x11c>
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
				res = remove_chain(fp->fs, fp->sclust);
				fp->sclust = 0;
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
				res = FR_OK;
    4b22:	81 e0       	ldi	r24, 0x01	; 1
    4b24:	9f ef       	ldi	r25, 0xFF	; 255
    4b26:	c9 16       	cp	r12, r25
    4b28:	9f ef       	ldi	r25, 0xFF	; 255
    4b2a:	d9 06       	cpc	r13, r25
    4b2c:	9f ef       	ldi	r25, 0xFF	; 255
    4b2e:	e9 06       	cpc	r14, r25
    4b30:	9f ef       	ldi	r25, 0xFF	; 255
    4b32:	f9 06       	cpc	r15, r25
    4b34:	09 f0       	breq	.+2      	; 0x4b38 <f_truncate+0x9e>
    4b36:	80 e0       	ldi	r24, 0x00	; 0
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
				if (res == FR_OK && ncl < fp->fs->n_fatent) {
    4b38:	88 23       	and	r24, r24
    4b3a:	01 f5       	brne	.+64     	; 0x4b7c <f_truncate+0xe2>
    4b3c:	e8 81       	ld	r30, Y
    4b3e:	f9 81       	ldd	r31, Y+1	; 0x01
    4b40:	42 8d       	ldd	r20, Z+26	; 0x1a
    4b42:	53 8d       	ldd	r21, Z+27	; 0x1b
    4b44:	64 8d       	ldd	r22, Z+28	; 0x1c
    4b46:	75 8d       	ldd	r23, Z+29	; 0x1d
    4b48:	c4 16       	cp	r12, r20
    4b4a:	d5 06       	cpc	r13, r21
    4b4c:	e6 06       	cpc	r14, r22
    4b4e:	f7 06       	cpc	r15, r23
    4b50:	d0 f4       	brcc	.+52     	; 0x4b86 <f_truncate+0xec>
					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
    4b52:	4a 89       	ldd	r20, Y+18	; 0x12
    4b54:	5b 89       	ldd	r21, Y+19	; 0x13
    4b56:	6c 89       	ldd	r22, Y+20	; 0x14
    4b58:	7d 89       	ldd	r23, Y+21	; 0x15
    4b5a:	cf 01       	movw	r24, r30
    4b5c:	0f ef       	ldi	r16, 0xFF	; 255
    4b5e:	1f ef       	ldi	r17, 0xFF	; 255
    4b60:	2f ef       	ldi	r18, 0xFF	; 255
    4b62:	3f e0       	ldi	r19, 0x0F	; 15
    4b64:	0e 94 9c 13 	call	0x2738	; 0x2738 <put_fat>
					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
    4b68:	88 23       	and	r24, r24
    4b6a:	41 f4       	brne	.+16     	; 0x4b7c <f_truncate+0xe2>
    4b6c:	88 81       	ld	r24, Y
    4b6e:	99 81       	ldd	r25, Y+1	; 0x01
    4b70:	b7 01       	movw	r22, r14
    4b72:	a6 01       	movw	r20, r12
    4b74:	0e 94 cc 19 	call	0x3398	; 0x3398 <remove_chain>
				}
			}
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
    4b78:	88 23       	and	r24, r24
    4b7a:	29 f0       	breq	.+10     	; 0x4b86 <f_truncate+0xec>
    4b7c:	9c 81       	ldd	r25, Y+4	; 0x04
    4b7e:	90 68       	ori	r25, 0x80	; 128
    4b80:	9c 83       	std	Y+4, r25	; 0x04
    4b82:	01 c0       	rjmp	.+2      	; 0x4b86 <f_truncate+0xec>
{
	FRESULT res;
	DWORD ncl;


	if (!fp) return FR_INVALID_OBJECT;
    4b84:	89 e0       	ldi	r24, 0x09	; 9
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
	}

	LEAVE_FF(fp->fs, res);
}
    4b86:	df 91       	pop	r29
    4b88:	cf 91       	pop	r28
    4b8a:	1f 91       	pop	r17
    4b8c:	0f 91       	pop	r16
    4b8e:	ff 90       	pop	r15
    4b90:	ef 90       	pop	r14
    4b92:	df 90       	pop	r13
    4b94:	cf 90       	pop	r12
    4b96:	08 95       	ret
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
				res = FR_DENIED;
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
    4b98:	4e 81       	ldd	r20, Y+6	; 0x06
    4b9a:	5f 81       	ldd	r21, Y+7	; 0x07
    4b9c:	68 85       	ldd	r22, Y+8	; 0x08
    4b9e:	79 85       	ldd	r23, Y+9	; 0x09
    4ba0:	0a 85       	ldd	r16, Y+10	; 0x0a
    4ba2:	1b 85       	ldd	r17, Y+11	; 0x0b
    4ba4:	2c 85       	ldd	r18, Y+12	; 0x0c
    4ba6:	3d 85       	ldd	r19, Y+13	; 0x0d
    4ba8:	40 17       	cp	r20, r16
    4baa:	51 07       	cpc	r21, r17
    4bac:	62 07       	cpc	r22, r18
    4bae:	73 07       	cpc	r23, r19
    4bb0:	08 f4       	brcc	.+2      	; 0x4bb4 <f_truncate+0x11a>
    4bb2:	8d cf       	rjmp	.-230    	; 0x4ace <f_truncate+0x34>
    4bb4:	e8 cf       	rjmp	.-48     	; 0x4b86 <f_truncate+0xec>
				fp->sclust = 0;
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
				res = FR_OK;
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
    4bb6:	82 e0       	ldi	r24, 0x02	; 2
    4bb8:	e1 cf       	rjmp	.-62     	; 0x4b7c <f_truncate+0xe2>

00004bba <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR *path		/* Pointer to the file or directory path */
)
{
    4bba:	cf 92       	push	r12
    4bbc:	df 92       	push	r13
    4bbe:	ef 92       	push	r14
    4bc0:	ff 92       	push	r15
    4bc2:	1f 93       	push	r17
    4bc4:	cf 93       	push	r28
    4bc6:	df 93       	push	r29
    4bc8:	cd b7       	in	r28, 0x3d	; 61
    4bca:	de b7       	in	r29, 0x3e	; 62
    4bcc:	ea 97       	sbiw	r28, 0x3a	; 58
    4bce:	0f b6       	in	r0, 0x3f	; 63
    4bd0:	f8 94       	cli
    4bd2:	de bf       	out	0x3e, r29	; 62
    4bd4:	0f be       	out	0x3f, r0	; 63
    4bd6:	cd bf       	out	0x3d, r28	; 61
    4bd8:	9a af       	sts	0x7a, r25
    4bda:	89 af       	sts	0x79, r24
	BYTE *dir;
	DWORD dclst;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4bdc:	ce 01       	movw	r24, r28
    4bde:	c9 96       	adiw	r24, 0x39	; 57
    4be0:	be 01       	movw	r22, r28
    4be2:	6f 5f       	subi	r22, 0xFF	; 255
    4be4:	7f 4f       	sbci	r23, 0xFF	; 255
    4be6:	41 e0       	ldi	r20, 0x01	; 1
    4be8:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <chk_mounted>
	if (res == FR_OK) {
    4bec:	88 23       	and	r24, r24
    4bee:	09 f0       	breq	.+2      	; 0x4bf2 <f_unlink+0x38>
    4bf0:	63 c0       	rjmp	.+198    	; 0x4cb8 <f_unlink+0xfe>
		INIT_BUF(dj);
    4bf2:	ce 01       	movw	r24, r28
    4bf4:	8d 96       	adiw	r24, 0x2d	; 45
    4bf6:	9e 8b       	std	Y+22, r25	; 0x16
    4bf8:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the file path */
    4bfa:	69 ad       	sts	0x69, r22
    4bfc:	7a ad       	sts	0x6a, r23
    4bfe:	ce 01       	movw	r24, r28
    4c00:	01 96       	adiw	r24, 0x01	; 1
    4c02:	0e 94 14 17 	call	0x2e28	; 0x2e28 <follow_path>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    4c06:	88 23       	and	r24, r24
    4c08:	09 f0       	breq	.+2      	; 0x4c0c <f_unlink+0x52>
    4c0a:	56 c0       	rjmp	.+172    	; 0x4cb8 <f_unlink+0xfe>
    4c0c:	ed 89       	ldd	r30, Y+21	; 0x15
    4c0e:	fe 89       	ldd	r31, Y+22	; 0x16
    4c10:	83 85       	ldd	r24, Z+11	; 0x0b
    4c12:	85 ff       	sbrs	r24, 5
    4c14:	5f c0       	rjmp	.+190    	; 0x4cd4 <f_unlink+0x11a>
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
    4c16:	86 e0       	ldi	r24, 0x06	; 6
    4c18:	4f c0       	rjmp	.+158    	; 0x4cb8 <f_unlink+0xfe>
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
    4c1a:	fb 01       	movw	r30, r22
    4c1c:	13 85       	ldd	r17, Z+11	; 0x0b
    4c1e:	10 ff       	sbrs	r17, 0
    4c20:	60 c0       	rjmp	.+192    	; 0x4ce2 <f_unlink+0x128>
					res = FR_DENIED;		/* Cannot remove R/O object */
    4c22:	87 e0       	ldi	r24, 0x07	; 7
    4c24:	49 c0       	rjmp	.+146    	; 0x4cb8 <f_unlink+0xfe>
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
    4c26:	86 e0       	ldi	r24, 0x06	; 6
    4c28:	47 c0       	rjmp	.+142    	; 0x4cb8 <f_unlink+0xfe>
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = ld_clust(dj.fs, dir);
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
				if (dclst < 2) {
    4c2a:	f2 e0       	ldi	r31, 0x02	; 2
    4c2c:	cf 16       	cp	r12, r31
    4c2e:	d1 04       	cpc	r13, r1
    4c30:	e1 04       	cpc	r14, r1
    4c32:	f1 04       	cpc	r15, r1
    4c34:	08 f4       	brcc	.+2      	; 0x4c38 <f_unlink+0x7e>
    4c36:	5e c0       	rjmp	.+188    	; 0x4cf4 <f_unlink+0x13a>
					res = FR_INT_ERR;
				} else {
					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
    4c38:	ce 01       	movw	r24, r28
    4c3a:	47 96       	adiw	r24, 0x17	; 23
    4c3c:	be 01       	movw	r22, r28
    4c3e:	6f 5f       	subi	r22, 0xFF	; 255
    4c40:	7f 4f       	sbci	r23, 0xFF	; 255
    4c42:	26 e1       	ldi	r18, 0x16	; 22
    4c44:	30 e0       	ldi	r19, 0x00	; 0
    4c46:	40 e0       	ldi	r20, 0x00	; 0
    4c48:	50 e0       	ldi	r21, 0x00	; 0
    4c4a:	0e 94 42 0a 	call	0x1484	; 0x1484 <mem_cpy>
					sdj.sclust = dclst;
    4c4e:	cd 8e       	std	Y+29, r12	; 0x1d
    4c50:	de 8e       	std	Y+30, r13	; 0x1e
    4c52:	ef 8e       	std	Y+31, r14	; 0x1f
    4c54:	f8 a2       	lds	r31, 0x98
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
    4c56:	ce 01       	movw	r24, r28
    4c58:	47 96       	adiw	r24, 0x17	; 23
    4c5a:	62 e0       	ldi	r22, 0x02	; 2
    4c5c:	70 e0       	ldi	r23, 0x00	; 0
    4c5e:	0e 94 b9 12 	call	0x2572	; 0x2572 <dir_sdi>
					if (res == FR_OK) {
    4c62:	88 23       	and	r24, r24
    4c64:	49 f5       	brne	.+82     	; 0x4cb8 <f_unlink+0xfe>
						res = dir_read(&sdj);
    4c66:	ce 01       	movw	r24, r28
    4c68:	47 96       	adiw	r24, 0x17	; 23
    4c6a:	0e 94 9c 19 	call	0x3338	; 0x3338 <dir_read>
						if (res == FR_OK		/* Not empty dir */
    4c6e:	88 23       	and	r24, r24
    4c70:	71 f0       	breq	.+28     	; 0x4c8e <f_unlink+0xd4>
#if _FS_RPATH
						|| dclst == dj.fs->cdir	/* Current dir */
    4c72:	e9 81       	ldd	r30, Y+1	; 0x01
    4c74:	fa 81       	ldd	r31, Y+2	; 0x02
    4c76:	46 89       	ldd	r20, Z+22	; 0x16
    4c78:	57 89       	ldd	r21, Z+23	; 0x17
    4c7a:	60 8d       	ldd	r22, Z+24	; 0x18
    4c7c:	71 8d       	ldd	r23, Z+25	; 0x19
    4c7e:	4c 15       	cp	r20, r12
    4c80:	5d 05       	cpc	r21, r13
    4c82:	6e 05       	cpc	r22, r14
    4c84:	7f 05       	cpc	r23, r15
    4c86:	29 f0       	breq	.+10     	; 0x4c92 <f_unlink+0xd8>
#endif
						) res = FR_DENIED;
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
    4c88:	84 30       	cpi	r24, 0x04	; 4
    4c8a:	b1 f1       	breq	.+108    	; 0x4cf8 <f_unlink+0x13e>
    4c8c:	15 c0       	rjmp	.+42     	; 0x4cb8 <f_unlink+0xfe>
					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
					sdj.sclust = dclst;
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
					if (res == FR_OK) {
						res = dir_read(&sdj);
						if (res == FR_OK		/* Not empty dir */
    4c8e:	87 e0       	ldi	r24, 0x07	; 7
    4c90:	13 c0       	rjmp	.+38     	; 0x4cb8 <f_unlink+0xfe>
#if _FS_RPATH
						|| dclst == dj.fs->cdir	/* Current dir */
    4c92:	87 e0       	ldi	r24, 0x07	; 7
    4c94:	11 c0       	rjmp	.+34     	; 0x4cb8 <f_unlink+0xfe>
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
				if (res == FR_OK) {
					if (dclst)				/* Remove the cluster chain if exist */
    4c96:	c1 14       	cp	r12, r1
    4c98:	d1 04       	cpc	r13, r1
    4c9a:	e1 04       	cpc	r14, r1
    4c9c:	f1 04       	cpc	r15, r1
    4c9e:	41 f0       	breq	.+16     	; 0x4cb0 <f_unlink+0xf6>
						res = remove_chain(dj.fs, dclst);
    4ca0:	89 81       	ldd	r24, Y+1	; 0x01
    4ca2:	9a 81       	ldd	r25, Y+2	; 0x02
    4ca4:	b7 01       	movw	r22, r14
    4ca6:	a6 01       	movw	r20, r12
    4ca8:	0e 94 cc 19 	call	0x3398	; 0x3398 <remove_chain>
					if (res == FR_OK) res = sync(dj.fs);
    4cac:	88 23       	and	r24, r24
    4cae:	21 f4       	brne	.+8      	; 0x4cb8 <f_unlink+0xfe>
    4cb0:	89 81       	ldd	r24, Y+1	; 0x01
    4cb2:	9a 81       	ldd	r25, Y+2	; 0x02
    4cb4:	0e 94 ba 10 	call	0x2174	; 0x2174 <sync>
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(dj.fs, res);
}
    4cb8:	ea 96       	adiw	r28, 0x3a	; 58
    4cba:	0f b6       	in	r0, 0x3f	; 63
    4cbc:	f8 94       	cli
    4cbe:	de bf       	out	0x3e, r29	; 62
    4cc0:	0f be       	out	0x3f, r0	; 63
    4cc2:	cd bf       	out	0x3d, r28	; 61
    4cc4:	df 91       	pop	r29
    4cc6:	cf 91       	pop	r28
    4cc8:	1f 91       	pop	r17
    4cca:	ff 90       	pop	r15
    4ccc:	ef 90       	pop	r14
    4cce:	df 90       	pop	r13
    4cd0:	cf 90       	pop	r12
    4cd2:	08 95       	ret
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
    4cd4:	6b 89       	ldd	r22, Y+19	; 0x13
    4cd6:	7c 89       	ldd	r23, Y+20	; 0x14
			if (!dir) {
    4cd8:	61 15       	cp	r22, r1
    4cda:	71 05       	cpc	r23, r1
    4cdc:	09 f0       	breq	.+2      	; 0x4ce0 <f_unlink+0x126>
    4cde:	9d cf       	rjmp	.-198    	; 0x4c1a <f_unlink+0x60>
    4ce0:	a2 cf       	rjmp	.-188    	; 0x4c26 <f_unlink+0x6c>
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = ld_clust(dj.fs, dir);
    4ce2:	89 81       	ldd	r24, Y+1	; 0x01
    4ce4:	9a 81       	ldd	r25, Y+2	; 0x02
    4ce6:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <ld_clust>
    4cea:	6b 01       	movw	r12, r22
    4cec:	7c 01       	movw	r14, r24
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
    4cee:	14 fd       	sbrc	r17, 4
    4cf0:	9c cf       	rjmp	.-200    	; 0x4c2a <f_unlink+0x70>
    4cf2:	02 c0       	rjmp	.+4      	; 0x4cf8 <f_unlink+0x13e>
				if (dclst < 2) {
					res = FR_INT_ERR;
    4cf4:	82 e0       	ldi	r24, 0x02	; 2
    4cf6:	e0 cf       	rjmp	.-64     	; 0x4cb8 <f_unlink+0xfe>
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
    4cf8:	ce 01       	movw	r24, r28
    4cfa:	01 96       	adiw	r24, 0x01	; 1
    4cfc:	0e 94 7e 13 	call	0x26fc	; 0x26fc <dir_remove>
				if (res == FR_OK) {
    4d00:	88 23       	and	r24, r24
    4d02:	49 f2       	breq	.-110    	; 0x4c96 <f_unlink+0xdc>
    4d04:	d9 cf       	rjmp	.-78     	; 0x4cb8 <f_unlink+0xfe>

00004d06 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR *path		/* Pointer to the directory path */
)
{
    4d06:	2f 92       	push	r2
    4d08:	3f 92       	push	r3
    4d0a:	4f 92       	push	r4
    4d0c:	5f 92       	push	r5
    4d0e:	6f 92       	push	r6
    4d10:	7f 92       	push	r7
    4d12:	8f 92       	push	r8
    4d14:	9f 92       	push	r9
    4d16:	af 92       	push	r10
    4d18:	bf 92       	push	r11
    4d1a:	cf 92       	push	r12
    4d1c:	df 92       	push	r13
    4d1e:	ef 92       	push	r14
    4d20:	ff 92       	push	r15
    4d22:	0f 93       	push	r16
    4d24:	1f 93       	push	r17
    4d26:	cf 93       	push	r28
    4d28:	df 93       	push	r29
    4d2a:	cd b7       	in	r28, 0x3d	; 61
    4d2c:	de b7       	in	r29, 0x3e	; 62
    4d2e:	a8 97       	sbiw	r28, 0x28	; 40
    4d30:	0f b6       	in	r0, 0x3f	; 63
    4d32:	f8 94       	cli
    4d34:	de bf       	out	0x3e, r29	; 62
    4d36:	0f be       	out	0x3f, r0	; 63
    4d38:	cd bf       	out	0x3d, r28	; 61
    4d3a:	9c a3       	lds	r25, 0x5c
    4d3c:	8b a3       	lds	r24, 0x5b
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tim = get_fattime();
    4d3e:	0e 94 48 11 	call	0x2290	; 0x2290 <get_fattime>
    4d42:	6b 01       	movw	r12, r22
    4d44:	7c 01       	movw	r14, r24
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4d46:	ce 01       	movw	r24, r28
    4d48:	83 96       	adiw	r24, 0x23	; 35
    4d4a:	be 01       	movw	r22, r28
    4d4c:	6f 5f       	subi	r22, 0xFF	; 255
    4d4e:	7f 4f       	sbci	r23, 0xFF	; 255
    4d50:	41 e0       	ldi	r20, 0x01	; 1
    4d52:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <chk_mounted>
    4d56:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    4d58:	88 23       	and	r24, r24
    4d5a:	09 f0       	breq	.+2      	; 0x4d5e <f_mkdir+0x58>
    4d5c:	f6 c0       	rjmp	.+492    	; 0x4f4a <f_mkdir+0x244>
		INIT_BUF(dj);
    4d5e:	ce 01       	movw	r24, r28
    4d60:	47 96       	adiw	r24, 0x17	; 23
    4d62:	9e 8b       	std	Y+22, r25	; 0x16
    4d64:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);			/* Follow the file path */
    4d66:	6b a1       	lds	r22, 0x4b
    4d68:	7c a1       	lds	r23, 0x4c
    4d6a:	ce 01       	movw	r24, r28
    4d6c:	01 96       	adiw	r24, 0x01	; 1
    4d6e:	0e 94 14 17 	call	0x2e28	; 0x2e28 <follow_path>
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
    4d72:	88 23       	and	r24, r24
    4d74:	49 f0       	breq	.+18     	; 0x4d88 <f_mkdir+0x82>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
    4d76:	84 30       	cpi	r24, 0x04	; 4
    4d78:	41 f4       	brne	.+16     	; 0x4d8a <f_mkdir+0x84>
    4d7a:	ed 89       	ldd	r30, Y+21	; 0x15
    4d7c:	fe 89       	ldd	r31, Y+22	; 0x16
    4d7e:	83 85       	ldd	r24, Z+11	; 0x0b
    4d80:	85 ff       	sbrs	r24, 5
    4d82:	fd c0       	rjmp	.+506    	; 0x4f7e <f_mkdir+0x278>
			res = FR_INVALID_NAME;
    4d84:	86 e0       	ldi	r24, 0x06	; 6
    4d86:	01 c0       	rjmp	.+2      	; 0x4d8a <f_mkdir+0x84>

	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
    4d88:	88 e0       	ldi	r24, 0x08	; 8
				ST_DWORD(dir+DIR_WrtTime, tim);
				st_clust(dir, dcl);
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
    4d8a:	18 2f       	mov	r17, r24
    4d8c:	de c0       	rjmp	.+444    	; 0x4f4a <f_mkdir+0x244>
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
			if (dcl == 1) res = FR_INT_ERR;
    4d8e:	81 e0       	ldi	r24, 0x01	; 1
    4d90:	48 16       	cp	r4, r24
    4d92:	51 04       	cpc	r5, r1
    4d94:	61 04       	cpc	r6, r1
    4d96:	71 04       	cpc	r7, r1
    4d98:	09 f4       	brne	.+2      	; 0x4d9c <f_mkdir+0x96>
    4d9a:	01 c1       	rjmp	.+514    	; 0x4f9e <f_mkdir+0x298>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
    4d9c:	ef ef       	ldi	r30, 0xFF	; 255
    4d9e:	4e 16       	cp	r4, r30
    4da0:	ef ef       	ldi	r30, 0xFF	; 255
    4da2:	5e 06       	cpc	r5, r30
    4da4:	ef ef       	ldi	r30, 0xFF	; 255
    4da6:	6e 06       	cpc	r6, r30
    4da8:	ef ef       	ldi	r30, 0xFF	; 255
    4daa:	7e 06       	cpc	r7, r30
    4dac:	09 f4       	brne	.+2      	; 0x4db0 <f_mkdir+0xaa>
    4dae:	f9 c0       	rjmp	.+498    	; 0x4fa2 <f_mkdir+0x29c>
    4db0:	01 c0       	rjmp	.+2      	; 0x4db4 <f_mkdir+0xae>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
    4db2:	17 e0       	ldi	r17, 0x07	; 7
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
			if (res == FR_OK)					/* Flush FAT */
    4db4:	11 23       	and	r17, r17
    4db6:	09 f0       	breq	.+2      	; 0x4dba <f_mkdir+0xb4>
    4db8:	a8 c0       	rjmp	.+336    	; 0x4f0a <f_mkdir+0x204>
				res = move_window(dj.fs, 0);
    4dba:	89 81       	ldd	r24, Y+1	; 0x01
    4dbc:	9a 81       	ldd	r25, Y+2	; 0x02
    4dbe:	40 e0       	ldi	r20, 0x00	; 0
    4dc0:	50 e0       	ldi	r21, 0x00	; 0
    4dc2:	ba 01       	movw	r22, r20
    4dc4:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
    4dc8:	18 2f       	mov	r17, r24
			if (res == FR_OK) {					/* Initialize the new directory table */
    4dca:	88 23       	and	r24, r24
    4dcc:	09 f0       	breq	.+2      	; 0x4dd0 <f_mkdir+0xca>
    4dce:	9d c0       	rjmp	.+314    	; 0x4f0a <f_mkdir+0x204>
				dsc = clust2sect(dj.fs, dcl);
    4dd0:	09 81       	ldd	r16, Y+1	; 0x01
    4dd2:	1a 81       	ldd	r17, Y+2	; 0x02
    4dd4:	c8 01       	movw	r24, r16
    4dd6:	b3 01       	movw	r22, r6
    4dd8:	a2 01       	movw	r20, r4
    4dda:	0e 94 4c 11 	call	0x2298	; 0x2298 <clust2sect>
    4dde:	4b 01       	movw	r8, r22
    4de0:	5c 01       	movw	r10, r24
				dir = dj.fs->win;
    4de2:	0f 2e       	mov	r0, r31
    4de4:	f2 e3       	ldi	r31, 0x32	; 50
    4de6:	2f 2e       	mov	r2, r31
    4de8:	33 24       	eor	r3, r3
    4dea:	f0 2d       	mov	r31, r0
    4dec:	20 0e       	add	r2, r16
    4dee:	31 1e       	adc	r3, r17
				mem_set(dir, 0, SS(dj.fs));
    4df0:	c1 01       	movw	r24, r2
    4df2:	60 e0       	ldi	r22, 0x00	; 0
    4df4:	70 e0       	ldi	r23, 0x00	; 0
    4df6:	20 e0       	ldi	r18, 0x00	; 0
    4df8:	32 e0       	ldi	r19, 0x02	; 2
    4dfa:	40 e0       	ldi	r20, 0x00	; 0
    4dfc:	50 e0       	ldi	r21, 0x00	; 0
    4dfe:	0e 94 57 0a 	call	0x14ae	; 0x14ae <mem_set>
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
    4e02:	c1 01       	movw	r24, r2
    4e04:	60 e2       	ldi	r22, 0x20	; 32
    4e06:	70 e0       	ldi	r23, 0x00	; 0
    4e08:	2b e0       	ldi	r18, 0x0B	; 11
    4e0a:	30 e0       	ldi	r19, 0x00	; 0
    4e0c:	40 e0       	ldi	r20, 0x00	; 0
    4e0e:	50 e0       	ldi	r21, 0x00	; 0
    4e10:	0e 94 57 0a 	call	0x14ae	; 0x14ae <mem_set>
				dir[DIR_Name] = '.';
    4e14:	8e e2       	ldi	r24, 0x2E	; 46
    4e16:	f8 01       	movw	r30, r16
    4e18:	82 ab       	sts	0x52, r24
				dir[DIR_Attr] = AM_DIR;
    4e1a:	80 e1       	ldi	r24, 0x10	; 16
    4e1c:	85 af       	sts	0x75, r24
				ST_DWORD(dir+DIR_WrtTime, tim);
    4e1e:	cd a2       	lds	r28, 0x9d
    4e20:	e8 5b       	subi	r30, 0xB8	; 184
    4e22:	ff 4f       	sbci	r31, 0xFF	; 255
    4e24:	c0 82       	st	Z, r12
    4e26:	8d 2d       	mov	r24, r13
    4e28:	99 27       	eor	r25, r25
    4e2a:	8e a3       	lds	r24, 0x5e
    4e2c:	f8 01       	movw	r30, r16
    4e2e:	e7 5b       	subi	r30, 0xB7	; 183
    4e30:	ff 4f       	sbci	r31, 0xFF	; 255
    4e32:	80 83       	st	Z, r24
    4e34:	c7 01       	movw	r24, r14
    4e36:	aa 27       	eor	r26, r26
    4e38:	bb 27       	eor	r27, r27
    4e3a:	8f a3       	lds	r24, 0x5f
    4e3c:	f8 01       	movw	r30, r16
    4e3e:	e6 5b       	subi	r30, 0xB6	; 182
    4e40:	ff 4f       	sbci	r31, 0xFF	; 255
    4e42:	80 83       	st	Z, r24
    4e44:	cf 2c       	mov	r12, r15
    4e46:	dd 24       	eor	r13, r13
    4e48:	ee 24       	eor	r14, r14
    4e4a:	ff 24       	eor	r15, r15
    4e4c:	c8 a6       	lds	r28, 0xb8
    4e4e:	f8 01       	movw	r30, r16
    4e50:	e5 5b       	subi	r30, 0xB5	; 181
    4e52:	ff 4f       	sbci	r31, 0xFF	; 255
    4e54:	c0 82       	st	Z, r12
				st_clust(dir, dcl);
    4e56:	c1 01       	movw	r24, r2
    4e58:	b3 01       	movw	r22, r6
    4e5a:	a2 01       	movw	r20, r4
    4e5c:	0e 94 8d 0a 	call	0x151a	; 0x151a <st_clust>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
    4e60:	0f 2e       	mov	r0, r31
    4e62:	f2 e5       	ldi	r31, 0x52	; 82
    4e64:	cf 2e       	mov	r12, r31
    4e66:	dd 24       	eor	r13, r13
    4e68:	f0 2d       	mov	r31, r0
    4e6a:	c0 0e       	add	r12, r16
    4e6c:	d1 1e       	adc	r13, r17
    4e6e:	c6 01       	movw	r24, r12
    4e70:	b1 01       	movw	r22, r2
    4e72:	20 e2       	ldi	r18, 0x20	; 32
    4e74:	30 e0       	ldi	r19, 0x00	; 0
    4e76:	40 e0       	ldi	r20, 0x00	; 0
    4e78:	50 e0       	ldi	r21, 0x00	; 0
    4e7a:	0e 94 42 0a 	call	0x1484	; 0x1484 <mem_cpy>
				dir[33] = '.'; pcl = dj.sclust;
    4e7e:	f8 01       	movw	r30, r16
    4e80:	ed 5a       	subi	r30, 0xAD	; 173
    4e82:	ff 4f       	sbci	r31, 0xFF	; 255
    4e84:	8e e2       	ldi	r24, 0x2E	; 46
    4e86:	80 83       	st	Z, r24
    4e88:	4f 81       	ldd	r20, Y+7	; 0x07
    4e8a:	58 85       	ldd	r21, Y+8	; 0x08
    4e8c:	69 85       	ldd	r22, Y+9	; 0x09
    4e8e:	7a 85       	ldd	r23, Y+10	; 0x0a
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
    4e90:	e9 81       	ldd	r30, Y+1	; 0x01
    4e92:	fa 81       	ldd	r31, Y+2	; 0x02
    4e94:	80 81       	ld	r24, Z
    4e96:	83 30       	cpi	r24, 0x03	; 3
    4e98:	61 f4       	brne	.+24     	; 0x4eb2 <f_mkdir+0x1ac>
    4e9a:	86 a1       	lds	r24, 0x46
    4e9c:	97 a1       	lds	r25, 0x47
    4e9e:	a0 a5       	lds	r26, 0x60
    4ea0:	b1 a5       	lds	r27, 0x61
    4ea2:	84 17       	cp	r24, r20
    4ea4:	95 07       	cpc	r25, r21
    4ea6:	a6 07       	cpc	r26, r22
    4ea8:	b7 07       	cpc	r27, r23
    4eaa:	19 f4       	brne	.+6      	; 0x4eb2 <f_mkdir+0x1ac>
					pcl = 0;
    4eac:	40 e0       	ldi	r20, 0x00	; 0
    4eae:	50 e0       	ldi	r21, 0x00	; 0
    4eb0:	ba 01       	movw	r22, r20
				st_clust(dir+SZ_DIR, pcl);
    4eb2:	c6 01       	movw	r24, r12
    4eb4:	0e 94 8d 0a 	call	0x151a	; 0x151a <st_clust>
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
    4eb8:	e9 81       	ldd	r30, Y+1	; 0x01
    4eba:	fa 81       	ldd	r31, Y+2	; 0x02
    4ebc:	02 81       	ldd	r16, Z+2	; 0x02
    4ebe:	00 23       	and	r16, r16
    4ec0:	09 f4       	brne	.+2      	; 0x4ec4 <f_mkdir+0x1be>
    4ec2:	71 c0       	rjmp	.+226    	; 0x4fa6 <f_mkdir+0x2a0>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
    4ec4:	cc 24       	eor	r12, r12
    4ec6:	c3 94       	inc	r12
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
    4ec8:	89 81       	ldd	r24, Y+1	; 0x01
    4eca:	9a 81       	ldd	r25, Y+2	; 0x02
    4ecc:	fc 01       	movw	r30, r24
    4ece:	86 a6       	lds	r24, 0xb6
    4ed0:	97 a6       	lds	r25, 0xb7
    4ed2:	a0 aa       	sts	0x90, r26
    4ed4:	b1 aa       	sts	0x91, r27
    4ed6:	08 94       	sec
    4ed8:	81 1c       	adc	r8, r1
    4eda:	91 1c       	adc	r9, r1
    4edc:	a1 1c       	adc	r10, r1
    4ede:	b1 1c       	adc	r11, r1
					dj.fs->wflag = 1;
    4ee0:	c4 82       	std	Z+4, r12	; 0x04
					res = move_window(dj.fs, 0);
    4ee2:	40 e0       	ldi	r20, 0x00	; 0
    4ee4:	50 e0       	ldi	r21, 0x00	; 0
    4ee6:	ba 01       	movw	r22, r20
    4ee8:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
    4eec:	18 2f       	mov	r17, r24
					if (res != FR_OK) break;
    4eee:	88 23       	and	r24, r24
    4ef0:	61 f4       	brne	.+24     	; 0x4f0a <f_mkdir+0x204>
					mem_set(dir, 0, SS(dj.fs));
    4ef2:	c1 01       	movw	r24, r2
    4ef4:	60 e0       	ldi	r22, 0x00	; 0
    4ef6:	70 e0       	ldi	r23, 0x00	; 0
    4ef8:	20 e0       	ldi	r18, 0x00	; 0
    4efa:	32 e0       	ldi	r19, 0x02	; 2
    4efc:	40 e0       	ldi	r20, 0x00	; 0
    4efe:	50 e0       	ldi	r21, 0x00	; 0
    4f00:	0e 94 57 0a 	call	0x14ae	; 0x14ae <mem_set>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
    4f04:	01 50       	subi	r16, 0x01	; 1
    4f06:	01 f7       	brne	.-64     	; 0x4ec8 <f_mkdir+0x1c2>
    4f08:	4e c0       	rjmp	.+156    	; 0x4fa6 <f_mkdir+0x2a0>
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
    4f0a:	89 81       	ldd	r24, Y+1	; 0x01
    4f0c:	9a 81       	ldd	r25, Y+2	; 0x02
    4f0e:	b3 01       	movw	r22, r6
    4f10:	a2 01       	movw	r20, r4
    4f12:	0e 94 cc 19 	call	0x3398	; 0x3398 <remove_chain>
    4f16:	19 c0       	rjmp	.+50     	; 0x4f4a <f_mkdir+0x244>
			} else {
				dir = dj.dir;
    4f18:	eb 89       	ldd	r30, Y+19	; 0x13
    4f1a:	fc 89       	ldd	r31, Y+20	; 0x14
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
    4f1c:	80 e1       	ldi	r24, 0x10	; 16
    4f1e:	83 87       	std	Z+11, r24	; 0x0b
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
    4f20:	8d a1       	lds	r24, 0x4d
    4f22:	86 8b       	std	Z+22, r24	; 0x16
    4f24:	8e a1       	lds	r24, 0x4e
    4f26:	87 8b       	std	Z+23, r24	; 0x17
    4f28:	8f a1       	lds	r24, 0x4f
    4f2a:	80 8f       	std	Z+24, r24	; 0x18
    4f2c:	88 a5       	lds	r24, 0x68
    4f2e:	81 8f       	std	Z+25, r24	; 0x19
				st_clust(dir, dcl);					/* Table start cluster */
    4f30:	cf 01       	movw	r24, r30
    4f32:	b3 01       	movw	r22, r6
    4f34:	a2 01       	movw	r20, r4
    4f36:	0e 94 8d 0a 	call	0x151a	; 0x151a <st_clust>
				dj.fs->wflag = 1;
    4f3a:	89 81       	ldd	r24, Y+1	; 0x01
    4f3c:	9a 81       	ldd	r25, Y+2	; 0x02
    4f3e:	21 e0       	ldi	r18, 0x01	; 1
    4f40:	fc 01       	movw	r30, r24
    4f42:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    4f44:	0e 94 ba 10 	call	0x2174	; 0x2174 <sync>
    4f48:	18 2f       	mov	r17, r24
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    4f4a:	81 2f       	mov	r24, r17
    4f4c:	a8 96       	adiw	r28, 0x28	; 40
    4f4e:	0f b6       	in	r0, 0x3f	; 63
    4f50:	f8 94       	cli
    4f52:	de bf       	out	0x3e, r29	; 62
    4f54:	0f be       	out	0x3f, r0	; 63
    4f56:	cd bf       	out	0x3d, r28	; 61
    4f58:	df 91       	pop	r29
    4f5a:	cf 91       	pop	r28
    4f5c:	1f 91       	pop	r17
    4f5e:	0f 91       	pop	r16
    4f60:	ff 90       	pop	r15
    4f62:	ef 90       	pop	r14
    4f64:	df 90       	pop	r13
    4f66:	cf 90       	pop	r12
    4f68:	bf 90       	pop	r11
    4f6a:	af 90       	pop	r10
    4f6c:	9f 90       	pop	r9
    4f6e:	8f 90       	pop	r8
    4f70:	7f 90       	pop	r7
    4f72:	6f 90       	pop	r6
    4f74:	5f 90       	pop	r5
    4f76:	4f 90       	pop	r4
    4f78:	3f 90       	pop	r3
    4f7a:	2f 90       	pop	r2
    4f7c:	08 95       	ret
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
    4f7e:	89 81       	ldd	r24, Y+1	; 0x01
    4f80:	9a 81       	ldd	r25, Y+2	; 0x02
    4f82:	40 e0       	ldi	r20, 0x00	; 0
    4f84:	50 e0       	ldi	r21, 0x00	; 0
    4f86:	ba 01       	movw	r22, r20
    4f88:	0e 94 ab 14 	call	0x2956	; 0x2956 <create_chain>
    4f8c:	2b 01       	movw	r4, r22
    4f8e:	3c 01       	movw	r6, r24
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
    4f90:	61 15       	cp	r22, r1
    4f92:	71 05       	cpc	r23, r1
    4f94:	81 05       	cpc	r24, r1
    4f96:	91 05       	cpc	r25, r1
    4f98:	09 f4       	brne	.+2      	; 0x4f9c <f_mkdir+0x296>
    4f9a:	0b cf       	rjmp	.-490    	; 0x4db2 <f_mkdir+0xac>
    4f9c:	f8 ce       	rjmp	.-528    	; 0x4d8e <f_mkdir+0x88>
			if (dcl == 1) res = FR_INT_ERR;
    4f9e:	12 e0       	ldi	r17, 0x02	; 2
    4fa0:	b4 cf       	rjmp	.-152    	; 0x4f0a <f_mkdir+0x204>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
    4fa2:	11 e0       	ldi	r17, 0x01	; 1
    4fa4:	b2 cf       	rjmp	.-156    	; 0x4f0a <f_mkdir+0x204>
					res = move_window(dj.fs, 0);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
    4fa6:	ce 01       	movw	r24, r28
    4fa8:	01 96       	adiw	r24, 0x01	; 1
    4faa:	0e 94 3b 19 	call	0x3276	; 0x3276 <dir_register>
    4fae:	18 2f       	mov	r17, r24
			if (res != FR_OK) {
    4fb0:	88 23       	and	r24, r24
    4fb2:	09 f4       	brne	.+2      	; 0x4fb6 <f_mkdir+0x2b0>
    4fb4:	b1 cf       	rjmp	.-158    	; 0x4f18 <f_mkdir+0x212>
    4fb6:	a9 cf       	rjmp	.-174    	; 0x4f0a <f_mkdir+0x204>

00004fb8 <f_chmod>:
FRESULT f_chmod (
	const TCHAR *path,	/* Pointer to the file path */
	BYTE value,			/* Attribute bits */
	BYTE mask			/* Attribute mask to change */
)
{
    4fb8:	0f 93       	push	r16
    4fba:	1f 93       	push	r17
    4fbc:	cf 93       	push	r28
    4fbe:	df 93       	push	r29
    4fc0:	cd b7       	in	r28, 0x3d	; 61
    4fc2:	de b7       	in	r29, 0x3e	; 62
    4fc4:	a4 97       	sbiw	r28, 0x24	; 36
    4fc6:	0f b6       	in	r0, 0x3f	; 63
    4fc8:	f8 94       	cli
    4fca:	de bf       	out	0x3e, r29	; 62
    4fcc:	0f be       	out	0x3f, r0	; 63
    4fce:	cd bf       	out	0x3d, r28	; 61
    4fd0:	9c a3       	lds	r25, 0x5c
    4fd2:	8b a3       	lds	r24, 0x5b
    4fd4:	06 2f       	mov	r16, r22
    4fd6:	14 2f       	mov	r17, r20
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4fd8:	ce 01       	movw	r24, r28
    4fda:	83 96       	adiw	r24, 0x23	; 35
    4fdc:	be 01       	movw	r22, r28
    4fde:	6f 5f       	subi	r22, 0xFF	; 255
    4fe0:	7f 4f       	sbci	r23, 0xFF	; 255
    4fe2:	41 e0       	ldi	r20, 0x01	; 1
    4fe4:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <chk_mounted>
	if (res == FR_OK) {
    4fe8:	88 23       	and	r24, r24
    4fea:	29 f5       	brne	.+74     	; 0x5036 <f_chmod+0x7e>
		INIT_BUF(dj);
    4fec:	ce 01       	movw	r24, r28
    4fee:	47 96       	adiw	r24, 0x17	; 23
    4ff0:	9e 8b       	std	Y+22, r25	; 0x16
    4ff2:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the file path */
    4ff4:	6b a1       	lds	r22, 0x4b
    4ff6:	7c a1       	lds	r23, 0x4c
    4ff8:	ce 01       	movw	r24, r28
    4ffa:	01 96       	adiw	r24, 0x01	; 1
    4ffc:	0e 94 14 17 	call	0x2e28	; 0x2e28 <follow_path>
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    5000:	88 23       	and	r24, r24
    5002:	c9 f4       	brne	.+50     	; 0x5036 <f_chmod+0x7e>
    5004:	ed 89       	ldd	r30, Y+21	; 0x15
    5006:	fe 89       	ldd	r31, Y+22	; 0x16
    5008:	83 85       	ldd	r24, Z+11	; 0x0b
    500a:	85 ff       	sbrs	r24, 5
    500c:	1f c0       	rjmp	.+62     	; 0x504c <f_chmod+0x94>
			res = FR_INVALID_NAME;
    500e:	86 e0       	ldi	r24, 0x06	; 6
    5010:	12 c0       	rjmp	.+36     	; 0x5036 <f_chmod+0x7e>
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
			} else {						/* File or sub directory */
				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
    5012:	17 72       	andi	r17, 0x27	; 39
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
    5014:	91 2f       	mov	r25, r17
    5016:	90 95       	com	r25
    5018:	83 85       	ldd	r24, Z+11	; 0x0b
    501a:	89 23       	and	r24, r25
    501c:	01 23       	and	r16, r17
    501e:	18 2f       	mov	r17, r24
    5020:	10 2b       	or	r17, r16
    5022:	13 87       	std	Z+11, r17	; 0x0b
				dj.fs->wflag = 1;
    5024:	89 81       	ldd	r24, Y+1	; 0x01
    5026:	9a 81       	ldd	r25, Y+2	; 0x02
    5028:	21 e0       	ldi	r18, 0x01	; 1
    502a:	fc 01       	movw	r30, r24
    502c:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    502e:	0e 94 ba 10 	call	0x2174	; 0x2174 <sync>
    5032:	01 c0       	rjmp	.+2      	; 0x5036 <f_chmod+0x7e>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
    5034:	86 e0       	ldi	r24, 0x06	; 6
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
    5036:	a4 96       	adiw	r28, 0x24	; 36
    5038:	0f b6       	in	r0, 0x3f	; 63
    503a:	f8 94       	cli
    503c:	de bf       	out	0x3e, r29	; 62
    503e:	0f be       	out	0x3f, r0	; 63
    5040:	cd bf       	out	0x3d, r28	; 61
    5042:	df 91       	pop	r29
    5044:	cf 91       	pop	r28
    5046:	1f 91       	pop	r17
    5048:	0f 91       	pop	r16
    504a:	08 95       	ret
		res = follow_path(&dj, path);		/* Follow the file path */
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
    504c:	eb 89       	ldd	r30, Y+19	; 0x13
    504e:	fc 89       	ldd	r31, Y+20	; 0x14
			if (!dir) {						/* Is it a root directory? */
    5050:	30 97       	sbiw	r30, 0x00	; 0
    5052:	f9 f6       	brne	.-66     	; 0x5012 <f_chmod+0x5a>
    5054:	ef cf       	rjmp	.-34     	; 0x5034 <f_chmod+0x7c>

00005056 <f_utime>:

FRESULT f_utime (
	const TCHAR *path,	/* Pointer to the file/directory name */
	const FILINFO *fno	/* Pointer to the time stamp to be set */
)
{
    5056:	0f 93       	push	r16
    5058:	1f 93       	push	r17
    505a:	cf 93       	push	r28
    505c:	df 93       	push	r29
    505e:	cd b7       	in	r28, 0x3d	; 61
    5060:	de b7       	in	r29, 0x3e	; 62
    5062:	a4 97       	sbiw	r28, 0x24	; 36
    5064:	0f b6       	in	r0, 0x3f	; 63
    5066:	f8 94       	cli
    5068:	de bf       	out	0x3e, r29	; 62
    506a:	0f be       	out	0x3f, r0	; 63
    506c:	cd bf       	out	0x3d, r28	; 61
    506e:	9c a3       	lds	r25, 0x5c
    5070:	8b a3       	lds	r24, 0x5b
    5072:	8b 01       	movw	r16, r22
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    5074:	ce 01       	movw	r24, r28
    5076:	83 96       	adiw	r24, 0x23	; 35
    5078:	be 01       	movw	r22, r28
    507a:	6f 5f       	subi	r22, 0xFF	; 255
    507c:	7f 4f       	sbci	r23, 0xFF	; 255
    507e:	41 e0       	ldi	r20, 0x01	; 1
    5080:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <chk_mounted>
	if (res == FR_OK) {
    5084:	88 23       	and	r24, r24
    5086:	61 f5       	brne	.+88     	; 0x50e0 <f_utime+0x8a>
		INIT_BUF(dj);
    5088:	ce 01       	movw	r24, r28
    508a:	47 96       	adiw	r24, 0x17	; 23
    508c:	9e 8b       	std	Y+22, r25	; 0x16
    508e:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    5090:	6b a1       	lds	r22, 0x4b
    5092:	7c a1       	lds	r23, 0x4c
    5094:	ce 01       	movw	r24, r28
    5096:	01 96       	adiw	r24, 0x01	; 1
    5098:	0e 94 14 17 	call	0x2e28	; 0x2e28 <follow_path>
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    509c:	88 23       	and	r24, r24
    509e:	01 f5       	brne	.+64     	; 0x50e0 <f_utime+0x8a>
    50a0:	ed 89       	ldd	r30, Y+21	; 0x15
    50a2:	fe 89       	ldd	r31, Y+22	; 0x16
    50a4:	83 85       	ldd	r24, Z+11	; 0x0b
    50a6:	85 ff       	sbrs	r24, 5
    50a8:	26 c0       	rjmp	.+76     	; 0x50f6 <f_utime+0xa0>
			res = FR_INVALID_NAME;
    50aa:	86 e0       	ldi	r24, 0x06	; 6
    50ac:	19 c0       	rjmp	.+50     	; 0x50e0 <f_utime+0x8a>
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {					/* Root directory */
				res = FR_INVALID_NAME;
			} else {					/* File or sub-directory */
				ST_WORD(dir+DIR_WrtTime, fno->ftime);
    50ae:	d8 01       	movw	r26, r16
    50b0:	16 96       	adiw	r26, 0x06	; 6
    50b2:	8c 91       	ld	r24, X
    50b4:	16 97       	sbiw	r26, 0x06	; 6
    50b6:	86 8b       	std	Z+22, r24	; 0x16
    50b8:	17 96       	adiw	r26, 0x07	; 7
    50ba:	8c 91       	ld	r24, X
    50bc:	17 97       	sbiw	r26, 0x07	; 7
    50be:	87 8b       	std	Z+23, r24	; 0x17
				ST_WORD(dir+DIR_WrtDate, fno->fdate);
    50c0:	14 96       	adiw	r26, 0x04	; 4
    50c2:	8c 91       	ld	r24, X
    50c4:	14 97       	sbiw	r26, 0x04	; 4
    50c6:	80 8f       	std	Z+24, r24	; 0x18
    50c8:	15 96       	adiw	r26, 0x05	; 5
    50ca:	8c 91       	ld	r24, X
    50cc:	81 8f       	std	Z+25, r24	; 0x19
				dj.fs->wflag = 1;
    50ce:	89 81       	ldd	r24, Y+1	; 0x01
    50d0:	9a 81       	ldd	r25, Y+2	; 0x02
    50d2:	21 e0       	ldi	r18, 0x01	; 1
    50d4:	fc 01       	movw	r30, r24
    50d6:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    50d8:	0e 94 ba 10 	call	0x2174	; 0x2174 <sync>
    50dc:	01 c0       	rjmp	.+2      	; 0x50e0 <f_utime+0x8a>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {					/* Root directory */
				res = FR_INVALID_NAME;
    50de:	86 e0       	ldi	r24, 0x06	; 6
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
    50e0:	a4 96       	adiw	r28, 0x24	; 36
    50e2:	0f b6       	in	r0, 0x3f	; 63
    50e4:	f8 94       	cli
    50e6:	de bf       	out	0x3e, r29	; 62
    50e8:	0f be       	out	0x3f, r0	; 63
    50ea:	cd bf       	out	0x3d, r28	; 61
    50ec:	df 91       	pop	r29
    50ee:	cf 91       	pop	r28
    50f0:	1f 91       	pop	r17
    50f2:	0f 91       	pop	r16
    50f4:	08 95       	ret
		res = follow_path(&dj, path);	/* Follow the file path */
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
    50f6:	eb 89       	ldd	r30, Y+19	; 0x13
    50f8:	fc 89       	ldd	r31, Y+20	; 0x14
			if (!dir) {					/* Root directory */
    50fa:	30 97       	sbiw	r30, 0x00	; 0
    50fc:	c1 f6       	brne	.-80     	; 0x50ae <f_utime+0x58>
    50fe:	ef cf       	rjmp	.-34     	; 0x50de <f_utime+0x88>

00005100 <f_rename>:

FRESULT f_rename (
	const TCHAR *path_old,	/* Pointer to the old name */
	const TCHAR *path_new	/* Pointer to the new name */
)
{
    5100:	ef 92       	push	r14
    5102:	ff 92       	push	r15
    5104:	0f 93       	push	r16
    5106:	1f 93       	push	r17
    5108:	cf 93       	push	r28
    510a:	df 93       	push	r29
    510c:	cd b7       	in	r28, 0x3d	; 61
    510e:	de b7       	in	r29, 0x3e	; 62
    5110:	cf 54       	subi	r28, 0x4F	; 79
    5112:	d0 40       	sbci	r29, 0x00	; 0
    5114:	0f b6       	in	r0, 0x3f	; 63
    5116:	f8 94       	cli
    5118:	de bf       	out	0x3e, r29	; 62
    511a:	0f be       	out	0x3f, r0	; 63
    511c:	cd bf       	out	0x3d, r28	; 61
    511e:	60 96       	adiw	r28, 0x10	; 16
    5120:	9f af       	sts	0x7f, r25
    5122:	8e af       	sts	0x7e, r24
    5124:	60 97       	sbiw	r28, 0x10	; 16
    5126:	8b 01       	movw	r16, r22
	BYTE buf[21], *dir;
	DWORD dw;
	DEF_NAMEBUF;


	res = chk_mounted(&path_old, &djo.fs, 1);
    5128:	ce 01       	movw	r24, r28
    512a:	82 5b       	subi	r24, 0xB2	; 178
    512c:	9f 4f       	sbci	r25, 0xFF	; 255
    512e:	be 01       	movw	r22, r28
    5130:	6f 5f       	subi	r22, 0xFF	; 255
    5132:	7f 4f       	sbci	r23, 0xFF	; 255
    5134:	41 e0       	ldi	r20, 0x01	; 1
    5136:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <chk_mounted>
	if (res == FR_OK) {
    513a:	88 23       	and	r24, r24
    513c:	09 f0       	breq	.+2      	; 0x5140 <f_rename+0x40>
    513e:	b7 c0       	rjmp	.+366    	; 0x52ae <f_rename+0x1ae>
		djn.fs = djo.fs;
    5140:	89 81       	ldd	r24, Y+1	; 0x01
    5142:	9a 81       	ldd	r25, Y+2	; 0x02
    5144:	98 8f       	std	Y+24, r25	; 0x18
    5146:	8f 8b       	std	Y+23, r24	; 0x17
		INIT_BUF(djo);
    5148:	ce 01       	movw	r24, r28
    514a:	8e 5b       	subi	r24, 0xBE	; 190
    514c:	9f 4f       	sbci	r25, 0xFF	; 255
    514e:	9e 8b       	std	Y+22, r25	; 0x16
    5150:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&djo, path_old);		/* Check old object */
    5152:	60 96       	adiw	r28, 0x10	; 16
    5154:	6e ad       	sts	0x6e, r22
    5156:	7f ad       	sts	0x6f, r23
    5158:	60 97       	sbiw	r28, 0x10	; 16
    515a:	ce 01       	movw	r24, r28
    515c:	01 96       	adiw	r24, 0x01	; 1
    515e:	0e 94 14 17 	call	0x2e28	; 0x2e28 <follow_path>
		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
    5162:	88 23       	and	r24, r24
    5164:	09 f0       	breq	.+2      	; 0x5168 <f_rename+0x68>
    5166:	a3 c0       	rjmp	.+326    	; 0x52ae <f_rename+0x1ae>
    5168:	ed 89       	ldd	r30, Y+21	; 0x15
    516a:	fe 89       	ldd	r31, Y+22	; 0x16
    516c:	83 85       	ldd	r24, Z+11	; 0x0b
    516e:	85 ff       	sbrs	r24, 5
    5170:	ac c0       	rjmp	.+344    	; 0x52ca <f_rename+0x1ca>
			res = FR_INVALID_NAME;
    5172:	86 e0       	ldi	r24, 0x06	; 6
    5174:	9c c0       	rjmp	.+312    	; 0x52ae <f_rename+0x1ae>
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
    5176:	65 5f       	subi	r22, 0xF5	; 245
    5178:	7f 4f       	sbci	r23, 0xFF	; 255
    517a:	ce 01       	movw	r24, r28
    517c:	8d 96       	adiw	r24, 0x2d	; 45
    517e:	25 e1       	ldi	r18, 0x15	; 21
    5180:	30 e0       	ldi	r19, 0x00	; 0
    5182:	40 e0       	ldi	r20, 0x00	; 0
    5184:	50 e0       	ldi	r21, 0x00	; 0
    5186:	0e 94 42 0a 	call	0x1484	; 0x1484 <mem_cpy>
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
    518a:	ce 01       	movw	r24, r28
    518c:	47 96       	adiw	r24, 0x17	; 23
    518e:	be 01       	movw	r22, r28
    5190:	6f 5f       	subi	r22, 0xFF	; 255
    5192:	7f 4f       	sbci	r23, 0xFF	; 255
    5194:	26 e1       	ldi	r18, 0x16	; 22
    5196:	30 e0       	ldi	r19, 0x00	; 0
    5198:	40 e0       	ldi	r20, 0x00	; 0
    519a:	50 e0       	ldi	r21, 0x00	; 0
    519c:	0e 94 42 0a 	call	0x1484	; 0x1484 <mem_cpy>
				res = follow_path(&djn, path_new);
    51a0:	ce 01       	movw	r24, r28
    51a2:	47 96       	adiw	r24, 0x17	; 23
    51a4:	b8 01       	movw	r22, r16
    51a6:	0e 94 14 17 	call	0x2e28	; 0x2e28 <follow_path>
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
    51aa:	88 23       	and	r24, r24
    51ac:	09 f4       	brne	.+2      	; 0x51b0 <f_rename+0xb0>
    51ae:	7c c0       	rjmp	.+248    	; 0x52a8 <f_rename+0x1a8>
				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
    51b0:	84 30       	cpi	r24, 0x04	; 4
    51b2:	09 f0       	breq	.+2      	; 0x51b6 <f_rename+0xb6>
    51b4:	7c c0       	rjmp	.+248    	; 0x52ae <f_rename+0x1ae>
/* Start critical section that an interruption or error can cause cross-link */
					res = dir_register(&djn);			/* Register the new entry */
    51b6:	ce 01       	movw	r24, r28
    51b8:	47 96       	adiw	r24, 0x17	; 23
    51ba:	0e 94 3b 19 	call	0x3276	; 0x3276 <dir_register>
					if (res == FR_OK) {
    51be:	88 23       	and	r24, r24
    51c0:	09 f0       	breq	.+2      	; 0x51c4 <f_rename+0xc4>
    51c2:	75 c0       	rjmp	.+234    	; 0x52ae <f_rename+0x1ae>
						dir = djn.dir;					/* Copy object information except for name */
    51c4:	09 a5       	lds	r16, 0x69
    51c6:	1a a5       	lds	r17, 0x6a
						mem_cpy(dir+13, buf+2, 19);
    51c8:	c8 01       	movw	r24, r16
    51ca:	0d 96       	adiw	r24, 0x0d	; 13
    51cc:	be 01       	movw	r22, r28
    51ce:	61 5d       	subi	r22, 0xD1	; 209
    51d0:	7f 4f       	sbci	r23, 0xFF	; 255
    51d2:	23 e1       	ldi	r18, 0x13	; 19
    51d4:	30 e0       	ldi	r19, 0x00	; 0
    51d6:	40 e0       	ldi	r20, 0x00	; 0
    51d8:	50 e0       	ldi	r21, 0x00	; 0
    51da:	0e 94 42 0a 	call	0x1484	; 0x1484 <mem_cpy>
						dir[DIR_Attr] = buf[0] | AM_ARC;
    51de:	8d a5       	lds	r24, 0x6d
    51e0:	80 62       	ori	r24, 0x20	; 32
    51e2:	f8 01       	movw	r30, r16
    51e4:	83 87       	std	Z+11, r24	; 0x0b
						djo.fs->wflag = 1;
    51e6:	e9 80       	ldd	r14, Y+1	; 0x01
    51e8:	fa 80       	ldd	r15, Y+2	; 0x02
    51ea:	81 e0       	ldi	r24, 0x01	; 1
    51ec:	f7 01       	movw	r30, r14
    51ee:	84 83       	std	Z+4, r24	; 0x04
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
    51f0:	4f 81       	ldd	r20, Y+7	; 0x07
    51f2:	58 85       	ldd	r21, Y+8	; 0x08
    51f4:	69 85       	ldd	r22, Y+9	; 0x09
    51f6:	7a 85       	ldd	r23, Y+10	; 0x0a
    51f8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    51fa:	9e 8d       	ldd	r25, Y+30	; 0x1e
    51fc:	af 8d       	ldd	r26, Y+31	; 0x1f
    51fe:	b8 a1       	lds	r27, 0x48
    5200:	48 17       	cp	r20, r24
    5202:	59 07       	cpc	r21, r25
    5204:	6a 07       	cpc	r22, r26
    5206:	7b 07       	cpc	r23, r27
    5208:	09 f4       	brne	.+2      	; 0x520c <f_rename+0x10c>
    520a:	43 c0       	rjmp	.+134    	; 0x5292 <f_rename+0x192>
    520c:	f8 01       	movw	r30, r16
    520e:	83 85       	ldd	r24, Z+11	; 0x0b
    5210:	84 ff       	sbrs	r24, 4
    5212:	3f c0       	rjmp	.+126    	; 0x5292 <f_rename+0x192>
							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
    5214:	c7 01       	movw	r24, r14
    5216:	b8 01       	movw	r22, r16
    5218:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <ld_clust>
    521c:	ab 01       	movw	r20, r22
    521e:	bc 01       	movw	r22, r24
    5220:	c7 01       	movw	r24, r14
    5222:	0e 94 4c 11 	call	0x2298	; 0x2298 <clust2sect>
    5226:	ab 01       	movw	r20, r22
    5228:	bc 01       	movw	r22, r24
							if (!dw) {
    522a:	41 15       	cp	r20, r1
    522c:	51 05       	cpc	r21, r1
    522e:	61 05       	cpc	r22, r1
    5230:	71 05       	cpc	r23, r1
    5232:	09 f4       	brne	.+2      	; 0x5236 <f_rename+0x136>
    5234:	51 c0       	rjmp	.+162    	; 0x52d8 <f_rename+0x1d8>
								res = FR_INT_ERR;
							} else {
								res = move_window(djo.fs, dw);
    5236:	c7 01       	movw	r24, r14
    5238:	0e 94 34 10 	call	0x2068	; 0x2068 <move_window>
								dir = djo.fs->win+SZ_DIR;	/* .. entry */
    523c:	e9 81       	ldd	r30, Y+1	; 0x01
    523e:	fa 81       	ldd	r31, Y+2	; 0x02
								if (res == FR_OK && dir[1] == '.') {
    5240:	88 23       	and	r24, r24
    5242:	a9 f5       	brne	.+106    	; 0x52ae <f_rename+0x1ae>
    5244:	df 01       	movw	r26, r30
    5246:	ad 5a       	subi	r26, 0xAD	; 173
    5248:	bf 4f       	sbci	r27, 0xFF	; 255
    524a:	8c 91       	ld	r24, X
    524c:	8e 32       	cpi	r24, 0x2E	; 46
    524e:	09 f5       	brne	.+66     	; 0x5292 <f_rename+0x192>
									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
    5250:	80 81       	ld	r24, Z
    5252:	83 30       	cpi	r24, 0x03	; 3
    5254:	69 f4       	brne	.+26     	; 0x5270 <f_rename+0x170>
    5256:	4d 8d       	ldd	r20, Y+29	; 0x1d
    5258:	5e 8d       	ldd	r21, Y+30	; 0x1e
    525a:	6f 8d       	ldd	r22, Y+31	; 0x1f
    525c:	78 a1       	lds	r23, 0x48
    525e:	86 a1       	lds	r24, 0x46
    5260:	97 a1       	lds	r25, 0x47
    5262:	a0 a5       	lds	r26, 0x60
    5264:	b1 a5       	lds	r27, 0x61
    5266:	48 17       	cp	r20, r24
    5268:	59 07       	cpc	r21, r25
    526a:	6a 07       	cpc	r22, r26
    526c:	7b 07       	cpc	r23, r27
    526e:	29 f0       	breq	.+10     	; 0x527a <f_rename+0x17a>
    5270:	4d 8d       	ldd	r20, Y+29	; 0x1d
    5272:	5e 8d       	ldd	r21, Y+30	; 0x1e
    5274:	6f 8d       	ldd	r22, Y+31	; 0x1f
    5276:	78 a1       	lds	r23, 0x48
    5278:	03 c0       	rjmp	.+6      	; 0x5280 <f_rename+0x180>
    527a:	40 e0       	ldi	r20, 0x00	; 0
    527c:	50 e0       	ldi	r21, 0x00	; 0
    527e:	ba 01       	movw	r22, r20
									st_clust(dir, dw);
    5280:	cf 01       	movw	r24, r30
    5282:	8e 5a       	subi	r24, 0xAE	; 174
    5284:	9f 4f       	sbci	r25, 0xFF	; 255
    5286:	0e 94 8d 0a 	call	0x151a	; 0x151a <st_clust>
									djo.fs->wflag = 1;
    528a:	e9 81       	ldd	r30, Y+1	; 0x01
    528c:	fa 81       	ldd	r31, Y+2	; 0x02
    528e:	81 e0       	ldi	r24, 0x01	; 1
    5290:	84 83       	std	Z+4, r24	; 0x04
								}
							}
						}
						if (res == FR_OK) {
							res = dir_remove(&djo);		/* Remove old entry */
    5292:	ce 01       	movw	r24, r28
    5294:	01 96       	adiw	r24, 0x01	; 1
    5296:	0e 94 7e 13 	call	0x26fc	; 0x26fc <dir_remove>
							if (res == FR_OK)
    529a:	88 23       	and	r24, r24
    529c:	41 f4       	brne	.+16     	; 0x52ae <f_rename+0x1ae>
								res = sync(djo.fs);
    529e:	89 81       	ldd	r24, Y+1	; 0x01
    52a0:	9a 81       	ldd	r25, Y+2	; 0x02
    52a2:	0e 94 ba 10 	call	0x2174	; 0x2174 <sync>
    52a6:	03 c0       	rjmp	.+6      	; 0x52ae <f_rename+0x1ae>
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
				res = follow_path(&djn, path_new);
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
    52a8:	88 e0       	ldi	r24, 0x08	; 8
    52aa:	01 c0       	rjmp	.+2      	; 0x52ae <f_rename+0x1ae>
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
    52ac:	84 e0       	ldi	r24, 0x04	; 4
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(djo.fs, res);
}
    52ae:	c1 5b       	subi	r28, 0xB1	; 177
    52b0:	df 4f       	sbci	r29, 0xFF	; 255
    52b2:	0f b6       	in	r0, 0x3f	; 63
    52b4:	f8 94       	cli
    52b6:	de bf       	out	0x3e, r29	; 62
    52b8:	0f be       	out	0x3f, r0	; 63
    52ba:	cd bf       	out	0x3d, r28	; 61
    52bc:	df 91       	pop	r29
    52be:	cf 91       	pop	r28
    52c0:	1f 91       	pop	r17
    52c2:	0f 91       	pop	r16
    52c4:	ff 90       	pop	r15
    52c6:	ef 90       	pop	r14
    52c8:	08 95       	ret
			res = FR_INVALID_NAME;
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
    52ca:	6b 89       	ldd	r22, Y+19	; 0x13
    52cc:	7c 89       	ldd	r23, Y+20	; 0x14
    52ce:	61 15       	cp	r22, r1
    52d0:	71 05       	cpc	r23, r1
    52d2:	09 f0       	breq	.+2      	; 0x52d6 <f_rename+0x1d6>
    52d4:	50 cf       	rjmp	.-352    	; 0x5176 <f_rename+0x76>
    52d6:	ea cf       	rjmp	.-44     	; 0x52ac <f_rename+0x1ac>
						dir[DIR_Attr] = buf[0] | AM_ARC;
						djo.fs->wflag = 1;
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
							if (!dw) {
								res = FR_INT_ERR;
    52d8:	82 e0       	ldi	r24, 0x02	; 2
    52da:	e9 cf       	rjmp	.-46     	; 0x52ae <f_rename+0x1ae>

000052dc <PCA9542A_Init>:
 */ 
#include "PCA9542A.h"


unsigned char PCA9542A_Init()
{
    52dc:	cf 93       	push	r28
    52de:	df 93       	push	r29
    52e0:	00 d0       	rcall	.+0      	; 0x52e2 <PCA9542A_Init+0x6>
    52e2:	00 d0       	rcall	.+0      	; 0x52e4 <PCA9542A_Init+0x8>
    52e4:	cd b7       	in	r28, 0x3d	; 61
    52e6:	de b7       	in	r29, 0x3e	; 62
	unsigned char messageBuf[TWI_BUFFER_SIZE];
	messageBuf[0] = (PCA9542A_ADDR  <<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consit of General Call code or the TWI slave address.
    52e8:	88 ee       	ldi	r24, 0xE8	; 232
    52ea:	89 83       	std	Y+1, r24	; 0x01
	messageBuf[1] = NO_SELECT;             // The first byte is used for commands.
    52ec:	1a 82       	std	Y+2, r1	; 0x02
	// The second byte is used for the data.
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
    52ee:	ce 01       	movw	r24, r28
    52f0:	01 96       	adiw	r24, 0x01	; 1
    52f2:	62 e0       	ldi	r22, 0x02	; 2
    52f4:	0e 94 db 29 	call	0x53b6	; 0x53b6 <TWI_Start_Transceiver_With_Data>
	
	while(TWI_Transceiver_Busy()) ; //Wait for transceiver to clear
    52f8:	0e 94 d0 29 	call	0x53a0	; 0x53a0 <TWI_Transceiver_Busy>
    52fc:	88 23       	and	r24, r24
    52fe:	e1 f7       	brne	.-8      	; 0x52f8 <PCA9542A_Init+0x1c>
	
	return TWI_statusReg.lastTransOK;
    5300:	80 91 28 04 	lds	r24, 0x0428
}
    5304:	81 70       	andi	r24, 0x01	; 1
    5306:	0f 90       	pop	r0
    5308:	0f 90       	pop	r0
    530a:	0f 90       	pop	r0
    530c:	0f 90       	pop	r0
    530e:	df 91       	pop	r29
    5310:	cf 91       	pop	r28
    5312:	08 95       	ret

00005314 <PCA9542A_SetChannel>:

unsigned char PCA9542A_SetChannel( uint8_t Channel )
{
    5314:	cf 93       	push	r28
    5316:	df 93       	push	r29
    5318:	00 d0       	rcall	.+0      	; 0x531a <PCA9542A_SetChannel+0x6>
    531a:	00 d0       	rcall	.+0      	; 0x531c <PCA9542A_SetChannel+0x8>
    531c:	cd b7       	in	r28, 0x3d	; 61
    531e:	de b7       	in	r29, 0x3e	; 62
	unsigned char messageBuf[TWI_BUFFER_SIZE];
	messageBuf[0] = (PCA9542A_ADDR  <<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consit of General Call code or the TWI slave address.
    5320:	98 ee       	ldi	r25, 0xE8	; 232
    5322:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = Channel;             // The first byte is used for commands.
    5324:	8a 83       	std	Y+2, r24	; 0x02
		                    // The second byte is used for the data.
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
    5326:	ce 01       	movw	r24, r28
    5328:	01 96       	adiw	r24, 0x01	; 1
    532a:	62 e0       	ldi	r22, 0x02	; 2
    532c:	0e 94 db 29 	call	0x53b6	; 0x53b6 <TWI_Start_Transceiver_With_Data>
		
	while(TWI_Transceiver_Busy()) ; //Wait for transceiver to clear
    5330:	0e 94 d0 29 	call	0x53a0	; 0x53a0 <TWI_Transceiver_Busy>
    5334:	88 23       	and	r24, r24
    5336:	e1 f7       	brne	.-8      	; 0x5330 <PCA9542A_SetChannel+0x1c>
		
	return TWI_statusReg.lastTransOK;
    5338:	80 91 28 04 	lds	r24, 0x0428
}
    533c:	81 70       	andi	r24, 0x01	; 1
    533e:	0f 90       	pop	r0
    5340:	0f 90       	pop	r0
    5342:	0f 90       	pop	r0
    5344:	0f 90       	pop	r0
    5346:	df 91       	pop	r29
    5348:	cf 91       	pop	r28
    534a:	08 95       	ret

0000534c <PCA9542A_ReadChannel>:

unsigned char PCA9542A_ReadChannel()
{
    534c:	cf 93       	push	r28
    534e:	df 93       	push	r29
    5350:	00 d0       	rcall	.+0      	; 0x5352 <PCA9542A_ReadChannel+0x6>
    5352:	00 d0       	rcall	.+0      	; 0x5354 <PCA9542A_ReadChannel+0x8>
    5354:	cd b7       	in	r28, 0x3d	; 61
    5356:	de b7       	in	r29, 0x3e	; 62
	unsigned char messageBuf[TWI_BUFFER_SIZE];
	messageBuf[0] = (PCA9542A_ADDR  <<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT); // The first byte must always consit of General Call code or the TWI slave address.
    5358:	89 ee       	ldi	r24, 0xE9	; 233
    535a:	89 83       	std	Y+1, r24	; 0x01

	TWI_Start_Transceiver_With_Data( messageBuf, 1 );
    535c:	ce 01       	movw	r24, r28
    535e:	01 96       	adiw	r24, 0x01	; 1
    5360:	61 e0       	ldi	r22, 0x01	; 1
    5362:	0e 94 db 29 	call	0x53b6	; 0x53b6 <TWI_Start_Transceiver_With_Data>
	
	while(TWI_Transceiver_Busy()) ; //Wait for transceiver to clear
    5366:	0e 94 d0 29 	call	0x53a0	; 0x53a0 <TWI_Transceiver_Busy>
    536a:	88 23       	and	r24, r24
    536c:	e1 f7       	brne	.-8      	; 0x5366 <PCA9542A_ReadChannel+0x1a>
	// Get the received data from the transceiver buffer
	TWI_Get_Data_From_Transceiver( messageBuf, 2 );
    536e:	ce 01       	movw	r24, r28
    5370:	01 96       	adiw	r24, 0x01	; 1
    5372:	62 e0       	ldi	r22, 0x02	; 2
    5374:	0e 94 11 2a 	call	0x5422	; 0x5422 <TWI_Get_Data_From_Transceiver>
	return TWI_statusReg.lastTransOK;
    5378:	80 91 28 04 	lds	r24, 0x0428
    537c:	81 70       	andi	r24, 0x01	; 1
    537e:	0f 90       	pop	r0
    5380:	0f 90       	pop	r0
    5382:	0f 90       	pop	r0
    5384:	0f 90       	pop	r0
    5386:	df 91       	pop	r29
    5388:	cf 91       	pop	r28
    538a:	08 95       	ret

0000538c <TWI_Master_Initialise>:
		DDRC = 0x00;
		PORTC = (1 << PC0) | (1 << PC1);
	#else
		#pragma message("External I2C Pull Ups Required.")
	#endif
	TWBR = TWI_TWBR;                                  // Set bit rate register (Baudrate). Defined in header file.
    538c:	84 e3       	ldi	r24, 0x34	; 52
    538e:	80 93 b8 00 	sts	0x00B8, r24
	// TWSR = TWI_TWPS;                                  // Not used. Driver presumes prescaler to be 00.
	TWDR = 0xFF;                                      // Default content = SDA released.
    5392:	8f ef       	ldi	r24, 0xFF	; 255
    5394:	80 93 bb 00 	sts	0x00BB, r24
	TWCR =	(1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
    5398:	84 e0       	ldi	r24, 0x04	; 4
    539a:	80 93 bc 00 	sts	0x00BC, r24
			(0<<TWIE)|(0<<TWINT)|                      // Disable Interupt.
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests.
			(0<<TWWC);                                 //
}    
    539e:	08 95       	ret

000053a0 <TWI_Transceiver_Busy>:
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
    53a0:	80 91 bc 00 	lds	r24, 0x00BC
}
    53a4:	81 70       	andi	r24, 0x01	; 1
    53a6:	08 95       	ret

000053a8 <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
    53a8:	0e 94 d0 29 	call	0x53a0	; 0x53a0 <TWI_Transceiver_Busy>
    53ac:	88 23       	and	r24, r24
    53ae:	e1 f7       	brne	.-8      	; 0x53a8 <TWI_Get_State_Info>
  return ( TWI_state );                         // Return error state.
}
    53b0:	80 91 1e 04 	lds	r24, 0x041E
    53b4:	08 95       	ret

000053b6 <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
    53b6:	0f 93       	push	r16
    53b8:	1f 93       	push	r17
    53ba:	cf 93       	push	r28
    53bc:	8c 01       	movw	r16, r24
    53be:	c6 2f       	mov	r28, r22
  unsigned char temp;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    53c0:	0e 94 d0 29 	call	0x53a0	; 0x53a0 <TWI_Transceiver_Busy>
    53c4:	88 23       	and	r24, r24
    53c6:	e1 f7       	brne	.-8      	; 0x53c0 <TWI_Start_Transceiver_With_Data+0xa>

  TWI_msgSize = msgSize;                        // Number of data to transmit.
    53c8:	c0 93 29 04 	sts	0x0429, r28
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
    53cc:	f8 01       	movw	r30, r16
    53ce:	80 81       	ld	r24, Z
    53d0:	80 93 2a 04 	sts	0x042A, r24
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
    53d4:	80 fd       	sbrc	r24, 0
    53d6:	0c c0       	rjmp	.+24     	; 0x53f0 <TWI_Start_Transceiver_With_Data+0x3a>
  {
    for ( temp = 1; temp < msgSize; temp++ )
    53d8:	c2 30       	cpi	r28, 0x02	; 2
    53da:	50 f0       	brcs	.+20     	; 0x53f0 <TWI_Start_Transceiver_With_Data+0x3a>
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    53dc:	d8 01       	movw	r26, r16
    53de:	11 96       	adiw	r26, 0x01	; 1

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    53e0:	eb e2       	ldi	r30, 0x2B	; 43
    53e2:	f4 e0       	ldi	r31, 0x04	; 4
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    53e4:	81 e0       	ldi	r24, 0x01	; 1
  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
      TWI_buf[ temp ] = msg[ temp ];
    53e6:	9d 91       	ld	r25, X+
    53e8:	91 93       	st	Z+, r25

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    53ea:	8f 5f       	subi	r24, 0xFF	; 255
    53ec:	8c 17       	cp	r24, r28
    53ee:	d9 f7       	brne	.-10     	; 0x53e6 <TWI_Start_Transceiver_With_Data+0x30>
      TWI_buf[ temp ] = msg[ temp ];
  }
  TWI_statusReg.all = 0;      
    53f0:	10 92 28 04 	sts	0x0428, r1
  TWI_state         = TWI_NO_STATE ;
    53f4:	88 ef       	ldi	r24, 0xF8	; 248
    53f6:	80 93 1e 04 	sts	0x041E, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    53fa:	85 ea       	ldi	r24, 0xA5	; 165
    53fc:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    5400:	cf 91       	pop	r28
    5402:	1f 91       	pop	r17
    5404:	0f 91       	pop	r16
    5406:	08 95       	ret

00005408 <TWI_Start_Transceiver>:
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    5408:	0e 94 d0 29 	call	0x53a0	; 0x53a0 <TWI_Transceiver_Busy>
    540c:	88 23       	and	r24, r24
    540e:	e1 f7       	brne	.-8      	; 0x5408 <TWI_Start_Transceiver>
  TWI_statusReg.all = 0;      
    5410:	10 92 28 04 	sts	0x0428, r1
  TWI_state         = TWI_NO_STATE ;
    5414:	88 ef       	ldi	r24, 0xF8	; 248
    5416:	80 93 1e 04 	sts	0x041E, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    541a:	85 ea       	ldi	r24, 0xA5	; 165
    541c:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    5420:	08 95       	ret

00005422 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    5422:	1f 93       	push	r17
    5424:	cf 93       	push	r28
    5426:	df 93       	push	r29
    5428:	d8 2f       	mov	r29, r24
    542a:	19 2f       	mov	r17, r25
    542c:	c6 2f       	mov	r28, r22
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    542e:	0e 94 d0 29 	call	0x53a0	; 0x53a0 <TWI_Transceiver_Busy>
    5432:	88 23       	and	r24, r24
    5434:	e1 f7       	brne	.-8      	; 0x542e <TWI_Get_Data_From_Transceiver+0xc>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    5436:	80 91 28 04 	lds	r24, 0x0428
    543a:	80 ff       	sbrs	r24, 0
    543c:	0d c0       	rjmp	.+26     	; 0x5458 <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    543e:	cc 23       	and	r28, r28
    5440:	59 f0       	breq	.+22     	; 0x5458 <TWI_Get_Data_From_Transceiver+0x36>
    5442:	aa e2       	ldi	r26, 0x2A	; 42
    5444:	b4 e0       	ldi	r27, 0x04	; 4
    5446:	9d 2f       	mov	r25, r29
    5448:	ed 2f       	mov	r30, r29
    544a:	f1 2f       	mov	r31, r17
    {
      msg[ i ] = TWI_buf[ i ];
    544c:	8d 91       	ld	r24, X+
    544e:	81 93       	st	Z+, r24

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    5450:	8e 2f       	mov	r24, r30
    5452:	89 1b       	sub	r24, r25
    5454:	8c 17       	cp	r24, r28
    5456:	d0 f3       	brcs	.-12     	; 0x544c <TWI_Get_Data_From_Transceiver+0x2a>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    5458:	80 91 28 04 	lds	r24, 0x0428
}
    545c:	81 70       	andi	r24, 0x01	; 1
    545e:	df 91       	pop	r29
    5460:	cf 91       	pop	r28
    5462:	1f 91       	pop	r17
    5464:	08 95       	ret

00005466 <__vector_26>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/

ISR(TWI_vect)
{
    5466:	1f 92       	push	r1
    5468:	0f 92       	push	r0
    546a:	0f b6       	in	r0, 0x3f	; 63
    546c:	0f 92       	push	r0
    546e:	11 24       	eor	r1, r1
    5470:	2f 93       	push	r18
    5472:	3f 93       	push	r19
    5474:	8f 93       	push	r24
    5476:	9f 93       	push	r25
    5478:	ef 93       	push	r30
    547a:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    547c:	80 91 b9 00 	lds	r24, 0x00B9
    5480:	88 32       	cpi	r24, 0x28	; 40
    5482:	d1 f0       	breq	.+52     	; 0x54b8 <__vector_26+0x52>
    5484:	89 32       	cpi	r24, 0x29	; 41
    5486:	40 f4       	brcc	.+16     	; 0x5498 <__vector_26+0x32>
    5488:	80 31       	cpi	r24, 0x10	; 16
    548a:	a1 f0       	breq	.+40     	; 0x54b4 <__vector_26+0x4e>
    548c:	88 31       	cpi	r24, 0x18	; 24
    548e:	a1 f0       	breq	.+40     	; 0x54b8 <__vector_26+0x52>
    5490:	88 30       	cpi	r24, 0x08	; 8
    5492:	09 f0       	breq	.+2      	; 0x5496 <__vector_26+0x30>
    5494:	61 c0       	rjmp	.+194    	; 0x5558 <__vector_26+0xf2>
    5496:	0e c0       	rjmp	.+28     	; 0x54b4 <__vector_26+0x4e>
    5498:	80 34       	cpi	r24, 0x40	; 64
    549a:	b9 f1       	breq	.+110    	; 0x550a <__vector_26+0xa4>
    549c:	81 34       	cpi	r24, 0x41	; 65
    549e:	20 f4       	brcc	.+8      	; 0x54a8 <__vector_26+0x42>
    54a0:	88 33       	cpi	r24, 0x38	; 56
    54a2:	09 f0       	breq	.+2      	; 0x54a6 <__vector_26+0x40>
    54a4:	59 c0       	rjmp	.+178    	; 0x5558 <__vector_26+0xf2>
    54a6:	54 c0       	rjmp	.+168    	; 0x5550 <__vector_26+0xea>
    54a8:	80 35       	cpi	r24, 0x50	; 80
    54aa:	19 f1       	breq	.+70     	; 0x54f2 <__vector_26+0x8c>
    54ac:	88 35       	cpi	r24, 0x58	; 88
    54ae:	09 f0       	breq	.+2      	; 0x54b2 <__vector_26+0x4c>
    54b0:	53 c0       	rjmp	.+166    	; 0x5558 <__vector_26+0xf2>
    54b2:	3d c0       	rjmp	.+122    	; 0x552e <__vector_26+0xc8>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    54b4:	10 92 2e 04 	sts	0x042E, r1
    case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    54b8:	80 91 2e 04 	lds	r24, 0x042E
    54bc:	90 91 29 04 	lds	r25, 0x0429
    54c0:	89 17       	cp	r24, r25
    54c2:	70 f4       	brcc	.+28     	; 0x54e0 <__vector_26+0x7a>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    54c4:	e8 2f       	mov	r30, r24
    54c6:	f0 e0       	ldi	r31, 0x00	; 0
    54c8:	e6 5d       	subi	r30, 0xD6	; 214
    54ca:	fb 4f       	sbci	r31, 0xFB	; 251
    54cc:	90 81       	ld	r25, Z
    54ce:	90 93 bb 00 	sts	0x00BB, r25
    54d2:	8f 5f       	subi	r24, 0xFF	; 255
    54d4:	80 93 2e 04 	sts	0x042E, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    54d8:	85 e8       	ldi	r24, 0x85	; 133
    54da:	80 93 bc 00 	sts	0x00BC, r24
    54de:	43 c0       	rjmp	.+134    	; 0x5566 <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    54e0:	80 91 28 04 	lds	r24, 0x0428
    54e4:	81 60       	ori	r24, 0x01	; 1
    54e6:	80 93 28 04 	sts	0x0428, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    54ea:	84 e9       	ldi	r24, 0x94	; 148
    54ec:	80 93 bc 00 	sts	0x00BC, r24
    54f0:	3a c0       	rjmp	.+116    	; 0x5566 <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    54f2:	80 91 2e 04 	lds	r24, 0x042E
    54f6:	90 91 bb 00 	lds	r25, 0x00BB
    54fa:	e8 2f       	mov	r30, r24
    54fc:	f0 e0       	ldi	r31, 0x00	; 0
    54fe:	e6 5d       	subi	r30, 0xD6	; 214
    5500:	fb 4f       	sbci	r31, 0xFB	; 251
    5502:	90 83       	st	Z, r25
    5504:	8f 5f       	subi	r24, 0xFF	; 255
    5506:	80 93 2e 04 	sts	0x042E, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    550a:	20 91 2e 04 	lds	r18, 0x042E
    550e:	30 e0       	ldi	r19, 0x00	; 0
    5510:	80 91 29 04 	lds	r24, 0x0429
    5514:	90 e0       	ldi	r25, 0x00	; 0
    5516:	01 97       	sbiw	r24, 0x01	; 1
    5518:	28 17       	cp	r18, r24
    551a:	39 07       	cpc	r19, r25
    551c:	24 f4       	brge	.+8      	; 0x5526 <__vector_26+0xc0>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    551e:	85 ec       	ldi	r24, 0xC5	; 197
    5520:	80 93 bc 00 	sts	0x00BC, r24
    5524:	20 c0       	rjmp	.+64     	; 0x5566 <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    5526:	85 e8       	ldi	r24, 0x85	; 133
    5528:	80 93 bc 00 	sts	0x00BC, r24
    552c:	1c c0       	rjmp	.+56     	; 0x5566 <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    552e:	80 91 bb 00 	lds	r24, 0x00BB
    5532:	e0 91 2e 04 	lds	r30, 0x042E
    5536:	f0 e0       	ldi	r31, 0x00	; 0
    5538:	e6 5d       	subi	r30, 0xD6	; 214
    553a:	fb 4f       	sbci	r31, 0xFB	; 251
    553c:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    553e:	80 91 28 04 	lds	r24, 0x0428
    5542:	81 60       	ori	r24, 0x01	; 1
    5544:	80 93 28 04 	sts	0x0428, r24
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    5548:	84 e9       	ldi	r24, 0x94	; 148
    554a:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    554e:	0b c0       	rjmp	.+22     	; 0x5566 <__vector_26+0x100>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    5550:	85 ea       	ldi	r24, 0xA5	; 165
    5552:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    5556:	07 c0       	rjmp	.+14     	; 0x5566 <__vector_26+0x100>
    case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
//    case TWI_NO_STATE              // No relevant state information available; TWINT = 0
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    5558:	80 91 b9 00 	lds	r24, 0x00B9
    555c:	80 93 1e 04 	sts	0x041E, r24
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    5560:	84 e0       	ldi	r24, 0x04	; 4
    5562:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    5566:	ff 91       	pop	r31
    5568:	ef 91       	pop	r30
    556a:	9f 91       	pop	r25
    556c:	8f 91       	pop	r24
    556e:	3f 91       	pop	r19
    5570:	2f 91       	pop	r18
    5572:	0f 90       	pop	r0
    5574:	0f be       	out	0x3f, r0	; 63
    5576:	0f 90       	pop	r0
    5578:	1f 90       	pop	r1
    557a:	18 95       	reti

0000557c <USART0_Init>:

void USART0_Init()
{
	uint16_t ubrr = UBBR;
	//Set baud rate
	UBRR0H = (unsigned char)(ubrr >>8);
    557c:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (unsigned char)ubrr ;
    5580:	8c e0       	ldi	r24, 0x0C	; 12
    5582:	80 93 c4 00 	sts	0x00C4, r24
	//Enable receiver and transmitter
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    5586:	88 e1       	ldi	r24, 0x18	; 24
    5588:	80 93 c1 00 	sts	0x00C1, r24
	
	UCSR0C = 0x06; //set asynchronous, no parity, one stop bit, 8 bit transfer.
    558c:	86 e0       	ldi	r24, 0x06	; 6
    558e:	80 93 c2 00 	sts	0x00C2, r24
	
	//UCSR0B |= (1 << RXCIE0) | (1 << TXCIE0); //set RX and TX interrupt on
}
    5592:	08 95       	ret

00005594 <Usart_SendChar>:
void Usart_SendChar(char data) 
{
    // Wait for empty transmit buffer
    while ( !(UCSR0A & (1 << UDRE0)) );
    5594:	e0 ec       	ldi	r30, 0xC0	; 192
    5596:	f0 e0       	ldi	r31, 0x00	; 0
    5598:	90 81       	ld	r25, Z
    559a:	95 ff       	sbrs	r25, 5
    559c:	fd cf       	rjmp	.-6      	; 0x5598 <Usart_SendChar+0x4>
    // Start transmission
    UDR0 = data; 
    559e:	80 93 c6 00 	sts	0x00C6, r24
}
    55a2:	08 95       	ret

000055a4 <Usart_Receive>:
unsigned char Usart_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
    55a4:	e0 ec       	ldi	r30, 0xC0	; 192
    55a6:	f0 e0       	ldi	r31, 0x00	; 0
    55a8:	80 81       	ld	r24, Z
    55aa:	88 23       	and	r24, r24
    55ac:	ec f7       	brge	.-6      	; 0x55a8 <Usart_Receive+0x4>
	;
	/* Get and return received data from buffer */
	//Usart_SendChar(UDR0);
	return UDR0;
    55ae:	80 91 c6 00 	lds	r24, 0x00C6
}
    55b2:	08 95       	ret

000055b4 <Usart_printf>:
//to use this copy the following as a global- 
//		static FILE mystdout = FDEV_SETUP_STREAM(Usart_printf, NULL, _FDEV_SETUP_WRITE);
// and add this line at the beginning of main:
//		stdout = &mystdout;
//	stdio.h must be used.
int Usart_printf(char var, FILE *stream) {
    55b4:	cf 93       	push	r28
    55b6:	c8 2f       	mov	r28, r24
    // translate \n to \r for br@y++ terminal
    if (var == '\n') Usart_SendChar('\r');
    55b8:	8a 30       	cpi	r24, 0x0A	; 10
    55ba:	19 f4       	brne	.+6      	; 0x55c2 <Usart_printf+0xe>
    55bc:	8d e0       	ldi	r24, 0x0D	; 13
    55be:	0e 94 ca 2a 	call	0x5594	; 0x5594 <Usart_SendChar>
    Usart_SendChar(var);
    55c2:	8c 2f       	mov	r24, r28
    55c4:	0e 94 ca 2a 	call	0x5594	; 0x5594 <Usart_SendChar>
    return 0;
}
    55c8:	80 e0       	ldi	r24, 0x00	; 0
    55ca:	90 e0       	ldi	r25, 0x00	; 0
    55cc:	cf 91       	pop	r28
    55ce:	08 95       	ret

000055d0 <Usart_get_line>:

void Usart_get_line (char *buff, int len)
{
    55d0:	ef 92       	push	r14
    55d2:	ff 92       	push	r15
    55d4:	0f 93       	push	r16
    55d6:	1f 93       	push	r17
    55d8:	cf 93       	push	r28
    55da:	df 93       	push	r29
    55dc:	7c 01       	movw	r14, r24
	cli();
    55de:	f8 94       	cli
	char c;
	int i = 0;
    55e0:	c0 e0       	ldi	r28, 0x00	; 0
    55e2:	d0 e0       	ldi	r29, 0x00	; 0
		if ((c == '\b') && i) {
			i--;
			Usart_SendChar(c);
			continue;
		}
		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    55e4:	8b 01       	movw	r16, r22
    55e6:	01 50       	subi	r16, 0x01	; 1
    55e8:	10 40       	sbci	r17, 0x00	; 0
	char c;
	int i = 0;


	for (;;) {
		c = Usart_Receive();
    55ea:	0e 94 d2 2a 	call	0x55a4	; 0x55a4 <Usart_Receive>
		if (c == '\r') break;
    55ee:	8d 30       	cpi	r24, 0x0D	; 13
    55f0:	a9 f0       	breq	.+42     	; 0x561c <Usart_get_line+0x4c>
		if ((c == '\b') && i) {
    55f2:	88 30       	cpi	r24, 0x08	; 8
    55f4:	31 f4       	brne	.+12     	; 0x5602 <Usart_get_line+0x32>
    55f6:	20 97       	sbiw	r28, 0x00	; 0
    55f8:	c1 f3       	breq	.-16     	; 0x55ea <Usart_get_line+0x1a>
			i--;
    55fa:	21 97       	sbiw	r28, 0x01	; 1
			Usart_SendChar(c);
    55fc:	0e 94 ca 2a 	call	0x5594	; 0x5594 <Usart_SendChar>
			continue;
    5600:	f4 cf       	rjmp	.-24     	; 0x55ea <Usart_get_line+0x1a>
		}
		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    5602:	80 32       	cpi	r24, 0x20	; 32
    5604:	90 f3       	brcs	.-28     	; 0x55ea <Usart_get_line+0x1a>
    5606:	c0 17       	cp	r28, r16
    5608:	d1 07       	cpc	r29, r17
    560a:	7c f7       	brge	.-34     	; 0x55ea <Usart_get_line+0x1a>
			buff[i++] = c;
    560c:	f7 01       	movw	r30, r14
    560e:	ec 0f       	add	r30, r28
    5610:	fd 1f       	adc	r31, r29
    5612:	80 83       	st	Z, r24
    5614:	21 96       	adiw	r28, 0x01	; 1
			Usart_SendChar(c);
    5616:	0e 94 ca 2a 	call	0x5594	; 0x5594 <Usart_SendChar>
    561a:	e7 cf       	rjmp	.-50     	; 0x55ea <Usart_get_line+0x1a>
		}
	}
	buff[i] = 0;
    561c:	ce 0d       	add	r28, r14
    561e:	df 1d       	adc	r29, r15
    5620:	18 82       	st	Y, r1
	Usart_SendChar('\n');
    5622:	8a e0       	ldi	r24, 0x0A	; 10
    5624:	0e 94 ca 2a 	call	0x5594	; 0x5594 <Usart_SendChar>
	sei();
    5628:	78 94       	sei
}
    562a:	df 91       	pop	r29
    562c:	cf 91       	pop	r28
    562e:	1f 91       	pop	r17
    5630:	0f 91       	pop	r16
    5632:	ff 90       	pop	r15
    5634:	ef 90       	pop	r14
    5636:	08 95       	ret

00005638 <USART0_Senduint16>:
void USART0_Senduint16 (uint16_t Data)
{
    5638:	cf 93       	push	r28
    563a:	c8 2f       	mov	r28, r24
	Usart_SendChar(Data >> 8);
    563c:	89 2f       	mov	r24, r25
    563e:	0e 94 ca 2a 	call	0x5594	; 0x5594 <Usart_SendChar>
	Usart_SendChar(Data & 0xFF);
    5642:	8c 2f       	mov	r24, r28
    5644:	0e 94 ca 2a 	call	0x5594	; 0x5594 <Usart_SendChar>
    5648:	cf 91       	pop	r28
    564a:	08 95       	ret

0000564c <__mulsi3>:
    564c:	62 9f       	mul	r22, r18
    564e:	d0 01       	movw	r26, r0
    5650:	73 9f       	mul	r23, r19
    5652:	f0 01       	movw	r30, r0
    5654:	82 9f       	mul	r24, r18
    5656:	e0 0d       	add	r30, r0
    5658:	f1 1d       	adc	r31, r1
    565a:	64 9f       	mul	r22, r20
    565c:	e0 0d       	add	r30, r0
    565e:	f1 1d       	adc	r31, r1
    5660:	92 9f       	mul	r25, r18
    5662:	f0 0d       	add	r31, r0
    5664:	83 9f       	mul	r24, r19
    5666:	f0 0d       	add	r31, r0
    5668:	74 9f       	mul	r23, r20
    566a:	f0 0d       	add	r31, r0
    566c:	65 9f       	mul	r22, r21
    566e:	f0 0d       	add	r31, r0
    5670:	99 27       	eor	r25, r25
    5672:	72 9f       	mul	r23, r18
    5674:	b0 0d       	add	r27, r0
    5676:	e1 1d       	adc	r30, r1
    5678:	f9 1f       	adc	r31, r25
    567a:	63 9f       	mul	r22, r19
    567c:	b0 0d       	add	r27, r0
    567e:	e1 1d       	adc	r30, r1
    5680:	f9 1f       	adc	r31, r25
    5682:	bd 01       	movw	r22, r26
    5684:	cf 01       	movw	r24, r30
    5686:	11 24       	eor	r1, r1
    5688:	08 95       	ret

0000568a <__udivmodsi4>:
    568a:	a1 e2       	ldi	r26, 0x21	; 33
    568c:	1a 2e       	mov	r1, r26
    568e:	aa 1b       	sub	r26, r26
    5690:	bb 1b       	sub	r27, r27
    5692:	fd 01       	movw	r30, r26
    5694:	0d c0       	rjmp	.+26     	; 0x56b0 <__udivmodsi4_ep>

00005696 <__udivmodsi4_loop>:
    5696:	aa 1f       	adc	r26, r26
    5698:	bb 1f       	adc	r27, r27
    569a:	ee 1f       	adc	r30, r30
    569c:	ff 1f       	adc	r31, r31
    569e:	a2 17       	cp	r26, r18
    56a0:	b3 07       	cpc	r27, r19
    56a2:	e4 07       	cpc	r30, r20
    56a4:	f5 07       	cpc	r31, r21
    56a6:	20 f0       	brcs	.+8      	; 0x56b0 <__udivmodsi4_ep>
    56a8:	a2 1b       	sub	r26, r18
    56aa:	b3 0b       	sbc	r27, r19
    56ac:	e4 0b       	sbc	r30, r20
    56ae:	f5 0b       	sbc	r31, r21

000056b0 <__udivmodsi4_ep>:
    56b0:	66 1f       	adc	r22, r22
    56b2:	77 1f       	adc	r23, r23
    56b4:	88 1f       	adc	r24, r24
    56b6:	99 1f       	adc	r25, r25
    56b8:	1a 94       	dec	r1
    56ba:	69 f7       	brne	.-38     	; 0x5696 <__udivmodsi4_loop>
    56bc:	60 95       	com	r22
    56be:	70 95       	com	r23
    56c0:	80 95       	com	r24
    56c2:	90 95       	com	r25
    56c4:	9b 01       	movw	r18, r22
    56c6:	ac 01       	movw	r20, r24
    56c8:	bd 01       	movw	r22, r26
    56ca:	cf 01       	movw	r24, r30
    56cc:	08 95       	ret

000056ce <sprintf>:
    56ce:	ae e0       	ldi	r26, 0x0E	; 14
    56d0:	b0 e0       	ldi	r27, 0x00	; 0
    56d2:	ed e6       	ldi	r30, 0x6D	; 109
    56d4:	fb e2       	ldi	r31, 0x2B	; 43
    56d6:	0c 94 15 2e 	jmp	0x5c2a	; 0x5c2a <__prologue_saves__+0x1c>
    56da:	0d 89       	ldd	r16, Y+21	; 0x15
    56dc:	1e 89       	ldd	r17, Y+22	; 0x16
    56de:	86 e0       	ldi	r24, 0x06	; 6
    56e0:	8c 83       	std	Y+4, r24	; 0x04
    56e2:	1a 83       	std	Y+2, r17	; 0x02
    56e4:	09 83       	std	Y+1, r16	; 0x01
    56e6:	8f ef       	ldi	r24, 0xFF	; 255
    56e8:	9f e7       	ldi	r25, 0x7F	; 127
    56ea:	9e 83       	std	Y+6, r25	; 0x06
    56ec:	8d 83       	std	Y+5, r24	; 0x05
    56ee:	ae 01       	movw	r20, r28
    56f0:	47 5e       	subi	r20, 0xE7	; 231
    56f2:	5f 4f       	sbci	r21, 0xFF	; 255
    56f4:	ce 01       	movw	r24, r28
    56f6:	01 96       	adiw	r24, 0x01	; 1
    56f8:	6f 89       	ldd	r22, Y+23	; 0x17
    56fa:	78 8d       	ldd	r23, Y+24	; 0x18
    56fc:	0e 94 89 2b 	call	0x5712	; 0x5712 <vfprintf>
    5700:	ef 81       	ldd	r30, Y+7	; 0x07
    5702:	f8 85       	ldd	r31, Y+8	; 0x08
    5704:	e0 0f       	add	r30, r16
    5706:	f1 1f       	adc	r31, r17
    5708:	10 82       	st	Z, r1
    570a:	2e 96       	adiw	r28, 0x0e	; 14
    570c:	e4 e0       	ldi	r30, 0x04	; 4
    570e:	0c 94 31 2e 	jmp	0x5c62	; 0x5c62 <__epilogue_restores__+0x1c>

00005712 <vfprintf>:
    5712:	ad e0       	ldi	r26, 0x0D	; 13
    5714:	b0 e0       	ldi	r27, 0x00	; 0
    5716:	ef e8       	ldi	r30, 0x8F	; 143
    5718:	fb e2       	ldi	r31, 0x2B	; 43
    571a:	0c 94 07 2e 	jmp	0x5c0e	; 0x5c0e <__prologue_saves__>
    571e:	3c 01       	movw	r6, r24
    5720:	7d 87       	std	Y+13, r23	; 0x0d
    5722:	6c 87       	std	Y+12, r22	; 0x0c
    5724:	5a 01       	movw	r10, r20
    5726:	fc 01       	movw	r30, r24
    5728:	17 82       	std	Z+7, r1	; 0x07
    572a:	16 82       	std	Z+6, r1	; 0x06
    572c:	83 81       	ldd	r24, Z+3	; 0x03
    572e:	81 ff       	sbrs	r24, 1
    5730:	c8 c1       	rjmp	.+912    	; 0x5ac2 <vfprintf+0x3b0>
    5732:	2e 01       	movw	r4, r28
    5734:	08 94       	sec
    5736:	41 1c       	adc	r4, r1
    5738:	51 1c       	adc	r5, r1
    573a:	f3 01       	movw	r30, r6
    573c:	93 81       	ldd	r25, Z+3	; 0x03
    573e:	ec 85       	ldd	r30, Y+12	; 0x0c
    5740:	fd 85       	ldd	r31, Y+13	; 0x0d
    5742:	93 fd       	sbrc	r25, 3
    5744:	85 91       	lpm	r24, Z+
    5746:	93 ff       	sbrs	r25, 3
    5748:	81 91       	ld	r24, Z+
    574a:	fd 87       	std	Y+13, r31	; 0x0d
    574c:	ec 87       	std	Y+12, r30	; 0x0c
    574e:	88 23       	and	r24, r24
    5750:	09 f4       	brne	.+2      	; 0x5754 <vfprintf+0x42>
    5752:	b3 c1       	rjmp	.+870    	; 0x5aba <vfprintf+0x3a8>
    5754:	85 32       	cpi	r24, 0x25	; 37
    5756:	41 f4       	brne	.+16     	; 0x5768 <vfprintf+0x56>
    5758:	93 fd       	sbrc	r25, 3
    575a:	85 91       	lpm	r24, Z+
    575c:	93 ff       	sbrs	r25, 3
    575e:	81 91       	ld	r24, Z+
    5760:	fd 87       	std	Y+13, r31	; 0x0d
    5762:	ec 87       	std	Y+12, r30	; 0x0c
    5764:	85 32       	cpi	r24, 0x25	; 37
    5766:	29 f4       	brne	.+10     	; 0x5772 <vfprintf+0x60>
    5768:	90 e0       	ldi	r25, 0x00	; 0
    576a:	b3 01       	movw	r22, r6
    576c:	0e 94 7d 2d 	call	0x5afa	; 0x5afa <fputc>
    5770:	e4 cf       	rjmp	.-56     	; 0x573a <vfprintf+0x28>
    5772:	ff 24       	eor	r15, r15
    5774:	ee 24       	eor	r14, r14
    5776:	10 e0       	ldi	r17, 0x00	; 0
    5778:	10 32       	cpi	r17, 0x20	; 32
    577a:	b0 f4       	brcc	.+44     	; 0x57a8 <vfprintf+0x96>
    577c:	8b 32       	cpi	r24, 0x2B	; 43
    577e:	69 f0       	breq	.+26     	; 0x579a <vfprintf+0x88>
    5780:	8c 32       	cpi	r24, 0x2C	; 44
    5782:	28 f4       	brcc	.+10     	; 0x578e <vfprintf+0x7c>
    5784:	80 32       	cpi	r24, 0x20	; 32
    5786:	51 f0       	breq	.+20     	; 0x579c <vfprintf+0x8a>
    5788:	83 32       	cpi	r24, 0x23	; 35
    578a:	71 f4       	brne	.+28     	; 0x57a8 <vfprintf+0x96>
    578c:	0b c0       	rjmp	.+22     	; 0x57a4 <vfprintf+0x92>
    578e:	8d 32       	cpi	r24, 0x2D	; 45
    5790:	39 f0       	breq	.+14     	; 0x57a0 <vfprintf+0x8e>
    5792:	80 33       	cpi	r24, 0x30	; 48
    5794:	49 f4       	brne	.+18     	; 0x57a8 <vfprintf+0x96>
    5796:	11 60       	ori	r17, 0x01	; 1
    5798:	2c c0       	rjmp	.+88     	; 0x57f2 <vfprintf+0xe0>
    579a:	12 60       	ori	r17, 0x02	; 2
    579c:	14 60       	ori	r17, 0x04	; 4
    579e:	29 c0       	rjmp	.+82     	; 0x57f2 <vfprintf+0xe0>
    57a0:	18 60       	ori	r17, 0x08	; 8
    57a2:	27 c0       	rjmp	.+78     	; 0x57f2 <vfprintf+0xe0>
    57a4:	10 61       	ori	r17, 0x10	; 16
    57a6:	25 c0       	rjmp	.+74     	; 0x57f2 <vfprintf+0xe0>
    57a8:	17 fd       	sbrc	r17, 7
    57aa:	2e c0       	rjmp	.+92     	; 0x5808 <vfprintf+0xf6>
    57ac:	28 2f       	mov	r18, r24
    57ae:	20 53       	subi	r18, 0x30	; 48
    57b0:	2a 30       	cpi	r18, 0x0A	; 10
    57b2:	98 f4       	brcc	.+38     	; 0x57da <vfprintf+0xc8>
    57b4:	16 ff       	sbrs	r17, 6
    57b6:	08 c0       	rjmp	.+16     	; 0x57c8 <vfprintf+0xb6>
    57b8:	8f 2d       	mov	r24, r15
    57ba:	88 0f       	add	r24, r24
    57bc:	f8 2e       	mov	r15, r24
    57be:	ff 0c       	add	r15, r15
    57c0:	ff 0c       	add	r15, r15
    57c2:	f8 0e       	add	r15, r24
    57c4:	f2 0e       	add	r15, r18
    57c6:	15 c0       	rjmp	.+42     	; 0x57f2 <vfprintf+0xe0>
    57c8:	8e 2d       	mov	r24, r14
    57ca:	88 0f       	add	r24, r24
    57cc:	e8 2e       	mov	r14, r24
    57ce:	ee 0c       	add	r14, r14
    57d0:	ee 0c       	add	r14, r14
    57d2:	e8 0e       	add	r14, r24
    57d4:	e2 0e       	add	r14, r18
    57d6:	10 62       	ori	r17, 0x20	; 32
    57d8:	0c c0       	rjmp	.+24     	; 0x57f2 <vfprintf+0xe0>
    57da:	8e 32       	cpi	r24, 0x2E	; 46
    57dc:	21 f4       	brne	.+8      	; 0x57e6 <vfprintf+0xd4>
    57de:	16 fd       	sbrc	r17, 6
    57e0:	6c c1       	rjmp	.+728    	; 0x5aba <vfprintf+0x3a8>
    57e2:	10 64       	ori	r17, 0x40	; 64
    57e4:	06 c0       	rjmp	.+12     	; 0x57f2 <vfprintf+0xe0>
    57e6:	8c 36       	cpi	r24, 0x6C	; 108
    57e8:	11 f4       	brne	.+4      	; 0x57ee <vfprintf+0xdc>
    57ea:	10 68       	ori	r17, 0x80	; 128
    57ec:	02 c0       	rjmp	.+4      	; 0x57f2 <vfprintf+0xe0>
    57ee:	88 36       	cpi	r24, 0x68	; 104
    57f0:	59 f4       	brne	.+22     	; 0x5808 <vfprintf+0xf6>
    57f2:	ec 85       	ldd	r30, Y+12	; 0x0c
    57f4:	fd 85       	ldd	r31, Y+13	; 0x0d
    57f6:	93 fd       	sbrc	r25, 3
    57f8:	85 91       	lpm	r24, Z+
    57fa:	93 ff       	sbrs	r25, 3
    57fc:	81 91       	ld	r24, Z+
    57fe:	fd 87       	std	Y+13, r31	; 0x0d
    5800:	ec 87       	std	Y+12, r30	; 0x0c
    5802:	88 23       	and	r24, r24
    5804:	09 f0       	breq	.+2      	; 0x5808 <vfprintf+0xf6>
    5806:	b8 cf       	rjmp	.-144    	; 0x5778 <vfprintf+0x66>
    5808:	98 2f       	mov	r25, r24
    580a:	95 54       	subi	r25, 0x45	; 69
    580c:	93 30       	cpi	r25, 0x03	; 3
    580e:	18 f0       	brcs	.+6      	; 0x5816 <vfprintf+0x104>
    5810:	90 52       	subi	r25, 0x20	; 32
    5812:	93 30       	cpi	r25, 0x03	; 3
    5814:	38 f4       	brcc	.+14     	; 0x5824 <vfprintf+0x112>
    5816:	24 e0       	ldi	r18, 0x04	; 4
    5818:	30 e0       	ldi	r19, 0x00	; 0
    581a:	a2 0e       	add	r10, r18
    581c:	b3 1e       	adc	r11, r19
    581e:	3f e3       	ldi	r19, 0x3F	; 63
    5820:	39 83       	std	Y+1, r19	; 0x01
    5822:	0f c0       	rjmp	.+30     	; 0x5842 <vfprintf+0x130>
    5824:	83 36       	cpi	r24, 0x63	; 99
    5826:	31 f0       	breq	.+12     	; 0x5834 <vfprintf+0x122>
    5828:	83 37       	cpi	r24, 0x73	; 115
    582a:	81 f0       	breq	.+32     	; 0x584c <vfprintf+0x13a>
    582c:	83 35       	cpi	r24, 0x53	; 83
    582e:	09 f0       	breq	.+2      	; 0x5832 <vfprintf+0x120>
    5830:	5a c0       	rjmp	.+180    	; 0x58e6 <vfprintf+0x1d4>
    5832:	22 c0       	rjmp	.+68     	; 0x5878 <vfprintf+0x166>
    5834:	f5 01       	movw	r30, r10
    5836:	80 81       	ld	r24, Z
    5838:	89 83       	std	Y+1, r24	; 0x01
    583a:	22 e0       	ldi	r18, 0x02	; 2
    583c:	30 e0       	ldi	r19, 0x00	; 0
    583e:	a2 0e       	add	r10, r18
    5840:	b3 1e       	adc	r11, r19
    5842:	21 e0       	ldi	r18, 0x01	; 1
    5844:	c2 2e       	mov	r12, r18
    5846:	d1 2c       	mov	r13, r1
    5848:	42 01       	movw	r8, r4
    584a:	14 c0       	rjmp	.+40     	; 0x5874 <vfprintf+0x162>
    584c:	92 e0       	ldi	r25, 0x02	; 2
    584e:	29 2e       	mov	r2, r25
    5850:	31 2c       	mov	r3, r1
    5852:	2a 0c       	add	r2, r10
    5854:	3b 1c       	adc	r3, r11
    5856:	f5 01       	movw	r30, r10
    5858:	80 80       	ld	r8, Z
    585a:	91 80       	ldd	r9, Z+1	; 0x01
    585c:	16 ff       	sbrs	r17, 6
    585e:	03 c0       	rjmp	.+6      	; 0x5866 <vfprintf+0x154>
    5860:	6f 2d       	mov	r22, r15
    5862:	70 e0       	ldi	r23, 0x00	; 0
    5864:	02 c0       	rjmp	.+4      	; 0x586a <vfprintf+0x158>
    5866:	6f ef       	ldi	r22, 0xFF	; 255
    5868:	7f ef       	ldi	r23, 0xFF	; 255
    586a:	c4 01       	movw	r24, r8
    586c:	0e 94 72 2d 	call	0x5ae4	; 0x5ae4 <strnlen>
    5870:	6c 01       	movw	r12, r24
    5872:	51 01       	movw	r10, r2
    5874:	1f 77       	andi	r17, 0x7F	; 127
    5876:	15 c0       	rjmp	.+42     	; 0x58a2 <vfprintf+0x190>
    5878:	82 e0       	ldi	r24, 0x02	; 2
    587a:	28 2e       	mov	r2, r24
    587c:	31 2c       	mov	r3, r1
    587e:	2a 0c       	add	r2, r10
    5880:	3b 1c       	adc	r3, r11
    5882:	f5 01       	movw	r30, r10
    5884:	80 80       	ld	r8, Z
    5886:	91 80       	ldd	r9, Z+1	; 0x01
    5888:	16 ff       	sbrs	r17, 6
    588a:	03 c0       	rjmp	.+6      	; 0x5892 <vfprintf+0x180>
    588c:	6f 2d       	mov	r22, r15
    588e:	70 e0       	ldi	r23, 0x00	; 0
    5890:	02 c0       	rjmp	.+4      	; 0x5896 <vfprintf+0x184>
    5892:	6f ef       	ldi	r22, 0xFF	; 255
    5894:	7f ef       	ldi	r23, 0xFF	; 255
    5896:	c4 01       	movw	r24, r8
    5898:	0e 94 67 2d 	call	0x5ace	; 0x5ace <strnlen_P>
    589c:	6c 01       	movw	r12, r24
    589e:	10 68       	ori	r17, 0x80	; 128
    58a0:	51 01       	movw	r10, r2
    58a2:	13 fd       	sbrc	r17, 3
    58a4:	1c c0       	rjmp	.+56     	; 0x58de <vfprintf+0x1cc>
    58a6:	06 c0       	rjmp	.+12     	; 0x58b4 <vfprintf+0x1a2>
    58a8:	80 e2       	ldi	r24, 0x20	; 32
    58aa:	90 e0       	ldi	r25, 0x00	; 0
    58ac:	b3 01       	movw	r22, r6
    58ae:	0e 94 7d 2d 	call	0x5afa	; 0x5afa <fputc>
    58b2:	ea 94       	dec	r14
    58b4:	8e 2d       	mov	r24, r14
    58b6:	90 e0       	ldi	r25, 0x00	; 0
    58b8:	c8 16       	cp	r12, r24
    58ba:	d9 06       	cpc	r13, r25
    58bc:	a8 f3       	brcs	.-22     	; 0x58a8 <vfprintf+0x196>
    58be:	0f c0       	rjmp	.+30     	; 0x58de <vfprintf+0x1cc>
    58c0:	f4 01       	movw	r30, r8
    58c2:	17 fd       	sbrc	r17, 7
    58c4:	85 91       	lpm	r24, Z+
    58c6:	17 ff       	sbrs	r17, 7
    58c8:	81 91       	ld	r24, Z+
    58ca:	4f 01       	movw	r8, r30
    58cc:	90 e0       	ldi	r25, 0x00	; 0
    58ce:	b3 01       	movw	r22, r6
    58d0:	0e 94 7d 2d 	call	0x5afa	; 0x5afa <fputc>
    58d4:	e1 10       	cpse	r14, r1
    58d6:	ea 94       	dec	r14
    58d8:	08 94       	sec
    58da:	c1 08       	sbc	r12, r1
    58dc:	d1 08       	sbc	r13, r1
    58de:	c1 14       	cp	r12, r1
    58e0:	d1 04       	cpc	r13, r1
    58e2:	71 f7       	brne	.-36     	; 0x58c0 <vfprintf+0x1ae>
    58e4:	e7 c0       	rjmp	.+462    	; 0x5ab4 <vfprintf+0x3a2>
    58e6:	84 36       	cpi	r24, 0x64	; 100
    58e8:	11 f0       	breq	.+4      	; 0x58ee <vfprintf+0x1dc>
    58ea:	89 36       	cpi	r24, 0x69	; 105
    58ec:	51 f5       	brne	.+84     	; 0x5942 <vfprintf+0x230>
    58ee:	f5 01       	movw	r30, r10
    58f0:	17 ff       	sbrs	r17, 7
    58f2:	07 c0       	rjmp	.+14     	; 0x5902 <vfprintf+0x1f0>
    58f4:	80 81       	ld	r24, Z
    58f6:	91 81       	ldd	r25, Z+1	; 0x01
    58f8:	a2 81       	ldd	r26, Z+2	; 0x02
    58fa:	b3 81       	ldd	r27, Z+3	; 0x03
    58fc:	24 e0       	ldi	r18, 0x04	; 4
    58fe:	30 e0       	ldi	r19, 0x00	; 0
    5900:	08 c0       	rjmp	.+16     	; 0x5912 <vfprintf+0x200>
    5902:	80 81       	ld	r24, Z
    5904:	91 81       	ldd	r25, Z+1	; 0x01
    5906:	aa 27       	eor	r26, r26
    5908:	97 fd       	sbrc	r25, 7
    590a:	a0 95       	com	r26
    590c:	ba 2f       	mov	r27, r26
    590e:	22 e0       	ldi	r18, 0x02	; 2
    5910:	30 e0       	ldi	r19, 0x00	; 0
    5912:	a2 0e       	add	r10, r18
    5914:	b3 1e       	adc	r11, r19
    5916:	01 2f       	mov	r16, r17
    5918:	0f 76       	andi	r16, 0x6F	; 111
    591a:	b7 ff       	sbrs	r27, 7
    591c:	08 c0       	rjmp	.+16     	; 0x592e <vfprintf+0x21c>
    591e:	b0 95       	com	r27
    5920:	a0 95       	com	r26
    5922:	90 95       	com	r25
    5924:	81 95       	neg	r24
    5926:	9f 4f       	sbci	r25, 0xFF	; 255
    5928:	af 4f       	sbci	r26, 0xFF	; 255
    592a:	bf 4f       	sbci	r27, 0xFF	; 255
    592c:	00 68       	ori	r16, 0x80	; 128
    592e:	bc 01       	movw	r22, r24
    5930:	cd 01       	movw	r24, r26
    5932:	a2 01       	movw	r20, r4
    5934:	2a e0       	ldi	r18, 0x0A	; 10
    5936:	30 e0       	ldi	r19, 0x00	; 0
    5938:	0e 94 a9 2d 	call	0x5b52	; 0x5b52 <__ultoa_invert>
    593c:	d8 2e       	mov	r13, r24
    593e:	d4 18       	sub	r13, r4
    5940:	3f c0       	rjmp	.+126    	; 0x59c0 <vfprintf+0x2ae>
    5942:	85 37       	cpi	r24, 0x75	; 117
    5944:	21 f4       	brne	.+8      	; 0x594e <vfprintf+0x23c>
    5946:	1f 7e       	andi	r17, 0xEF	; 239
    5948:	2a e0       	ldi	r18, 0x0A	; 10
    594a:	30 e0       	ldi	r19, 0x00	; 0
    594c:	20 c0       	rjmp	.+64     	; 0x598e <vfprintf+0x27c>
    594e:	19 7f       	andi	r17, 0xF9	; 249
    5950:	8f 36       	cpi	r24, 0x6F	; 111
    5952:	a9 f0       	breq	.+42     	; 0x597e <vfprintf+0x26c>
    5954:	80 37       	cpi	r24, 0x70	; 112
    5956:	20 f4       	brcc	.+8      	; 0x5960 <vfprintf+0x24e>
    5958:	88 35       	cpi	r24, 0x58	; 88
    595a:	09 f0       	breq	.+2      	; 0x595e <vfprintf+0x24c>
    595c:	ae c0       	rjmp	.+348    	; 0x5aba <vfprintf+0x3a8>
    595e:	0b c0       	rjmp	.+22     	; 0x5976 <vfprintf+0x264>
    5960:	80 37       	cpi	r24, 0x70	; 112
    5962:	21 f0       	breq	.+8      	; 0x596c <vfprintf+0x25a>
    5964:	88 37       	cpi	r24, 0x78	; 120
    5966:	09 f0       	breq	.+2      	; 0x596a <vfprintf+0x258>
    5968:	a8 c0       	rjmp	.+336    	; 0x5aba <vfprintf+0x3a8>
    596a:	01 c0       	rjmp	.+2      	; 0x596e <vfprintf+0x25c>
    596c:	10 61       	ori	r17, 0x10	; 16
    596e:	14 ff       	sbrs	r17, 4
    5970:	09 c0       	rjmp	.+18     	; 0x5984 <vfprintf+0x272>
    5972:	14 60       	ori	r17, 0x04	; 4
    5974:	07 c0       	rjmp	.+14     	; 0x5984 <vfprintf+0x272>
    5976:	14 ff       	sbrs	r17, 4
    5978:	08 c0       	rjmp	.+16     	; 0x598a <vfprintf+0x278>
    597a:	16 60       	ori	r17, 0x06	; 6
    597c:	06 c0       	rjmp	.+12     	; 0x598a <vfprintf+0x278>
    597e:	28 e0       	ldi	r18, 0x08	; 8
    5980:	30 e0       	ldi	r19, 0x00	; 0
    5982:	05 c0       	rjmp	.+10     	; 0x598e <vfprintf+0x27c>
    5984:	20 e1       	ldi	r18, 0x10	; 16
    5986:	30 e0       	ldi	r19, 0x00	; 0
    5988:	02 c0       	rjmp	.+4      	; 0x598e <vfprintf+0x27c>
    598a:	20 e1       	ldi	r18, 0x10	; 16
    598c:	32 e0       	ldi	r19, 0x02	; 2
    598e:	f5 01       	movw	r30, r10
    5990:	17 ff       	sbrs	r17, 7
    5992:	07 c0       	rjmp	.+14     	; 0x59a2 <vfprintf+0x290>
    5994:	60 81       	ld	r22, Z
    5996:	71 81       	ldd	r23, Z+1	; 0x01
    5998:	82 81       	ldd	r24, Z+2	; 0x02
    599a:	93 81       	ldd	r25, Z+3	; 0x03
    599c:	44 e0       	ldi	r20, 0x04	; 4
    599e:	50 e0       	ldi	r21, 0x00	; 0
    59a0:	06 c0       	rjmp	.+12     	; 0x59ae <vfprintf+0x29c>
    59a2:	60 81       	ld	r22, Z
    59a4:	71 81       	ldd	r23, Z+1	; 0x01
    59a6:	80 e0       	ldi	r24, 0x00	; 0
    59a8:	90 e0       	ldi	r25, 0x00	; 0
    59aa:	42 e0       	ldi	r20, 0x02	; 2
    59ac:	50 e0       	ldi	r21, 0x00	; 0
    59ae:	a4 0e       	add	r10, r20
    59b0:	b5 1e       	adc	r11, r21
    59b2:	a2 01       	movw	r20, r4
    59b4:	0e 94 a9 2d 	call	0x5b52	; 0x5b52 <__ultoa_invert>
    59b8:	d8 2e       	mov	r13, r24
    59ba:	d4 18       	sub	r13, r4
    59bc:	01 2f       	mov	r16, r17
    59be:	0f 77       	andi	r16, 0x7F	; 127
    59c0:	06 ff       	sbrs	r16, 6
    59c2:	09 c0       	rjmp	.+18     	; 0x59d6 <vfprintf+0x2c4>
    59c4:	0e 7f       	andi	r16, 0xFE	; 254
    59c6:	df 14       	cp	r13, r15
    59c8:	30 f4       	brcc	.+12     	; 0x59d6 <vfprintf+0x2c4>
    59ca:	04 ff       	sbrs	r16, 4
    59cc:	06 c0       	rjmp	.+12     	; 0x59da <vfprintf+0x2c8>
    59ce:	02 fd       	sbrc	r16, 2
    59d0:	04 c0       	rjmp	.+8      	; 0x59da <vfprintf+0x2c8>
    59d2:	0f 7e       	andi	r16, 0xEF	; 239
    59d4:	02 c0       	rjmp	.+4      	; 0x59da <vfprintf+0x2c8>
    59d6:	1d 2d       	mov	r17, r13
    59d8:	01 c0       	rjmp	.+2      	; 0x59dc <vfprintf+0x2ca>
    59da:	1f 2d       	mov	r17, r15
    59dc:	80 2f       	mov	r24, r16
    59de:	90 e0       	ldi	r25, 0x00	; 0
    59e0:	04 ff       	sbrs	r16, 4
    59e2:	0c c0       	rjmp	.+24     	; 0x59fc <vfprintf+0x2ea>
    59e4:	fe 01       	movw	r30, r28
    59e6:	ed 0d       	add	r30, r13
    59e8:	f1 1d       	adc	r31, r1
    59ea:	20 81       	ld	r18, Z
    59ec:	20 33       	cpi	r18, 0x30	; 48
    59ee:	11 f4       	brne	.+4      	; 0x59f4 <vfprintf+0x2e2>
    59f0:	09 7e       	andi	r16, 0xE9	; 233
    59f2:	09 c0       	rjmp	.+18     	; 0x5a06 <vfprintf+0x2f4>
    59f4:	02 ff       	sbrs	r16, 2
    59f6:	06 c0       	rjmp	.+12     	; 0x5a04 <vfprintf+0x2f2>
    59f8:	1e 5f       	subi	r17, 0xFE	; 254
    59fa:	05 c0       	rjmp	.+10     	; 0x5a06 <vfprintf+0x2f4>
    59fc:	86 78       	andi	r24, 0x86	; 134
    59fe:	90 70       	andi	r25, 0x00	; 0
    5a00:	00 97       	sbiw	r24, 0x00	; 0
    5a02:	09 f0       	breq	.+2      	; 0x5a06 <vfprintf+0x2f4>
    5a04:	1f 5f       	subi	r17, 0xFF	; 255
    5a06:	80 2e       	mov	r8, r16
    5a08:	99 24       	eor	r9, r9
    5a0a:	03 fd       	sbrc	r16, 3
    5a0c:	12 c0       	rjmp	.+36     	; 0x5a32 <vfprintf+0x320>
    5a0e:	00 ff       	sbrs	r16, 0
    5a10:	0d c0       	rjmp	.+26     	; 0x5a2c <vfprintf+0x31a>
    5a12:	fd 2c       	mov	r15, r13
    5a14:	1e 15       	cp	r17, r14
    5a16:	50 f4       	brcc	.+20     	; 0x5a2c <vfprintf+0x31a>
    5a18:	fe 0c       	add	r15, r14
    5a1a:	f1 1a       	sub	r15, r17
    5a1c:	1e 2d       	mov	r17, r14
    5a1e:	06 c0       	rjmp	.+12     	; 0x5a2c <vfprintf+0x31a>
    5a20:	80 e2       	ldi	r24, 0x20	; 32
    5a22:	90 e0       	ldi	r25, 0x00	; 0
    5a24:	b3 01       	movw	r22, r6
    5a26:	0e 94 7d 2d 	call	0x5afa	; 0x5afa <fputc>
    5a2a:	1f 5f       	subi	r17, 0xFF	; 255
    5a2c:	1e 15       	cp	r17, r14
    5a2e:	c0 f3       	brcs	.-16     	; 0x5a20 <vfprintf+0x30e>
    5a30:	04 c0       	rjmp	.+8      	; 0x5a3a <vfprintf+0x328>
    5a32:	1e 15       	cp	r17, r14
    5a34:	10 f4       	brcc	.+4      	; 0x5a3a <vfprintf+0x328>
    5a36:	e1 1a       	sub	r14, r17
    5a38:	01 c0       	rjmp	.+2      	; 0x5a3c <vfprintf+0x32a>
    5a3a:	ee 24       	eor	r14, r14
    5a3c:	84 fe       	sbrs	r8, 4
    5a3e:	0f c0       	rjmp	.+30     	; 0x5a5e <vfprintf+0x34c>
    5a40:	80 e3       	ldi	r24, 0x30	; 48
    5a42:	90 e0       	ldi	r25, 0x00	; 0
    5a44:	b3 01       	movw	r22, r6
    5a46:	0e 94 7d 2d 	call	0x5afa	; 0x5afa <fputc>
    5a4a:	82 fe       	sbrs	r8, 2
    5a4c:	1f c0       	rjmp	.+62     	; 0x5a8c <vfprintf+0x37a>
    5a4e:	81 fe       	sbrs	r8, 1
    5a50:	03 c0       	rjmp	.+6      	; 0x5a58 <vfprintf+0x346>
    5a52:	88 e5       	ldi	r24, 0x58	; 88
    5a54:	90 e0       	ldi	r25, 0x00	; 0
    5a56:	10 c0       	rjmp	.+32     	; 0x5a78 <vfprintf+0x366>
    5a58:	88 e7       	ldi	r24, 0x78	; 120
    5a5a:	90 e0       	ldi	r25, 0x00	; 0
    5a5c:	0d c0       	rjmp	.+26     	; 0x5a78 <vfprintf+0x366>
    5a5e:	c4 01       	movw	r24, r8
    5a60:	86 78       	andi	r24, 0x86	; 134
    5a62:	90 70       	andi	r25, 0x00	; 0
    5a64:	00 97       	sbiw	r24, 0x00	; 0
    5a66:	91 f0       	breq	.+36     	; 0x5a8c <vfprintf+0x37a>
    5a68:	81 fc       	sbrc	r8, 1
    5a6a:	02 c0       	rjmp	.+4      	; 0x5a70 <vfprintf+0x35e>
    5a6c:	80 e2       	ldi	r24, 0x20	; 32
    5a6e:	01 c0       	rjmp	.+2      	; 0x5a72 <vfprintf+0x360>
    5a70:	8b e2       	ldi	r24, 0x2B	; 43
    5a72:	07 fd       	sbrc	r16, 7
    5a74:	8d e2       	ldi	r24, 0x2D	; 45
    5a76:	90 e0       	ldi	r25, 0x00	; 0
    5a78:	b3 01       	movw	r22, r6
    5a7a:	0e 94 7d 2d 	call	0x5afa	; 0x5afa <fputc>
    5a7e:	06 c0       	rjmp	.+12     	; 0x5a8c <vfprintf+0x37a>
    5a80:	80 e3       	ldi	r24, 0x30	; 48
    5a82:	90 e0       	ldi	r25, 0x00	; 0
    5a84:	b3 01       	movw	r22, r6
    5a86:	0e 94 7d 2d 	call	0x5afa	; 0x5afa <fputc>
    5a8a:	fa 94       	dec	r15
    5a8c:	df 14       	cp	r13, r15
    5a8e:	c0 f3       	brcs	.-16     	; 0x5a80 <vfprintf+0x36e>
    5a90:	da 94       	dec	r13
    5a92:	f2 01       	movw	r30, r4
    5a94:	ed 0d       	add	r30, r13
    5a96:	f1 1d       	adc	r31, r1
    5a98:	80 81       	ld	r24, Z
    5a9a:	90 e0       	ldi	r25, 0x00	; 0
    5a9c:	b3 01       	movw	r22, r6
    5a9e:	0e 94 7d 2d 	call	0x5afa	; 0x5afa <fputc>
    5aa2:	dd 20       	and	r13, r13
    5aa4:	a9 f7       	brne	.-22     	; 0x5a90 <vfprintf+0x37e>
    5aa6:	06 c0       	rjmp	.+12     	; 0x5ab4 <vfprintf+0x3a2>
    5aa8:	80 e2       	ldi	r24, 0x20	; 32
    5aaa:	90 e0       	ldi	r25, 0x00	; 0
    5aac:	b3 01       	movw	r22, r6
    5aae:	0e 94 7d 2d 	call	0x5afa	; 0x5afa <fputc>
    5ab2:	ea 94       	dec	r14
    5ab4:	ee 20       	and	r14, r14
    5ab6:	c1 f7       	brne	.-16     	; 0x5aa8 <vfprintf+0x396>
    5ab8:	40 ce       	rjmp	.-896    	; 0x573a <vfprintf+0x28>
    5aba:	f3 01       	movw	r30, r6
    5abc:	86 81       	ldd	r24, Z+6	; 0x06
    5abe:	97 81       	ldd	r25, Z+7	; 0x07
    5ac0:	02 c0       	rjmp	.+4      	; 0x5ac6 <vfprintf+0x3b4>
    5ac2:	8f ef       	ldi	r24, 0xFF	; 255
    5ac4:	9f ef       	ldi	r25, 0xFF	; 255
    5ac6:	2d 96       	adiw	r28, 0x0d	; 13
    5ac8:	e2 e1       	ldi	r30, 0x12	; 18
    5aca:	0c 94 23 2e 	jmp	0x5c46	; 0x5c46 <__epilogue_restores__>

00005ace <strnlen_P>:
    5ace:	fc 01       	movw	r30, r24
    5ad0:	05 90       	lpm	r0, Z+
    5ad2:	61 50       	subi	r22, 0x01	; 1
    5ad4:	70 40       	sbci	r23, 0x00	; 0
    5ad6:	01 10       	cpse	r0, r1
    5ad8:	d8 f7       	brcc	.-10     	; 0x5ad0 <strnlen_P+0x2>
    5ada:	80 95       	com	r24
    5adc:	90 95       	com	r25
    5ade:	8e 0f       	add	r24, r30
    5ae0:	9f 1f       	adc	r25, r31
    5ae2:	08 95       	ret

00005ae4 <strnlen>:
    5ae4:	fc 01       	movw	r30, r24
    5ae6:	61 50       	subi	r22, 0x01	; 1
    5ae8:	70 40       	sbci	r23, 0x00	; 0
    5aea:	01 90       	ld	r0, Z+
    5aec:	01 10       	cpse	r0, r1
    5aee:	d8 f7       	brcc	.-10     	; 0x5ae6 <strnlen+0x2>
    5af0:	80 95       	com	r24
    5af2:	90 95       	com	r25
    5af4:	8e 0f       	add	r24, r30
    5af6:	9f 1f       	adc	r25, r31
    5af8:	08 95       	ret

00005afa <fputc>:
    5afa:	0f 93       	push	r16
    5afc:	1f 93       	push	r17
    5afe:	cf 93       	push	r28
    5b00:	df 93       	push	r29
    5b02:	8c 01       	movw	r16, r24
    5b04:	eb 01       	movw	r28, r22
    5b06:	8b 81       	ldd	r24, Y+3	; 0x03
    5b08:	81 ff       	sbrs	r24, 1
    5b0a:	1b c0       	rjmp	.+54     	; 0x5b42 <fputc+0x48>
    5b0c:	82 ff       	sbrs	r24, 2
    5b0e:	0d c0       	rjmp	.+26     	; 0x5b2a <fputc+0x30>
    5b10:	2e 81       	ldd	r18, Y+6	; 0x06
    5b12:	3f 81       	ldd	r19, Y+7	; 0x07
    5b14:	8c 81       	ldd	r24, Y+4	; 0x04
    5b16:	9d 81       	ldd	r25, Y+5	; 0x05
    5b18:	28 17       	cp	r18, r24
    5b1a:	39 07       	cpc	r19, r25
    5b1c:	64 f4       	brge	.+24     	; 0x5b36 <fputc+0x3c>
    5b1e:	e8 81       	ld	r30, Y
    5b20:	f9 81       	ldd	r31, Y+1	; 0x01
    5b22:	01 93       	st	Z+, r16
    5b24:	f9 83       	std	Y+1, r31	; 0x01
    5b26:	e8 83       	st	Y, r30
    5b28:	06 c0       	rjmp	.+12     	; 0x5b36 <fputc+0x3c>
    5b2a:	e8 85       	ldd	r30, Y+8	; 0x08
    5b2c:	f9 85       	ldd	r31, Y+9	; 0x09
    5b2e:	80 2f       	mov	r24, r16
    5b30:	09 95       	icall
    5b32:	00 97       	sbiw	r24, 0x00	; 0
    5b34:	31 f4       	brne	.+12     	; 0x5b42 <fputc+0x48>
    5b36:	8e 81       	ldd	r24, Y+6	; 0x06
    5b38:	9f 81       	ldd	r25, Y+7	; 0x07
    5b3a:	01 96       	adiw	r24, 0x01	; 1
    5b3c:	9f 83       	std	Y+7, r25	; 0x07
    5b3e:	8e 83       	std	Y+6, r24	; 0x06
    5b40:	02 c0       	rjmp	.+4      	; 0x5b46 <fputc+0x4c>
    5b42:	0f ef       	ldi	r16, 0xFF	; 255
    5b44:	1f ef       	ldi	r17, 0xFF	; 255
    5b46:	c8 01       	movw	r24, r16
    5b48:	df 91       	pop	r29
    5b4a:	cf 91       	pop	r28
    5b4c:	1f 91       	pop	r17
    5b4e:	0f 91       	pop	r16
    5b50:	08 95       	ret

00005b52 <__ultoa_invert>:
    5b52:	fa 01       	movw	r30, r20
    5b54:	aa 27       	eor	r26, r26
    5b56:	28 30       	cpi	r18, 0x08	; 8
    5b58:	51 f1       	breq	.+84     	; 0x5bae <__ultoa_invert+0x5c>
    5b5a:	20 31       	cpi	r18, 0x10	; 16
    5b5c:	81 f1       	breq	.+96     	; 0x5bbe <__ultoa_invert+0x6c>
    5b5e:	e8 94       	clt
    5b60:	6f 93       	push	r22
    5b62:	6e 7f       	andi	r22, 0xFE	; 254
    5b64:	6e 5f       	subi	r22, 0xFE	; 254
    5b66:	7f 4f       	sbci	r23, 0xFF	; 255
    5b68:	8f 4f       	sbci	r24, 0xFF	; 255
    5b6a:	9f 4f       	sbci	r25, 0xFF	; 255
    5b6c:	af 4f       	sbci	r26, 0xFF	; 255
    5b6e:	b1 e0       	ldi	r27, 0x01	; 1
    5b70:	3e d0       	rcall	.+124    	; 0x5bee <__ultoa_invert+0x9c>
    5b72:	b4 e0       	ldi	r27, 0x04	; 4
    5b74:	3c d0       	rcall	.+120    	; 0x5bee <__ultoa_invert+0x9c>
    5b76:	67 0f       	add	r22, r23
    5b78:	78 1f       	adc	r23, r24
    5b7a:	89 1f       	adc	r24, r25
    5b7c:	9a 1f       	adc	r25, r26
    5b7e:	a1 1d       	adc	r26, r1
    5b80:	68 0f       	add	r22, r24
    5b82:	79 1f       	adc	r23, r25
    5b84:	8a 1f       	adc	r24, r26
    5b86:	91 1d       	adc	r25, r1
    5b88:	a1 1d       	adc	r26, r1
    5b8a:	6a 0f       	add	r22, r26
    5b8c:	71 1d       	adc	r23, r1
    5b8e:	81 1d       	adc	r24, r1
    5b90:	91 1d       	adc	r25, r1
    5b92:	a1 1d       	adc	r26, r1
    5b94:	20 d0       	rcall	.+64     	; 0x5bd6 <__ultoa_invert+0x84>
    5b96:	09 f4       	brne	.+2      	; 0x5b9a <__ultoa_invert+0x48>
    5b98:	68 94       	set
    5b9a:	3f 91       	pop	r19
    5b9c:	2a e0       	ldi	r18, 0x0A	; 10
    5b9e:	26 9f       	mul	r18, r22
    5ba0:	11 24       	eor	r1, r1
    5ba2:	30 19       	sub	r19, r0
    5ba4:	30 5d       	subi	r19, 0xD0	; 208
    5ba6:	31 93       	st	Z+, r19
    5ba8:	de f6       	brtc	.-74     	; 0x5b60 <__ultoa_invert+0xe>
    5baa:	cf 01       	movw	r24, r30
    5bac:	08 95       	ret
    5bae:	46 2f       	mov	r20, r22
    5bb0:	47 70       	andi	r20, 0x07	; 7
    5bb2:	40 5d       	subi	r20, 0xD0	; 208
    5bb4:	41 93       	st	Z+, r20
    5bb6:	b3 e0       	ldi	r27, 0x03	; 3
    5bb8:	0f d0       	rcall	.+30     	; 0x5bd8 <__ultoa_invert+0x86>
    5bba:	c9 f7       	brne	.-14     	; 0x5bae <__ultoa_invert+0x5c>
    5bbc:	f6 cf       	rjmp	.-20     	; 0x5baa <__ultoa_invert+0x58>
    5bbe:	46 2f       	mov	r20, r22
    5bc0:	4f 70       	andi	r20, 0x0F	; 15
    5bc2:	40 5d       	subi	r20, 0xD0	; 208
    5bc4:	4a 33       	cpi	r20, 0x3A	; 58
    5bc6:	18 f0       	brcs	.+6      	; 0x5bce <__ultoa_invert+0x7c>
    5bc8:	49 5d       	subi	r20, 0xD9	; 217
    5bca:	31 fd       	sbrc	r19, 1
    5bcc:	40 52       	subi	r20, 0x20	; 32
    5bce:	41 93       	st	Z+, r20
    5bd0:	02 d0       	rcall	.+4      	; 0x5bd6 <__ultoa_invert+0x84>
    5bd2:	a9 f7       	brne	.-22     	; 0x5bbe <__ultoa_invert+0x6c>
    5bd4:	ea cf       	rjmp	.-44     	; 0x5baa <__ultoa_invert+0x58>
    5bd6:	b4 e0       	ldi	r27, 0x04	; 4
    5bd8:	a6 95       	lsr	r26
    5bda:	97 95       	ror	r25
    5bdc:	87 95       	ror	r24
    5bde:	77 95       	ror	r23
    5be0:	67 95       	ror	r22
    5be2:	ba 95       	dec	r27
    5be4:	c9 f7       	brne	.-14     	; 0x5bd8 <__ultoa_invert+0x86>
    5be6:	00 97       	sbiw	r24, 0x00	; 0
    5be8:	61 05       	cpc	r22, r1
    5bea:	71 05       	cpc	r23, r1
    5bec:	08 95       	ret
    5bee:	9b 01       	movw	r18, r22
    5bf0:	ac 01       	movw	r20, r24
    5bf2:	0a 2e       	mov	r0, r26
    5bf4:	06 94       	lsr	r0
    5bf6:	57 95       	ror	r21
    5bf8:	47 95       	ror	r20
    5bfa:	37 95       	ror	r19
    5bfc:	27 95       	ror	r18
    5bfe:	ba 95       	dec	r27
    5c00:	c9 f7       	brne	.-14     	; 0x5bf4 <__ultoa_invert+0xa2>
    5c02:	62 0f       	add	r22, r18
    5c04:	73 1f       	adc	r23, r19
    5c06:	84 1f       	adc	r24, r20
    5c08:	95 1f       	adc	r25, r21
    5c0a:	a0 1d       	adc	r26, r0
    5c0c:	08 95       	ret

00005c0e <__prologue_saves__>:
    5c0e:	2f 92       	push	r2
    5c10:	3f 92       	push	r3
    5c12:	4f 92       	push	r4
    5c14:	5f 92       	push	r5
    5c16:	6f 92       	push	r6
    5c18:	7f 92       	push	r7
    5c1a:	8f 92       	push	r8
    5c1c:	9f 92       	push	r9
    5c1e:	af 92       	push	r10
    5c20:	bf 92       	push	r11
    5c22:	cf 92       	push	r12
    5c24:	df 92       	push	r13
    5c26:	ef 92       	push	r14
    5c28:	ff 92       	push	r15
    5c2a:	0f 93       	push	r16
    5c2c:	1f 93       	push	r17
    5c2e:	cf 93       	push	r28
    5c30:	df 93       	push	r29
    5c32:	cd b7       	in	r28, 0x3d	; 61
    5c34:	de b7       	in	r29, 0x3e	; 62
    5c36:	ca 1b       	sub	r28, r26
    5c38:	db 0b       	sbc	r29, r27
    5c3a:	0f b6       	in	r0, 0x3f	; 63
    5c3c:	f8 94       	cli
    5c3e:	de bf       	out	0x3e, r29	; 62
    5c40:	0f be       	out	0x3f, r0	; 63
    5c42:	cd bf       	out	0x3d, r28	; 61
    5c44:	09 94       	ijmp

00005c46 <__epilogue_restores__>:
    5c46:	2a 88       	ldd	r2, Y+18	; 0x12
    5c48:	39 88       	ldd	r3, Y+17	; 0x11
    5c4a:	48 88       	ldd	r4, Y+16	; 0x10
    5c4c:	5f 84       	ldd	r5, Y+15	; 0x0f
    5c4e:	6e 84       	ldd	r6, Y+14	; 0x0e
    5c50:	7d 84       	ldd	r7, Y+13	; 0x0d
    5c52:	8c 84       	ldd	r8, Y+12	; 0x0c
    5c54:	9b 84       	ldd	r9, Y+11	; 0x0b
    5c56:	aa 84       	ldd	r10, Y+10	; 0x0a
    5c58:	b9 84       	ldd	r11, Y+9	; 0x09
    5c5a:	c8 84       	ldd	r12, Y+8	; 0x08
    5c5c:	df 80       	ldd	r13, Y+7	; 0x07
    5c5e:	ee 80       	ldd	r14, Y+6	; 0x06
    5c60:	fd 80       	ldd	r15, Y+5	; 0x05
    5c62:	0c 81       	ldd	r16, Y+4	; 0x04
    5c64:	1b 81       	ldd	r17, Y+3	; 0x03
    5c66:	aa 81       	ldd	r26, Y+2	; 0x02
    5c68:	b9 81       	ldd	r27, Y+1	; 0x01
    5c6a:	ce 0f       	add	r28, r30
    5c6c:	d1 1d       	adc	r29, r1
    5c6e:	0f b6       	in	r0, 0x3f	; 63
    5c70:	f8 94       	cli
    5c72:	de bf       	out	0x3e, r29	; 62
    5c74:	0f be       	out	0x3f, r0	; 63
    5c76:	cd bf       	out	0x3d, r28	; 61
    5c78:	ed 01       	movw	r28, r26
    5c7a:	08 95       	ret

00005c7c <_exit>:
    5c7c:	f8 94       	cli

00005c7e <__stop_program>:
    5c7e:	ff cf       	rjmp	.-2      	; 0x5c7e <__stop_program>
