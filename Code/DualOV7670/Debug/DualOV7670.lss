
DualOV7670.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000320  00800100  00005e94  00005f28  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005e94  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000a9a  00800420  00800420  00006248  2**0
                  ALLOC
  3 .stab         00000c84  00000000  00000000  00006248  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001b6  00000000  00000000  00006ecc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000260  00000000  00000000  00007088  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000058d2  00000000  00000000  000072e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000143f  00000000  00000000  0000cbba  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002283  00000000  00000000  0000dff9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001148  00000000  00000000  0001027c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000bae  00000000  00000000  000113c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006d96  00000000  00000000  00011f72  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000138  00000000  00000000  00018d08  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 82 05 	jmp	0xb04	; 0xb04 <__vector_1>
       8:	0c 94 ad 05 	jmp	0xb5a	; 0xb5a <__vector_2>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 68 08 	jmp	0x10d0	; 0x10d0 <__vector_16>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 3d 2b 	jmp	0x567a	; 0x567a <__vector_26>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d0 e1       	ldi	r29, 0x10	; 16
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	14 e0       	ldi	r17, 0x04	; 4
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	e4 e9       	ldi	r30, 0x94	; 148
      90:	fe e5       	ldi	r31, 0x5E	; 94
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	a0 32       	cpi	r26, 0x20	; 32
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	1e e0       	ldi	r17, 0x0E	; 14
      a0:	a0 e2       	ldi	r26, 0x20	; 32
      a2:	b4 e0       	ldi	r27, 0x04	; 4
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	aa 3b       	cpi	r26, 0xBA	; 186
      aa:	b1 07       	cpc	r27, r17
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 8c 08 	call	0x1118	; 0x1118 <main>
      b2:	0c 94 48 2f 	jmp	0x5e90	; 0x5e90 <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <WriteBMPHeader>:
										};



FRESULT WriteBMPHeader(FIL *File)
{
      ba:	0f 93       	push	r16
      bc:	1f 93       	push	r17
      be:	cf 93       	push	r28
      c0:	df 93       	push	r29
      c2:	00 d0       	rcall	.+0      	; 0xc4 <WriteBMPHeader+0xa>
      c4:	00 d0       	rcall	.+0      	; 0xc6 <WriteBMPHeader+0xc>
      c6:	cd b7       	in	r28, 0x3d	; 61
      c8:	de b7       	in	r29, 0x3e	; 62
      ca:	8c 01       	movw	r16, r24
	uint32_t p;
	FRESULT f; 
	
	f_lseek(File, 0);
      cc:	40 e0       	ldi	r20, 0x00	; 0
      ce:	50 e0       	ldi	r21, 0x00	; 0
      d0:	ba 01       	movw	r22, r20
      d2:	0e 94 7e 21 	call	0x42fc	; 0x42fc <f_lseek>
	f = f_write(File, BMPHeader, BMPHEADERSIZE, &p);
      d6:	c8 01       	movw	r24, r16
      d8:	60 e0       	ldi	r22, 0x00	; 0
      da:	71 e0       	ldi	r23, 0x01	; 1
      dc:	2e e0       	ldi	r18, 0x0E	; 14
      de:	30 e0       	ldi	r19, 0x00	; 0
      e0:	40 e0       	ldi	r20, 0x00	; 0
      e2:	50 e0       	ldi	r21, 0x00	; 0
      e4:	8e 01       	movw	r16, r28
      e6:	0f 5f       	subi	r16, 0xFF	; 255
      e8:	1f 4f       	sbci	r17, 0xFF	; 255
      ea:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <f_write>
	
	return f;
}
      ee:	0f 90       	pop	r0
      f0:	0f 90       	pop	r0
      f2:	0f 90       	pop	r0
      f4:	0f 90       	pop	r0
      f6:	df 91       	pop	r29
      f8:	cf 91       	pop	r28
      fa:	1f 91       	pop	r17
      fc:	0f 91       	pop	r16
      fe:	08 95       	ret

00000100 <WriteDIBHeader>:

FRESULT WriteDIBHeader(FIL *File)
{
     100:	0f 93       	push	r16
     102:	1f 93       	push	r17
     104:	cf 93       	push	r28
     106:	df 93       	push	r29
     108:	00 d0       	rcall	.+0      	; 0x10a <WriteDIBHeader+0xa>
     10a:	00 d0       	rcall	.+0      	; 0x10c <WriteDIBHeader+0xc>
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
     110:	8c 01       	movw	r16, r24
	uint32_t p;
	FRESULT f;
	
	f_lseek(File, BMPHEADERSIZE);//place just after the bitmap header
     112:	4e e0       	ldi	r20, 0x0E	; 14
     114:	50 e0       	ldi	r21, 0x00	; 0
     116:	60 e0       	ldi	r22, 0x00	; 0
     118:	70 e0       	ldi	r23, 0x00	; 0
     11a:	0e 94 7e 21 	call	0x42fc	; 0x42fc <f_lseek>
	f = f_write(File, DIBHead, DIBHEADERSIZE, &p);
     11e:	c8 01       	movw	r24, r16
     120:	6e e0       	ldi	r22, 0x0E	; 14
     122:	71 e0       	ldi	r23, 0x01	; 1
     124:	2c e7       	ldi	r18, 0x7C	; 124
     126:	30 e0       	ldi	r19, 0x00	; 0
     128:	40 e0       	ldi	r20, 0x00	; 0
     12a:	50 e0       	ldi	r21, 0x00	; 0
     12c:	8e 01       	movw	r16, r28
     12e:	0f 5f       	subi	r16, 0xFF	; 255
     130:	1f 4f       	sbci	r17, 0xFF	; 255
     132:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <f_write>
	return f;
}
     136:	0f 90       	pop	r0
     138:	0f 90       	pop	r0
     13a:	0f 90       	pop	r0
     13c:	0f 90       	pop	r0
     13e:	df 91       	pop	r29
     140:	cf 91       	pop	r28
     142:	1f 91       	pop	r17
     144:	0f 91       	pop	r16
     146:	08 95       	ret

00000148 <IO_Init>:
#include "Config.h"
#include <avr/io.h>
void IO_Init(void)
{
	//initialise timer 0 to interrupt every 10 ms
	TIMSK0 |= (1 << OCIE0A);
     148:	ee e6       	ldi	r30, 0x6E	; 110
     14a:	f0 e0       	ldi	r31, 0x00	; 0
     14c:	80 81       	ld	r24, Z
     14e:	82 60       	ori	r24, 0x02	; 2
     150:	80 83       	st	Z, r24
	TCCR0A |= (1 << WGM01);
     152:	84 b5       	in	r24, 0x24	; 36
     154:	82 60       	ori	r24, 0x02	; 2
     156:	84 bd       	out	0x24, r24	; 36
	OCR0A = 117; //10ms interrupt at 12MHz
     158:	85 e7       	ldi	r24, 0x75	; 117
     15a:	87 bd       	out	0x27, r24	; 39
	TCCR0B |= (1 << CS02) | (1 << CS00);
     15c:	85 b5       	in	r24, 0x25	; 37
     15e:	85 60       	ori	r24, 0x05	; 5
     160:	85 bd       	out	0x25, r24	; 37
	
	
	DDRA = 0x00;
     162:	11 b8       	out	0x01, r1	; 1
	//PORTB = 0xBF;
	DDRC = 0xFC;
     164:	8c ef       	ldi	r24, 0xFC	; 252
     166:	87 b9       	out	0x07, r24	; 7
	DDRD = 0xF2;
     168:	82 ef       	ldi	r24, 0xF2	; 242
     16a:	8a b9       	out	0x0a, r24	; 10
	
	
	
	//set int0 and int1 to trigger on falling edge
	EIMSK = (1 << INT0) | (1 << INT1);				//Enable INT0 and INT1
     16c:	83 e0       	ldi	r24, 0x03	; 3
     16e:	8d bb       	out	0x1d, r24	; 29
	EICRA = (1 << ISC01) | (1 << ISC11);			//Trigger INT0 and INT1 on the falling edge
     170:	8a e0       	ldi	r24, 0x0A	; 10
     172:	80 93 69 00 	sts	0x0069, r24
     176:	08 95       	ret

00000178 <power_off>:
}

static
void power_off (void)
{
	SPCR = 0;				/* Disable SPI function */
     178:	1c bc       	out	0x2c, r1	; 44
// 	DDRB  &= ~0b00110111;	/* Set SCK/MOSI/CS as hi-z, INS#/WP as pull-up */
// 	PORTB &= ~0b00000111;
// 	PORTB |=  0b00110000;


	PORTB = ~0b00010000;      // SS high
     17a:	8f ee       	ldi	r24, 0xEF	; 239
     17c:	85 b9       	out	0x05, r24	; 5
	DDRB =  ~(uint8_t)0b10110000;      // !SS,SCK and MOSI outputs
     17e:	8f e4       	ldi	r24, 0x4F	; 79
     180:	84 b9       	out	0x04, r24	; 4
// 	{	/* Remove this block if no socket power control */
// 		PORTE |= _BV(7);		/* Socket power off (PE7=high) */
// 		for (Timer1 = 20; Timer1; );	/* Wait for 20ms */
// 	}
}
     182:	08 95       	ret

00000184 <xchg_spi>:
static
BYTE xchg_spi (		/* Returns received data */
	BYTE dat		/* Data to be sent */
)
{
	SPDR = dat;
     184:	8e bd       	out	0x2e, r24	; 46
	loop_until_bit_is_set(SPSR, SPIF);
     186:	0d b4       	in	r0, 0x2d	; 45
     188:	07 fe       	sbrs	r0, 7
     18a:	fd cf       	rjmp	.-6      	; 0x186 <xchg_spi+0x2>
	return SPDR;
     18c:	8e b5       	in	r24, 0x2e	; 46
}
     18e:	08 95       	ret

00000190 <wait_ready>:
int wait_ready (void)	/* 1:OK, 0:Timeout */
{
	BYTE d;


	Timer2 = 50;	/* Wait for ready in timeout of 500ms */
     190:	82 e3       	ldi	r24, 0x32	; 50
     192:	80 93 20 04 	sts	0x0420, r24
	do
		d = xchg_spi(0xFF);
     196:	8f ef       	ldi	r24, 0xFF	; 255
     198:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	while (d != 0xFF && Timer2);
     19c:	8f 3f       	cpi	r24, 0xFF	; 255
     19e:	21 f0       	breq	.+8      	; 0x1a8 <wait_ready+0x18>
     1a0:	90 91 20 04 	lds	r25, 0x0420
     1a4:	99 23       	and	r25, r25
     1a6:	b9 f7       	brne	.-18     	; 0x196 <wait_ready+0x6>

	return (d == 0xFF) ? 1 : 0;
     1a8:	21 e0       	ldi	r18, 0x01	; 1
     1aa:	30 e0       	ldi	r19, 0x00	; 0
     1ac:	8f 3f       	cpi	r24, 0xFF	; 255
     1ae:	11 f0       	breq	.+4      	; 0x1b4 <wait_ready+0x24>
     1b0:	20 e0       	ldi	r18, 0x00	; 0
     1b2:	30 e0       	ldi	r19, 0x00	; 0
}
     1b4:	82 2f       	mov	r24, r18
     1b6:	93 2f       	mov	r25, r19
     1b8:	08 95       	ret

000001ba <deselect>:
/*-----------------------------------------------------------------------*/

static
void deselect (void)
{
	CS_HIGH();
     1ba:	2c 9a       	sbi	0x05, 4	; 5
	xchg_spi(0xFF);	/* Dummy clock (force DO hi-z for multiple slave SPI) */
     1bc:	8f ef       	ldi	r24, 0xFF	; 255
     1be:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
}
     1c2:	08 95       	ret

000001c4 <select>:
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:Successful, 0:Timeout */
{
	CS_LOW();
     1c4:	2c 98       	cbi	0x05, 4	; 5
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */
     1c6:	8f ef       	ldi	r24, 0xFF	; 255
     1c8:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>

	if (wait_ready()) return 1;	/* OK */
     1cc:	0e 94 c8 00 	call	0x190	; 0x190 <wait_ready>
     1d0:	00 97       	sbiw	r24, 0x00	; 0
     1d2:	29 f4       	brne	.+10     	; 0x1de <select+0x1a>
	deselect();
     1d4:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
	return 0;	/* Timeout */
     1d8:	80 e0       	ldi	r24, 0x00	; 0
     1da:	90 e0       	ldi	r25, 0x00	; 0
     1dc:	08 95       	ret
int select (void)	/* 1:Successful, 0:Timeout */
{
	CS_LOW();
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */

	if (wait_ready()) return 1;	/* OK */
     1de:	81 e0       	ldi	r24, 0x01	; 1
     1e0:	90 e0       	ldi	r25, 0x00	; 0
	deselect();
	return 0;	/* Timeout */
}
     1e2:	08 95       	ret

000001e4 <rcvr_datablock>:
static
int rcvr_datablock (
	BYTE *buff,			/* Data buffer to store received data */
	UINT btr			/* Byte count (must be multiple of 4) */
)
{
     1e4:	cf 92       	push	r12
     1e6:	df 92       	push	r13
     1e8:	ef 92       	push	r14
     1ea:	ff 92       	push	r15
     1ec:	cf 93       	push	r28
     1ee:	df 93       	push	r29
     1f0:	ec 01       	movw	r28, r24
     1f2:	6a 01       	movw	r12, r20
     1f4:	7b 01       	movw	r14, r22
	BYTE token;


	Timer1 = 20;
     1f6:	84 e1       	ldi	r24, 0x14	; 20
     1f8:	80 93 21 04 	sts	0x0421, r24
	do {							/* Wait for data packet in timeout of 200ms */
		token = xchg_spi(0xFF);
     1fc:	8f ef       	ldi	r24, 0xFF	; 255
     1fe:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	} while ((token == 0xFF) && Timer1);
     202:	8f 3f       	cpi	r24, 0xFF	; 255
     204:	39 f4       	brne	.+14     	; 0x214 <rcvr_datablock+0x30>
     206:	80 91 21 04 	lds	r24, 0x0421
     20a:	88 23       	and	r24, r24
     20c:	b9 f7       	brne	.-18     	; 0x1fc <rcvr_datablock+0x18>
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */
     20e:	80 e0       	ldi	r24, 0x00	; 0
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	28 c0       	rjmp	.+80     	; 0x264 <rcvr_datablock+0x80>
     214:	8e 3f       	cpi	r24, 0xFE	; 254
     216:	21 f5       	brne	.+72     	; 0x260 <rcvr_datablock+0x7c>
	BYTE *p,	/* Data buffer */
	UINT cnt	/* Size of data block */
)
{
	do {
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
     218:	8f ef       	ldi	r24, 0xFF	; 255
     21a:	8e bd       	out	0x2e, r24	; 46
     21c:	0d b4       	in	r0, 0x2d	; 45
     21e:	07 fe       	sbrs	r0, 7
     220:	fd cf       	rjmp	.-6      	; 0x21c <rcvr_datablock+0x38>
     222:	9e b5       	in	r25, 0x2e	; 46
     224:	98 83       	st	Y, r25
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
     226:	8e bd       	out	0x2e, r24	; 46
     228:	0d b4       	in	r0, 0x2d	; 45
     22a:	07 fe       	sbrs	r0, 7
     22c:	fd cf       	rjmp	.-6      	; 0x228 <rcvr_datablock+0x44>
     22e:	9e b5       	in	r25, 0x2e	; 46
     230:	99 83       	std	Y+1, r25	; 0x01
/*-----------------------------------------------------------------------*/
/* Receive a data packet from MMC                                        */
/*-----------------------------------------------------------------------*/

static
int rcvr_datablock (
     232:	22 96       	adiw	r28, 0x02	; 2
)
{
	do {
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
	} while (cnt -= 2);
     234:	2e ef       	ldi	r18, 0xFE	; 254
     236:	3f ef       	ldi	r19, 0xFF	; 255
     238:	4f ef       	ldi	r20, 0xFF	; 255
     23a:	5f ef       	ldi	r21, 0xFF	; 255
     23c:	c2 0e       	add	r12, r18
     23e:	d3 1e       	adc	r13, r19
     240:	e4 1e       	adc	r14, r20
     242:	f5 1e       	adc	r15, r21
     244:	c1 14       	cp	r12, r1
     246:	d1 04       	cpc	r13, r1
     248:	e1 04       	cpc	r14, r1
     24a:	f1 04       	cpc	r15, r1
     24c:	31 f7       	brne	.-52     	; 0x21a <rcvr_datablock+0x36>
		token = xchg_spi(0xFF);
	} while ((token == 0xFF) && Timer1);
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */

	rcvr_spi_multi(buff, btr);		/* Receive the data block into buffer */
	xchg_spi(0xFF);					/* Discard CRC */
     24e:	8f ef       	ldi	r24, 0xFF	; 255
     250:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi(0xFF);
     254:	8f ef       	ldi	r24, 0xFF	; 255
     256:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>

	return 1;						/* Return with success */
     25a:	81 e0       	ldi	r24, 0x01	; 1
     25c:	90 e0       	ldi	r25, 0x00	; 0
     25e:	02 c0       	rjmp	.+4      	; 0x264 <rcvr_datablock+0x80>

	Timer1 = 20;
	do {							/* Wait for data packet in timeout of 200ms */
		token = xchg_spi(0xFF);
	} while ((token == 0xFF) && Timer1);
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */
     260:	80 e0       	ldi	r24, 0x00	; 0
     262:	90 e0       	ldi	r25, 0x00	; 0
	rcvr_spi_multi(buff, btr);		/* Receive the data block into buffer */
	xchg_spi(0xFF);					/* Discard CRC */
	xchg_spi(0xFF);

	return 1;						/* Return with success */
}
     264:	df 91       	pop	r29
     266:	cf 91       	pop	r28
     268:	ff 90       	pop	r15
     26a:	ef 90       	pop	r14
     26c:	df 90       	pop	r13
     26e:	cf 90       	pop	r12
     270:	08 95       	ret

00000272 <xmit_datablock>:
static
int xmit_datablock (
	const BYTE *buff,	/* 512 byte data block to be transmitted */
	BYTE token			/* Data/Stop token */
)
{
     272:	1f 93       	push	r17
     274:	cf 93       	push	r28
     276:	df 93       	push	r29
     278:	ec 01       	movw	r28, r24
     27a:	16 2f       	mov	r17, r22
	BYTE resp;


	if (!wait_ready()) return 0;
     27c:	0e 94 c8 00 	call	0x190	; 0x190 <wait_ready>
     280:	00 97       	sbiw	r24, 0x00	; 0
     282:	41 f1       	breq	.+80     	; 0x2d4 <xmit_datablock+0x62>

	xchg_spi(token);					/* Xmit data token */
     284:	81 2f       	mov	r24, r17
     286:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	if (token != 0xFD) {	/* Is data token */
     28a:	1d 3f       	cpi	r17, 0xFD	; 253
     28c:	31 f1       	breq	.+76     	; 0x2da <xmit_datablock+0x68>
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     28e:	ce 01       	movw	r24, r28
     290:	80 50       	subi	r24, 0x00	; 0
     292:	9e 4f       	sbci	r25, 0xFE	; 254
	const BYTE *p,	/* Data block to be sent */
	UINT cnt		/* Size of data block */
)
{
	do {
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     294:	28 81       	ld	r18, Y
     296:	2e bd       	out	0x2e, r18	; 46
     298:	0d b4       	in	r0, 0x2d	; 45
     29a:	07 fe       	sbrs	r0, 7
     29c:	fd cf       	rjmp	.-6      	; 0x298 <xmit_datablock+0x26>
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     29e:	29 81       	ldd	r18, Y+1	; 0x01
     2a0:	2e bd       	out	0x2e, r18	; 46
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     2a2:	22 96       	adiw	r28, 0x02	; 2
	UINT cnt		/* Size of data block */
)
{
	do {
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     2a4:	0d b4       	in	r0, 0x2d	; 45
     2a6:	07 fe       	sbrs	r0, 7
     2a8:	fd cf       	rjmp	.-6      	; 0x2a4 <xmit_datablock+0x32>
	} while (cnt -= 2);
     2aa:	8c 17       	cp	r24, r28
     2ac:	9d 07       	cpc	r25, r29
     2ae:	91 f7       	brne	.-28     	; 0x294 <xmit_datablock+0x22>
	if (!wait_ready()) return 0;

	xchg_spi(token);					/* Xmit data token */
	if (token != 0xFD) {	/* Is data token */
		xmit_spi_multi(buff, 512);		/* Xmit the data block to the MMC */
		xchg_spi(0xFF);					/* CRC (Dummy) */
     2b0:	8f ef       	ldi	r24, 0xFF	; 255
     2b2:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
		xchg_spi(0xFF);
     2b6:	8f ef       	ldi	r24, 0xFF	; 255
     2b8:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
		resp = xchg_spi(0xFF);			/* Reveive data response */
     2bc:	8f ef       	ldi	r24, 0xFF	; 255
     2be:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
     2c2:	8f 71       	andi	r24, 0x1F	; 31
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     2c4:	21 e0       	ldi	r18, 0x01	; 1
     2c6:	30 e0       	ldi	r19, 0x00	; 0
     2c8:	85 30       	cpi	r24, 0x05	; 5
     2ca:	11 f0       	breq	.+4      	; 0x2d0 <xmit_datablock+0x5e>
     2cc:	20 e0       	ldi	r18, 0x00	; 0
     2ce:	30 e0       	ldi	r19, 0x00	; 0
)
{
	BYTE resp;


	if (!wait_ready()) return 0;
     2d0:	c9 01       	movw	r24, r18
     2d2:	05 c0       	rjmp	.+10     	; 0x2de <xmit_datablock+0x6c>
     2d4:	80 e0       	ldi	r24, 0x00	; 0
     2d6:	90 e0       	ldi	r25, 0x00	; 0
     2d8:	02 c0       	rjmp	.+4      	; 0x2de <xmit_datablock+0x6c>
		resp = xchg_spi(0xFF);			/* Reveive data response */
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
			return 0;
	}

	return 1;
     2da:	81 e0       	ldi	r24, 0x01	; 1
     2dc:	90 e0       	ldi	r25, 0x00	; 0
}
     2de:	df 91       	pop	r29
     2e0:	cf 91       	pop	r28
     2e2:	1f 91       	pop	r17
     2e4:	08 95       	ret

000002e6 <send_cmd>:
static
BYTE send_cmd (		/* Returns R1 resp (bit7==1:Send failed) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
     2e6:	ff 92       	push	r15
     2e8:	0f 93       	push	r16
     2ea:	1f 93       	push	r17
     2ec:	cf 93       	push	r28
     2ee:	df 93       	push	r29
     2f0:	c8 2f       	mov	r28, r24
     2f2:	d4 2f       	mov	r29, r20
     2f4:	15 2f       	mov	r17, r21
     2f6:	06 2f       	mov	r16, r22
     2f8:	f7 2e       	mov	r15, r23
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
     2fa:	88 23       	and	r24, r24
     2fc:	4c f4       	brge	.+18     	; 0x310 <send_cmd+0x2a>
		cmd &= 0x7F;
		res = send_cmd(CMD55, 0);
     2fe:	87 e3       	ldi	r24, 0x37	; 55
     300:	40 e0       	ldi	r20, 0x00	; 0
     302:	50 e0       	ldi	r21, 0x00	; 0
     304:	ba 01       	movw	r22, r20
     306:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
		if (res > 1) return res;
     30a:	82 30       	cpi	r24, 0x02	; 2
     30c:	68 f5       	brcc	.+90     	; 0x368 <send_cmd+0x82>
{
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
     30e:	cf 77       	andi	r28, 0x7F	; 127
		res = send_cmd(CMD55, 0);
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	deselect();
     310:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
	if (!select()) return 0xFF;
     314:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <select>
     318:	00 97       	sbiw	r24, 0x00	; 0
     31a:	29 f1       	breq	.+74     	; 0x366 <send_cmd+0x80>

	/* Send command packet */
	xchg_spi(0x40 | cmd);				/* Start + Command index */
     31c:	8c 2f       	mov	r24, r28
     31e:	80 64       	ori	r24, 0x40	; 64
     320:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
     324:	8f 2d       	mov	r24, r15
     326:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
     32a:	80 2f       	mov	r24, r16
     32c:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
     330:	81 2f       	mov	r24, r17
     332:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
     336:	8d 2f       	mov	r24, r29
     338:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) + Stop */
     33c:	cc 23       	and	r28, r28
     33e:	f1 f0       	breq	.+60     	; 0x37c <send_cmd+0x96>
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) Stop */
     340:	c8 30       	cpi	r28, 0x08	; 8
     342:	c1 f0       	breq	.+48     	; 0x374 <send_cmd+0x8e>
	xchg_spi(n);
     344:	81 e0       	ldi	r24, 0x01	; 1
     346:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>

	/* Receive command response */
	if (cmd == CMD12) xchg_spi(0xFF);		/* Skip a stuff byte when stop reading */
     34a:	cc 30       	cpi	r28, 0x0C	; 12
     34c:	19 f4       	brne	.+6      	; 0x354 <send_cmd+0x6e>
     34e:	8f ef       	ldi	r24, 0xFF	; 255
     350:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
static
BYTE send_cmd (		/* Returns R1 resp (bit7==1:Send failed) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
     354:	ca e0       	ldi	r28, 0x0A	; 10

	/* Receive command response */
	if (cmd == CMD12) xchg_spi(0xFF);		/* Skip a stuff byte when stop reading */
	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do
		res = xchg_spi(0xFF);
     356:	8f ef       	ldi	r24, 0xFF	; 255
     358:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	while ((res & 0x80) && --n);
     35c:	88 23       	and	r24, r24
     35e:	24 f4       	brge	.+8      	; 0x368 <send_cmd+0x82>
     360:	c1 50       	subi	r28, 0x01	; 1
     362:	c9 f7       	brne	.-14     	; 0x356 <send_cmd+0x70>
     364:	01 c0       	rjmp	.+2      	; 0x368 <send_cmd+0x82>
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	deselect();
	if (!select()) return 0xFF;
     366:	8f ef       	ldi	r24, 0xFF	; 255
	do
		res = xchg_spi(0xFF);
	while ((res & 0x80) && --n);

	return res;			/* Return with the response value */
}
     368:	df 91       	pop	r29
     36a:	cf 91       	pop	r28
     36c:	1f 91       	pop	r17
     36e:	0f 91       	pop	r16
     370:	ff 90       	pop	r15
     372:	08 95       	ret
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) + Stop */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) Stop */
	xchg_spi(n);
     374:	87 e8       	ldi	r24, 0x87	; 135
     376:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     37a:	ec cf       	rjmp	.-40     	; 0x354 <send_cmd+0x6e>
     37c:	85 e9       	ldi	r24, 0x95	; 149
     37e:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     382:	e8 cf       	rjmp	.-48     	; 0x354 <send_cmd+0x6e>

00000384 <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
     384:	cf 92       	push	r12
     386:	df 92       	push	r13
     388:	ef 92       	push	r14
     38a:	ff 92       	push	r15
     38c:	0f 93       	push	r16
     38e:	1f 93       	push	r17
     390:	cf 93       	push	r28
     392:	df 93       	push	r29
     394:	00 d0       	rcall	.+0      	; 0x396 <disk_initialize+0x12>
     396:	00 d0       	rcall	.+0      	; 0x398 <disk_initialize+0x14>
     398:	cd b7       	in	r28, 0x3d	; 61
     39a:	de b7       	in	r29, 0x3e	; 62
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only single drive */
     39c:	88 23       	and	r24, r24
     39e:	09 f0       	breq	.+2      	; 0x3a2 <disk_initialize+0x1e>
     3a0:	a8 c0       	rjmp	.+336    	; 0x4f2 <disk_initialize+0x16e>
	power_off();						/* Turn off the socket power to reset the card */
     3a2:	0e 94 bc 00 	call	0x178	; 0x178 <power_off>
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
     3a6:	80 91 8a 01 	lds	r24, 0x018A
     3aa:	81 ff       	sbrs	r24, 1
     3ac:	03 c0       	rjmp	.+6      	; 0x3b4 <disk_initialize+0x30>
     3ae:	80 91 8a 01 	lds	r24, 0x018A
     3b2:	a0 c0       	rjmp	.+320    	; 0x4f4 <disk_initialize+0x170>
	// Configure for: PB4 - /SS
	//                PB5 - MOSI
	//                PB6 - MISO
	//                PB7 - SCK

	PORTB = 0b00010000;      // SS high
     3b4:	80 e1       	ldi	r24, 0x10	; 16
     3b6:	85 b9       	out	0x05, r24	; 5
	DDRB =  0b10110000;      // !SS,SCK and MOSI outputs
     3b8:	80 eb       	ldi	r24, 0xB0	; 176
     3ba:	84 b9       	out	0x04, r24	; 4

	/* Set MOSI and SCK output, all others input */
	//DDR_SPI = (1<<DD_MOSI)|(1<<DD_SCK);
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
     3bc:	81 e5       	ldi	r24, 0x51	; 81
     3be:	8c bd       	out	0x2c, r24	; 44

	if (drv) return STA_NOINIT;			/* Supports only single drive */
	power_off();						/* Turn off the socket power to reset the card */
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
	power_on();							/* Turn on the socket power */
	FCLK_SLOW();
     3c0:	82 e5       	ldi	r24, 0x52	; 82
     3c2:	8c bd       	out	0x2c, r24	; 44
     3c4:	0a e0       	ldi	r16, 0x0A	; 10
	for (n = 10; n; n--) xchg_spi(0xFF);	/* 80 dummy clocks */
     3c6:	8f ef       	ldi	r24, 0xFF	; 255
     3c8:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     3cc:	01 50       	subi	r16, 0x01	; 1
     3ce:	d9 f7       	brne	.-10     	; 0x3c6 <disk_initialize+0x42>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
     3d0:	80 e0       	ldi	r24, 0x00	; 0
     3d2:	40 e0       	ldi	r20, 0x00	; 0
     3d4:	50 e0       	ldi	r21, 0x00	; 0
     3d6:	ba 01       	movw	r22, r20
     3d8:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     3dc:	81 30       	cpi	r24, 0x01	; 1
     3de:	09 f0       	breq	.+2      	; 0x3e2 <disk_initialize+0x5e>
     3e0:	9c c0       	rjmp	.+312    	; 0x51a <disk_initialize+0x196>
		Timer1 = 100;						/* Initialization timeout of 1000 msec */
     3e2:	84 e6       	ldi	r24, 0x64	; 100
     3e4:	80 93 21 04 	sts	0x0421, r24
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
     3e8:	88 e0       	ldi	r24, 0x08	; 8
     3ea:	4a ea       	ldi	r20, 0xAA	; 170
     3ec:	51 e0       	ldi	r21, 0x01	; 1
     3ee:	60 e0       	ldi	r22, 0x00	; 0
     3f0:	70 e0       	ldi	r23, 0x00	; 0
     3f2:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     3f6:	81 30       	cpi	r24, 0x01	; 1
     3f8:	09 f0       	breq	.+2      	; 0x3fc <disk_initialize+0x78>
     3fa:	42 c0       	rjmp	.+132    	; 0x480 <disk_initialize+0xfc>
     3fc:	6e 01       	movw	r12, r28
     3fe:	08 94       	sec
     400:	c1 1c       	adc	r12, r1
     402:	d1 1c       	adc	r13, r1

/*-----------------------------------------------------------------------*/
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
     404:	8e 01       	movw	r16, r28
     406:	0b 5f       	subi	r16, 0xFB	; 251
     408:	1f 4f       	sbci	r17, 0xFF	; 255
     40a:	76 01       	movw	r14, r12

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		Timer1 = 100;						/* Initialization timeout of 1000 msec */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);		/* Get trailing return value of R7 resp */
     40c:	8f ef       	ldi	r24, 0xFF	; 255
     40e:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     412:	f7 01       	movw	r30, r14
     414:	81 93       	st	Z+, r24
     416:	7f 01       	movw	r14, r30
     418:	e0 17       	cp	r30, r16
     41a:	f1 07       	cpc	r31, r17
     41c:	b9 f7       	brne	.-18     	; 0x40c <disk_initialize+0x88>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	81 30       	cpi	r24, 0x01	; 1
     422:	09 f0       	breq	.+2      	; 0x426 <disk_initialize+0xa2>
     424:	7a c0       	rjmp	.+244    	; 0x51a <disk_initialize+0x196>
     426:	8c 81       	ldd	r24, Y+4	; 0x04
     428:	8a 3a       	cpi	r24, 0xAA	; 170
     42a:	09 f0       	breq	.+2      	; 0x42e <disk_initialize+0xaa>
     42c:	76 c0       	rjmp	.+236    	; 0x51a <disk_initialize+0x196>
				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
     42e:	80 91 21 04 	lds	r24, 0x0421
     432:	88 23       	and	r24, r24
     434:	49 f0       	breq	.+18     	; 0x448 <disk_initialize+0xc4>
     436:	89 ea       	ldi	r24, 0xA9	; 169
     438:	40 e0       	ldi	r20, 0x00	; 0
     43a:	50 e0       	ldi	r21, 0x00	; 0
     43c:	60 e0       	ldi	r22, 0x00	; 0
     43e:	70 e4       	ldi	r23, 0x40	; 64
     440:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     444:	88 23       	and	r24, r24
     446:	99 f7       	brne	.-26     	; 0x42e <disk_initialize+0xaa>
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
     448:	80 91 21 04 	lds	r24, 0x0421
     44c:	88 23       	and	r24, r24
     44e:	09 f4       	brne	.+2      	; 0x452 <disk_initialize+0xce>
     450:	64 c0       	rjmp	.+200    	; 0x51a <disk_initialize+0x196>
     452:	8a e3       	ldi	r24, 0x3A	; 58
     454:	40 e0       	ldi	r20, 0x00	; 0
     456:	50 e0       	ldi	r21, 0x00	; 0
     458:	ba 01       	movw	r22, r20
     45a:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     45e:	88 23       	and	r24, r24
     460:	09 f0       	breq	.+2      	; 0x464 <disk_initialize+0xe0>
     462:	5b c0       	rjmp	.+182    	; 0x51a <disk_initialize+0x196>
     464:	04 e0       	ldi	r16, 0x04	; 4
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
     466:	8f ef       	ldi	r24, 0xFF	; 255
     468:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     46c:	f6 01       	movw	r30, r12
     46e:	81 93       	st	Z+, r24
     470:	6f 01       	movw	r12, r30
     472:	01 50       	subi	r16, 0x01	; 1
     474:	c1 f7       	brne	.-16     	; 0x466 <disk_initialize+0xe2>
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
     476:	89 81       	ldd	r24, Y+1	; 0x01
     478:	86 fd       	sbrc	r24, 6
     47a:	49 c0       	rjmp	.+146    	; 0x50e <disk_initialize+0x18a>
     47c:	84 e0       	ldi	r24, 0x04	; 4
     47e:	48 c0       	rjmp	.+144    	; 0x510 <disk_initialize+0x18c>
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
     480:	89 ea       	ldi	r24, 0xA9	; 169
     482:	40 e0       	ldi	r20, 0x00	; 0
     484:	50 e0       	ldi	r21, 0x00	; 0
     486:	ba 01       	movw	r22, r20
     488:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     48c:	82 30       	cpi	r24, 0x02	; 2
     48e:	18 f4       	brcc	.+6      	; 0x496 <disk_initialize+0x112>
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
     490:	12 e0       	ldi	r17, 0x02	; 2
     492:	09 ea       	ldi	r16, 0xA9	; 169
     494:	02 c0       	rjmp	.+4      	; 0x49a <disk_initialize+0x116>
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
     496:	11 e0       	ldi	r17, 0x01	; 1
     498:	01 e0       	ldi	r16, 0x01	; 1
			}
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
     49a:	80 91 21 04 	lds	r24, 0x0421
     49e:	88 23       	and	r24, r24
     4a0:	41 f0       	breq	.+16     	; 0x4b2 <disk_initialize+0x12e>
     4a2:	80 2f       	mov	r24, r16
     4a4:	40 e0       	ldi	r20, 0x00	; 0
     4a6:	50 e0       	ldi	r21, 0x00	; 0
     4a8:	ba 01       	movw	r22, r20
     4aa:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     4ae:	88 23       	and	r24, r24
     4b0:	a1 f7       	brne	.-24     	; 0x49a <disk_initialize+0x116>
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
     4b2:	80 91 21 04 	lds	r24, 0x0421
     4b6:	88 23       	and	r24, r24
     4b8:	81 f1       	breq	.+96     	; 0x51a <disk_initialize+0x196>
     4ba:	80 e1       	ldi	r24, 0x10	; 16
     4bc:	40 e0       	ldi	r20, 0x00	; 0
     4be:	52 e0       	ldi	r21, 0x02	; 2
     4c0:	60 e0       	ldi	r22, 0x00	; 0
     4c2:	70 e0       	ldi	r23, 0x00	; 0
     4c4:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     4c8:	88 23       	and	r24, r24
     4ca:	39 f5       	brne	.+78     	; 0x51a <disk_initialize+0x196>
				ty = 0;
		}
	}
	CardType = ty;
     4cc:	10 93 22 04 	sts	0x0422, r17
	deselect();
     4d0:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>

	if (ty) {			/* Initialization succeded */
     4d4:	11 23       	and	r17, r17
     4d6:	41 f0       	breq	.+16     	; 0x4e8 <disk_initialize+0x164>
		Stat &= ~STA_NOINIT;		/* Clear STA_NOINIT */
     4d8:	80 91 8a 01 	lds	r24, 0x018A
     4dc:	8e 7f       	andi	r24, 0xFE	; 254
     4de:	80 93 8a 01 	sts	0x018A, r24
		FCLK_FAST();
     4e2:	80 e5       	ldi	r24, 0x50	; 80
     4e4:	8c bd       	out	0x2c, r24	; 44
     4e6:	02 c0       	rjmp	.+4      	; 0x4ec <disk_initialize+0x168>
	} else {			/* Initialization failed */
		power_off();
     4e8:	0e 94 bc 00 	call	0x178	; 0x178 <power_off>
	}

	return Stat;
     4ec:	80 91 8a 01 	lds	r24, 0x018A
     4f0:	01 c0       	rjmp	.+2      	; 0x4f4 <disk_initialize+0x170>
)
{
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only single drive */
     4f2:	81 e0       	ldi	r24, 0x01	; 1
	} else {			/* Initialization failed */
		power_off();
	}

	return Stat;
}
     4f4:	0f 90       	pop	r0
     4f6:	0f 90       	pop	r0
     4f8:	0f 90       	pop	r0
     4fa:	0f 90       	pop	r0
     4fc:	df 91       	pop	r29
     4fe:	cf 91       	pop	r28
     500:	1f 91       	pop	r17
     502:	0f 91       	pop	r16
     504:	ff 90       	pop	r15
     506:	ef 90       	pop	r14
     508:	df 90       	pop	r13
     50a:	cf 90       	pop	r12
     50c:	08 95       	ret
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);		/* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
     50e:	8c e0       	ldi	r24, 0x0C	; 12
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
     510:	80 93 22 04 	sts	0x0422, r24
	deselect();
     514:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
     518:	df cf       	rjmp	.-66     	; 0x4d8 <disk_initialize+0x154>
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
     51a:	10 92 22 04 	sts	0x0422, r1
	deselect();
     51e:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
     522:	e2 cf       	rjmp	.-60     	; 0x4e8 <disk_initialize+0x164>

00000524 <disk_status>:

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
     524:	88 23       	and	r24, r24
     526:	19 f4       	brne	.+6      	; 0x52e <disk_status+0xa>
	return Stat;
     528:	80 91 8a 01 	lds	r24, 0x018A
     52c:	08 95       	ret

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
     52e:	81 e0       	ldi	r24, 0x01	; 1
	return Stat;
}
     530:	08 95       	ret

00000532 <disk_read>:
	BYTE drv,			/* Physical drive nmuber (0) */
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
     532:	0f 93       	push	r16
     534:	cf 93       	push	r28
     536:	df 93       	push	r29
     538:	eb 01       	movw	r28, r22
	if (drv || !count) return RES_PARERR;
     53a:	88 23       	and	r24, r24
     53c:	09 f0       	breq	.+2      	; 0x540 <disk_read+0xe>
     53e:	4a c0       	rjmp	.+148    	; 0x5d4 <disk_read+0xa2>
     540:	00 23       	and	r16, r16
     542:	09 f4       	brne	.+2      	; 0x546 <disk_read+0x14>
     544:	49 c0       	rjmp	.+146    	; 0x5d8 <disk_read+0xa6>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     546:	80 91 8a 01 	lds	r24, 0x018A
     54a:	80 fd       	sbrc	r24, 0
     54c:	47 c0       	rjmp	.+142    	; 0x5dc <disk_read+0xaa>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
     54e:	80 91 22 04 	lds	r24, 0x0422
     552:	83 fd       	sbrc	r24, 3
     554:	09 c0       	rjmp	.+18     	; 0x568 <disk_read+0x36>
     556:	01 2e       	mov	r0, r17
     558:	19 e0       	ldi	r17, 0x09	; 9
     55a:	22 0f       	add	r18, r18
     55c:	33 1f       	adc	r19, r19
     55e:	44 1f       	adc	r20, r20
     560:	55 1f       	adc	r21, r21
     562:	1a 95       	dec	r17
     564:	d1 f7       	brne	.-12     	; 0x55a <disk_read+0x28>
     566:	10 2d       	mov	r17, r0

	if (count == 1) {	/* Single block read */
     568:	01 30       	cpi	r16, 0x01	; 1
     56a:	89 f4       	brne	.+34     	; 0x58e <disk_read+0x5c>
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
     56c:	81 e1       	ldi	r24, 0x11	; 17
     56e:	ba 01       	movw	r22, r20
     570:	a9 01       	movw	r20, r18
     572:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     576:	88 23       	and	r24, r24
     578:	31 f5       	brne	.+76     	; 0x5c6 <disk_read+0x94>
			&& rcvr_datablock(buff, 512))
     57a:	ce 01       	movw	r24, r28
     57c:	40 e0       	ldi	r20, 0x00	; 0
     57e:	52 e0       	ldi	r21, 0x02	; 2
     580:	60 e0       	ldi	r22, 0x00	; 0
     582:	70 e0       	ldi	r23, 0x00	; 0
     584:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     588:	00 97       	sbiw	r24, 0x00	; 0
     58a:	e1 f4       	brne	.+56     	; 0x5c4 <disk_read+0x92>
     58c:	1c c0       	rjmp	.+56     	; 0x5c6 <disk_read+0x94>
			count = 0;
	}
	else {				/* Multiple block read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
     58e:	82 e1       	ldi	r24, 0x12	; 18
     590:	ba 01       	movw	r22, r20
     592:	a9 01       	movw	r20, r18
     594:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     598:	88 23       	and	r24, r24
     59a:	a9 f4       	brne	.+42     	; 0x5c6 <disk_read+0x94>
			do {
				if (!rcvr_datablock(buff, 512)) break;
     59c:	ce 01       	movw	r24, r28
     59e:	40 e0       	ldi	r20, 0x00	; 0
     5a0:	52 e0       	ldi	r21, 0x02	; 2
     5a2:	60 e0       	ldi	r22, 0x00	; 0
     5a4:	70 e0       	ldi	r23, 0x00	; 0
     5a6:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     5aa:	00 97       	sbiw	r24, 0x00	; 0
     5ac:	21 f0       	breq	.+8      	; 0x5b6 <disk_read+0x84>
				buff += 512;
     5ae:	c0 50       	subi	r28, 0x00	; 0
     5b0:	de 4f       	sbci	r29, 0xFE	; 254
			} while (--count);
     5b2:	01 50       	subi	r16, 0x01	; 1
     5b4:	99 f7       	brne	.-26     	; 0x59c <disk_read+0x6a>
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
     5b6:	8c e0       	ldi	r24, 0x0C	; 12
     5b8:	40 e0       	ldi	r20, 0x00	; 0
     5ba:	50 e0       	ldi	r21, 0x00	; 0
     5bc:	ba 01       	movw	r22, r20
     5be:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     5c2:	01 c0       	rjmp	.+2      	; 0x5c6 <disk_read+0x94>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */

	if (count == 1) {	/* Single block read */
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
			&& rcvr_datablock(buff, 512))
			count = 0;
     5c4:	00 e0       	ldi	r16, 0x00	; 0
				buff += 512;
			} while (--count);
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
		}
	}
	deselect();
     5c6:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>

	return count ? RES_ERROR : RES_OK;
     5ca:	81 e0       	ldi	r24, 0x01	; 1
     5cc:	00 23       	and	r16, r16
     5ce:	39 f4       	brne	.+14     	; 0x5de <disk_read+0xac>
     5d0:	80 e0       	ldi	r24, 0x00	; 0
     5d2:	05 c0       	rjmp	.+10     	; 0x5de <disk_read+0xac>
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
	if (drv || !count) return RES_PARERR;
     5d4:	84 e0       	ldi	r24, 0x04	; 4
     5d6:	03 c0       	rjmp	.+6      	; 0x5de <disk_read+0xac>
     5d8:	84 e0       	ldi	r24, 0x04	; 4
     5da:	01 c0       	rjmp	.+2      	; 0x5de <disk_read+0xac>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     5dc:	83 e0       	ldi	r24, 0x03	; 3
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
     5de:	df 91       	pop	r29
     5e0:	cf 91       	pop	r28
     5e2:	0f 91       	pop	r16
     5e4:	08 95       	ret

000005e6 <disk_write>:
	BYTE drv,			/* Physical drive nmuber (0) */
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
     5e6:	cf 92       	push	r12
     5e8:	df 92       	push	r13
     5ea:	ef 92       	push	r14
     5ec:	ff 92       	push	r15
     5ee:	0f 93       	push	r16
     5f0:	cf 93       	push	r28
     5f2:	df 93       	push	r29
     5f4:	eb 01       	movw	r28, r22
     5f6:	69 01       	movw	r12, r18
     5f8:	7a 01       	movw	r14, r20
	if (drv || !count) return RES_PARERR;
     5fa:	88 23       	and	r24, r24
     5fc:	09 f0       	breq	.+2      	; 0x600 <disk_write+0x1a>
     5fe:	57 c0       	rjmp	.+174    	; 0x6ae <disk_write+0xc8>
     600:	00 23       	and	r16, r16
     602:	09 f4       	brne	.+2      	; 0x606 <disk_write+0x20>
     604:	56 c0       	rjmp	.+172    	; 0x6b2 <disk_write+0xcc>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     606:	80 91 8a 01 	lds	r24, 0x018A
     60a:	80 fd       	sbrc	r24, 0
     60c:	54 c0       	rjmp	.+168    	; 0x6b6 <disk_write+0xd0>
	if (Stat & STA_PROTECT) return RES_WRPRT;
     60e:	80 91 8a 01 	lds	r24, 0x018A
     612:	82 fd       	sbrc	r24, 2
     614:	52 c0       	rjmp	.+164    	; 0x6ba <disk_write+0xd4>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
     616:	80 91 22 04 	lds	r24, 0x0422
     61a:	90 e0       	ldi	r25, 0x00	; 0
     61c:	83 fd       	sbrc	r24, 3
     61e:	09 c0       	rjmp	.+18     	; 0x632 <disk_write+0x4c>
     620:	0b 2e       	mov	r0, r27
     622:	b9 e0       	ldi	r27, 0x09	; 9
     624:	cc 0c       	add	r12, r12
     626:	dd 1c       	adc	r13, r13
     628:	ee 1c       	adc	r14, r14
     62a:	ff 1c       	adc	r15, r15
     62c:	ba 95       	dec	r27
     62e:	d1 f7       	brne	.-12     	; 0x624 <disk_write+0x3e>
     630:	b0 2d       	mov	r27, r0

	if (count == 1) {	/* Single block write */
     632:	01 30       	cpi	r16, 0x01	; 1
     634:	71 f4       	brne	.+28     	; 0x652 <disk_write+0x6c>
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
     636:	88 e1       	ldi	r24, 0x18	; 24
     638:	b7 01       	movw	r22, r14
     63a:	a6 01       	movw	r20, r12
     63c:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     640:	88 23       	and	r24, r24
     642:	71 f5       	brne	.+92     	; 0x6a0 <disk_write+0xba>
			&& xmit_datablock(buff, 0xFE))
     644:	ce 01       	movw	r24, r28
     646:	6e ef       	ldi	r22, 0xFE	; 254
     648:	0e 94 39 01 	call	0x272	; 0x272 <xmit_datablock>
     64c:	00 97       	sbiw	r24, 0x00	; 0
     64e:	29 f5       	brne	.+74     	; 0x69a <disk_write+0xb4>
     650:	27 c0       	rjmp	.+78     	; 0x6a0 <disk_write+0xba>
			count = 0;
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
     652:	86 70       	andi	r24, 0x06	; 6
     654:	90 70       	andi	r25, 0x00	; 0
     656:	00 97       	sbiw	r24, 0x00	; 0
     658:	39 f0       	breq	.+14     	; 0x668 <disk_write+0x82>
     65a:	40 2f       	mov	r20, r16
     65c:	50 e0       	ldi	r21, 0x00	; 0
     65e:	60 e0       	ldi	r22, 0x00	; 0
     660:	70 e0       	ldi	r23, 0x00	; 0
     662:	87 e9       	ldi	r24, 0x97	; 151
     664:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
     668:	89 e1       	ldi	r24, 0x19	; 25
     66a:	b7 01       	movw	r22, r14
     66c:	a6 01       	movw	r20, r12
     66e:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     672:	88 23       	and	r24, r24
     674:	a9 f4       	brne	.+42     	; 0x6a0 <disk_write+0xba>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
     676:	ce 01       	movw	r24, r28
     678:	6c ef       	ldi	r22, 0xFC	; 252
     67a:	0e 94 39 01 	call	0x272	; 0x272 <xmit_datablock>
     67e:	00 97       	sbiw	r24, 0x00	; 0
     680:	21 f0       	breq	.+8      	; 0x68a <disk_write+0xa4>
				buff += 512;
     682:	c0 50       	subi	r28, 0x00	; 0
     684:	de 4f       	sbci	r29, 0xFE	; 254
			} while (--count);
     686:	01 50       	subi	r16, 0x01	; 1
     688:	b1 f7       	brne	.-20     	; 0x676 <disk_write+0x90>
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
     68a:	80 e0       	ldi	r24, 0x00	; 0
     68c:	90 e0       	ldi	r25, 0x00	; 0
     68e:	6d ef       	ldi	r22, 0xFD	; 253
     690:	0e 94 39 01 	call	0x272	; 0x272 <xmit_datablock>
     694:	00 97       	sbiw	r24, 0x00	; 0
     696:	19 f0       	breq	.+6      	; 0x69e <disk_write+0xb8>
     698:	03 c0       	rjmp	.+6      	; 0x6a0 <disk_write+0xba>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */

	if (count == 1) {	/* Single block write */
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
			&& xmit_datablock(buff, 0xFE))
			count = 0;
     69a:	00 e0       	ldi	r16, 0x00	; 0
     69c:	01 c0       	rjmp	.+2      	; 0x6a0 <disk_write+0xba>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
				buff += 512;
			} while (--count);
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
				count = 1;
     69e:	01 e0       	ldi	r16, 0x01	; 1
		}
	}
	deselect();
     6a0:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>

	return count ? RES_ERROR : RES_OK;
     6a4:	81 e0       	ldi	r24, 0x01	; 1
     6a6:	00 23       	and	r16, r16
     6a8:	49 f4       	brne	.+18     	; 0x6bc <disk_write+0xd6>
     6aa:	80 e0       	ldi	r24, 0x00	; 0
     6ac:	07 c0       	rjmp	.+14     	; 0x6bc <disk_write+0xd6>
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
	if (drv || !count) return RES_PARERR;
     6ae:	84 e0       	ldi	r24, 0x04	; 4
     6b0:	05 c0       	rjmp	.+10     	; 0x6bc <disk_write+0xd6>
     6b2:	84 e0       	ldi	r24, 0x04	; 4
     6b4:	03 c0       	rjmp	.+6      	; 0x6bc <disk_write+0xd6>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     6b6:	83 e0       	ldi	r24, 0x03	; 3
     6b8:	01 c0       	rjmp	.+2      	; 0x6bc <disk_write+0xd6>
	if (Stat & STA_PROTECT) return RES_WRPRT;
     6ba:	82 e0       	ldi	r24, 0x02	; 2
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
     6bc:	df 91       	pop	r29
     6be:	cf 91       	pop	r28
     6c0:	0f 91       	pop	r16
     6c2:	ff 90       	pop	r15
     6c4:	ef 90       	pop	r14
     6c6:	df 90       	pop	r13
     6c8:	cf 90       	pop	r12
     6ca:	08 95       	ret

000006cc <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
     6cc:	ef 92       	push	r14
     6ce:	ff 92       	push	r15
     6d0:	0f 93       	push	r16
     6d2:	1f 93       	push	r17
     6d4:	cf 93       	push	r28
     6d6:	df 93       	push	r29
     6d8:	cd b7       	in	r28, 0x3d	; 61
     6da:	de b7       	in	r29, 0x3e	; 62
     6dc:	60 97       	sbiw	r28, 0x10	; 16
     6de:	0f b6       	in	r0, 0x3f	; 63
     6e0:	f8 94       	cli
     6e2:	de bf       	out	0x3e, r29	; 62
     6e4:	0f be       	out	0x3f, r0	; 63
     6e6:	cd bf       	out	0x3d, r28	; 61
     6e8:	7a 01       	movw	r14, r20
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	DWORD csize;


	if (drv) return RES_PARERR;
     6ea:	88 23       	and	r24, r24
     6ec:	09 f0       	breq	.+2      	; 0x6f0 <disk_ioctl+0x24>
     6ee:	da c1       	rjmp	.+948    	; 0xaa4 <disk_ioctl+0x3d8>

	res = RES_ERROR;

	if (ctrl == CTRL_POWER) {
     6f0:	65 30       	cpi	r22, 0x05	; 5
     6f2:	89 f4       	brne	.+34     	; 0x716 <disk_ioctl+0x4a>
		switch (ptr[0]) {
     6f4:	fa 01       	movw	r30, r20
     6f6:	80 81       	ld	r24, Z
     6f8:	88 23       	and	r24, r24
     6fa:	21 f0       	breq	.+8      	; 0x704 <disk_ioctl+0x38>
     6fc:	81 30       	cpi	r24, 0x01	; 1
     6fe:	09 f0       	breq	.+2      	; 0x702 <disk_ioctl+0x36>
     700:	d3 c1       	rjmp	.+934    	; 0xaa8 <disk_ioctl+0x3dc>
     702:	04 c0       	rjmp	.+8      	; 0x70c <disk_ioctl+0x40>
		case 0:		/* Sub control code (POWER_OFF) */
			power_off();		/* Power off */
     704:	0e 94 bc 00 	call	0x178	; 0x178 <power_off>
			res = RES_OK;
     708:	00 e0       	ldi	r16, 0x00	; 0
			break;
     70a:	d1 c1       	rjmp	.+930    	; 0xaae <disk_ioctl+0x3e2>
		case 1:		/* Sub control code (POWER_GET) */
			ptr[1] = (BYTE)power_status();
     70c:	81 e0       	ldi	r24, 0x01	; 1
     70e:	fa 01       	movw	r30, r20
     710:	81 83       	std	Z+1, r24	; 0x01
			res = RES_OK;
     712:	00 e0       	ldi	r16, 0x00	; 0
			break;
     714:	cc c1       	rjmp	.+920    	; 0xaae <disk_ioctl+0x3e2>
		default :
			res = RES_PARERR;
		}
	}
	else {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
     716:	80 91 8a 01 	lds	r24, 0x018A
     71a:	80 fd       	sbrc	r24, 0
     71c:	c7 c1       	rjmp	.+910    	; 0xaac <disk_ioctl+0x3e0>

		switch (ctrl) {
     71e:	6a 30       	cpi	r22, 0x0A	; 10
     720:	09 f4       	brne	.+2      	; 0x724 <disk_ioctl+0x58>
     722:	44 c1       	rjmp	.+648    	; 0x9ac <disk_ioctl+0x2e0>
     724:	6b 30       	cpi	r22, 0x0B	; 11
     726:	58 f4       	brcc	.+22     	; 0x73e <disk_ioctl+0x72>
     728:	61 30       	cpi	r22, 0x01	; 1
     72a:	f9 f0       	breq	.+62     	; 0x76a <disk_ioctl+0x9e>
     72c:	61 30       	cpi	r22, 0x01	; 1
     72e:	a0 f0       	brcs	.+40     	; 0x758 <disk_ioctl+0x8c>
     730:	62 30       	cpi	r22, 0x02	; 2
     732:	09 f4       	brne	.+2      	; 0x736 <disk_ioctl+0x6a>
     734:	98 c0       	rjmp	.+304    	; 0x866 <disk_ioctl+0x19a>
     736:	63 30       	cpi	r22, 0x03	; 3
     738:	09 f0       	breq	.+2      	; 0x73c <disk_ioctl+0x70>
     73a:	94 c1       	rjmp	.+808    	; 0xa64 <disk_ioctl+0x398>
     73c:	9b c0       	rjmp	.+310    	; 0x874 <disk_ioctl+0x1a8>
     73e:	6c 30       	cpi	r22, 0x0C	; 12
     740:	09 f4       	brne	.+2      	; 0x744 <disk_ioctl+0x78>
     742:	4f c1       	rjmp	.+670    	; 0x9e2 <disk_ioctl+0x316>
     744:	6c 30       	cpi	r22, 0x0C	; 12
     746:	08 f4       	brcc	.+2      	; 0x74a <disk_ioctl+0x7e>
     748:	37 c1       	rjmp	.+622    	; 0x9b8 <disk_ioctl+0x2ec>
     74a:	6d 30       	cpi	r22, 0x0D	; 13
     74c:	09 f4       	brne	.+2      	; 0x750 <disk_ioctl+0x84>
     74e:	5e c1       	rjmp	.+700    	; 0xa0c <disk_ioctl+0x340>
     750:	6e 30       	cpi	r22, 0x0E	; 14
     752:	09 f0       	breq	.+2      	; 0x756 <disk_ioctl+0x8a>
     754:	87 c1       	rjmp	.+782    	; 0xa64 <disk_ioctl+0x398>
     756:	70 c1       	rjmp	.+736    	; 0xa38 <disk_ioctl+0x36c>
		case CTRL_SYNC :		/* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
			if (select()) {
     758:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <select>
     75c:	00 97       	sbiw	r24, 0x00	; 0
     75e:	09 f4       	brne	.+2      	; 0x762 <disk_ioctl+0x96>
     760:	83 c1       	rjmp	.+774    	; 0xa68 <disk_ioctl+0x39c>
				deselect();
     762:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
				res = RES_OK;
     766:	00 e0       	ldi	r16, 0x00	; 0
     768:	9a c1       	rjmp	.+820    	; 0xa9e <disk_ioctl+0x3d2>
			}
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
     76a:	89 e0       	ldi	r24, 0x09	; 9
     76c:	40 e0       	ldi	r20, 0x00	; 0
     76e:	50 e0       	ldi	r21, 0x00	; 0
     770:	ba 01       	movw	r22, r20
     772:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     776:	88 23       	and	r24, r24
     778:	09 f0       	breq	.+2      	; 0x77c <disk_ioctl+0xb0>
     77a:	78 c1       	rjmp	.+752    	; 0xa6c <disk_ioctl+0x3a0>
     77c:	ce 01       	movw	r24, r28
     77e:	01 96       	adiw	r24, 0x01	; 1
     780:	40 e1       	ldi	r20, 0x10	; 16
     782:	50 e0       	ldi	r21, 0x00	; 0
     784:	60 e0       	ldi	r22, 0x00	; 0
     786:	70 e0       	ldi	r23, 0x00	; 0
     788:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     78c:	00 97       	sbiw	r24, 0x00	; 0
     78e:	09 f4       	brne	.+2      	; 0x792 <disk_ioctl+0xc6>
     790:	6f c1       	rjmp	.+734    	; 0xa70 <disk_ioctl+0x3a4>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
     792:	89 81       	ldd	r24, Y+1	; 0x01
     794:	82 95       	swap	r24
     796:	86 95       	lsr	r24
     798:	86 95       	lsr	r24
     79a:	83 70       	andi	r24, 0x03	; 3
     79c:	81 30       	cpi	r24, 0x01	; 1
     79e:	51 f5       	brne	.+84     	; 0x7f4 <disk_ioctl+0x128>
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
     7a0:	48 85       	ldd	r20, Y+8	; 0x08
     7a2:	50 e0       	ldi	r21, 0x00	; 0
     7a4:	60 e0       	ldi	r22, 0x00	; 0
     7a6:	70 e0       	ldi	r23, 0x00	; 0
     7a8:	4f 73       	andi	r20, 0x3F	; 63
     7aa:	50 70       	andi	r21, 0x00	; 0
     7ac:	60 70       	andi	r22, 0x00	; 0
     7ae:	70 70       	andi	r23, 0x00	; 0
     7b0:	ba 01       	movw	r22, r20
     7b2:	55 27       	eor	r21, r21
     7b4:	44 27       	eor	r20, r20
     7b6:	4f 5f       	subi	r20, 0xFF	; 255
     7b8:	5f 4f       	sbci	r21, 0xFF	; 255
     7ba:	6f 4f       	sbci	r22, 0xFF	; 255
     7bc:	7f 4f       	sbci	r23, 0xFF	; 255
     7be:	99 85       	ldd	r25, Y+9	; 0x09
     7c0:	80 e0       	ldi	r24, 0x00	; 0
     7c2:	2a 85       	ldd	r18, Y+10	; 0x0a
     7c4:	82 0f       	add	r24, r18
     7c6:	91 1d       	adc	r25, r1
     7c8:	a0 e0       	ldi	r26, 0x00	; 0
     7ca:	b0 e0       	ldi	r27, 0x00	; 0
     7cc:	84 0f       	add	r24, r20
     7ce:	95 1f       	adc	r25, r21
     7d0:	a6 1f       	adc	r26, r22
     7d2:	b7 1f       	adc	r27, r23
					*(DWORD*)buff = csize << 10;
     7d4:	07 2e       	mov	r0, r23
     7d6:	7a e0       	ldi	r23, 0x0A	; 10
     7d8:	88 0f       	add	r24, r24
     7da:	99 1f       	adc	r25, r25
     7dc:	aa 1f       	adc	r26, r26
     7de:	bb 1f       	adc	r27, r27
     7e0:	7a 95       	dec	r23
     7e2:	d1 f7       	brne	.-12     	; 0x7d8 <disk_ioctl+0x10c>
     7e4:	70 2d       	mov	r23, r0
     7e6:	f7 01       	movw	r30, r14
     7e8:	80 83       	st	Z, r24
     7ea:	91 83       	std	Z+1, r25	; 0x01
     7ec:	a2 83       	std	Z+2, r26	; 0x02
     7ee:	b3 83       	std	Z+3, r27	; 0x03
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = csize << (n - 9);
				}
				res = RES_OK;
     7f0:	00 e0       	ldi	r16, 0x00	; 0
     7f2:	55 c1       	rjmp	.+682    	; 0xa9e <disk_ioctl+0x3d2>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = csize << 10;
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
     7f4:	29 85       	ldd	r18, Y+9	; 0x09
     7f6:	22 95       	swap	r18
     7f8:	26 95       	lsr	r18
     7fa:	26 95       	lsr	r18
     7fc:	23 70       	andi	r18, 0x03	; 3
     7fe:	88 85       	ldd	r24, Y+8	; 0x08
     800:	90 e0       	ldi	r25, 0x00	; 0
     802:	88 0f       	add	r24, r24
     804:	99 1f       	adc	r25, r25
     806:	88 0f       	add	r24, r24
     808:	99 1f       	adc	r25, r25
     80a:	82 0f       	add	r24, r18
     80c:	91 1d       	adc	r25, r1
     80e:	01 96       	adiw	r24, 0x01	; 1
     810:	2f 81       	ldd	r18, Y+7	; 0x07
     812:	30 e0       	ldi	r19, 0x00	; 0
     814:	23 70       	andi	r18, 0x03	; 3
     816:	30 70       	andi	r19, 0x00	; 0
     818:	32 2f       	mov	r19, r18
     81a:	22 27       	eor	r18, r18
     81c:	33 0f       	add	r19, r19
     81e:	33 0f       	add	r19, r19
     820:	82 0f       	add	r24, r18
     822:	93 1f       	adc	r25, r19
     824:	ac 01       	movw	r20, r24
     826:	60 e0       	ldi	r22, 0x00	; 0
     828:	70 e0       	ldi	r23, 0x00	; 0
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = csize << 10;
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
     82a:	9e 81       	ldd	r25, Y+6	; 0x06
     82c:	9f 70       	andi	r25, 0x0F	; 15
     82e:	8b 85       	ldd	r24, Y+11	; 0x0b
     830:	88 1f       	adc	r24, r24
     832:	88 27       	eor	r24, r24
     834:	88 1f       	adc	r24, r24
     836:	98 0f       	add	r25, r24
     838:	9e 5f       	subi	r25, 0xFE	; 254
     83a:	8a 85       	ldd	r24, Y+10	; 0x0a
     83c:	83 70       	andi	r24, 0x03	; 3
     83e:	88 0f       	add	r24, r24
     840:	89 0f       	add	r24, r25
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = csize << (n - 9);
     842:	90 e0       	ldi	r25, 0x00	; 0
     844:	09 97       	sbiw	r24, 0x09	; 9
     846:	8a 01       	movw	r16, r20
     848:	9b 01       	movw	r18, r22
     84a:	04 c0       	rjmp	.+8      	; 0x854 <disk_ioctl+0x188>
     84c:	00 0f       	add	r16, r16
     84e:	11 1f       	adc	r17, r17
     850:	22 1f       	adc	r18, r18
     852:	33 1f       	adc	r19, r19
     854:	8a 95       	dec	r24
     856:	d2 f7       	brpl	.-12     	; 0x84c <disk_ioctl+0x180>
     858:	f7 01       	movw	r30, r14
     85a:	00 83       	st	Z, r16
     85c:	11 83       	std	Z+1, r17	; 0x01
     85e:	22 83       	std	Z+2, r18	; 0x02
     860:	33 83       	std	Z+3, r19	; 0x03
				}
				res = RES_OK;
     862:	00 e0       	ldi	r16, 0x00	; 0
     864:	1c c1       	rjmp	.+568    	; 0xa9e <disk_ioctl+0x3d2>
			}
			break;

		case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
			*(WORD*)buff = 512;
     866:	80 e0       	ldi	r24, 0x00	; 0
     868:	92 e0       	ldi	r25, 0x02	; 2
     86a:	fa 01       	movw	r30, r20
     86c:	91 83       	std	Z+1, r25	; 0x01
     86e:	80 83       	st	Z, r24
			res = RES_OK;
     870:	00 e0       	ldi	r16, 0x00	; 0
			break;
     872:	15 c1       	rjmp	.+554    	; 0xa9e <disk_ioctl+0x3d2>

		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
			if (CardType & CT_SD2) {	/* SDv2? */
     874:	00 91 22 04 	lds	r16, 0x0422
     878:	02 ff       	sbrs	r16, 2
     87a:	31 c0       	rjmp	.+98     	; 0x8de <disk_ioctl+0x212>
				if (send_cmd(ACMD13, 0) == 0) {	/* Read SD status */
     87c:	8d e8       	ldi	r24, 0x8D	; 141
     87e:	40 e0       	ldi	r20, 0x00	; 0
     880:	50 e0       	ldi	r21, 0x00	; 0
     882:	ba 01       	movw	r22, r20
     884:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     888:	88 23       	and	r24, r24
     88a:	09 f0       	breq	.+2      	; 0x88e <disk_ioctl+0x1c2>
     88c:	f3 c0       	rjmp	.+486    	; 0xa74 <disk_ioctl+0x3a8>
					xchg_spi(0xFF);
     88e:	8f ef       	ldi	r24, 0xFF	; 255
     890:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
					if (rcvr_datablock(csd, 16)) {				/* Read partial block */
     894:	ce 01       	movw	r24, r28
     896:	01 96       	adiw	r24, 0x01	; 1
     898:	40 e1       	ldi	r20, 0x10	; 16
     89a:	50 e0       	ldi	r21, 0x00	; 0
     89c:	60 e0       	ldi	r22, 0x00	; 0
     89e:	70 e0       	ldi	r23, 0x00	; 0
     8a0:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     8a4:	00 97       	sbiw	r24, 0x00	; 0
     8a6:	09 f4       	brne	.+2      	; 0x8aa <disk_ioctl+0x1de>
     8a8:	e7 c0       	rjmp	.+462    	; 0xa78 <disk_ioctl+0x3ac>
     8aa:	00 e3       	ldi	r16, 0x30	; 48
						for (n = 64 - 16; n; n--) xchg_spi(0xFF);	/* Purge trailing data */
     8ac:	8f ef       	ldi	r24, 0xFF	; 255
     8ae:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     8b2:	01 50       	subi	r16, 0x01	; 1
     8b4:	d9 f7       	brne	.-10     	; 0x8ac <disk_ioctl+0x1e0>
						*(DWORD*)buff = 16UL << (csd[10] >> 4);
     8b6:	2b 85       	ldd	r18, Y+11	; 0x0b
     8b8:	22 95       	swap	r18
     8ba:	2f 70       	andi	r18, 0x0F	; 15
     8bc:	80 e1       	ldi	r24, 0x10	; 16
     8be:	90 e0       	ldi	r25, 0x00	; 0
     8c0:	a0 e0       	ldi	r26, 0x00	; 0
     8c2:	b0 e0       	ldi	r27, 0x00	; 0
     8c4:	04 c0       	rjmp	.+8      	; 0x8ce <disk_ioctl+0x202>
     8c6:	88 0f       	add	r24, r24
     8c8:	99 1f       	adc	r25, r25
     8ca:	aa 1f       	adc	r26, r26
     8cc:	bb 1f       	adc	r27, r27
     8ce:	2a 95       	dec	r18
     8d0:	d2 f7       	brpl	.-12     	; 0x8c6 <disk_ioctl+0x1fa>
     8d2:	f7 01       	movw	r30, r14
     8d4:	80 83       	st	Z, r24
     8d6:	91 83       	std	Z+1, r25	; 0x01
     8d8:	a2 83       	std	Z+2, r26	; 0x02
     8da:	b3 83       	std	Z+3, r27	; 0x03
     8dc:	e0 c0       	rjmp	.+448    	; 0xa9e <disk_ioctl+0x3d2>
						res = RES_OK;
					}
				}
			} else {					/* SDv1 or MMCv3 */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
     8de:	89 e0       	ldi	r24, 0x09	; 9
     8e0:	40 e0       	ldi	r20, 0x00	; 0
     8e2:	50 e0       	ldi	r21, 0x00	; 0
     8e4:	ba 01       	movw	r22, r20
     8e6:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     8ea:	88 23       	and	r24, r24
     8ec:	09 f0       	breq	.+2      	; 0x8f0 <disk_ioctl+0x224>
     8ee:	c6 c0       	rjmp	.+396    	; 0xa7c <disk_ioctl+0x3b0>
     8f0:	ce 01       	movw	r24, r28
     8f2:	01 96       	adiw	r24, 0x01	; 1
     8f4:	40 e1       	ldi	r20, 0x10	; 16
     8f6:	50 e0       	ldi	r21, 0x00	; 0
     8f8:	60 e0       	ldi	r22, 0x00	; 0
     8fa:	70 e0       	ldi	r23, 0x00	; 0
     8fc:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     900:	00 97       	sbiw	r24, 0x00	; 0
     902:	09 f4       	brne	.+2      	; 0x906 <disk_ioctl+0x23a>
     904:	bd c0       	rjmp	.+378    	; 0xa80 <disk_ioctl+0x3b4>
					if (CardType & CT_SD1) {	/* SDv1 */
     906:	01 ff       	sbrs	r16, 1
     908:	25 c0       	rjmp	.+74     	; 0x954 <disk_ioctl+0x288>
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
     90a:	8c 85       	ldd	r24, Y+12	; 0x0c
     90c:	88 1f       	adc	r24, r24
     90e:	88 27       	eor	r24, r24
     910:	88 1f       	adc	r24, r24
     912:	90 e0       	ldi	r25, 0x00	; 0
     914:	01 96       	adiw	r24, 0x01	; 1
     916:	2b 85       	ldd	r18, Y+11	; 0x0b
     918:	30 e0       	ldi	r19, 0x00	; 0
     91a:	2f 73       	andi	r18, 0x3F	; 63
     91c:	30 70       	andi	r19, 0x00	; 0
     91e:	22 0f       	add	r18, r18
     920:	33 1f       	adc	r19, r19
     922:	28 0f       	add	r18, r24
     924:	39 1f       	adc	r19, r25
     926:	8e 85       	ldd	r24, Y+14	; 0x0e
     928:	82 95       	swap	r24
     92a:	86 95       	lsr	r24
     92c:	86 95       	lsr	r24
     92e:	83 70       	andi	r24, 0x03	; 3
     930:	90 e0       	ldi	r25, 0x00	; 0
     932:	01 97       	sbiw	r24, 0x01	; 1
     934:	89 01       	movw	r16, r18
     936:	02 c0       	rjmp	.+4      	; 0x93c <disk_ioctl+0x270>
     938:	00 0f       	add	r16, r16
     93a:	11 1f       	adc	r17, r17
     93c:	8a 95       	dec	r24
     93e:	e2 f7       	brpl	.-8      	; 0x938 <disk_ioctl+0x26c>
     940:	c8 01       	movw	r24, r16
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	f7 01       	movw	r30, r14
     948:	80 83       	st	Z, r24
     94a:	91 83       	std	Z+1, r25	; 0x01
     94c:	a2 83       	std	Z+2, r26	; 0x02
     94e:	b3 83       	std	Z+3, r27	; 0x03
					} else {					/* MMCv3 */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
					}
					res = RES_OK;
     950:	00 e0       	ldi	r16, 0x00	; 0
     952:	a5 c0       	rjmp	.+330    	; 0xa9e <disk_ioctl+0x3d2>
			} else {					/* SDv1 or MMCv3 */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
					if (CardType & CT_SD1) {	/* SDv1 */
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
					} else {					/* MMCv3 */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
     954:	8c 85       	ldd	r24, Y+12	; 0x0c
     956:	48 2f       	mov	r20, r24
     958:	50 e0       	ldi	r21, 0x00	; 0
     95a:	43 70       	andi	r20, 0x03	; 3
     95c:	50 70       	andi	r21, 0x00	; 0
     95e:	44 0f       	add	r20, r20
     960:	55 1f       	adc	r21, r21
     962:	44 0f       	add	r20, r20
     964:	55 1f       	adc	r21, r21
     966:	44 0f       	add	r20, r20
     968:	55 1f       	adc	r21, r21
     96a:	82 95       	swap	r24
     96c:	86 95       	lsr	r24
     96e:	87 70       	andi	r24, 0x07	; 7
     970:	48 0f       	add	r20, r24
     972:	51 1d       	adc	r21, r1
     974:	4f 5f       	subi	r20, 0xFF	; 255
     976:	5f 4f       	sbci	r21, 0xFF	; 255
     978:	2b 85       	ldd	r18, Y+11	; 0x0b
     97a:	30 e0       	ldi	r19, 0x00	; 0
     97c:	2c 77       	andi	r18, 0x7C	; 124
     97e:	30 70       	andi	r19, 0x00	; 0
     980:	35 95       	asr	r19
     982:	27 95       	ror	r18
     984:	35 95       	asr	r19
     986:	27 95       	ror	r18
     988:	2f 5f       	subi	r18, 0xFF	; 255
     98a:	3f 4f       	sbci	r19, 0xFF	; 255
     98c:	42 9f       	mul	r20, r18
     98e:	c0 01       	movw	r24, r0
     990:	43 9f       	mul	r20, r19
     992:	90 0d       	add	r25, r0
     994:	52 9f       	mul	r21, r18
     996:	90 0d       	add	r25, r0
     998:	11 24       	eor	r1, r1
     99a:	a0 e0       	ldi	r26, 0x00	; 0
     99c:	b0 e0       	ldi	r27, 0x00	; 0
     99e:	f7 01       	movw	r30, r14
     9a0:	80 83       	st	Z, r24
     9a2:	91 83       	std	Z+1, r25	; 0x01
     9a4:	a2 83       	std	Z+2, r26	; 0x02
     9a6:	b3 83       	std	Z+3, r27	; 0x03
					}
					res = RES_OK;
     9a8:	00 e0       	ldi	r16, 0x00	; 0
     9aa:	79 c0       	rjmp	.+242    	; 0xa9e <disk_ioctl+0x3d2>
				}
			}
			break;

		case MMC_GET_TYPE :		/* Get card type flags (1 byte) */
			*ptr = CardType;
     9ac:	80 91 22 04 	lds	r24, 0x0422
     9b0:	fa 01       	movw	r30, r20
     9b2:	80 83       	st	Z, r24
			res = RES_OK;
     9b4:	00 e0       	ldi	r16, 0x00	; 0
			break;
     9b6:	73 c0       	rjmp	.+230    	; 0xa9e <disk_ioctl+0x3d2>

		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
     9b8:	89 e0       	ldi	r24, 0x09	; 9
     9ba:	40 e0       	ldi	r20, 0x00	; 0
     9bc:	50 e0       	ldi	r21, 0x00	; 0
     9be:	ba 01       	movw	r22, r20
     9c0:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     9c4:	88 23       	and	r24, r24
     9c6:	09 f0       	breq	.+2      	; 0x9ca <disk_ioctl+0x2fe>
     9c8:	5d c0       	rjmp	.+186    	; 0xa84 <disk_ioctl+0x3b8>
				&& rcvr_datablock(ptr, 16))
     9ca:	c7 01       	movw	r24, r14
     9cc:	40 e1       	ldi	r20, 0x10	; 16
     9ce:	50 e0       	ldi	r21, 0x00	; 0
     9d0:	60 e0       	ldi	r22, 0x00	; 0
     9d2:	70 e0       	ldi	r23, 0x00	; 0
     9d4:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     9d8:	00 97       	sbiw	r24, 0x00	; 0
     9da:	09 f0       	breq	.+2      	; 0x9de <disk_ioctl+0x312>
     9dc:	55 c0       	rjmp	.+170    	; 0xa88 <disk_ioctl+0x3bc>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     9de:	01 e0       	ldi	r16, 0x01	; 1
     9e0:	5e c0       	rjmp	.+188    	; 0xa9e <disk_ioctl+0x3d2>
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
			break;

		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
     9e2:	8a e0       	ldi	r24, 0x0A	; 10
     9e4:	40 e0       	ldi	r20, 0x00	; 0
     9e6:	50 e0       	ldi	r21, 0x00	; 0
     9e8:	ba 01       	movw	r22, r20
     9ea:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     9ee:	88 23       	and	r24, r24
     9f0:	09 f0       	breq	.+2      	; 0x9f4 <disk_ioctl+0x328>
     9f2:	4c c0       	rjmp	.+152    	; 0xa8c <disk_ioctl+0x3c0>
				&& rcvr_datablock(ptr, 16))
     9f4:	c7 01       	movw	r24, r14
     9f6:	40 e1       	ldi	r20, 0x10	; 16
     9f8:	50 e0       	ldi	r21, 0x00	; 0
     9fa:	60 e0       	ldi	r22, 0x00	; 0
     9fc:	70 e0       	ldi	r23, 0x00	; 0
     9fe:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     a02:	00 97       	sbiw	r24, 0x00	; 0
     a04:	09 f0       	breq	.+2      	; 0xa08 <disk_ioctl+0x33c>
     a06:	44 c0       	rjmp	.+136    	; 0xa90 <disk_ioctl+0x3c4>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a08:	01 e0       	ldi	r16, 0x01	; 1
     a0a:	49 c0       	rjmp	.+146    	; 0xa9e <disk_ioctl+0x3d2>
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
			break;

		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
			if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
     a0c:	8a e3       	ldi	r24, 0x3A	; 58
     a0e:	40 e0       	ldi	r20, 0x00	; 0
     a10:	50 e0       	ldi	r21, 0x00	; 0
     a12:	ba 01       	movw	r22, r20
     a14:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     a18:	88 23       	and	r24, r24
     a1a:	e1 f5       	brne	.+120    	; 0xa94 <disk_ioctl+0x3c8>
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
/*-----------------------------------------------------------------------*/

#if _USE_IOCTL
DRESULT disk_ioctl (
     a1c:	87 01       	movw	r16, r14
     a1e:	0c 5f       	subi	r16, 0xFC	; 252
     a20:	1f 4f       	sbci	r17, 0xFF	; 255
				res = RES_OK;
			break;

		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
			if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
				for (n = 4; n; n--) *ptr++ = xchg_spi(0xFF);
     a22:	8f ef       	ldi	r24, 0xFF	; 255
     a24:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     a28:	f7 01       	movw	r30, r14
     a2a:	81 93       	st	Z+, r24
     a2c:	7f 01       	movw	r14, r30
     a2e:	e0 17       	cp	r30, r16
     a30:	f1 07       	cpc	r31, r17
     a32:	b9 f7       	brne	.-18     	; 0xa22 <disk_ioctl+0x356>
				res = RES_OK;
     a34:	00 e0       	ldi	r16, 0x00	; 0
     a36:	33 c0       	rjmp	.+102    	; 0xa9e <disk_ioctl+0x3d2>
			}
			break;

		case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
			if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
     a38:	8d e8       	ldi	r24, 0x8D	; 141
     a3a:	40 e0       	ldi	r20, 0x00	; 0
     a3c:	50 e0       	ldi	r21, 0x00	; 0
     a3e:	ba 01       	movw	r22, r20
     a40:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     a44:	88 23       	and	r24, r24
     a46:	41 f5       	brne	.+80     	; 0xa98 <disk_ioctl+0x3cc>
				xchg_spi(0xFF);
     a48:	8f ef       	ldi	r24, 0xFF	; 255
     a4a:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
				if (rcvr_datablock(ptr, 64))
     a4e:	c7 01       	movw	r24, r14
     a50:	40 e4       	ldi	r20, 0x40	; 64
     a52:	50 e0       	ldi	r21, 0x00	; 0
     a54:	60 e0       	ldi	r22, 0x00	; 0
     a56:	70 e0       	ldi	r23, 0x00	; 0
     a58:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     a5c:	00 97       	sbiw	r24, 0x00	; 0
     a5e:	f1 f4       	brne	.+60     	; 0xa9c <disk_ioctl+0x3d0>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a60:	01 e0       	ldi	r16, 0x01	; 1
     a62:	1d c0       	rjmp	.+58     	; 0xa9e <disk_ioctl+0x3d2>
					res = RES_OK;
			}
			break;

		default:
			res = RES_PARERR;
     a64:	04 e0       	ldi	r16, 0x04	; 4
     a66:	1b c0       	rjmp	.+54     	; 0xa9e <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a68:	01 e0       	ldi	r16, 0x01	; 1
     a6a:	19 c0       	rjmp	.+50     	; 0xa9e <disk_ioctl+0x3d2>
     a6c:	01 e0       	ldi	r16, 0x01	; 1
     a6e:	17 c0       	rjmp	.+46     	; 0xa9e <disk_ioctl+0x3d2>
     a70:	01 e0       	ldi	r16, 0x01	; 1
     a72:	15 c0       	rjmp	.+42     	; 0xa9e <disk_ioctl+0x3d2>
     a74:	01 e0       	ldi	r16, 0x01	; 1
     a76:	13 c0       	rjmp	.+38     	; 0xa9e <disk_ioctl+0x3d2>
     a78:	01 e0       	ldi	r16, 0x01	; 1
     a7a:	11 c0       	rjmp	.+34     	; 0xa9e <disk_ioctl+0x3d2>
     a7c:	01 e0       	ldi	r16, 0x01	; 1
     a7e:	0f c0       	rjmp	.+30     	; 0xa9e <disk_ioctl+0x3d2>
     a80:	01 e0       	ldi	r16, 0x01	; 1
     a82:	0d c0       	rjmp	.+26     	; 0xa9e <disk_ioctl+0x3d2>
     a84:	01 e0       	ldi	r16, 0x01	; 1
     a86:	0b c0       	rjmp	.+22     	; 0xa9e <disk_ioctl+0x3d2>
			break;

		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
     a88:	00 e0       	ldi	r16, 0x00	; 0
     a8a:	09 c0       	rjmp	.+18     	; 0xa9e <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a8c:	01 e0       	ldi	r16, 0x01	; 1
     a8e:	07 c0       	rjmp	.+14     	; 0xa9e <disk_ioctl+0x3d2>
			break;

		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
     a90:	00 e0       	ldi	r16, 0x00	; 0
     a92:	05 c0       	rjmp	.+10     	; 0xa9e <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a94:	01 e0       	ldi	r16, 0x01	; 1
     a96:	03 c0       	rjmp	.+6      	; 0xa9e <disk_ioctl+0x3d2>
     a98:	01 e0       	ldi	r16, 0x01	; 1
     a9a:	01 c0       	rjmp	.+2      	; 0xa9e <disk_ioctl+0x3d2>

		case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
			if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
				xchg_spi(0xFF);
				if (rcvr_datablock(ptr, 64))
					res = RES_OK;
     a9c:	00 e0       	ldi	r16, 0x00	; 0

		default:
			res = RES_PARERR;
		}

		deselect();
     a9e:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
     aa2:	05 c0       	rjmp	.+10     	; 0xaae <disk_ioctl+0x3e2>
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	DWORD csize;


	if (drv) return RES_PARERR;
     aa4:	04 e0       	ldi	r16, 0x04	; 4
     aa6:	03 c0       	rjmp	.+6      	; 0xaae <disk_ioctl+0x3e2>
		case 1:		/* Sub control code (POWER_GET) */
			ptr[1] = (BYTE)power_status();
			res = RES_OK;
			break;
		default :
			res = RES_PARERR;
     aa8:	04 e0       	ldi	r16, 0x04	; 4
     aaa:	01 c0       	rjmp	.+2      	; 0xaae <disk_ioctl+0x3e2>
		}
	}
	else {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
     aac:	03 e0       	ldi	r16, 0x03	; 3

		deselect();
	}

	return res;
}
     aae:	80 2f       	mov	r24, r16
     ab0:	60 96       	adiw	r28, 0x10	; 16
     ab2:	0f b6       	in	r0, 0x3f	; 63
     ab4:	f8 94       	cli
     ab6:	de bf       	out	0x3e, r29	; 62
     ab8:	0f be       	out	0x3f, r0	; 63
     aba:	cd bf       	out	0x3d, r28	; 61
     abc:	df 91       	pop	r29
     abe:	cf 91       	pop	r28
     ac0:	1f 91       	pop	r17
     ac2:	0f 91       	pop	r16
     ac4:	ff 90       	pop	r15
     ac6:	ef 90       	pop	r14
     ac8:	08 95       	ret

00000aca <disk_timerproc>:
void disk_timerproc (void)
{
	BYTE n, s;


	n = Timer1;				/* 100Hz decrement timer */
     aca:	80 91 21 04 	lds	r24, 0x0421
	if (n) Timer1 = --n;
     ace:	88 23       	and	r24, r24
     ad0:	19 f0       	breq	.+6      	; 0xad8 <disk_timerproc+0xe>
     ad2:	81 50       	subi	r24, 0x01	; 1
     ad4:	80 93 21 04 	sts	0x0421, r24
	n = Timer2;
     ad8:	80 91 20 04 	lds	r24, 0x0420
	if (n) Timer2 = --n;
     adc:	88 23       	and	r24, r24
     ade:	19 f0       	breq	.+6      	; 0xae6 <disk_timerproc+0x1c>
     ae0:	81 50       	subi	r24, 0x01	; 1
     ae2:	80 93 20 04 	sts	0x0420, r24

	s = Stat;
     ae6:	80 91 8a 01 	lds	r24, 0x018A

	if (SOCKWP)				/* Write protected */
     aea:	18 9b       	sbis	0x03, 0	; 3
     aec:	02 c0       	rjmp	.+4      	; 0xaf2 <disk_timerproc+0x28>
		s |= STA_PROTECT;
     aee:	84 60       	ori	r24, 0x04	; 4
     af0:	01 c0       	rjmp	.+2      	; 0xaf4 <disk_timerproc+0x2a>
	else					/* Write enabled */
		s &= ~STA_PROTECT;
     af2:	8b 7f       	andi	r24, 0xFB	; 251

	if (SOCKINS)			/* Card inserted */
     af4:	19 99       	sbic	0x03, 1	; 3
     af6:	02 c0       	rjmp	.+4      	; 0xafc <disk_timerproc+0x32>
		s &= ~STA_NODISK;
     af8:	8d 7f       	andi	r24, 0xFD	; 253
     afa:	01 c0       	rjmp	.+2      	; 0xafe <disk_timerproc+0x34>
	else					/* Socket empty */
		s |= (STA_NODISK | STA_NOINIT);
     afc:	83 60       	ori	r24, 0x03	; 3

	Stat = s;				/* Update MMC status */
     afe:	80 93 8a 01 	sts	0x018A, r24
}
     b02:	08 95       	ret

00000b04 <__vector_1>:



//ISR for controlling WEN.
ISR(INT0_vect)
{
     b04:	1f 92       	push	r1
     b06:	0f 92       	push	r0
     b08:	0f b6       	in	r0, 0x3f	; 63
     b0a:	0f 92       	push	r0
     b0c:	11 24       	eor	r1, r1
     b0e:	8f 93       	push	r24
	//printf("ISR INT0 Entered\n");
	if (VSYNC_0_Count==1)//start a frame read
     b10:	80 91 2f 04 	lds	r24, 0x042F
     b14:	81 30       	cpi	r24, 0x01	; 1
     b16:	39 f4       	brne	.+14     	; 0xb26 <__vector_1+0x22>
	{
		FIFO_WEN_0_SET;
     b18:	5e 9a       	sbi	0x0b, 6	; 11
		VSYNC_0_Count++;
     b1a:	80 91 2f 04 	lds	r24, 0x042F
     b1e:	8f 5f       	subi	r24, 0xFF	; 255
     b20:	80 93 2f 04 	sts	0x042F, r24
     b24:	14 c0       	rjmp	.+40     	; 0xb4e <__vector_1+0x4a>
	}
	else if (VSYNC_0_Count==2)//end a frame read
     b26:	80 91 2f 04 	lds	r24, 0x042F
     b2a:	82 30       	cpi	r24, 0x02	; 2
     b2c:	39 f4       	brne	.+14     	; 0xb3c <__vector_1+0x38>
	{
		FIFO_WEN_0_CLR;
     b2e:	5e 98       	cbi	0x0b, 6	; 11
		VSYNC_0_Count++;
     b30:	80 91 2f 04 	lds	r24, 0x042F
     b34:	8f 5f       	subi	r24, 0xFF	; 255
     b36:	80 93 2f 04 	sts	0x042F, r24
     b3a:	09 c0       	rjmp	.+18     	; 0xb4e <__vector_1+0x4a>
	}
	else if(VSYNC_0_Count == 3)
     b3c:	80 91 2f 04 	lds	r24, 0x042F
     b40:	83 30       	cpi	r24, 0x03	; 3
     b42:	11 f4       	brne	.+4      	; 0xb48 <__vector_1+0x44>
	{
		FIFO_WEN_0_CLR;
     b44:	5e 98       	cbi	0x0b, 6	; 11
     b46:	03 c0       	rjmp	.+6      	; 0xb4e <__vector_1+0x4a>
	}
	else
	{
		FIFO_WEN_0_CLR
     b48:	5e 98       	cbi	0x0b, 6	; 11
		VSYNC_0_Count = 0;//wait for a read to be started
     b4a:	10 92 2f 04 	sts	0x042F, r1
	}
}
     b4e:	8f 91       	pop	r24
     b50:	0f 90       	pop	r0
     b52:	0f be       	out	0x3f, r0	; 63
     b54:	0f 90       	pop	r0
     b56:	1f 90       	pop	r1
     b58:	18 95       	reti

00000b5a <__vector_2>:
//ISR for controlling WEN.
ISR(INT1_vect)
{
     b5a:	1f 92       	push	r1
     b5c:	0f 92       	push	r0
     b5e:	0f b6       	in	r0, 0x3f	; 63
     b60:	0f 92       	push	r0
     b62:	11 24       	eor	r1, r1
     b64:	8f 93       	push	r24
	//printf("ISR INT1 Entered\n");
	if (VSYNC_1_Count==1)//start a frame read
     b66:	80 91 70 0c 	lds	r24, 0x0C70
     b6a:	81 30       	cpi	r24, 0x01	; 1
     b6c:	39 f4       	brne	.+14     	; 0xb7c <__vector_2+0x22>
	{
		FIFO_WEN_1_SET;
     b6e:	44 9a       	sbi	0x08, 4	; 8
		VSYNC_1_Count++;
     b70:	80 91 70 0c 	lds	r24, 0x0C70
     b74:	8f 5f       	subi	r24, 0xFF	; 255
     b76:	80 93 70 0c 	sts	0x0C70, r24
     b7a:	14 c0       	rjmp	.+40     	; 0xba4 <__vector_2+0x4a>
	}
	else if (VSYNC_1_Count==2)//end a frame read
     b7c:	80 91 70 0c 	lds	r24, 0x0C70
     b80:	82 30       	cpi	r24, 0x02	; 2
     b82:	39 f4       	brne	.+14     	; 0xb92 <__vector_2+0x38>
	{
		FIFO_WEN_1_CLR;
     b84:	44 98       	cbi	0x08, 4	; 8
		VSYNC_1_Count++;
     b86:	80 91 70 0c 	lds	r24, 0x0C70
     b8a:	8f 5f       	subi	r24, 0xFF	; 255
     b8c:	80 93 70 0c 	sts	0x0C70, r24
     b90:	09 c0       	rjmp	.+18     	; 0xba4 <__vector_2+0x4a>
	}
	else if(VSYNC_1_Count == 3)
     b92:	80 91 70 0c 	lds	r24, 0x0C70
     b96:	83 30       	cpi	r24, 0x03	; 3
     b98:	11 f4       	brne	.+4      	; 0xb9e <__vector_2+0x44>
	{
		FIFO_WEN_1_CLR;
     b9a:	44 98       	cbi	0x08, 4	; 8
     b9c:	03 c0       	rjmp	.+6      	; 0xba4 <__vector_2+0x4a>
	}
	else
	{
		FIFO_WEN_1_CLR
     b9e:	44 98       	cbi	0x08, 4	; 8
		VSYNC_1_Count = 0;//wait for a read to be started
     ba0:	10 92 70 0c 	sts	0x0C70, r1
	}
}
     ba4:	8f 91       	pop	r24
     ba6:	0f 90       	pop	r0
     ba8:	0f be       	out	0x3f, r0	; 63
     baa:	0f 90       	pop	r0
     bac:	1f 90       	pop	r1
     bae:	18 95       	reti

00000bb0 <wrOV7670Reg>:

//Write Register Method
unsigned char wrOV7670Reg(unsigned char regID, unsigned char regDat)
{
     bb0:	cf 93       	push	r28
     bb2:	df 93       	push	r29
     bb4:	00 d0       	rcall	.+0      	; 0xbb6 <wrOV7670Reg+0x6>
     bb6:	00 d0       	rcall	.+0      	; 0xbb8 <wrOV7670Reg+0x8>
     bb8:	cd b7       	in	r28, 0x3d	; 61
     bba:	de b7       	in	r29, 0x3e	; 62
	/*	I2C Traffic Generated:
	 *	S | OV_7670 + W | A | RegID | A | Data | A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE];
	messageBuf[0] = (OV7670_ADDR  <<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consit of General Call code or the TWI slave address.
     bbc:	92 e4       	ldi	r25, 0x42	; 66
     bbe:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for commands.
     bc0:	8a 83       	std	Y+2, r24	; 0x02
	messageBuf[2] = regDat;                        // The second byte is used for the data.
     bc2:	6b 83       	std	Y+3, r22	; 0x03
	TWI_Start_Transceiver_With_Data( messageBuf, 3 );
     bc4:	ce 01       	movw	r24, r28
     bc6:	01 96       	adiw	r24, 0x01	; 1
     bc8:	63 e0       	ldi	r22, 0x03	; 3
     bca:	0e 94 e5 2a 	call	0x55ca	; 0x55ca <TWI_Start_Transceiver_With_Data>
	
	while(TWI_Transceiver_Busy()) ; //Wait for transceiver to clear
     bce:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <TWI_Transceiver_Busy>
     bd2:	88 23       	and	r24, r24
     bd4:	e1 f7       	brne	.-8      	; 0xbce <wrOV7670Reg+0x1e>
	
	return TWI_statusReg.lastTransOK;
     bd6:	80 91 28 04 	lds	r24, 0x0428
}
     bda:	81 70       	andi	r24, 0x01	; 1
     bdc:	0f 90       	pop	r0
     bde:	0f 90       	pop	r0
     be0:	0f 90       	pop	r0
     be2:	0f 90       	pop	r0
     be4:	df 91       	pop	r29
     be6:	cf 91       	pop	r28
     be8:	08 95       	ret

00000bea <rdOV7670Reg>:

//Read Register Method
unsigned char rdOV7670Reg(unsigned char regID, unsigned char *regDat)
{
     bea:	0f 93       	push	r16
     bec:	1f 93       	push	r17
     bee:	cf 93       	push	r28
     bf0:	df 93       	push	r29
     bf2:	00 d0       	rcall	.+0      	; 0xbf4 <rdOV7670Reg+0xa>
     bf4:	00 d0       	rcall	.+0      	; 0xbf6 <rdOV7670Reg+0xc>
     bf6:	cd b7       	in	r28, 0x3d	; 61
     bf8:	de b7       	in	r29, 0x3e	; 62
     bfa:	8b 01       	movw	r16, r22
	 *	S	|	OV_ADDR + W	| A | RegID | A | P |
	 *	S	|	OV_ADDR + R | A | Data	|~A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE]; //Initialise a buffer
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
     bfc:	92 e4       	ldi	r25, 0x42	; 66
     bfe:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for Address Pointer.
     c00:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
     c02:	ce 01       	movw	r24, r28
     c04:	01 96       	adiw	r24, 0x01	; 1
     c06:	62 e0       	ldi	r22, 0x02	; 2
     c08:	0e 94 e5 2a 	call	0x55ca	; 0x55ca <TWI_Start_Transceiver_With_Data>
	
	// Request/collect the data from the Slave
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
     c0c:	83 e4       	ldi	r24, 0x43	; 67
     c0e:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );              
     c10:	ce 01       	movw	r24, r28
     c12:	01 96       	adiw	r24, 0x01	; 1
     c14:	62 e0       	ldi	r22, 0x02	; 2
     c16:	0e 94 e5 2a 	call	0x55ca	; 0x55ca <TWI_Start_Transceiver_With_Data>
    
	// Get the received data from the transceiver buffer
	TWI_Get_Data_From_Transceiver( messageBuf, 2 );
     c1a:	ce 01       	movw	r24, r28
     c1c:	01 96       	adiw	r24, 0x01	; 1
     c1e:	62 e0       	ldi	r22, 0x02	; 2
     c20:	0e 94 1b 2b 	call	0x5636	; 0x5636 <TWI_Get_Data_From_Transceiver>
	*regDat = messageBuf[1];       
     c24:	8a 81       	ldd	r24, Y+2	; 0x02
     c26:	f8 01       	movw	r30, r16
     c28:	80 83       	st	Z, r24
	return TWI_statusReg.lastTransOK;
     c2a:	80 91 28 04 	lds	r24, 0x0428
}
     c2e:	81 70       	andi	r24, 0x01	; 1
     c30:	0f 90       	pop	r0
     c32:	0f 90       	pop	r0
     c34:	0f 90       	pop	r0
     c36:	0f 90       	pop	r0
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	1f 91       	pop	r17
     c3e:	0f 91       	pop	r16
     c40:	08 95       	ret

00000c42 <OV7670_init>:


unsigned char OV7670_init()
{
     c42:	0f 93       	push	r16
     c44:	1f 93       	push	r17
     c46:	cf 93       	push	r28
     c48:	df 93       	push	r29
	uint8_t i = 0;
	if(0==wrOV7670Reg(OV_COM7, 0x80)) //Reset Camera
     c4a:	82 e1       	ldi	r24, 0x12	; 18
     c4c:	60 e8       	ldi	r22, 0x80	; 128
     c4e:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <wrOV7670Reg>
     c52:	88 23       	and	r24, r24
     c54:	f1 f0       	breq	.+60     	; 0xc92 <OV7670_init+0x50>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     c56:	8f e2       	ldi	r24, 0x2F	; 47
     c58:	95 e7       	ldi	r25, 0x75	; 117
     c5a:	01 97       	sbiw	r24, 0x01	; 1
     c5c:	f1 f7       	brne	.-4      	; 0xc5a <OV7670_init+0x18>
     c5e:	00 c0       	rjmp	.+0      	; 0xc60 <OV7670_init+0x1e>
     c60:	00 00       	nop
     c62:	cc e8       	ldi	r28, 0x8C	; 140
     c64:	d1 e0       	ldi	r29, 0x01	; 1
	*regDat = messageBuf[1];       
	return TWI_statusReg.lastTransOK;
}


unsigned char OV7670_init()
     c66:	0a ed       	ldi	r16, 0xDA	; 218
     c68:	12 e0       	ldi	r17, 0x02	; 2
     c6a:	fe 01       	movw	r30, r28
     c6c:	31 97       	sbiw	r30, 0x01	; 1
		return 1;
	}
	_delay_ms(10);
	for(i=0; i<SETTINGS_LENGTH; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
     c6e:	80 81       	ld	r24, Z
     c70:	68 81       	ld	r22, Y
     c72:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <wrOV7670Reg>
     c76:	88 23       	and	r24, r24
     c78:	71 f0       	breq	.+28     	; 0xc96 <OV7670_init+0x54>
     c7a:	87 eb       	ldi	r24, 0xB7	; 183
     c7c:	9b e0       	ldi	r25, 0x0B	; 11
     c7e:	01 97       	sbiw	r24, 0x01	; 1
     c80:	f1 f7       	brne	.-4      	; 0xc7e <OV7670_init+0x3c>
     c82:	00 c0       	rjmp	.+0      	; 0xc84 <OV7670_init+0x42>
     c84:	00 00       	nop
     c86:	22 96       	adiw	r28, 0x02	; 2
	if(0==wrOV7670Reg(OV_COM7, 0x80)) //Reset Camera
	{
		return 1;
	}
	_delay_ms(10);
	for(i=0; i<SETTINGS_LENGTH; i++)
     c88:	c0 17       	cp	r28, r16
     c8a:	d1 07       	cpc	r29, r17
     c8c:	71 f7       	brne	.-36     	; 0xc6a <OV7670_init+0x28>
			return 1;
		}
		_delay_ms(1);
	}
	
	return 0;
     c8e:	80 e0       	ldi	r24, 0x00	; 0
     c90:	03 c0       	rjmp	.+6      	; 0xc98 <OV7670_init+0x56>
unsigned char OV7670_init()
{
	uint8_t i = 0;
	if(0==wrOV7670Reg(OV_COM7, 0x80)) //Reset Camera
	{
		return 1;
     c92:	81 e0       	ldi	r24, 0x01	; 1
     c94:	01 c0       	rjmp	.+2      	; 0xc98 <OV7670_init+0x56>
	_delay_ms(10);
	for(i=0; i<SETTINGS_LENGTH; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
		{
			return 1;
     c96:	81 e0       	ldi	r24, 0x01	; 1
		}
		_delay_ms(1);
	}
	
	return 0;
}
     c98:	df 91       	pop	r29
     c9a:	cf 91       	pop	r28
     c9c:	1f 91       	pop	r17
     c9e:	0f 91       	pop	r16
     ca0:	08 95       	ret

00000ca2 <FIFO_init>:

void FIFO_init( void )
{
	//disable both outputs
	FIFO_nOE_0_SET;
     ca2:	46 9a       	sbi	0x08, 6	; 8
	FIFO_nOE_1_SET;
     ca4:	47 9a       	sbi	0x08, 7	; 8
	//Reset Buffer 0
	FIFO_WRST_0_CLR;
     ca6:	5f 98       	cbi	0x0b, 7	; 11
	FIFO_RCLK_0_CLR;
     ca8:	5c 98       	cbi	0x0b, 4	; 11
	//FIFO_nOE_0_CLR;
	FIFO_nRRST_0_SET;
     caa:	5d 9a       	sbi	0x0b, 5	; 11
	FIFO_WEN_0_CLR;
     cac:	5e 98       	cbi	0x0b, 6	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     cae:	88 e2       	ldi	r24, 0x28	; 40
     cb0:	8a 95       	dec	r24
     cb2:	f1 f7       	brne	.-4      	; 0xcb0 <FIFO_init+0xe>
	_delay_us(10);
	FIFO_RCLK_0_SET;
     cb4:	5c 9a       	sbi	0x0b, 4	; 11
     cb6:	88 e2       	ldi	r24, 0x28	; 40
     cb8:	8a 95       	dec	r24
     cba:	f1 f7       	brne	.-4      	; 0xcb8 <FIFO_init+0x16>
	_delay_us(10);
	FIFO_RCLK_0_CLR;
     cbc:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_0_CLR;
     cbe:	5d 98       	cbi	0x0b, 5	; 11
     cc0:	88 e2       	ldi	r24, 0x28	; 40
     cc2:	8a 95       	dec	r24
     cc4:	f1 f7       	brne	.-4      	; 0xcc2 <FIFO_init+0x20>
	_delay_us(10);
	FIFO_RCLK_0_SET;
     cc6:	5c 9a       	sbi	0x0b, 4	; 11
     cc8:	88 e2       	ldi	r24, 0x28	; 40
     cca:	8a 95       	dec	r24
     ccc:	f1 f7       	brne	.-4      	; 0xcca <FIFO_init+0x28>
	_delay_us(10);
	FIFO_RCLK_0_CLR;
     cce:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_0_SET;
     cd0:	5d 9a       	sbi	0x0b, 5	; 11
     cd2:	88 e2       	ldi	r24, 0x28	; 40
     cd4:	8a 95       	dec	r24
     cd6:	f1 f7       	brne	.-4      	; 0xcd4 <FIFO_init+0x32>
	_delay_us(10);
	FIFO_WRST_0_SET;
     cd8:	5f 9a       	sbi	0x0b, 7	; 11
	
	//Reset Buffer 1
	FIFO_WRST_1_CLR;
     cda:	45 98       	cbi	0x08, 5	; 8
	FIFO_RCLK_1_CLR;
     cdc:	42 98       	cbi	0x08, 2	; 8
	//FIFO_nOE_1_CLR;
	FIFO_nRRST_1_SET;
     cde:	43 9a       	sbi	0x08, 3	; 8
	FIFO_WEN_1_CLR;
     ce0:	44 98       	cbi	0x08, 4	; 8
     ce2:	88 e2       	ldi	r24, 0x28	; 40
     ce4:	8a 95       	dec	r24
     ce6:	f1 f7       	brne	.-4      	; 0xce4 <FIFO_init+0x42>
	_delay_us(10);
	FIFO_RCLK_1_SET;
     ce8:	42 9a       	sbi	0x08, 2	; 8
     cea:	88 e2       	ldi	r24, 0x28	; 40
     cec:	8a 95       	dec	r24
     cee:	f1 f7       	brne	.-4      	; 0xcec <FIFO_init+0x4a>
	_delay_us(10);
	FIFO_RCLK_1_CLR;
     cf0:	42 98       	cbi	0x08, 2	; 8
	FIFO_nRRST_1_CLR;
     cf2:	43 98       	cbi	0x08, 3	; 8
     cf4:	88 e2       	ldi	r24, 0x28	; 40
     cf6:	8a 95       	dec	r24
     cf8:	f1 f7       	brne	.-4      	; 0xcf6 <FIFO_init+0x54>
	_delay_us(10);
	FIFO_RCLK_1_SET;
     cfa:	42 9a       	sbi	0x08, 2	; 8
     cfc:	88 e2       	ldi	r24, 0x28	; 40
     cfe:	8a 95       	dec	r24
     d00:	f1 f7       	brne	.-4      	; 0xcfe <FIFO_init+0x5c>
	_delay_us(10);
	FIFO_RCLK_1_CLR;
     d02:	42 98       	cbi	0x08, 2	; 8
	FIFO_nRRST_1_SET;
     d04:	43 9a       	sbi	0x08, 3	; 8
     d06:	88 e2       	ldi	r24, 0x28	; 40
     d08:	8a 95       	dec	r24
     d0a:	f1 f7       	brne	.-4      	; 0xd08 <FIFO_init+0x66>
	_delay_us(10);
	FIFO_WRST_1_SET;
     d0c:	45 9a       	sbi	0x08, 5	; 8

}
     d0e:	08 95       	ret

00000d10 <FIFO_TO_AVR>:
//Write one pixel in AVR
uint16_t FIFO_TO_AVR(uint8_t ID)
{
	uint16_t data = 0;
	
	DDRA = 0;
     d10:	11 b8       	out	0x01, r1	; 1
	if(ID == 1)
     d12:	81 30       	cpi	r24, 0x01	; 1
     d14:	61 f4       	brne	.+24     	; 0xd2e <FIFO_TO_AVR+0x1e>
	{
		FIFO_RCLK_1_SET;
     d16:	42 9a       	sbi	0x08, 2	; 8
		data = PINA;
     d18:	80 b1       	in	r24, 0x00	; 0
		FIFO_RCLK_1_CLR;
     d1a:	42 98       	cbi	0x08, 2	; 8
		data <<= 8;
     d1c:	38 2f       	mov	r19, r24
     d1e:	20 e0       	ldi	r18, 0x00	; 0
		FIFO_RCLK_1_SET;
     d20:	42 9a       	sbi	0x08, 2	; 8
		data |= PINA;
     d22:	80 b1       	in	r24, 0x00	; 0
     d24:	90 e0       	ldi	r25, 0x00	; 0
     d26:	82 2b       	or	r24, r18
     d28:	93 2b       	or	r25, r19
		FIFO_RCLK_1_CLR;
     d2a:	42 98       	cbi	0x08, 2	; 8
     d2c:	08 95       	ret
	}		
	else
	{	
		FIFO_RCLK_0_SET;
     d2e:	5c 9a       	sbi	0x0b, 4	; 11
		data = PINA;
     d30:	80 b1       	in	r24, 0x00	; 0
		FIFO_RCLK_0_CLR;
     d32:	5c 98       	cbi	0x0b, 4	; 11
		data <<= 8;
     d34:	38 2f       	mov	r19, r24
     d36:	20 e0       	ldi	r18, 0x00	; 0
		FIFO_RCLK_0_SET;
     d38:	5c 9a       	sbi	0x0b, 4	; 11
		data |= PINA;
     d3a:	80 b1       	in	r24, 0x00	; 0
     d3c:	90 e0       	ldi	r25, 0x00	; 0
     d3e:	82 2b       	or	r24, r18
     d40:	93 2b       	or	r25, r19
		FIFO_RCLK_0_CLR;
     d42:	5c 98       	cbi	0x0b, 4	; 11
	}		
	return(data);
}
     d44:	08 95       	ret

00000d46 <FIFO_Reset>:


//Resets both pointers
void FIFO_Reset(uint8_t CameraID)
{
	FIFO_nOE_0_SET;	
     d46:	46 9a       	sbi	0x08, 6	; 8
	FIFO_nOE_1_SET;
     d48:	47 9a       	sbi	0x08, 7	; 8
	if(CameraID == 0)
     d4a:	88 23       	and	r24, r24
     d4c:	39 f4       	brne	.+14     	; 0xd5c <FIFO_Reset+0x16>
	{
		FIFO_WRST_0_CLR;
     d4e:	5f 98       	cbi	0x0b, 7	; 11
		FIFO_nRRST_0_CLR;
     d50:	5d 98       	cbi	0x0b, 5	; 11
		FIFO_RCLK_0_SET;
     d52:	5c 9a       	sbi	0x0b, 4	; 11
		FIFO_RCLK_0_CLR;
     d54:	5c 98       	cbi	0x0b, 4	; 11
		FIFO_nRRST_0_SET;
     d56:	5d 9a       	sbi	0x0b, 5	; 11
		FIFO_WRST_0_SET;
     d58:	5f 9a       	sbi	0x0b, 7	; 11
     d5a:	08 95       	ret
	}
	else
	{
		FIFO_WRST_1_CLR;
     d5c:	45 98       	cbi	0x08, 5	; 8
		FIFO_nRRST_1_CLR;
     d5e:	43 98       	cbi	0x08, 3	; 8
		FIFO_RCLK_1_SET;
     d60:	42 9a       	sbi	0x08, 2	; 8
		FIFO_RCLK_1_CLR;
     d62:	42 98       	cbi	0x08, 2	; 8
		FIFO_nRRST_1_SET;
     d64:	43 9a       	sbi	0x08, 3	; 8
		FIFO_WRST_1_SET;
     d66:	45 9a       	sbi	0x08, 5	; 8
     d68:	08 95       	ret

00000d6a <LoadImagesToBuffer>:
	}
	
}
void LoadImagesToBuffer()
{
	VSYNC_0_Count = 0;
     d6a:	10 92 2f 04 	sts	0x042F, r1
	VSYNC_1_Count = 0;
     d6e:	10 92 70 0c 	sts	0x0C70, r1
	FIFO_Reset(0);
     d72:	80 e0       	ldi	r24, 0x00	; 0
     d74:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
	FIFO_Reset(1);
     d78:	81 e0       	ldi	r24, 0x01	; 1
     d7a:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
	VSYNC_0_Count = 1;
     d7e:	81 e0       	ldi	r24, 0x01	; 1
     d80:	80 93 2f 04 	sts	0x042F, r24
	VSYNC_1_Count = 1;
     d84:	80 93 70 0c 	sts	0x0C70, r24
	
}
     d88:	08 95       	ret

00000d8a <GetImageIfAvailiable>:
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
{
     d8a:	2f 92       	push	r2
     d8c:	3f 92       	push	r3
     d8e:	4f 92       	push	r4
     d90:	5f 92       	push	r5
     d92:	6f 92       	push	r6
     d94:	7f 92       	push	r7
     d96:	8f 92       	push	r8
     d98:	9f 92       	push	r9
     d9a:	af 92       	push	r10
     d9c:	bf 92       	push	r11
     d9e:	cf 92       	push	r12
     da0:	df 92       	push	r13
     da2:	ff 92       	push	r15
     da4:	0f 93       	push	r16
     da6:	1f 93       	push	r17
     da8:	cf 93       	push	r28
     daa:	df 93       	push	r29
     dac:	00 d0       	rcall	.+0      	; 0xdae <GetImageIfAvailiable+0x24>
     dae:	00 d0       	rcall	.+0      	; 0xdb0 <GetImageIfAvailiable+0x26>
     db0:	cd b7       	in	r28, 0x3d	; 61
     db2:	de b7       	in	r29, 0x3e	; 62
     db4:	3c 01       	movw	r6, r24
     db6:	f6 2e       	mov	r15, r22

	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
     db8:	66 23       	and	r22, r22
     dba:	31 f4       	brne	.+12     	; 0xdc8 <GetImageIfAvailiable+0x3e>
     dbc:	80 91 2f 04 	lds	r24, 0x042F
     dc0:	83 30       	cpi	r24, 0x03	; 3
     dc2:	69 f0       	breq	.+26     	; 0xdde <GetImageIfAvailiable+0x54>
		FIFO_nOE_1_SET;
		return 0;
	}
	else
	{
		return 2;
     dc4:	82 e0       	ldi	r24, 0x02	; 2
     dc6:	78 c0       	rjmp	.+240    	; 0xeb8 <GetImageIfAvailiable+0x12e>
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
{

	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
     dc8:	81 e0       	ldi	r24, 0x01	; 1
     dca:	68 17       	cp	r22, r24
     dcc:	09 f0       	breq	.+2      	; 0xdd0 <GetImageIfAvailiable+0x46>
     dce:	73 c0       	rjmp	.+230    	; 0xeb6 <GetImageIfAvailiable+0x12c>
		((CameraID == 1) && (VSYNC_1_Count == 3)) )
     dd0:	80 91 70 0c 	lds	r24, 0x0C70
     dd4:	83 30       	cpi	r24, 0x03	; 3
     dd6:	09 f4       	brne	.+2      	; 0xdda <GetImageIfAvailiable+0x50>
     dd8:	85 c0       	rjmp	.+266    	; 0xee4 <GetImageIfAvailiable+0x15a>
		FIFO_nOE_1_SET;
		return 0;
	}
	else
	{
		return 2;
     dda:	82 e0       	ldi	r24, 0x02	; 2
     ddc:	6d c0       	rjmp	.+218    	; 0xeb8 <GetImageIfAvailiable+0x12e>
	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
		((CameraID == 1) && (VSYNC_1_Count == 3)) )
	{
		
		//Write Bitmap Headers
		WriteBMPHeader(File);
     dde:	c3 01       	movw	r24, r6
     de0:	0e 94 5d 00 	call	0xba	; 0xba <WriteBMPHeader>
		WriteDIBHeader(File);
     de4:	c3 01       	movw	r24, r6
     de6:	0e 94 80 00 	call	0x100	; 0x100 <WriteDIBHeader>
		if (CameraID == 0)
		{
			//Enable output of Camera 0
			FIFO_nOE_0_CLR;
     dea:	46 98       	cbi	0x08, 6	; 8
			//Reset Read Pointer
			FIFO_nRRST_0_CLR;
     dec:	5d 98       	cbi	0x0b, 5	; 11
			FIFO_RCLK_0_SET;
     dee:	5c 9a       	sbi	0x0b, 4	; 11
			FIFO_RCLK_0_CLR;
     df0:	5c 98       	cbi	0x0b, 4	; 11
			FIFO_nRRST_0_SET;
     df2:	5d 9a       	sbi	0x0b, 5	; 11
	VSYNC_0_Count = 1;
	VSYNC_1_Count = 1;
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
{
     df4:	0f 2e       	mov	r0, r31
     df6:	fa e8       	ldi	r31, 0x8A	; 138
     df8:	8f 2e       	mov	r8, r31
     dfa:	f0 e0       	ldi	r31, 0x00	; 0
     dfc:	9f 2e       	mov	r9, r31
     dfe:	f0 e0       	ldi	r31, 0x00	; 0
     e00:	af 2e       	mov	r10, r31
     e02:	f0 e0       	ldi	r31, 0x00	; 0
     e04:	bf 2e       	mov	r11, r31
     e06:	f0 2d       	mov	r31, r0
		uint32_t pointer;
		uint16_t Temp;
		uint32_t p;
		FRESULT fr;
		//for(j = HEIGHT; j>0; j--)
		for(j = 0; j < HEIGHT; j++)
     e08:	0f 2e       	mov	r0, r31
     e0a:	f1 e7       	ldi	r31, 0x71	; 113
     e0c:	4f 2e       	mov	r4, r31
     e0e:	f8 e0       	ldi	r31, 0x08	; 8
     e10:	5f 2e       	mov	r5, r31
     e12:	f0 2d       	mov	r31, r0
	FIFO_Reset(1);
	VSYNC_0_Count = 1;
	VSYNC_1_Count = 1;
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
     e14:	0f 2e       	mov	r0, r31
     e16:	f1 ef       	ldi	r31, 0xF1	; 241
     e18:	cf 2e       	mov	r12, r31
     e1a:	fa e0       	ldi	r31, 0x0A	; 10
     e1c:	df 2e       	mov	r13, r31
     e1e:	f0 2d       	mov	r31, r0
				Buff[pointer++] = (uint8_t)(Temp >> 8);
				Buff[pointer++] = (uint8_t)Temp;
			}
			pointer = (uint32_t)j * (uint32_t)WIDTH * 2 + BMPHEADERSIZE + DIBHEADERSIZE;
			f_lseek(File, pointer);
			fr = f_write(File, Buff, WIDTH * 2, &p);
     e20:	0f 2e       	mov	r0, r31
     e22:	f0 e7       	ldi	r31, 0x70	; 112
     e24:	2f 2e       	mov	r2, r31
     e26:	f8 e0       	ldi	r31, 0x08	; 8
     e28:	3f 2e       	mov	r3, r31
     e2a:	f0 2d       	mov	r31, r0
     e2c:	3b c0       	rjmp	.+118    	; 0xea4 <GetImageIfAvailiable+0x11a>
		for(j = 0; j < HEIGHT; j++)
		{
			pointer = 0;
			for(i = 0; i < WIDTH; i++)
			{
				Temp = FIFO_TO_AVR(CameraID);
     e2e:	8f 2d       	mov	r24, r15
     e30:	0e 94 88 06 	call	0xd10	; 0xd10 <FIFO_TO_AVR>
	FIFO_Reset(1);
	VSYNC_0_Count = 1;
	VSYNC_1_Count = 1;
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
     e34:	f8 01       	movw	r30, r16
     e36:	31 97       	sbiw	r30, 0x01	; 1
			for(i = 0; i < WIDTH; i++)
			{
				Temp = FIFO_TO_AVR(CameraID);
				//USART0_Senduint16(Temp);
				
				Buff[pointer++] = (uint8_t)(Temp >> 8);
     e38:	90 83       	st	Z, r25
				Buff[pointer++] = (uint8_t)Temp;
     e3a:	d8 01       	movw	r26, r16
     e3c:	8c 93       	st	X, r24
     e3e:	0e 5f       	subi	r16, 0xFE	; 254
     e40:	1f 4f       	sbci	r17, 0xFF	; 255
		FRESULT fr;
		//for(j = HEIGHT; j>0; j--)
		for(j = 0; j < HEIGHT; j++)
		{
			pointer = 0;
			for(i = 0; i < WIDTH; i++)
     e42:	0c 15       	cp	r16, r12
     e44:	1d 05       	cpc	r17, r13
     e46:	99 f7       	brne	.-26     	; 0xe2e <GetImageIfAvailiable+0xa4>
				
				Buff[pointer++] = (uint8_t)(Temp >> 8);
				Buff[pointer++] = (uint8_t)Temp;
			}
			pointer = (uint32_t)j * (uint32_t)WIDTH * 2 + BMPHEADERSIZE + DIBHEADERSIZE;
			f_lseek(File, pointer);
     e48:	c3 01       	movw	r24, r6
     e4a:	b5 01       	movw	r22, r10
     e4c:	a4 01       	movw	r20, r8
     e4e:	0e 94 7e 21 	call	0x42fc	; 0x42fc <f_lseek>
			fr = f_write(File, Buff, WIDTH * 2, &p);
     e52:	c3 01       	movw	r24, r6
     e54:	b1 01       	movw	r22, r2
     e56:	20 e8       	ldi	r18, 0x80	; 128
     e58:	32 e0       	ldi	r19, 0x02	; 2
     e5a:	40 e0       	ldi	r20, 0x00	; 0
     e5c:	50 e0       	ldi	r21, 0x00	; 0
     e5e:	8e 01       	movw	r16, r28
     e60:	0f 5f       	subi	r16, 0xFF	; 255
     e62:	1f 4f       	sbci	r17, 0xFF	; 255
     e64:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <f_write>
			if(fr != FR_OK)
     e68:	88 23       	and	r24, r24
     e6a:	59 f0       	breq	.+22     	; 0xe82 <GetImageIfAvailiable+0xf8>
			{
				//printf("Write Fail.\n");
				VSYNC_0_Count = 0;
     e6c:	10 92 2f 04 	sts	0x042F, r1
				VSYNC_1_Count = 0;
     e70:	10 92 70 0c 	sts	0x0C70, r1
				FIFO_Reset(CameraID);
     e74:	8f 2d       	mov	r24, r15
     e76:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
				FIFO_nOE_0_SET;
     e7a:	46 9a       	sbi	0x08, 6	; 8
				FIFO_nOE_1_SET;
     e7c:	47 9a       	sbi	0x08, 7	; 8
				return 1;
     e7e:	81 e0       	ldi	r24, 0x01	; 1
     e80:	1b c0       	rjmp	.+54     	; 0xeb8 <GetImageIfAvailiable+0x12e>
     e82:	80 e8       	ldi	r24, 0x80	; 128
     e84:	92 e0       	ldi	r25, 0x02	; 2
     e86:	a0 e0       	ldi	r26, 0x00	; 0
     e88:	b0 e0       	ldi	r27, 0x00	; 0
     e8a:	88 0e       	add	r8, r24
     e8c:	99 1e       	adc	r9, r25
     e8e:	aa 1e       	adc	r10, r26
     e90:	bb 1e       	adc	r11, r27
		uint32_t pointer;
		uint16_t Temp;
		uint32_t p;
		FRESULT fr;
		//for(j = HEIGHT; j>0; j--)
		for(j = 0; j < HEIGHT; j++)
     e92:	9a e8       	ldi	r25, 0x8A	; 138
     e94:	89 16       	cp	r8, r25
     e96:	98 e5       	ldi	r25, 0x58	; 88
     e98:	99 06       	cpc	r9, r25
     e9a:	92 e0       	ldi	r25, 0x02	; 2
     e9c:	a9 06       	cpc	r10, r25
     e9e:	90 e0       	ldi	r25, 0x00	; 0
     ea0:	b9 06       	cpc	r11, r25
     ea2:	11 f0       	breq	.+4      	; 0xea8 <GetImageIfAvailiable+0x11e>
     ea4:	82 01       	movw	r16, r4
     ea6:	c3 cf       	rjmp	.-122    	; 0xe2e <GetImageIfAvailiable+0xa4>
				FIFO_nOE_0_SET;
				FIFO_nOE_1_SET;
				return 1;
			}
		}
		FIFO_Reset(CameraID);
     ea8:	8f 2d       	mov	r24, r15
     eaa:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
		//fr = f_close(File);
		FIFO_nOE_0_SET;
     eae:	46 9a       	sbi	0x08, 6	; 8
		FIFO_nOE_1_SET;
     eb0:	47 9a       	sbi	0x08, 7	; 8
		return 0;
     eb2:	80 e0       	ldi	r24, 0x00	; 0
     eb4:	01 c0       	rjmp	.+2      	; 0xeb8 <GetImageIfAvailiable+0x12e>
	}
	else
	{
		return 2;
     eb6:	82 e0       	ldi	r24, 0x02	; 2
	}
}
     eb8:	0f 90       	pop	r0
     eba:	0f 90       	pop	r0
     ebc:	0f 90       	pop	r0
     ebe:	0f 90       	pop	r0
     ec0:	df 91       	pop	r29
     ec2:	cf 91       	pop	r28
     ec4:	1f 91       	pop	r17
     ec6:	0f 91       	pop	r16
     ec8:	ff 90       	pop	r15
     eca:	df 90       	pop	r13
     ecc:	cf 90       	pop	r12
     ece:	bf 90       	pop	r11
     ed0:	af 90       	pop	r10
     ed2:	9f 90       	pop	r9
     ed4:	8f 90       	pop	r8
     ed6:	7f 90       	pop	r7
     ed8:	6f 90       	pop	r6
     eda:	5f 90       	pop	r5
     edc:	4f 90       	pop	r4
     ede:	3f 90       	pop	r3
     ee0:	2f 90       	pop	r2
     ee2:	08 95       	ret
	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
		((CameraID == 1) && (VSYNC_1_Count == 3)) )
	{
		
		//Write Bitmap Headers
		WriteBMPHeader(File);
     ee4:	c3 01       	movw	r24, r6
     ee6:	0e 94 5d 00 	call	0xba	; 0xba <WriteBMPHeader>
		WriteDIBHeader(File);
     eea:	c3 01       	movw	r24, r6
     eec:	0e 94 80 00 	call	0x100	; 0x100 <WriteDIBHeader>
			FIFO_nRRST_0_SET;
		}		
		else 
		{
			//Enable output of Camera 0
			FIFO_nOE_1_CLR;
     ef0:	47 98       	cbi	0x08, 7	; 8
			//Reset Read Pointer
			FIFO_nRRST_1_CLR;
     ef2:	43 98       	cbi	0x08, 3	; 8
			FIFO_RCLK_1_SET;
     ef4:	42 9a       	sbi	0x08, 2	; 8
			FIFO_RCLK_1_CLR;
     ef6:	42 98       	cbi	0x08, 2	; 8
			FIFO_nRRST_1_SET;
     ef8:	43 9a       	sbi	0x08, 3	; 8
     efa:	7c cf       	rjmp	.-264    	; 0xdf4 <GetImageIfAvailiable+0x6a>

00000efc <SCCB_wrOV7670Reg>:
		return 2;
	}
}

unsigned char SCCB_wrOV7670Reg(unsigned char regID, unsigned char regDat)
{
     efc:	cf 93       	push	r28
     efe:	df 93       	push	r29
     f00:	c8 2f       	mov	r28, r24
     f02:	d6 2f       	mov	r29, r22
	startSCCB();
     f04:	0e 94 14 2a 	call	0x5428	; 0x5428 <startSCCB>
	if(0==SCCBwriteByte(0x42))
     f08:	82 e4       	ldi	r24, 0x42	; 66
     f0a:	0e 94 64 2a 	call	0x54c8	; 0x54c8 <SCCBwriteByte>
     f0e:	88 23       	and	r24, r24
     f10:	21 f4       	brne	.+8      	; 0xf1a <SCCB_wrOV7670Reg+0x1e>
	{
		stopSCCB();
     f12:	0e 94 31 2a 	call	0x5462	; 0x5462 <stopSCCB>
		return(0);
     f16:	80 e0       	ldi	r24, 0x00	; 0
     f18:	21 c0       	rjmp	.+66     	; 0xf5c <SCCB_wrOV7670Reg+0x60>
     f1a:	8b e2       	ldi	r24, 0x2B	; 43
     f1c:	91 e0       	ldi	r25, 0x01	; 1
     f1e:	01 97       	sbiw	r24, 0x01	; 1
     f20:	f1 f7       	brne	.-4      	; 0xf1e <SCCB_wrOV7670Reg+0x22>
     f22:	00 c0       	rjmp	.+0      	; 0xf24 <SCCB_wrOV7670Reg+0x28>
     f24:	00 00       	nop
	}
	_delay_us(100);
	if(0==SCCBwriteByte(regID))
     f26:	8c 2f       	mov	r24, r28
     f28:	0e 94 64 2a 	call	0x54c8	; 0x54c8 <SCCBwriteByte>
     f2c:	88 23       	and	r24, r24
     f2e:	21 f4       	brne	.+8      	; 0xf38 <SCCB_wrOV7670Reg+0x3c>
	{
		stopSCCB();
     f30:	0e 94 31 2a 	call	0x5462	; 0x5462 <stopSCCB>
		return(0);
     f34:	80 e0       	ldi	r24, 0x00	; 0
     f36:	12 c0       	rjmp	.+36     	; 0xf5c <SCCB_wrOV7670Reg+0x60>
     f38:	8b e2       	ldi	r24, 0x2B	; 43
     f3a:	91 e0       	ldi	r25, 0x01	; 1
     f3c:	01 97       	sbiw	r24, 0x01	; 1
     f3e:	f1 f7       	brne	.-4      	; 0xf3c <SCCB_wrOV7670Reg+0x40>
     f40:	00 c0       	rjmp	.+0      	; 0xf42 <SCCB_wrOV7670Reg+0x46>
     f42:	00 00       	nop
	}
	_delay_us(100);
	if(0==SCCBwriteByte(regDat))
     f44:	8d 2f       	mov	r24, r29
     f46:	0e 94 64 2a 	call	0x54c8	; 0x54c8 <SCCBwriteByte>
     f4a:	88 23       	and	r24, r24
     f4c:	21 f4       	brne	.+8      	; 0xf56 <SCCB_wrOV7670Reg+0x5a>
	{
		stopSCCB();
     f4e:	0e 94 31 2a 	call	0x5462	; 0x5462 <stopSCCB>
		return(0);
     f52:	80 e0       	ldi	r24, 0x00	; 0
     f54:	03 c0       	rjmp	.+6      	; 0xf5c <SCCB_wrOV7670Reg+0x60>
	}
	stopSCCB();
     f56:	0e 94 31 2a 	call	0x5462	; 0x5462 <stopSCCB>
	
	return(1);
     f5a:	81 e0       	ldi	r24, 0x01	; 1
}
     f5c:	df 91       	pop	r29
     f5e:	cf 91       	pop	r28
     f60:	08 95       	ret

00000f62 <SCCB_rdOV7670Reg>:

//Read the OV7670 Registers

unsigned char SCCB_rdOV7670Reg(unsigned regID, unsigned char *regDat)
{
     f62:	1f 93       	push	r17
     f64:	cf 93       	push	r28
     f66:	df 93       	push	r29
     f68:	18 2f       	mov	r17, r24
     f6a:	eb 01       	movw	r28, r22
	//Using write operate to set the Register Address
	startSCCB();
     f6c:	0e 94 14 2a 	call	0x5428	; 0x5428 <startSCCB>
	if(0==SCCBwriteByte(0x42))
     f70:	82 e4       	ldi	r24, 0x42	; 66
     f72:	0e 94 64 2a 	call	0x54c8	; 0x54c8 <SCCBwriteByte>
     f76:	88 23       	and	r24, r24
     f78:	21 f4       	brne	.+8      	; 0xf82 <SCCB_rdOV7670Reg+0x20>
	{
		stopSCCB();
     f7a:	0e 94 31 2a 	call	0x5462	; 0x5462 <stopSCCB>
		return(0);
     f7e:	80 e0       	ldi	r24, 0x00	; 0
     f80:	30 c0       	rjmp	.+96     	; 0xfe2 <SCCB_rdOV7670Reg+0x80>
     f82:	8b e2       	ldi	r24, 0x2B	; 43
     f84:	91 e0       	ldi	r25, 0x01	; 1
     f86:	01 97       	sbiw	r24, 0x01	; 1
     f88:	f1 f7       	brne	.-4      	; 0xf86 <SCCB_rdOV7670Reg+0x24>
     f8a:	00 c0       	rjmp	.+0      	; 0xf8c <SCCB_rdOV7670Reg+0x2a>
     f8c:	00 00       	nop
	}
	_delay_us(100);
	if(0==SCCBwriteByte(regID))
     f8e:	81 2f       	mov	r24, r17
     f90:	0e 94 64 2a 	call	0x54c8	; 0x54c8 <SCCBwriteByte>
     f94:	88 23       	and	r24, r24
     f96:	21 f4       	brne	.+8      	; 0xfa0 <SCCB_rdOV7670Reg+0x3e>
	{
		stopSCCB();
     f98:	0e 94 31 2a 	call	0x5462	; 0x5462 <stopSCCB>
		return(0);
     f9c:	80 e0       	ldi	r24, 0x00	; 0
     f9e:	21 c0       	rjmp	.+66     	; 0xfe2 <SCCB_rdOV7670Reg+0x80>
	}
	stopSCCB();
     fa0:	0e 94 31 2a 	call	0x5462	; 0x5462 <stopSCCB>
     fa4:	8b e2       	ldi	r24, 0x2B	; 43
     fa6:	91 e0       	ldi	r25, 0x01	; 1
     fa8:	01 97       	sbiw	r24, 0x01	; 1
     faa:	f1 f7       	brne	.-4      	; 0xfa8 <SCCB_rdOV7670Reg+0x46>
     fac:	00 c0       	rjmp	.+0      	; 0xfae <SCCB_rdOV7670Reg+0x4c>
     fae:	00 00       	nop
	
	_delay_us(100);
	
	//Begin to read
	startSCCB();
     fb0:	0e 94 14 2a 	call	0x5428	; 0x5428 <startSCCB>
	if(0==SCCBwriteByte(0x43))
     fb4:	83 e4       	ldi	r24, 0x43	; 67
     fb6:	0e 94 64 2a 	call	0x54c8	; 0x54c8 <SCCBwriteByte>
     fba:	88 23       	and	r24, r24
     fbc:	21 f4       	brne	.+8      	; 0xfc6 <SCCB_rdOV7670Reg+0x64>
	{
		stopSCCB();
     fbe:	0e 94 31 2a 	call	0x5462	; 0x5462 <stopSCCB>
		return(0);
     fc2:	80 e0       	ldi	r24, 0x00	; 0
     fc4:	0e c0       	rjmp	.+28     	; 0xfe2 <SCCB_rdOV7670Reg+0x80>
     fc6:	8b e2       	ldi	r24, 0x2B	; 43
     fc8:	91 e0       	ldi	r25, 0x01	; 1
     fca:	01 97       	sbiw	r24, 0x01	; 1
     fcc:	f1 f7       	brne	.-4      	; 0xfca <SCCB_rdOV7670Reg+0x68>
     fce:	00 c0       	rjmp	.+0      	; 0xfd0 <SCCB_rdOV7670Reg+0x6e>
     fd0:	00 00       	nop
	}
	_delay_us(100);
	*regDat=SCCBreadByte();
     fd2:	0e 94 ad 2a 	call	0x555a	; 0x555a <SCCBreadByte>
     fd6:	88 83       	st	Y, r24
	noAck();
     fd8:	0e 94 47 2a 	call	0x548e	; 0x548e <noAck>
	stopSCCB();
     fdc:	0e 94 31 2a 	call	0x5462	; 0x5462 <stopSCCB>
	return(1);
     fe0:	81 e0       	ldi	r24, 0x01	; 1
}
     fe2:	df 91       	pop	r29
     fe4:	cf 91       	pop	r28
     fe6:	1f 91       	pop	r17
     fe8:	08 95       	ret

00000fea <OV7670_SCCB_init>:



// Initial OV7670
unsigned char OV7670_SCCB_init(void)
{
     fea:	0f 93       	push	r16
     fec:	1f 93       	push	r17
     fee:	cf 93       	push	r28
     ff0:	df 93       	push	r29
	unsigned char temp;
	
	unsigned int i=0;

	
	InitSCCB();
     ff2:	0e 94 0d 2a 	call	0x541a	; 0x541a <InitSCCB>

	temp=0x80;
	if(0==SCCB_wrOV7670Reg(0x12, temp)) //Reset SCCB
     ff6:	82 e1       	ldi	r24, 0x12	; 18
     ff8:	60 e8       	ldi	r22, 0x80	; 128
     ffa:	0e 94 7e 07 	call	0xefc	; 0xefc <SCCB_wrOV7670Reg>
     ffe:	88 23       	and	r24, r24
    1000:	c1 f0       	breq	.+48     	; 0x1032 <OV7670_SCCB_init+0x48>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1002:	8f e2       	ldi	r24, 0x2F	; 47
    1004:	95 e7       	ldi	r25, 0x75	; 117
    1006:	01 97       	sbiw	r24, 0x01	; 1
    1008:	f1 f7       	brne	.-4      	; 0x1006 <OV7670_SCCB_init+0x1c>
    100a:	00 c0       	rjmp	.+0      	; 0x100c <OV7670_SCCB_init+0x22>
    100c:	00 00       	nop
    100e:	cc e8       	ldi	r28, 0x8C	; 140
    1010:	d1 e0       	ldi	r29, 0x01	; 1




// Initial OV7670
unsigned char OV7670_SCCB_init(void)
    1012:	0a ed       	ldi	r16, 0xDA	; 218
    1014:	12 e0       	ldi	r17, 0x02	; 2
    1016:	fe 01       	movw	r30, r28
    1018:	31 97       	sbiw	r30, 0x01	; 1
	}
	_delay_ms(10);

	for(i=0;i<SETTINGS_LENGTH;i++)
	{
		if( 0==SCCB_wrOV7670Reg(default_settings[i][0],default_settings[i][1] ))
    101a:	80 81       	ld	r24, Z
    101c:	68 81       	ld	r22, Y
    101e:	0e 94 7e 07 	call	0xefc	; 0xefc <SCCB_wrOV7670Reg>
    1022:	88 23       	and	r24, r24
    1024:	41 f0       	breq	.+16     	; 0x1036 <OV7670_SCCB_init+0x4c>
    1026:	22 96       	adiw	r28, 0x02	; 2
	{
		return 1 ;
	}
	_delay_ms(10);

	for(i=0;i<SETTINGS_LENGTH;i++)
    1028:	c0 17       	cp	r28, r16
    102a:	d1 07       	cpc	r29, r17
    102c:	a1 f7       	brne	.-24     	; 0x1016 <OV7670_SCCB_init+0x2c>
		{
			return 2;
		}
	}

	return 0; //ok
    102e:	80 e0       	ldi	r24, 0x00	; 0
    1030:	03 c0       	rjmp	.+6      	; 0x1038 <OV7670_SCCB_init+0x4e>
	InitSCCB();

	temp=0x80;
	if(0==SCCB_wrOV7670Reg(0x12, temp)) //Reset SCCB
	{
		return 1 ;
    1032:	81 e0       	ldi	r24, 0x01	; 1
    1034:	01 c0       	rjmp	.+2      	; 0x1038 <OV7670_SCCB_init+0x4e>

	for(i=0;i<SETTINGS_LENGTH;i++)
	{
		if( 0==SCCB_wrOV7670Reg(default_settings[i][0],default_settings[i][1] ))
		{
			return 2;
    1036:	82 e0       	ldi	r24, 0x02	; 2
	}

	return 0; //ok

	
    1038:	df 91       	pop	r29
    103a:	cf 91       	pop	r28
    103c:	1f 91       	pop	r17
    103e:	0f 91       	pop	r16
    1040:	08 95       	ret

00001042 <UI_LEDs>:
#define STATUS_Exit_Bad		0x80

#define Button_Capture		0
#define Button_Exit			3
unsigned char UI_LEDs(uint8_t LED)
{
    1042:	cf 93       	push	r28
    1044:	df 93       	push	r29
    1046:	00 d0       	rcall	.+0      	; 0x1048 <UI_LEDs+0x6>
    1048:	00 d0       	rcall	.+0      	; 0x104a <UI_LEDs+0x8>
    104a:	cd b7       	in	r28, 0x3d	; 61
    104c:	de b7       	in	r29, 0x3e	; 62
	unsigned char mesbuf[TWI_BUFFER_SIZE];
	mesbuf[0] = (0x15 << TWI_ADR_BITS) | (FALSE << TWI_READ_BIT);
    104e:	9a e2       	ldi	r25, 0x2A	; 42
    1050:	99 83       	std	Y+1, r25	; 0x01
	mesbuf[1] = 0x10;
    1052:	90 e1       	ldi	r25, 0x10	; 16
    1054:	9a 83       	std	Y+2, r25	; 0x02
	mesbuf[2] = LED;
    1056:	8b 83       	std	Y+3, r24	; 0x03
	TWI_Start_Transceiver_With_Data(mesbuf, 3);
    1058:	ce 01       	movw	r24, r28
    105a:	01 96       	adiw	r24, 0x01	; 1
    105c:	63 e0       	ldi	r22, 0x03	; 3
    105e:	0e 94 e5 2a 	call	0x55ca	; 0x55ca <TWI_Start_Transceiver_With_Data>
	while(TWI_Transceiver_Busy())	;
    1062:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <TWI_Transceiver_Busy>
    1066:	88 23       	and	r24, r24
    1068:	e1 f7       	brne	.-8      	; 0x1062 <UI_LEDs+0x20>
	return TWI_statusReg.lastTransOK;
    106a:	80 91 28 04 	lds	r24, 0x0428
}
    106e:	81 70       	andi	r24, 0x01	; 1
    1070:	0f 90       	pop	r0
    1072:	0f 90       	pop	r0
    1074:	0f 90       	pop	r0
    1076:	0f 90       	pop	r0
    1078:	df 91       	pop	r29
    107a:	cf 91       	pop	r28
    107c:	08 95       	ret

0000107e <UI_Buttons>:
unsigned char UI_Buttons()
{
    107e:	cf 93       	push	r28
    1080:	df 93       	push	r29
    1082:	00 d0       	rcall	.+0      	; 0x1084 <UI_Buttons+0x6>
    1084:	00 d0       	rcall	.+0      	; 0x1086 <UI_Buttons+0x8>
    1086:	cd b7       	in	r28, 0x3d	; 61
    1088:	de b7       	in	r29, 0x3e	; 62
	unsigned char messageBuf[TWI_BUFFER_SIZE]; //Initialise a buffer
	messageBuf[0] = (0x15<<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
    108a:	8a e2       	ldi	r24, 0x2A	; 42
    108c:	89 83       	std	Y+1, r24	; 0x01
	messageBuf[1] = 0x20;             // The first byte is used for the command
    108e:	80 e2       	ldi	r24, 0x20	; 32
    1090:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
    1092:	ce 01       	movw	r24, r28
    1094:	01 96       	adiw	r24, 0x01	; 1
    1096:	62 e0       	ldi	r22, 0x02	; 2
    1098:	0e 94 e5 2a 	call	0x55ca	; 0x55ca <TWI_Start_Transceiver_With_Data>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    109c:	8d ee       	ldi	r24, 0xED	; 237
    109e:	92 e0       	ldi	r25, 0x02	; 2
    10a0:	01 97       	sbiw	r24, 0x01	; 1
    10a2:	f1 f7       	brne	.-4      	; 0x10a0 <UI_Buttons+0x22>
    10a4:	00 c0       	rjmp	.+0      	; 0x10a6 <UI_Buttons+0x28>
    10a6:	00 00       	nop
	_delay_us(250);
	// Request/collect the data from the Slave
	messageBuf[0] = (0x15<<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
    10a8:	8b e2       	ldi	r24, 0x2B	; 43
    10aa:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
    10ac:	ce 01       	movw	r24, r28
    10ae:	01 96       	adiw	r24, 0x01	; 1
    10b0:	62 e0       	ldi	r22, 0x02	; 2
    10b2:	0e 94 e5 2a 	call	0x55ca	; 0x55ca <TWI_Start_Transceiver_With_Data>
	
	// Get the received data from the transceiver buffer
	TWI_Get_Data_From_Transceiver( messageBuf, 2 );
    10b6:	ce 01       	movw	r24, r28
    10b8:	01 96       	adiw	r24, 0x01	; 1
    10ba:	62 e0       	ldi	r22, 0x02	; 2
    10bc:	0e 94 1b 2b 	call	0x5636	; 0x5636 <TWI_Get_Data_From_Transceiver>
	return messageBuf[1];
}
    10c0:	8a 81       	ldd	r24, Y+2	; 0x02
    10c2:	0f 90       	pop	r0
    10c4:	0f 90       	pop	r0
    10c6:	0f 90       	pop	r0
    10c8:	0f 90       	pop	r0
    10ca:	df 91       	pop	r29
    10cc:	cf 91       	pop	r28
    10ce:	08 95       	ret

000010d0 <__vector_16>:
ISR(TIMER0_COMPA_vect)
{
    10d0:	1f 92       	push	r1
    10d2:	0f 92       	push	r0
    10d4:	0f b6       	in	r0, 0x3f	; 63
    10d6:	0f 92       	push	r0
    10d8:	11 24       	eor	r1, r1
    10da:	2f 93       	push	r18
    10dc:	3f 93       	push	r19
    10de:	4f 93       	push	r20
    10e0:	5f 93       	push	r21
    10e2:	6f 93       	push	r22
    10e4:	7f 93       	push	r23
    10e6:	8f 93       	push	r24
    10e8:	9f 93       	push	r25
    10ea:	af 93       	push	r26
    10ec:	bf 93       	push	r27
    10ee:	ef 93       	push	r30
    10f0:	ff 93       	push	r31
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
    10f2:	0e 94 65 05 	call	0xaca	; 0xaca <disk_timerproc>
// 	if(!TWI_statusReg.lastTransOK) //if the last TWI transmission failed, reset the protocol
// 		TWI_Start_Transceiver();
// 	if(!TWI_Transceiver_Busy())
// 		UI_LEDs(StatusReg);
}
    10f6:	ff 91       	pop	r31
    10f8:	ef 91       	pop	r30
    10fa:	bf 91       	pop	r27
    10fc:	af 91       	pop	r26
    10fe:	9f 91       	pop	r25
    1100:	8f 91       	pop	r24
    1102:	7f 91       	pop	r23
    1104:	6f 91       	pop	r22
    1106:	5f 91       	pop	r21
    1108:	4f 91       	pop	r20
    110a:	3f 91       	pop	r19
    110c:	2f 91       	pop	r18
    110e:	0f 90       	pop	r0
    1110:	0f be       	out	0x3f, r0	; 63
    1112:	0f 90       	pop	r0
    1114:	1f 90       	pop	r1
    1116:	18 95       	reti

00001118 <main>:
int main(void)
{
    1118:	2f 92       	push	r2
    111a:	3f 92       	push	r3
    111c:	4f 92       	push	r4
    111e:	5f 92       	push	r5
    1120:	6f 92       	push	r6
    1122:	7f 92       	push	r7
    1124:	8f 92       	push	r8
    1126:	9f 92       	push	r9
    1128:	af 92       	push	r10
    112a:	bf 92       	push	r11
    112c:	df 92       	push	r13
    112e:	ef 92       	push	r14
    1130:	ff 92       	push	r15
    1132:	0f 93       	push	r16
    1134:	1f 93       	push	r17
    1136:	cf 93       	push	r28
    1138:	df 93       	push	r29
    113a:	00 d0       	rcall	.+0      	; 0x113c <main+0x24>
    113c:	00 d0       	rcall	.+0      	; 0x113e <main+0x26>
    113e:	cd b7       	in	r28, 0x3d	; 61
    1140:	de b7       	in	r29, 0x3e	; 62
	unsigned long int a = 0;
    1142:	19 82       	std	Y+1, r1	; 0x01
    1144:	1a 82       	std	Y+2, r1	; 0x02
    1146:	1b 82       	std	Y+3, r1	; 0x03
    1148:	1c 82       	std	Y+4, r1	; 0x04
	uint8_t b = 0;
	FRESULT fr;
	
	TWI_Master_Initialise();
    114a:	0e 94 d0 2a 	call	0x55a0	; 0x55a0 <TWI_Master_Initialise>
	IO_Init();
    114e:	0e 94 a4 00 	call	0x148	; 0x148 <IO_Init>
	sei();
    1152:	78 94       	sei

	StatusReg = STATUS_OKAY;
    1154:	81 e0       	ldi	r24, 0x01	; 1
    1156:	80 93 b9 0e 	sts	0x0EB9, r24
	UI_LEDs(StatusReg);
    115a:	0e 94 21 08 	call	0x1042	; 0x1042 <UI_LEDs>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    115e:	8f e2       	ldi	r24, 0x2F	; 47
    1160:	95 e7       	ldi	r25, 0x75	; 117
    1162:	01 97       	sbiw	r24, 0x01	; 1
    1164:	f1 f7       	brne	.-4      	; 0x1162 <main+0x4a>
    1166:	00 c0       	rjmp	.+0      	; 0x1168 <main+0x50>
    1168:	00 00       	nop
	_delay_ms(10);
	UI_Buttons();
    116a:	0e 94 3f 08 	call	0x107e	; 0x107e <UI_Buttons>

	fr = f_mount(0, &Fatfs[0]);
    116e:	80 e0       	ldi	r24, 0x00	; 0
    1170:	61 e7       	ldi	r22, 0x71	; 113
    1172:	7c e0       	ldi	r23, 0x0C	; 12
    1174:	0e 94 ed 1a 	call	0x35da	; 0x35da <f_mount>
	if(fr != FR_OK)
    1178:	88 23       	and	r24, r24
    117a:	49 f0       	breq	.+18     	; 0x118e <main+0x76>
	{
		StatusReg |= (STATUS_Exit_Bad);
    117c:	80 91 b9 0e 	lds	r24, 0x0EB9
    1180:	80 68       	ori	r24, 0x80	; 128
		StatusReg &= ~(STATUS_OKAY);
    1182:	8e 7f       	andi	r24, 0xFE	; 254
    1184:	80 93 b9 0e 	sts	0x0EB9, r24
		UI_LEDs(StatusReg);
    1188:	0e 94 21 08 	call	0x1042	; 0x1042 <UI_LEDs>
		return 0;
    118c:	02 c2       	rjmp	.+1028   	; 0x1592 <main+0x47a>
	}
	else
		StatusReg |= STATUS_SDOkay;
    118e:	80 91 b9 0e 	lds	r24, 0x0EB9
    1192:	82 60       	ori	r24, 0x02	; 2
    1194:	80 93 b9 0e 	sts	0x0EB9, r24
	UI_LEDs(StatusReg);
    1198:	0e 94 21 08 	call	0x1042	; 0x1042 <UI_LEDs>
	
	fr = f_open(&Files[0], "/log.txt", FA_WRITE|FA_CREATE_ALWAYS);
    119c:	80 e3       	ldi	r24, 0x30	; 48
    119e:	94 e0       	ldi	r25, 0x04	; 4
    11a0:	69 ed       	ldi	r22, 0xD9	; 217
    11a2:	72 e0       	ldi	r23, 0x02	; 2
    11a4:	4a e0       	ldi	r20, 0x0A	; 10
    11a6:	0e 94 03 1b 	call	0x3606	; 0x3606 <f_open>
	if(fr != FR_OK)
    11aa:	88 23       	and	r24, r24
    11ac:	49 f0       	breq	.+18     	; 0x11c0 <main+0xa8>
	{
		StatusReg |= (STATUS_Exit_Bad);
    11ae:	80 91 b9 0e 	lds	r24, 0x0EB9
    11b2:	80 68       	ori	r24, 0x80	; 128
		StatusReg &= ~(1<<STATUS_SDOkay) | (1<<STATUS_OKAY);
    11b4:	8b 7f       	andi	r24, 0xFB	; 251
    11b6:	80 93 b9 0e 	sts	0x0EB9, r24
		UI_LEDs(StatusReg);
    11ba:	0e 94 21 08 	call	0x1042	; 0x1042 <UI_LEDs>
		return 0;
    11be:	e9 c1       	rjmp	.+978    	; 0x1592 <main+0x47a>
	}		
	UI_LEDs(StatusReg);
    11c0:	80 91 b9 0e 	lds	r24, 0x0EB9
    11c4:	0e 94 21 08 	call	0x1042	; 0x1042 <UI_LEDs>
	
	f_close(&Files[0]);
    11c8:	00 e3       	ldi	r16, 0x30	; 48
    11ca:	14 e0       	ldi	r17, 0x04	; 4
    11cc:	c8 01       	movw	r24, r16
    11ce:	0e 94 12 21 	call	0x4224	; 0x4224 <f_close>
	f_open(&Files[0], "/log.txt", FA_WRITE);
    11d2:	c8 01       	movw	r24, r16
    11d4:	69 ed       	ldi	r22, 0xD9	; 217
    11d6:	72 e0       	ldi	r23, 0x02	; 2
    11d8:	42 e0       	ldi	r20, 0x02	; 2
    11da:	0e 94 03 1b 	call	0x3606	; 0x3606 <f_open>
	//stdout = &mystdout;
	b = MCUSR;
    11de:	84 b7       	in	r24, 0x34	; 52
	MCUSR = 0;
    11e0:	14 be       	out	0x34, r1	; 52
	f_write(&Files[0],"Il Matto Dual Camera\n", sizeof("Il Matto Dual Camera\n"), &a);
    11e2:	c8 01       	movw	r24, r16
    11e4:	62 ee       	ldi	r22, 0xE2	; 226
    11e6:	72 e0       	ldi	r23, 0x02	; 2
    11e8:	26 e1       	ldi	r18, 0x16	; 22
    11ea:	30 e0       	ldi	r19, 0x00	; 0
    11ec:	40 e0       	ldi	r20, 0x00	; 0
    11ee:	50 e0       	ldi	r21, 0x00	; 0
    11f0:	8e 01       	movw	r16, r28
    11f2:	0f 5f       	subi	r16, 0xFF	; 255
    11f4:	1f 4f       	sbci	r17, 0xFF	; 255
    11f6:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <f_write>

	/*f_write(&Files[0], "System Startup Complete.\n", 26, &a);*/
	

	b = OV7670_init();
    11fa:	0e 94 21 06 	call	0xc42	; 0xc42 <OV7670_init>
    11fe:	08 2f       	mov	r16, r24
	if(b == 0)
    1200:	88 23       	and	r24, r24
    1202:	29 f4       	brne	.+10     	; 0x120e <main+0xf6>
		StatusReg |= STATUS_CAM1Okay;
    1204:	80 91 b9 0e 	lds	r24, 0x0EB9
    1208:	88 60       	ori	r24, 0x08	; 8
    120a:	80 93 b9 0e 	sts	0x0EB9, r24
		
	UI_LEDs(StatusReg);
    120e:	80 91 b9 0e 	lds	r24, 0x0EB9
    1212:	0e 94 21 08 	call	0x1042	; 0x1042 <UI_LEDs>
	sprintf(Buff, "OV7670_1 Initialise result : %d\n", b);
    1216:	00 d0       	rcall	.+0      	; 0x1218 <main+0x100>
    1218:	00 d0       	rcall	.+0      	; 0x121a <main+0x102>
    121a:	00 d0       	rcall	.+0      	; 0x121c <main+0x104>
    121c:	ed b7       	in	r30, 0x3d	; 61
    121e:	fe b7       	in	r31, 0x3e	; 62
    1220:	31 96       	adiw	r30, 0x01	; 1
    1222:	0f 2e       	mov	r0, r31
    1224:	f0 e7       	ldi	r31, 0x70	; 112
    1226:	ef 2e       	mov	r14, r31
    1228:	f8 e0       	ldi	r31, 0x08	; 8
    122a:	ff 2e       	mov	r15, r31
    122c:	f0 2d       	mov	r31, r0
    122e:	ad b7       	in	r26, 0x3d	; 61
    1230:	be b7       	in	r27, 0x3e	; 62
    1232:	12 96       	adiw	r26, 0x02	; 2
    1234:	fc 92       	st	X, r15
    1236:	ee 92       	st	-X, r14
    1238:	11 97       	sbiw	r26, 0x01	; 1
    123a:	88 ef       	ldi	r24, 0xF8	; 248
    123c:	92 e0       	ldi	r25, 0x02	; 2
    123e:	93 83       	std	Z+3, r25	; 0x03
    1240:	82 83       	std	Z+2, r24	; 0x02
    1242:	04 83       	std	Z+4, r16	; 0x04
    1244:	15 82       	std	Z+5, r1	; 0x05
    1246:	0e 94 71 2c 	call	0x58e2	; 0x58e2 <sprintf>
	f_write(&Files[0], &Buff, 33, &a);
    124a:	8d b7       	in	r24, 0x3d	; 61
    124c:	9e b7       	in	r25, 0x3e	; 62
    124e:	06 96       	adiw	r24, 0x06	; 6
    1250:	0f b6       	in	r0, 0x3f	; 63
    1252:	f8 94       	cli
    1254:	9e bf       	out	0x3e, r25	; 62
    1256:	0f be       	out	0x3f, r0	; 63
    1258:	8d bf       	out	0x3d, r24	; 61
    125a:	80 e3       	ldi	r24, 0x30	; 48
    125c:	94 e0       	ldi	r25, 0x04	; 4
    125e:	b7 01       	movw	r22, r14
    1260:	21 e2       	ldi	r18, 0x21	; 33
    1262:	30 e0       	ldi	r19, 0x00	; 0
    1264:	40 e0       	ldi	r20, 0x00	; 0
    1266:	50 e0       	ldi	r21, 0x00	; 0
    1268:	8e 01       	movw	r16, r28
    126a:	0f 5f       	subi	r16, 0xFF	; 255
    126c:	1f 4f       	sbci	r17, 0xFF	; 255
    126e:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <f_write>
	
	InitSCCB();
    1272:	0e 94 0d 2a 	call	0x541a	; 0x541a <InitSCCB>
	b = OV7670_SCCB_init();
    1276:	0e 94 f5 07 	call	0xfea	; 0xfea <OV7670_SCCB_init>
    127a:	08 2f       	mov	r16, r24
	if(b == 0)
    127c:	88 23       	and	r24, r24
    127e:	29 f4       	brne	.+10     	; 0x128a <main+0x172>
		StatusReg |= STATUS_CAM0Okay;
    1280:	80 91 b9 0e 	lds	r24, 0x0EB9
    1284:	84 60       	ori	r24, 0x04	; 4
    1286:	80 93 b9 0e 	sts	0x0EB9, r24
	UI_LEDs(StatusReg);
    128a:	80 91 b9 0e 	lds	r24, 0x0EB9
    128e:	0e 94 21 08 	call	0x1042	; 0x1042 <UI_LEDs>
	
	sprintf(Buff, "OV7670_0 Initialise result : %d\n", b);
    1292:	00 d0       	rcall	.+0      	; 0x1294 <main+0x17c>
    1294:	00 d0       	rcall	.+0      	; 0x1296 <main+0x17e>
    1296:	00 d0       	rcall	.+0      	; 0x1298 <main+0x180>
    1298:	ed b7       	in	r30, 0x3d	; 61
    129a:	fe b7       	in	r31, 0x3e	; 62
    129c:	31 96       	adiw	r30, 0x01	; 1
    129e:	0f 2e       	mov	r0, r31
    12a0:	f0 e7       	ldi	r31, 0x70	; 112
    12a2:	ef 2e       	mov	r14, r31
    12a4:	f8 e0       	ldi	r31, 0x08	; 8
    12a6:	ff 2e       	mov	r15, r31
    12a8:	f0 2d       	mov	r31, r0
    12aa:	ad b7       	in	r26, 0x3d	; 61
    12ac:	be b7       	in	r27, 0x3e	; 62
    12ae:	12 96       	adiw	r26, 0x02	; 2
    12b0:	fc 92       	st	X, r15
    12b2:	ee 92       	st	-X, r14
    12b4:	11 97       	sbiw	r26, 0x01	; 1
    12b6:	89 e1       	ldi	r24, 0x19	; 25
    12b8:	93 e0       	ldi	r25, 0x03	; 3
    12ba:	93 83       	std	Z+3, r25	; 0x03
    12bc:	82 83       	std	Z+2, r24	; 0x02
    12be:	04 83       	std	Z+4, r16	; 0x04
    12c0:	15 82       	std	Z+5, r1	; 0x05
    12c2:	0e 94 71 2c 	call	0x58e2	; 0x58e2 <sprintf>
	f_write(&Files[0], &Buff, 33, &a);
    12c6:	8d b7       	in	r24, 0x3d	; 61
    12c8:	9e b7       	in	r25, 0x3e	; 62
    12ca:	06 96       	adiw	r24, 0x06	; 6
    12cc:	0f b6       	in	r0, 0x3f	; 63
    12ce:	f8 94       	cli
    12d0:	9e bf       	out	0x3e, r25	; 62
    12d2:	0f be       	out	0x3f, r0	; 63
    12d4:	8d bf       	out	0x3d, r24	; 61
    12d6:	80 e3       	ldi	r24, 0x30	; 48
    12d8:	94 e0       	ldi	r25, 0x04	; 4
    12da:	b7 01       	movw	r22, r14
    12dc:	21 e2       	ldi	r18, 0x21	; 33
    12de:	30 e0       	ldi	r19, 0x00	; 0
    12e0:	40 e0       	ldi	r20, 0x00	; 0
    12e2:	50 e0       	ldi	r21, 0x00	; 0
    12e4:	8e 01       	movw	r16, r28
    12e6:	0f 5f       	subi	r16, 0xFF	; 255
    12e8:	1f 4f       	sbci	r17, 0xFF	; 255
    12ea:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <f_write>
	FIFO_init();
    12ee:	0e 94 51 06 	call	0xca2	; 0xca2 <FIFO_init>

	//f_close(&Files[0]);
	StatusReg |= STATUS_READY;
    12f2:	80 91 b9 0e 	lds	r24, 0x0EB9
    12f6:	80 61       	ori	r24, 0x10	; 16
    12f8:	80 93 b9 0e 	sts	0x0EB9, r24
	UI_LEDs(StatusReg);
    12fc:	0e 94 21 08 	call	0x1042	; 0x1042 <UI_LEDs>
    1300:	8f eb       	ldi	r24, 0xBF	; 191
    1302:	97 e2       	ldi	r25, 0x27	; 39
    1304:	a9 e0       	ldi	r26, 0x09	; 9
    1306:	81 50       	subi	r24, 0x01	; 1
    1308:	90 40       	sbci	r25, 0x00	; 0
    130a:	a0 40       	sbci	r26, 0x00	; 0
    130c:	e1 f7       	brne	.-8      	; 0x1306 <main+0x1ee>
    130e:	00 c0       	rjmp	.+0      	; 0x1310 <main+0x1f8>
    1310:	00 00       	nop
    {
		Input = (~UI_Buttons() & 0x0F);//Data is received negative
		if(Input)//if a button has been pressed
		{
			_delay_ms(250);
			sprintf(Buff, "Button Received : %d\n", Input);
    1312:	47 01       	movw	r8, r14
    1314:	0f 2e       	mov	r0, r31
    1316:	fa e3       	ldi	r31, 0x3A	; 58
    1318:	6f 2e       	mov	r6, r31
    131a:	f3 e0       	ldi	r31, 0x03	; 3
    131c:	7f 2e       	mov	r7, r31
    131e:	f0 2d       	mov	r31, r0
			f_write(&Files[0], Buff, 21, &a);
    1320:	0f 2e       	mov	r0, r31
    1322:	f0 e3       	ldi	r31, 0x30	; 48
    1324:	af 2e       	mov	r10, r31
    1326:	f4 e0       	ldi	r31, 0x04	; 4
    1328:	bf 2e       	mov	r11, r31
    132a:	f0 2d       	mov	r31, r0
					FIFO_Reset(1);
					f_write(&Files[0], "Capturing Images...\n", 20, &a);
					LoadImagesToBuffer();//Load both images
					
					//Create Bitmap for image 0
					f_open(&Files[1], "/image0.bmp", FA_CREATE_ALWAYS | FA_WRITE);
    132c:	0f 2e       	mov	r0, r31
    132e:	f0 e5       	ldi	r31, 0x50	; 80
    1330:	ef 2e       	mov	r14, r31
    1332:	f6 e0       	ldi	r31, 0x06	; 6
    1334:	ff 2e       	mov	r15, r31
    1336:	f0 2d       	mov	r31, r0
    1338:	0f 2e       	mov	r0, r31
    133a:	f5 e6       	ldi	r31, 0x65	; 101
    133c:	4f 2e       	mov	r4, r31
    133e:	f3 e0       	ldi	r31, 0x03	; 3
    1340:	5f 2e       	mov	r5, r31
    1342:	f0 2d       	mov	r31, r0
					f_lseek(&Files[1], 0);
					f_close(&Files[1]);
					f_write(&Files[0], "Extended image0 file.\n", 22, &a);
					
					//Create Bitmap for image 1
					f_open(&Files[1], "/image1.bmp", FA_CREATE_ALWAYS | FA_WRITE);
    1344:	0f 2e       	mov	r0, r31
    1346:	fe e9       	ldi	r31, 0x9E	; 158
    1348:	2f 2e       	mov	r2, r31
    134a:	f3 e0       	ldi	r31, 0x03	; 3
    134c:	3f 2e       	mov	r3, r31
    134e:	f0 2d       	mov	r31, r0
	_delay_ms(250);
	uint8_t Input;
	
    while(1)
    {
		Input = (~UI_Buttons() & 0x0F);//Data is received negative
    1350:	0e 94 3f 08 	call	0x107e	; 0x107e <UI_Buttons>
    1354:	80 95       	com	r24
    1356:	0f 2e       	mov	r0, r31
    1358:	ff e0       	ldi	r31, 0x0F	; 15
    135a:	df 2e       	mov	r13, r31
    135c:	f0 2d       	mov	r31, r0
    135e:	d8 22       	and	r13, r24
		if(Input)//if a button has been pressed
    1360:	09 f4       	brne	.+2      	; 0x1364 <main+0x24c>
    1362:	06 c1       	rjmp	.+524    	; 0x1570 <main+0x458>
    1364:	8f eb       	ldi	r24, 0xBF	; 191
    1366:	97 e2       	ldi	r25, 0x27	; 39
    1368:	a9 e0       	ldi	r26, 0x09	; 9
    136a:	81 50       	subi	r24, 0x01	; 1
    136c:	90 40       	sbci	r25, 0x00	; 0
    136e:	a0 40       	sbci	r26, 0x00	; 0
    1370:	e1 f7       	brne	.-8      	; 0x136a <main+0x252>
    1372:	00 c0       	rjmp	.+0      	; 0x1374 <main+0x25c>
    1374:	00 00       	nop
		{
			_delay_ms(250);
			sprintf(Buff, "Button Received : %d\n", Input);
    1376:	00 d0       	rcall	.+0      	; 0x1378 <main+0x260>
    1378:	00 d0       	rcall	.+0      	; 0x137a <main+0x262>
    137a:	00 d0       	rcall	.+0      	; 0x137c <main+0x264>
    137c:	ed b7       	in	r30, 0x3d	; 61
    137e:	fe b7       	in	r31, 0x3e	; 62
    1380:	31 96       	adiw	r30, 0x01	; 1
    1382:	ad b7       	in	r26, 0x3d	; 61
    1384:	be b7       	in	r27, 0x3e	; 62
    1386:	12 96       	adiw	r26, 0x02	; 2
    1388:	9c 92       	st	X, r9
    138a:	8e 92       	st	-X, r8
    138c:	11 97       	sbiw	r26, 0x01	; 1
    138e:	73 82       	std	Z+3, r7	; 0x03
    1390:	62 82       	std	Z+2, r6	; 0x02
    1392:	d4 82       	std	Z+4, r13	; 0x04
    1394:	15 82       	std	Z+5, r1	; 0x05
    1396:	0e 94 71 2c 	call	0x58e2	; 0x58e2 <sprintf>
			f_write(&Files[0], Buff, 21, &a);
    139a:	8d b7       	in	r24, 0x3d	; 61
    139c:	9e b7       	in	r25, 0x3e	; 62
    139e:	06 96       	adiw	r24, 0x06	; 6
    13a0:	0f b6       	in	r0, 0x3f	; 63
    13a2:	f8 94       	cli
    13a4:	9e bf       	out	0x3e, r25	; 62
    13a6:	0f be       	out	0x3f, r0	; 63
    13a8:	8d bf       	out	0x3d, r24	; 61
    13aa:	c5 01       	movw	r24, r10
    13ac:	b4 01       	movw	r22, r8
    13ae:	25 e1       	ldi	r18, 0x15	; 21
    13b0:	30 e0       	ldi	r19, 0x00	; 0
    13b2:	40 e0       	ldi	r20, 0x00	; 0
    13b4:	50 e0       	ldi	r21, 0x00	; 0
    13b6:	8e 01       	movw	r16, r28
    13b8:	0f 5f       	subi	r16, 0xFF	; 255
    13ba:	1f 4f       	sbci	r17, 0xFF	; 255
    13bc:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <f_write>
			
			StatusReg&= ~(STATUS_READY);//no longer ready
    13c0:	80 91 b9 0e 	lds	r24, 0x0EB9
    13c4:	8f 7e       	andi	r24, 0xEF	; 239
    13c6:	80 93 b9 0e 	sts	0x0EB9, r24
			
			switch(Input)
    13ca:	91 e0       	ldi	r25, 0x01	; 1
    13cc:	d9 16       	cp	r13, r25
    13ce:	29 f0       	breq	.+10     	; 0x13da <main+0x2c2>
    13d0:	a8 e0       	ldi	r26, 0x08	; 8
    13d2:	da 16       	cp	r13, r26
    13d4:	09 f0       	breq	.+2      	; 0x13d8 <main+0x2c0>
    13d6:	bc cf       	rjmp	.-136    	; 0x1350 <main+0x238>
    13d8:	b0 c0       	rjmp	.+352    	; 0x153a <main+0x422>
			{
				case (1<<Button_Capture):
					StatusReg |= STATUS_CAPTURING;
    13da:	80 62       	ori	r24, 0x20	; 32
    13dc:	80 93 b9 0e 	sts	0x0EB9, r24
					UI_LEDs(StatusReg);
    13e0:	0e 94 21 08 	call	0x1042	; 0x1042 <UI_LEDs>
					//Reset both buffers
					FIFO_Reset(0);
    13e4:	80 e0       	ldi	r24, 0x00	; 0
    13e6:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
					FIFO_Reset(1);
    13ea:	81 e0       	ldi	r24, 0x01	; 1
    13ec:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
					f_write(&Files[0], "Capturing Images...\n", 20, &a);
    13f0:	c5 01       	movw	r24, r10
    13f2:	60 e5       	ldi	r22, 0x50	; 80
    13f4:	73 e0       	ldi	r23, 0x03	; 3
    13f6:	24 e1       	ldi	r18, 0x14	; 20
    13f8:	30 e0       	ldi	r19, 0x00	; 0
    13fa:	40 e0       	ldi	r20, 0x00	; 0
    13fc:	50 e0       	ldi	r21, 0x00	; 0
    13fe:	8e 01       	movw	r16, r28
    1400:	0f 5f       	subi	r16, 0xFF	; 255
    1402:	1f 4f       	sbci	r17, 0xFF	; 255
    1404:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <f_write>
					LoadImagesToBuffer();//Load both images
    1408:	0e 94 b5 06 	call	0xd6a	; 0xd6a <LoadImagesToBuffer>
					
					//Create Bitmap for image 0
					f_open(&Files[1], "/image0.bmp", FA_CREATE_ALWAYS | FA_WRITE);
    140c:	c7 01       	movw	r24, r14
    140e:	b2 01       	movw	r22, r4
    1410:	4a e0       	ldi	r20, 0x0A	; 10
    1412:	0e 94 03 1b 	call	0x3606	; 0x3606 <f_open>
					f_write(&Files[0], "Created image0 file.\n", 22, &a);
    1416:	c5 01       	movw	r24, r10
    1418:	61 e7       	ldi	r22, 0x71	; 113
    141a:	73 e0       	ldi	r23, 0x03	; 3
    141c:	26 e1       	ldi	r18, 0x16	; 22
    141e:	30 e0       	ldi	r19, 0x00	; 0
    1420:	40 e0       	ldi	r20, 0x00	; 0
    1422:	50 e0       	ldi	r21, 0x00	; 0
    1424:	8e 01       	movw	r16, r28
    1426:	0f 5f       	subi	r16, 0xFF	; 255
    1428:	1f 4f       	sbci	r17, 0xFF	; 255
    142a:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <f_write>
					f_lseek(&Files[1], BMPFileSize);
    142e:	c7 01       	movw	r24, r14
    1430:	4a e8       	ldi	r20, 0x8A	; 138
    1432:	58 e5       	ldi	r21, 0x58	; 88
    1434:	62 e0       	ldi	r22, 0x02	; 2
    1436:	70 e0       	ldi	r23, 0x00	; 0
    1438:	0e 94 7e 21 	call	0x42fc	; 0x42fc <f_lseek>
					f_lseek(&Files[1], 0);
    143c:	c7 01       	movw	r24, r14
    143e:	40 e0       	ldi	r20, 0x00	; 0
    1440:	50 e0       	ldi	r21, 0x00	; 0
    1442:	ba 01       	movw	r22, r20
    1444:	0e 94 7e 21 	call	0x42fc	; 0x42fc <f_lseek>
					f_close(&Files[1]);
    1448:	c7 01       	movw	r24, r14
    144a:	0e 94 12 21 	call	0x4224	; 0x4224 <f_close>
					f_write(&Files[0], "Extended image0 file.\n", 22, &a);
    144e:	c5 01       	movw	r24, r10
    1450:	67 e8       	ldi	r22, 0x87	; 135
    1452:	73 e0       	ldi	r23, 0x03	; 3
    1454:	26 e1       	ldi	r18, 0x16	; 22
    1456:	30 e0       	ldi	r19, 0x00	; 0
    1458:	40 e0       	ldi	r20, 0x00	; 0
    145a:	50 e0       	ldi	r21, 0x00	; 0
    145c:	8e 01       	movw	r16, r28
    145e:	0f 5f       	subi	r16, 0xFF	; 255
    1460:	1f 4f       	sbci	r17, 0xFF	; 255
    1462:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <f_write>
					
					//Create Bitmap for image 1
					f_open(&Files[1], "/image1.bmp", FA_CREATE_ALWAYS | FA_WRITE);
    1466:	c7 01       	movw	r24, r14
    1468:	b1 01       	movw	r22, r2
    146a:	4a e0       	ldi	r20, 0x0A	; 10
    146c:	0e 94 03 1b 	call	0x3606	; 0x3606 <f_open>
					f_write(&Files[0], "Created image1 file.\n", 22, &a);
    1470:	c5 01       	movw	r24, r10
    1472:	6a ea       	ldi	r22, 0xAA	; 170
    1474:	73 e0       	ldi	r23, 0x03	; 3
    1476:	26 e1       	ldi	r18, 0x16	; 22
    1478:	30 e0       	ldi	r19, 0x00	; 0
    147a:	40 e0       	ldi	r20, 0x00	; 0
    147c:	50 e0       	ldi	r21, 0x00	; 0
    147e:	8e 01       	movw	r16, r28
    1480:	0f 5f       	subi	r16, 0xFF	; 255
    1482:	1f 4f       	sbci	r17, 0xFF	; 255
    1484:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <f_write>
					f_lseek(&Files[1], BMPFileSize);
    1488:	c7 01       	movw	r24, r14
    148a:	4a e8       	ldi	r20, 0x8A	; 138
    148c:	58 e5       	ldi	r21, 0x58	; 88
    148e:	62 e0       	ldi	r22, 0x02	; 2
    1490:	70 e0       	ldi	r23, 0x00	; 0
    1492:	0e 94 7e 21 	call	0x42fc	; 0x42fc <f_lseek>
					f_lseek(&Files[1], 0);
    1496:	c7 01       	movw	r24, r14
    1498:	40 e0       	ldi	r20, 0x00	; 0
    149a:	50 e0       	ldi	r21, 0x00	; 0
    149c:	ba 01       	movw	r22, r20
    149e:	0e 94 7e 21 	call	0x42fc	; 0x42fc <f_lseek>
					f_close(&Files[1]);
    14a2:	c7 01       	movw	r24, r14
    14a4:	0e 94 12 21 	call	0x4224	; 0x4224 <f_close>
					f_write(&Files[0], "Extended image1 file.\n", 22, &a);
    14a8:	c5 01       	movw	r24, r10
    14aa:	60 ec       	ldi	r22, 0xC0	; 192
    14ac:	73 e0       	ldi	r23, 0x03	; 3
    14ae:	26 e1       	ldi	r18, 0x16	; 22
    14b0:	30 e0       	ldi	r19, 0x00	; 0
    14b2:	40 e0       	ldi	r20, 0x00	; 0
    14b4:	50 e0       	ldi	r21, 0x00	; 0
    14b6:	8e 01       	movw	r16, r28
    14b8:	0f 5f       	subi	r16, 0xFF	; 255
    14ba:	1f 4f       	sbci	r17, 0xFF	; 255
    14bc:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <f_write>
					//Get image 0
					f_open(&Files[1], "/image0.bmp", FA_WRITE);
    14c0:	c7 01       	movw	r24, r14
    14c2:	b2 01       	movw	r22, r4
    14c4:	42 e0       	ldi	r20, 0x02	; 2
    14c6:	0e 94 03 1b 	call	0x3606	; 0x3606 <f_open>
					while (2 == GetImageIfAvailiable(&Files[1], 0))	;
    14ca:	c7 01       	movw	r24, r14
    14cc:	60 e0       	ldi	r22, 0x00	; 0
    14ce:	0e 94 c5 06 	call	0xd8a	; 0xd8a <GetImageIfAvailiable>
    14d2:	82 30       	cpi	r24, 0x02	; 2
    14d4:	d1 f3       	breq	.-12     	; 0x14ca <main+0x3b2>
					f_close(&Files[1]);
    14d6:	c7 01       	movw	r24, r14
    14d8:	0e 94 12 21 	call	0x4224	; 0x4224 <f_close>
					f_write(&Files[0], "Captured image0.\n", 17, &a);
    14dc:	c5 01       	movw	r24, r10
    14de:	67 ed       	ldi	r22, 0xD7	; 215
    14e0:	73 e0       	ldi	r23, 0x03	; 3
    14e2:	21 e1       	ldi	r18, 0x11	; 17
    14e4:	30 e0       	ldi	r19, 0x00	; 0
    14e6:	40 e0       	ldi	r20, 0x00	; 0
    14e8:	50 e0       	ldi	r21, 0x00	; 0
    14ea:	8e 01       	movw	r16, r28
    14ec:	0f 5f       	subi	r16, 0xFF	; 255
    14ee:	1f 4f       	sbci	r17, 0xFF	; 255
    14f0:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <f_write>
					//get image 1
					f_open(&Files[1], "/image1.bmp", FA_WRITE);
    14f4:	c7 01       	movw	r24, r14
    14f6:	b1 01       	movw	r22, r2
    14f8:	42 e0       	ldi	r20, 0x02	; 2
    14fa:	0e 94 03 1b 	call	0x3606	; 0x3606 <f_open>
					while (2 == GetImageIfAvailiable(&Files[1], 1))	;
    14fe:	c7 01       	movw	r24, r14
    1500:	61 e0       	ldi	r22, 0x01	; 1
    1502:	0e 94 c5 06 	call	0xd8a	; 0xd8a <GetImageIfAvailiable>
    1506:	82 30       	cpi	r24, 0x02	; 2
    1508:	d1 f3       	breq	.-12     	; 0x14fe <main+0x3e6>
					f_close(&Files[1]);
    150a:	c7 01       	movw	r24, r14
    150c:	0e 94 12 21 	call	0x4224	; 0x4224 <f_close>
					f_write(&Files[0], "Captured image1.\n", 17, &a);
    1510:	c5 01       	movw	r24, r10
    1512:	69 ee       	ldi	r22, 0xE9	; 233
    1514:	73 e0       	ldi	r23, 0x03	; 3
    1516:	21 e1       	ldi	r18, 0x11	; 17
    1518:	30 e0       	ldi	r19, 0x00	; 0
    151a:	40 e0       	ldi	r20, 0x00	; 0
    151c:	50 e0       	ldi	r21, 0x00	; 0
    151e:	8e 01       	movw	r16, r28
    1520:	0f 5f       	subi	r16, 0xFF	; 255
    1522:	1f 4f       	sbci	r17, 0xFF	; 255
    1524:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <f_write>
					StatusReg |= STATUS_READY;
    1528:	80 91 b9 0e 	lds	r24, 0x0EB9
    152c:	80 61       	ori	r24, 0x10	; 16
					StatusReg &= ~STATUS_CAPTURING;
    152e:	8f 7d       	andi	r24, 0xDF	; 223
    1530:	80 93 b9 0e 	sts	0x0EB9, r24
					UI_LEDs(StatusReg);
    1534:	0e 94 21 08 	call	0x1042	; 0x1042 <UI_LEDs>
					break;//break case(1<<ButtonCapture)
    1538:	0b cf       	rjmp	.-490    	; 0x1350 <main+0x238>
					
				case (1<<Button_Exit):
					f_write(&Files[0], "\nSystem Exiting...\n",19 ,&a);
    153a:	0f 2e       	mov	r0, r31
    153c:	f0 e3       	ldi	r31, 0x30	; 48
    153e:	ef 2e       	mov	r14, r31
    1540:	f4 e0       	ldi	r31, 0x04	; 4
    1542:	ff 2e       	mov	r15, r31
    1544:	f0 2d       	mov	r31, r0
    1546:	c7 01       	movw	r24, r14
    1548:	6b ef       	ldi	r22, 0xFB	; 251
    154a:	73 e0       	ldi	r23, 0x03	; 3
    154c:	23 e1       	ldi	r18, 0x13	; 19
    154e:	30 e0       	ldi	r19, 0x00	; 0
    1550:	40 e0       	ldi	r20, 0x00	; 0
    1552:	50 e0       	ldi	r21, 0x00	; 0
    1554:	8e 01       	movw	r16, r28
    1556:	0f 5f       	subi	r16, 0xFF	; 255
    1558:	1f 4f       	sbci	r17, 0xFF	; 255
    155a:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <f_write>
					f_close(&Files[0]);//close log file
    155e:	c7 01       	movw	r24, r14
    1560:	0e 94 12 21 	call	0x4224	; 0x4224 <f_close>
					
					StatusReg = 0x41;
    1564:	81 e4       	ldi	r24, 0x41	; 65
    1566:	80 93 b9 0e 	sts	0x0EB9, r24
					UI_LEDs(StatusReg);
    156a:	0e 94 21 08 	call	0x1042	; 0x1042 <UI_LEDs>
					return 0;//Q
    156e:	11 c0       	rjmp	.+34     	; 0x1592 <main+0x47a>
			}//End switch
		}//End if(Input)
		else
		{
			StatusReg |= STATUS_READY;
    1570:	80 91 b9 0e 	lds	r24, 0x0EB9
    1574:	80 61       	ori	r24, 0x10	; 16
    1576:	80 93 b9 0e 	sts	0x0EB9, r24
			UI_LEDs(StatusReg);
    157a:	0e 94 21 08 	call	0x1042	; 0x1042 <UI_LEDs>
    157e:	8f eb       	ldi	r24, 0xBF	; 191
    1580:	97 e2       	ldi	r25, 0x27	; 39
    1582:	a9 e0       	ldi	r26, 0x09	; 9
    1584:	81 50       	subi	r24, 0x01	; 1
    1586:	90 40       	sbci	r25, 0x00	; 0
    1588:	a0 40       	sbci	r26, 0x00	; 0
    158a:	e1 f7       	brne	.-8      	; 0x1584 <main+0x46c>
    158c:	00 c0       	rjmp	.+0      	; 0x158e <main+0x476>
    158e:	00 00       	nop
    1590:	df ce       	rjmp	.-578    	; 0x1350 <main+0x238>
			_delay_ms(250);//wait
		}//end else(Input)					
    }//End while(1)
    1592:	80 e0       	ldi	r24, 0x00	; 0
    1594:	90 e0       	ldi	r25, 0x00	; 0
    1596:	0f 90       	pop	r0
    1598:	0f 90       	pop	r0
    159a:	0f 90       	pop	r0
    159c:	0f 90       	pop	r0
    159e:	df 91       	pop	r29
    15a0:	cf 91       	pop	r28
    15a2:	1f 91       	pop	r17
    15a4:	0f 91       	pop	r16
    15a6:	ff 90       	pop	r15
    15a8:	ef 90       	pop	r14
    15aa:	df 90       	pop	r13
    15ac:	bf 90       	pop	r11
    15ae:	af 90       	pop	r10
    15b0:	9f 90       	pop	r9
    15b2:	8f 90       	pop	r8
    15b4:	7f 90       	pop	r7
    15b6:	6f 90       	pop	r6
    15b8:	5f 90       	pop	r5
    15ba:	4f 90       	pop	r4
    15bc:	3f 90       	pop	r3
    15be:	2f 90       	pop	r2
    15c0:	08 95       	ret

000015c2 <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
    15c2:	e6 2f       	mov	r30, r22
    15c4:	f7 2f       	mov	r31, r23
    15c6:	ba 01       	movw	r22, r20
    15c8:	a9 01       	movw	r20, r18
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
    15ca:	41 15       	cp	r20, r1
    15cc:	51 05       	cpc	r21, r1
    15ce:	61 05       	cpc	r22, r1
    15d0:	71 05       	cpc	r23, r1
    15d2:	59 f0       	breq	.+22     	; 0x15ea <mem_cpy+0x28>
    15d4:	ae 2f       	mov	r26, r30
    15d6:	bf 2f       	mov	r27, r31
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    15d8:	e8 2f       	mov	r30, r24
    15da:	f9 2f       	mov	r31, r25
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
    15dc:	8d 91       	ld	r24, X+
    15de:	81 93       	st	Z+, r24
    15e0:	41 50       	subi	r20, 0x01	; 1
    15e2:	50 40       	sbci	r21, 0x00	; 0
    15e4:	60 40       	sbci	r22, 0x00	; 0
    15e6:	70 40       	sbci	r23, 0x00	; 0
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
    15e8:	c9 f7       	brne	.-14     	; 0x15dc <mem_cpy+0x1a>
    15ea:	08 95       	ret

000015ec <mem_set>:
		*d++ = *s++;
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
    15ec:	a6 2f       	mov	r26, r22
    15ee:	ba 01       	movw	r22, r20
    15f0:	a9 01       	movw	r20, r18
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    15f2:	41 15       	cp	r20, r1
    15f4:	51 05       	cpc	r21, r1
    15f6:	61 05       	cpc	r22, r1
    15f8:	71 05       	cpc	r23, r1
    15fa:	41 f0       	breq	.+16     	; 0x160c <mem_set+0x20>
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    15fc:	e8 2f       	mov	r30, r24
    15fe:	f9 2f       	mov	r31, r25

	while (cnt--)
		*d++ = (BYTE)val;
    1600:	a1 93       	st	Z+, r26
    1602:	41 50       	subi	r20, 0x01	; 1
    1604:	50 40       	sbci	r21, 0x00	; 0
    1606:	60 40       	sbci	r22, 0x00	; 0
    1608:	70 40       	sbci	r23, 0x00	; 0
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    160a:	d1 f7       	brne	.-12     	; 0x1600 <mem_set+0x14>
    160c:	08 95       	ret

0000160e <ld_clust>:
static
DWORD ld_clust (
	FATFS *fs,	/* Pointer to the fs object */
	BYTE *dir	/* Pointer to the directory entry */
)
{
    160e:	0f 93       	push	r16
    1610:	1f 93       	push	r17
    1612:	dc 01       	movw	r26, r24
    1614:	fb 01       	movw	r30, r22
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
    1616:	93 8d       	ldd	r25, Z+27	; 0x1b
    1618:	80 e0       	ldi	r24, 0x00	; 0
    161a:	02 8d       	ldd	r16, Z+26	; 0x1a
    161c:	10 e0       	ldi	r17, 0x00	; 0
    161e:	08 2b       	or	r16, r24
    1620:	19 2b       	or	r17, r25
    1622:	20 e0       	ldi	r18, 0x00	; 0
    1624:	30 e0       	ldi	r19, 0x00	; 0
	if (fs->fs_type == FS_FAT32)
    1626:	8c 91       	ld	r24, X
    1628:	83 30       	cpi	r24, 0x03	; 3
    162a:	79 f4       	brne	.+30     	; 0x164a <ld_clust+0x3c>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
    162c:	55 89       	ldd	r21, Z+21	; 0x15
    162e:	40 e0       	ldi	r20, 0x00	; 0
    1630:	84 89       	ldd	r24, Z+20	; 0x14
    1632:	90 e0       	ldi	r25, 0x00	; 0
    1634:	84 2b       	or	r24, r20
    1636:	95 2b       	or	r25, r21
    1638:	a0 e0       	ldi	r26, 0x00	; 0
    163a:	b0 e0       	ldi	r27, 0x00	; 0
    163c:	dc 01       	movw	r26, r24
    163e:	99 27       	eor	r25, r25
    1640:	88 27       	eor	r24, r24
    1642:	08 2b       	or	r16, r24
    1644:	19 2b       	or	r17, r25
    1646:	2a 2b       	or	r18, r26
    1648:	3b 2b       	or	r19, r27

	return cl;
}
    164a:	60 2f       	mov	r22, r16
    164c:	71 2f       	mov	r23, r17
    164e:	82 2f       	mov	r24, r18
    1650:	93 2f       	mov	r25, r19
    1652:	1f 91       	pop	r17
    1654:	0f 91       	pop	r16
    1656:	08 95       	ret

00001658 <st_clust>:
static
void st_clust (
	BYTE *dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
    1658:	fc 01       	movw	r30, r24
	ST_WORD(dir+DIR_FstClusLO, cl);
    165a:	42 8f       	std	Z+26, r20	; 0x1a
    165c:	53 8f       	std	Z+27, r21	; 0x1b
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
    165e:	ab 01       	movw	r20, r22
    1660:	66 27       	eor	r22, r22
    1662:	77 27       	eor	r23, r23
    1664:	44 8b       	std	Z+20, r20	; 0x14
    1666:	55 8b       	std	Z+21, r21	; 0x15
}
    1668:	08 95       	ret

0000166a <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to the file information to be filled */
)
{
    166a:	ef 92       	push	r14
    166c:	ff 92       	push	r15
    166e:	0f 93       	push	r16
    1670:	1f 93       	push	r17
    1672:	cf 93       	push	r28
    1674:	df 93       	push	r29
    1676:	fc 01       	movw	r30, r24
    1678:	7b 01       	movw	r14, r22
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
    167a:	8b 01       	movw	r16, r22
    167c:	07 5f       	subi	r16, 0xF7	; 247
    167e:	1f 4f       	sbci	r17, 0xFF	; 255
	if (dj->sect) {
    1680:	86 85       	ldd	r24, Z+14	; 0x0e
    1682:	97 85       	ldd	r25, Z+15	; 0x0f
    1684:	a0 89       	ldd	r26, Z+16	; 0x10
    1686:	b1 89       	ldd	r27, Z+17	; 0x11
    1688:	00 97       	sbiw	r24, 0x00	; 0
    168a:	a1 05       	cpc	r26, r1
    168c:	b1 05       	cpc	r27, r1
    168e:	09 f4       	brne	.+2      	; 0x1692 <get_fileinfo+0x28>
    1690:	65 c0       	rjmp	.+202    	; 0x175c <get_fileinfo+0xf2>
		dir = dj->dir;
    1692:	c2 89       	ldd	r28, Z+18	; 0x12
    1694:	d3 89       	ldd	r29, Z+19	; 0x13
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
    1696:	28 81       	ld	r18, Y
			if (c == ' ') break;
    1698:	20 32       	cpi	r18, 0x20	; 32
    169a:	99 f0       	breq	.+38     	; 0x16c2 <get_fileinfo+0x58>
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
    169c:	de 01       	movw	r26, r28
    169e:	11 96       	adiw	r26, 0x01	; 1
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
    16a0:	f8 01       	movw	r30, r16
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
    16a2:	80 e0       	ldi	r24, 0x00	; 0
    16a4:	90 e0       	ldi	r25, 0x00	; 0
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
    16a6:	35 ee       	ldi	r19, 0xE5	; 229
    16a8:	04 c0       	rjmp	.+8      	; 0x16b2 <get_fileinfo+0x48>
	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
    16aa:	2d 91       	ld	r18, X+
    16ac:	01 96       	adiw	r24, 0x01	; 1
			if (c == ' ') break;
    16ae:	20 32       	cpi	r18, 0x20	; 32
    16b0:	41 f0       	breq	.+16     	; 0x16c2 <get_fileinfo+0x58>
			if (c == NDDE) c = (TCHAR)DDE;
    16b2:	25 30       	cpi	r18, 0x05	; 5
    16b4:	09 f4       	brne	.+2      	; 0x16b8 <get_fileinfo+0x4e>
    16b6:	23 2f       	mov	r18, r19
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
    16b8:	21 93       	st	Z+, r18
    16ba:	8f 01       	movw	r16, r30

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
    16bc:	87 30       	cpi	r24, 0x07	; 7
    16be:	91 05       	cpc	r25, r1
    16c0:	a1 f7       	brne	.-24     	; 0x16aa <get_fileinfo+0x40>
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
    16c2:	88 85       	ldd	r24, Y+8	; 0x08
    16c4:	80 32       	cpi	r24, 0x20	; 32
    16c6:	81 f0       	breq	.+32     	; 0x16e8 <get_fileinfo+0x7e>
			*p++ = '.';
    16c8:	8e e2       	ldi	r24, 0x2E	; 46
    16ca:	f8 01       	movw	r30, r16
    16cc:	80 83       	st	Z, r24
			for (i = 8; i < 11; i++) {
				c = dir[i];
    16ce:	88 85       	ldd	r24, Y+8	; 0x08
				if (c == ' ') break;
    16d0:	80 32       	cpi	r24, 0x20	; 32
    16d2:	09 f0       	breq	.+2      	; 0x16d6 <get_fileinfo+0x6c>
    16d4:	4c c0       	rjmp	.+152    	; 0x176e <get_fileinfo+0x104>
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
    16d6:	0f 5f       	subi	r16, 0xFF	; 255
    16d8:	1f 4f       	sbci	r17, 0xFF	; 255
    16da:	06 c0       	rjmp	.+12     	; 0x16e8 <get_fileinfo+0x7e>
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
    16dc:	8c 01       	movw	r16, r24
    16de:	04 c0       	rjmp	.+8      	; 0x16e8 <get_fileinfo+0x7e>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    16e0:	f8 01       	movw	r30, r16
    16e2:	23 83       	std	Z+3, r18	; 0x03
    16e4:	0c 5f       	subi	r16, 0xFC	; 252
    16e6:	1f 4f       	sbci	r17, 0xFF	; 255
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
    16e8:	8b 85       	ldd	r24, Y+11	; 0x0b
    16ea:	f7 01       	movw	r30, r14
    16ec:	80 87       	std	Z+8, r24	; 0x08
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
    16ee:	8f 8d       	ldd	r24, Y+31	; 0x1f
    16f0:	90 e0       	ldi	r25, 0x00	; 0
    16f2:	a0 e0       	ldi	r26, 0x00	; 0
    16f4:	b0 e0       	ldi	r27, 0x00	; 0
    16f6:	b8 2f       	mov	r27, r24
    16f8:	aa 27       	eor	r26, r26
    16fa:	99 27       	eor	r25, r25
    16fc:	88 27       	eor	r24, r24
    16fe:	4e 8d       	ldd	r20, Y+30	; 0x1e
    1700:	50 e0       	ldi	r21, 0x00	; 0
    1702:	60 e0       	ldi	r22, 0x00	; 0
    1704:	70 e0       	ldi	r23, 0x00	; 0
    1706:	ba 01       	movw	r22, r20
    1708:	55 27       	eor	r21, r21
    170a:	44 27       	eor	r20, r20
    170c:	48 2b       	or	r20, r24
    170e:	59 2b       	or	r21, r25
    1710:	6a 2b       	or	r22, r26
    1712:	7b 2b       	or	r23, r27
    1714:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1716:	90 e0       	ldi	r25, 0x00	; 0
    1718:	a0 e0       	ldi	r26, 0x00	; 0
    171a:	b0 e0       	ldi	r27, 0x00	; 0
    171c:	48 2b       	or	r20, r24
    171e:	59 2b       	or	r21, r25
    1720:	6a 2b       	or	r22, r26
    1722:	7b 2b       	or	r23, r27
    1724:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1726:	80 e0       	ldi	r24, 0x00	; 0
    1728:	a0 e0       	ldi	r26, 0x00	; 0
    172a:	b0 e0       	ldi	r27, 0x00	; 0
    172c:	84 2b       	or	r24, r20
    172e:	95 2b       	or	r25, r21
    1730:	a6 2b       	or	r26, r22
    1732:	b7 2b       	or	r27, r23
    1734:	80 83       	st	Z, r24
    1736:	91 83       	std	Z+1, r25	; 0x01
    1738:	a2 83       	std	Z+2, r26	; 0x02
    173a:	b3 83       	std	Z+3, r27	; 0x03
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
    173c:	39 8d       	ldd	r19, Y+25	; 0x19
    173e:	20 e0       	ldi	r18, 0x00	; 0
    1740:	88 8d       	ldd	r24, Y+24	; 0x18
    1742:	90 e0       	ldi	r25, 0x00	; 0
    1744:	82 2b       	or	r24, r18
    1746:	93 2b       	or	r25, r19
    1748:	95 83       	std	Z+5, r25	; 0x05
    174a:	84 83       	std	Z+4, r24	; 0x04
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
    174c:	9f 89       	ldd	r25, Y+23	; 0x17
    174e:	80 e0       	ldi	r24, 0x00	; 0
    1750:	2e 89       	ldd	r18, Y+22	; 0x16
    1752:	30 e0       	ldi	r19, 0x00	; 0
    1754:	82 2b       	or	r24, r18
    1756:	93 2b       	or	r25, r19
    1758:	97 83       	std	Z+7, r25	; 0x07
    175a:	86 83       	std	Z+6, r24	; 0x06
	}
	*p = 0;		/* Terminate SFN str by a \0 */
    175c:	f8 01       	movw	r30, r16
    175e:	10 82       	st	Z, r1
			}
		}
		tp[i] = 0;	/* Terminate the LFN str by a \0 */
	}
#endif
}
    1760:	df 91       	pop	r29
    1762:	cf 91       	pop	r28
    1764:	1f 91       	pop	r17
    1766:	0f 91       	pop	r16
    1768:	ff 90       	pop	r15
    176a:	ef 90       	pop	r14
    176c:	08 95       	ret
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    176e:	f8 01       	movw	r30, r16
    1770:	81 83       	std	Z+1, r24	; 0x01
    1772:	c8 01       	movw	r24, r16
    1774:	02 96       	adiw	r24, 0x02	; 2
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
    1776:	29 85       	ldd	r18, Y+9	; 0x09
				if (c == ' ') break;
    1778:	20 32       	cpi	r18, 0x20	; 32
    177a:	09 f4       	brne	.+2      	; 0x177e <get_fileinfo+0x114>
    177c:	af cf       	rjmp	.-162    	; 0x16dc <get_fileinfo+0x72>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    177e:	22 83       	std	Z+2, r18	; 0x02
    1780:	c8 01       	movw	r24, r16
    1782:	03 96       	adiw	r24, 0x03	; 3
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
    1784:	2a 85       	ldd	r18, Y+10	; 0x0a
				if (c == ' ') break;
    1786:	20 32       	cpi	r18, 0x20	; 32
    1788:	09 f0       	breq	.+2      	; 0x178c <get_fileinfo+0x122>
    178a:	aa cf       	rjmp	.-172    	; 0x16e0 <get_fileinfo+0x76>
    178c:	a7 cf       	rjmp	.-178    	; 0x16dc <get_fileinfo+0x72>

0000178e <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
    178e:	dc 01       	movw	r26, r24
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
    1790:	ed 91       	ld	r30, X+
    1792:	fc 91       	ld	r31, X
    1794:	11 97       	sbiw	r26, 0x01	; 1
    1796:	30 97       	sbiw	r30, 0x00	; 0
    1798:	99 f0       	breq	.+38     	; 0x17c0 <validate+0x32>
    179a:	80 81       	ld	r24, Z
    179c:	88 23       	and	r24, r24
    179e:	91 f0       	breq	.+36     	; 0x17c4 <validate+0x36>
    17a0:	26 81       	ldd	r18, Z+6	; 0x06
    17a2:	37 81       	ldd	r19, Z+7	; 0x07
    17a4:	12 96       	adiw	r26, 0x02	; 2
    17a6:	8d 91       	ld	r24, X+
    17a8:	9c 91       	ld	r25, X
    17aa:	13 97       	sbiw	r26, 0x03	; 3
    17ac:	28 17       	cp	r18, r24
    17ae:	39 07       	cpc	r19, r25
    17b0:	59 f4       	brne	.+22     	; 0x17c8 <validate+0x3a>
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
    17b2:	81 81       	ldd	r24, Z+1	; 0x01
    17b4:	0e 94 92 02 	call	0x524	; 0x524 <disk_status>
    17b8:	80 ff       	sbrs	r24, 0
    17ba:	08 c0       	rjmp	.+16     	; 0x17cc <validate+0x3e>
		return FR_NOT_READY;
    17bc:	83 e0       	ldi	r24, 0x03	; 3
    17be:	08 95       	ret
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
		return FR_INVALID_OBJECT;
    17c0:	89 e0       	ldi	r24, 0x09	; 9
    17c2:	08 95       	ret
    17c4:	89 e0       	ldi	r24, 0x09	; 9
    17c6:	08 95       	ret
    17c8:	89 e0       	ldi	r24, 0x09	; 9
    17ca:	08 95       	ret
	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
    17cc:	80 e0       	ldi	r24, 0x00	; 0
}
    17ce:	08 95       	ret

000017d0 <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    17d0:	0f 93       	push	r16
    17d2:	cf 93       	push	r28
    17d4:	df 93       	push	r29
    17d6:	ec 01       	movw	r28, r24
    17d8:	9a 01       	movw	r18, r20
    17da:	ab 01       	movw	r20, r22
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    17dc:	bc 01       	movw	r22, r24
    17de:	6e 5c       	subi	r22, 0xCE	; 206
    17e0:	7f 4f       	sbci	r23, 0xFF	; 255
    17e2:	89 81       	ldd	r24, Y+1	; 0x01
    17e4:	01 e0       	ldi	r16, 0x01	; 1
    17e6:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    17ea:	88 23       	and	r24, r24
    17ec:	09 f0       	breq	.+2      	; 0x17f0 <check_fs+0x20>
    17ee:	83 c0       	rjmp	.+262    	; 0x18f6 <check_fs+0x126>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    17f0:	fe 01       	movw	r30, r28
    17f2:	ef 5c       	subi	r30, 0xCF	; 207
    17f4:	fd 4f       	sbci	r31, 0xFD	; 253
    17f6:	90 81       	ld	r25, Z
    17f8:	80 e0       	ldi	r24, 0x00	; 0
    17fa:	fe 01       	movw	r30, r28
    17fc:	e0 5d       	subi	r30, 0xD0	; 208
    17fe:	fd 4f       	sbci	r31, 0xFD	; 253
    1800:	20 81       	ld	r18, Z
    1802:	30 e0       	ldi	r19, 0x00	; 0
    1804:	82 2b       	or	r24, r18
    1806:	93 2b       	or	r25, r19
    1808:	2a ea       	ldi	r18, 0xAA	; 170
    180a:	85 35       	cpi	r24, 0x55	; 85
    180c:	92 07       	cpc	r25, r18
    180e:	09 f0       	breq	.+2      	; 0x1812 <check_fs+0x42>
    1810:	74 c0       	rjmp	.+232    	; 0x18fa <check_fs+0x12a>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    1812:	fe 01       	movw	r30, r28
    1814:	e5 59       	subi	r30, 0x95	; 149
    1816:	ff 4f       	sbci	r31, 0xFF	; 255
    1818:	80 81       	ld	r24, Z
    181a:	90 e0       	ldi	r25, 0x00	; 0
    181c:	a0 e0       	ldi	r26, 0x00	; 0
    181e:	b0 e0       	ldi	r27, 0x00	; 0
    1820:	b8 2f       	mov	r27, r24
    1822:	aa 27       	eor	r26, r26
    1824:	99 27       	eor	r25, r25
    1826:	88 27       	eor	r24, r24
    1828:	fe 01       	movw	r30, r28
    182a:	e6 59       	subi	r30, 0x96	; 150
    182c:	ff 4f       	sbci	r31, 0xFF	; 255
    182e:	40 81       	ld	r20, Z
    1830:	50 e0       	ldi	r21, 0x00	; 0
    1832:	60 e0       	ldi	r22, 0x00	; 0
    1834:	70 e0       	ldi	r23, 0x00	; 0
    1836:	ba 01       	movw	r22, r20
    1838:	55 27       	eor	r21, r21
    183a:	44 27       	eor	r20, r20
    183c:	48 2b       	or	r20, r24
    183e:	59 2b       	or	r21, r25
    1840:	6a 2b       	or	r22, r26
    1842:	7b 2b       	or	r23, r27
    1844:	fe 01       	movw	r30, r28
    1846:	e8 59       	subi	r30, 0x98	; 152
    1848:	ff 4f       	sbci	r31, 0xFF	; 255
    184a:	80 81       	ld	r24, Z
    184c:	90 e0       	ldi	r25, 0x00	; 0
    184e:	a0 e0       	ldi	r26, 0x00	; 0
    1850:	b0 e0       	ldi	r27, 0x00	; 0
    1852:	48 2b       	or	r20, r24
    1854:	59 2b       	or	r21, r25
    1856:	6a 2b       	or	r22, r26
    1858:	7b 2b       	or	r23, r27
    185a:	fe 01       	movw	r30, r28
    185c:	e7 59       	subi	r30, 0x97	; 151
    185e:	ff 4f       	sbci	r31, 0xFF	; 255
    1860:	90 81       	ld	r25, Z
    1862:	80 e0       	ldi	r24, 0x00	; 0
    1864:	a0 e0       	ldi	r26, 0x00	; 0
    1866:	b0 e0       	ldi	r27, 0x00	; 0
    1868:	48 2b       	or	r20, r24
    186a:	59 2b       	or	r21, r25
    186c:	6a 2b       	or	r22, r26
    186e:	7b 2b       	or	r23, r27
    1870:	70 70       	andi	r23, 0x00	; 0
    1872:	46 34       	cpi	r20, 0x46	; 70
    1874:	81 e4       	ldi	r24, 0x41	; 65
    1876:	58 07       	cpc	r21, r24
    1878:	84 e5       	ldi	r24, 0x54	; 84
    187a:	68 07       	cpc	r22, r24
    187c:	80 e0       	ldi	r24, 0x00	; 0
    187e:	78 07       	cpc	r23, r24
    1880:	f1 f1       	breq	.+124    	; 0x18fe <check_fs+0x12e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    1882:	fe 01       	movw	r30, r28
    1884:	e9 57       	subi	r30, 0x79	; 121
    1886:	ff 4f       	sbci	r31, 0xFF	; 255
    1888:	80 81       	ld	r24, Z
    188a:	90 e0       	ldi	r25, 0x00	; 0
    188c:	a0 e0       	ldi	r26, 0x00	; 0
    188e:	b0 e0       	ldi	r27, 0x00	; 0
    1890:	b8 2f       	mov	r27, r24
    1892:	aa 27       	eor	r26, r26
    1894:	99 27       	eor	r25, r25
    1896:	88 27       	eor	r24, r24
    1898:	fe 01       	movw	r30, r28
    189a:	ea 57       	subi	r30, 0x7A	; 122
    189c:	ff 4f       	sbci	r31, 0xFF	; 255
    189e:	40 81       	ld	r20, Z
    18a0:	50 e0       	ldi	r21, 0x00	; 0
    18a2:	60 e0       	ldi	r22, 0x00	; 0
    18a4:	70 e0       	ldi	r23, 0x00	; 0
    18a6:	ba 01       	movw	r22, r20
    18a8:	55 27       	eor	r21, r21
    18aa:	44 27       	eor	r20, r20
    18ac:	48 2b       	or	r20, r24
    18ae:	59 2b       	or	r21, r25
    18b0:	6a 2b       	or	r22, r26
    18b2:	7b 2b       	or	r23, r27
    18b4:	fe 01       	movw	r30, r28
    18b6:	ec 57       	subi	r30, 0x7C	; 124
    18b8:	ff 4f       	sbci	r31, 0xFF	; 255
    18ba:	80 81       	ld	r24, Z
    18bc:	90 e0       	ldi	r25, 0x00	; 0
    18be:	a0 e0       	ldi	r26, 0x00	; 0
    18c0:	b0 e0       	ldi	r27, 0x00	; 0
    18c2:	48 2b       	or	r20, r24
    18c4:	59 2b       	or	r21, r25
    18c6:	6a 2b       	or	r22, r26
    18c8:	7b 2b       	or	r23, r27
    18ca:	cb 57       	subi	r28, 0x7B	; 123
    18cc:	df 4f       	sbci	r29, 0xFF	; 255
    18ce:	98 81       	ld	r25, Y
    18d0:	80 e0       	ldi	r24, 0x00	; 0
    18d2:	a0 e0       	ldi	r26, 0x00	; 0
    18d4:	b0 e0       	ldi	r27, 0x00	; 0
    18d6:	48 2b       	or	r20, r24
    18d8:	59 2b       	or	r21, r25
    18da:	6a 2b       	or	r22, r26
    18dc:	7b 2b       	or	r23, r27
    18de:	70 70       	andi	r23, 0x00	; 0
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
    18e0:	81 e0       	ldi	r24, 0x01	; 1
    18e2:	46 34       	cpi	r20, 0x46	; 70
    18e4:	91 e4       	ldi	r25, 0x41	; 65
    18e6:	59 07       	cpc	r21, r25
    18e8:	94 e5       	ldi	r25, 0x54	; 84
    18ea:	69 07       	cpc	r22, r25
    18ec:	90 e0       	ldi	r25, 0x00	; 0
    18ee:	79 07       	cpc	r23, r25
    18f0:	39 f4       	brne	.+14     	; 0x1900 <check_fs+0x130>
    18f2:	80 e0       	ldi	r24, 0x00	; 0
    18f4:	05 c0       	rjmp	.+10     	; 0x1900 <check_fs+0x130>
    18f6:	83 e0       	ldi	r24, 0x03	; 3
    18f8:	03 c0       	rjmp	.+6      	; 0x1900 <check_fs+0x130>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
    18fa:	82 e0       	ldi	r24, 0x02	; 2
    18fc:	01 c0       	rjmp	.+2      	; 0x1900 <check_fs+0x130>

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;
    18fe:	80 e0       	ldi	r24, 0x00	; 0
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
    1900:	df 91       	pop	r29
    1902:	cf 91       	pop	r28
    1904:	0f 91       	pop	r16
    1906:	08 95       	ret

00001908 <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
    1908:	2f 92       	push	r2
    190a:	3f 92       	push	r3
    190c:	4f 92       	push	r4
    190e:	5f 92       	push	r5
    1910:	6f 92       	push	r6
    1912:	7f 92       	push	r7
    1914:	8f 92       	push	r8
    1916:	9f 92       	push	r9
    1918:	af 92       	push	r10
    191a:	bf 92       	push	r11
    191c:	cf 92       	push	r12
    191e:	df 92       	push	r13
    1920:	ef 92       	push	r14
    1922:	ff 92       	push	r15
    1924:	0f 93       	push	r16
    1926:	1f 93       	push	r17
    1928:	cf 93       	push	r28
    192a:	df 93       	push	r29
    192c:	cd b7       	in	r28, 0x3d	; 61
    192e:	de b7       	in	r29, 0x3e	; 62
    1930:	60 97       	sbiw	r28, 0x10	; 16
    1932:	0f b6       	in	r0, 0x3f	; 63
    1934:	f8 94       	cli
    1936:	de bf       	out	0x3e, r29	; 62
    1938:	0f be       	out	0x3f, r0	; 63
    193a:	cd bf       	out	0x3d, r28	; 61
    193c:	8b 01       	movw	r16, r22
    193e:	d4 2e       	mov	r13, r20
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
    1940:	dc 01       	movw	r26, r24
    1942:	ed 91       	ld	r30, X+
    1944:	fc 91       	ld	r31, X
    1946:	11 97       	sbiw	r26, 0x01	; 1
	FATFS *fs;


	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
    1948:	40 81       	ld	r20, Z
    194a:	50 e0       	ldi	r21, 0x00	; 0
    194c:	40 53       	subi	r20, 0x30	; 48
    194e:	50 40       	sbci	r21, 0x00	; 0
    1950:	66 27       	eor	r22, r22
    1952:	57 fd       	sbrc	r21, 7
    1954:	60 95       	com	r22
    1956:	76 2f       	mov	r23, r22
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    1958:	4a 30       	cpi	r20, 0x0A	; 10
    195a:	51 05       	cpc	r21, r1
    195c:	61 05       	cpc	r22, r1
    195e:	71 05       	cpc	r23, r1
    1960:	48 f4       	brcc	.+18     	; 0x1974 <chk_mounted+0x6c>
    1962:	81 81       	ldd	r24, Z+1	; 0x01
    1964:	8a 33       	cpi	r24, 0x3A	; 58
    1966:	31 f4       	brne	.+12     	; 0x1974 <chk_mounted+0x6c>
		p += 2; *path = p;				/* Return pointer to the path name */
    1968:	cf 01       	movw	r24, r30
    196a:	02 96       	adiw	r24, 0x02	; 2
    196c:	11 96       	adiw	r26, 0x01	; 1
    196e:	9c 93       	st	X, r25
    1970:	8e 93       	st	-X, r24
    1972:	05 c0       	rjmp	.+10     	; 0x197e <chk_mounted+0x76>
	} else {							/* No drive number is given */
#if _FS_RPATH
		vol = CurrVol;					/* Use current drive */
    1974:	40 91 25 04 	lds	r20, 0x0425
    1978:	50 e0       	ldi	r21, 0x00	; 0
    197a:	60 e0       	ldi	r22, 0x00	; 0
    197c:	70 e0       	ldi	r23, 0x00	; 0
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
    197e:	f8 01       	movw	r30, r16
    1980:	11 82       	std	Z+1, r1	; 0x01
    1982:	10 82       	st	Z, r1
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    1984:	41 15       	cp	r20, r1
    1986:	51 05       	cpc	r21, r1
    1988:	61 05       	cpc	r22, r1
    198a:	71 05       	cpc	r23, r1
    198c:	09 f0       	breq	.+2      	; 0x1990 <chk_mounted+0x88>
    198e:	a3 c3       	rjmp	.+1862   	; 0x20d6 <chk_mounted+0x7ce>
		return FR_INVALID_DRIVE;
	fs = FatFs[vol];					/* Get corresponding file system object */
    1990:	e0 90 23 04 	lds	r14, 0x0423
    1994:	f0 90 24 04 	lds	r15, 0x0424
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    1998:	e1 14       	cp	r14, r1
    199a:	f1 04       	cpc	r15, r1
    199c:	09 f4       	brne	.+2      	; 0x19a0 <chk_mounted+0x98>
    199e:	9d c3       	rjmp	.+1850   	; 0x20da <chk_mounted+0x7d2>

	ENTER_FF(fs);						/* Lock file system */

	*rfs = fs;							/* Return pointer to the corresponding file system object */
    19a0:	f1 82       	std	Z+1, r15	; 0x01
    19a2:	e0 82       	st	Z, r14
	if (fs->fs_type) {					/* If the volume has been mounted */
    19a4:	d7 01       	movw	r26, r14
    19a6:	8c 91       	ld	r24, X
    19a8:	88 23       	and	r24, r24
    19aa:	69 f0       	breq	.+26     	; 0x19c6 <chk_mounted+0xbe>
		stat = disk_status(fs->drv);
    19ac:	11 96       	adiw	r26, 0x01	; 1
    19ae:	8c 91       	ld	r24, X
    19b0:	0e 94 92 02 	call	0x524	; 0x524 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    19b4:	80 fd       	sbrc	r24, 0
    19b6:	07 c0       	rjmp	.+14     	; 0x19c6 <chk_mounted+0xbe>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
    19b8:	dd 20       	and	r13, r13
    19ba:	09 f4       	brne	.+2      	; 0x19be <chk_mounted+0xb6>
    19bc:	90 c3       	rjmp	.+1824   	; 0x20de <chk_mounted+0x7d6>
    19be:	82 fd       	sbrc	r24, 2
    19c0:	90 c3       	rjmp	.+1824   	; 0x20e2 <chk_mounted+0x7da>
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
    19c2:	80 e0       	ldi	r24, 0x00	; 0
    19c4:	af c3       	rjmp	.+1886   	; 0x2124 <chk_mounted+0x81c>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
    19c6:	f7 01       	movw	r30, r14
    19c8:	10 82       	st	Z, r1
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    19ca:	11 82       	std	Z+1, r1	; 0x01
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
    19cc:	80 e0       	ldi	r24, 0x00	; 0
    19ce:	0e 94 c2 01 	call	0x384	; 0x384 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    19d2:	80 fd       	sbrc	r24, 0
    19d4:	88 c3       	rjmp	.+1808   	; 0x20e6 <chk_mounted+0x7de>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    19d6:	dd 20       	and	r13, r13
    19d8:	11 f0       	breq	.+4      	; 0x19de <chk_mounted+0xd6>
    19da:	82 fd       	sbrc	r24, 2
    19dc:	86 c3       	rjmp	.+1804   	; 0x20ea <chk_mounted+0x7e2>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    19de:	c7 01       	movw	r24, r14
    19e0:	40 e0       	ldi	r20, 0x00	; 0
    19e2:	50 e0       	ldi	r21, 0x00	; 0
    19e4:	ba 01       	movw	r22, r20
    19e6:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <check_fs>
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    19ea:	81 30       	cpi	r24, 0x01	; 1
    19ec:	e9 f5       	brne	.+122    	; 0x1a68 <chk_mounted+0x160>
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
    19ee:	f7 01       	movw	r30, r14
    19f0:	ec 50       	subi	r30, 0x0C	; 12
    19f2:	fe 4f       	sbci	r31, 0xFE	; 254
    19f4:	80 81       	ld	r24, Z
    19f6:	88 23       	and	r24, r24
    19f8:	09 f4       	brne	.+2      	; 0x19fc <chk_mounted+0xf4>
    19fa:	79 c3       	rjmp	.+1778   	; 0x20ee <chk_mounted+0x7e6>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    19fc:	f7 01       	movw	r30, r14
    19fe:	e5 50       	subi	r30, 0x05	; 5
    1a00:	fe 4f       	sbci	r31, 0xFE	; 254
    1a02:	80 81       	ld	r24, Z
    1a04:	90 e0       	ldi	r25, 0x00	; 0
    1a06:	a0 e0       	ldi	r26, 0x00	; 0
    1a08:	b0 e0       	ldi	r27, 0x00	; 0
    1a0a:	b8 2f       	mov	r27, r24
    1a0c:	aa 27       	eor	r26, r26
    1a0e:	99 27       	eor	r25, r25
    1a10:	88 27       	eor	r24, r24
    1a12:	f7 01       	movw	r30, r14
    1a14:	e6 50       	subi	r30, 0x06	; 6
    1a16:	fe 4f       	sbci	r31, 0xFE	; 254
    1a18:	40 81       	ld	r20, Z
    1a1a:	50 e0       	ldi	r21, 0x00	; 0
    1a1c:	60 e0       	ldi	r22, 0x00	; 0
    1a1e:	70 e0       	ldi	r23, 0x00	; 0
    1a20:	ba 01       	movw	r22, r20
    1a22:	55 27       	eor	r21, r21
    1a24:	44 27       	eor	r20, r20
    1a26:	84 2b       	or	r24, r20
    1a28:	95 2b       	or	r25, r21
    1a2a:	a6 2b       	or	r26, r22
    1a2c:	b7 2b       	or	r27, r23
    1a2e:	f7 01       	movw	r30, r14
    1a30:	e8 50       	subi	r30, 0x08	; 8
    1a32:	fe 4f       	sbci	r31, 0xFE	; 254
    1a34:	40 81       	ld	r20, Z
    1a36:	50 e0       	ldi	r21, 0x00	; 0
    1a38:	60 e0       	ldi	r22, 0x00	; 0
    1a3a:	70 e0       	ldi	r23, 0x00	; 0
    1a3c:	48 2b       	or	r20, r24
    1a3e:	59 2b       	or	r21, r25
    1a40:	6a 2b       	or	r22, r26
    1a42:	7b 2b       	or	r23, r27
    1a44:	f7 01       	movw	r30, r14
    1a46:	e7 50       	subi	r30, 0x07	; 7
    1a48:	fe 4f       	sbci	r31, 0xFE	; 254
    1a4a:	90 81       	ld	r25, Z
    1a4c:	80 e0       	ldi	r24, 0x00	; 0
    1a4e:	4c 01       	movw	r8, r24
    1a50:	aa 24       	eor	r10, r10
    1a52:	bb 24       	eor	r11, r11
    1a54:	84 2a       	or	r8, r20
    1a56:	95 2a       	or	r9, r21
    1a58:	a6 2a       	or	r10, r22
    1a5a:	b7 2a       	or	r11, r23
			fmt = check_fs(fs, bsect);		/* Check the partition */
    1a5c:	c7 01       	movw	r24, r14
    1a5e:	b5 01       	movw	r22, r10
    1a60:	a4 01       	movw	r20, r8
    1a62:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <check_fs>
    1a66:	03 c0       	rjmp	.+6      	; 0x1a6e <chk_mounted+0x166>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    1a68:	88 24       	eor	r8, r8
    1a6a:	99 24       	eor	r9, r9
    1a6c:	54 01       	movw	r10, r8
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    1a6e:	83 30       	cpi	r24, 0x03	; 3
    1a70:	09 f4       	brne	.+2      	; 0x1a74 <chk_mounted+0x16c>
    1a72:	3f c3       	rjmp	.+1662   	; 0x20f2 <chk_mounted+0x7ea>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    1a74:	88 23       	and	r24, r24
    1a76:	09 f0       	breq	.+2      	; 0x1a7a <chk_mounted+0x172>
    1a78:	3e c3       	rjmp	.+1660   	; 0x20f6 <chk_mounted+0x7ee>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    1a7a:	d7 01       	movw	r26, r14
    1a7c:	de 96       	adiw	r26, 0x3e	; 62
    1a7e:	9c 91       	ld	r25, X
    1a80:	de 97       	sbiw	r26, 0x3e	; 62
    1a82:	80 e0       	ldi	r24, 0x00	; 0
    1a84:	dd 96       	adiw	r26, 0x3d	; 61
    1a86:	2c 91       	ld	r18, X
    1a88:	dd 97       	sbiw	r26, 0x3d	; 61
    1a8a:	30 e0       	ldi	r19, 0x00	; 0
    1a8c:	82 2b       	or	r24, r18
    1a8e:	93 2b       	or	r25, r19
    1a90:	b2 e0       	ldi	r27, 0x02	; 2
    1a92:	80 30       	cpi	r24, 0x00	; 0
    1a94:	9b 07       	cpc	r25, r27
    1a96:	09 f0       	breq	.+2      	; 0x1a9a <chk_mounted+0x192>
    1a98:	30 c3       	rjmp	.+1632   	; 0x20fa <chk_mounted+0x7f2>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    1a9a:	f7 01       	movw	r30, r14
    1a9c:	e7 5b       	subi	r30, 0xB7	; 183
    1a9e:	ff 4f       	sbci	r31, 0xFF	; 255
    1aa0:	30 81       	ld	r19, Z
    1aa2:	20 e0       	ldi	r18, 0x00	; 0
    1aa4:	f7 01       	movw	r30, r14
    1aa6:	e8 5b       	subi	r30, 0xB8	; 184
    1aa8:	ff 4f       	sbci	r31, 0xFF	; 255
    1aaa:	80 81       	ld	r24, Z
    1aac:	90 e0       	ldi	r25, 0x00	; 0
    1aae:	82 2b       	or	r24, r18
    1ab0:	93 2b       	or	r25, r19
    1ab2:	2c 01       	movw	r4, r24
    1ab4:	66 24       	eor	r6, r6
    1ab6:	77 24       	eor	r7, r7
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    1ab8:	41 14       	cp	r4, r1
    1aba:	51 04       	cpc	r5, r1
    1abc:	61 04       	cpc	r6, r1
    1abe:	71 04       	cpc	r7, r1
    1ac0:	89 f5       	brne	.+98     	; 0x1b24 <chk_mounted+0x21c>
    1ac2:	f7 01       	movw	r30, r14
    1ac4:	e7 5a       	subi	r30, 0xA7	; 167
    1ac6:	ff 4f       	sbci	r31, 0xFF	; 255
    1ac8:	40 81       	ld	r20, Z
    1aca:	50 e0       	ldi	r21, 0x00	; 0
    1acc:	60 e0       	ldi	r22, 0x00	; 0
    1ace:	70 e0       	ldi	r23, 0x00	; 0
    1ad0:	74 2f       	mov	r23, r20
    1ad2:	66 27       	eor	r22, r22
    1ad4:	55 27       	eor	r21, r21
    1ad6:	44 27       	eor	r20, r20
    1ad8:	f7 01       	movw	r30, r14
    1ada:	e8 5a       	subi	r30, 0xA8	; 168
    1adc:	ff 4f       	sbci	r31, 0xFF	; 255
    1ade:	80 81       	ld	r24, Z
    1ae0:	90 e0       	ldi	r25, 0x00	; 0
    1ae2:	a0 e0       	ldi	r26, 0x00	; 0
    1ae4:	b0 e0       	ldi	r27, 0x00	; 0
    1ae6:	dc 01       	movw	r26, r24
    1ae8:	99 27       	eor	r25, r25
    1aea:	88 27       	eor	r24, r24
    1aec:	48 2b       	or	r20, r24
    1aee:	59 2b       	or	r21, r25
    1af0:	6a 2b       	or	r22, r26
    1af2:	7b 2b       	or	r23, r27
    1af4:	f7 01       	movw	r30, r14
    1af6:	ea 5a       	subi	r30, 0xAA	; 170
    1af8:	ff 4f       	sbci	r31, 0xFF	; 255
    1afa:	80 81       	ld	r24, Z
    1afc:	90 e0       	ldi	r25, 0x00	; 0
    1afe:	a0 e0       	ldi	r26, 0x00	; 0
    1b00:	b0 e0       	ldi	r27, 0x00	; 0
    1b02:	48 2b       	or	r20, r24
    1b04:	59 2b       	or	r21, r25
    1b06:	6a 2b       	or	r22, r26
    1b08:	7b 2b       	or	r23, r27
    1b0a:	f7 01       	movw	r30, r14
    1b0c:	e9 5a       	subi	r30, 0xA9	; 169
    1b0e:	ff 4f       	sbci	r31, 0xFF	; 255
    1b10:	90 81       	ld	r25, Z
    1b12:	80 e0       	ldi	r24, 0x00	; 0
    1b14:	a0 e0       	ldi	r26, 0x00	; 0
    1b16:	b0 e0       	ldi	r27, 0x00	; 0
    1b18:	2a 01       	movw	r4, r20
    1b1a:	3b 01       	movw	r6, r22
    1b1c:	48 2a       	or	r4, r24
    1b1e:	59 2a       	or	r5, r25
    1b20:	6a 2a       	or	r6, r26
    1b22:	7b 2a       	or	r7, r27
	fs->fsize = fasize;
    1b24:	f7 01       	movw	r30, r14
    1b26:	46 8e       	std	Z+30, r4	; 0x1e
    1b28:	57 8e       	std	Z+31, r5	; 0x1f
    1b2a:	60 a2       	lds	r22, 0x90
    1b2c:	71 a2       	lds	r23, 0x91

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    1b2e:	ee 5b       	subi	r30, 0xBE	; 190
    1b30:	ff 4f       	sbci	r31, 0xFF	; 255
    1b32:	c0 80       	ld	r12, Z
    1b34:	d7 01       	movw	r26, r14
    1b36:	13 96       	adiw	r26, 0x03	; 3
    1b38:	cc 92       	st	X, r12
    1b3a:	13 97       	sbiw	r26, 0x03	; 3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    1b3c:	8c 2d       	mov	r24, r12
    1b3e:	81 50       	subi	r24, 0x01	; 1
    1b40:	82 30       	cpi	r24, 0x02	; 2
    1b42:	08 f0       	brcs	.+2      	; 0x1b46 <chk_mounted+0x23e>
    1b44:	dc c2       	rjmp	.+1464   	; 0x20fe <chk_mounted+0x7f6>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    1b46:	df 96       	adiw	r26, 0x3f	; 63
    1b48:	dc 90       	ld	r13, X
    1b4a:	df 97       	sbiw	r26, 0x3f	; 63
    1b4c:	12 96       	adiw	r26, 0x02	; 2
    1b4e:	dc 92       	st	X, r13
    1b50:	12 97       	sbiw	r26, 0x02	; 2
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    1b52:	dd 20       	and	r13, r13
    1b54:	09 f4       	brne	.+2      	; 0x1b58 <chk_mounted+0x250>
    1b56:	d5 c2       	rjmp	.+1450   	; 0x2102 <chk_mounted+0x7fa>
    1b58:	8d 2d       	mov	r24, r13
    1b5a:	90 e0       	ldi	r25, 0x00	; 0
    1b5c:	9c 01       	movw	r18, r24
    1b5e:	21 50       	subi	r18, 0x01	; 1
    1b60:	30 40       	sbci	r19, 0x00	; 0
    1b62:	82 23       	and	r24, r18
    1b64:	93 23       	and	r25, r19
    1b66:	00 97       	sbiw	r24, 0x00	; 0
    1b68:	09 f0       	breq	.+2      	; 0x1b6c <chk_mounted+0x264>
    1b6a:	cd c2       	rjmp	.+1434   	; 0x2106 <chk_mounted+0x7fe>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    1b6c:	f7 01       	movw	r30, r14
    1b6e:	ec 5b       	subi	r30, 0xBC	; 188
    1b70:	ff 4f       	sbci	r31, 0xFF	; 255
    1b72:	30 81       	ld	r19, Z
    1b74:	20 e0       	ldi	r18, 0x00	; 0
    1b76:	f7 01       	movw	r30, r14
    1b78:	ed 5b       	subi	r30, 0xBD	; 189
    1b7a:	ff 4f       	sbci	r31, 0xFF	; 255
    1b7c:	80 81       	ld	r24, Z
    1b7e:	90 e0       	ldi	r25, 0x00	; 0
    1b80:	19 01       	movw	r2, r18
    1b82:	28 2a       	or	r2, r24
    1b84:	39 2a       	or	r3, r25
    1b86:	f7 01       	movw	r30, r14
    1b88:	31 86       	std	Z+9, r3	; 0x09
    1b8a:	20 86       	std	Z+8, r2	; 0x08
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    1b8c:	c1 01       	movw	r24, r2
    1b8e:	8f 70       	andi	r24, 0x0F	; 15
    1b90:	90 70       	andi	r25, 0x00	; 0
    1b92:	00 97       	sbiw	r24, 0x00	; 0
    1b94:	09 f0       	breq	.+2      	; 0x1b98 <chk_mounted+0x290>
    1b96:	b9 c2       	rjmp	.+1394   	; 0x210a <chk_mounted+0x802>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    1b98:	ea 5b       	subi	r30, 0xBA	; 186
    1b9a:	ff 4f       	sbci	r31, 0xFF	; 255
    1b9c:	30 81       	ld	r19, Z
    1b9e:	20 e0       	ldi	r18, 0x00	; 0
    1ba0:	f7 01       	movw	r30, r14
    1ba2:	eb 5b       	subi	r30, 0xBB	; 187
    1ba4:	ff 4f       	sbci	r31, 0xFF	; 255
    1ba6:	80 81       	ld	r24, Z
    1ba8:	90 e0       	ldi	r25, 0x00	; 0
    1baa:	82 2b       	or	r24, r18
    1bac:	93 2b       	or	r25, r19
    1bae:	8c 01       	movw	r16, r24
    1bb0:	20 e0       	ldi	r18, 0x00	; 0
    1bb2:	30 e0       	ldi	r19, 0x00	; 0
    1bb4:	09 83       	std	Y+1, r16	; 0x01
    1bb6:	1a 83       	std	Y+2, r17	; 0x02
    1bb8:	2b 83       	std	Y+3, r18	; 0x03
    1bba:	3c 83       	std	Y+4, r19	; 0x04
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    1bbc:	01 15       	cp	r16, r1
    1bbe:	11 05       	cpc	r17, r1
    1bc0:	21 05       	cpc	r18, r1
    1bc2:	31 05       	cpc	r19, r1
    1bc4:	a9 f5       	brne	.+106    	; 0x1c30 <chk_mounted+0x328>
    1bc6:	f7 01       	movw	r30, r14
    1bc8:	eb 5a       	subi	r30, 0xAB	; 171
    1bca:	ff 4f       	sbci	r31, 0xFF	; 255
    1bcc:	80 81       	ld	r24, Z
    1bce:	90 e0       	ldi	r25, 0x00	; 0
    1bd0:	a0 e0       	ldi	r26, 0x00	; 0
    1bd2:	b0 e0       	ldi	r27, 0x00	; 0
    1bd4:	78 2f       	mov	r23, r24
    1bd6:	66 27       	eor	r22, r22
    1bd8:	55 27       	eor	r21, r21
    1bda:	44 27       	eor	r20, r20
    1bdc:	f7 01       	movw	r30, r14
    1bde:	ec 5a       	subi	r30, 0xAC	; 172
    1be0:	ff 4f       	sbci	r31, 0xFF	; 255
    1be2:	80 81       	ld	r24, Z
    1be4:	90 e0       	ldi	r25, 0x00	; 0
    1be6:	a0 e0       	ldi	r26, 0x00	; 0
    1be8:	b0 e0       	ldi	r27, 0x00	; 0
    1bea:	dc 01       	movw	r26, r24
    1bec:	99 27       	eor	r25, r25
    1bee:	88 27       	eor	r24, r24
    1bf0:	48 2b       	or	r20, r24
    1bf2:	59 2b       	or	r21, r25
    1bf4:	6a 2b       	or	r22, r26
    1bf6:	7b 2b       	or	r23, r27
    1bf8:	f7 01       	movw	r30, r14
    1bfa:	ee 5a       	subi	r30, 0xAE	; 174
    1bfc:	ff 4f       	sbci	r31, 0xFF	; 255
    1bfe:	80 81       	ld	r24, Z
    1c00:	90 e0       	ldi	r25, 0x00	; 0
    1c02:	a0 e0       	ldi	r26, 0x00	; 0
    1c04:	b0 e0       	ldi	r27, 0x00	; 0
    1c06:	48 2b       	or	r20, r24
    1c08:	59 2b       	or	r21, r25
    1c0a:	6a 2b       	or	r22, r26
    1c0c:	7b 2b       	or	r23, r27
    1c0e:	f7 01       	movw	r30, r14
    1c10:	ed 5a       	subi	r30, 0xAD	; 173
    1c12:	ff 4f       	sbci	r31, 0xFF	; 255
    1c14:	90 81       	ld	r25, Z
    1c16:	80 e0       	ldi	r24, 0x00	; 0
    1c18:	a0 e0       	ldi	r26, 0x00	; 0
    1c1a:	b0 e0       	ldi	r27, 0x00	; 0
    1c1c:	8a 01       	movw	r16, r20
    1c1e:	9b 01       	movw	r18, r22
    1c20:	08 2b       	or	r16, r24
    1c22:	19 2b       	or	r17, r25
    1c24:	2a 2b       	or	r18, r26
    1c26:	3b 2b       	or	r19, r27
    1c28:	09 83       	std	Y+1, r16	; 0x01
    1c2a:	1a 83       	std	Y+2, r17	; 0x02
    1c2c:	2b 83       	std	Y+3, r18	; 0x03
    1c2e:	3c 83       	std	Y+4, r19	; 0x04

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    1c30:	f7 01       	movw	r30, r14
    1c32:	ef 5b       	subi	r30, 0xBF	; 191
    1c34:	ff 4f       	sbci	r31, 0xFF	; 255
    1c36:	30 81       	ld	r19, Z
    1c38:	20 e0       	ldi	r18, 0x00	; 0
    1c3a:	f7 01       	movw	r30, r14
    1c3c:	e0 5c       	subi	r30, 0xC0	; 192
    1c3e:	ff 4f       	sbci	r31, 0xFF	; 255
    1c40:	80 81       	ld	r24, Z
    1c42:	90 e0       	ldi	r25, 0x00	; 0
    1c44:	89 01       	movw	r16, r18
    1c46:	08 2b       	or	r16, r24
    1c48:	19 2b       	or	r17, r25
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    1c4a:	01 15       	cp	r16, r1
    1c4c:	11 05       	cpc	r17, r1
    1c4e:	09 f4       	brne	.+2      	; 0x1c52 <chk_mounted+0x34a>
    1c50:	5e c2       	rjmp	.+1212   	; 0x210e <chk_mounted+0x806>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
    1c52:	2c 2d       	mov	r18, r12
    1c54:	30 e0       	ldi	r19, 0x00	; 0
    1c56:	40 e0       	ldi	r20, 0x00	; 0
    1c58:	50 e0       	ldi	r21, 0x00	; 0
    1c5a:	c3 01       	movw	r24, r6
    1c5c:	b2 01       	movw	r22, r4
    1c5e:	0e 94 30 2c 	call	0x5860	; 0x5860 <__mulsi3>
    1c62:	6d 87       	std	Y+13, r22	; 0x0d
    1c64:	7e 87       	std	Y+14, r23	; 0x0e
    1c66:	8f 87       	std	Y+15, r24	; 0x0f
    1c68:	98 8b       	std	Y+16, r25	; 0x10

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    1c6a:	98 01       	movw	r18, r16
    1c6c:	40 e0       	ldi	r20, 0x00	; 0
    1c6e:	50 e0       	ldi	r21, 0x00	; 0
    1c70:	29 87       	std	Y+9, r18	; 0x09
    1c72:	3a 87       	std	Y+10, r19	; 0x0a
    1c74:	4b 87       	std	Y+11, r20	; 0x0b
    1c76:	5c 87       	std	Y+12, r21	; 0x0c
    1c78:	c1 01       	movw	r24, r2
    1c7a:	92 95       	swap	r25
    1c7c:	82 95       	swap	r24
    1c7e:	8f 70       	andi	r24, 0x0F	; 15
    1c80:	89 27       	eor	r24, r25
    1c82:	9f 70       	andi	r25, 0x0F	; 15
    1c84:	89 27       	eor	r24, r25
    1c86:	a0 e0       	ldi	r26, 0x00	; 0
    1c88:	b0 e0       	ldi	r27, 0x00	; 0
    1c8a:	82 0f       	add	r24, r18
    1c8c:	93 1f       	adc	r25, r19
    1c8e:	a4 1f       	adc	r26, r20
    1c90:	b5 1f       	adc	r27, r21
    1c92:	0d 85       	ldd	r16, Y+13	; 0x0d
    1c94:	1e 85       	ldd	r17, Y+14	; 0x0e
    1c96:	2f 85       	ldd	r18, Y+15	; 0x0f
    1c98:	38 89       	ldd	r19, Y+16	; 0x10
    1c9a:	08 0f       	add	r16, r24
    1c9c:	19 1f       	adc	r17, r25
    1c9e:	2a 1f       	adc	r18, r26
    1ca0:	3b 1f       	adc	r19, r27
    1ca2:	0d 83       	std	Y+5, r16	; 0x05
    1ca4:	1e 83       	std	Y+6, r17	; 0x06
    1ca6:	2f 83       	std	Y+7, r18	; 0x07
    1ca8:	38 87       	std	Y+8, r19	; 0x08
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    1caa:	89 81       	ldd	r24, Y+1	; 0x01
    1cac:	9a 81       	ldd	r25, Y+2	; 0x02
    1cae:	ab 81       	ldd	r26, Y+3	; 0x03
    1cb0:	bc 81       	ldd	r27, Y+4	; 0x04
    1cb2:	80 17       	cp	r24, r16
    1cb4:	91 07       	cpc	r25, r17
    1cb6:	a2 07       	cpc	r26, r18
    1cb8:	b3 07       	cpc	r27, r19
    1cba:	08 f4       	brcc	.+2      	; 0x1cbe <chk_mounted+0x3b6>
    1cbc:	2a c2       	rjmp	.+1108   	; 0x2112 <chk_mounted+0x80a>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    1cbe:	bc 01       	movw	r22, r24
    1cc0:	cd 01       	movw	r24, r26
    1cc2:	60 1b       	sub	r22, r16
    1cc4:	71 0b       	sbc	r23, r17
    1cc6:	82 0b       	sbc	r24, r18
    1cc8:	93 0b       	sbc	r25, r19
    1cca:	2d 2d       	mov	r18, r13
    1ccc:	30 e0       	ldi	r19, 0x00	; 0
    1cce:	40 e0       	ldi	r20, 0x00	; 0
    1cd0:	50 e0       	ldi	r21, 0x00	; 0
    1cd2:	0e 94 4f 2c 	call	0x589e	; 0x589e <__udivmodsi4>
    1cd6:	89 01       	movw	r16, r18
    1cd8:	9a 01       	movw	r18, r20
    1cda:	d9 01       	movw	r26, r18
    1cdc:	c8 01       	movw	r24, r16
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    1cde:	01 15       	cp	r16, r1
    1ce0:	11 05       	cpc	r17, r1
    1ce2:	21 05       	cpc	r18, r1
    1ce4:	31 05       	cpc	r19, r1
    1ce6:	09 f4       	brne	.+2      	; 0x1cea <chk_mounted+0x3e2>
    1ce8:	16 c2       	rjmp	.+1068   	; 0x2116 <chk_mounted+0x80e>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    1cea:	06 3f       	cpi	r16, 0xF6	; 246
    1cec:	ef e0       	ldi	r30, 0x0F	; 15
    1cee:	1e 07       	cpc	r17, r30
    1cf0:	e0 e0       	ldi	r30, 0x00	; 0
    1cf2:	2e 07       	cpc	r18, r30
    1cf4:	e0 e0       	ldi	r30, 0x00	; 0
    1cf6:	3e 07       	cpc	r19, r30
    1cf8:	18 f4       	brcc	.+6      	; 0x1d00 <chk_mounted+0x3f8>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
    1cfa:	dd 24       	eor	r13, r13
    1cfc:	d3 94       	inc	r13
    1cfe:	03 c0       	rjmp	.+6      	; 0x1d06 <chk_mounted+0x3fe>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    1d00:	dd 24       	eor	r13, r13
    1d02:	68 94       	set
    1d04:	d1 f8       	bld	r13, 1
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    1d06:	86 3f       	cpi	r24, 0xF6	; 246
    1d08:	ff ef       	ldi	r31, 0xFF	; 255
    1d0a:	9f 07       	cpc	r25, r31
    1d0c:	f0 e0       	ldi	r31, 0x00	; 0
    1d0e:	af 07       	cpc	r26, r31
    1d10:	f0 e0       	ldi	r31, 0x00	; 0
    1d12:	bf 07       	cpc	r27, r31
    1d14:	08 f0       	brcs	.+2      	; 0x1d18 <chk_mounted+0x410>
    1d16:	1f c2       	rjmp	.+1086   	; 0x2156 <chk_mounted+0x84e>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    1d18:	b9 01       	movw	r22, r18
    1d1a:	a8 01       	movw	r20, r16
    1d1c:	4e 5f       	subi	r20, 0xFE	; 254
    1d1e:	5f 4f       	sbci	r21, 0xFF	; 255
    1d20:	6f 4f       	sbci	r22, 0xFF	; 255
    1d22:	7f 4f       	sbci	r23, 0xFF	; 255
    1d24:	d7 01       	movw	r26, r14
    1d26:	5a 96       	adiw	r26, 0x1a	; 26
    1d28:	4d 93       	st	X+, r20
    1d2a:	5d 93       	st	X+, r21
    1d2c:	6d 93       	st	X+, r22
    1d2e:	7c 93       	st	X, r23
    1d30:	5d 97       	sbiw	r26, 0x1d	; 29
	fs->database = bsect + sysect;						/* Data start sector */
    1d32:	8d 81       	ldd	r24, Y+5	; 0x05
    1d34:	9e 81       	ldd	r25, Y+6	; 0x06
    1d36:	af 81       	ldd	r26, Y+7	; 0x07
    1d38:	b8 85       	ldd	r27, Y+8	; 0x08
    1d3a:	88 0d       	add	r24, r8
    1d3c:	99 1d       	adc	r25, r9
    1d3e:	aa 1d       	adc	r26, r10
    1d40:	bb 1d       	adc	r27, r11
    1d42:	f7 01       	movw	r30, r14
    1d44:	82 a7       	lds	r24, 0x72
    1d46:	93 a7       	lds	r25, 0x73
    1d48:	a4 a7       	lds	r26, 0x74
    1d4a:	b5 a7       	lds	r27, 0x75
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    1d4c:	89 85       	ldd	r24, Y+9	; 0x09
    1d4e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d50:	ab 85       	ldd	r26, Y+11	; 0x0b
    1d52:	bc 85       	ldd	r27, Y+12	; 0x0c
    1d54:	88 0d       	add	r24, r8
    1d56:	99 1d       	adc	r25, r9
    1d58:	aa 1d       	adc	r26, r10
    1d5a:	bb 1d       	adc	r27, r11
    1d5c:	82 a3       	lds	r24, 0x52
    1d5e:	93 a3       	lds	r25, 0x53
    1d60:	a4 a3       	lds	r26, 0x54
    1d62:	b5 a3       	lds	r27, 0x55
	if (fmt == FS_FAT32) {
    1d64:	f3 e0       	ldi	r31, 0x03	; 3
    1d66:	df 16       	cp	r13, r31
    1d68:	09 f0       	breq	.+2      	; 0x1d6c <chk_mounted+0x464>
    1d6a:	41 c0       	rjmp	.+130    	; 0x1dee <chk_mounted+0x4e6>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    1d6c:	21 14       	cp	r2, r1
    1d6e:	31 04       	cpc	r3, r1
    1d70:	09 f0       	breq	.+2      	; 0x1d74 <chk_mounted+0x46c>
    1d72:	d3 c1       	rjmp	.+934    	; 0x211a <chk_mounted+0x812>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    1d74:	f7 01       	movw	r30, r14
    1d76:	ef 59       	subi	r30, 0x9F	; 159
    1d78:	ff 4f       	sbci	r31, 0xFF	; 255
    1d7a:	80 81       	ld	r24, Z
    1d7c:	90 e0       	ldi	r25, 0x00	; 0
    1d7e:	a0 e0       	ldi	r26, 0x00	; 0
    1d80:	b0 e0       	ldi	r27, 0x00	; 0
    1d82:	38 2f       	mov	r19, r24
    1d84:	22 27       	eor	r18, r18
    1d86:	11 27       	eor	r17, r17
    1d88:	00 27       	eor	r16, r16
    1d8a:	f7 01       	movw	r30, r14
    1d8c:	e0 5a       	subi	r30, 0xA0	; 160
    1d8e:	ff 4f       	sbci	r31, 0xFF	; 255
    1d90:	80 81       	ld	r24, Z
    1d92:	90 e0       	ldi	r25, 0x00	; 0
    1d94:	a0 e0       	ldi	r26, 0x00	; 0
    1d96:	b0 e0       	ldi	r27, 0x00	; 0
    1d98:	dc 01       	movw	r26, r24
    1d9a:	99 27       	eor	r25, r25
    1d9c:	88 27       	eor	r24, r24
    1d9e:	08 2b       	or	r16, r24
    1da0:	19 2b       	or	r17, r25
    1da2:	2a 2b       	or	r18, r26
    1da4:	3b 2b       	or	r19, r27
    1da6:	f7 01       	movw	r30, r14
    1da8:	e2 5a       	subi	r30, 0xA2	; 162
    1daa:	ff 4f       	sbci	r31, 0xFF	; 255
    1dac:	80 81       	ld	r24, Z
    1dae:	90 e0       	ldi	r25, 0x00	; 0
    1db0:	a0 e0       	ldi	r26, 0x00	; 0
    1db2:	b0 e0       	ldi	r27, 0x00	; 0
    1db4:	08 2b       	or	r16, r24
    1db6:	19 2b       	or	r17, r25
    1db8:	2a 2b       	or	r18, r26
    1dba:	3b 2b       	or	r19, r27
    1dbc:	f7 01       	movw	r30, r14
    1dbe:	e1 5a       	subi	r30, 0xA1	; 161
    1dc0:	ff 4f       	sbci	r31, 0xFF	; 255
    1dc2:	90 81       	ld	r25, Z
    1dc4:	80 e0       	ldi	r24, 0x00	; 0
    1dc6:	a0 e0       	ldi	r26, 0x00	; 0
    1dc8:	b0 e0       	ldi	r27, 0x00	; 0
    1dca:	80 2b       	or	r24, r16
    1dcc:	91 2b       	or	r25, r17
    1dce:	a2 2b       	or	r26, r18
    1dd0:	b3 2b       	or	r27, r19
    1dd2:	f7 01       	movw	r30, r14
    1dd4:	86 a3       	lds	r24, 0x56
    1dd6:	97 a3       	lds	r25, 0x57
    1dd8:	a0 a7       	lds	r26, 0x70
    1dda:	b1 a7       	lds	r27, 0x71
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    1ddc:	44 0f       	add	r20, r20
    1dde:	55 1f       	adc	r21, r21
    1de0:	66 1f       	adc	r22, r22
    1de2:	77 1f       	adc	r23, r23
    1de4:	44 0f       	add	r20, r20
    1de6:	55 1f       	adc	r21, r21
    1de8:	66 1f       	adc	r22, r22
    1dea:	77 1f       	adc	r23, r23
    1dec:	2f c0       	rjmp	.+94     	; 0x1e4c <chk_mounted+0x544>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    1dee:	21 14       	cp	r2, r1
    1df0:	31 04       	cpc	r3, r1
    1df2:	09 f4       	brne	.+2      	; 0x1df6 <chk_mounted+0x4ee>
    1df4:	94 c1       	rjmp	.+808    	; 0x211e <chk_mounted+0x816>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    1df6:	0d 85       	ldd	r16, Y+13	; 0x0d
    1df8:	1e 85       	ldd	r17, Y+14	; 0x0e
    1dfa:	2f 85       	ldd	r18, Y+15	; 0x0f
    1dfc:	38 89       	ldd	r19, Y+16	; 0x10
    1dfe:	80 0f       	add	r24, r16
    1e00:	91 1f       	adc	r25, r17
    1e02:	a2 1f       	adc	r26, r18
    1e04:	b3 1f       	adc	r27, r19
    1e06:	f7 01       	movw	r30, r14
    1e08:	86 a3       	lds	r24, 0x56
    1e0a:	97 a3       	lds	r25, 0x57
    1e0c:	a0 a7       	lds	r26, 0x70
    1e0e:	b1 a7       	lds	r27, 0x71
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    1e10:	f2 e0       	ldi	r31, 0x02	; 2
    1e12:	df 16       	cp	r13, r31
    1e14:	29 f4       	brne	.+10     	; 0x1e20 <chk_mounted+0x518>
    1e16:	44 0f       	add	r20, r20
    1e18:	55 1f       	adc	r21, r21
    1e1a:	66 1f       	adc	r22, r22
    1e1c:	77 1f       	adc	r23, r23
    1e1e:	16 c0       	rjmp	.+44     	; 0x1e4c <chk_mounted+0x544>
    1e20:	db 01       	movw	r26, r22
    1e22:	ca 01       	movw	r24, r20
    1e24:	88 0f       	add	r24, r24
    1e26:	99 1f       	adc	r25, r25
    1e28:	aa 1f       	adc	r26, r26
    1e2a:	bb 1f       	adc	r27, r27
    1e2c:	84 0f       	add	r24, r20
    1e2e:	95 1f       	adc	r25, r21
    1e30:	a6 1f       	adc	r26, r22
    1e32:	b7 1f       	adc	r27, r23
    1e34:	b6 95       	lsr	r27
    1e36:	a7 95       	ror	r26
    1e38:	97 95       	ror	r25
    1e3a:	87 95       	ror	r24
    1e3c:	41 70       	andi	r20, 0x01	; 1
    1e3e:	50 70       	andi	r21, 0x00	; 0
    1e40:	60 70       	andi	r22, 0x00	; 0
    1e42:	70 70       	andi	r23, 0x00	; 0
    1e44:	48 0f       	add	r20, r24
    1e46:	59 1f       	adc	r21, r25
    1e48:	6a 1f       	adc	r22, r26
    1e4a:	7b 1f       	adc	r23, r27
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    1e4c:	db 01       	movw	r26, r22
    1e4e:	ca 01       	movw	r24, r20
    1e50:	81 50       	subi	r24, 0x01	; 1
    1e52:	9e 4f       	sbci	r25, 0xFE	; 254
    1e54:	af 4f       	sbci	r26, 0xFF	; 255
    1e56:	bf 4f       	sbci	r27, 0xFF	; 255
    1e58:	07 2e       	mov	r0, r23
    1e5a:	79 e0       	ldi	r23, 0x09	; 9
    1e5c:	b6 95       	lsr	r27
    1e5e:	a7 95       	ror	r26
    1e60:	97 95       	ror	r25
    1e62:	87 95       	ror	r24
    1e64:	7a 95       	dec	r23
    1e66:	d1 f7       	brne	.-12     	; 0x1e5c <chk_mounted+0x554>
    1e68:	70 2d       	mov	r23, r0
    1e6a:	48 16       	cp	r4, r24
    1e6c:	59 06       	cpc	r5, r25
    1e6e:	6a 06       	cpc	r6, r26
    1e70:	7b 06       	cpc	r7, r27
    1e72:	08 f4       	brcc	.+2      	; 0x1e76 <chk_mounted+0x56e>
    1e74:	56 c1       	rjmp	.+684    	; 0x2122 <chk_mounted+0x81a>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
    1e76:	8f ef       	ldi	r24, 0xFF	; 255
    1e78:	9f ef       	ldi	r25, 0xFF	; 255
    1e7a:	dc 01       	movw	r26, r24
    1e7c:	f7 01       	movw	r30, r14
    1e7e:	86 87       	std	Z+14, r24	; 0x0e
    1e80:	97 87       	std	Z+15, r25	; 0x0f
    1e82:	a0 8b       	std	Z+16, r26	; 0x10
    1e84:	b1 8b       	std	Z+17, r27	; 0x11
	fs->last_clust = 0;
    1e86:	12 86       	std	Z+10, r1	; 0x0a
    1e88:	13 86       	std	Z+11, r1	; 0x0b
    1e8a:	14 86       	std	Z+12, r1	; 0x0c
    1e8c:	15 86       	std	Z+13, r1	; 0x0d

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
    1e8e:	b3 e0       	ldi	r27, 0x03	; 3
    1e90:	db 16       	cp	r13, r27
    1e92:	09 f0       	breq	.+2      	; 0x1e96 <chk_mounted+0x58e>
    1e94:	03 c1       	rjmp	.+518    	; 0x209c <chk_mounted+0x794>
	 	fs->fsi_flag = 0;
    1e96:	15 82       	std	Z+5, r1	; 0x05
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
    1e98:	ed 59       	subi	r30, 0x9D	; 157
    1e9a:	ff 4f       	sbci	r31, 0xFF	; 255
    1e9c:	30 81       	ld	r19, Z
    1e9e:	20 e0       	ldi	r18, 0x00	; 0
    1ea0:	f7 01       	movw	r30, r14
    1ea2:	ee 59       	subi	r30, 0x9E	; 158
    1ea4:	ff 4f       	sbci	r31, 0xFF	; 255
    1ea6:	80 81       	ld	r24, Z
    1ea8:	90 e0       	ldi	r25, 0x00	; 0
    1eaa:	82 2b       	or	r24, r18
    1eac:	93 2b       	or	r25, r19
    1eae:	a0 e0       	ldi	r26, 0x00	; 0
    1eb0:	b0 e0       	ldi	r27, 0x00	; 0
    1eb2:	a5 01       	movw	r20, r10
    1eb4:	94 01       	movw	r18, r8
    1eb6:	28 0f       	add	r18, r24
    1eb8:	39 1f       	adc	r19, r25
    1eba:	4a 1f       	adc	r20, r26
    1ebc:	5b 1f       	adc	r21, r27
    1ebe:	d7 01       	movw	r26, r14
    1ec0:	52 96       	adiw	r26, 0x12	; 18
    1ec2:	2d 93       	st	X+, r18
    1ec4:	3d 93       	st	X+, r19
    1ec6:	4d 93       	st	X+, r20
    1ec8:	5c 93       	st	X, r21
    1eca:	55 97       	sbiw	r26, 0x15	; 21
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    1ecc:	b7 01       	movw	r22, r14
    1ece:	6e 5c       	subi	r22, 0xCE	; 206
    1ed0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ed2:	11 96       	adiw	r26, 0x01	; 1
    1ed4:	8c 91       	ld	r24, X
    1ed6:	01 e0       	ldi	r16, 0x01	; 1
    1ed8:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    1edc:	88 23       	and	r24, r24
    1ede:	09 f0       	breq	.+2      	; 0x1ee2 <chk_mounted+0x5da>
    1ee0:	dd c0       	rjmp	.+442    	; 0x209c <chk_mounted+0x794>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
    1ee2:	f7 01       	movw	r30, r14
    1ee4:	ef 5c       	subi	r30, 0xCF	; 207
    1ee6:	fd 4f       	sbci	r31, 0xFD	; 253
    1ee8:	30 81       	ld	r19, Z
    1eea:	20 e0       	ldi	r18, 0x00	; 0
    1eec:	f7 01       	movw	r30, r14
    1eee:	e0 5d       	subi	r30, 0xD0	; 208
    1ef0:	fd 4f       	sbci	r31, 0xFD	; 253
    1ef2:	80 81       	ld	r24, Z
    1ef4:	90 e0       	ldi	r25, 0x00	; 0
    1ef6:	82 2b       	or	r24, r18
    1ef8:	93 2b       	or	r25, r19

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    1efa:	ba ea       	ldi	r27, 0xAA	; 170
    1efc:	85 35       	cpi	r24, 0x55	; 85
    1efe:	9b 07       	cpc	r25, r27
    1f00:	09 f0       	breq	.+2      	; 0x1f04 <chk_mounted+0x5fc>
    1f02:	cc c0       	rjmp	.+408    	; 0x209c <chk_mounted+0x794>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
    1f04:	f7 01       	movw	r30, r14
    1f06:	45 a9       	sts	0x45, r20
    1f08:	50 e0       	ldi	r21, 0x00	; 0
    1f0a:	60 e0       	ldi	r22, 0x00	; 0
    1f0c:	70 e0       	ldi	r23, 0x00	; 0
    1f0e:	74 2f       	mov	r23, r20
    1f10:	66 27       	eor	r22, r22
    1f12:	55 27       	eor	r21, r21
    1f14:	44 27       	eor	r20, r20
    1f16:	84 a9       	sts	0x44, r24
    1f18:	90 e0       	ldi	r25, 0x00	; 0
    1f1a:	a0 e0       	ldi	r26, 0x00	; 0
    1f1c:	b0 e0       	ldi	r27, 0x00	; 0
    1f1e:	dc 01       	movw	r26, r24
    1f20:	99 27       	eor	r25, r25
    1f22:	88 27       	eor	r24, r24
    1f24:	48 2b       	or	r20, r24
    1f26:	59 2b       	or	r21, r25
    1f28:	6a 2b       	or	r22, r26
    1f2a:	7b 2b       	or	r23, r27
    1f2c:	82 a9       	sts	0x42, r24
    1f2e:	90 e0       	ldi	r25, 0x00	; 0
    1f30:	a0 e0       	ldi	r26, 0x00	; 0
    1f32:	b0 e0       	ldi	r27, 0x00	; 0
    1f34:	48 2b       	or	r20, r24
    1f36:	59 2b       	or	r21, r25
    1f38:	6a 2b       	or	r22, r26
    1f3a:	7b 2b       	or	r23, r27
    1f3c:	93 a9       	sts	0x43, r25
    1f3e:	80 e0       	ldi	r24, 0x00	; 0
    1f40:	a0 e0       	ldi	r26, 0x00	; 0
    1f42:	b0 e0       	ldi	r27, 0x00	; 0
    1f44:	84 2b       	or	r24, r20
    1f46:	95 2b       	or	r25, r21
    1f48:	a6 2b       	or	r26, r22
    1f4a:	b7 2b       	or	r27, r23
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
    1f4c:	82 35       	cpi	r24, 0x52	; 82
    1f4e:	f2 e5       	ldi	r31, 0x52	; 82
    1f50:	9f 07       	cpc	r25, r31
    1f52:	f1 e6       	ldi	r31, 0x61	; 97
    1f54:	af 07       	cpc	r26, r31
    1f56:	f1 e4       	ldi	r31, 0x41	; 65
    1f58:	bf 07       	cpc	r27, r31
    1f5a:	09 f0       	breq	.+2      	; 0x1f5e <chk_mounted+0x656>
    1f5c:	9f c0       	rjmp	.+318    	; 0x209c <chk_mounted+0x794>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
    1f5e:	f7 01       	movw	r30, r14
    1f60:	e7 5e       	subi	r30, 0xE7	; 231
    1f62:	fd 4f       	sbci	r31, 0xFD	; 253
    1f64:	80 81       	ld	r24, Z
    1f66:	90 e0       	ldi	r25, 0x00	; 0
    1f68:	a0 e0       	ldi	r26, 0x00	; 0
    1f6a:	b0 e0       	ldi	r27, 0x00	; 0
    1f6c:	b8 2f       	mov	r27, r24
    1f6e:	aa 27       	eor	r26, r26
    1f70:	99 27       	eor	r25, r25
    1f72:	88 27       	eor	r24, r24
    1f74:	f7 01       	movw	r30, r14
    1f76:	e8 5e       	subi	r30, 0xE8	; 232
    1f78:	fd 4f       	sbci	r31, 0xFD	; 253
    1f7a:	40 81       	ld	r20, Z
    1f7c:	50 e0       	ldi	r21, 0x00	; 0
    1f7e:	60 e0       	ldi	r22, 0x00	; 0
    1f80:	70 e0       	ldi	r23, 0x00	; 0
    1f82:	ba 01       	movw	r22, r20
    1f84:	55 27       	eor	r21, r21
    1f86:	44 27       	eor	r20, r20
    1f88:	84 2b       	or	r24, r20
    1f8a:	95 2b       	or	r25, r21
    1f8c:	a6 2b       	or	r26, r22
    1f8e:	b7 2b       	or	r27, r23
    1f90:	f7 01       	movw	r30, r14
    1f92:	ea 5e       	subi	r30, 0xEA	; 234
    1f94:	fd 4f       	sbci	r31, 0xFD	; 253
    1f96:	40 81       	ld	r20, Z
    1f98:	50 e0       	ldi	r21, 0x00	; 0
    1f9a:	60 e0       	ldi	r22, 0x00	; 0
    1f9c:	70 e0       	ldi	r23, 0x00	; 0
    1f9e:	48 2b       	or	r20, r24
    1fa0:	59 2b       	or	r21, r25
    1fa2:	6a 2b       	or	r22, r26
    1fa4:	7b 2b       	or	r23, r27
    1fa6:	f7 01       	movw	r30, r14
    1fa8:	e9 5e       	subi	r30, 0xE9	; 233
    1faa:	fd 4f       	sbci	r31, 0xFD	; 253
    1fac:	90 81       	ld	r25, Z
    1fae:	80 e0       	ldi	r24, 0x00	; 0
    1fb0:	a0 e0       	ldi	r26, 0x00	; 0
    1fb2:	b0 e0       	ldi	r27, 0x00	; 0
    1fb4:	84 2b       	or	r24, r20
    1fb6:	95 2b       	or	r25, r21
    1fb8:	a6 2b       	or	r26, r22
    1fba:	b7 2b       	or	r27, r23
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
    1fbc:	82 37       	cpi	r24, 0x72	; 114
    1fbe:	02 e7       	ldi	r16, 0x72	; 114
    1fc0:	90 07       	cpc	r25, r16
    1fc2:	01 e4       	ldi	r16, 0x41	; 65
    1fc4:	a0 07       	cpc	r26, r16
    1fc6:	01 e6       	ldi	r16, 0x61	; 97
    1fc8:	b0 07       	cpc	r27, r16
    1fca:	09 f0       	breq	.+2      	; 0x1fce <chk_mounted+0x6c6>
    1fcc:	67 c0       	rjmp	.+206    	; 0x209c <chk_mounted+0x794>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
    1fce:	f7 01       	movw	r30, r14
    1fd0:	ef 5d       	subi	r30, 0xDF	; 223
    1fd2:	fd 4f       	sbci	r31, 0xFD	; 253
    1fd4:	80 81       	ld	r24, Z
    1fd6:	90 e0       	ldi	r25, 0x00	; 0
    1fd8:	a0 e0       	ldi	r26, 0x00	; 0
    1fda:	b0 e0       	ldi	r27, 0x00	; 0
    1fdc:	b8 2f       	mov	r27, r24
    1fde:	aa 27       	eor	r26, r26
    1fe0:	99 27       	eor	r25, r25
    1fe2:	88 27       	eor	r24, r24
    1fe4:	f7 01       	movw	r30, r14
    1fe6:	e0 5e       	subi	r30, 0xE0	; 224
    1fe8:	fd 4f       	sbci	r31, 0xFD	; 253
    1fea:	40 81       	ld	r20, Z
    1fec:	50 e0       	ldi	r21, 0x00	; 0
    1fee:	60 e0       	ldi	r22, 0x00	; 0
    1ff0:	70 e0       	ldi	r23, 0x00	; 0
    1ff2:	ba 01       	movw	r22, r20
    1ff4:	55 27       	eor	r21, r21
    1ff6:	44 27       	eor	r20, r20
    1ff8:	84 2b       	or	r24, r20
    1ffa:	95 2b       	or	r25, r21
    1ffc:	a6 2b       	or	r26, r22
    1ffe:	b7 2b       	or	r27, r23
    2000:	f7 01       	movw	r30, r14
    2002:	e2 5e       	subi	r30, 0xE2	; 226
    2004:	fd 4f       	sbci	r31, 0xFD	; 253
    2006:	40 81       	ld	r20, Z
    2008:	50 e0       	ldi	r21, 0x00	; 0
    200a:	60 e0       	ldi	r22, 0x00	; 0
    200c:	70 e0       	ldi	r23, 0x00	; 0
    200e:	48 2b       	or	r20, r24
    2010:	59 2b       	or	r21, r25
    2012:	6a 2b       	or	r22, r26
    2014:	7b 2b       	or	r23, r27
    2016:	f7 01       	movw	r30, r14
    2018:	e1 5e       	subi	r30, 0xE1	; 225
    201a:	fd 4f       	sbci	r31, 0xFD	; 253
    201c:	90 81       	ld	r25, Z
    201e:	80 e0       	ldi	r24, 0x00	; 0
    2020:	a0 e0       	ldi	r26, 0x00	; 0
    2022:	b0 e0       	ldi	r27, 0x00	; 0
    2024:	84 2b       	or	r24, r20
    2026:	95 2b       	or	r25, r21
    2028:	a6 2b       	or	r26, r22
    202a:	b7 2b       	or	r27, r23
    202c:	f7 01       	movw	r30, r14
    202e:	82 87       	std	Z+10, r24	; 0x0a
    2030:	93 87       	std	Z+11, r25	; 0x0b
    2032:	a4 87       	std	Z+12, r26	; 0x0c
    2034:	b5 87       	std	Z+13, r27	; 0x0d
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
    2036:	e3 5e       	subi	r30, 0xE3	; 227
    2038:	fd 4f       	sbci	r31, 0xFD	; 253
    203a:	80 81       	ld	r24, Z
    203c:	90 e0       	ldi	r25, 0x00	; 0
    203e:	a0 e0       	ldi	r26, 0x00	; 0
    2040:	b0 e0       	ldi	r27, 0x00	; 0
    2042:	b8 2f       	mov	r27, r24
    2044:	aa 27       	eor	r26, r26
    2046:	99 27       	eor	r25, r25
    2048:	88 27       	eor	r24, r24
    204a:	f7 01       	movw	r30, r14
    204c:	e4 5e       	subi	r30, 0xE4	; 228
    204e:	fd 4f       	sbci	r31, 0xFD	; 253
    2050:	40 81       	ld	r20, Z
    2052:	50 e0       	ldi	r21, 0x00	; 0
    2054:	60 e0       	ldi	r22, 0x00	; 0
    2056:	70 e0       	ldi	r23, 0x00	; 0
    2058:	ba 01       	movw	r22, r20
    205a:	55 27       	eor	r21, r21
    205c:	44 27       	eor	r20, r20
    205e:	84 2b       	or	r24, r20
    2060:	95 2b       	or	r25, r21
    2062:	a6 2b       	or	r26, r22
    2064:	b7 2b       	or	r27, r23
    2066:	f7 01       	movw	r30, r14
    2068:	e6 5e       	subi	r30, 0xE6	; 230
    206a:	fd 4f       	sbci	r31, 0xFD	; 253
    206c:	40 81       	ld	r20, Z
    206e:	50 e0       	ldi	r21, 0x00	; 0
    2070:	60 e0       	ldi	r22, 0x00	; 0
    2072:	70 e0       	ldi	r23, 0x00	; 0
    2074:	48 2b       	or	r20, r24
    2076:	59 2b       	or	r21, r25
    2078:	6a 2b       	or	r22, r26
    207a:	7b 2b       	or	r23, r27
    207c:	f7 01       	movw	r30, r14
    207e:	e5 5e       	subi	r30, 0xE5	; 229
    2080:	fd 4f       	sbci	r31, 0xFD	; 253
    2082:	90 81       	ld	r25, Z
    2084:	80 e0       	ldi	r24, 0x00	; 0
    2086:	a0 e0       	ldi	r26, 0x00	; 0
    2088:	b0 e0       	ldi	r27, 0x00	; 0
    208a:	84 2b       	or	r24, r20
    208c:	95 2b       	or	r25, r21
    208e:	a6 2b       	or	r26, r22
    2090:	b7 2b       	or	r27, r23
    2092:	f7 01       	movw	r30, r14
    2094:	86 87       	std	Z+14, r24	; 0x0e
    2096:	97 87       	std	Z+15, r25	; 0x0f
    2098:	a0 8b       	std	Z+16, r26	; 0x10
    209a:	b1 8b       	std	Z+17, r27	; 0x11
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
    209c:	d7 01       	movw	r26, r14
    209e:	dc 92       	st	X, r13
	fs->id = ++Fsid;		/* File system mount ID */
    20a0:	80 91 26 04 	lds	r24, 0x0426
    20a4:	90 91 27 04 	lds	r25, 0x0427
    20a8:	01 96       	adiw	r24, 0x01	; 1
    20aa:	90 93 27 04 	sts	0x0427, r25
    20ae:	80 93 26 04 	sts	0x0426, r24
    20b2:	17 96       	adiw	r26, 0x07	; 7
    20b4:	9c 93       	st	X, r25
    20b6:	8e 93       	st	-X, r24
    20b8:	16 97       	sbiw	r26, 0x06	; 6
	fs->winsect = 0;		/* Invalidate sector cache */
    20ba:	f7 01       	movw	r30, r14
    20bc:	16 a6       	lds	r17, 0xb6
    20be:	17 a6       	lds	r17, 0xb7
    20c0:	10 aa       	sts	0x90, r17
    20c2:	11 aa       	sts	0x91, r17
	fs->wflag = 0;
    20c4:	14 82       	std	Z+4, r1	; 0x04
#if _FS_RPATH
	fs->cdir = 0;			/* Current directory (root dir) */
    20c6:	56 96       	adiw	r26, 0x16	; 22
    20c8:	1d 92       	st	X+, r1
    20ca:	1d 92       	st	X+, r1
    20cc:	1d 92       	st	X+, r1
    20ce:	1c 92       	st	X, r1
    20d0:	59 97       	sbiw	r26, 0x19	; 25
#endif
#if _FS_LOCK				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
    20d2:	80 e0       	ldi	r24, 0x00	; 0
    20d4:	27 c0       	rjmp	.+78     	; 0x2124 <chk_mounted+0x81c>
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
    20d6:	8b e0       	ldi	r24, 0x0B	; 11
    20d8:	25 c0       	rjmp	.+74     	; 0x2124 <chk_mounted+0x81c>
	fs = FatFs[vol];					/* Get corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    20da:	8c e0       	ldi	r24, 0x0C	; 12
    20dc:	23 c0       	rjmp	.+70     	; 0x2124 <chk_mounted+0x81c>
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
    20de:	80 e0       	ldi	r24, 0x00	; 0
    20e0:	21 c0       	rjmp	.+66     	; 0x2124 <chk_mounted+0x81c>
	*rfs = fs;							/* Return pointer to the corresponding file system object */
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
    20e2:	8a e0       	ldi	r24, 0x0A	; 10
    20e4:	1f c0       	rjmp	.+62     	; 0x2124 <chk_mounted+0x81c>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
    20e6:	83 e0       	ldi	r24, 0x03	; 3
    20e8:	1d c0       	rjmp	.+58     	; 0x2124 <chk_mounted+0x81c>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
    20ea:	8a e0       	ldi	r24, 0x0A	; 10
    20ec:	1b c0       	rjmp	.+54     	; 0x2124 <chk_mounted+0x81c>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    20ee:	8d e0       	ldi	r24, 0x0D	; 13
    20f0:	19 c0       	rjmp	.+50     	; 0x2124 <chk_mounted+0x81c>
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    20f2:	81 e0       	ldi	r24, 0x01	; 1
    20f4:	17 c0       	rjmp	.+46     	; 0x2124 <chk_mounted+0x81c>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    20f6:	8d e0       	ldi	r24, 0x0D	; 13
    20f8:	15 c0       	rjmp	.+42     	; 0x2124 <chk_mounted+0x81c>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;
    20fa:	8d e0       	ldi	r24, 0x0D	; 13
    20fc:	13 c0       	rjmp	.+38     	; 0x2124 <chk_mounted+0x81c>
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    20fe:	8d e0       	ldi	r24, 0x0D	; 13
    2100:	11 c0       	rjmp	.+34     	; 0x2124 <chk_mounted+0x81c>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    2102:	8d e0       	ldi	r24, 0x0D	; 13
    2104:	0f c0       	rjmp	.+30     	; 0x2124 <chk_mounted+0x81c>
    2106:	8d e0       	ldi	r24, 0x0D	; 13
    2108:	0d c0       	rjmp	.+26     	; 0x2124 <chk_mounted+0x81c>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    210a:	8d e0       	ldi	r24, 0x0D	; 13
    210c:	0b c0       	rjmp	.+22     	; 0x2124 <chk_mounted+0x81c>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    210e:	8d e0       	ldi	r24, 0x0D	; 13
    2110:	09 c0       	rjmp	.+18     	; 0x2124 <chk_mounted+0x81c>

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    2112:	8d e0       	ldi	r24, 0x0D	; 13
    2114:	07 c0       	rjmp	.+14     	; 0x2124 <chk_mounted+0x81c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    2116:	8d e0       	ldi	r24, 0x0D	; 13
    2118:	05 c0       	rjmp	.+10     	; 0x2124 <chk_mounted+0x81c>
	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    211a:	8d e0       	ldi	r24, 0x0D	; 13
    211c:	03 c0       	rjmp	.+6      	; 0x2124 <chk_mounted+0x81c>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    211e:	8d e0       	ldi	r24, 0x0D	; 13
    2120:	01 c0       	rjmp	.+2      	; 0x2124 <chk_mounted+0x81c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;
    2122:	8d e0       	ldi	r24, 0x0D	; 13
#if _FS_LOCK				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
}
    2124:	60 96       	adiw	r28, 0x10	; 16
    2126:	0f b6       	in	r0, 0x3f	; 63
    2128:	f8 94       	cli
    212a:	de bf       	out	0x3e, r29	; 62
    212c:	0f be       	out	0x3f, r0	; 63
    212e:	cd bf       	out	0x3d, r28	; 61
    2130:	df 91       	pop	r29
    2132:	cf 91       	pop	r28
    2134:	1f 91       	pop	r17
    2136:	0f 91       	pop	r16
    2138:	ff 90       	pop	r15
    213a:	ef 90       	pop	r14
    213c:	df 90       	pop	r13
    213e:	cf 90       	pop	r12
    2140:	bf 90       	pop	r11
    2142:	af 90       	pop	r10
    2144:	9f 90       	pop	r9
    2146:	8f 90       	pop	r8
    2148:	7f 90       	pop	r7
    214a:	6f 90       	pop	r6
    214c:	5f 90       	pop	r5
    214e:	4f 90       	pop	r4
    2150:	3f 90       	pop	r3
    2152:	2f 90       	pop	r2
    2154:	08 95       	ret
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    2156:	b9 01       	movw	r22, r18
    2158:	a8 01       	movw	r20, r16
    215a:	4e 5f       	subi	r20, 0xFE	; 254
    215c:	5f 4f       	sbci	r21, 0xFF	; 255
    215e:	6f 4f       	sbci	r22, 0xFF	; 255
    2160:	7f 4f       	sbci	r23, 0xFF	; 255
    2162:	f7 01       	movw	r30, r14
    2164:	42 8f       	std	Z+26, r20	; 0x1a
    2166:	53 8f       	std	Z+27, r21	; 0x1b
    2168:	64 8f       	std	Z+28, r22	; 0x1c
    216a:	75 8f       	std	Z+29, r23	; 0x1d
	fs->database = bsect + sysect;						/* Data start sector */
    216c:	8d 81       	ldd	r24, Y+5	; 0x05
    216e:	9e 81       	ldd	r25, Y+6	; 0x06
    2170:	af 81       	ldd	r26, Y+7	; 0x07
    2172:	b8 85       	ldd	r27, Y+8	; 0x08
    2174:	88 0d       	add	r24, r8
    2176:	99 1d       	adc	r25, r9
    2178:	aa 1d       	adc	r26, r10
    217a:	bb 1d       	adc	r27, r11
    217c:	82 a7       	lds	r24, 0x72
    217e:	93 a7       	lds	r25, 0x73
    2180:	a4 a7       	lds	r26, 0x74
    2182:	b5 a7       	lds	r27, 0x75
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    2184:	89 85       	ldd	r24, Y+9	; 0x09
    2186:	9a 85       	ldd	r25, Y+10	; 0x0a
    2188:	ab 85       	ldd	r26, Y+11	; 0x0b
    218a:	bc 85       	ldd	r27, Y+12	; 0x0c
    218c:	88 0d       	add	r24, r8
    218e:	99 1d       	adc	r25, r9
    2190:	aa 1d       	adc	r26, r10
    2192:	bb 1d       	adc	r27, r11
    2194:	82 a3       	lds	r24, 0x52
    2196:	93 a3       	lds	r25, 0x53
    2198:	a4 a3       	lds	r26, 0x54
    219a:	b5 a3       	lds	r27, 0x55
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    219c:	0f 2e       	mov	r0, r31
    219e:	f3 e0       	ldi	r31, 0x03	; 3
    21a0:	df 2e       	mov	r13, r31
    21a2:	f0 2d       	mov	r31, r0
    21a4:	e3 cd       	rjmp	.-1082   	; 0x1d6c <chk_mounted+0x464>

000021a6 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
    21a6:	4f 92       	push	r4
    21a8:	5f 92       	push	r5
    21aa:	6f 92       	push	r6
    21ac:	7f 92       	push	r7
    21ae:	8f 92       	push	r8
    21b0:	9f 92       	push	r9
    21b2:	af 92       	push	r10
    21b4:	bf 92       	push	r11
    21b6:	cf 92       	push	r12
    21b8:	df 92       	push	r13
    21ba:	ef 92       	push	r14
    21bc:	ff 92       	push	r15
    21be:	0f 93       	push	r16
    21c0:	cf 93       	push	r28
    21c2:	5c 01       	movw	r10, r24
    21c4:	2a 01       	movw	r4, r20
    21c6:	3b 01       	movw	r6, r22
	DWORD wsect;


	wsect = fs->winsect;
    21c8:	fc 01       	movw	r30, r24
    21ca:	c6 a4       	lds	r28, 0xa6
    21cc:	d7 a4       	lds	r29, 0xa7
    21ce:	e0 a8       	sts	0x00, r30
    21d0:	f1 a8       	sts	0x81, r31
	if (wsect != sector) {	/* Changed current window */
    21d2:	c4 16       	cp	r12, r20
    21d4:	d5 06       	cpc	r13, r21
    21d6:	e6 06       	cpc	r14, r22
    21d8:	f7 06       	cpc	r15, r23
    21da:	09 f4       	brne	.+2      	; 0x21de <move_window+0x38>
    21dc:	54 c0       	rjmp	.+168    	; 0x2286 <move_window+0xe0>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
    21de:	84 81       	ldd	r24, Z+4	; 0x04
    21e0:	88 23       	and	r24, r24
    21e2:	d1 f1       	breq	.+116    	; 0x2258 <move_window+0xb2>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    21e4:	0f 2e       	mov	r0, r31
    21e6:	f2 e3       	ldi	r31, 0x32	; 50
    21e8:	8f 2e       	mov	r8, r31
    21ea:	99 24       	eor	r9, r9
    21ec:	f0 2d       	mov	r31, r0
    21ee:	8a 0c       	add	r8, r10
    21f0:	9b 1c       	adc	r9, r11
    21f2:	81 81       	ldd	r24, Z+1	; 0x01
    21f4:	b4 01       	movw	r22, r8
    21f6:	a7 01       	movw	r20, r14
    21f8:	96 01       	movw	r18, r12
    21fa:	01 e0       	ldi	r16, 0x01	; 1
    21fc:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    2200:	88 23       	and	r24, r24
    2202:	09 f0       	breq	.+2      	; 0x2206 <move_window+0x60>
    2204:	42 c0       	rjmp	.+132    	; 0x228a <move_window+0xe4>
				return FR_DISK_ERR;
			fs->wflag = 0;
    2206:	f5 01       	movw	r30, r10
    2208:	14 82       	std	Z+4, r1	; 0x04
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    220a:	46 8d       	ldd	r20, Z+30	; 0x1e
    220c:	57 8d       	ldd	r21, Z+31	; 0x1f
    220e:	60 a1       	lds	r22, 0x40
    2210:	71 a1       	lds	r23, 0x41
    2212:	82 a1       	lds	r24, 0x42
    2214:	93 a1       	lds	r25, 0x43
    2216:	a4 a1       	lds	r26, 0x44
    2218:	b5 a1       	lds	r27, 0x45
    221a:	84 0f       	add	r24, r20
    221c:	95 1f       	adc	r25, r21
    221e:	a6 1f       	adc	r26, r22
    2220:	b7 1f       	adc	r27, r23
    2222:	c8 16       	cp	r12, r24
    2224:	d9 06       	cpc	r13, r25
    2226:	ea 06       	cpc	r14, r26
    2228:	fb 06       	cpc	r15, r27
    222a:	b0 f4       	brcc	.+44     	; 0x2258 <move_window+0xb2>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    222c:	c3 81       	ldd	r28, Z+3	; 0x03
    222e:	c2 30       	cpi	r28, 0x02	; 2
    2230:	98 f0       	brcs	.+38     	; 0x2258 <move_window+0xb2>
					wsect += fs->fsize;
    2232:	f5 01       	movw	r30, r10
    2234:	86 8d       	ldd	r24, Z+30	; 0x1e
    2236:	97 8d       	ldd	r25, Z+31	; 0x1f
    2238:	a0 a1       	lds	r26, 0x40
    223a:	b1 a1       	lds	r27, 0x41
    223c:	c8 0e       	add	r12, r24
    223e:	d9 1e       	adc	r13, r25
    2240:	ea 1e       	adc	r14, r26
    2242:	fb 1e       	adc	r15, r27
					disk_write(fs->drv, fs->win, wsect, 1);
    2244:	81 81       	ldd	r24, Z+1	; 0x01
    2246:	b4 01       	movw	r22, r8
    2248:	a7 01       	movw	r20, r14
    224a:	96 01       	movw	r18, r12
    224c:	01 e0       	ldi	r16, 0x01	; 1
    224e:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    2252:	c1 50       	subi	r28, 0x01	; 1
    2254:	c1 30       	cpi	r28, 0x01	; 1
    2256:	69 f7       	brne	.-38     	; 0x2232 <move_window+0x8c>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
    2258:	41 14       	cp	r4, r1
    225a:	51 04       	cpc	r5, r1
    225c:	61 04       	cpc	r6, r1
    225e:	71 04       	cpc	r7, r1
    2260:	b1 f0       	breq	.+44     	; 0x228e <move_window+0xe8>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    2262:	b5 01       	movw	r22, r10
    2264:	6e 5c       	subi	r22, 0xCE	; 206
    2266:	7f 4f       	sbci	r23, 0xFF	; 255
    2268:	f5 01       	movw	r30, r10
    226a:	81 81       	ldd	r24, Z+1	; 0x01
    226c:	a3 01       	movw	r20, r6
    226e:	92 01       	movw	r18, r4
    2270:	01 e0       	ldi	r16, 0x01	; 1
    2272:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    2276:	88 23       	and	r24, r24
    2278:	61 f4       	brne	.+24     	; 0x2292 <move_window+0xec>
				return FR_DISK_ERR;
			fs->winsect = sector;
    227a:	f5 01       	movw	r30, r10
    227c:	46 a6       	lds	r20, 0xb6
    227e:	57 a6       	lds	r21, 0xb7
    2280:	60 aa       	sts	0x90, r22
    2282:	71 aa       	sts	0x91, r23
    2284:	07 c0       	rjmp	.+14     	; 0x2294 <move_window+0xee>
		}
	}

	return FR_OK;
    2286:	80 e0       	ldi	r24, 0x00	; 0
    2288:	05 c0       	rjmp	.+10     	; 0x2294 <move_window+0xee>
	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
    228a:	81 e0       	ldi	r24, 0x01	; 1
    228c:	03 c0       	rjmp	.+6      	; 0x2294 <move_window+0xee>
				return FR_DISK_ERR;
			fs->winsect = sector;
		}
	}

	return FR_OK;
    228e:	80 e0       	ldi	r24, 0x00	; 0
    2290:	01 c0       	rjmp	.+2      	; 0x2294 <move_window+0xee>
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
    2292:	81 e0       	ldi	r24, 0x01	; 1
			fs->winsect = sector;
		}
	}

	return FR_OK;
}
    2294:	cf 91       	pop	r28
    2296:	0f 91       	pop	r16
    2298:	ff 90       	pop	r15
    229a:	ef 90       	pop	r14
    229c:	df 90       	pop	r13
    229e:	cf 90       	pop	r12
    22a0:	bf 90       	pop	r11
    22a2:	af 90       	pop	r10
    22a4:	9f 90       	pop	r9
    22a6:	8f 90       	pop	r8
    22a8:	7f 90       	pop	r7
    22aa:	6f 90       	pop	r6
    22ac:	5f 90       	pop	r5
    22ae:	4f 90       	pop	r4
    22b0:	08 95       	ret

000022b2 <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
    22b2:	ef 92       	push	r14
    22b4:	ff 92       	push	r15
    22b6:	0f 93       	push	r16
    22b8:	1f 93       	push	r17
    22ba:	cf 93       	push	r28
    22bc:	7c 01       	movw	r14, r24
	FRESULT res;


	res = move_window(fs, 0);
    22be:	40 e0       	ldi	r20, 0x00	; 0
    22c0:	50 e0       	ldi	r21, 0x00	; 0
    22c2:	ba 01       	movw	r22, r20
    22c4:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
    22c8:	c8 2f       	mov	r28, r24
	if (res == FR_OK) {
    22ca:	88 23       	and	r24, r24
    22cc:	09 f0       	breq	.+2      	; 0x22d0 <sync+0x1e>
    22ce:	78 c0       	rjmp	.+240    	; 0x23c0 <sync+0x10e>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    22d0:	f7 01       	movw	r30, r14
    22d2:	80 81       	ld	r24, Z
    22d4:	83 30       	cpi	r24, 0x03	; 3
    22d6:	09 f0       	breq	.+2      	; 0x22da <sync+0x28>
    22d8:	6a c0       	rjmp	.+212    	; 0x23ae <sync+0xfc>
    22da:	85 81       	ldd	r24, Z+5	; 0x05
    22dc:	88 23       	and	r24, r24
    22de:	09 f4       	brne	.+2      	; 0x22e2 <sync+0x30>
    22e0:	66 c0       	rjmp	.+204    	; 0x23ae <sync+0xfc>
			fs->winsect = 0;
    22e2:	16 a6       	lds	r17, 0xb6
    22e4:	17 a6       	lds	r17, 0xb7
    22e6:	10 aa       	sts	0x90, r17
    22e8:	11 aa       	sts	0x91, r17
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
    22ea:	87 01       	movw	r16, r14
    22ec:	0e 5c       	subi	r16, 0xCE	; 206
    22ee:	1f 4f       	sbci	r17, 0xFF	; 255
    22f0:	c8 01       	movw	r24, r16
    22f2:	60 e0       	ldi	r22, 0x00	; 0
    22f4:	70 e0       	ldi	r23, 0x00	; 0
    22f6:	20 e0       	ldi	r18, 0x00	; 0
    22f8:	32 e0       	ldi	r19, 0x02	; 2
    22fa:	40 e0       	ldi	r20, 0x00	; 0
    22fc:	50 e0       	ldi	r21, 0x00	; 0
    22fe:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <mem_set>
			ST_WORD(fs->win+BS_55AA, 0xAA55);
    2302:	f7 01       	movw	r30, r14
    2304:	e0 5d       	subi	r30, 0xD0	; 208
    2306:	fd 4f       	sbci	r31, 0xFD	; 253
    2308:	85 e5       	ldi	r24, 0x55	; 85
    230a:	80 83       	st	Z, r24
    230c:	f7 01       	movw	r30, r14
    230e:	ef 5c       	subi	r30, 0xCF	; 207
    2310:	fd 4f       	sbci	r31, 0xFD	; 253
    2312:	8a ea       	ldi	r24, 0xAA	; 170
    2314:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    2316:	82 e5       	ldi	r24, 0x52	; 82
    2318:	f7 01       	movw	r30, r14
    231a:	82 ab       	sts	0x52, r24
    231c:	83 ab       	sts	0x53, r24
    231e:	81 e6       	ldi	r24, 0x61	; 97
    2320:	84 ab       	sts	0x54, r24
    2322:	91 e4       	ldi	r25, 0x41	; 65
    2324:	95 ab       	sts	0x55, r25
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    2326:	ea 5e       	subi	r30, 0xEA	; 234
    2328:	fd 4f       	sbci	r31, 0xFD	; 253
    232a:	22 e7       	ldi	r18, 0x72	; 114
    232c:	20 83       	st	Z, r18
    232e:	f7 01       	movw	r30, r14
    2330:	e9 5e       	subi	r30, 0xE9	; 233
    2332:	fd 4f       	sbci	r31, 0xFD	; 253
    2334:	20 83       	st	Z, r18
    2336:	f7 01       	movw	r30, r14
    2338:	e8 5e       	subi	r30, 0xE8	; 232
    233a:	fd 4f       	sbci	r31, 0xFD	; 253
    233c:	90 83       	st	Z, r25
    233e:	f7 01       	movw	r30, r14
    2340:	e7 5e       	subi	r30, 0xE7	; 231
    2342:	fd 4f       	sbci	r31, 0xFD	; 253
    2344:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    2346:	f7 01       	movw	r30, r14
    2348:	36 85       	ldd	r19, Z+14	; 0x0e
    234a:	27 85       	ldd	r18, Z+15	; 0x0f
    234c:	90 89       	ldd	r25, Z+16	; 0x10
    234e:	81 89       	ldd	r24, Z+17	; 0x11
    2350:	e6 5e       	subi	r30, 0xE6	; 230
    2352:	fd 4f       	sbci	r31, 0xFD	; 253
    2354:	30 83       	st	Z, r19
    2356:	f7 01       	movw	r30, r14
    2358:	e5 5e       	subi	r30, 0xE5	; 229
    235a:	fd 4f       	sbci	r31, 0xFD	; 253
    235c:	20 83       	st	Z, r18
    235e:	f7 01       	movw	r30, r14
    2360:	e4 5e       	subi	r30, 0xE4	; 228
    2362:	fd 4f       	sbci	r31, 0xFD	; 253
    2364:	90 83       	st	Z, r25
    2366:	f7 01       	movw	r30, r14
    2368:	e3 5e       	subi	r30, 0xE3	; 227
    236a:	fd 4f       	sbci	r31, 0xFD	; 253
    236c:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    236e:	f7 01       	movw	r30, r14
    2370:	32 85       	ldd	r19, Z+10	; 0x0a
    2372:	23 85       	ldd	r18, Z+11	; 0x0b
    2374:	94 85       	ldd	r25, Z+12	; 0x0c
    2376:	85 85       	ldd	r24, Z+13	; 0x0d
    2378:	e2 5e       	subi	r30, 0xE2	; 226
    237a:	fd 4f       	sbci	r31, 0xFD	; 253
    237c:	30 83       	st	Z, r19
    237e:	f7 01       	movw	r30, r14
    2380:	e1 5e       	subi	r30, 0xE1	; 225
    2382:	fd 4f       	sbci	r31, 0xFD	; 253
    2384:	20 83       	st	Z, r18
    2386:	f7 01       	movw	r30, r14
    2388:	e0 5e       	subi	r30, 0xE0	; 224
    238a:	fd 4f       	sbci	r31, 0xFD	; 253
    238c:	90 83       	st	Z, r25
    238e:	f7 01       	movw	r30, r14
    2390:	ef 5d       	subi	r30, 0xDF	; 223
    2392:	fd 4f       	sbci	r31, 0xFD	; 253
    2394:	80 83       	st	Z, r24
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    2396:	f7 01       	movw	r30, r14
    2398:	22 89       	ldd	r18, Z+18	; 0x12
    239a:	33 89       	ldd	r19, Z+19	; 0x13
    239c:	44 89       	ldd	r20, Z+20	; 0x14
    239e:	55 89       	ldd	r21, Z+21	; 0x15
    23a0:	81 81       	ldd	r24, Z+1	; 0x01
    23a2:	b8 01       	movw	r22, r16
    23a4:	01 e0       	ldi	r16, 0x01	; 1
    23a6:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
			fs->fsi_flag = 0;
    23aa:	f7 01       	movw	r30, r14
    23ac:	15 82       	std	Z+5, r1	; 0x05
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    23ae:	f7 01       	movw	r30, r14
    23b0:	81 81       	ldd	r24, Z+1	; 0x01
    23b2:	60 e0       	ldi	r22, 0x00	; 0
    23b4:	40 e0       	ldi	r20, 0x00	; 0
    23b6:	50 e0       	ldi	r21, 0x00	; 0
    23b8:	0e 94 66 03 	call	0x6cc	; 0x6cc <disk_ioctl>
    23bc:	81 11       	cpse	r24, r1
			res = FR_DISK_ERR;
    23be:	c1 e0       	ldi	r28, 0x01	; 1
	}

	return res;
}
    23c0:	8c 2f       	mov	r24, r28
    23c2:	cf 91       	pop	r28
    23c4:	1f 91       	pop	r17
    23c6:	0f 91       	pop	r16
    23c8:	ff 90       	pop	r15
    23ca:	ef 90       	pop	r14
    23cc:	08 95       	ret

000023ce <get_fattime>:
#include "diskio.h"		/* Declarations of low level disk I/O functions */

DWORD get_fattime( void )
{
	return 0;
}
    23ce:	60 e0       	ldi	r22, 0x00	; 0
    23d0:	70 e0       	ldi	r23, 0x00	; 0
    23d2:	cb 01       	movw	r24, r22
    23d4:	08 95       	ret

000023d6 <clust2sect>:

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
    23d6:	0f 93       	push	r16
    23d8:	1f 93       	push	r17
    23da:	cf 93       	push	r28
    23dc:	df 93       	push	r29
    23de:	ec 01       	movw	r28, r24
    23e0:	db 01       	movw	r26, r22
    23e2:	ca 01       	movw	r24, r20
	clst -= 2;
    23e4:	02 97       	sbiw	r24, 0x02	; 2
    23e6:	a1 09       	sbc	r26, r1
    23e8:	b1 09       	sbc	r27, r1
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    23ea:	4a 8d       	ldd	r20, Y+26	; 0x1a
    23ec:	5b 8d       	ldd	r21, Y+27	; 0x1b
    23ee:	6c 8d       	ldd	r22, Y+28	; 0x1c
    23f0:	7d 8d       	ldd	r23, Y+29	; 0x1d
    23f2:	42 50       	subi	r20, 0x02	; 2
    23f4:	50 40       	sbci	r21, 0x00	; 0
    23f6:	60 40       	sbci	r22, 0x00	; 0
    23f8:	70 40       	sbci	r23, 0x00	; 0
    23fa:	84 17       	cp	r24, r20
    23fc:	95 07       	cpc	r25, r21
    23fe:	a6 07       	cpc	r26, r22
    2400:	b7 07       	cpc	r27, r23
    2402:	98 f4       	brcc	.+38     	; 0x242a <clust2sect+0x54>
	return clst * fs->csize + fs->database;
    2404:	2a 81       	ldd	r18, Y+2	; 0x02
    2406:	30 e0       	ldi	r19, 0x00	; 0
    2408:	40 e0       	ldi	r20, 0x00	; 0
    240a:	50 e0       	ldi	r21, 0x00	; 0
    240c:	bc 01       	movw	r22, r24
    240e:	cd 01       	movw	r24, r26
    2410:	0e 94 30 2c 	call	0x5860	; 0x5860 <__mulsi3>
    2414:	8b 01       	movw	r16, r22
    2416:	9c 01       	movw	r18, r24
    2418:	8a a5       	lds	r24, 0x6a
    241a:	9b a5       	lds	r25, 0x6b
    241c:	ac a5       	lds	r26, 0x6c
    241e:	bd a5       	lds	r27, 0x6d
    2420:	08 0f       	add	r16, r24
    2422:	19 1f       	adc	r17, r25
    2424:	2a 1f       	adc	r18, r26
    2426:	3b 1f       	adc	r19, r27
    2428:	03 c0       	rjmp	.+6      	; 0x2430 <clust2sect+0x5a>
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    242a:	00 e0       	ldi	r16, 0x00	; 0
    242c:	10 e0       	ldi	r17, 0x00	; 0
    242e:	98 01       	movw	r18, r16
	return clst * fs->csize + fs->database;
}
    2430:	60 2f       	mov	r22, r16
    2432:	71 2f       	mov	r23, r17
    2434:	82 2f       	mov	r24, r18
    2436:	93 2f       	mov	r25, r19
    2438:	df 91       	pop	r29
    243a:	cf 91       	pop	r28
    243c:	1f 91       	pop	r17
    243e:	0f 91       	pop	r16
    2440:	08 95       	ret

00002442 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
    2442:	8f 92       	push	r8
    2444:	9f 92       	push	r9
    2446:	af 92       	push	r10
    2448:	bf 92       	push	r11
    244a:	cf 92       	push	r12
    244c:	df 92       	push	r13
    244e:	ef 92       	push	r14
    2450:	ff 92       	push	r15
    2452:	0f 93       	push	r16
    2454:	1f 93       	push	r17
    2456:	cf 93       	push	r28
    2458:	df 93       	push	r29
    245a:	ec 01       	movw	r28, r24
    245c:	6a 01       	movw	r12, r20
    245e:	7b 01       	movw	r14, r22
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
    2460:	42 30       	cpi	r20, 0x02	; 2
    2462:	51 05       	cpc	r21, r1
    2464:	61 05       	cpc	r22, r1
    2466:	71 05       	cpc	r23, r1
    2468:	08 f4       	brcc	.+2      	; 0x246c <get_fat+0x2a>
    246a:	f4 c0       	rjmp	.+488    	; 0x2654 <get_fat+0x212>
    246c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    246e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2470:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2472:	bd 8d       	ldd	r27, Y+29	; 0x1d
    2474:	48 17       	cp	r20, r24
    2476:	59 07       	cpc	r21, r25
    2478:	6a 07       	cpc	r22, r26
    247a:	7b 07       	cpc	r23, r27
    247c:	08 f0       	brcs	.+2      	; 0x2480 <get_fat+0x3e>
    247e:	ef c0       	rjmp	.+478    	; 0x265e <get_fat+0x21c>
		return 1;

	switch (fs->fs_type) {
    2480:	88 81       	ld	r24, Y
    2482:	82 30       	cpi	r24, 0x02	; 2
    2484:	09 f4       	brne	.+2      	; 0x2488 <get_fat+0x46>
    2486:	81 c0       	rjmp	.+258    	; 0x258a <get_fat+0x148>
    2488:	83 30       	cpi	r24, 0x03	; 3
    248a:	09 f4       	brne	.+2      	; 0x248e <get_fat+0x4c>
    248c:	a0 c0       	rjmp	.+320    	; 0x25ce <get_fat+0x18c>
    248e:	81 30       	cpi	r24, 0x01	; 1
    2490:	09 f0       	breq	.+2      	; 0x2494 <get_fat+0x52>
    2492:	ea c0       	rjmp	.+468    	; 0x2668 <get_fat+0x226>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
    2494:	4a 01       	movw	r8, r20
    2496:	5b 01       	movw	r10, r22
    2498:	b6 94       	lsr	r11
    249a:	a7 94       	ror	r10
    249c:	97 94       	ror	r9
    249e:	87 94       	ror	r8
    24a0:	84 0e       	add	r8, r20
    24a2:	95 1e       	adc	r9, r21
    24a4:	a6 1e       	adc	r10, r22
    24a6:	b7 1e       	adc	r11, r23
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    24a8:	b5 01       	movw	r22, r10
    24aa:	a4 01       	movw	r20, r8
    24ac:	03 2e       	mov	r0, r19
    24ae:	39 e0       	ldi	r19, 0x09	; 9
    24b0:	76 95       	lsr	r23
    24b2:	67 95       	ror	r22
    24b4:	57 95       	ror	r21
    24b6:	47 95       	ror	r20
    24b8:	3a 95       	dec	r19
    24ba:	d1 f7       	brne	.-12     	; 0x24b0 <get_fat+0x6e>
    24bc:	30 2d       	mov	r19, r0
    24be:	8a a1       	lds	r24, 0x4a
    24c0:	9b a1       	lds	r25, 0x4b
    24c2:	ac a1       	lds	r26, 0x4c
    24c4:	bd a1       	lds	r27, 0x4d
    24c6:	48 0f       	add	r20, r24
    24c8:	59 1f       	adc	r21, r25
    24ca:	6a 1f       	adc	r22, r26
    24cc:	7b 1f       	adc	r23, r27
    24ce:	ce 01       	movw	r24, r28
    24d0:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
    24d4:	88 23       	and	r24, r24
    24d6:	09 f0       	breq	.+2      	; 0x24da <get_fat+0x98>
    24d8:	cb c0       	rjmp	.+406    	; 0x2670 <get_fat+0x22e>
		wc = fs->win[bc % SS(fs)]; bc++;
    24da:	d5 01       	movw	r26, r10
    24dc:	c4 01       	movw	r24, r8
    24de:	91 70       	andi	r25, 0x01	; 1
    24e0:	a0 70       	andi	r26, 0x00	; 0
    24e2:	b0 70       	andi	r27, 0x00	; 0
    24e4:	fe 01       	movw	r30, r28
    24e6:	e8 0f       	add	r30, r24
    24e8:	f9 1f       	adc	r31, r25
    24ea:	12 a9       	sts	0x42, r17
    24ec:	08 94       	sec
    24ee:	81 1c       	adc	r8, r1
    24f0:	91 1c       	adc	r9, r1
    24f2:	a1 1c       	adc	r10, r1
    24f4:	b1 1c       	adc	r11, r1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    24f6:	b5 01       	movw	r22, r10
    24f8:	a4 01       	movw	r20, r8
    24fa:	03 2e       	mov	r0, r19
    24fc:	39 e0       	ldi	r19, 0x09	; 9
    24fe:	76 95       	lsr	r23
    2500:	67 95       	ror	r22
    2502:	57 95       	ror	r21
    2504:	47 95       	ror	r20
    2506:	3a 95       	dec	r19
    2508:	d1 f7       	brne	.-12     	; 0x24fe <get_fat+0xbc>
    250a:	30 2d       	mov	r19, r0
    250c:	8a a1       	lds	r24, 0x4a
    250e:	9b a1       	lds	r25, 0x4b
    2510:	ac a1       	lds	r26, 0x4c
    2512:	bd a1       	lds	r27, 0x4d
    2514:	48 0f       	add	r20, r24
    2516:	59 1f       	adc	r21, r25
    2518:	6a 1f       	adc	r22, r26
    251a:	7b 1f       	adc	r23, r27
    251c:	ce 01       	movw	r24, r28
    251e:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
    2522:	88 23       	and	r24, r24
    2524:	09 f0       	breq	.+2      	; 0x2528 <get_fat+0xe6>
    2526:	a8 c0       	rjmp	.+336    	; 0x2678 <get_fat+0x236>

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
    2528:	41 2f       	mov	r20, r17
    252a:	50 e0       	ldi	r21, 0x00	; 0
    252c:	60 e0       	ldi	r22, 0x00	; 0
    252e:	70 e0       	ldi	r23, 0x00	; 0
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
    2530:	8f ef       	ldi	r24, 0xFF	; 255
    2532:	91 e0       	ldi	r25, 0x01	; 1
    2534:	a0 e0       	ldi	r26, 0x00	; 0
    2536:	b0 e0       	ldi	r27, 0x00	; 0
    2538:	88 22       	and	r8, r24
    253a:	99 22       	and	r9, r25
    253c:	aa 22       	and	r10, r26
    253e:	bb 22       	and	r11, r27
    2540:	fe 01       	movw	r30, r28
    2542:	e8 0d       	add	r30, r8
    2544:	f9 1d       	adc	r31, r9
    2546:	92 a9       	sts	0x42, r25
    2548:	80 e0       	ldi	r24, 0x00	; 0
    254a:	8c 01       	movw	r16, r24
    254c:	22 27       	eor	r18, r18
    254e:	17 fd       	sbrc	r17, 7
    2550:	20 95       	com	r18
    2552:	32 2f       	mov	r19, r18
    2554:	40 2b       	or	r20, r16
    2556:	51 2b       	or	r21, r17
    2558:	62 2b       	or	r22, r18
    255a:	73 2b       	or	r23, r19
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    255c:	91 e0       	ldi	r25, 0x01	; 1
    255e:	c9 22       	and	r12, r25
    2560:	dd 24       	eor	r13, r13
    2562:	c1 14       	cp	r12, r1
    2564:	d1 04       	cpc	r13, r1
    2566:	59 f0       	breq	.+22     	; 0x257e <get_fat+0x13c>
    2568:	8a 01       	movw	r16, r20
    256a:	9b 01       	movw	r18, r22
    256c:	68 94       	set
    256e:	13 f8       	bld	r1, 3
    2570:	36 95       	lsr	r19
    2572:	27 95       	ror	r18
    2574:	17 95       	ror	r17
    2576:	07 95       	ror	r16
    2578:	16 94       	lsr	r1
    257a:	d1 f7       	brne	.-12     	; 0x2570 <get_fat+0x12e>
    257c:	88 c0       	rjmp	.+272    	; 0x268e <get_fat+0x24c>
    257e:	8a 01       	movw	r16, r20
    2580:	9b 01       	movw	r18, r22
    2582:	1f 70       	andi	r17, 0x0F	; 15
    2584:	20 70       	andi	r18, 0x00	; 0
    2586:	30 70       	andi	r19, 0x00	; 0
    2588:	82 c0       	rjmp	.+260    	; 0x268e <get_fat+0x24c>

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    258a:	45 2f       	mov	r20, r21
    258c:	56 2f       	mov	r21, r22
    258e:	67 2f       	mov	r22, r23
    2590:	77 27       	eor	r23, r23
    2592:	8a a1       	lds	r24, 0x4a
    2594:	9b a1       	lds	r25, 0x4b
    2596:	ac a1       	lds	r26, 0x4c
    2598:	bd a1       	lds	r27, 0x4d
    259a:	48 0f       	add	r20, r24
    259c:	59 1f       	adc	r21, r25
    259e:	6a 1f       	adc	r22, r26
    25a0:	7b 1f       	adc	r23, r27
    25a2:	ce 01       	movw	r24, r28
    25a4:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
    25a8:	88 23       	and	r24, r24
    25aa:	09 f0       	breq	.+2      	; 0x25ae <get_fat+0x16c>
    25ac:	69 c0       	rjmp	.+210    	; 0x2680 <get_fat+0x23e>
		p = &fs->win[clst * 2 % SS(fs)];
    25ae:	f6 01       	movw	r30, r12
    25b0:	ee 0f       	add	r30, r30
    25b2:	ff 1f       	adc	r31, r31
    25b4:	f1 70       	andi	r31, 0x01	; 1
		return LD_WORD(p);
    25b6:	ce 0f       	add	r28, r30
    25b8:	df 1f       	adc	r29, r31
    25ba:	9b a9       	sts	0x4b, r25
    25bc:	80 e0       	ldi	r24, 0x00	; 0
    25be:	0a a9       	sts	0x4a, r16
    25c0:	10 e0       	ldi	r17, 0x00	; 0
    25c2:	80 2b       	or	r24, r16
    25c4:	91 2b       	or	r25, r17
    25c6:	8c 01       	movw	r16, r24
    25c8:	20 e0       	ldi	r18, 0x00	; 0
    25ca:	30 e0       	ldi	r19, 0x00	; 0
    25cc:	60 c0       	rjmp	.+192    	; 0x268e <get_fat+0x24c>

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    25ce:	68 94       	set
    25d0:	16 f8       	bld	r1, 6
    25d2:	76 95       	lsr	r23
    25d4:	67 95       	ror	r22
    25d6:	57 95       	ror	r21
    25d8:	47 95       	ror	r20
    25da:	16 94       	lsr	r1
    25dc:	d1 f7       	brne	.-12     	; 0x25d2 <get_fat+0x190>
    25de:	8a a1       	lds	r24, 0x4a
    25e0:	9b a1       	lds	r25, 0x4b
    25e2:	ac a1       	lds	r26, 0x4c
    25e4:	bd a1       	lds	r27, 0x4d
    25e6:	48 0f       	add	r20, r24
    25e8:	59 1f       	adc	r21, r25
    25ea:	6a 1f       	adc	r22, r26
    25ec:	7b 1f       	adc	r23, r27
    25ee:	ce 01       	movw	r24, r28
    25f0:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
    25f4:	88 23       	and	r24, r24
    25f6:	09 f0       	breq	.+2      	; 0x25fa <get_fat+0x1b8>
    25f8:	47 c0       	rjmp	.+142    	; 0x2688 <get_fat+0x246>
		p = &fs->win[clst * 4 % SS(fs)];
    25fa:	f6 01       	movw	r30, r12
    25fc:	ee 0f       	add	r30, r30
    25fe:	ff 1f       	adc	r31, r31
    2600:	ee 0f       	add	r30, r30
    2602:	ff 1f       	adc	r31, r31
    2604:	f1 70       	andi	r31, 0x01	; 1
		return LD_DWORD(p) & 0x0FFFFFFF;
    2606:	ce 0f       	add	r28, r30
    2608:	df 1f       	adc	r29, r31
    260a:	0d a9       	sts	0x4d, r16
    260c:	10 e0       	ldi	r17, 0x00	; 0
    260e:	20 e0       	ldi	r18, 0x00	; 0
    2610:	30 e0       	ldi	r19, 0x00	; 0
    2612:	30 2f       	mov	r19, r16
    2614:	22 27       	eor	r18, r18
    2616:	11 27       	eor	r17, r17
    2618:	00 27       	eor	r16, r16
    261a:	8c a9       	sts	0x4c, r24
    261c:	90 e0       	ldi	r25, 0x00	; 0
    261e:	a0 e0       	ldi	r26, 0x00	; 0
    2620:	b0 e0       	ldi	r27, 0x00	; 0
    2622:	dc 01       	movw	r26, r24
    2624:	99 27       	eor	r25, r25
    2626:	88 27       	eor	r24, r24
    2628:	08 2b       	or	r16, r24
    262a:	19 2b       	or	r17, r25
    262c:	2a 2b       	or	r18, r26
    262e:	3b 2b       	or	r19, r27
    2630:	8a a9       	sts	0x4a, r24
    2632:	90 e0       	ldi	r25, 0x00	; 0
    2634:	a0 e0       	ldi	r26, 0x00	; 0
    2636:	b0 e0       	ldi	r27, 0x00	; 0
    2638:	08 2b       	or	r16, r24
    263a:	19 2b       	or	r17, r25
    263c:	2a 2b       	or	r18, r26
    263e:	3b 2b       	or	r19, r27
    2640:	9b a9       	sts	0x4b, r25
    2642:	80 e0       	ldi	r24, 0x00	; 0
    2644:	a0 e0       	ldi	r26, 0x00	; 0
    2646:	b0 e0       	ldi	r27, 0x00	; 0
    2648:	08 2b       	or	r16, r24
    264a:	19 2b       	or	r17, r25
    264c:	2a 2b       	or	r18, r26
    264e:	3b 2b       	or	r19, r27
    2650:	3f 70       	andi	r19, 0x0F	; 15
    2652:	1d c0       	rjmp	.+58     	; 0x268e <get_fat+0x24c>
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;
    2654:	01 e0       	ldi	r16, 0x01	; 1
    2656:	10 e0       	ldi	r17, 0x00	; 0
    2658:	20 e0       	ldi	r18, 0x00	; 0
    265a:	30 e0       	ldi	r19, 0x00	; 0
    265c:	18 c0       	rjmp	.+48     	; 0x268e <get_fat+0x24c>
    265e:	01 e0       	ldi	r16, 0x01	; 1
    2660:	10 e0       	ldi	r17, 0x00	; 0
    2662:	20 e0       	ldi	r18, 0x00	; 0
    2664:	30 e0       	ldi	r19, 0x00	; 0
    2666:	13 c0       	rjmp	.+38     	; 0x268e <get_fat+0x24c>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    2668:	0f ef       	ldi	r16, 0xFF	; 255
    266a:	1f ef       	ldi	r17, 0xFF	; 255
    266c:	98 01       	movw	r18, r16
    266e:	0f c0       	rjmp	.+30     	; 0x268e <get_fat+0x24c>
    2670:	0f ef       	ldi	r16, 0xFF	; 255
    2672:	1f ef       	ldi	r17, 0xFF	; 255
    2674:	98 01       	movw	r18, r16
    2676:	0b c0       	rjmp	.+22     	; 0x268e <get_fat+0x24c>
    2678:	0f ef       	ldi	r16, 0xFF	; 255
    267a:	1f ef       	ldi	r17, 0xFF	; 255
    267c:	98 01       	movw	r18, r16
    267e:	07 c0       	rjmp	.+14     	; 0x268e <get_fat+0x24c>
    2680:	0f ef       	ldi	r16, 0xFF	; 255
    2682:	1f ef       	ldi	r17, 0xFF	; 255
    2684:	98 01       	movw	r18, r16
    2686:	03 c0       	rjmp	.+6      	; 0x268e <get_fat+0x24c>
    2688:	0f ef       	ldi	r16, 0xFF	; 255
    268a:	1f ef       	ldi	r17, 0xFF	; 255
    268c:	98 01       	movw	r18, r16
}
    268e:	60 2f       	mov	r22, r16
    2690:	71 2f       	mov	r23, r17
    2692:	82 2f       	mov	r24, r18
    2694:	93 2f       	mov	r25, r19
    2696:	df 91       	pop	r29
    2698:	cf 91       	pop	r28
    269a:	1f 91       	pop	r17
    269c:	0f 91       	pop	r16
    269e:	ff 90       	pop	r15
    26a0:	ef 90       	pop	r14
    26a2:	df 90       	pop	r13
    26a4:	cf 90       	pop	r12
    26a6:	bf 90       	pop	r11
    26a8:	af 90       	pop	r10
    26aa:	9f 90       	pop	r9
    26ac:	8f 90       	pop	r8
    26ae:	08 95       	ret

000026b0 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Index of directory table */
)
{
    26b0:	ef 92       	push	r14
    26b2:	ff 92       	push	r15
    26b4:	0f 93       	push	r16
    26b6:	1f 93       	push	r17
    26b8:	cf 93       	push	r28
    26ba:	df 93       	push	r29
    26bc:	ec 01       	movw	r28, r24
    26be:	8b 01       	movw	r16, r22
	DWORD clst;
	WORD ic;


	dj->index = idx;
    26c0:	7d 83       	std	Y+5, r23	; 0x05
    26c2:	6c 83       	std	Y+4, r22	; 0x04
	clst = dj->sclust;
    26c4:	4e 81       	ldd	r20, Y+6	; 0x06
    26c6:	5f 81       	ldd	r21, Y+7	; 0x07
    26c8:	68 85       	ldd	r22, Y+8	; 0x08
    26ca:	79 85       	ldd	r23, Y+9	; 0x09
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    26cc:	41 30       	cpi	r20, 0x01	; 1
    26ce:	51 05       	cpc	r21, r1
    26d0:	61 05       	cpc	r22, r1
    26d2:	71 05       	cpc	r23, r1
    26d4:	09 f4       	brne	.+2      	; 0x26d8 <dir_sdi+0x28>
    26d6:	9f c0       	rjmp	.+318    	; 0x2816 <dir_sdi+0x166>
    26d8:	e8 81       	ld	r30, Y
    26da:	f9 81       	ldd	r31, Y+1	; 0x01
    26dc:	82 8d       	ldd	r24, Z+26	; 0x1a
    26de:	93 8d       	ldd	r25, Z+27	; 0x1b
    26e0:	a4 8d       	ldd	r26, Z+28	; 0x1c
    26e2:	b5 8d       	ldd	r27, Z+29	; 0x1d
    26e4:	48 17       	cp	r20, r24
    26e6:	59 07       	cpc	r21, r25
    26e8:	6a 07       	cpc	r22, r26
    26ea:	7b 07       	cpc	r23, r27
    26ec:	08 f0       	brcs	.+2      	; 0x26f0 <dir_sdi+0x40>
    26ee:	95 c0       	rjmp	.+298    	; 0x281a <dir_sdi+0x16a>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    26f0:	41 15       	cp	r20, r1
    26f2:	51 05       	cpc	r21, r1
    26f4:	61 05       	cpc	r22, r1
    26f6:	71 05       	cpc	r23, r1
    26f8:	69 f5       	brne	.+90     	; 0x2754 <dir_sdi+0xa4>
    26fa:	80 81       	ld	r24, Z
    26fc:	83 30       	cpi	r24, 0x03	; 3
    26fe:	49 f4       	brne	.+18     	; 0x2712 <dir_sdi+0x62>
		clst = dj->fs->dirbase;
    2700:	46 a1       	lds	r20, 0x46
    2702:	57 a1       	lds	r21, 0x47
    2704:	60 a5       	lds	r22, 0x60
    2706:	71 a5       	lds	r23, 0x61

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    2708:	41 15       	cp	r20, r1
    270a:	51 05       	cpc	r21, r1
    270c:	61 05       	cpc	r22, r1
    270e:	71 05       	cpc	r23, r1
    2710:	09 f5       	brne	.+66     	; 0x2754 <dir_sdi+0xa4>
		dj->clust = clst;
    2712:	1a 86       	std	Y+10, r1	; 0x0a
    2714:	1b 86       	std	Y+11, r1	; 0x0b
    2716:	1c 86       	std	Y+12, r1	; 0x0c
    2718:	1d 86       	std	Y+13, r1	; 0x0d
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    271a:	80 85       	ldd	r24, Z+8	; 0x08
    271c:	91 85       	ldd	r25, Z+9	; 0x09
    271e:	08 17       	cp	r16, r24
    2720:	19 07       	cpc	r17, r25
    2722:	08 f0       	brcs	.+2      	; 0x2726 <dir_sdi+0x76>
    2724:	7c c0       	rjmp	.+248    	; 0x281e <dir_sdi+0x16e>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    2726:	c8 01       	movw	r24, r16
    2728:	92 95       	swap	r25
    272a:	82 95       	swap	r24
    272c:	8f 70       	andi	r24, 0x0F	; 15
    272e:	89 27       	eor	r24, r25
    2730:	9f 70       	andi	r25, 0x0F	; 15
    2732:	89 27       	eor	r24, r25
    2734:	ac 01       	movw	r20, r24
    2736:	60 e0       	ldi	r22, 0x00	; 0
    2738:	70 e0       	ldi	r23, 0x00	; 0
    273a:	86 a1       	lds	r24, 0x46
    273c:	97 a1       	lds	r25, 0x47
    273e:	a0 a5       	lds	r26, 0x60
    2740:	b1 a5       	lds	r27, 0x61
    2742:	84 0f       	add	r24, r20
    2744:	95 1f       	adc	r25, r21
    2746:	a6 1f       	adc	r26, r22
    2748:	b7 1f       	adc	r27, r23
    274a:	8e 87       	std	Y+14, r24	; 0x0e
    274c:	9f 87       	std	Y+15, r25	; 0x0f
    274e:	a8 8b       	std	Y+16, r26	; 0x10
    2750:	b9 8b       	std	Y+17, r27	; 0x11
    2752:	4e c0       	rjmp	.+156    	; 0x27f0 <dir_sdi+0x140>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    2754:	82 81       	ldd	r24, Z+2	; 0x02
    2756:	90 e0       	ldi	r25, 0x00	; 0
    2758:	7c 01       	movw	r14, r24
    275a:	ee 0c       	add	r14, r14
    275c:	ff 1c       	adc	r15, r15
    275e:	ee 0c       	add	r14, r14
    2760:	ff 1c       	adc	r15, r15
    2762:	ee 0c       	add	r14, r14
    2764:	ff 1c       	adc	r15, r15
    2766:	ee 0c       	add	r14, r14
    2768:	ff 1c       	adc	r15, r15
		while (idx >= ic) {	/* Follow cluster chain */
    276a:	0e 15       	cp	r16, r14
    276c:	1f 05       	cpc	r17, r15
    276e:	28 f1       	brcs	.+74     	; 0x27ba <dir_sdi+0x10a>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    2770:	88 81       	ld	r24, Y
    2772:	99 81       	ldd	r25, Y+1	; 0x01
    2774:	0e 94 21 12 	call	0x2442	; 0x2442 <get_fat>
    2778:	ab 01       	movw	r20, r22
    277a:	bc 01       	movw	r22, r24
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    277c:	4f 3f       	cpi	r20, 0xFF	; 255
    277e:	8f ef       	ldi	r24, 0xFF	; 255
    2780:	58 07       	cpc	r21, r24
    2782:	8f ef       	ldi	r24, 0xFF	; 255
    2784:	68 07       	cpc	r22, r24
    2786:	8f ef       	ldi	r24, 0xFF	; 255
    2788:	78 07       	cpc	r23, r24
    278a:	09 f4       	brne	.+2      	; 0x278e <dir_sdi+0xde>
    278c:	4a c0       	rjmp	.+148    	; 0x2822 <dir_sdi+0x172>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    278e:	42 30       	cpi	r20, 0x02	; 2
    2790:	51 05       	cpc	r21, r1
    2792:	61 05       	cpc	r22, r1
    2794:	71 05       	cpc	r23, r1
    2796:	08 f4       	brcc	.+2      	; 0x279a <dir_sdi+0xea>
    2798:	46 c0       	rjmp	.+140    	; 0x2826 <dir_sdi+0x176>
    279a:	e8 81       	ld	r30, Y
    279c:	f9 81       	ldd	r31, Y+1	; 0x01
    279e:	82 8d       	ldd	r24, Z+26	; 0x1a
    27a0:	93 8d       	ldd	r25, Z+27	; 0x1b
    27a2:	a4 8d       	ldd	r26, Z+28	; 0x1c
    27a4:	b5 8d       	ldd	r27, Z+29	; 0x1d
    27a6:	48 17       	cp	r20, r24
    27a8:	59 07       	cpc	r21, r25
    27aa:	6a 07       	cpc	r22, r26
    27ac:	7b 07       	cpc	r23, r27
    27ae:	e8 f5       	brcc	.+122    	; 0x282a <dir_sdi+0x17a>
				return FR_INT_ERR;
			idx -= ic;
    27b0:	0e 19       	sub	r16, r14
    27b2:	1f 09       	sbc	r17, r15
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
    27b4:	0e 15       	cp	r16, r14
    27b6:	1f 05       	cpc	r17, r15
    27b8:	d8 f6       	brcc	.-74     	; 0x2770 <dir_sdi+0xc0>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
    27ba:	4a 87       	std	Y+10, r20	; 0x0a
    27bc:	5b 87       	std	Y+11, r21	; 0x0b
    27be:	6c 87       	std	Y+12, r22	; 0x0c
    27c0:	7d 87       	std	Y+13, r23	; 0x0d
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    27c2:	88 81       	ld	r24, Y
    27c4:	99 81       	ldd	r25, Y+1	; 0x01
    27c6:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <clust2sect>
    27ca:	ab 01       	movw	r20, r22
    27cc:	bc 01       	movw	r22, r24
    27ce:	c8 01       	movw	r24, r16
    27d0:	92 95       	swap	r25
    27d2:	82 95       	swap	r24
    27d4:	8f 70       	andi	r24, 0x0F	; 15
    27d6:	89 27       	eor	r24, r25
    27d8:	9f 70       	andi	r25, 0x0F	; 15
    27da:	89 27       	eor	r24, r25
    27dc:	a0 e0       	ldi	r26, 0x00	; 0
    27de:	b0 e0       	ldi	r27, 0x00	; 0
    27e0:	84 0f       	add	r24, r20
    27e2:	95 1f       	adc	r25, r21
    27e4:	a6 1f       	adc	r26, r22
    27e6:	b7 1f       	adc	r27, r23
    27e8:	8e 87       	std	Y+14, r24	; 0x0e
    27ea:	9f 87       	std	Y+15, r25	; 0x0f
    27ec:	a8 8b       	std	Y+16, r26	; 0x10
    27ee:	b9 8b       	std	Y+17, r27	; 0x11
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    27f0:	88 81       	ld	r24, Y
    27f2:	99 81       	ldd	r25, Y+1	; 0x01
    27f4:	c2 96       	adiw	r24, 0x32	; 50
    27f6:	0f 70       	andi	r16, 0x0F	; 15
    27f8:	10 70       	andi	r17, 0x00	; 0
    27fa:	00 0f       	add	r16, r16
    27fc:	11 1f       	adc	r17, r17
    27fe:	02 95       	swap	r16
    2800:	12 95       	swap	r17
    2802:	10 7f       	andi	r17, 0xF0	; 240
    2804:	10 27       	eor	r17, r16
    2806:	00 7f       	andi	r16, 0xF0	; 240
    2808:	10 27       	eor	r17, r16
    280a:	80 0f       	add	r24, r16
    280c:	91 1f       	adc	r25, r17
    280e:	9b 8b       	std	Y+19, r25	; 0x13
    2810:	8a 8b       	std	Y+18, r24	; 0x12

	return FR_OK;	/* Seek succeeded */
    2812:	80 e0       	ldi	r24, 0x00	; 0
    2814:	0b c0       	rjmp	.+22     	; 0x282c <dir_sdi+0x17c>


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
    2816:	82 e0       	ldi	r24, 0x02	; 2
    2818:	09 c0       	rjmp	.+18     	; 0x282c <dir_sdi+0x17c>
    281a:	82 e0       	ldi	r24, 0x02	; 2
    281c:	07 c0       	rjmp	.+14     	; 0x282c <dir_sdi+0x17c>
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
    281e:	82 e0       	ldi	r24, 0x02	; 2
    2820:	05 c0       	rjmp	.+10     	; 0x282c <dir_sdi+0x17c>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    2822:	81 e0       	ldi	r24, 0x01	; 1
    2824:	03 c0       	rjmp	.+6      	; 0x282c <dir_sdi+0x17c>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
    2826:	82 e0       	ldi	r24, 0x02	; 2
    2828:	01 c0       	rjmp	.+2      	; 0x282c <dir_sdi+0x17c>
    282a:	82 e0       	ldi	r24, 0x02	; 2
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
    282c:	df 91       	pop	r29
    282e:	cf 91       	pop	r28
    2830:	1f 91       	pop	r17
    2832:	0f 91       	pop	r16
    2834:	ff 90       	pop	r15
    2836:	ef 90       	pop	r14
    2838:	08 95       	ret

0000283a <dir_remove>:
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
	DIR *dj				/* Directory object pointing the entry to be removed */
)
{
    283a:	cf 93       	push	r28
    283c:	df 93       	push	r29
    283e:	ec 01       	movw	r28, r24
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
	}

#else			/* Non LFN configuration */
	res = dir_sdi(dj, dj->index);
    2840:	6c 81       	ldd	r22, Y+4	; 0x04
    2842:	7d 81       	ldd	r23, Y+5	; 0x05
    2844:	0e 94 58 13 	call	0x26b0	; 0x26b0 <dir_sdi>
	if (res == FR_OK) {
    2848:	88 23       	and	r24, r24
    284a:	91 f4       	brne	.+36     	; 0x2870 <dir_remove+0x36>
		res = move_window(dj->fs, dj->sect);
    284c:	4e 85       	ldd	r20, Y+14	; 0x0e
    284e:	5f 85       	ldd	r21, Y+15	; 0x0f
    2850:	68 89       	ldd	r22, Y+16	; 0x10
    2852:	79 89       	ldd	r23, Y+17	; 0x11
    2854:	88 81       	ld	r24, Y
    2856:	99 81       	ldd	r25, Y+1	; 0x01
    2858:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
		if (res == FR_OK) {
    285c:	88 23       	and	r24, r24
    285e:	41 f4       	brne	.+16     	; 0x2870 <dir_remove+0x36>
			*dj->dir = DDE;			/* Mark the entry "deleted" */
    2860:	ea 89       	ldd	r30, Y+18	; 0x12
    2862:	fb 89       	ldd	r31, Y+19	; 0x13
    2864:	95 ee       	ldi	r25, 0xE5	; 229
    2866:	90 83       	st	Z, r25
			dj->fs->wflag = 1;
    2868:	e8 81       	ld	r30, Y
    286a:	f9 81       	ldd	r31, Y+1	; 0x01
    286c:	91 e0       	ldi	r25, 0x01	; 1
    286e:	94 83       	std	Z+4, r25	; 0x04
		}
	}
#endif

	return res;
}
    2870:	df 91       	pop	r29
    2872:	cf 91       	pop	r28
    2874:	08 95       	ret

00002876 <put_fat>:
FRESULT put_fat (
	FATFS *fs,	/* File system object */
	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
	DWORD val	/* New value to mark the cluster */
)
{
    2876:	4f 92       	push	r4
    2878:	5f 92       	push	r5
    287a:	6f 92       	push	r6
    287c:	7f 92       	push	r7
    287e:	8f 92       	push	r8
    2880:	9f 92       	push	r9
    2882:	af 92       	push	r10
    2884:	bf 92       	push	r11
    2886:	cf 92       	push	r12
    2888:	df 92       	push	r13
    288a:	ef 92       	push	r14
    288c:	ff 92       	push	r15
    288e:	0f 93       	push	r16
    2890:	1f 93       	push	r17
    2892:	cf 93       	push	r28
    2894:	df 93       	push	r29
    2896:	ec 01       	movw	r28, r24
    2898:	6a 01       	movw	r12, r20
    289a:	7b 01       	movw	r14, r22
    289c:	48 01       	movw	r8, r16
    289e:	59 01       	movw	r10, r18
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    28a0:	42 30       	cpi	r20, 0x02	; 2
    28a2:	51 05       	cpc	r21, r1
    28a4:	61 05       	cpc	r22, r1
    28a6:	71 05       	cpc	r23, r1
    28a8:	08 f4       	brcc	.+2      	; 0x28ac <put_fat+0x36>
    28aa:	e0 c0       	rjmp	.+448    	; 0x2a6c <put_fat+0x1f6>
    28ac:	8a 8d       	ldd	r24, Y+26	; 0x1a
    28ae:	9b 8d       	ldd	r25, Y+27	; 0x1b
    28b0:	ac 8d       	ldd	r26, Y+28	; 0x1c
    28b2:	bd 8d       	ldd	r27, Y+29	; 0x1d
    28b4:	48 17       	cp	r20, r24
    28b6:	59 07       	cpc	r21, r25
    28b8:	6a 07       	cpc	r22, r26
    28ba:	7b 07       	cpc	r23, r27
    28bc:	08 f0       	brcs	.+2      	; 0x28c0 <put_fat+0x4a>
    28be:	d8 c0       	rjmp	.+432    	; 0x2a70 <put_fat+0x1fa>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
    28c0:	88 81       	ld	r24, Y
    28c2:	82 30       	cpi	r24, 0x02	; 2
    28c4:	09 f4       	brne	.+2      	; 0x28c8 <put_fat+0x52>
    28c6:	80 c0       	rjmp	.+256    	; 0x29c8 <put_fat+0x152>
    28c8:	83 30       	cpi	r24, 0x03	; 3
    28ca:	09 f4       	brne	.+2      	; 0x28ce <put_fat+0x58>
    28cc:	98 c0       	rjmp	.+304    	; 0x29fe <put_fat+0x188>
    28ce:	81 30       	cpi	r24, 0x01	; 1
    28d0:	09 f0       	breq	.+2      	; 0x28d4 <put_fat+0x5e>
    28d2:	c8 c0       	rjmp	.+400    	; 0x2a64 <put_fat+0x1ee>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
    28d4:	db 01       	movw	r26, r22
    28d6:	ca 01       	movw	r24, r20
    28d8:	b6 95       	lsr	r27
    28da:	a7 95       	ror	r26
    28dc:	97 95       	ror	r25
    28de:	87 95       	ror	r24
    28e0:	2c 01       	movw	r4, r24
    28e2:	3d 01       	movw	r6, r26
    28e4:	44 0e       	add	r4, r20
    28e6:	55 1e       	adc	r5, r21
    28e8:	66 1e       	adc	r6, r22
    28ea:	77 1e       	adc	r7, r23
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    28ec:	b3 01       	movw	r22, r6
    28ee:	a2 01       	movw	r20, r4
    28f0:	03 2e       	mov	r0, r19
    28f2:	39 e0       	ldi	r19, 0x09	; 9
    28f4:	76 95       	lsr	r23
    28f6:	67 95       	ror	r22
    28f8:	57 95       	ror	r21
    28fa:	47 95       	ror	r20
    28fc:	3a 95       	dec	r19
    28fe:	d1 f7       	brne	.-12     	; 0x28f4 <put_fat+0x7e>
    2900:	30 2d       	mov	r19, r0
    2902:	8a a1       	lds	r24, 0x4a
    2904:	9b a1       	lds	r25, 0x4b
    2906:	ac a1       	lds	r26, 0x4c
    2908:	bd a1       	lds	r27, 0x4d
    290a:	48 0f       	add	r20, r24
    290c:	59 1f       	adc	r21, r25
    290e:	6a 1f       	adc	r22, r26
    2910:	7b 1f       	adc	r23, r27
    2912:	ce 01       	movw	r24, r28
    2914:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
			if (res != FR_OK) break;
    2918:	88 23       	and	r24, r24
    291a:	09 f0       	breq	.+2      	; 0x291e <put_fat+0xa8>
    291c:	a4 c0       	rjmp	.+328    	; 0x2a66 <put_fat+0x1f0>
			p = &fs->win[bc % SS(fs)];
    291e:	c2 01       	movw	r24, r4
    2920:	91 70       	andi	r25, 0x01	; 1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    2922:	31 e0       	ldi	r19, 0x01	; 1
    2924:	c3 22       	and	r12, r19
    2926:	dd 24       	eor	r13, r13
    2928:	c1 14       	cp	r12, r1
    292a:	d1 04       	cpc	r13, r1
    292c:	51 f0       	breq	.+20     	; 0x2942 <put_fat+0xcc>
    292e:	fe 01       	movw	r30, r28
    2930:	e8 0f       	add	r30, r24
    2932:	f9 1f       	adc	r31, r25
    2934:	22 a9       	sts	0x42, r18
    2936:	2f 70       	andi	r18, 0x0F	; 15
    2938:	38 2d       	mov	r19, r8
    293a:	32 95       	swap	r19
    293c:	30 7f       	andi	r19, 0xF0	; 240
    293e:	23 2b       	or	r18, r19
    2940:	01 c0       	rjmp	.+2      	; 0x2944 <put_fat+0xce>
    2942:	28 2d       	mov	r18, r8
    2944:	fe 01       	movw	r30, r28
    2946:	e8 0f       	add	r30, r24
    2948:	f9 1f       	adc	r31, r25
    294a:	22 ab       	sts	0x52, r18
			bc++;
    294c:	08 94       	sec
    294e:	41 1c       	adc	r4, r1
    2950:	51 1c       	adc	r5, r1
    2952:	61 1c       	adc	r6, r1
    2954:	71 1c       	adc	r7, r1
			fs->wflag = 1;
    2956:	81 e0       	ldi	r24, 0x01	; 1
    2958:	8c 83       	std	Y+4, r24	; 0x04
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    295a:	b3 01       	movw	r22, r6
    295c:	a2 01       	movw	r20, r4
    295e:	03 2e       	mov	r0, r19
    2960:	39 e0       	ldi	r19, 0x09	; 9
    2962:	76 95       	lsr	r23
    2964:	67 95       	ror	r22
    2966:	57 95       	ror	r21
    2968:	47 95       	ror	r20
    296a:	3a 95       	dec	r19
    296c:	d1 f7       	brne	.-12     	; 0x2962 <put_fat+0xec>
    296e:	30 2d       	mov	r19, r0
    2970:	8a a1       	lds	r24, 0x4a
    2972:	9b a1       	lds	r25, 0x4b
    2974:	ac a1       	lds	r26, 0x4c
    2976:	bd a1       	lds	r27, 0x4d
    2978:	48 0f       	add	r20, r24
    297a:	59 1f       	adc	r21, r25
    297c:	6a 1f       	adc	r22, r26
    297e:	7b 1f       	adc	r23, r27
    2980:	ce 01       	movw	r24, r28
    2982:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
			if (res != FR_OK) break;
    2986:	88 23       	and	r24, r24
    2988:	09 f0       	breq	.+2      	; 0x298c <put_fat+0x116>
    298a:	6d c0       	rjmp	.+218    	; 0x2a66 <put_fat+0x1f0>
			p = &fs->win[bc % SS(fs)];
    298c:	ef ef       	ldi	r30, 0xFF	; 255
    298e:	f1 e0       	ldi	r31, 0x01	; 1
    2990:	4e 22       	and	r4, r30
    2992:	5f 22       	and	r5, r31
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    2994:	c1 14       	cp	r12, r1
    2996:	d1 04       	cpc	r13, r1
    2998:	49 f0       	breq	.+18     	; 0x29ac <put_fat+0x136>
    299a:	68 94       	set
    299c:	13 f8       	bld	r1, 3
    299e:	b6 94       	lsr	r11
    29a0:	a7 94       	ror	r10
    29a2:	97 94       	ror	r9
    29a4:	87 94       	ror	r8
    29a6:	16 94       	lsr	r1
    29a8:	d1 f7       	brne	.-12     	; 0x299e <put_fat+0x128>
    29aa:	09 c0       	rjmp	.+18     	; 0x29be <put_fat+0x148>
    29ac:	fe 01       	movw	r30, r28
    29ae:	e4 0d       	add	r30, r4
    29b0:	f5 1d       	adc	r31, r5
    29b2:	22 a9       	sts	0x42, r18
    29b4:	20 7f       	andi	r18, 0xF0	; 240
    29b6:	99 2d       	mov	r25, r9
    29b8:	9f 70       	andi	r25, 0x0F	; 15
    29ba:	82 2e       	mov	r8, r18
    29bc:	89 2a       	or	r8, r25
    29be:	4c 0e       	add	r4, r28
    29c0:	5d 1e       	adc	r5, r29
    29c2:	f2 01       	movw	r30, r4
    29c4:	82 aa       	sts	0x92, r24
			break;
    29c6:	4f c0       	rjmp	.+158    	; 0x2a66 <put_fat+0x1f0>

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    29c8:	45 2f       	mov	r20, r21
    29ca:	56 2f       	mov	r21, r22
    29cc:	67 2f       	mov	r22, r23
    29ce:	77 27       	eor	r23, r23
    29d0:	8a a1       	lds	r24, 0x4a
    29d2:	9b a1       	lds	r25, 0x4b
    29d4:	ac a1       	lds	r26, 0x4c
    29d6:	bd a1       	lds	r27, 0x4d
    29d8:	48 0f       	add	r20, r24
    29da:	59 1f       	adc	r21, r25
    29dc:	6a 1f       	adc	r22, r26
    29de:	7b 1f       	adc	r23, r27
    29e0:	ce 01       	movw	r24, r28
    29e2:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
			if (res != FR_OK) break;
    29e6:	88 23       	and	r24, r24
    29e8:	09 f0       	breq	.+2      	; 0x29ec <put_fat+0x176>
    29ea:	3d c0       	rjmp	.+122    	; 0x2a66 <put_fat+0x1f0>
			p = &fs->win[clst * 2 % SS(fs)];
    29ec:	f6 01       	movw	r30, r12
    29ee:	ee 0f       	add	r30, r30
    29f0:	ff 1f       	adc	r31, r31
    29f2:	f1 70       	andi	r31, 0x01	; 1
			ST_WORD(p, (WORD)val);
    29f4:	ec 0f       	add	r30, r28
    29f6:	fd 1f       	adc	r31, r29
    29f8:	82 aa       	sts	0x92, r24
    29fa:	93 aa       	sts	0x93, r25
			break;
    29fc:	34 c0       	rjmp	.+104    	; 0x2a66 <put_fat+0x1f0>

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    29fe:	68 94       	set
    2a00:	16 f8       	bld	r1, 6
    2a02:	76 95       	lsr	r23
    2a04:	67 95       	ror	r22
    2a06:	57 95       	ror	r21
    2a08:	47 95       	ror	r20
    2a0a:	16 94       	lsr	r1
    2a0c:	d1 f7       	brne	.-12     	; 0x2a02 <put_fat+0x18c>
    2a0e:	8a a1       	lds	r24, 0x4a
    2a10:	9b a1       	lds	r25, 0x4b
    2a12:	ac a1       	lds	r26, 0x4c
    2a14:	bd a1       	lds	r27, 0x4d
    2a16:	48 0f       	add	r20, r24
    2a18:	59 1f       	adc	r21, r25
    2a1a:	6a 1f       	adc	r22, r26
    2a1c:	7b 1f       	adc	r23, r27
    2a1e:	ce 01       	movw	r24, r28
    2a20:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
			if (res != FR_OK) break;
    2a24:	88 23       	and	r24, r24
    2a26:	f9 f4       	brne	.+62     	; 0x2a66 <put_fat+0x1f0>
			p = &fs->win[clst * 4 % SS(fs)];
    2a28:	96 01       	movw	r18, r12
    2a2a:	22 0f       	add	r18, r18
    2a2c:	33 1f       	adc	r19, r19
    2a2e:	22 0f       	add	r18, r18
    2a30:	33 1f       	adc	r19, r19
    2a32:	31 70       	andi	r19, 0x01	; 1
			val |= LD_DWORD(p) & 0xF0000000;
    2a34:	fe 01       	movw	r30, r28
    2a36:	e2 0f       	add	r30, r18
    2a38:	f3 1f       	adc	r31, r19
    2a3a:	45 a9       	sts	0x45, r20
    2a3c:	50 e0       	ldi	r21, 0x00	; 0
    2a3e:	60 e0       	ldi	r22, 0x00	; 0
    2a40:	70 e0       	ldi	r23, 0x00	; 0
    2a42:	74 2f       	mov	r23, r20
    2a44:	66 27       	eor	r22, r22
    2a46:	55 27       	eor	r21, r21
    2a48:	44 27       	eor	r20, r20
    2a4a:	40 70       	andi	r20, 0x00	; 0
    2a4c:	50 70       	andi	r21, 0x00	; 0
    2a4e:	60 70       	andi	r22, 0x00	; 0
    2a50:	70 7f       	andi	r23, 0xF0	; 240
    2a52:	48 29       	or	r20, r8
    2a54:	59 29       	or	r21, r9
    2a56:	6a 29       	or	r22, r10
    2a58:	7b 29       	or	r23, r11
			ST_DWORD(p, val);
    2a5a:	42 ab       	sts	0x52, r20
    2a5c:	53 ab       	sts	0x53, r21
    2a5e:	64 ab       	sts	0x54, r22
    2a60:	75 ab       	sts	0x55, r23
			break;
    2a62:	01 c0       	rjmp	.+2      	; 0x2a66 <put_fat+0x1f0>

		default :
			res = FR_INT_ERR;
    2a64:	82 e0       	ldi	r24, 0x02	; 2
		}
		fs->wflag = 1;
    2a66:	91 e0       	ldi	r25, 0x01	; 1
    2a68:	9c 83       	std	Y+4, r25	; 0x04
    2a6a:	03 c0       	rjmp	.+6      	; 0x2a72 <put_fat+0x1fc>
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
    2a6c:	82 e0       	ldi	r24, 0x02	; 2
    2a6e:	01 c0       	rjmp	.+2      	; 0x2a72 <put_fat+0x1fc>
    2a70:	82 e0       	ldi	r24, 0x02	; 2
		}
		fs->wflag = 1;
	}

	return res;
}
    2a72:	df 91       	pop	r29
    2a74:	cf 91       	pop	r28
    2a76:	1f 91       	pop	r17
    2a78:	0f 91       	pop	r16
    2a7a:	ff 90       	pop	r15
    2a7c:	ef 90       	pop	r14
    2a7e:	df 90       	pop	r13
    2a80:	cf 90       	pop	r12
    2a82:	bf 90       	pop	r11
    2a84:	af 90       	pop	r10
    2a86:	9f 90       	pop	r9
    2a88:	8f 90       	pop	r8
    2a8a:	7f 90       	pop	r7
    2a8c:	6f 90       	pop	r6
    2a8e:	5f 90       	pop	r5
    2a90:	4f 90       	pop	r4
    2a92:	08 95       	ret

00002a94 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
    2a94:	2f 92       	push	r2
    2a96:	3f 92       	push	r3
    2a98:	4f 92       	push	r4
    2a9a:	5f 92       	push	r5
    2a9c:	6f 92       	push	r6
    2a9e:	7f 92       	push	r7
    2aa0:	8f 92       	push	r8
    2aa2:	9f 92       	push	r9
    2aa4:	af 92       	push	r10
    2aa6:	bf 92       	push	r11
    2aa8:	cf 92       	push	r12
    2aaa:	df 92       	push	r13
    2aac:	ef 92       	push	r14
    2aae:	ff 92       	push	r15
    2ab0:	0f 93       	push	r16
    2ab2:	1f 93       	push	r17
    2ab4:	cf 93       	push	r28
    2ab6:	df 93       	push	r29
    2ab8:	00 d0       	rcall	.+0      	; 0x2aba <create_chain+0x26>
    2aba:	00 d0       	rcall	.+0      	; 0x2abc <create_chain+0x28>
    2abc:	cd b7       	in	r28, 0x3d	; 61
    2abe:	de b7       	in	r29, 0x3e	; 62
    2ac0:	1c 01       	movw	r2, r24
    2ac2:	49 83       	std	Y+1, r20	; 0x01
    2ac4:	5a 83       	std	Y+2, r21	; 0x02
    2ac6:	6b 83       	std	Y+3, r22	; 0x03
    2ac8:	7c 83       	std	Y+4, r23	; 0x04
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
    2aca:	41 15       	cp	r20, r1
    2acc:	51 05       	cpc	r21, r1
    2ace:	61 05       	cpc	r22, r1
    2ad0:	71 05       	cpc	r23, r1
    2ad2:	c1 f4       	brne	.+48     	; 0x2b04 <create_chain+0x70>
		scl = fs->last_clust;			/* Get suggested start point */
    2ad4:	dc 01       	movw	r26, r24
    2ad6:	1a 96       	adiw	r26, 0x0a	; 10
    2ad8:	8d 90       	ld	r8, X+
    2ada:	9d 90       	ld	r9, X+
    2adc:	ad 90       	ld	r10, X+
    2ade:	bc 90       	ld	r11, X
    2ae0:	1d 97       	sbiw	r26, 0x0d	; 13
		if (!scl || scl >= fs->n_fatent) scl = 1;
    2ae2:	81 14       	cp	r8, r1
    2ae4:	91 04       	cpc	r9, r1
    2ae6:	a1 04       	cpc	r10, r1
    2ae8:	b1 04       	cpc	r11, r1
    2aea:	51 f1       	breq	.+84     	; 0x2b40 <create_chain+0xac>
    2aec:	5a 96       	adiw	r26, 0x1a	; 26
    2aee:	8d 91       	ld	r24, X+
    2af0:	9d 91       	ld	r25, X+
    2af2:	0d 90       	ld	r0, X+
    2af4:	bc 91       	ld	r27, X
    2af6:	a0 2d       	mov	r26, r0
    2af8:	88 16       	cp	r8, r24
    2afa:	99 06       	cpc	r9, r25
    2afc:	aa 06       	cpc	r10, r26
    2afe:	bb 06       	cpc	r11, r27
    2b00:	20 f5       	brcc	.+72     	; 0x2b4a <create_chain+0xb6>
    2b02:	27 c0       	rjmp	.+78     	; 0x2b52 <create_chain+0xbe>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
    2b04:	49 81       	ldd	r20, Y+1	; 0x01
    2b06:	5a 81       	ldd	r21, Y+2	; 0x02
    2b08:	6b 81       	ldd	r22, Y+3	; 0x03
    2b0a:	7c 81       	ldd	r23, Y+4	; 0x04
    2b0c:	0e 94 21 12 	call	0x2442	; 0x2442 <get_fat>
    2b10:	8b 01       	movw	r16, r22
    2b12:	9c 01       	movw	r18, r24
		if (cs < 2) return 1;			/* It is an invalid cluster */
    2b14:	62 30       	cpi	r22, 0x02	; 2
    2b16:	71 05       	cpc	r23, r1
    2b18:	81 05       	cpc	r24, r1
    2b1a:	91 05       	cpc	r25, r1
    2b1c:	08 f4       	brcc	.+2      	; 0x2b20 <create_chain+0x8c>
    2b1e:	ad c0       	rjmp	.+346    	; 0x2c7a <create_chain+0x1e6>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    2b20:	f1 01       	movw	r30, r2
    2b22:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b24:	93 8d       	ldd	r25, Z+27	; 0x1b
    2b26:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2b28:	b5 8d       	ldd	r27, Z+29	; 0x1d
    2b2a:	08 17       	cp	r16, r24
    2b2c:	19 07       	cpc	r17, r25
    2b2e:	2a 07       	cpc	r18, r26
    2b30:	3b 07       	cpc	r19, r27
    2b32:	08 f4       	brcc	.+2      	; 0x2b36 <create_chain+0xa2>
    2b34:	b6 c0       	rjmp	.+364    	; 0x2ca2 <create_chain+0x20e>
		scl = clst;
    2b36:	89 80       	ldd	r8, Y+1	; 0x01
    2b38:	9a 80       	ldd	r9, Y+2	; 0x02
    2b3a:	ab 80       	ldd	r10, Y+3	; 0x03
    2b3c:	bc 80       	ldd	r11, Y+4	; 0x04
    2b3e:	09 c0       	rjmp	.+18     	; 0x2b52 <create_chain+0xbe>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
    2b40:	88 24       	eor	r8, r8
    2b42:	99 24       	eor	r9, r9
    2b44:	54 01       	movw	r10, r8
    2b46:	83 94       	inc	r8
    2b48:	04 c0       	rjmp	.+8      	; 0x2b52 <create_chain+0xbe>
    2b4a:	88 24       	eor	r8, r8
    2b4c:	99 24       	eor	r9, r9
    2b4e:	54 01       	movw	r10, r8
    2b50:	83 94       	inc	r8
		if (cs < 2) return 1;			/* It is an invalid cluster */
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
    2b52:	75 01       	movw	r14, r10
    2b54:	64 01       	movw	r12, r8
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
    2b56:	44 24       	eor	r4, r4
    2b58:	55 24       	eor	r5, r5
    2b5a:	32 01       	movw	r6, r4
    2b5c:	68 94       	set
    2b5e:	41 f8       	bld	r4, 1
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
    2b60:	08 94       	sec
    2b62:	c1 1c       	adc	r12, r1
    2b64:	d1 1c       	adc	r13, r1
    2b66:	e1 1c       	adc	r14, r1
    2b68:	f1 1c       	adc	r15, r1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
    2b6a:	f1 01       	movw	r30, r2
    2b6c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b6e:	93 8d       	ldd	r25, Z+27	; 0x1b
    2b70:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2b72:	b5 8d       	ldd	r27, Z+29	; 0x1d
    2b74:	c8 16       	cp	r12, r24
    2b76:	d9 06       	cpc	r13, r25
    2b78:	ea 06       	cpc	r14, r26
    2b7a:	fb 06       	cpc	r15, r27
    2b7c:	48 f0       	brcs	.+18     	; 0x2b90 <create_chain+0xfc>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
    2b7e:	f2 e0       	ldi	r31, 0x02	; 2
    2b80:	8f 16       	cp	r8, r31
    2b82:	91 04       	cpc	r9, r1
    2b84:	a1 04       	cpc	r10, r1
    2b86:	b1 04       	cpc	r11, r1
    2b88:	08 f4       	brcc	.+2      	; 0x2b8c <create_chain+0xf8>
    2b8a:	7c c0       	rjmp	.+248    	; 0x2c84 <create_chain+0x1f0>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
    2b8c:	73 01       	movw	r14, r6
    2b8e:	62 01       	movw	r12, r4
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
    2b90:	c1 01       	movw	r24, r2
    2b92:	b7 01       	movw	r22, r14
    2b94:	a6 01       	movw	r20, r12
    2b96:	0e 94 21 12 	call	0x2442	; 0x2442 <get_fat>
    2b9a:	8b 01       	movw	r16, r22
    2b9c:	9c 01       	movw	r18, r24
		if (cs == 0) break;				/* Found a free cluster */
    2b9e:	61 15       	cp	r22, r1
    2ba0:	71 05       	cpc	r23, r1
    2ba2:	81 05       	cpc	r24, r1
    2ba4:	91 05       	cpc	r25, r1
    2ba6:	a9 f0       	breq	.+42     	; 0x2bd2 <create_chain+0x13e>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    2ba8:	0f 3f       	cpi	r16, 0xFF	; 255
    2baa:	8f ef       	ldi	r24, 0xFF	; 255
    2bac:	18 07       	cpc	r17, r24
    2bae:	8f ef       	ldi	r24, 0xFF	; 255
    2bb0:	28 07       	cpc	r18, r24
    2bb2:	8f ef       	ldi	r24, 0xFF	; 255
    2bb4:	38 07       	cpc	r19, r24
    2bb6:	09 f4       	brne	.+2      	; 0x2bba <create_chain+0x126>
    2bb8:	74 c0       	rjmp	.+232    	; 0x2ca2 <create_chain+0x20e>
    2bba:	01 30       	cpi	r16, 0x01	; 1
    2bbc:	11 05       	cpc	r17, r1
    2bbe:	21 05       	cpc	r18, r1
    2bc0:	31 05       	cpc	r19, r1
    2bc2:	09 f4       	brne	.+2      	; 0x2bc6 <create_chain+0x132>
    2bc4:	6e c0       	rjmp	.+220    	; 0x2ca2 <create_chain+0x20e>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
    2bc6:	c8 14       	cp	r12, r8
    2bc8:	d9 04       	cpc	r13, r9
    2bca:	ea 04       	cpc	r14, r10
    2bcc:	fb 04       	cpc	r15, r11
    2bce:	41 f6       	brne	.-112    	; 0x2b60 <create_chain+0xcc>
    2bd0:	5d c0       	rjmp	.+186    	; 0x2c8c <create_chain+0x1f8>
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
    2bd2:	8c 2c       	mov	r8, r12
    2bd4:	4d 2c       	mov	r4, r13
    2bd6:	be 2c       	mov	r11, r14
    2bd8:	af 2c       	mov	r10, r15
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    2bda:	c1 01       	movw	r24, r2
    2bdc:	4c 2d       	mov	r20, r12
    2bde:	5d 2d       	mov	r21, r13
    2be0:	6e 2d       	mov	r22, r14
    2be2:	7f 2d       	mov	r23, r15
    2be4:	0f ef       	ldi	r16, 0xFF	; 255
    2be6:	1f ef       	ldi	r17, 0xFF	; 255
    2be8:	2f ef       	ldi	r18, 0xFF	; 255
    2bea:	3f e0       	ldi	r19, 0x0F	; 15
    2bec:	0e 94 3b 14 	call	0x2876	; 0x2876 <put_fat>
	if (res == FR_OK && clst != 0) {
    2bf0:	88 23       	and	r24, r24
    2bf2:	e9 f5       	brne	.+122    	; 0x2c6e <create_chain+0x1da>
    2bf4:	89 81       	ldd	r24, Y+1	; 0x01
    2bf6:	9a 81       	ldd	r25, Y+2	; 0x02
    2bf8:	ab 81       	ldd	r26, Y+3	; 0x03
    2bfa:	bc 81       	ldd	r27, Y+4	; 0x04
    2bfc:	00 97       	sbiw	r24, 0x00	; 0
    2bfe:	a1 05       	cpc	r26, r1
    2c00:	b1 05       	cpc	r27, r1
    2c02:	69 f0       	breq	.+26     	; 0x2c1e <create_chain+0x18a>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    2c04:	c1 01       	movw	r24, r2
    2c06:	49 81       	ldd	r20, Y+1	; 0x01
    2c08:	5a 81       	ldd	r21, Y+2	; 0x02
    2c0a:	6b 81       	ldd	r22, Y+3	; 0x03
    2c0c:	7c 81       	ldd	r23, Y+4	; 0x04
    2c0e:	0c 2d       	mov	r16, r12
    2c10:	1d 2d       	mov	r17, r13
    2c12:	2e 2d       	mov	r18, r14
    2c14:	3f 2d       	mov	r19, r15
    2c16:	0e 94 3b 14 	call	0x2876	; 0x2876 <put_fat>
	}
	if (res == FR_OK) {
    2c1a:	88 23       	and	r24, r24
    2c1c:	41 f5       	brne	.+80     	; 0x2c6e <create_chain+0x1da>
		fs->last_clust = ncl;			/* Update FSINFO */
    2c1e:	d1 01       	movw	r26, r2
    2c20:	1a 96       	adiw	r26, 0x0a	; 10
    2c22:	8c 92       	st	X, r8
    2c24:	1a 97       	sbiw	r26, 0x0a	; 10
    2c26:	1b 96       	adiw	r26, 0x0b	; 11
    2c28:	4c 92       	st	X, r4
    2c2a:	1b 97       	sbiw	r26, 0x0b	; 11
    2c2c:	1c 96       	adiw	r26, 0x0c	; 12
    2c2e:	bc 92       	st	X, r11
    2c30:	1c 97       	sbiw	r26, 0x0c	; 12
    2c32:	1d 96       	adiw	r26, 0x0d	; 13
    2c34:	ac 92       	st	X, r10
    2c36:	1d 97       	sbiw	r26, 0x0d	; 13
		if (fs->free_clust != 0xFFFFFFFF) {
    2c38:	1e 96       	adiw	r26, 0x0e	; 14
    2c3a:	8d 91       	ld	r24, X+
    2c3c:	9d 91       	ld	r25, X+
    2c3e:	0d 90       	ld	r0, X+
    2c40:	bc 91       	ld	r27, X
    2c42:	a0 2d       	mov	r26, r0
    2c44:	8f 3f       	cpi	r24, 0xFF	; 255
    2c46:	ef ef       	ldi	r30, 0xFF	; 255
    2c48:	9e 07       	cpc	r25, r30
    2c4a:	ef ef       	ldi	r30, 0xFF	; 255
    2c4c:	ae 07       	cpc	r26, r30
    2c4e:	ef ef       	ldi	r30, 0xFF	; 255
    2c50:	be 07       	cpc	r27, r30
    2c52:	01 f1       	breq	.+64     	; 0x2c94 <create_chain+0x200>
			fs->free_clust--;
    2c54:	01 97       	sbiw	r24, 0x01	; 1
    2c56:	a1 09       	sbc	r26, r1
    2c58:	b1 09       	sbc	r27, r1
    2c5a:	f1 01       	movw	r30, r2
    2c5c:	86 87       	std	Z+14, r24	; 0x0e
    2c5e:	97 87       	std	Z+15, r25	; 0x0f
    2c60:	a0 8b       	std	Z+16, r26	; 0x10
    2c62:	b1 8b       	std	Z+17, r27	; 0x11
			fs->fsi_flag = 1;
    2c64:	81 e0       	ldi	r24, 0x01	; 1
    2c66:	85 83       	std	Z+5, r24	; 0x05
    2c68:	97 01       	movw	r18, r14
    2c6a:	86 01       	movw	r16, r12
    2c6c:	1a c0       	rjmp	.+52     	; 0x2ca2 <create_chain+0x20e>
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    2c6e:	81 30       	cpi	r24, 0x01	; 1
    2c70:	a1 f4       	brne	.+40     	; 0x2c9a <create_chain+0x206>
    2c72:	0f ef       	ldi	r16, 0xFF	; 255
    2c74:	1f ef       	ldi	r17, 0xFF	; 255
    2c76:	98 01       	movw	r18, r16
    2c78:	14 c0       	rjmp	.+40     	; 0x2ca2 <create_chain+0x20e>
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* It is an invalid cluster */
    2c7a:	01 e0       	ldi	r16, 0x01	; 1
    2c7c:	10 e0       	ldi	r17, 0x00	; 0
    2c7e:	20 e0       	ldi	r18, 0x00	; 0
    2c80:	30 e0       	ldi	r19, 0x00	; 0
    2c82:	0f c0       	rjmp	.+30     	; 0x2ca2 <create_chain+0x20e>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
    2c84:	00 e0       	ldi	r16, 0x00	; 0
    2c86:	10 e0       	ldi	r17, 0x00	; 0
    2c88:	98 01       	movw	r18, r16
    2c8a:	0b c0       	rjmp	.+22     	; 0x2ca2 <create_chain+0x20e>
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
    2c8c:	00 e0       	ldi	r16, 0x00	; 0
    2c8e:	10 e0       	ldi	r17, 0x00	; 0
    2c90:	98 01       	movw	r18, r16
    2c92:	07 c0       	rjmp	.+14     	; 0x2ca2 <create_chain+0x20e>
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
    2c94:	97 01       	movw	r18, r14
    2c96:	86 01       	movw	r16, r12
    2c98:	04 c0       	rjmp	.+8      	; 0x2ca2 <create_chain+0x20e>
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    2c9a:	01 e0       	ldi	r16, 0x01	; 1
    2c9c:	10 e0       	ldi	r17, 0x00	; 0
    2c9e:	20 e0       	ldi	r18, 0x00	; 0
    2ca0:	30 e0       	ldi	r19, 0x00	; 0
	}

	return ncl;		/* Return new cluster number or error code */
}
    2ca2:	60 2f       	mov	r22, r16
    2ca4:	71 2f       	mov	r23, r17
    2ca6:	82 2f       	mov	r24, r18
    2ca8:	93 2f       	mov	r25, r19
    2caa:	0f 90       	pop	r0
    2cac:	0f 90       	pop	r0
    2cae:	0f 90       	pop	r0
    2cb0:	0f 90       	pop	r0
    2cb2:	df 91       	pop	r29
    2cb4:	cf 91       	pop	r28
    2cb6:	1f 91       	pop	r17
    2cb8:	0f 91       	pop	r16
    2cba:	ff 90       	pop	r15
    2cbc:	ef 90       	pop	r14
    2cbe:	df 90       	pop	r13
    2cc0:	cf 90       	pop	r12
    2cc2:	bf 90       	pop	r11
    2cc4:	af 90       	pop	r10
    2cc6:	9f 90       	pop	r9
    2cc8:	8f 90       	pop	r8
    2cca:	7f 90       	pop	r7
    2ccc:	6f 90       	pop	r6
    2cce:	5f 90       	pop	r5
    2cd0:	4f 90       	pop	r4
    2cd2:	3f 90       	pop	r3
    2cd4:	2f 90       	pop	r2
    2cd6:	08 95       	ret

00002cd8 <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
    2cd8:	8f 92       	push	r8
    2cda:	9f 92       	push	r9
    2cdc:	af 92       	push	r10
    2cde:	bf 92       	push	r11
    2ce0:	cf 92       	push	r12
    2ce2:	df 92       	push	r13
    2ce4:	ef 92       	push	r14
    2ce6:	ff 92       	push	r15
    2ce8:	0f 93       	push	r16
    2cea:	1f 93       	push	r17
    2cec:	cf 93       	push	r28
    2cee:	df 93       	push	r29
    2cf0:	8c 01       	movw	r16, r24
    2cf2:	eb 01       	movw	r28, r22
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
    2cf4:	dc 01       	movw	r26, r24
    2cf6:	14 96       	adiw	r26, 0x04	; 4
    2cf8:	ed 90       	ld	r14, X+
    2cfa:	fc 90       	ld	r15, X
    2cfc:	15 97       	sbiw	r26, 0x05	; 5
    2cfe:	08 94       	sec
    2d00:	e1 1c       	adc	r14, r1
    2d02:	f1 1c       	adc	r15, r1
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    2d04:	e1 14       	cp	r14, r1
    2d06:	f1 04       	cpc	r15, r1
    2d08:	09 f4       	brne	.+2      	; 0x2d0c <dir_next+0x34>
    2d0a:	0b c1       	rjmp	.+534    	; 0x2f22 <dir_next+0x24a>
    2d0c:	1e 96       	adiw	r26, 0x0e	; 14
    2d0e:	8d 91       	ld	r24, X+
    2d10:	9d 91       	ld	r25, X+
    2d12:	0d 90       	ld	r0, X+
    2d14:	bc 91       	ld	r27, X
    2d16:	a0 2d       	mov	r26, r0
    2d18:	00 97       	sbiw	r24, 0x00	; 0
    2d1a:	a1 05       	cpc	r26, r1
    2d1c:	b1 05       	cpc	r27, r1
    2d1e:	09 f4       	brne	.+2      	; 0x2d22 <dir_next+0x4a>
    2d20:	02 c1       	rjmp	.+516    	; 0x2f26 <dir_next+0x24e>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    2d22:	0f 2e       	mov	r0, r31
    2d24:	ff e0       	ldi	r31, 0x0F	; 15
    2d26:	cf 2e       	mov	r12, r31
    2d28:	dd 24       	eor	r13, r13
    2d2a:	f0 2d       	mov	r31, r0
    2d2c:	ce 20       	and	r12, r14
    2d2e:	df 20       	and	r13, r15
    2d30:	c1 14       	cp	r12, r1
    2d32:	d1 04       	cpc	r13, r1
    2d34:	09 f0       	breq	.+2      	; 0x2d38 <dir_next+0x60>
    2d36:	da c0       	rjmp	.+436    	; 0x2eec <dir_next+0x214>
		dj->sect++;					/* Next sector */
    2d38:	01 96       	adiw	r24, 0x01	; 1
    2d3a:	a1 1d       	adc	r26, r1
    2d3c:	b1 1d       	adc	r27, r1
    2d3e:	f8 01       	movw	r30, r16
    2d40:	86 87       	std	Z+14, r24	; 0x0e
    2d42:	97 87       	std	Z+15, r25	; 0x0f
    2d44:	a0 8b       	std	Z+16, r26	; 0x10
    2d46:	b1 8b       	std	Z+17, r27	; 0x11

		if (dj->clust == 0) {	/* Static table */
    2d48:	42 85       	ldd	r20, Z+10	; 0x0a
    2d4a:	53 85       	ldd	r21, Z+11	; 0x0b
    2d4c:	64 85       	ldd	r22, Z+12	; 0x0c
    2d4e:	75 85       	ldd	r23, Z+13	; 0x0d
    2d50:	41 15       	cp	r20, r1
    2d52:	51 05       	cpc	r21, r1
    2d54:	61 05       	cpc	r22, r1
    2d56:	71 05       	cpc	r23, r1
    2d58:	51 f4       	brne	.+20     	; 0x2d6e <dir_next+0x96>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    2d5a:	01 90       	ld	r0, Z+
    2d5c:	f0 81       	ld	r31, Z
    2d5e:	e0 2d       	mov	r30, r0
    2d60:	80 85       	ldd	r24, Z+8	; 0x08
    2d62:	91 85       	ldd	r25, Z+9	; 0x09
    2d64:	e8 16       	cp	r14, r24
    2d66:	f9 06       	cpc	r15, r25
    2d68:	08 f0       	brcs	.+2      	; 0x2d6c <dir_next+0x94>
    2d6a:	df c0       	rjmp	.+446    	; 0x2f2a <dir_next+0x252>
    2d6c:	bf c0       	rjmp	.+382    	; 0x2eec <dir_next+0x214>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    2d6e:	01 90       	ld	r0, Z+
    2d70:	f0 81       	ld	r31, Z
    2d72:	e0 2d       	mov	r30, r0
    2d74:	82 81       	ldd	r24, Z+2	; 0x02
    2d76:	90 e0       	ldi	r25, 0x00	; 0
    2d78:	01 97       	sbiw	r24, 0x01	; 1
    2d7a:	97 01       	movw	r18, r14
    2d7c:	32 95       	swap	r19
    2d7e:	22 95       	swap	r18
    2d80:	2f 70       	andi	r18, 0x0F	; 15
    2d82:	23 27       	eor	r18, r19
    2d84:	3f 70       	andi	r19, 0x0F	; 15
    2d86:	23 27       	eor	r18, r19
    2d88:	82 23       	and	r24, r18
    2d8a:	93 23       	and	r25, r19
    2d8c:	00 97       	sbiw	r24, 0x00	; 0
    2d8e:	09 f0       	breq	.+2      	; 0x2d92 <dir_next+0xba>
    2d90:	ad c0       	rjmp	.+346    	; 0x2eec <dir_next+0x214>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    2d92:	cf 01       	movw	r24, r30
    2d94:	0e 94 21 12 	call	0x2442	; 0x2442 <get_fat>
    2d98:	4b 01       	movw	r8, r22
    2d9a:	5c 01       	movw	r10, r24
				if (clst <= 1) return FR_INT_ERR;
    2d9c:	62 30       	cpi	r22, 0x02	; 2
    2d9e:	71 05       	cpc	r23, r1
    2da0:	81 05       	cpc	r24, r1
    2da2:	91 05       	cpc	r25, r1
    2da4:	08 f4       	brcc	.+2      	; 0x2da8 <dir_next+0xd0>
    2da6:	c3 c0       	rjmp	.+390    	; 0x2f2e <dir_next+0x256>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2da8:	6f 3f       	cpi	r22, 0xFF	; 255
    2daa:	ef ef       	ldi	r30, 0xFF	; 255
    2dac:	7e 07       	cpc	r23, r30
    2dae:	ef ef       	ldi	r30, 0xFF	; 255
    2db0:	8e 07       	cpc	r24, r30
    2db2:	ef ef       	ldi	r30, 0xFF	; 255
    2db4:	9e 07       	cpc	r25, r30
    2db6:	09 f4       	brne	.+2      	; 0x2dba <dir_next+0xe2>
    2db8:	bc c0       	rjmp	.+376    	; 0x2f32 <dir_next+0x25a>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    2dba:	d8 01       	movw	r26, r16
    2dbc:	ed 91       	ld	r30, X+
    2dbe:	fc 91       	ld	r31, X
    2dc0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2dc2:	93 8d       	ldd	r25, Z+27	; 0x1b
    2dc4:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2dc6:	b5 8d       	ldd	r27, Z+29	; 0x1d
    2dc8:	88 16       	cp	r8, r24
    2dca:	99 06       	cpc	r9, r25
    2dcc:	aa 06       	cpc	r10, r26
    2dce:	bb 06       	cpc	r11, r27
    2dd0:	08 f4       	brcc	.+2      	; 0x2dd4 <dir_next+0xfc>
    2dd2:	7a c0       	rjmp	.+244    	; 0x2ec8 <dir_next+0x1f0>
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    2dd4:	20 97       	sbiw	r28, 0x00	; 0
    2dd6:	09 f4       	brne	.+2      	; 0x2dda <dir_next+0x102>
    2dd8:	ae c0       	rjmp	.+348    	; 0x2f36 <dir_next+0x25e>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
    2dda:	d8 01       	movw	r26, r16
    2ddc:	1a 96       	adiw	r26, 0x0a	; 10
    2dde:	4d 91       	ld	r20, X+
    2de0:	5d 91       	ld	r21, X+
    2de2:	6d 91       	ld	r22, X+
    2de4:	7c 91       	ld	r23, X
    2de6:	1d 97       	sbiw	r26, 0x0d	; 13
    2de8:	cf 01       	movw	r24, r30
    2dea:	0e 94 4a 15 	call	0x2a94	; 0x2a94 <create_chain>
    2dee:	4b 01       	movw	r8, r22
    2df0:	5c 01       	movw	r10, r24
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    2df2:	61 15       	cp	r22, r1
    2df4:	71 05       	cpc	r23, r1
    2df6:	81 05       	cpc	r24, r1
    2df8:	91 05       	cpc	r25, r1
    2dfa:	09 f4       	brne	.+2      	; 0x2dfe <dir_next+0x126>
    2dfc:	9e c0       	rjmp	.+316    	; 0x2f3a <dir_next+0x262>
					if (clst == 1) return FR_INT_ERR;
    2dfe:	61 30       	cpi	r22, 0x01	; 1
    2e00:	71 05       	cpc	r23, r1
    2e02:	81 05       	cpc	r24, r1
    2e04:	91 05       	cpc	r25, r1
    2e06:	09 f4       	brne	.+2      	; 0x2e0a <dir_next+0x132>
    2e08:	9a c0       	rjmp	.+308    	; 0x2f3e <dir_next+0x266>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2e0a:	6f 3f       	cpi	r22, 0xFF	; 255
    2e0c:	ef ef       	ldi	r30, 0xFF	; 255
    2e0e:	7e 07       	cpc	r23, r30
    2e10:	ef ef       	ldi	r30, 0xFF	; 255
    2e12:	8e 07       	cpc	r24, r30
    2e14:	ef ef       	ldi	r30, 0xFF	; 255
    2e16:	9e 07       	cpc	r25, r30
    2e18:	09 f4       	brne	.+2      	; 0x2e1c <dir_next+0x144>
    2e1a:	93 c0       	rjmp	.+294    	; 0x2f42 <dir_next+0x26a>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    2e1c:	d8 01       	movw	r26, r16
    2e1e:	8d 91       	ld	r24, X+
    2e20:	9c 91       	ld	r25, X
    2e22:	40 e0       	ldi	r20, 0x00	; 0
    2e24:	50 e0       	ldi	r21, 0x00	; 0
    2e26:	ba 01       	movw	r22, r20
    2e28:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
    2e2c:	88 23       	and	r24, r24
    2e2e:	09 f0       	breq	.+2      	; 0x2e32 <dir_next+0x15a>
    2e30:	8a c0       	rjmp	.+276    	; 0x2f46 <dir_next+0x26e>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
    2e32:	f8 01       	movw	r30, r16
    2e34:	80 81       	ld	r24, Z
    2e36:	91 81       	ldd	r25, Z+1	; 0x01
    2e38:	c2 96       	adiw	r24, 0x32	; 50
    2e3a:	60 e0       	ldi	r22, 0x00	; 0
    2e3c:	70 e0       	ldi	r23, 0x00	; 0
    2e3e:	20 e0       	ldi	r18, 0x00	; 0
    2e40:	32 e0       	ldi	r19, 0x02	; 2
    2e42:	40 e0       	ldi	r20, 0x00	; 0
    2e44:	50 e0       	ldi	r21, 0x00	; 0
    2e46:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <mem_set>
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    2e4a:	d8 01       	movw	r26, r16
    2e4c:	cd 91       	ld	r28, X+
    2e4e:	dc 91       	ld	r29, X
    2e50:	ce 01       	movw	r24, r28
    2e52:	b5 01       	movw	r22, r10
    2e54:	a4 01       	movw	r20, r8
    2e56:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <clust2sect>
    2e5a:	dc 01       	movw	r26, r24
    2e5c:	cb 01       	movw	r24, r22
    2e5e:	8e a7       	lds	r24, 0x7e
    2e60:	9f a7       	lds	r25, 0x7f
    2e62:	a8 ab       	sts	0x58, r26
    2e64:	b9 ab       	sts	0x59, r27
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2e66:	c0 e0       	ldi	r28, 0x00	; 0
						dj->fs->wflag = 1;
    2e68:	d1 e0       	ldi	r29, 0x01	; 1
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2e6a:	1b c0       	rjmp	.+54     	; 0x2ea2 <dir_next+0x1ca>
						dj->fs->wflag = 1;
    2e6c:	d4 83       	std	Z+4, r29	; 0x04
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    2e6e:	f8 01       	movw	r30, r16
    2e70:	80 81       	ld	r24, Z
    2e72:	91 81       	ldd	r25, Z+1	; 0x01
    2e74:	40 e0       	ldi	r20, 0x00	; 0
    2e76:	50 e0       	ldi	r21, 0x00	; 0
    2e78:	ba 01       	movw	r22, r20
    2e7a:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
    2e7e:	88 23       	and	r24, r24
    2e80:	09 f0       	breq	.+2      	; 0x2e84 <dir_next+0x1ac>
    2e82:	63 c0       	rjmp	.+198    	; 0x2f4a <dir_next+0x272>
						dj->fs->winsect++;
    2e84:	d8 01       	movw	r26, r16
    2e86:	ed 91       	ld	r30, X+
    2e88:	fc 91       	ld	r31, X
    2e8a:	86 a5       	lds	r24, 0x66
    2e8c:	97 a5       	lds	r25, 0x67
    2e8e:	a0 a9       	sts	0x40, r26
    2e90:	b1 a9       	sts	0x41, r27
    2e92:	01 96       	adiw	r24, 0x01	; 1
    2e94:	a1 1d       	adc	r26, r1
    2e96:	b1 1d       	adc	r27, r1
    2e98:	86 a7       	lds	r24, 0x76
    2e9a:	97 a7       	lds	r25, 0x77
    2e9c:	a0 ab       	sts	0x50, r26
    2e9e:	b1 ab       	sts	0x51, r27
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2ea0:	cf 5f       	subi	r28, 0xFF	; 255
    2ea2:	d8 01       	movw	r26, r16
    2ea4:	ed 91       	ld	r30, X+
    2ea6:	fc 91       	ld	r31, X
    2ea8:	11 97       	sbiw	r26, 0x01	; 1
    2eaa:	82 81       	ldd	r24, Z+2	; 0x02
    2eac:	c8 17       	cp	r28, r24
    2eae:	f0 f2       	brcs	.-68     	; 0x2e6c <dir_next+0x194>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
    2eb0:	86 a5       	lds	r24, 0x66
    2eb2:	97 a5       	lds	r25, 0x67
    2eb4:	a0 a9       	sts	0x40, r26
    2eb6:	b1 a9       	sts	0x41, r27
    2eb8:	8c 1b       	sub	r24, r28
    2eba:	91 09       	sbc	r25, r1
    2ebc:	a1 09       	sbc	r26, r1
    2ebe:	b1 09       	sbc	r27, r1
    2ec0:	86 a7       	lds	r24, 0x76
    2ec2:	97 a7       	lds	r25, 0x77
    2ec4:	a0 ab       	sts	0x50, r26
    2ec6:	b1 ab       	sts	0x51, r27
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
    2ec8:	f8 01       	movw	r30, r16
    2eca:	82 86       	std	Z+10, r8	; 0x0a
    2ecc:	93 86       	std	Z+11, r9	; 0x0b
    2ece:	a4 86       	std	Z+12, r10	; 0x0c
    2ed0:	b5 86       	std	Z+13, r11	; 0x0d
				dj->sect = clust2sect(dj->fs, clst);
    2ed2:	80 81       	ld	r24, Z
    2ed4:	91 81       	ldd	r25, Z+1	; 0x01
    2ed6:	b5 01       	movw	r22, r10
    2ed8:	a4 01       	movw	r20, r8
    2eda:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <clust2sect>
    2ede:	dc 01       	movw	r26, r24
    2ee0:	cb 01       	movw	r24, r22
    2ee2:	f8 01       	movw	r30, r16
    2ee4:	86 87       	std	Z+14, r24	; 0x0e
    2ee6:	97 87       	std	Z+15, r25	; 0x0f
    2ee8:	a0 8b       	std	Z+16, r26	; 0x10
    2eea:	b1 8b       	std	Z+17, r27	; 0x11
			}
		}
	}

	dj->index = i;
    2eec:	d8 01       	movw	r26, r16
    2eee:	15 96       	adiw	r26, 0x05	; 5
    2ef0:	fc 92       	st	X, r15
    2ef2:	ee 92       	st	-X, r14
    2ef4:	14 97       	sbiw	r26, 0x04	; 4
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    2ef6:	8d 91       	ld	r24, X+
    2ef8:	9c 91       	ld	r25, X
    2efa:	11 97       	sbiw	r26, 0x01	; 1
    2efc:	c2 96       	adiw	r24, 0x32	; 50
    2efe:	cc 0c       	add	r12, r12
    2f00:	dd 1c       	adc	r13, r13
    2f02:	cc 0c       	add	r12, r12
    2f04:	dd 1c       	adc	r13, r13
    2f06:	cc 0c       	add	r12, r12
    2f08:	dd 1c       	adc	r13, r13
    2f0a:	cc 0c       	add	r12, r12
    2f0c:	dd 1c       	adc	r13, r13
    2f0e:	cc 0c       	add	r12, r12
    2f10:	dd 1c       	adc	r13, r13
    2f12:	8c 0d       	add	r24, r12
    2f14:	9d 1d       	adc	r25, r13
    2f16:	53 96       	adiw	r26, 0x13	; 19
    2f18:	9c 93       	st	X, r25
    2f1a:	8e 93       	st	-X, r24
    2f1c:	52 97       	sbiw	r26, 0x12	; 18

	return FR_OK;
    2f1e:	80 e0       	ldi	r24, 0x00	; 0
    2f20:	15 c0       	rjmp	.+42     	; 0x2f4c <dir_next+0x274>


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
    2f22:	84 e0       	ldi	r24, 0x04	; 4
    2f24:	13 c0       	rjmp	.+38     	; 0x2f4c <dir_next+0x274>
    2f26:	84 e0       	ldi	r24, 0x04	; 4
    2f28:	11 c0       	rjmp	.+34     	; 0x2f4c <dir_next+0x274>
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
    2f2a:	84 e0       	ldi	r24, 0x04	; 4
    2f2c:	0f c0       	rjmp	.+30     	; 0x2f4c <dir_next+0x274>
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
    2f2e:	82 e0       	ldi	r24, 0x02	; 2
    2f30:	0d c0       	rjmp	.+26     	; 0x2f4c <dir_next+0x274>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2f32:	81 e0       	ldi	r24, 0x01	; 1
    2f34:	0b c0       	rjmp	.+22     	; 0x2f4c <dir_next+0x274>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    2f36:	84 e0       	ldi	r24, 0x04	; 4
    2f38:	09 c0       	rjmp	.+18     	; 0x2f4c <dir_next+0x274>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    2f3a:	87 e0       	ldi	r24, 0x07	; 7
    2f3c:	07 c0       	rjmp	.+14     	; 0x2f4c <dir_next+0x274>
					if (clst == 1) return FR_INT_ERR;
    2f3e:	82 e0       	ldi	r24, 0x02	; 2
    2f40:	05 c0       	rjmp	.+10     	; 0x2f4c <dir_next+0x274>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2f42:	81 e0       	ldi	r24, 0x01	; 1
    2f44:	03 c0       	rjmp	.+6      	; 0x2f4c <dir_next+0x274>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    2f46:	81 e0       	ldi	r24, 0x01	; 1
    2f48:	01 c0       	rjmp	.+2      	; 0x2f4c <dir_next+0x274>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    2f4a:	81 e0       	ldi	r24, 0x01	; 1

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
}
    2f4c:	df 91       	pop	r29
    2f4e:	cf 91       	pop	r28
    2f50:	1f 91       	pop	r17
    2f52:	0f 91       	pop	r16
    2f54:	ff 90       	pop	r15
    2f56:	ef 90       	pop	r14
    2f58:	df 90       	pop	r13
    2f5a:	cf 90       	pop	r12
    2f5c:	bf 90       	pop	r11
    2f5e:	af 90       	pop	r10
    2f60:	9f 90       	pop	r9
    2f62:	8f 90       	pop	r8
    2f64:	08 95       	ret

00002f66 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
    2f66:	2f 92       	push	r2
    2f68:	3f 92       	push	r3
    2f6a:	4f 92       	push	r4
    2f6c:	5f 92       	push	r5
    2f6e:	6f 92       	push	r6
    2f70:	7f 92       	push	r7
    2f72:	8f 92       	push	r8
    2f74:	9f 92       	push	r9
    2f76:	af 92       	push	r10
    2f78:	bf 92       	push	r11
    2f7a:	cf 92       	push	r12
    2f7c:	df 92       	push	r13
    2f7e:	ef 92       	push	r14
    2f80:	ff 92       	push	r15
    2f82:	0f 93       	push	r16
    2f84:	1f 93       	push	r17
    2f86:	cf 93       	push	r28
    2f88:	df 93       	push	r29
    2f8a:	cd b7       	in	r28, 0x3d	; 61
    2f8c:	de b7       	in	r29, 0x3e	; 62
    2f8e:	2b 97       	sbiw	r28, 0x0b	; 11
    2f90:	0f b6       	in	r0, 0x3f	; 63
    2f92:	f8 94       	cli
    2f94:	de bf       	out	0x3e, r29	; 62
    2f96:	0f be       	out	0x3f, r0	; 63
    2f98:	cd bf       	out	0x3d, r28	; 61
    2f9a:	8c 01       	movw	r16, r24
    2f9c:	2b 01       	movw	r4, r22
	FRESULT res;
	BYTE *dir, ns;


#if _FS_RPATH
	if (*path == '/' || *path == '\\') { /* There is a heading separator */
    2f9e:	db 01       	movw	r26, r22
    2fa0:	8c 91       	ld	r24, X
    2fa2:	8f 32       	cpi	r24, 0x2F	; 47
    2fa4:	11 f0       	breq	.+4      	; 0x2faa <follow_path+0x44>
    2fa6:	8c 35       	cpi	r24, 0x5C	; 92
    2fa8:	49 f4       	brne	.+18     	; 0x2fbc <follow_path+0x56>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
    2faa:	08 94       	sec
    2fac:	41 1c       	adc	r4, r1
    2fae:	51 1c       	adc	r5, r1
    2fb0:	f8 01       	movw	r30, r16
    2fb2:	16 82       	std	Z+6, r1	; 0x06
    2fb4:	17 82       	std	Z+7, r1	; 0x07
    2fb6:	10 86       	std	Z+8, r1	; 0x08
    2fb8:	11 86       	std	Z+9, r1	; 0x09
    2fba:	0c c0       	rjmp	.+24     	; 0x2fd4 <follow_path+0x6e>
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
    2fbc:	d8 01       	movw	r26, r16
    2fbe:	ed 91       	ld	r30, X+
    2fc0:	fc 91       	ld	r31, X
    2fc2:	86 89       	ldd	r24, Z+22	; 0x16
    2fc4:	97 89       	ldd	r25, Z+23	; 0x17
    2fc6:	a0 8d       	ldd	r26, Z+24	; 0x18
    2fc8:	b1 8d       	ldd	r27, Z+25	; 0x19
    2fca:	f8 01       	movw	r30, r16
    2fcc:	86 83       	std	Z+6, r24	; 0x06
    2fce:	97 83       	std	Z+7, r25	; 0x07
    2fd0:	a0 87       	std	Z+8, r26	; 0x08
    2fd2:	b1 87       	std	Z+9, r27	; 0x09
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    2fd4:	d2 01       	movw	r26, r4
    2fd6:	8c 91       	ld	r24, X
    2fd8:	80 32       	cpi	r24, 0x20	; 32
    2fda:	48 f4       	brcc	.+18     	; 0x2fee <follow_path+0x88>
		res = dir_sdi(dj, 0);
    2fdc:	c8 01       	movw	r24, r16
    2fde:	60 e0       	ldi	r22, 0x00	; 0
    2fe0:	70 e0       	ldi	r23, 0x00	; 0
    2fe2:	0e 94 58 13 	call	0x26b0	; 0x26b0 <dir_sdi>
		dj->dir = 0;
    2fe6:	f8 01       	movw	r30, r16
    2fe8:	13 8a       	std	Z+19, r1	; 0x13
    2fea:	12 8a       	std	Z+18, r1	; 0x12
    2fec:	a5 c1       	rjmp	.+842    	; 0x3338 <follow_path+0x3d2>
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    2fee:	f8 e0       	ldi	r31, 0x08	; 8
    2ff0:	fa 83       	std	Y+2, r31	; 0x02
    2ff2:	1b 82       	std	Y+3, r1	; 0x03
    2ff4:	1c 82       	std	Y+4, r1	; 0x04
    2ff6:	1d 82       	std	Y+5, r1	; 0x05
    2ff8:	2b e0       	ldi	r18, 0x0B	; 11
    2ffa:	2e 83       	std	Y+6, r18	; 0x06
    2ffc:	1f 82       	std	Y+7, r1	; 0x07
    2ffe:	18 86       	std	Y+8, r1	; 0x08
    3000:	19 86       	std	Y+9, r1	; 0x09
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
		res = dir_sdi(dj, 0);
		dj->dir = 0;
    3002:	f2 01       	movw	r30, r4
    3004:	9f 01       	movw	r18, r30
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    3006:	81 91       	ld	r24, Z+
    3008:	8f 32       	cpi	r24, 0x2F	; 47
    300a:	e1 f3       	breq	.-8      	; 0x3004 <follow_path+0x9e>
    300c:	8c 35       	cpi	r24, 0x5C	; 92
    300e:	d1 f3       	breq	.-12     	; 0x3004 <follow_path+0x9e>
    3010:	3b 87       	std	Y+11, r19	; 0x0b
    3012:	2a 87       	std	Y+10, r18	; 0x0a
	sfn = dj->fn;
    3014:	d8 01       	movw	r26, r16
    3016:	54 96       	adiw	r26, 0x14	; 20
    3018:	2d 90       	ld	r2, X+
    301a:	3c 90       	ld	r3, X
    301c:	55 97       	sbiw	r26, 0x15	; 21
	mem_set(sfn, ' ', 11);
    301e:	c1 01       	movw	r24, r2
    3020:	60 e2       	ldi	r22, 0x20	; 32
    3022:	70 e0       	ldi	r23, 0x00	; 0
    3024:	2b e0       	ldi	r18, 0x0B	; 11
    3026:	30 e0       	ldi	r19, 0x00	; 0
    3028:	40 e0       	ldi	r20, 0x00	; 0
    302a:	50 e0       	ldi	r21, 0x00	; 0
    302c:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <mem_set>
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
    3030:	ea 85       	ldd	r30, Y+10	; 0x0a
    3032:	fb 85       	ldd	r31, Y+11	; 0x0b
    3034:	80 81       	ld	r24, Z
    3036:	8e 32       	cpi	r24, 0x2E	; 46
    3038:	89 f5       	brne	.+98     	; 0x309c <follow_path+0x136>
		for (;;) {
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
    303a:	ee e2       	ldi	r30, 0x2E	; 46
    303c:	d1 01       	movw	r26, r2
    303e:	ec 93       	st	X, r30
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    3040:	aa 85       	ldd	r26, Y+10	; 0x0a
    3042:	bb 85       	ldd	r27, Y+11	; 0x0b
    3044:	11 96       	adiw	r26, 0x01	; 1
    3046:	2c 91       	ld	r18, X
    3048:	11 97       	sbiw	r26, 0x01	; 1
			if (c != '.' || si >= 3) break;
    304a:	2e 32       	cpi	r18, 0x2E	; 46
    304c:	61 f4       	brne	.+24     	; 0x3066 <follow_path+0x100>
			sfn[i++] = c;
    304e:	f1 01       	movw	r30, r2
    3050:	21 83       	std	Z+1, r18	; 0x01
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    3052:	12 96       	adiw	r26, 0x02	; 2
    3054:	2c 91       	ld	r18, X
    3056:	12 97       	sbiw	r26, 0x02	; 2
			if (c != '.' || si >= 3) break;
    3058:	2e 32       	cpi	r18, 0x2E	; 46
    305a:	71 f0       	breq	.+28     	; 0x3078 <follow_path+0x112>
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    305c:	83 e0       	ldi	r24, 0x03	; 3
    305e:	90 e0       	ldi	r25, 0x00	; 0
    3060:	a0 e0       	ldi	r26, 0x00	; 0
    3062:	b0 e0       	ldi	r27, 0x00	; 0
    3064:	04 c0       	rjmp	.+8      	; 0x306e <follow_path+0x108>
    3066:	82 e0       	ldi	r24, 0x02	; 2
    3068:	90 e0       	ldi	r25, 0x00	; 0
    306a:	a0 e0       	ldi	r26, 0x00	; 0
    306c:	b0 e0       	ldi	r27, 0x00	; 0
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    306e:	2f 32       	cpi	r18, 0x2F	; 47
    3070:	59 f0       	breq	.+22     	; 0x3088 <follow_path+0x122>
    3072:	2c 35       	cpi	r18, 0x5C	; 92
    3074:	49 f0       	breq	.+18     	; 0x3088 <follow_path+0x122>
    3076:	04 c0       	rjmp	.+8      	; 0x3080 <follow_path+0x11a>
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    3078:	83 e0       	ldi	r24, 0x03	; 3
    307a:	90 e0       	ldi	r25, 0x00	; 0
    307c:	a0 e0       	ldi	r26, 0x00	; 0
    307e:	b0 e0       	ldi	r27, 0x00	; 0
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    3080:	21 32       	cpi	r18, 0x21	; 33
    3082:	08 f0       	brcs	.+2      	; 0x3086 <follow_path+0x120>
    3084:	48 c1       	rjmp	.+656    	; 0x3316 <follow_path+0x3b0>
    3086:	71 c1       	rjmp	.+738    	; 0x336a <follow_path+0x404>
		*path = &p[si];									/* Return pointer to the next segment */
    3088:	4a 84       	ldd	r4, Y+10	; 0x0a
    308a:	5b 84       	ldd	r5, Y+11	; 0x0b
    308c:	48 0e       	add	r4, r24
    308e:	59 1e       	adc	r5, r25
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
    3090:	80 e2       	ldi	r24, 0x20	; 32
    3092:	d1 01       	movw	r26, r2
    3094:	1b 96       	adiw	r26, 0x0b	; 11
    3096:	8c 93       	st	X, r24
    3098:	1b 97       	sbiw	r26, 0x0b	; 11
    309a:	74 c1       	rjmp	.+744    	; 0x3384 <follow_path+0x41e>
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
    309c:	cc 24       	eor	r12, r12
    309e:	dd 24       	eor	r13, r13
    30a0:	76 01       	movw	r14, r12
    30a2:	40 e0       	ldi	r20, 0x00	; 0
    30a4:	50 e0       	ldi	r21, 0x00	; 0
    30a6:	ba 01       	movw	r22, r20
    30a8:	88 24       	eor	r8, r8
    30aa:	99 24       	eor	r9, r9
    30ac:	54 01       	movw	r10, r8
    30ae:	68 94       	set
    30b0:	83 f8       	bld	r8, 3
    30b2:	19 82       	std	Y+1, r1	; 0x01
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    30b4:	ea 85       	ldd	r30, Y+10	; 0x0a
    30b6:	fb 85       	ldd	r31, Y+11	; 0x0b
    30b8:	e4 0f       	add	r30, r20
    30ba:	f5 1f       	adc	r31, r21
    30bc:	20 81       	ld	r18, Z
    30be:	2a 01       	movw	r4, r20
    30c0:	3b 01       	movw	r6, r22
    30c2:	08 94       	sec
    30c4:	41 1c       	adc	r4, r1
    30c6:	51 1c       	adc	r5, r1
    30c8:	61 1c       	adc	r6, r1
    30ca:	71 1c       	adc	r7, r1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    30cc:	21 32       	cpi	r18, 0x21	; 33
    30ce:	08 f4       	brcc	.+2      	; 0x30d2 <follow_path+0x16c>
    30d0:	95 c0       	rjmp	.+298    	; 0x31fc <follow_path+0x296>
    30d2:	2f 32       	cpi	r18, 0x2F	; 47
    30d4:	09 f4       	brne	.+2      	; 0x30d8 <follow_path+0x172>
    30d6:	4f c1       	rjmp	.+670    	; 0x3376 <follow_path+0x410>
    30d8:	2c 35       	cpi	r18, 0x5C	; 92
    30da:	09 f4       	brne	.+2      	; 0x30de <follow_path+0x178>
    30dc:	4c c1       	rjmp	.+664    	; 0x3376 <follow_path+0x410>
		if (c == '.' || i >= ni) {
    30de:	2e 32       	cpi	r18, 0x2E	; 46
    30e0:	29 f0       	breq	.+10     	; 0x30ec <follow_path+0x186>
    30e2:	c8 14       	cp	r12, r8
    30e4:	d9 04       	cpc	r13, r9
    30e6:	ea 04       	cpc	r14, r10
    30e8:	fb 04       	cpc	r15, r11
    30ea:	c8 f0       	brcs	.+50     	; 0x311e <follow_path+0x1b8>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    30ec:	f8 e0       	ldi	r31, 0x08	; 8
    30ee:	8f 16       	cp	r8, r31
    30f0:	91 04       	cpc	r9, r1
    30f2:	a1 04       	cpc	r10, r1
    30f4:	b1 04       	cpc	r11, r1
    30f6:	09 f0       	breq	.+2      	; 0x30fa <follow_path+0x194>
    30f8:	10 c1       	rjmp	.+544    	; 0x331a <follow_path+0x3b4>
    30fa:	2e 32       	cpi	r18, 0x2E	; 46
    30fc:	09 f0       	breq	.+2      	; 0x3100 <follow_path+0x19a>
    30fe:	0f c1       	rjmp	.+542    	; 0x331e <follow_path+0x3b8>
			i = 8; ni = 11;
			b <<= 2; continue;
    3100:	29 81       	ldd	r18, Y+1	; 0x01
    3102:	22 0f       	add	r18, r18
    3104:	22 0f       	add	r18, r18
    3106:	29 83       	std	Y+1, r18	; 0x01
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    3108:	b3 01       	movw	r22, r6
    310a:	a2 01       	movw	r20, r4
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    310c:	ca 80       	ldd	r12, Y+2	; 0x02
    310e:	db 80       	ldd	r13, Y+3	; 0x03
    3110:	ec 80       	ldd	r14, Y+4	; 0x04
    3112:	fd 80       	ldd	r15, Y+5	; 0x05
    3114:	8e 80       	ldd	r8, Y+6	; 0x06
    3116:	9f 80       	ldd	r9, Y+7	; 0x07
    3118:	a8 84       	ldd	r10, Y+8	; 0x08
    311a:	b9 84       	ldd	r11, Y+9	; 0x09
    311c:	cb cf       	rjmp	.-106    	; 0x30b4 <follow_path+0x14e>
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended char? */
    311e:	22 23       	and	r18, r18
    3120:	1c f4       	brge	.+6      	; 0x3128 <follow_path+0x1c2>
			b |= 3;						/* Eliminate NT flag */
    3122:	89 81       	ldd	r24, Y+1	; 0x01
    3124:	83 60       	ori	r24, 0x03	; 3
    3126:	89 83       	std	Y+1, r24	; 0x01
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    3128:	82 2f       	mov	r24, r18
    312a:	81 58       	subi	r24, 0x81	; 129
    312c:	8f 31       	cpi	r24, 0x1F	; 31
    312e:	18 f0       	brcs	.+6      	; 0x3136 <follow_path+0x1d0>
    3130:	8f 55       	subi	r24, 0x5F	; 95
    3132:	8d 31       	cpi	r24, 0x1D	; 29
    3134:	90 f5       	brcc	.+100    	; 0x319a <follow_path+0x234>
			d = (BYTE)p[si++];			/* Get 2nd byte */
    3136:	ea 85       	ldd	r30, Y+10	; 0x0a
    3138:	fb 85       	ldd	r31, Y+11	; 0x0b
    313a:	e4 0d       	add	r30, r4
    313c:	f5 1d       	adc	r31, r5
    313e:	30 81       	ld	r19, Z
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    3140:	83 2f       	mov	r24, r19
    3142:	80 54       	subi	r24, 0x40	; 64
    3144:	8f 33       	cpi	r24, 0x3F	; 63
    3146:	20 f0       	brcs	.+8      	; 0x3150 <follow_path+0x1ea>
    3148:	80 54       	subi	r24, 0x40	; 64
    314a:	8d 37       	cpi	r24, 0x7D	; 125
    314c:	08 f0       	brcs	.+2      	; 0x3150 <follow_path+0x1ea>
    314e:	e9 c0       	rjmp	.+466    	; 0x3322 <follow_path+0x3bc>
    3150:	d5 01       	movw	r26, r10
    3152:	c4 01       	movw	r24, r8
    3154:	01 97       	sbiw	r24, 0x01	; 1
    3156:	a1 09       	sbc	r26, r1
    3158:	b1 09       	sbc	r27, r1
    315a:	c8 16       	cp	r12, r24
    315c:	d9 06       	cpc	r13, r25
    315e:	ea 06       	cpc	r14, r26
    3160:	fb 06       	cpc	r15, r27
    3162:	08 f0       	brcs	.+2      	; 0x3166 <follow_path+0x200>
    3164:	e0 c0       	rjmp	.+448    	; 0x3326 <follow_path+0x3c0>
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
    3166:	4e 5f       	subi	r20, 0xFE	; 254
    3168:	5f 4f       	sbci	r21, 0xFF	; 255
    316a:	6f 4f       	sbci	r22, 0xFF	; 255
    316c:	7f 4f       	sbci	r23, 0xFF	; 255
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
    316e:	f1 01       	movw	r30, r2
    3170:	ec 0d       	add	r30, r12
    3172:	fd 1d       	adc	r31, r13
    3174:	20 83       	st	Z, r18
    3176:	d7 01       	movw	r26, r14
    3178:	c6 01       	movw	r24, r12
    317a:	01 96       	adiw	r24, 0x01	; 1
    317c:	a1 1d       	adc	r26, r1
    317e:	b1 1d       	adc	r27, r1
			sfn[i++] = d;
    3180:	82 0d       	add	r24, r2
    3182:	93 1d       	adc	r25, r3
    3184:	dc 01       	movw	r26, r24
    3186:	3c 93       	st	X, r19
    3188:	82 e0       	ldi	r24, 0x02	; 2
    318a:	90 e0       	ldi	r25, 0x00	; 0
    318c:	a0 e0       	ldi	r26, 0x00	; 0
    318e:	b0 e0       	ldi	r27, 0x00	; 0
    3190:	c8 0e       	add	r12, r24
    3192:	d9 1e       	adc	r13, r25
    3194:	ea 1e       	adc	r14, r26
    3196:	fb 1e       	adc	r15, r27
    3198:	8d cf       	rjmp	.-230    	; 0x30b4 <follow_path+0x14e>
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    319a:	42 2f       	mov	r20, r18
    319c:	50 e0       	ldi	r21, 0x00	; 0
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    319e:	42 32       	cpi	r20, 0x22	; 34
    31a0:	51 05       	cpc	r21, r1
    31a2:	09 f4       	brne	.+2      	; 0x31a6 <follow_path+0x240>
    31a4:	c2 c0       	rjmp	.+388    	; 0x332a <follow_path+0x3c4>
    31a6:	e0 e1       	ldi	r30, 0x10	; 16
    31a8:	f4 e0       	ldi	r31, 0x04	; 4
    31aa:	6a 85       	ldd	r22, Y+10	; 0x0a
    31ac:	7b 85       	ldd	r23, Y+11	; 0x0b
    31ae:	81 91       	ld	r24, Z+
    31b0:	88 23       	and	r24, r24
    31b2:	31 f0       	breq	.+12     	; 0x31c0 <follow_path+0x25a>
    31b4:	90 e0       	ldi	r25, 0x00	; 0
    31b6:	48 17       	cp	r20, r24
    31b8:	59 07       	cpc	r21, r25
    31ba:	c9 f7       	brne	.-14     	; 0x31ae <follow_path+0x248>
    31bc:	86 e0       	ldi	r24, 0x06	; 6
    31be:	bc c0       	rjmp	.+376    	; 0x3338 <follow_path+0x3d2>
    31c0:	7b 87       	std	Y+11, r23	; 0x0b
    31c2:	6a 87       	std	Y+10, r22	; 0x0a
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
    31c4:	82 2f       	mov	r24, r18
    31c6:	81 54       	subi	r24, 0x41	; 65
    31c8:	8a 31       	cpi	r24, 0x1A	; 26
    31ca:	20 f4       	brcc	.+8      	; 0x31d4 <follow_path+0x26e>
				b |= 2;
    31cc:	99 81       	ldd	r25, Y+1	; 0x01
    31ce:	92 60       	ori	r25, 0x02	; 2
    31d0:	99 83       	std	Y+1, r25	; 0x01
    31d2:	08 c0       	rjmp	.+16     	; 0x31e4 <follow_path+0x27e>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
    31d4:	82 2f       	mov	r24, r18
    31d6:	81 56       	subi	r24, 0x61	; 97
    31d8:	8a 31       	cpi	r24, 0x1A	; 26
    31da:	20 f4       	brcc	.+8      	; 0x31e4 <follow_path+0x27e>
					b |= 1; c -= 0x20;
    31dc:	a9 81       	ldd	r26, Y+1	; 0x01
    31de:	a1 60       	ori	r26, 0x01	; 1
    31e0:	a9 83       	std	Y+1, r26	; 0x01
    31e2:	20 52       	subi	r18, 0x20	; 32
				}
			}
			sfn[i++] = c;
    31e4:	f1 01       	movw	r30, r2
    31e6:	ec 0d       	add	r30, r12
    31e8:	fd 1d       	adc	r31, r13
    31ea:	20 83       	st	Z, r18
    31ec:	08 94       	sec
    31ee:	c1 1c       	adc	r12, r1
    31f0:	d1 1c       	adc	r13, r1
    31f2:	e1 1c       	adc	r14, r1
    31f4:	f1 1c       	adc	r15, r1
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    31f6:	b3 01       	movw	r22, r6
    31f8:	a2 01       	movw	r20, r4
    31fa:	5c cf       	rjmp	.-328    	; 0x30b4 <follow_path+0x14e>
    31fc:	ea 85       	ldd	r30, Y+10	; 0x0a
    31fe:	fb 85       	ldd	r31, Y+11	; 0x0b
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    3200:	4e 0e       	add	r4, r30
    3202:	5f 1e       	adc	r5, r31
    3204:	89 81       	ldd	r24, Y+1	; 0x01
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    3206:	44 e0       	ldi	r20, 0x04	; 4

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    3208:	c1 14       	cp	r12, r1
    320a:	d1 04       	cpc	r13, r1
    320c:	e1 04       	cpc	r14, r1
    320e:	f1 04       	cpc	r15, r1
    3210:	09 f4       	brne	.+2      	; 0x3214 <follow_path+0x2ae>
    3212:	8d c0       	rjmp	.+282    	; 0x332e <follow_path+0x3c8>
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    3214:	d1 01       	movw	r26, r2
    3216:	9c 91       	ld	r25, X
    3218:	95 3e       	cpi	r25, 0xE5	; 229
    321a:	11 f4       	brne	.+4      	; 0x3220 <follow_path+0x2ba>
    321c:	e5 e0       	ldi	r30, 0x05	; 5
    321e:	ec 93       	st	X, r30

	if (ni == 8) b <<= 2;
    3220:	f8 e0       	ldi	r31, 0x08	; 8
    3222:	8f 16       	cp	r8, r31
    3224:	91 04       	cpc	r9, r1
    3226:	a1 04       	cpc	r10, r1
    3228:	b1 04       	cpc	r11, r1
    322a:	19 f4       	brne	.+6      	; 0x3232 <follow_path+0x2cc>
    322c:	88 0f       	add	r24, r24
    322e:	88 0f       	add	r24, r24
    3230:	89 83       	std	Y+1, r24	; 0x01
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    3232:	29 81       	ldd	r18, Y+1	; 0x01
    3234:	82 2f       	mov	r24, r18
    3236:	90 e0       	ldi	r25, 0x00	; 0
    3238:	9c 01       	movw	r18, r24
    323a:	23 70       	andi	r18, 0x03	; 3
    323c:	30 70       	andi	r19, 0x00	; 0
    323e:	21 30       	cpi	r18, 0x01	; 1
    3240:	31 05       	cpc	r19, r1
    3242:	09 f4       	brne	.+2      	; 0x3246 <follow_path+0x2e0>
    3244:	40 61       	ori	r20, 0x10	; 16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    3246:	8c 70       	andi	r24, 0x0C	; 12
    3248:	90 70       	andi	r25, 0x00	; 0
    324a:	84 30       	cpi	r24, 0x04	; 4
    324c:	91 05       	cpc	r25, r1
    324e:	09 f4       	brne	.+2      	; 0x3252 <follow_path+0x2ec>
    3250:	48 60       	ori	r20, 0x08	; 8

	sfn[NS] = c;		/* Store NT flag, File name is created */
    3252:	d1 01       	movw	r26, r2
    3254:	1b 96       	adiw	r26, 0x0b	; 11
    3256:	4c 93       	st	X, r20
    3258:	1b 97       	sbiw	r26, 0x0b	; 11
    325a:	94 c0       	rjmp	.+296    	; 0x3384 <follow_path+0x41e>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
    325c:	f8 01       	movw	r30, r16
    325e:	46 85       	ldd	r20, Z+14	; 0x0e
    3260:	57 85       	ldd	r21, Z+15	; 0x0f
    3262:	60 89       	ldd	r22, Z+16	; 0x10
    3264:	71 89       	ldd	r23, Z+17	; 0x11
    3266:	80 81       	ld	r24, Z
    3268:	91 81       	ldd	r25, Z+1	; 0x01
    326a:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
		if (res != FR_OK) break;
    326e:	88 23       	and	r24, r24
    3270:	31 f5       	brne	.+76     	; 0x32be <follow_path+0x358>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    3272:	d8 01       	movw	r26, r16
    3274:	52 96       	adiw	r26, 0x12	; 18
    3276:	6d 91       	ld	r22, X+
    3278:	7c 91       	ld	r23, X
    327a:	53 97       	sbiw	r26, 0x13	; 19
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    327c:	fb 01       	movw	r30, r22
    327e:	90 81       	ld	r25, Z
    3280:	99 23       	and	r25, r25
    3282:	09 f4       	brne	.+2      	; 0x3286 <follow_path+0x320>
    3284:	90 c0       	rjmp	.+288    	; 0x33a6 <follow_path+0x440>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    3286:	93 85       	ldd	r25, Z+11	; 0x0b
    3288:	93 fd       	sbrc	r25, 3
    328a:	12 c0       	rjmp	.+36     	; 0x32b0 <follow_path+0x34a>
    328c:	54 96       	adiw	r26, 0x14	; 20
    328e:	4d 91       	ld	r20, X+
    3290:	5c 91       	ld	r21, X
    3292:	55 97       	sbiw	r26, 0x15	; 21
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
    3294:	9b 01       	movw	r18, r22
    3296:	25 5f       	subi	r18, 0xF5	; 245
    3298:	3f 4f       	sbci	r19, 0xFF	; 255
}

/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    329a:	da 01       	movw	r26, r20
    329c:	6b 01       	movw	r12, r22
    329e:	04 c0       	rjmp	.+8      	; 0x32a8 <follow_path+0x342>
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    32a0:	e2 17       	cp	r30, r18
    32a2:	f3 07       	cpc	r31, r19
    32a4:	09 f4       	brne	.+2      	; 0x32a8 <follow_path+0x342>
    32a6:	77 c0       	rjmp	.+238    	; 0x3396 <follow_path+0x430>
    32a8:	61 91       	ld	r22, Z+
    32aa:	9d 91       	ld	r25, X+
    32ac:	69 17       	cp	r22, r25
    32ae:	c1 f3       	breq	.-16     	; 0x32a0 <follow_path+0x33a>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
    32b0:	c8 01       	movw	r24, r16
    32b2:	60 e0       	ldi	r22, 0x00	; 0
    32b4:	70 e0       	ldi	r23, 0x00	; 0
    32b6:	0e 94 6c 16 	call	0x2cd8	; 0x2cd8 <dir_next>
	} while (res == FR_OK);
    32ba:	88 23       	and	r24, r24
    32bc:	79 f2       	breq	.-98     	; 0x325c <follow_path+0x2f6>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    32be:	d8 01       	movw	r26, r16
    32c0:	54 96       	adiw	r26, 0x14	; 20
    32c2:	ed 91       	ld	r30, X+
    32c4:	fc 91       	ld	r31, X
    32c6:	55 97       	sbiw	r26, 0x15	; 21
    32c8:	93 85       	ldd	r25, Z+11	; 0x0b
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
    32ca:	84 30       	cpi	r24, 0x04	; 4
    32cc:	a9 f5       	brne	.+106    	; 0x3338 <follow_path+0x3d2>
				/* Object not found */
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
    32ce:	95 ff       	sbrs	r25, 5
    32d0:	0b c0       	rjmp	.+22     	; 0x32e8 <follow_path+0x382>
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
    32d2:	f8 01       	movw	r30, r16
    32d4:	16 82       	std	Z+6, r1	; 0x06
    32d6:	17 82       	std	Z+7, r1	; 0x07
    32d8:	10 86       	std	Z+8, r1	; 0x08
    32da:	11 86       	std	Z+9, r1	; 0x09
    32dc:	13 8a       	std	Z+19, r1	; 0x13
    32de:	12 8a       	std	Z+18, r1	; 0x12
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
    32e0:	92 ff       	sbrs	r25, 2
    32e2:	8f ce       	rjmp	.-738    	; 0x3002 <follow_path+0x9c>
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
				/* Object not found */
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
    32e4:	80 e0       	ldi	r24, 0x00	; 0
    32e6:	28 c0       	rjmp	.+80     	; 0x3338 <follow_path+0x3d2>
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    32e8:	92 ff       	sbrs	r25, 2
    32ea:	23 c0       	rjmp	.+70     	; 0x3332 <follow_path+0x3cc>
		dj->dir = 0;
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
    32ec:	84 e0       	ldi	r24, 0x04	; 4
    32ee:	24 c0       	rjmp	.+72     	; 0x3338 <follow_path+0x3d2>
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    32f0:	db 01       	movw	r26, r22
    32f2:	1b 96       	adiw	r26, 0x0b	; 11
    32f4:	8c 91       	ld	r24, X
    32f6:	1b 97       	sbiw	r26, 0x0b	; 11
    32f8:	84 ff       	sbrs	r24, 4
    32fa:	1d c0       	rjmp	.+58     	; 0x3336 <follow_path+0x3d0>
				res = FR_NO_PATH; break;
			}
			dj->sclust = ld_clust(dj->fs, dir);
    32fc:	f8 01       	movw	r30, r16
    32fe:	80 81       	ld	r24, Z
    3300:	91 81       	ldd	r25, Z+1	; 0x01
    3302:	0e 94 07 0b 	call	0x160e	; 0x160e <ld_clust>
    3306:	dc 01       	movw	r26, r24
    3308:	cb 01       	movw	r24, r22
    330a:	f8 01       	movw	r30, r16
    330c:	86 83       	std	Z+6, r24	; 0x06
    330e:	97 83       	std	Z+7, r25	; 0x07
    3310:	a0 87       	std	Z+8, r26	; 0x08
    3312:	b1 87       	std	Z+9, r27	; 0x09
    3314:	76 ce       	rjmp	.-788    	; 0x3002 <follow_path+0x9c>
		for (;;) {
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    3316:	86 e0       	ldi	r24, 0x06	; 6
    3318:	0f c0       	rjmp	.+30     	; 0x3338 <follow_path+0x3d2>
#endif
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    331a:	86 e0       	ldi	r24, 0x06	; 6
    331c:	0d c0       	rjmp	.+26     	; 0x3338 <follow_path+0x3d2>
    331e:	86 e0       	ldi	r24, 0x06	; 6
    3320:	0b c0       	rjmp	.+22     	; 0x3338 <follow_path+0x3d2>
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    3322:	86 e0       	ldi	r24, 0x06	; 6
    3324:	09 c0       	rjmp	.+18     	; 0x3338 <follow_path+0x3d2>
    3326:	86 e0       	ldi	r24, 0x06	; 6
    3328:	07 c0       	rjmp	.+14     	; 0x3338 <follow_path+0x3d2>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    332a:	86 e0       	ldi	r24, 0x06	; 6
    332c:	05 c0       	rjmp	.+10     	; 0x3338 <follow_path+0x3d2>
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    332e:	86 e0       	ldi	r24, 0x06	; 6
    3330:	03 c0       	rjmp	.+6      	; 0x3338 <follow_path+0x3d2>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    3332:	85 e0       	ldi	r24, 0x05	; 5
    3334:	01 c0       	rjmp	.+2      	; 0x3338 <follow_path+0x3d2>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
    3336:	85 e0       	ldi	r24, 0x05	; 5
			dj->sclust = ld_clust(dj->fs, dir);
		}
	}

	return res;
}
    3338:	2b 96       	adiw	r28, 0x0b	; 11
    333a:	0f b6       	in	r0, 0x3f	; 63
    333c:	f8 94       	cli
    333e:	de bf       	out	0x3e, r29	; 62
    3340:	0f be       	out	0x3f, r0	; 63
    3342:	cd bf       	out	0x3d, r28	; 61
    3344:	df 91       	pop	r29
    3346:	cf 91       	pop	r28
    3348:	1f 91       	pop	r17
    334a:	0f 91       	pop	r16
    334c:	ff 90       	pop	r15
    334e:	ef 90       	pop	r14
    3350:	df 90       	pop	r13
    3352:	cf 90       	pop	r12
    3354:	bf 90       	pop	r11
    3356:	af 90       	pop	r10
    3358:	9f 90       	pop	r9
    335a:	8f 90       	pop	r8
    335c:	7f 90       	pop	r7
    335e:	6f 90       	pop	r6
    3360:	5f 90       	pop	r5
    3362:	4f 90       	pop	r4
    3364:	3f 90       	pop	r3
    3366:	2f 90       	pop	r2
    3368:	08 95       	ret
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
		*path = &p[si];									/* Return pointer to the next segment */
    336a:	4a 84       	ldd	r4, Y+10	; 0x0a
    336c:	5b 84       	ldd	r5, Y+11	; 0x0b
    336e:	48 0e       	add	r4, r24
    3370:	59 1e       	adc	r5, r25
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
    3372:	84 e2       	ldi	r24, 0x24	; 36
    3374:	8e ce       	rjmp	.-740    	; 0x3092 <follow_path+0x12c>
    3376:	8a 85       	ldd	r24, Y+10	; 0x0a
    3378:	9b 85       	ldd	r25, Y+11	; 0x0b
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    337a:	48 0e       	add	r4, r24
    337c:	59 1e       	adc	r5, r25
    337e:	89 81       	ldd	r24, Y+1	; 0x01
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    3380:	40 e0       	ldi	r20, 0x00	; 0
    3382:	42 cf       	rjmp	.-380    	; 0x3208 <follow_path+0x2a2>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
    3384:	c8 01       	movw	r24, r16
    3386:	60 e0       	ldi	r22, 0x00	; 0
    3388:	70 e0       	ldi	r23, 0x00	; 0
    338a:	0e 94 58 13 	call	0x26b0	; 0x26b0 <dir_sdi>
	if (res != FR_OK) return res;
    338e:	88 23       	and	r24, r24
    3390:	09 f4       	brne	.+2      	; 0x3394 <follow_path+0x42e>
    3392:	64 cf       	rjmp	.-312    	; 0x325c <follow_path+0x2f6>
    3394:	94 cf       	rjmp	.-216    	; 0x32be <follow_path+0x358>
    3396:	b6 01       	movw	r22, r12
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    3398:	da 01       	movw	r26, r20
    339a:	1b 96       	adiw	r26, 0x0b	; 11
    339c:	9c 91       	ld	r25, X
    339e:	1b 97       	sbiw	r26, 0x0b	; 11
    33a0:	92 ff       	sbrs	r25, 2
    33a2:	a6 cf       	rjmp	.-180    	; 0x32f0 <follow_path+0x38a>
    33a4:	c9 cf       	rjmp	.-110    	; 0x3338 <follow_path+0x3d2>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    33a6:	d8 01       	movw	r26, r16
    33a8:	54 96       	adiw	r26, 0x14	; 20
    33aa:	ed 91       	ld	r30, X+
    33ac:	fc 91       	ld	r31, X
    33ae:	55 97       	sbiw	r26, 0x15	; 21
    33b0:	93 85       	ldd	r25, Z+11	; 0x0b
    33b2:	8d cf       	rjmp	.-230    	; 0x32ce <follow_path+0x368>

000033b4 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
    33b4:	ef 92       	push	r14
    33b6:	ff 92       	push	r15
    33b8:	0f 93       	push	r16
    33ba:	1f 93       	push	r17
    33bc:	cf 93       	push	r28
    33be:	8c 01       	movw	r16, r24
			} while (res == FR_OK && --ne);
		}
	}

#else	/* Non LFN configuration */
	res = dir_sdi(dj, 0);
    33c0:	60 e0       	ldi	r22, 0x00	; 0
    33c2:	70 e0       	ldi	r23, 0x00	; 0
    33c4:	0e 94 58 13 	call	0x26b0	; 0x26b0 <dir_sdi>
    33c8:	c8 2f       	mov	r28, r24
	if (res == FR_OK) {
    33ca:	88 23       	and	r24, r24
    33cc:	09 f0       	breq	.+2      	; 0x33d0 <dir_register+0x1c>
    33ce:	3f c0       	rjmp	.+126    	; 0x344e <dir_register+0x9a>
		do {	/* Find a blank entry for the SFN */
			res = move_window(dj->fs, dj->sect);
    33d0:	d8 01       	movw	r26, r16
    33d2:	1e 96       	adiw	r26, 0x0e	; 14
    33d4:	4d 91       	ld	r20, X+
    33d6:	5d 91       	ld	r21, X+
    33d8:	6d 91       	ld	r22, X+
    33da:	7c 91       	ld	r23, X
    33dc:	51 97       	sbiw	r26, 0x11	; 17
    33de:	8d 91       	ld	r24, X+
    33e0:	9c 91       	ld	r25, X
    33e2:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
    33e6:	c8 2f       	mov	r28, r24
			if (res != FR_OK) break;
    33e8:	88 23       	and	r24, r24
    33ea:	89 f5       	brne	.+98     	; 0x344e <dir_register+0x9a>
			c = *dj->dir;
    33ec:	d8 01       	movw	r26, r16
    33ee:	52 96       	adiw	r26, 0x12	; 18
    33f0:	ed 91       	ld	r30, X+
    33f2:	fc 91       	ld	r31, X
    33f4:	53 97       	sbiw	r26, 0x13	; 19
    33f6:	80 81       	ld	r24, Z
			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
    33f8:	85 3e       	cpi	r24, 0xE5	; 229
    33fa:	81 f1       	breq	.+96     	; 0x345c <dir_register+0xa8>
    33fc:	88 23       	and	r24, r24
    33fe:	71 f1       	breq	.+92     	; 0x345c <dir_register+0xa8>
			res = dir_next(dj, 1);			/* Next entry with table stretch */
    3400:	c8 01       	movw	r24, r16
    3402:	61 e0       	ldi	r22, 0x01	; 1
    3404:	70 e0       	ldi	r23, 0x00	; 0
    3406:	0e 94 6c 16 	call	0x2cd8	; 0x2cd8 <dir_next>
    340a:	c8 2f       	mov	r28, r24
		} while (res == FR_OK);
    340c:	88 23       	and	r24, r24
    340e:	01 f3       	breq	.-64     	; 0x33d0 <dir_register+0x1c>
    3410:	1e c0       	rjmp	.+60     	; 0x344e <dir_register+0x9a>
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
    3412:	f8 01       	movw	r30, r16
    3414:	e2 88       	ldd	r14, Z+18	; 0x12
    3416:	f3 88       	ldd	r15, Z+19	; 0x13
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
    3418:	c7 01       	movw	r24, r14
    341a:	60 e0       	ldi	r22, 0x00	; 0
    341c:	70 e0       	ldi	r23, 0x00	; 0
    341e:	20 e2       	ldi	r18, 0x20	; 32
    3420:	30 e0       	ldi	r19, 0x00	; 0
    3422:	40 e0       	ldi	r20, 0x00	; 0
    3424:	50 e0       	ldi	r21, 0x00	; 0
    3426:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <mem_set>
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
    342a:	d8 01       	movw	r26, r16
    342c:	54 96       	adiw	r26, 0x14	; 20
    342e:	6d 91       	ld	r22, X+
    3430:	7c 91       	ld	r23, X
    3432:	55 97       	sbiw	r26, 0x15	; 21
    3434:	c7 01       	movw	r24, r14
    3436:	2b e0       	ldi	r18, 0x0B	; 11
    3438:	30 e0       	ldi	r19, 0x00	; 0
    343a:	40 e0       	ldi	r20, 0x00	; 0
    343c:	50 e0       	ldi	r21, 0x00	; 0
    343e:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <mem_cpy>
#if _USE_LFN
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dj->fs->wflag = 1;
    3442:	d8 01       	movw	r26, r16
    3444:	ed 91       	ld	r30, X+
    3446:	fc 91       	ld	r31, X
    3448:	11 97       	sbiw	r26, 0x01	; 1
    344a:	81 e0       	ldi	r24, 0x01	; 1
    344c:	84 83       	std	Z+4, r24	; 0x04
		}
	}

	return res;
}
    344e:	8c 2f       	mov	r24, r28
    3450:	cf 91       	pop	r28
    3452:	1f 91       	pop	r17
    3454:	0f 91       	pop	r16
    3456:	ff 90       	pop	r15
    3458:	ef 90       	pop	r14
    345a:	08 95       	ret
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
    345c:	f8 01       	movw	r30, r16
    345e:	46 85       	ldd	r20, Z+14	; 0x0e
    3460:	57 85       	ldd	r21, Z+15	; 0x0f
    3462:	60 89       	ldd	r22, Z+16	; 0x10
    3464:	71 89       	ldd	r23, Z+17	; 0x11
    3466:	80 81       	ld	r24, Z
    3468:	91 81       	ldd	r25, Z+1	; 0x01
    346a:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
    346e:	c8 2f       	mov	r28, r24
		if (res == FR_OK) {
    3470:	88 23       	and	r24, r24
    3472:	69 f7       	brne	.-38     	; 0x344e <dir_register+0x9a>
    3474:	ce cf       	rjmp	.-100    	; 0x3412 <dir_register+0x5e>

00003476 <dir_read>:
#if _FS_MINIMIZE <= 1
static
FRESULT dir_read (
	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
)
{
    3476:	cf 93       	push	r28
    3478:	df 93       	push	r29
    347a:	ec 01       	movw	r28, r24
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
    347c:	84 e0       	ldi	r24, 0x04	; 4
	while (dj->sect) {
    347e:	17 c0       	rjmp	.+46     	; 0x34ae <dir_read+0x38>
		res = move_window(dj->fs, dj->sect);
    3480:	88 81       	ld	r24, Y
    3482:	99 81       	ldd	r25, Y+1	; 0x01
    3484:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
		if (res != FR_OK) break;
    3488:	88 23       	and	r24, r24
    348a:	e1 f4       	brne	.+56     	; 0x34c4 <dir_read+0x4e>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    348c:	ea 89       	ldd	r30, Y+18	; 0x12
    348e:	fb 89       	ldd	r31, Y+19	; 0x13
		c = dir[DIR_Name];
    3490:	90 81       	ld	r25, Z
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    3492:	99 23       	and	r25, r25
    3494:	f1 f0       	breq	.+60     	; 0x34d2 <dir_read+0x5c>
					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    3496:	95 3e       	cpi	r25, 0xE5	; 229
    3498:	19 f0       	breq	.+6      	; 0x34a0 <dir_read+0x2a>
    349a:	93 85       	ldd	r25, Z+11	; 0x0b
    349c:	93 ff       	sbrs	r25, 3
    349e:	16 c0       	rjmp	.+44     	; 0x34cc <dir_read+0x56>
			break;
#endif
		res = dir_next(dj, 0);				/* Next entry */
    34a0:	ce 01       	movw	r24, r28
    34a2:	60 e0       	ldi	r22, 0x00	; 0
    34a4:	70 e0       	ldi	r23, 0x00	; 0
    34a6:	0e 94 6c 16 	call	0x2cd8	; 0x2cd8 <dir_next>
		if (res != FR_OK) break;
    34aa:	88 23       	and	r24, r24
    34ac:	59 f4       	brne	.+22     	; 0x34c4 <dir_read+0x4e>
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
    34ae:	4e 85       	ldd	r20, Y+14	; 0x0e
    34b0:	5f 85       	ldd	r21, Y+15	; 0x0f
    34b2:	68 89       	ldd	r22, Y+16	; 0x10
    34b4:	79 89       	ldd	r23, Y+17	; 0x11
    34b6:	41 15       	cp	r20, r1
    34b8:	51 05       	cpc	r21, r1
    34ba:	61 05       	cpc	r22, r1
    34bc:	71 05       	cpc	r23, r1
    34be:	01 f7       	brne	.-64     	; 0x3480 <dir_read+0xa>
#endif
		res = dir_next(dj, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
    34c0:	88 23       	and	r24, r24
    34c2:	21 f0       	breq	.+8      	; 0x34cc <dir_read+0x56>
    34c4:	1e 86       	std	Y+14, r1	; 0x0e
    34c6:	1f 86       	std	Y+15, r1	; 0x0f
    34c8:	18 8a       	std	Y+16, r1	; 0x10
    34ca:	19 8a       	std	Y+17, r1	; 0x11

	return res;
}
    34cc:	df 91       	pop	r29
    34ce:	cf 91       	pop	r28
    34d0:	08 95       	ret
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    34d2:	84 e0       	ldi	r24, 0x04	; 4
    34d4:	f7 cf       	rjmp	.-18     	; 0x34c4 <dir_read+0x4e>

000034d6 <remove_chain>:
static
FRESULT remove_chain (
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
    34d6:	7f 92       	push	r7
    34d8:	8f 92       	push	r8
    34da:	9f 92       	push	r9
    34dc:	af 92       	push	r10
    34de:	bf 92       	push	r11
    34e0:	cf 92       	push	r12
    34e2:	df 92       	push	r13
    34e4:	ef 92       	push	r14
    34e6:	ff 92       	push	r15
    34e8:	0f 93       	push	r16
    34ea:	1f 93       	push	r17
    34ec:	cf 93       	push	r28
    34ee:	df 93       	push	r29
    34f0:	ec 01       	movw	r28, r24
    34f2:	4a 01       	movw	r8, r20
    34f4:	5b 01       	movw	r10, r22
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    34f6:	42 30       	cpi	r20, 0x02	; 2
    34f8:	51 05       	cpc	r21, r1
    34fa:	61 05       	cpc	r22, r1
    34fc:	71 05       	cpc	r23, r1
    34fe:	08 f4       	brcc	.+2      	; 0x3502 <remove_chain+0x2c>
    3500:	55 c0       	rjmp	.+170    	; 0x35ac <remove_chain+0xd6>
    3502:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3504:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3506:	ac 8d       	ldd	r26, Y+28	; 0x1c
    3508:	bd 8d       	ldd	r27, Y+29	; 0x1d
    350a:	48 17       	cp	r20, r24
    350c:	59 07       	cpc	r21, r25
    350e:	6a 07       	cpc	r22, r26
    3510:	7b 07       	cpc	r23, r27
    3512:	08 f0       	brcs	.+2      	; 0x3516 <remove_chain+0x40>
    3514:	4d c0       	rjmp	.+154    	; 0x35b0 <remove_chain+0xda>
    3516:	03 c0       	rjmp	.+6      	; 0x351e <remove_chain+0x48>
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
    3518:	46 01       	movw	r8, r12
    351a:	57 01       	movw	r10, r14
    351c:	02 c0       	rjmp	.+4      	; 0x3522 <remove_chain+0x4c>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
				fs->free_clust++;
				fs->fsi_flag = 1;
    351e:	77 24       	eor	r7, r7
    3520:	73 94       	inc	r7
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
    3522:	ce 01       	movw	r24, r28
    3524:	b5 01       	movw	r22, r10
    3526:	a4 01       	movw	r20, r8
    3528:	0e 94 21 12 	call	0x2442	; 0x2442 <get_fat>
    352c:	6b 01       	movw	r12, r22
    352e:	7c 01       	movw	r14, r24
			if (nxt == 0) break;				/* Empty cluster? */
    3530:	61 15       	cp	r22, r1
    3532:	71 05       	cpc	r23, r1
    3534:	81 05       	cpc	r24, r1
    3536:	91 05       	cpc	r25, r1
    3538:	e9 f1       	breq	.+122    	; 0x35b4 <remove_chain+0xde>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    353a:	91 e0       	ldi	r25, 0x01	; 1
    353c:	c9 16       	cp	r12, r25
    353e:	d1 04       	cpc	r13, r1
    3540:	e1 04       	cpc	r14, r1
    3542:	f1 04       	cpc	r15, r1
    3544:	c9 f1       	breq	.+114    	; 0x35b8 <remove_chain+0xe2>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    3546:	8f ef       	ldi	r24, 0xFF	; 255
    3548:	c8 16       	cp	r12, r24
    354a:	8f ef       	ldi	r24, 0xFF	; 255
    354c:	d8 06       	cpc	r13, r24
    354e:	8f ef       	ldi	r24, 0xFF	; 255
    3550:	e8 06       	cpc	r14, r24
    3552:	8f ef       	ldi	r24, 0xFF	; 255
    3554:	f8 06       	cpc	r15, r24
    3556:	91 f1       	breq	.+100    	; 0x35bc <remove_chain+0xe6>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    3558:	ce 01       	movw	r24, r28
    355a:	b5 01       	movw	r22, r10
    355c:	a4 01       	movw	r20, r8
    355e:	00 e0       	ldi	r16, 0x00	; 0
    3560:	10 e0       	ldi	r17, 0x00	; 0
    3562:	98 01       	movw	r18, r16
    3564:	0e 94 3b 14 	call	0x2876	; 0x2876 <put_fat>
			if (res != FR_OK) break;
    3568:	88 23       	and	r24, r24
    356a:	49 f5       	brne	.+82     	; 0x35be <remove_chain+0xe8>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    356c:	4e 85       	ldd	r20, Y+14	; 0x0e
    356e:	5f 85       	ldd	r21, Y+15	; 0x0f
    3570:	68 89       	ldd	r22, Y+16	; 0x10
    3572:	79 89       	ldd	r23, Y+17	; 0x11
    3574:	4f 3f       	cpi	r20, 0xFF	; 255
    3576:	9f ef       	ldi	r25, 0xFF	; 255
    3578:	59 07       	cpc	r21, r25
    357a:	9f ef       	ldi	r25, 0xFF	; 255
    357c:	69 07       	cpc	r22, r25
    357e:	9f ef       	ldi	r25, 0xFF	; 255
    3580:	79 07       	cpc	r23, r25
    3582:	49 f0       	breq	.+18     	; 0x3596 <remove_chain+0xc0>
				fs->free_clust++;
    3584:	4f 5f       	subi	r20, 0xFF	; 255
    3586:	5f 4f       	sbci	r21, 0xFF	; 255
    3588:	6f 4f       	sbci	r22, 0xFF	; 255
    358a:	7f 4f       	sbci	r23, 0xFF	; 255
    358c:	4e 87       	std	Y+14, r20	; 0x0e
    358e:	5f 87       	std	Y+15, r21	; 0x0f
    3590:	68 8b       	std	Y+16, r22	; 0x10
    3592:	79 8b       	std	Y+17, r23	; 0x11
				fs->fsi_flag = 1;
    3594:	7d 82       	std	Y+5, r7	; 0x05
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
    3596:	4a 8d       	ldd	r20, Y+26	; 0x1a
    3598:	5b 8d       	ldd	r21, Y+27	; 0x1b
    359a:	6c 8d       	ldd	r22, Y+28	; 0x1c
    359c:	7d 8d       	ldd	r23, Y+29	; 0x1d
    359e:	c4 16       	cp	r12, r20
    35a0:	d5 06       	cpc	r13, r21
    35a2:	e6 06       	cpc	r14, r22
    35a4:	f7 06       	cpc	r15, r23
    35a6:	08 f4       	brcc	.+2      	; 0x35aa <remove_chain+0xd4>
    35a8:	b7 cf       	rjmp	.-146    	; 0x3518 <remove_chain+0x42>
    35aa:	09 c0       	rjmp	.+18     	; 0x35be <remove_chain+0xe8>
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
    35ac:	82 e0       	ldi	r24, 0x02	; 2
    35ae:	07 c0       	rjmp	.+14     	; 0x35be <remove_chain+0xe8>
    35b0:	82 e0       	ldi	r24, 0x02	; 2
    35b2:	05 c0       	rjmp	.+10     	; 0x35be <remove_chain+0xe8>

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
    35b4:	80 e0       	ldi	r24, 0x00	; 0
    35b6:	03 c0       	rjmp	.+6      	; 0x35be <remove_chain+0xe8>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    35b8:	82 e0       	ldi	r24, 0x02	; 2
    35ba:	01 c0       	rjmp	.+2      	; 0x35be <remove_chain+0xe8>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    35bc:	81 e0       	ldi	r24, 0x01	; 1
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
    35be:	df 91       	pop	r29
    35c0:	cf 91       	pop	r28
    35c2:	1f 91       	pop	r17
    35c4:	0f 91       	pop	r16
    35c6:	ff 90       	pop	r15
    35c8:	ef 90       	pop	r14
    35ca:	df 90       	pop	r13
    35cc:	cf 90       	pop	r12
    35ce:	bf 90       	pop	r11
    35d0:	af 90       	pop	r10
    35d2:	9f 90       	pop	r9
    35d4:	8f 90       	pop	r8
    35d6:	7f 90       	pop	r7
    35d8:	08 95       	ret

000035da <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
    35da:	88 23       	and	r24, r24
    35dc:	91 f4       	brne	.+36     	; 0x3602 <f_mount+0x28>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
    35de:	e0 91 23 04 	lds	r30, 0x0423
    35e2:	f0 91 24 04 	lds	r31, 0x0424

	if (rfs) {
    35e6:	30 97       	sbiw	r30, 0x00	; 0
    35e8:	09 f0       	breq	.+2      	; 0x35ec <f_mount+0x12>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
    35ea:	10 82       	st	Z, r1
	}

	if (fs) {
    35ec:	61 15       	cp	r22, r1
    35ee:	71 05       	cpc	r23, r1
    35f0:	11 f0       	breq	.+4      	; 0x35f6 <f_mount+0x1c>
		fs->fs_type = 0;		/* Clear new fs object */
    35f2:	fb 01       	movw	r30, r22
    35f4:	10 82       	st	Z, r1
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
    35f6:	70 93 24 04 	sts	0x0424, r23
    35fa:	60 93 23 04 	sts	0x0423, r22

	return FR_OK;
    35fe:	80 e0       	ldi	r24, 0x00	; 0
    3600:	08 95       	ret
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
    3602:	8b e0       	ldi	r24, 0x0B	; 11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
    3604:	08 95       	ret

00003606 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    3606:	4f 92       	push	r4
    3608:	5f 92       	push	r5
    360a:	6f 92       	push	r6
    360c:	7f 92       	push	r7
    360e:	8f 92       	push	r8
    3610:	9f 92       	push	r9
    3612:	af 92       	push	r10
    3614:	bf 92       	push	r11
    3616:	cf 92       	push	r12
    3618:	df 92       	push	r13
    361a:	ef 92       	push	r14
    361c:	ff 92       	push	r15
    361e:	0f 93       	push	r16
    3620:	1f 93       	push	r17
    3622:	cf 93       	push	r28
    3624:	df 93       	push	r29
    3626:	cd b7       	in	r28, 0x3d	; 61
    3628:	de b7       	in	r29, 0x3e	; 62
    362a:	a4 97       	sbiw	r28, 0x24	; 36
    362c:	0f b6       	in	r0, 0x3f	; 63
    362e:	f8 94       	cli
    3630:	de bf       	out	0x3e, r29	; 62
    3632:	0f be       	out	0x3f, r0	; 63
    3634:	cd bf       	out	0x3d, r28	; 61
    3636:	7c 01       	movw	r14, r24
    3638:	7c a3       	lds	r23, 0x5c
    363a:	6b a3       	lds	r22, 0x5b
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    363c:	00 97       	sbiw	r24, 0x00	; 0
    363e:	09 f4       	brne	.+2      	; 0x3642 <f_open+0x3c>
    3640:	ea c0       	rjmp	.+468    	; 0x3816 <f_open+0x210>
	fp->fs = 0;			/* Clear file object */
    3642:	fc 01       	movw	r30, r24
    3644:	11 82       	std	Z+1, r1	; 0x01
    3646:	10 82       	st	Z, r1

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    3648:	04 2f       	mov	r16, r20
    364a:	0f 71       	andi	r16, 0x1F	; 31
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
    364c:	4e 71       	andi	r20, 0x1E	; 30
    364e:	ce 01       	movw	r24, r28
    3650:	83 96       	adiw	r24, 0x23	; 35
    3652:	be 01       	movw	r22, r28
    3654:	6f 5f       	subi	r22, 0xFF	; 255
    3656:	7f 4f       	sbci	r23, 0xFF	; 255
    3658:	0e 94 84 0c 	call	0x1908	; 0x1908 <chk_mounted>
    365c:	18 2f       	mov	r17, r24
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res == FR_OK) {
    365e:	88 23       	and	r24, r24
    3660:	09 f0       	breq	.+2      	; 0x3664 <f_open+0x5e>
    3662:	da c0       	rjmp	.+436    	; 0x3818 <f_open+0x212>
		INIT_BUF(dj);
    3664:	ce 01       	movw	r24, r28
    3666:	47 96       	adiw	r24, 0x17	; 23
    3668:	9e 8b       	std	Y+22, r25	; 0x16
    366a:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    366c:	6b a1       	lds	r22, 0x4b
    366e:	7c a1       	lds	r23, 0x4c
    3670:	ce 01       	movw	r24, r28
    3672:	01 96       	adiw	r24, 0x01	; 1
    3674:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <follow_path>
		dir = dj.dir;
    3678:	cb 88       	ldd	r12, Y+19	; 0x13
    367a:	dc 88       	ldd	r13, Y+20	; 0x14
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
    367c:	88 23       	and	r24, r24
    367e:	21 f4       	brne	.+8      	; 0x3688 <f_open+0x82>
			if (!dir)	/* Current dir itself */
    3680:	c1 14       	cp	r12, r1
    3682:	d1 04       	cpc	r13, r1
    3684:	09 f4       	brne	.+2      	; 0x3688 <f_open+0x82>
				res = FR_INVALID_NAME;
    3686:	86 e0       	ldi	r24, 0x06	; 6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    3688:	40 2f       	mov	r20, r16
    368a:	50 e0       	ldi	r21, 0x00	; 0
    368c:	9a 01       	movw	r18, r20
    368e:	2c 71       	andi	r18, 0x1C	; 28
    3690:	30 70       	andi	r19, 0x00	; 0
    3692:	21 15       	cp	r18, r1
    3694:	31 05       	cpc	r19, r1
    3696:	09 f4       	brne	.+2      	; 0x369a <f_open+0x94>
    3698:	5b c0       	rjmp	.+182    	; 0x3750 <f_open+0x14a>
			DWORD dw, cl;

			if (res != FR_OK) {					/* No file, create new */
    369a:	88 23       	and	r24, r24
    369c:	71 f0       	breq	.+28     	; 0x36ba <f_open+0xb4>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    369e:	84 30       	cpi	r24, 0x04	; 4
    36a0:	09 f0       	breq	.+2      	; 0x36a4 <f_open+0x9e>
    36a2:	b7 c0       	rjmp	.+366    	; 0x3812 <f_open+0x20c>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
    36a4:	ce 01       	movw	r24, r28
    36a6:	01 96       	adiw	r24, 0x01	; 1
    36a8:	0e 94 da 19 	call	0x33b4	; 0x33b4 <dir_register>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
    36ac:	cb 88       	ldd	r12, Y+19	; 0x13
    36ae:	dc 88       	ldd	r13, Y+20	; 0x14
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    36b0:	88 23       	and	r24, r24
    36b2:	09 f0       	breq	.+2      	; 0x36b6 <f_open+0xb0>
    36b4:	ae c0       	rjmp	.+348    	; 0x3812 <f_open+0x20c>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
    36b6:	08 60       	ori	r16, 0x08	; 8
    36b8:	07 c0       	rjmp	.+14     	; 0x36c8 <f_open+0xc2>
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    36ba:	f6 01       	movw	r30, r12
    36bc:	83 85       	ldd	r24, Z+11	; 0x0b
    36be:	81 71       	andi	r24, 0x11	; 17
    36c0:	09 f0       	breq	.+2      	; 0x36c4 <f_open+0xbe>
    36c2:	c2 c0       	rjmp	.+388    	; 0x3848 <f_open+0x242>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    36c4:	02 fd       	sbrc	r16, 2
    36c6:	c2 c0       	rjmp	.+388    	; 0x384c <f_open+0x246>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    36c8:	03 ff       	sbrs	r16, 3
    36ca:	c6 c0       	rjmp	.+396    	; 0x3858 <f_open+0x252>
				dw = get_fattime();					/* Created time */
    36cc:	0e 94 e7 11 	call	0x23ce	; 0x23ce <get_fattime>
				ST_DWORD(dir+DIR_CrtTime, dw);
    36d0:	f6 01       	movw	r30, r12
    36d2:	66 87       	std	Z+14, r22	; 0x0e
    36d4:	77 87       	std	Z+15, r23	; 0x0f
    36d6:	80 8b       	std	Z+16, r24	; 0x10
    36d8:	91 8b       	std	Z+17, r25	; 0x11
				dir[DIR_Attr] = 0;					/* Reset attribute */
    36da:	13 86       	std	Z+11, r1	; 0x0b
				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
    36dc:	14 8e       	std	Z+28, r1	; 0x1c
    36de:	15 8e       	std	Z+29, r1	; 0x1d
    36e0:	16 8e       	std	Z+30, r1	; 0x1e
    36e2:	17 8e       	std	Z+31, r1	; 0x1f
				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
    36e4:	89 81       	ldd	r24, Y+1	; 0x01
    36e6:	9a 81       	ldd	r25, Y+2	; 0x02
    36e8:	b6 01       	movw	r22, r12
    36ea:	0e 94 07 0b 	call	0x160e	; 0x160e <ld_clust>
    36ee:	4b 01       	movw	r8, r22
    36f0:	5c 01       	movw	r10, r24
				st_clust(dir, 0);					/* cluster = 0 */
    36f2:	c6 01       	movw	r24, r12
    36f4:	40 e0       	ldi	r20, 0x00	; 0
    36f6:	50 e0       	ldi	r21, 0x00	; 0
    36f8:	ba 01       	movw	r22, r20
    36fa:	0e 94 2c 0b 	call	0x1658	; 0x1658 <st_clust>
				dj.fs->wflag = 1;
    36fe:	e9 81       	ldd	r30, Y+1	; 0x01
    3700:	fa 81       	ldd	r31, Y+2	; 0x02
    3702:	81 e0       	ldi	r24, 0x01	; 1
    3704:	84 83       	std	Z+4, r24	; 0x04
				if (cl) {							/* Remove the cluster chain if exist */
    3706:	81 14       	cp	r8, r1
    3708:	91 04       	cpc	r9, r1
    370a:	a1 04       	cpc	r10, r1
    370c:	b1 04       	cpc	r11, r1
    370e:	09 f4       	brne	.+2      	; 0x3712 <f_open+0x10c>
    3710:	a3 c0       	rjmp	.+326    	; 0x3858 <f_open+0x252>
					dw = dj.fs->winsect;
    3712:	46 a4       	lds	r20, 0xa6
    3714:	57 a4       	lds	r21, 0xa7
    3716:	60 a8       	sts	0x00, r22
    3718:	71 a8       	sts	0x81, r23
					res = remove_chain(dj.fs, cl);
    371a:	cf 01       	movw	r24, r30
    371c:	b5 01       	movw	r22, r10
    371e:	a4 01       	movw	r20, r8
    3720:	0e 94 6b 1a 	call	0x34d6	; 0x34d6 <remove_chain>
					if (res == FR_OK) {
    3724:	88 23       	and	r24, r24
    3726:	09 f0       	breq	.+2      	; 0x372a <f_open+0x124>
    3728:	74 c0       	rjmp	.+232    	; 0x3812 <f_open+0x20c>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    372a:	e9 81       	ldd	r30, Y+1	; 0x01
    372c:	fa 81       	ldd	r31, Y+2	; 0x02
    372e:	d5 01       	movw	r26, r10
    3730:	c4 01       	movw	r24, r8
    3732:	01 97       	sbiw	r24, 0x01	; 1
    3734:	a1 09       	sbc	r26, r1
    3736:	b1 09       	sbc	r27, r1
    3738:	82 87       	std	Z+10, r24	; 0x0a
    373a:	93 87       	std	Z+11, r25	; 0x0b
    373c:	a4 87       	std	Z+12, r26	; 0x0c
    373e:	b5 87       	std	Z+13, r27	; 0x0d
						res = move_window(dj.fs, dw);
    3740:	cf 01       	movw	r24, r30
    3742:	b3 01       	movw	r22, r6
    3744:	a2 01       	movw	r20, r4
    3746:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
    374a:	88 23       	and	r24, r24
    374c:	69 f0       	breq	.+26     	; 0x3768 <f_open+0x162>
    374e:	61 c0       	rjmp	.+194    	; 0x3812 <f_open+0x20c>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {						/* Follow succeeded */
    3750:	88 23       	and	r24, r24
    3752:	09 f0       	breq	.+2      	; 0x3756 <f_open+0x150>
    3754:	5e c0       	rjmp	.+188    	; 0x3812 <f_open+0x20c>
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    3756:	f6 01       	movw	r30, r12
    3758:	83 85       	ldd	r24, Z+11	; 0x0b
    375a:	84 fd       	sbrc	r24, 4
    375c:	79 c0       	rjmp	.+242    	; 0x3850 <f_open+0x24a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    375e:	01 ff       	sbrs	r16, 1
    3760:	7b c0       	rjmp	.+246    	; 0x3858 <f_open+0x252>
    3762:	80 fd       	sbrc	r24, 0
    3764:	77 c0       	rjmp	.+238    	; 0x3854 <f_open+0x24e>
    3766:	78 c0       	rjmp	.+240    	; 0x3858 <f_open+0x252>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
    3768:	00 62       	ori	r16, 0x20	; 32
			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
    376a:	a9 80       	ldd	r10, Y+1	; 0x01
    376c:	ba 80       	ldd	r11, Y+2	; 0x02
    376e:	f5 01       	movw	r30, r10
    3770:	86 a5       	lds	r24, 0x66
    3772:	97 a5       	lds	r25, 0x67
    3774:	a0 a9       	sts	0x40, r26
    3776:	b1 a9       	sts	0x41, r27
    3778:	f7 01       	movw	r30, r14
    377a:	82 8f       	std	Z+26, r24	; 0x1a
    377c:	93 8f       	std	Z+27, r25	; 0x1b
    377e:	a4 8f       	std	Z+28, r26	; 0x1c
    3780:	b5 8f       	std	Z+29, r27	; 0x1d
			fp->dir_ptr = dir;
    3782:	d7 8e       	std	Z+31, r13	; 0x1f
    3784:	c6 8e       	std	Z+30, r12	; 0x1e
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
    3786:	04 83       	std	Z+4, r16	; 0x04
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
    3788:	c5 01       	movw	r24, r10
    378a:	b6 01       	movw	r22, r12
    378c:	0e 94 07 0b 	call	0x160e	; 0x160e <ld_clust>
    3790:	dc 01       	movw	r26, r24
    3792:	cb 01       	movw	r24, r22
    3794:	f7 01       	movw	r30, r14
    3796:	86 87       	std	Z+14, r24	; 0x0e
    3798:	97 87       	std	Z+15, r25	; 0x0f
    379a:	a0 8b       	std	Z+16, r26	; 0x10
    379c:	b1 8b       	std	Z+17, r27	; 0x11
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    379e:	f6 01       	movw	r30, r12
    37a0:	87 8d       	ldd	r24, Z+31	; 0x1f
    37a2:	90 e0       	ldi	r25, 0x00	; 0
    37a4:	a0 e0       	ldi	r26, 0x00	; 0
    37a6:	b0 e0       	ldi	r27, 0x00	; 0
    37a8:	78 2f       	mov	r23, r24
    37aa:	66 27       	eor	r22, r22
    37ac:	55 27       	eor	r21, r21
    37ae:	44 27       	eor	r20, r20
    37b0:	86 8d       	ldd	r24, Z+30	; 0x1e
    37b2:	90 e0       	ldi	r25, 0x00	; 0
    37b4:	a0 e0       	ldi	r26, 0x00	; 0
    37b6:	b0 e0       	ldi	r27, 0x00	; 0
    37b8:	dc 01       	movw	r26, r24
    37ba:	99 27       	eor	r25, r25
    37bc:	88 27       	eor	r24, r24
    37be:	48 2b       	or	r20, r24
    37c0:	59 2b       	or	r21, r25
    37c2:	6a 2b       	or	r22, r26
    37c4:	7b 2b       	or	r23, r27
    37c6:	84 8d       	ldd	r24, Z+28	; 0x1c
    37c8:	90 e0       	ldi	r25, 0x00	; 0
    37ca:	a0 e0       	ldi	r26, 0x00	; 0
    37cc:	b0 e0       	ldi	r27, 0x00	; 0
    37ce:	48 2b       	or	r20, r24
    37d0:	59 2b       	or	r21, r25
    37d2:	6a 2b       	or	r22, r26
    37d4:	7b 2b       	or	r23, r27
    37d6:	95 8d       	ldd	r25, Z+29	; 0x1d
    37d8:	80 e0       	ldi	r24, 0x00	; 0
    37da:	a0 e0       	ldi	r26, 0x00	; 0
    37dc:	b0 e0       	ldi	r27, 0x00	; 0
    37de:	84 2b       	or	r24, r20
    37e0:	95 2b       	or	r25, r21
    37e2:	a6 2b       	or	r26, r22
    37e4:	b7 2b       	or	r27, r23
    37e6:	f7 01       	movw	r30, r14
    37e8:	82 87       	std	Z+10, r24	; 0x0a
    37ea:	93 87       	std	Z+11, r25	; 0x0b
    37ec:	a4 87       	std	Z+12, r26	; 0x0c
    37ee:	b5 87       	std	Z+13, r27	; 0x0d
			fp->fptr = 0;						/* File pointer */
    37f0:	16 82       	std	Z+6, r1	; 0x06
    37f2:	17 82       	std	Z+7, r1	; 0x07
    37f4:	10 86       	std	Z+8, r1	; 0x08
    37f6:	11 86       	std	Z+9, r1	; 0x09
			fp->dsect = 0;
    37f8:	16 8a       	std	Z+22, r1	; 0x16
    37fa:	17 8a       	std	Z+23, r1	; 0x17
    37fc:	10 8e       	std	Z+24, r1	; 0x18
    37fe:	11 8e       	std	Z+25, r1	; 0x19
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    3800:	b1 82       	std	Z+1, r11	; 0x01
    3802:	a0 82       	st	Z, r10
    3804:	f5 01       	movw	r30, r10
    3806:	86 81       	ldd	r24, Z+6	; 0x06
    3808:	97 81       	ldd	r25, Z+7	; 0x07
    380a:	f7 01       	movw	r30, r14
    380c:	93 83       	std	Z+3, r25	; 0x03
    380e:	82 83       	std	Z+2, r24	; 0x02
    3810:	03 c0       	rjmp	.+6      	; 0x3818 <f_open+0x212>
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    3812:	18 2f       	mov	r17, r24
    3814:	01 c0       	rjmp	.+2      	; 0x3818 <f_open+0x212>
    3816:	19 e0       	ldi	r17, 0x09	; 9
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
		}
	}

	LEAVE_FF(dj.fs, res);
}
    3818:	81 2f       	mov	r24, r17
    381a:	a4 96       	adiw	r28, 0x24	; 36
    381c:	0f b6       	in	r0, 0x3f	; 63
    381e:	f8 94       	cli
    3820:	de bf       	out	0x3e, r29	; 62
    3822:	0f be       	out	0x3f, r0	; 63
    3824:	cd bf       	out	0x3d, r28	; 61
    3826:	df 91       	pop	r29
    3828:	cf 91       	pop	r28
    382a:	1f 91       	pop	r17
    382c:	0f 91       	pop	r16
    382e:	ff 90       	pop	r15
    3830:	ef 90       	pop	r14
    3832:	df 90       	pop	r13
    3834:	cf 90       	pop	r12
    3836:	bf 90       	pop	r11
    3838:	af 90       	pop	r10
    383a:	9f 90       	pop	r9
    383c:	8f 90       	pop	r8
    383e:	7f 90       	pop	r7
    3840:	6f 90       	pop	r6
    3842:	5f 90       	pop	r5
    3844:	4f 90       	pop	r4
    3846:	08 95       	ret
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
					res = FR_DENIED;
    3848:	87 e0       	ldi	r24, 0x07	; 7
    384a:	e3 cf       	rjmp	.-58     	; 0x3812 <f_open+0x20c>
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
    384c:	88 e0       	ldi	r24, 0x08	; 8
    384e:	e1 cf       	rjmp	.-62     	; 0x3812 <f_open+0x20c>
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {						/* Follow succeeded */
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
					res = FR_NO_FILE;
    3850:	84 e0       	ldi	r24, 0x04	; 4
    3852:	df cf       	rjmp	.-66     	; 0x3812 <f_open+0x20c>
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
    3854:	87 e0       	ldi	r24, 0x07	; 7
    3856:	dd cf       	rjmp	.-70     	; 0x3812 <f_open+0x20c>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
    3858:	03 ff       	sbrs	r16, 3
    385a:	87 cf       	rjmp	.-242    	; 0x376a <f_open+0x164>
    385c:	85 cf       	rjmp	.-246    	; 0x3768 <f_open+0x162>

0000385e <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
    385e:	2f 92       	push	r2
    3860:	3f 92       	push	r3
    3862:	4f 92       	push	r4
    3864:	5f 92       	push	r5
    3866:	6f 92       	push	r6
    3868:	7f 92       	push	r7
    386a:	8f 92       	push	r8
    386c:	9f 92       	push	r9
    386e:	af 92       	push	r10
    3870:	bf 92       	push	r11
    3872:	cf 92       	push	r12
    3874:	df 92       	push	r13
    3876:	ef 92       	push	r14
    3878:	ff 92       	push	r15
    387a:	0f 93       	push	r16
    387c:	1f 93       	push	r17
    387e:	cf 93       	push	r28
    3880:	df 93       	push	r29
    3882:	cd b7       	in	r28, 0x3d	; 61
    3884:	de b7       	in	r29, 0x3e	; 62
    3886:	29 97       	sbiw	r28, 0x09	; 9
    3888:	0f b6       	in	r0, 0x3f	; 63
    388a:	f8 94       	cli
    388c:	de bf       	out	0x3e, r29	; 62
    388e:	0f be       	out	0x3f, r0	; 63
    3890:	cd bf       	out	0x3d, r28	; 61
    3892:	9c 83       	std	Y+4, r25	; 0x04
    3894:	8b 83       	std	Y+3, r24	; 0x03
    3896:	a6 2e       	mov	r10, r22
    3898:	97 2e       	mov	r9, r23
    389a:	c2 2e       	mov	r12, r18
    389c:	f3 2e       	mov	r15, r19
    389e:	e4 2e       	mov	r14, r20
    38a0:	d5 2e       	mov	r13, r21
    38a2:	18 01       	movw	r2, r16
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Clear read byte counter */
    38a4:	d8 01       	movw	r26, r16
    38a6:	1d 92       	st	X+, r1
    38a8:	1d 92       	st	X+, r1
    38aa:	1d 92       	st	X+, r1
    38ac:	1c 92       	st	X, r1
    38ae:	13 97       	sbiw	r26, 0x03	; 3

	res = validate(fp);							/* Check validity */
    38b0:	0e 94 c7 0b 	call	0x178e	; 0x178e <validate>
    38b4:	b8 2e       	mov	r11, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    38b6:	88 23       	and	r24, r24
    38b8:	09 f0       	breq	.+2      	; 0x38bc <f_read+0x5e>
    38ba:	e1 c1       	rjmp	.+962    	; 0x3c7e <f_read+0x420>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
    38bc:	eb 81       	ldd	r30, Y+3	; 0x03
    38be:	fc 81       	ldd	r31, Y+4	; 0x04
    38c0:	84 81       	ldd	r24, Z+4	; 0x04
    38c2:	88 23       	and	r24, r24
    38c4:	0c f4       	brge	.+2      	; 0x38c8 <f_read+0x6a>
    38c6:	d3 c1       	rjmp	.+934    	; 0x3c6e <f_read+0x410>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    38c8:	80 ff       	sbrs	r24, 0
    38ca:	d5 c1       	rjmp	.+938    	; 0x3c76 <f_read+0x418>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
    38cc:	42 85       	ldd	r20, Z+10	; 0x0a
    38ce:	53 85       	ldd	r21, Z+11	; 0x0b
    38d0:	64 85       	ldd	r22, Z+12	; 0x0c
    38d2:	75 85       	ldd	r23, Z+13	; 0x0d
    38d4:	86 81       	ldd	r24, Z+6	; 0x06
    38d6:	97 81       	ldd	r25, Z+7	; 0x07
    38d8:	a0 85       	ldd	r26, Z+8	; 0x08
    38da:	b1 85       	ldd	r27, Z+9	; 0x09
    38dc:	48 1b       	sub	r20, r24
    38de:	59 0b       	sbc	r21, r25
    38e0:	6a 0b       	sbc	r22, r26
    38e2:	7b 0b       	sbc	r23, r27

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    38e4:	4c 2c       	mov	r4, r12
    38e6:	5f 2c       	mov	r5, r15
    38e8:	6e 2c       	mov	r6, r14
    38ea:	7d 2c       	mov	r7, r13
    38ec:	44 15       	cp	r20, r4
    38ee:	55 05       	cpc	r21, r5
    38f0:	66 05       	cpc	r22, r6
    38f2:	77 05       	cpc	r23, r7
    38f4:	10 f4       	brcc	.+4      	; 0x38fa <f_read+0x9c>
    38f6:	2a 01       	movw	r4, r20
    38f8:	3b 01       	movw	r6, r22
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    38fa:	41 14       	cp	r4, r1
    38fc:	51 04       	cpc	r5, r1
    38fe:	61 04       	cpc	r6, r1
    3900:	71 04       	cpc	r7, r1
    3902:	09 f4       	brne	.+2      	; 0x3906 <f_read+0xa8>
    3904:	bc c1       	rjmp	.+888    	; 0x3c7e <f_read+0x420>
    3906:	a9 82       	std	Y+1, r10	; 0x01
    3908:	9a 82       	std	Y+2, r9	; 0x02
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    390a:	0b 81       	ldd	r16, Y+3	; 0x03
    390c:	1c 81       	ldd	r17, Y+4	; 0x04
    390e:	00 5e       	subi	r16, 0xE0	; 224
    3910:	1f 4f       	sbci	r17, 0xFF	; 255
    3912:	1e 83       	std	Y+6, r17	; 0x06
    3914:	0d 83       	std	Y+5, r16	; 0x05
    3916:	bf 82       	std	Y+7, r11	; 0x07
    3918:	2b 81       	ldd	r18, Y+3	; 0x03
    391a:	3c 81       	ldd	r19, Y+4	; 0x04
    391c:	39 87       	std	Y+9, r19	; 0x09
    391e:	28 87       	std	Y+8, r18	; 0x08
    3920:	3c 82       	std	Y+4, r3	; 0x04
    3922:	2b 82       	std	Y+3, r2	; 0x03
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    3924:	a8 85       	ldd	r26, Y+8	; 0x08
    3926:	b9 85       	ldd	r27, Y+9	; 0x09
    3928:	16 96       	adiw	r26, 0x06	; 6
    392a:	4d 91       	ld	r20, X+
    392c:	5d 91       	ld	r21, X+
    392e:	6d 91       	ld	r22, X+
    3930:	7c 91       	ld	r23, X
    3932:	19 97       	sbiw	r26, 0x09	; 9
    3934:	db 01       	movw	r26, r22
    3936:	ca 01       	movw	r24, r20
    3938:	91 70       	andi	r25, 0x01	; 1
    393a:	a0 70       	andi	r26, 0x00	; 0
    393c:	b0 70       	andi	r27, 0x00	; 0
    393e:	00 97       	sbiw	r24, 0x00	; 0
    3940:	a1 05       	cpc	r26, r1
    3942:	b1 05       	cpc	r27, r1
    3944:	09 f0       	breq	.+2      	; 0x3948 <f_read+0xea>
    3946:	3f c1       	rjmp	.+638    	; 0x3bc6 <f_read+0x368>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    3948:	a8 85       	ldd	r26, Y+8	; 0x08
    394a:	b9 85       	ldd	r27, Y+9	; 0x09
    394c:	ed 91       	ld	r30, X+
    394e:	fc 91       	ld	r31, X
    3950:	db 01       	movw	r26, r22
    3952:	ca 01       	movw	r24, r20
    3954:	07 2e       	mov	r0, r23
    3956:	79 e0       	ldi	r23, 0x09	; 9
    3958:	b6 95       	lsr	r27
    395a:	a7 95       	ror	r26
    395c:	97 95       	ror	r25
    395e:	87 95       	ror	r24
    3960:	7a 95       	dec	r23
    3962:	d1 f7       	brne	.-12     	; 0x3958 <f_read+0xfa>
    3964:	70 2d       	mov	r23, r0
    3966:	02 81       	ldd	r16, Z+2	; 0x02
    3968:	01 50       	subi	r16, 0x01	; 1
    396a:	08 23       	and	r16, r24
			if (!csect) {						/* On the cluster boundary? */
    396c:	09 f0       	breq	.+2      	; 0x3970 <f_read+0x112>
    396e:	44 c0       	rjmp	.+136    	; 0x39f8 <f_read+0x19a>
				if (fp->fptr == 0) {			/* On the top of the file? */
    3970:	41 15       	cp	r20, r1
    3972:	51 05       	cpc	r21, r1
    3974:	61 05       	cpc	r22, r1
    3976:	71 05       	cpc	r23, r1
    3978:	39 f4       	brne	.+14     	; 0x3988 <f_read+0x12a>
					clst = fp->sclust;			/* Follow from the origin */
    397a:	e8 85       	ldd	r30, Y+8	; 0x08
    397c:	f9 85       	ldd	r31, Y+9	; 0x09
    397e:	86 85       	ldd	r24, Z+14	; 0x0e
    3980:	97 85       	ldd	r25, Z+15	; 0x0f
    3982:	a0 89       	ldd	r26, Z+16	; 0x10
    3984:	b1 89       	ldd	r27, Z+17	; 0x11
    3986:	0d c0       	rjmp	.+26     	; 0x39a2 <f_read+0x144>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    3988:	a8 85       	ldd	r26, Y+8	; 0x08
    398a:	b9 85       	ldd	r27, Y+9	; 0x09
    398c:	52 96       	adiw	r26, 0x12	; 18
    398e:	4d 91       	ld	r20, X+
    3990:	5d 91       	ld	r21, X+
    3992:	6d 91       	ld	r22, X+
    3994:	7c 91       	ld	r23, X
    3996:	55 97       	sbiw	r26, 0x15	; 21
    3998:	cf 01       	movw	r24, r30
    399a:	0e 94 21 12 	call	0x2442	; 0x2442 <get_fat>
    399e:	dc 01       	movw	r26, r24
    39a0:	cb 01       	movw	r24, r22
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    39a2:	82 30       	cpi	r24, 0x02	; 2
    39a4:	91 05       	cpc	r25, r1
    39a6:	a1 05       	cpc	r26, r1
    39a8:	b1 05       	cpc	r27, r1
    39aa:	48 f4       	brcc	.+18     	; 0x39be <f_read+0x160>
    39ac:	e8 85       	ldd	r30, Y+8	; 0x08
    39ae:	f9 85       	ldd	r31, Y+9	; 0x09
    39b0:	84 81       	ldd	r24, Z+4	; 0x04
    39b2:	80 68       	ori	r24, 0x80	; 128
    39b4:	84 83       	std	Z+4, r24	; 0x04
    39b6:	bb 24       	eor	r11, r11
    39b8:	68 94       	set
    39ba:	b1 f8       	bld	r11, 1
    39bc:	60 c1       	rjmp	.+704    	; 0x3c7e <f_read+0x420>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    39be:	8f 3f       	cpi	r24, 0xFF	; 255
    39c0:	ff ef       	ldi	r31, 0xFF	; 255
    39c2:	9f 07       	cpc	r25, r31
    39c4:	ff ef       	ldi	r31, 0xFF	; 255
    39c6:	af 07       	cpc	r26, r31
    39c8:	ff ef       	ldi	r31, 0xFF	; 255
    39ca:	bf 07       	cpc	r27, r31
    39cc:	79 f4       	brne	.+30     	; 0x39ec <f_read+0x18e>
    39ce:	08 85       	ldd	r16, Y+8	; 0x08
    39d0:	19 85       	ldd	r17, Y+9	; 0x09
    39d2:	1c 83       	std	Y+4, r17	; 0x04
    39d4:	0b 83       	std	Y+3, r16	; 0x03
    39d6:	d8 01       	movw	r26, r16
    39d8:	14 96       	adiw	r26, 0x04	; 4
    39da:	8c 91       	ld	r24, X
    39dc:	14 97       	sbiw	r26, 0x04	; 4
    39de:	80 68       	ori	r24, 0x80	; 128
    39e0:	14 96       	adiw	r26, 0x04	; 4
    39e2:	8c 93       	st	X, r24
    39e4:	14 97       	sbiw	r26, 0x04	; 4
    39e6:	bb 24       	eor	r11, r11
    39e8:	b3 94       	inc	r11
    39ea:	49 c1       	rjmp	.+658    	; 0x3c7e <f_read+0x420>
				fp->clust = clst;				/* Update current cluster */
    39ec:	e8 85       	ldd	r30, Y+8	; 0x08
    39ee:	f9 85       	ldd	r31, Y+9	; 0x09
    39f0:	82 8b       	std	Z+18, r24	; 0x12
    39f2:	93 8b       	std	Z+19, r25	; 0x13
    39f4:	a4 8b       	std	Z+20, r26	; 0x14
    39f6:	b5 8b       	std	Z+21, r27	; 0x15
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    39f8:	a8 85       	ldd	r26, Y+8	; 0x08
    39fa:	b9 85       	ldd	r27, Y+9	; 0x09
    39fc:	2d 90       	ld	r2, X+
    39fe:	3c 90       	ld	r3, X
    3a00:	11 97       	sbiw	r26, 0x01	; 1
    3a02:	52 96       	adiw	r26, 0x12	; 18
    3a04:	4d 91       	ld	r20, X+
    3a06:	5d 91       	ld	r21, X+
    3a08:	6d 91       	ld	r22, X+
    3a0a:	7c 91       	ld	r23, X
    3a0c:	55 97       	sbiw	r26, 0x15	; 21
    3a0e:	c1 01       	movw	r24, r2
    3a10:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <clust2sect>
    3a14:	dc 01       	movw	r26, r24
    3a16:	cb 01       	movw	r24, r22
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    3a18:	00 97       	sbiw	r24, 0x00	; 0
    3a1a:	a1 05       	cpc	r26, r1
    3a1c:	b1 05       	cpc	r27, r1
    3a1e:	49 f4       	brne	.+18     	; 0x3a32 <f_read+0x1d4>
    3a20:	e8 85       	ldd	r30, Y+8	; 0x08
    3a22:	f9 85       	ldd	r31, Y+9	; 0x09
    3a24:	84 81       	ldd	r24, Z+4	; 0x04
    3a26:	80 68       	ori	r24, 0x80	; 128
    3a28:	84 83       	std	Z+4, r24	; 0x04
    3a2a:	bb 24       	eor	r11, r11
    3a2c:	68 94       	set
    3a2e:	b1 f8       	bld	r11, 1
    3a30:	26 c1       	rjmp	.+588    	; 0x3c7e <f_read+0x420>
			sect += csect;
    3a32:	40 2f       	mov	r20, r16
    3a34:	50 e0       	ldi	r21, 0x00	; 0
    3a36:	60 e0       	ldi	r22, 0x00	; 0
    3a38:	70 e0       	ldi	r23, 0x00	; 0
    3a3a:	4c 01       	movw	r8, r24
    3a3c:	5d 01       	movw	r10, r26
    3a3e:	84 0e       	add	r8, r20
    3a40:	95 1e       	adc	r9, r21
    3a42:	a6 1e       	adc	r10, r22
    3a44:	b7 1e       	adc	r11, r23
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    3a46:	73 01       	movw	r14, r6
    3a48:	62 01       	movw	r12, r4
    3a4a:	0b 2e       	mov	r0, r27
    3a4c:	b9 e0       	ldi	r27, 0x09	; 9
    3a4e:	f6 94       	lsr	r15
    3a50:	e7 94       	ror	r14
    3a52:	d7 94       	ror	r13
    3a54:	c7 94       	ror	r12
    3a56:	ba 95       	dec	r27
    3a58:	d1 f7       	brne	.-12     	; 0x3a4e <f_read+0x1f0>
    3a5a:	b0 2d       	mov	r27, r0
			if (cc) {							/* Read maximum contiguous sectors directly */
    3a5c:	c1 14       	cp	r12, r1
    3a5e:	d1 04       	cpc	r13, r1
    3a60:	e1 04       	cpc	r14, r1
    3a62:	f1 04       	cpc	r15, r1
    3a64:	09 f4       	brne	.+2      	; 0x3a68 <f_read+0x20a>
    3a66:	60 c0       	rjmp	.+192    	; 0x3b28 <f_read+0x2ca>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    3a68:	d1 01       	movw	r26, r2
    3a6a:	12 96       	adiw	r26, 0x02	; 2
    3a6c:	2c 91       	ld	r18, X
    3a6e:	d7 01       	movw	r26, r14
    3a70:	c6 01       	movw	r24, r12
    3a72:	84 0f       	add	r24, r20
    3a74:	95 1f       	adc	r25, r21
    3a76:	a6 1f       	adc	r26, r22
    3a78:	b7 1f       	adc	r27, r23
    3a7a:	42 2f       	mov	r20, r18
    3a7c:	50 e0       	ldi	r21, 0x00	; 0
    3a7e:	60 e0       	ldi	r22, 0x00	; 0
    3a80:	70 e0       	ldi	r23, 0x00	; 0
    3a82:	48 17       	cp	r20, r24
    3a84:	59 07       	cpc	r21, r25
    3a86:	6a 07       	cpc	r22, r26
    3a88:	7b 07       	cpc	r23, r27
    3a8a:	48 f4       	brcc	.+18     	; 0x3a9e <f_read+0x240>
					cc = fp->fs->csize - csect;
    3a8c:	82 2f       	mov	r24, r18
    3a8e:	90 e0       	ldi	r25, 0x00	; 0
    3a90:	80 1b       	sub	r24, r16
    3a92:	91 09       	sbc	r25, r1
    3a94:	6c 01       	movw	r12, r24
    3a96:	ee 24       	eor	r14, r14
    3a98:	d7 fc       	sbrc	r13, 7
    3a9a:	e0 94       	com	r14
    3a9c:	fe 2c       	mov	r15, r14
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    3a9e:	f1 01       	movw	r30, r2
    3aa0:	81 81       	ldd	r24, Z+1	; 0x01
    3aa2:	69 81       	ldd	r22, Y+1	; 0x01
    3aa4:	7a 81       	ldd	r23, Y+2	; 0x02
    3aa6:	a5 01       	movw	r20, r10
    3aa8:	94 01       	movw	r18, r8
    3aaa:	0c 2d       	mov	r16, r12
    3aac:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    3ab0:	88 23       	and	r24, r24
    3ab2:	79 f0       	breq	.+30     	; 0x3ad2 <f_read+0x274>
    3ab4:	08 85       	ldd	r16, Y+8	; 0x08
    3ab6:	19 85       	ldd	r17, Y+9	; 0x09
    3ab8:	1c 83       	std	Y+4, r17	; 0x04
    3aba:	0b 83       	std	Y+3, r16	; 0x03
					ABORT(fp->fs, FR_DISK_ERR);
    3abc:	d8 01       	movw	r26, r16
    3abe:	14 96       	adiw	r26, 0x04	; 4
    3ac0:	8c 91       	ld	r24, X
    3ac2:	14 97       	sbiw	r26, 0x04	; 4
    3ac4:	80 68       	ori	r24, 0x80	; 128
    3ac6:	14 96       	adiw	r26, 0x04	; 4
    3ac8:	8c 93       	st	X, r24
    3aca:	14 97       	sbiw	r26, 0x04	; 4
    3acc:	bb 24       	eor	r11, r11
    3ace:	b3 94       	inc	r11
    3ad0:	d6 c0       	rjmp	.+428    	; 0x3c7e <f_read+0x420>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
    3ad2:	e8 85       	ldd	r30, Y+8	; 0x08
    3ad4:	f9 85       	ldd	r31, Y+9	; 0x09
    3ad6:	84 81       	ldd	r24, Z+4	; 0x04
    3ad8:	86 ff       	sbrs	r24, 6
    3ada:	1c c0       	rjmp	.+56     	; 0x3b14 <f_read+0x2b6>
    3adc:	86 89       	ldd	r24, Z+22	; 0x16
    3ade:	97 89       	ldd	r25, Z+23	; 0x17
    3ae0:	a0 8d       	ldd	r26, Z+24	; 0x18
    3ae2:	b1 8d       	ldd	r27, Z+25	; 0x19
    3ae4:	88 19       	sub	r24, r8
    3ae6:	99 09       	sbc	r25, r9
    3ae8:	aa 09       	sbc	r26, r10
    3aea:	bb 09       	sbc	r27, r11
    3aec:	8c 15       	cp	r24, r12
    3aee:	9d 05       	cpc	r25, r13
    3af0:	ae 05       	cpc	r26, r14
    3af2:	bf 05       	cpc	r27, r15
    3af4:	78 f4       	brcc	.+30     	; 0x3b14 <f_read+0x2b6>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
    3af6:	98 2f       	mov	r25, r24
    3af8:	88 27       	eor	r24, r24
    3afa:	99 0f       	add	r25, r25
    3afc:	09 81       	ldd	r16, Y+1	; 0x01
    3afe:	1a 81       	ldd	r17, Y+2	; 0x02
    3b00:	80 0f       	add	r24, r16
    3b02:	91 1f       	adc	r25, r17
    3b04:	6d 81       	ldd	r22, Y+5	; 0x05
    3b06:	7e 81       	ldd	r23, Y+6	; 0x06
    3b08:	20 e0       	ldi	r18, 0x00	; 0
    3b0a:	32 e0       	ldi	r19, 0x02	; 2
    3b0c:	40 e0       	ldi	r20, 0x00	; 0
    3b0e:	50 e0       	ldi	r21, 0x00	; 0
    3b10:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <mem_cpy>
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    3b14:	0b 2e       	mov	r0, r27
    3b16:	b9 e0       	ldi	r27, 0x09	; 9
    3b18:	cc 0c       	add	r12, r12
    3b1a:	dd 1c       	adc	r13, r13
    3b1c:	ee 1c       	adc	r14, r14
    3b1e:	ff 1c       	adc	r15, r15
    3b20:	ba 95       	dec	r27
    3b22:	d1 f7       	brne	.-12     	; 0x3b18 <f_read+0x2ba>
    3b24:	b0 2d       	mov	r27, r0
				continue;
    3b26:	79 c0       	rjmp	.+242    	; 0x3c1a <f_read+0x3bc>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
    3b28:	a8 85       	ldd	r26, Y+8	; 0x08
    3b2a:	b9 85       	ldd	r27, Y+9	; 0x09
    3b2c:	56 96       	adiw	r26, 0x16	; 22
    3b2e:	0d 91       	ld	r16, X+
    3b30:	1d 91       	ld	r17, X+
    3b32:	2d 91       	ld	r18, X+
    3b34:	3c 91       	ld	r19, X
    3b36:	59 97       	sbiw	r26, 0x19	; 25
    3b38:	08 15       	cp	r16, r8
    3b3a:	19 05       	cpc	r17, r9
    3b3c:	2a 05       	cpc	r18, r10
    3b3e:	3b 05       	cpc	r19, r11
    3b40:	d1 f1       	breq	.+116    	; 0x3bb6 <f_read+0x358>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
    3b42:	14 96       	adiw	r26, 0x04	; 4
    3b44:	8c 91       	ld	r24, X
    3b46:	14 97       	sbiw	r26, 0x04	; 4
    3b48:	86 ff       	sbrs	r24, 6
    3b4a:	1f c0       	rjmp	.+62     	; 0x3b8a <f_read+0x32c>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3b4c:	f1 01       	movw	r30, r2
    3b4e:	81 81       	ldd	r24, Z+1	; 0x01
    3b50:	6d 81       	ldd	r22, Y+5	; 0x05
    3b52:	7e 81       	ldd	r23, Y+6	; 0x06
    3b54:	a9 01       	movw	r20, r18
    3b56:	98 01       	movw	r18, r16
    3b58:	01 e0       	ldi	r16, 0x01	; 1
    3b5a:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    3b5e:	88 23       	and	r24, r24
    3b60:	79 f0       	breq	.+30     	; 0x3b80 <f_read+0x322>
    3b62:	08 85       	ldd	r16, Y+8	; 0x08
    3b64:	19 85       	ldd	r17, Y+9	; 0x09
    3b66:	1c 83       	std	Y+4, r17	; 0x04
    3b68:	0b 83       	std	Y+3, r16	; 0x03
						ABORT(fp->fs, FR_DISK_ERR);
    3b6a:	d8 01       	movw	r26, r16
    3b6c:	14 96       	adiw	r26, 0x04	; 4
    3b6e:	8c 91       	ld	r24, X
    3b70:	14 97       	sbiw	r26, 0x04	; 4
    3b72:	80 68       	ori	r24, 0x80	; 128
    3b74:	14 96       	adiw	r26, 0x04	; 4
    3b76:	8c 93       	st	X, r24
    3b78:	14 97       	sbiw	r26, 0x04	; 4
    3b7a:	bb 24       	eor	r11, r11
    3b7c:	b3 94       	inc	r11
    3b7e:	7f c0       	rjmp	.+254    	; 0x3c7e <f_read+0x420>
					fp->flag &= ~FA__DIRTY;
    3b80:	e8 85       	ldd	r30, Y+8	; 0x08
    3b82:	f9 85       	ldd	r31, Y+9	; 0x09
    3b84:	84 81       	ldd	r24, Z+4	; 0x04
    3b86:	8f 7b       	andi	r24, 0xBF	; 191
    3b88:	84 83       	std	Z+4, r24	; 0x04
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    3b8a:	a8 85       	ldd	r26, Y+8	; 0x08
    3b8c:	b9 85       	ldd	r27, Y+9	; 0x09
    3b8e:	ed 91       	ld	r30, X+
    3b90:	fc 91       	ld	r31, X
    3b92:	81 81       	ldd	r24, Z+1	; 0x01
    3b94:	6d 81       	ldd	r22, Y+5	; 0x05
    3b96:	7e 81       	ldd	r23, Y+6	; 0x06
    3b98:	a5 01       	movw	r20, r10
    3b9a:	94 01       	movw	r18, r8
    3b9c:	01 e0       	ldi	r16, 0x01	; 1
    3b9e:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    3ba2:	88 23       	and	r24, r24
    3ba4:	41 f0       	breq	.+16     	; 0x3bb6 <f_read+0x358>
    3ba6:	e8 85       	ldd	r30, Y+8	; 0x08
    3ba8:	f9 85       	ldd	r31, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3baa:	84 81       	ldd	r24, Z+4	; 0x04
    3bac:	80 68       	ori	r24, 0x80	; 128
    3bae:	84 83       	std	Z+4, r24	; 0x04
    3bb0:	bb 24       	eor	r11, r11
    3bb2:	b3 94       	inc	r11
    3bb4:	64 c0       	rjmp	.+200    	; 0x3c7e <f_read+0x420>
			}
#endif
			fp->dsect = sect;
    3bb6:	a8 85       	ldd	r26, Y+8	; 0x08
    3bb8:	b9 85       	ldd	r27, Y+9	; 0x09
    3bba:	56 96       	adiw	r26, 0x16	; 22
    3bbc:	8d 92       	st	X+, r8
    3bbe:	9d 92       	st	X+, r9
    3bc0:	ad 92       	st	X+, r10
    3bc2:	bc 92       	st	X, r11
    3bc4:	59 97       	sbiw	r26, 0x19	; 25
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    3bc6:	e8 85       	ldd	r30, Y+8	; 0x08
    3bc8:	f9 85       	ldd	r31, Y+9	; 0x09
    3bca:	46 81       	ldd	r20, Z+6	; 0x06
    3bcc:	57 81       	ldd	r21, Z+7	; 0x07
    3bce:	60 85       	ldd	r22, Z+8	; 0x08
    3bd0:	71 85       	ldd	r23, Z+9	; 0x09
    3bd2:	db 01       	movw	r26, r22
    3bd4:	ca 01       	movw	r24, r20
    3bd6:	91 70       	andi	r25, 0x01	; 1
    3bd8:	a0 70       	andi	r26, 0x00	; 0
    3bda:	b0 70       	andi	r27, 0x00	; 0
    3bdc:	00 e0       	ldi	r16, 0x00	; 0
    3bde:	12 e0       	ldi	r17, 0x02	; 2
    3be0:	20 e0       	ldi	r18, 0x00	; 0
    3be2:	30 e0       	ldi	r19, 0x00	; 0
    3be4:	08 1b       	sub	r16, r24
    3be6:	19 0b       	sbc	r17, r25
    3be8:	2a 0b       	sbc	r18, r26
    3bea:	3b 0b       	sbc	r19, r27
    3bec:	73 01       	movw	r14, r6
    3bee:	62 01       	movw	r12, r4
    3bf0:	04 15       	cp	r16, r4
    3bf2:	15 05       	cpc	r17, r5
    3bf4:	26 05       	cpc	r18, r6
    3bf6:	37 05       	cpc	r19, r7
    3bf8:	10 f4       	brcc	.+4      	; 0x3bfe <f_read+0x3a0>
    3bfa:	68 01       	movw	r12, r16
    3bfc:	79 01       	movw	r14, r18
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    3bfe:	ba 01       	movw	r22, r20
    3c00:	71 70       	andi	r23, 0x01	; 1
    3c02:	60 5e       	subi	r22, 0xE0	; 224
    3c04:	7f 4f       	sbci	r23, 0xFF	; 255
    3c06:	28 85       	ldd	r18, Y+8	; 0x08
    3c08:	39 85       	ldd	r19, Y+9	; 0x09
    3c0a:	62 0f       	add	r22, r18
    3c0c:	73 1f       	adc	r23, r19
    3c0e:	89 81       	ldd	r24, Y+1	; 0x01
    3c10:	9a 81       	ldd	r25, Y+2	; 0x02
    3c12:	a7 01       	movw	r20, r14
    3c14:	96 01       	movw	r18, r12
    3c16:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <mem_cpy>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    3c1a:	89 81       	ldd	r24, Y+1	; 0x01
    3c1c:	9a 81       	ldd	r25, Y+2	; 0x02
    3c1e:	8c 0d       	add	r24, r12
    3c20:	9d 1d       	adc	r25, r13
    3c22:	9a 83       	std	Y+2, r25	; 0x02
    3c24:	89 83       	std	Y+1, r24	; 0x01
    3c26:	e8 85       	ldd	r30, Y+8	; 0x08
    3c28:	f9 85       	ldd	r31, Y+9	; 0x09
    3c2a:	86 81       	ldd	r24, Z+6	; 0x06
    3c2c:	97 81       	ldd	r25, Z+7	; 0x07
    3c2e:	a0 85       	ldd	r26, Z+8	; 0x08
    3c30:	b1 85       	ldd	r27, Z+9	; 0x09
    3c32:	8c 0d       	add	r24, r12
    3c34:	9d 1d       	adc	r25, r13
    3c36:	ae 1d       	adc	r26, r14
    3c38:	bf 1d       	adc	r27, r15
    3c3a:	86 83       	std	Z+6, r24	; 0x06
    3c3c:	97 83       	std	Z+7, r25	; 0x07
    3c3e:	a0 87       	std	Z+8, r26	; 0x08
    3c40:	b1 87       	std	Z+9, r27	; 0x09
    3c42:	eb 81       	ldd	r30, Y+3	; 0x03
    3c44:	fc 81       	ldd	r31, Y+4	; 0x04
    3c46:	80 81       	ld	r24, Z
    3c48:	91 81       	ldd	r25, Z+1	; 0x01
    3c4a:	a2 81       	ldd	r26, Z+2	; 0x02
    3c4c:	b3 81       	ldd	r27, Z+3	; 0x03
    3c4e:	8c 0d       	add	r24, r12
    3c50:	9d 1d       	adc	r25, r13
    3c52:	ae 1d       	adc	r26, r14
    3c54:	bf 1d       	adc	r27, r15
    3c56:	80 83       	st	Z, r24
    3c58:	91 83       	std	Z+1, r25	; 0x01
    3c5a:	a2 83       	std	Z+2, r26	; 0x02
    3c5c:	b3 83       	std	Z+3, r27	; 0x03
    3c5e:	4c 18       	sub	r4, r12
    3c60:	5d 08       	sbc	r5, r13
    3c62:	6e 08       	sbc	r6, r14
    3c64:	7f 08       	sbc	r7, r15
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    3c66:	09 f0       	breq	.+2      	; 0x3c6a <f_read+0x40c>
    3c68:	5d ce       	rjmp	.-838    	; 0x3924 <f_read+0xc6>
    3c6a:	bf 80       	ldd	r11, Y+7	; 0x07
    3c6c:	08 c0       	rjmp	.+16     	; 0x3c7e <f_read+0x420>
	*br = 0;	/* Clear read byte counter */

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    3c6e:	bb 24       	eor	r11, r11
    3c70:	68 94       	set
    3c72:	b1 f8       	bld	r11, 1
    3c74:	04 c0       	rjmp	.+8      	; 0x3c7e <f_read+0x420>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    3c76:	0f 2e       	mov	r0, r31
    3c78:	f7 e0       	ldi	r31, 0x07	; 7
    3c7a:	bf 2e       	mov	r11, r31
    3c7c:	f0 2d       	mov	r31, r0
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    3c7e:	8b 2d       	mov	r24, r11
    3c80:	29 96       	adiw	r28, 0x09	; 9
    3c82:	0f b6       	in	r0, 0x3f	; 63
    3c84:	f8 94       	cli
    3c86:	de bf       	out	0x3e, r29	; 62
    3c88:	0f be       	out	0x3f, r0	; 63
    3c8a:	cd bf       	out	0x3d, r28	; 61
    3c8c:	df 91       	pop	r29
    3c8e:	cf 91       	pop	r28
    3c90:	1f 91       	pop	r17
    3c92:	0f 91       	pop	r16
    3c94:	ff 90       	pop	r15
    3c96:	ef 90       	pop	r14
    3c98:	df 90       	pop	r13
    3c9a:	cf 90       	pop	r12
    3c9c:	bf 90       	pop	r11
    3c9e:	af 90       	pop	r10
    3ca0:	9f 90       	pop	r9
    3ca2:	8f 90       	pop	r8
    3ca4:	7f 90       	pop	r7
    3ca6:	6f 90       	pop	r6
    3ca8:	5f 90       	pop	r5
    3caa:	4f 90       	pop	r4
    3cac:	3f 90       	pop	r3
    3cae:	2f 90       	pop	r2
    3cb0:	08 95       	ret

00003cb2 <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
    3cb2:	2f 92       	push	r2
    3cb4:	3f 92       	push	r3
    3cb6:	4f 92       	push	r4
    3cb8:	5f 92       	push	r5
    3cba:	6f 92       	push	r6
    3cbc:	7f 92       	push	r7
    3cbe:	8f 92       	push	r8
    3cc0:	9f 92       	push	r9
    3cc2:	af 92       	push	r10
    3cc4:	bf 92       	push	r11
    3cc6:	cf 92       	push	r12
    3cc8:	df 92       	push	r13
    3cca:	ef 92       	push	r14
    3ccc:	ff 92       	push	r15
    3cce:	0f 93       	push	r16
    3cd0:	1f 93       	push	r17
    3cd2:	cf 93       	push	r28
    3cd4:	df 93       	push	r29
    3cd6:	cd b7       	in	r28, 0x3d	; 61
    3cd8:	de b7       	in	r29, 0x3e	; 62
    3cda:	29 97       	sbiw	r28, 0x09	; 9
    3cdc:	0f b6       	in	r0, 0x3f	; 63
    3cde:	f8 94       	cli
    3ce0:	de bf       	out	0x3e, r29	; 62
    3ce2:	0f be       	out	0x3f, r0	; 63
    3ce4:	cd bf       	out	0x3d, r28	; 61
    3ce6:	2c 01       	movw	r4, r24
    3ce8:	c6 2e       	mov	r12, r22
    3cea:	f7 2e       	mov	r15, r23
    3cec:	49 01       	movw	r8, r18
    3cee:	5a 01       	movw	r10, r20
    3cf0:	1a 83       	std	Y+2, r17	; 0x02
    3cf2:	09 83       	std	Y+1, r16	; 0x01
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
    3cf4:	d8 01       	movw	r26, r16
    3cf6:	1d 92       	st	X+, r1
    3cf8:	1d 92       	st	X+, r1
    3cfa:	1d 92       	st	X+, r1
    3cfc:	1c 92       	st	X, r1
    3cfe:	13 97       	sbiw	r26, 0x03	; 3

	res = validate(fp);						/* Check validity */
    3d00:	0e 94 c7 0b 	call	0x178e	; 0x178e <validate>
    3d04:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3d06:	88 23       	and	r24, r24
    3d08:	09 f0       	breq	.+2      	; 0x3d0c <f_write+0x5a>
    3d0a:	17 c2       	rjmp	.+1070   	; 0x413a <f_write+0x488>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
    3d0c:	f2 01       	movw	r30, r4
    3d0e:	84 81       	ldd	r24, Z+4	; 0x04
    3d10:	88 23       	and	r24, r24
    3d12:	0c f4       	brge	.+2      	; 0x3d16 <f_write+0x64>
    3d14:	0f c2       	rjmp	.+1054   	; 0x4134 <f_write+0x482>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    3d16:	81 ff       	sbrs	r24, 1
    3d18:	0f c2       	rjmp	.+1054   	; 0x4138 <f_write+0x486>
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
    3d1a:	82 85       	ldd	r24, Z+10	; 0x0a
    3d1c:	93 85       	ldd	r25, Z+11	; 0x0b
    3d1e:	a4 85       	ldd	r26, Z+12	; 0x0c
    3d20:	b5 85       	ldd	r27, Z+13	; 0x0d
    3d22:	b5 01       	movw	r22, r10
    3d24:	a4 01       	movw	r20, r8
    3d26:	48 0f       	add	r20, r24
    3d28:	59 1f       	adc	r21, r25
    3d2a:	6a 1f       	adc	r22, r26
    3d2c:	7b 1f       	adc	r23, r27
    3d2e:	48 17       	cp	r20, r24
    3d30:	59 07       	cpc	r21, r25
    3d32:	6a 07       	cpc	r22, r26
    3d34:	7b 07       	cpc	r23, r27
    3d36:	08 f4       	brcc	.+2      	; 0x3d3a <f_write+0x88>
    3d38:	e2 c1       	rjmp	.+964    	; 0x40fe <f_write+0x44c>

	for ( ;  btw;							/* Repeat until all data written */
    3d3a:	81 14       	cp	r8, r1
    3d3c:	91 04       	cpc	r9, r1
    3d3e:	a1 04       	cpc	r10, r1
    3d40:	b1 04       	cpc	r11, r1
    3d42:	09 f4       	brne	.+2      	; 0x3d46 <f_write+0x94>
    3d44:	dc c1       	rjmp	.+952    	; 0x40fe <f_write+0x44c>
    3d46:	cb 82       	std	Y+3, r12	; 0x03
    3d48:	fc 82       	std	Y+4, r15	; 0x04
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    3d4a:	92 01       	movw	r18, r4
    3d4c:	20 5e       	subi	r18, 0xE0	; 224
    3d4e:	3f 4f       	sbci	r19, 0xFF	; 255
    3d50:	3e 83       	std	Y+6, r19	; 0x06
    3d52:	2d 83       	std	Y+5, r18	; 0x05
    3d54:	1f 83       	std	Y+7, r17	; 0x07
    3d56:	59 86       	std	Y+9, r5	; 0x09
    3d58:	48 86       	std	Y+8, r4	; 0x08
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    3d5a:	a8 85       	ldd	r26, Y+8	; 0x08
    3d5c:	b9 85       	ldd	r27, Y+9	; 0x09
    3d5e:	16 96       	adiw	r26, 0x06	; 6
    3d60:	4d 91       	ld	r20, X+
    3d62:	5d 91       	ld	r21, X+
    3d64:	6d 91       	ld	r22, X+
    3d66:	7c 91       	ld	r23, X
    3d68:	19 97       	sbiw	r26, 0x09	; 9
    3d6a:	db 01       	movw	r26, r22
    3d6c:	ca 01       	movw	r24, r20
    3d6e:	91 70       	andi	r25, 0x01	; 1
    3d70:	a0 70       	andi	r26, 0x00	; 0
    3d72:	b0 70       	andi	r27, 0x00	; 0
    3d74:	00 97       	sbiw	r24, 0x00	; 0
    3d76:	a1 05       	cpc	r26, r1
    3d78:	b1 05       	cpc	r27, r1
    3d7a:	09 f0       	breq	.+2      	; 0x3d7e <f_write+0xcc>
    3d7c:	60 c1       	rjmp	.+704    	; 0x403e <f_write+0x38c>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    3d7e:	e8 85       	ldd	r30, Y+8	; 0x08
    3d80:	f9 85       	ldd	r31, Y+9	; 0x09
    3d82:	20 81       	ld	r18, Z
    3d84:	31 81       	ldd	r19, Z+1	; 0x01
    3d86:	db 01       	movw	r26, r22
    3d88:	ca 01       	movw	r24, r20
    3d8a:	07 2e       	mov	r0, r23
    3d8c:	79 e0       	ldi	r23, 0x09	; 9
    3d8e:	b6 95       	lsr	r27
    3d90:	a7 95       	ror	r26
    3d92:	97 95       	ror	r25
    3d94:	87 95       	ror	r24
    3d96:	7a 95       	dec	r23
    3d98:	d1 f7       	brne	.-12     	; 0x3d8e <f_write+0xdc>
    3d9a:	70 2d       	mov	r23, r0
    3d9c:	f9 01       	movw	r30, r18
    3d9e:	12 81       	ldd	r17, Z+2	; 0x02
    3da0:	11 50       	subi	r17, 0x01	; 1
    3da2:	18 23       	and	r17, r24
			if (!csect) {					/* On the cluster boundary? */
    3da4:	09 f0       	breq	.+2      	; 0x3da8 <f_write+0xf6>
    3da6:	57 c0       	rjmp	.+174    	; 0x3e56 <f_write+0x1a4>
				if (fp->fptr == 0) {		/* On the top of the file? */
    3da8:	41 15       	cp	r20, r1
    3daa:	51 05       	cpc	r21, r1
    3dac:	61 05       	cpc	r22, r1
    3dae:	71 05       	cpc	r23, r1
    3db0:	c9 f4       	brne	.+50     	; 0x3de4 <f_write+0x132>
					clst = fp->sclust;		/* Follow from the origin */
    3db2:	e8 85       	ldd	r30, Y+8	; 0x08
    3db4:	f9 85       	ldd	r31, Y+9	; 0x09
    3db6:	86 85       	ldd	r24, Z+14	; 0x0e
    3db8:	97 85       	ldd	r25, Z+15	; 0x0f
    3dba:	a0 89       	ldd	r26, Z+16	; 0x10
    3dbc:	b1 89       	ldd	r27, Z+17	; 0x11
					if (clst == 0)			/* When no cluster is allocated, */
    3dbe:	00 97       	sbiw	r24, 0x00	; 0
    3dc0:	a1 05       	cpc	r26, r1
    3dc2:	b1 05       	cpc	r27, r1
    3dc4:	09 f5       	brne	.+66     	; 0x3e08 <f_write+0x156>
						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    3dc6:	c9 01       	movw	r24, r18
    3dc8:	40 e0       	ldi	r20, 0x00	; 0
    3dca:	50 e0       	ldi	r21, 0x00	; 0
    3dcc:	ba 01       	movw	r22, r20
    3dce:	0e 94 4a 15 	call	0x2a94	; 0x2a94 <create_chain>
    3dd2:	dc 01       	movw	r26, r24
    3dd4:	cb 01       	movw	r24, r22
    3dd6:	e8 85       	ldd	r30, Y+8	; 0x08
    3dd8:	f9 85       	ldd	r31, Y+9	; 0x09
    3dda:	86 87       	std	Z+14, r24	; 0x0e
    3ddc:	97 87       	std	Z+15, r25	; 0x0f
    3dde:	a0 8b       	std	Z+16, r26	; 0x10
    3de0:	b1 8b       	std	Z+17, r27	; 0x11
    3de2:	0d c0       	rjmp	.+26     	; 0x3dfe <f_write+0x14c>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    3de4:	a8 85       	ldd	r26, Y+8	; 0x08
    3de6:	b9 85       	ldd	r27, Y+9	; 0x09
    3de8:	52 96       	adiw	r26, 0x12	; 18
    3dea:	4d 91       	ld	r20, X+
    3dec:	5d 91       	ld	r21, X+
    3dee:	6d 91       	ld	r22, X+
    3df0:	7c 91       	ld	r23, X
    3df2:	55 97       	sbiw	r26, 0x15	; 21
    3df4:	c9 01       	movw	r24, r18
    3df6:	0e 94 4a 15 	call	0x2a94	; 0x2a94 <create_chain>
    3dfa:	dc 01       	movw	r26, r24
    3dfc:	cb 01       	movw	r24, r22
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    3dfe:	00 97       	sbiw	r24, 0x00	; 0
    3e00:	a1 05       	cpc	r26, r1
    3e02:	b1 05       	cpc	r27, r1
    3e04:	09 f4       	brne	.+2      	; 0x3e08 <f_write+0x156>
    3e06:	78 c1       	rjmp	.+752    	; 0x40f8 <f_write+0x446>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    3e08:	81 30       	cpi	r24, 0x01	; 1
    3e0a:	91 05       	cpc	r25, r1
    3e0c:	a1 05       	cpc	r26, r1
    3e0e:	b1 05       	cpc	r27, r1
    3e10:	41 f4       	brne	.+16     	; 0x3e22 <f_write+0x170>
    3e12:	48 84       	ldd	r4, Y+8	; 0x08
    3e14:	59 84       	ldd	r5, Y+9	; 0x09
    3e16:	f2 01       	movw	r30, r4
    3e18:	84 81       	ldd	r24, Z+4	; 0x04
    3e1a:	80 68       	ori	r24, 0x80	; 128
    3e1c:	84 83       	std	Z+4, r24	; 0x04
    3e1e:	12 e0       	ldi	r17, 0x02	; 2
    3e20:	8c c1       	rjmp	.+792    	; 0x413a <f_write+0x488>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3e22:	8f 3f       	cpi	r24, 0xFF	; 255
    3e24:	ff ef       	ldi	r31, 0xFF	; 255
    3e26:	9f 07       	cpc	r25, r31
    3e28:	ff ef       	ldi	r31, 0xFF	; 255
    3e2a:	af 07       	cpc	r26, r31
    3e2c:	ff ef       	ldi	r31, 0xFF	; 255
    3e2e:	bf 07       	cpc	r27, r31
    3e30:	61 f4       	brne	.+24     	; 0x3e4a <f_write+0x198>
    3e32:	48 84       	ldd	r4, Y+8	; 0x08
    3e34:	59 84       	ldd	r5, Y+9	; 0x09
    3e36:	d2 01       	movw	r26, r4
    3e38:	14 96       	adiw	r26, 0x04	; 4
    3e3a:	8c 91       	ld	r24, X
    3e3c:	14 97       	sbiw	r26, 0x04	; 4
    3e3e:	80 68       	ori	r24, 0x80	; 128
    3e40:	14 96       	adiw	r26, 0x04	; 4
    3e42:	8c 93       	st	X, r24
    3e44:	14 97       	sbiw	r26, 0x04	; 4
    3e46:	11 e0       	ldi	r17, 0x01	; 1
    3e48:	78 c1       	rjmp	.+752    	; 0x413a <f_write+0x488>
				fp->clust = clst;			/* Update current cluster */
    3e4a:	e8 85       	ldd	r30, Y+8	; 0x08
    3e4c:	f9 85       	ldd	r31, Y+9	; 0x09
    3e4e:	82 8b       	std	Z+18, r24	; 0x12
    3e50:	93 8b       	std	Z+19, r25	; 0x13
    3e52:	a4 8b       	std	Z+20, r26	; 0x14
    3e54:	b5 8b       	std	Z+21, r27	; 0x15
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
    3e56:	a8 85       	ldd	r26, Y+8	; 0x08
    3e58:	b9 85       	ldd	r27, Y+9	; 0x09
    3e5a:	14 96       	adiw	r26, 0x04	; 4
    3e5c:	8c 91       	ld	r24, X
    3e5e:	14 97       	sbiw	r26, 0x04	; 4
    3e60:	86 ff       	sbrs	r24, 6
    3e62:	21 c0       	rjmp	.+66     	; 0x3ea6 <f_write+0x1f4>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3e64:	ed 91       	ld	r30, X+
    3e66:	fc 91       	ld	r31, X
    3e68:	11 97       	sbiw	r26, 0x01	; 1
    3e6a:	56 96       	adiw	r26, 0x16	; 22
    3e6c:	2d 91       	ld	r18, X+
    3e6e:	3d 91       	ld	r19, X+
    3e70:	4d 91       	ld	r20, X+
    3e72:	5c 91       	ld	r21, X
    3e74:	59 97       	sbiw	r26, 0x19	; 25
    3e76:	81 81       	ldd	r24, Z+1	; 0x01
    3e78:	6d 81       	ldd	r22, Y+5	; 0x05
    3e7a:	7e 81       	ldd	r23, Y+6	; 0x06
    3e7c:	01 e0       	ldi	r16, 0x01	; 1
    3e7e:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    3e82:	88 23       	and	r24, r24
    3e84:	41 f0       	breq	.+16     	; 0x3e96 <f_write+0x1e4>
    3e86:	48 84       	ldd	r4, Y+8	; 0x08
    3e88:	59 84       	ldd	r5, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3e8a:	f2 01       	movw	r30, r4
    3e8c:	84 81       	ldd	r24, Z+4	; 0x04
    3e8e:	80 68       	ori	r24, 0x80	; 128
    3e90:	84 83       	std	Z+4, r24	; 0x04
    3e92:	11 e0       	ldi	r17, 0x01	; 1
    3e94:	52 c1       	rjmp	.+676    	; 0x413a <f_write+0x488>
				fp->flag &= ~FA__DIRTY;
    3e96:	a8 85       	ldd	r26, Y+8	; 0x08
    3e98:	b9 85       	ldd	r27, Y+9	; 0x09
    3e9a:	14 96       	adiw	r26, 0x04	; 4
    3e9c:	8c 91       	ld	r24, X
    3e9e:	14 97       	sbiw	r26, 0x04	; 4
    3ea0:	8f 7b       	andi	r24, 0xBF	; 191
    3ea2:	14 96       	adiw	r26, 0x04	; 4
    3ea4:	8c 93       	st	X, r24
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    3ea6:	e8 85       	ldd	r30, Y+8	; 0x08
    3ea8:	f9 85       	ldd	r31, Y+9	; 0x09
    3eaa:	20 80       	ld	r2, Z
    3eac:	31 80       	ldd	r3, Z+1	; 0x01
    3eae:	42 89       	ldd	r20, Z+18	; 0x12
    3eb0:	53 89       	ldd	r21, Z+19	; 0x13
    3eb2:	64 89       	ldd	r22, Z+20	; 0x14
    3eb4:	75 89       	ldd	r23, Z+21	; 0x15
    3eb6:	c1 01       	movw	r24, r2
    3eb8:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <clust2sect>
    3ebc:	dc 01       	movw	r26, r24
    3ebe:	cb 01       	movw	r24, r22
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    3ec0:	00 97       	sbiw	r24, 0x00	; 0
    3ec2:	a1 05       	cpc	r26, r1
    3ec4:	b1 05       	cpc	r27, r1
    3ec6:	61 f4       	brne	.+24     	; 0x3ee0 <f_write+0x22e>
    3ec8:	48 84       	ldd	r4, Y+8	; 0x08
    3eca:	59 84       	ldd	r5, Y+9	; 0x09
    3ecc:	d2 01       	movw	r26, r4
    3ece:	14 96       	adiw	r26, 0x04	; 4
    3ed0:	8c 91       	ld	r24, X
    3ed2:	14 97       	sbiw	r26, 0x04	; 4
    3ed4:	80 68       	ori	r24, 0x80	; 128
    3ed6:	14 96       	adiw	r26, 0x04	; 4
    3ed8:	8c 93       	st	X, r24
    3eda:	14 97       	sbiw	r26, 0x04	; 4
    3edc:	12 e0       	ldi	r17, 0x02	; 2
    3ede:	2d c1       	rjmp	.+602    	; 0x413a <f_write+0x488>
			sect += csect;
    3ee0:	41 2f       	mov	r20, r17
    3ee2:	50 e0       	ldi	r21, 0x00	; 0
    3ee4:	60 e0       	ldi	r22, 0x00	; 0
    3ee6:	70 e0       	ldi	r23, 0x00	; 0
    3ee8:	2c 01       	movw	r4, r24
    3eea:	3d 01       	movw	r6, r26
    3eec:	44 0e       	add	r4, r20
    3eee:	55 1e       	adc	r5, r21
    3ef0:	66 1e       	adc	r6, r22
    3ef2:	77 1e       	adc	r7, r23
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    3ef4:	75 01       	movw	r14, r10
    3ef6:	64 01       	movw	r12, r8
    3ef8:	0b 2e       	mov	r0, r27
    3efa:	b9 e0       	ldi	r27, 0x09	; 9
    3efc:	f6 94       	lsr	r15
    3efe:	e7 94       	ror	r14
    3f00:	d7 94       	ror	r13
    3f02:	c7 94       	ror	r12
    3f04:	ba 95       	dec	r27
    3f06:	d1 f7       	brne	.-12     	; 0x3efc <f_write+0x24a>
    3f08:	b0 2d       	mov	r27, r0
			if (cc) {						/* Write maximum contiguous sectors directly */
    3f0a:	c1 14       	cp	r12, r1
    3f0c:	d1 04       	cpc	r13, r1
    3f0e:	e1 04       	cpc	r14, r1
    3f10:	f1 04       	cpc	r15, r1
    3f12:	09 f4       	brne	.+2      	; 0x3f16 <f_write+0x264>
    3f14:	60 c0       	rjmp	.+192    	; 0x3fd6 <f_write+0x324>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    3f16:	f1 01       	movw	r30, r2
    3f18:	22 81       	ldd	r18, Z+2	; 0x02
    3f1a:	d7 01       	movw	r26, r14
    3f1c:	c6 01       	movw	r24, r12
    3f1e:	84 0f       	add	r24, r20
    3f20:	95 1f       	adc	r25, r21
    3f22:	a6 1f       	adc	r26, r22
    3f24:	b7 1f       	adc	r27, r23
    3f26:	42 2f       	mov	r20, r18
    3f28:	50 e0       	ldi	r21, 0x00	; 0
    3f2a:	60 e0       	ldi	r22, 0x00	; 0
    3f2c:	70 e0       	ldi	r23, 0x00	; 0
    3f2e:	48 17       	cp	r20, r24
    3f30:	59 07       	cpc	r21, r25
    3f32:	6a 07       	cpc	r22, r26
    3f34:	7b 07       	cpc	r23, r27
    3f36:	48 f4       	brcc	.+18     	; 0x3f4a <f_write+0x298>
					cc = fp->fs->csize - csect;
    3f38:	82 2f       	mov	r24, r18
    3f3a:	90 e0       	ldi	r25, 0x00	; 0
    3f3c:	81 1b       	sub	r24, r17
    3f3e:	91 09       	sbc	r25, r1
    3f40:	6c 01       	movw	r12, r24
    3f42:	ee 24       	eor	r14, r14
    3f44:	d7 fc       	sbrc	r13, 7
    3f46:	e0 94       	com	r14
    3f48:	fe 2c       	mov	r15, r14
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
    3f4a:	d1 01       	movw	r26, r2
    3f4c:	11 96       	adiw	r26, 0x01	; 1
    3f4e:	8c 91       	ld	r24, X
    3f50:	6b 81       	ldd	r22, Y+3	; 0x03
    3f52:	7c 81       	ldd	r23, Y+4	; 0x04
    3f54:	a3 01       	movw	r20, r6
    3f56:	92 01       	movw	r18, r4
    3f58:	0c 2d       	mov	r16, r12
    3f5a:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    3f5e:	88 23       	and	r24, r24
    3f60:	41 f0       	breq	.+16     	; 0x3f72 <f_write+0x2c0>
    3f62:	48 84       	ldd	r4, Y+8	; 0x08
    3f64:	59 84       	ldd	r5, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3f66:	f2 01       	movw	r30, r4
    3f68:	84 81       	ldd	r24, Z+4	; 0x04
    3f6a:	80 68       	ori	r24, 0x80	; 128
    3f6c:	84 83       	std	Z+4, r24	; 0x04
    3f6e:	11 e0       	ldi	r17, 0x01	; 1
    3f70:	e4 c0       	rjmp	.+456    	; 0x413a <f_write+0x488>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
    3f72:	e8 85       	ldd	r30, Y+8	; 0x08
    3f74:	f9 85       	ldd	r31, Y+9	; 0x09
    3f76:	86 89       	ldd	r24, Z+22	; 0x16
    3f78:	97 89       	ldd	r25, Z+23	; 0x17
    3f7a:	a0 8d       	ldd	r26, Z+24	; 0x18
    3f7c:	b1 8d       	ldd	r27, Z+25	; 0x19
    3f7e:	84 19       	sub	r24, r4
    3f80:	95 09       	sbc	r25, r5
    3f82:	a6 09       	sbc	r26, r6
    3f84:	b7 09       	sbc	r27, r7
    3f86:	8c 15       	cp	r24, r12
    3f88:	9d 05       	cpc	r25, r13
    3f8a:	ae 05       	cpc	r26, r14
    3f8c:	bf 05       	cpc	r27, r15
    3f8e:	c8 f4       	brcc	.+50     	; 0x3fc2 <f_write+0x310>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
    3f90:	bc 01       	movw	r22, r24
    3f92:	76 2f       	mov	r23, r22
    3f94:	66 27       	eor	r22, r22
    3f96:	77 0f       	add	r23, r23
    3f98:	0b 81       	ldd	r16, Y+3	; 0x03
    3f9a:	1c 81       	ldd	r17, Y+4	; 0x04
    3f9c:	60 0f       	add	r22, r16
    3f9e:	71 1f       	adc	r23, r17
    3fa0:	8d 81       	ldd	r24, Y+5	; 0x05
    3fa2:	9e 81       	ldd	r25, Y+6	; 0x06
    3fa4:	20 e0       	ldi	r18, 0x00	; 0
    3fa6:	32 e0       	ldi	r19, 0x02	; 2
    3fa8:	40 e0       	ldi	r20, 0x00	; 0
    3faa:	50 e0       	ldi	r21, 0x00	; 0
    3fac:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <mem_cpy>
					fp->flag &= ~FA__DIRTY;
    3fb0:	a8 85       	ldd	r26, Y+8	; 0x08
    3fb2:	b9 85       	ldd	r27, Y+9	; 0x09
    3fb4:	14 96       	adiw	r26, 0x04	; 4
    3fb6:	8c 91       	ld	r24, X
    3fb8:	14 97       	sbiw	r26, 0x04	; 4
    3fba:	8f 7b       	andi	r24, 0xBF	; 191
    3fbc:	14 96       	adiw	r26, 0x04	; 4
    3fbe:	8c 93       	st	X, r24
    3fc0:	14 97       	sbiw	r26, 0x04	; 4
				}
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    3fc2:	0b 2e       	mov	r0, r27
    3fc4:	b9 e0       	ldi	r27, 0x09	; 9
    3fc6:	cc 0c       	add	r12, r12
    3fc8:	dd 1c       	adc	r13, r13
    3fca:	ee 1c       	adc	r14, r14
    3fcc:	ff 1c       	adc	r15, r15
    3fce:	ba 95       	dec	r27
    3fd0:	d1 f7       	brne	.-12     	; 0x3fc6 <f_write+0x314>
    3fd2:	b0 2d       	mov	r27, r0
				continue;
    3fd4:	65 c0       	rjmp	.+202    	; 0x40a0 <f_write+0x3ee>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
    3fd6:	e8 85       	ldd	r30, Y+8	; 0x08
    3fd8:	f9 85       	ldd	r31, Y+9	; 0x09
    3fda:	86 89       	ldd	r24, Z+22	; 0x16
    3fdc:	97 89       	ldd	r25, Z+23	; 0x17
    3fde:	a0 8d       	ldd	r26, Z+24	; 0x18
    3fe0:	b1 8d       	ldd	r27, Z+25	; 0x19
    3fe2:	84 15       	cp	r24, r4
    3fe4:	95 05       	cpc	r25, r5
    3fe6:	a6 05       	cpc	r26, r6
    3fe8:	b7 05       	cpc	r27, r7
    3fea:	09 f1       	breq	.+66     	; 0x402e <f_write+0x37c>
				if (fp->fptr < fp->fsize &&
    3fec:	86 81       	ldd	r24, Z+6	; 0x06
    3fee:	97 81       	ldd	r25, Z+7	; 0x07
    3ff0:	a0 85       	ldd	r26, Z+8	; 0x08
    3ff2:	b1 85       	ldd	r27, Z+9	; 0x09
    3ff4:	42 85       	ldd	r20, Z+10	; 0x0a
    3ff6:	53 85       	ldd	r21, Z+11	; 0x0b
    3ff8:	64 85       	ldd	r22, Z+12	; 0x0c
    3ffa:	75 85       	ldd	r23, Z+13	; 0x0d
    3ffc:	84 17       	cp	r24, r20
    3ffe:	95 07       	cpc	r25, r21
    4000:	a6 07       	cpc	r26, r22
    4002:	b7 07       	cpc	r27, r23
    4004:	a0 f4       	brcc	.+40     	; 0x402e <f_write+0x37c>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    4006:	d1 01       	movw	r26, r2
    4008:	11 96       	adiw	r26, 0x01	; 1
    400a:	8c 91       	ld	r24, X
    400c:	6d 81       	ldd	r22, Y+5	; 0x05
    400e:	7e 81       	ldd	r23, Y+6	; 0x06
    4010:	a3 01       	movw	r20, r6
    4012:	92 01       	movw	r18, r4
    4014:	01 e0       	ldi	r16, 0x01	; 1
    4016:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
    401a:	88 23       	and	r24, r24
    401c:	41 f0       	breq	.+16     	; 0x402e <f_write+0x37c>
    401e:	48 84       	ldd	r4, Y+8	; 0x08
    4020:	59 84       	ldd	r5, Y+9	; 0x09
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
    4022:	f2 01       	movw	r30, r4
    4024:	84 81       	ldd	r24, Z+4	; 0x04
    4026:	80 68       	ori	r24, 0x80	; 128
    4028:	84 83       	std	Z+4, r24	; 0x04
    402a:	11 e0       	ldi	r17, 0x01	; 1
    402c:	86 c0       	rjmp	.+268    	; 0x413a <f_write+0x488>
			}
#endif
			fp->dsect = sect;
    402e:	a8 85       	ldd	r26, Y+8	; 0x08
    4030:	b9 85       	ldd	r27, Y+9	; 0x09
    4032:	56 96       	adiw	r26, 0x16	; 22
    4034:	4d 92       	st	X+, r4
    4036:	5d 92       	st	X+, r5
    4038:	6d 92       	st	X+, r6
    403a:	7c 92       	st	X, r7
    403c:	59 97       	sbiw	r26, 0x19	; 25
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    403e:	e8 85       	ldd	r30, Y+8	; 0x08
    4040:	f9 85       	ldd	r31, Y+9	; 0x09
    4042:	46 81       	ldd	r20, Z+6	; 0x06
    4044:	57 81       	ldd	r21, Z+7	; 0x07
    4046:	60 85       	ldd	r22, Z+8	; 0x08
    4048:	71 85       	ldd	r23, Z+9	; 0x09
    404a:	db 01       	movw	r26, r22
    404c:	ca 01       	movw	r24, r20
    404e:	91 70       	andi	r25, 0x01	; 1
    4050:	a0 70       	andi	r26, 0x00	; 0
    4052:	b0 70       	andi	r27, 0x00	; 0
    4054:	00 e0       	ldi	r16, 0x00	; 0
    4056:	12 e0       	ldi	r17, 0x02	; 2
    4058:	20 e0       	ldi	r18, 0x00	; 0
    405a:	30 e0       	ldi	r19, 0x00	; 0
    405c:	08 1b       	sub	r16, r24
    405e:	19 0b       	sbc	r17, r25
    4060:	2a 0b       	sbc	r18, r26
    4062:	3b 0b       	sbc	r19, r27
    4064:	75 01       	movw	r14, r10
    4066:	64 01       	movw	r12, r8
    4068:	08 15       	cp	r16, r8
    406a:	19 05       	cpc	r17, r9
    406c:	2a 05       	cpc	r18, r10
    406e:	3b 05       	cpc	r19, r11
    4070:	10 f4       	brcc	.+4      	; 0x4076 <f_write+0x3c4>
    4072:	68 01       	movw	r12, r16
    4074:	79 01       	movw	r14, r18
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    4076:	ca 01       	movw	r24, r20
    4078:	91 70       	andi	r25, 0x01	; 1
    407a:	80 96       	adiw	r24, 0x20	; 32
    407c:	28 85       	ldd	r18, Y+8	; 0x08
    407e:	39 85       	ldd	r19, Y+9	; 0x09
    4080:	82 0f       	add	r24, r18
    4082:	93 1f       	adc	r25, r19
    4084:	6b 81       	ldd	r22, Y+3	; 0x03
    4086:	7c 81       	ldd	r23, Y+4	; 0x04
    4088:	a7 01       	movw	r20, r14
    408a:	96 01       	movw	r18, r12
    408c:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <mem_cpy>
		fp->flag |= FA__DIRTY;
    4090:	a8 85       	ldd	r26, Y+8	; 0x08
    4092:	b9 85       	ldd	r27, Y+9	; 0x09
    4094:	14 96       	adiw	r26, 0x04	; 4
    4096:	8c 91       	ld	r24, X
    4098:	14 97       	sbiw	r26, 0x04	; 4
    409a:	80 64       	ori	r24, 0x40	; 64
    409c:	14 96       	adiw	r26, 0x04	; 4
    409e:	8c 93       	st	X, r24
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    40a0:	eb 81       	ldd	r30, Y+3	; 0x03
    40a2:	fc 81       	ldd	r31, Y+4	; 0x04
    40a4:	ec 0d       	add	r30, r12
    40a6:	fd 1d       	adc	r31, r13
    40a8:	fc 83       	std	Y+4, r31	; 0x04
    40aa:	eb 83       	std	Y+3, r30	; 0x03
    40ac:	e8 85       	ldd	r30, Y+8	; 0x08
    40ae:	f9 85       	ldd	r31, Y+9	; 0x09
    40b0:	86 81       	ldd	r24, Z+6	; 0x06
    40b2:	97 81       	ldd	r25, Z+7	; 0x07
    40b4:	a0 85       	ldd	r26, Z+8	; 0x08
    40b6:	b1 85       	ldd	r27, Z+9	; 0x09
    40b8:	8c 0d       	add	r24, r12
    40ba:	9d 1d       	adc	r25, r13
    40bc:	ae 1d       	adc	r26, r14
    40be:	bf 1d       	adc	r27, r15
    40c0:	86 83       	std	Z+6, r24	; 0x06
    40c2:	97 83       	std	Z+7, r25	; 0x07
    40c4:	a0 87       	std	Z+8, r26	; 0x08
    40c6:	b1 87       	std	Z+9, r27	; 0x09
    40c8:	e9 81       	ldd	r30, Y+1	; 0x01
    40ca:	fa 81       	ldd	r31, Y+2	; 0x02
    40cc:	80 81       	ld	r24, Z
    40ce:	91 81       	ldd	r25, Z+1	; 0x01
    40d0:	a2 81       	ldd	r26, Z+2	; 0x02
    40d2:	b3 81       	ldd	r27, Z+3	; 0x03
    40d4:	8c 0d       	add	r24, r12
    40d6:	9d 1d       	adc	r25, r13
    40d8:	ae 1d       	adc	r26, r14
    40da:	bf 1d       	adc	r27, r15
    40dc:	80 83       	st	Z, r24
    40de:	91 83       	std	Z+1, r25	; 0x01
    40e0:	a2 83       	std	Z+2, r26	; 0x02
    40e2:	b3 83       	std	Z+3, r27	; 0x03
    40e4:	8c 18       	sub	r8, r12
    40e6:	9d 08       	sbc	r9, r13
    40e8:	ae 08       	sbc	r10, r14
    40ea:	bf 08       	sbc	r11, r15
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
    40ec:	09 f0       	breq	.+2      	; 0x40f0 <f_write+0x43e>
    40ee:	35 ce       	rjmp	.-918    	; 0x3d5a <f_write+0xa8>
    40f0:	1f 81       	ldd	r17, Y+7	; 0x07
    40f2:	48 84       	ldd	r4, Y+8	; 0x08
    40f4:	59 84       	ldd	r5, Y+9	; 0x09
    40f6:	03 c0       	rjmp	.+6      	; 0x40fe <f_write+0x44c>
    40f8:	1f 81       	ldd	r17, Y+7	; 0x07
    40fa:	48 84       	ldd	r4, Y+8	; 0x08
    40fc:	59 84       	ldd	r5, Y+9	; 0x09
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    40fe:	f2 01       	movw	r30, r4
    4100:	86 81       	ldd	r24, Z+6	; 0x06
    4102:	97 81       	ldd	r25, Z+7	; 0x07
    4104:	a0 85       	ldd	r26, Z+8	; 0x08
    4106:	b1 85       	ldd	r27, Z+9	; 0x09
    4108:	42 85       	ldd	r20, Z+10	; 0x0a
    410a:	53 85       	ldd	r21, Z+11	; 0x0b
    410c:	64 85       	ldd	r22, Z+12	; 0x0c
    410e:	75 85       	ldd	r23, Z+13	; 0x0d
    4110:	48 17       	cp	r20, r24
    4112:	59 07       	cpc	r21, r25
    4114:	6a 07       	cpc	r22, r26
    4116:	7b 07       	cpc	r23, r27
    4118:	20 f4       	brcc	.+8      	; 0x4122 <f_write+0x470>
    411a:	82 87       	std	Z+10, r24	; 0x0a
    411c:	93 87       	std	Z+11, r25	; 0x0b
    411e:	a4 87       	std	Z+12, r26	; 0x0c
    4120:	b5 87       	std	Z+13, r27	; 0x0d
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    4122:	d2 01       	movw	r26, r4
    4124:	14 96       	adiw	r26, 0x04	; 4
    4126:	8c 91       	ld	r24, X
    4128:	14 97       	sbiw	r26, 0x04	; 4
    412a:	80 62       	ori	r24, 0x20	; 32
    412c:	14 96       	adiw	r26, 0x04	; 4
    412e:	8c 93       	st	X, r24
    4130:	14 97       	sbiw	r26, 0x04	; 4

	LEAVE_FF(fp->fs, FR_OK);
    4132:	03 c0       	rjmp	.+6      	; 0x413a <f_write+0x488>
	*bw = 0;	/* Clear write byte counter */

	res = validate(fp);						/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)				/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    4134:	12 e0       	ldi	r17, 0x02	; 2
    4136:	01 c0       	rjmp	.+2      	; 0x413a <f_write+0x488>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    4138:	17 e0       	ldi	r17, 0x07	; 7

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
    413a:	81 2f       	mov	r24, r17
    413c:	29 96       	adiw	r28, 0x09	; 9
    413e:	0f b6       	in	r0, 0x3f	; 63
    4140:	f8 94       	cli
    4142:	de bf       	out	0x3e, r29	; 62
    4144:	0f be       	out	0x3f, r0	; 63
    4146:	cd bf       	out	0x3d, r28	; 61
    4148:	df 91       	pop	r29
    414a:	cf 91       	pop	r28
    414c:	1f 91       	pop	r17
    414e:	0f 91       	pop	r16
    4150:	ff 90       	pop	r15
    4152:	ef 90       	pop	r14
    4154:	df 90       	pop	r13
    4156:	cf 90       	pop	r12
    4158:	bf 90       	pop	r11
    415a:	af 90       	pop	r10
    415c:	9f 90       	pop	r9
    415e:	8f 90       	pop	r8
    4160:	7f 90       	pop	r7
    4162:	6f 90       	pop	r6
    4164:	5f 90       	pop	r5
    4166:	4f 90       	pop	r4
    4168:	3f 90       	pop	r3
    416a:	2f 90       	pop	r2
    416c:	08 95       	ret

0000416e <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
    416e:	0f 93       	push	r16
    4170:	1f 93       	push	r17
    4172:	cf 93       	push	r28
    4174:	df 93       	push	r29
    4176:	ec 01       	movw	r28, r24
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
    4178:	0e 94 c7 0b 	call	0x178e	; 0x178e <validate>
	if (res == FR_OK) {
    417c:	88 23       	and	r24, r24
    417e:	09 f0       	breq	.+2      	; 0x4182 <f_sync+0x14>
    4180:	4c c0       	rjmp	.+152    	; 0x421a <f_sync+0xac>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    4182:	9c 81       	ldd	r25, Y+4	; 0x04
    4184:	95 ff       	sbrs	r25, 5
    4186:	49 c0       	rjmp	.+146    	; 0x421a <f_sync+0xac>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
    4188:	96 ff       	sbrs	r25, 6
    418a:	12 c0       	rjmp	.+36     	; 0x41b0 <f_sync+0x42>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    418c:	e8 81       	ld	r30, Y
    418e:	f9 81       	ldd	r31, Y+1	; 0x01
    4190:	be 01       	movw	r22, r28
    4192:	60 5e       	subi	r22, 0xE0	; 224
    4194:	7f 4f       	sbci	r23, 0xFF	; 255
    4196:	2e 89       	ldd	r18, Y+22	; 0x16
    4198:	3f 89       	ldd	r19, Y+23	; 0x17
    419a:	48 8d       	ldd	r20, Y+24	; 0x18
    419c:	59 8d       	ldd	r21, Y+25	; 0x19
    419e:	81 81       	ldd	r24, Z+1	; 0x01
    41a0:	01 e0       	ldi	r16, 0x01	; 1
    41a2:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    41a6:	88 23       	and	r24, r24
    41a8:	b9 f5       	brne	.+110    	; 0x4218 <f_sync+0xaa>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
    41aa:	8c 81       	ldd	r24, Y+4	; 0x04
    41ac:	8f 7b       	andi	r24, 0xBF	; 191
    41ae:	8c 83       	std	Y+4, r24	; 0x04
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
    41b0:	4a 8d       	ldd	r20, Y+26	; 0x1a
    41b2:	5b 8d       	ldd	r21, Y+27	; 0x1b
    41b4:	6c 8d       	ldd	r22, Y+28	; 0x1c
    41b6:	7d 8d       	ldd	r23, Y+29	; 0x1d
    41b8:	88 81       	ld	r24, Y
    41ba:	99 81       	ldd	r25, Y+1	; 0x01
    41bc:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
			if (res == FR_OK) {
    41c0:	88 23       	and	r24, r24
    41c2:	59 f5       	brne	.+86     	; 0x421a <f_sync+0xac>
				dir = fp->dir_ptr;
    41c4:	0e 8d       	ldd	r16, Y+30	; 0x1e
    41c6:	1f 8d       	ldd	r17, Y+31	; 0x1f
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    41c8:	f8 01       	movw	r30, r16
    41ca:	83 85       	ldd	r24, Z+11	; 0x0b
    41cc:	80 62       	ori	r24, 0x20	; 32
    41ce:	83 87       	std	Z+11, r24	; 0x0b
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    41d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    41d2:	84 8f       	std	Z+28, r24	; 0x1c
    41d4:	8b 85       	ldd	r24, Y+11	; 0x0b
    41d6:	85 8f       	std	Z+29, r24	; 0x1d
    41d8:	8c 85       	ldd	r24, Y+12	; 0x0c
    41da:	86 8f       	std	Z+30, r24	; 0x1e
    41dc:	8d 85       	ldd	r24, Y+13	; 0x0d
    41de:	87 8f       	std	Z+31, r24	; 0x1f
				st_clust(dir, fp->sclust);					/* Update start cluster */
    41e0:	4e 85       	ldd	r20, Y+14	; 0x0e
    41e2:	5f 85       	ldd	r21, Y+15	; 0x0f
    41e4:	68 89       	ldd	r22, Y+16	; 0x10
    41e6:	79 89       	ldd	r23, Y+17	; 0x11
    41e8:	c8 01       	movw	r24, r16
    41ea:	0e 94 2c 0b 	call	0x1658	; 0x1658 <st_clust>
				tim = get_fattime();						/* Update updated time */
    41ee:	0e 94 e7 11 	call	0x23ce	; 0x23ce <get_fattime>
				ST_DWORD(dir+DIR_WrtTime, tim);
    41f2:	f8 01       	movw	r30, r16
    41f4:	66 8b       	std	Z+22, r22	; 0x16
    41f6:	77 8b       	std	Z+23, r23	; 0x17
    41f8:	80 8f       	std	Z+24, r24	; 0x18
    41fa:	91 8f       	std	Z+25, r25	; 0x19
				ST_WORD(dir+DIR_LstAccDate, 0);
    41fc:	12 8a       	std	Z+18, r1	; 0x12
    41fe:	13 8a       	std	Z+19, r1	; 0x13
				fp->flag &= ~FA__WRITTEN;
    4200:	8c 81       	ldd	r24, Y+4	; 0x04
    4202:	8f 7d       	andi	r24, 0xDF	; 223
    4204:	8c 83       	std	Y+4, r24	; 0x04
				fp->fs->wflag = 1;
    4206:	e8 81       	ld	r30, Y
    4208:	f9 81       	ldd	r31, Y+1	; 0x01
    420a:	81 e0       	ldi	r24, 0x01	; 1
    420c:	84 83       	std	Z+4, r24	; 0x04
				res = sync(fp->fs);
    420e:	88 81       	ld	r24, Y
    4210:	99 81       	ldd	r25, Y+1	; 0x01
    4212:	0e 94 59 11 	call	0x22b2	; 0x22b2 <sync>
    4216:	01 c0       	rjmp	.+2      	; 0x421a <f_sync+0xac>
	if (res == FR_OK) {
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
    4218:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
    421a:	df 91       	pop	r29
    421c:	cf 91       	pop	r28
    421e:	1f 91       	pop	r17
    4220:	0f 91       	pop	r16
    4222:	08 95       	ret

00004224 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    4224:	cf 93       	push	r28
    4226:	df 93       	push	r29
    4228:	ec 01       	movw	r28, r24
#endif
		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
		LEAVE_FF(fs, res);
	}
#else
	res = f_sync(fp);		/* Flush cached data */
    422a:	0e 94 b7 20 	call	0x416e	; 0x416e <f_sync>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    422e:	88 23       	and	r24, r24
    4230:	11 f4       	brne	.+4      	; 0x4236 <f_close+0x12>
    4232:	19 82       	std	Y+1, r1	; 0x01
    4234:	18 82       	st	Y, r1
	return res;
#endif
}
    4236:	df 91       	pop	r29
    4238:	cf 91       	pop	r28
    423a:	08 95       	ret

0000423c <f_chdrive>:

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
    423c:	88 23       	and	r24, r24
    423e:	19 f4       	brne	.+6      	; 0x4246 <f_chdrive+0xa>

	CurrVol = drv;
    4240:	10 92 25 04 	sts	0x0425, r1

	return FR_OK;
    4244:	08 95       	ret

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
    4246:	8b e0       	ldi	r24, 0x0B	; 11

	CurrVol = drv;

	return FR_OK;
}
    4248:	08 95       	ret

0000424a <f_chdir>:


FRESULT f_chdir (
	const TCHAR *path	/* Pointer to the directory path */
)
{
    424a:	ef 92       	push	r14
    424c:	ff 92       	push	r15
    424e:	1f 93       	push	r17
    4250:	cf 93       	push	r28
    4252:	df 93       	push	r29
    4254:	cd b7       	in	r28, 0x3d	; 61
    4256:	de b7       	in	r29, 0x3e	; 62
    4258:	a4 97       	sbiw	r28, 0x24	; 36
    425a:	0f b6       	in	r0, 0x3f	; 63
    425c:	f8 94       	cli
    425e:	de bf       	out	0x3e, r29	; 62
    4260:	0f be       	out	0x3f, r0	; 63
    4262:	cd bf       	out	0x3d, r28	; 61
    4264:	9c a3       	lds	r25, 0x5c
    4266:	8b a3       	lds	r24, 0x5b
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
    4268:	ce 01       	movw	r24, r28
    426a:	83 96       	adiw	r24, 0x23	; 35
    426c:	be 01       	movw	r22, r28
    426e:	6f 5f       	subi	r22, 0xFF	; 255
    4270:	7f 4f       	sbci	r23, 0xFF	; 255
    4272:	40 e0       	ldi	r20, 0x00	; 0
    4274:	0e 94 84 0c 	call	0x1908	; 0x1908 <chk_mounted>
    4278:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    427a:	88 23       	and	r24, r24
    427c:	81 f5       	brne	.+96     	; 0x42de <f_chdir+0x94>
		INIT_BUF(dj);
    427e:	ce 01       	movw	r24, r28
    4280:	47 96       	adiw	r24, 0x17	; 23
    4282:	9e 8b       	std	Y+22, r25	; 0x16
    4284:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the path */
    4286:	6b a1       	lds	r22, 0x4b
    4288:	7c a1       	lds	r23, 0x4c
    428a:	ce 01       	movw	r24, r28
    428c:	01 96       	adiw	r24, 0x01	; 1
    428e:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <follow_path>
    4292:	18 2f       	mov	r17, r24
		FREE_BUF();
		if (res == FR_OK) {					/* Follow completed */
    4294:	88 23       	and	r24, r24
    4296:	01 f5       	brne	.+64     	; 0x42d8 <f_chdir+0x8e>
			if (!dj.dir) {
    4298:	eb 89       	ldd	r30, Y+19	; 0x13
    429a:	fc 89       	ldd	r31, Y+20	; 0x14
    429c:	30 97       	sbiw	r30, 0x00	; 0
    429e:	59 f4       	brne	.+22     	; 0x42b6 <f_chdir+0x6c>
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
    42a0:	e9 81       	ldd	r30, Y+1	; 0x01
    42a2:	fa 81       	ldd	r31, Y+2	; 0x02
    42a4:	8f 81       	ldd	r24, Y+7	; 0x07
    42a6:	98 85       	ldd	r25, Y+8	; 0x08
    42a8:	a9 85       	ldd	r26, Y+9	; 0x09
    42aa:	ba 85       	ldd	r27, Y+10	; 0x0a
    42ac:	86 8b       	std	Z+22, r24	; 0x16
    42ae:	97 8b       	std	Z+23, r25	; 0x17
    42b0:	a0 8f       	std	Z+24, r26	; 0x18
    42b2:	b1 8f       	std	Z+25, r27	; 0x19
    42b4:	14 c0       	rjmp	.+40     	; 0x42de <f_chdir+0x94>
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
    42b6:	83 85       	ldd	r24, Z+11	; 0x0b
    42b8:	84 ff       	sbrs	r24, 4
    42ba:	1e c0       	rjmp	.+60     	; 0x42f8 <f_chdir+0xae>
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
    42bc:	e9 80       	ldd	r14, Y+1	; 0x01
    42be:	fa 80       	ldd	r15, Y+2	; 0x02
    42c0:	c7 01       	movw	r24, r14
    42c2:	bf 01       	movw	r22, r30
    42c4:	0e 94 07 0b 	call	0x160e	; 0x160e <ld_clust>
    42c8:	dc 01       	movw	r26, r24
    42ca:	cb 01       	movw	r24, r22
    42cc:	f7 01       	movw	r30, r14
    42ce:	86 8b       	std	Z+22, r24	; 0x16
    42d0:	97 8b       	std	Z+23, r25	; 0x17
    42d2:	a0 8f       	std	Z+24, r26	; 0x18
    42d4:	b1 8f       	std	Z+25, r27	; 0x19
    42d6:	03 c0       	rjmp	.+6      	; 0x42de <f_chdir+0x94>
				else
					res = FR_NO_PATH;		/* Reached but a file */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    42d8:	84 30       	cpi	r24, 0x04	; 4
    42da:	09 f4       	brne	.+2      	; 0x42de <f_chdir+0x94>
    42dc:	15 e0       	ldi	r17, 0x05	; 5
	}

	LEAVE_FF(dj.fs, res);
}
    42de:	81 2f       	mov	r24, r17
    42e0:	a4 96       	adiw	r28, 0x24	; 36
    42e2:	0f b6       	in	r0, 0x3f	; 63
    42e4:	f8 94       	cli
    42e6:	de bf       	out	0x3e, r29	; 62
    42e8:	0f be       	out	0x3f, r0	; 63
    42ea:	cd bf       	out	0x3d, r28	; 61
    42ec:	df 91       	pop	r29
    42ee:	cf 91       	pop	r28
    42f0:	1f 91       	pop	r17
    42f2:	ff 90       	pop	r15
    42f4:	ef 90       	pop	r14
    42f6:	08 95       	ret
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
				else
					res = FR_NO_PATH;		/* Reached but a file */
    42f8:	15 e0       	ldi	r17, 0x05	; 5
    42fa:	f1 cf       	rjmp	.-30     	; 0x42de <f_chdir+0x94>

000042fc <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
    42fc:	2f 92       	push	r2
    42fe:	3f 92       	push	r3
    4300:	4f 92       	push	r4
    4302:	5f 92       	push	r5
    4304:	6f 92       	push	r6
    4306:	7f 92       	push	r7
    4308:	8f 92       	push	r8
    430a:	9f 92       	push	r9
    430c:	af 92       	push	r10
    430e:	bf 92       	push	r11
    4310:	cf 92       	push	r12
    4312:	df 92       	push	r13
    4314:	ef 92       	push	r14
    4316:	ff 92       	push	r15
    4318:	0f 93       	push	r16
    431a:	1f 93       	push	r17
    431c:	cf 93       	push	r28
    431e:	df 93       	push	r29
    4320:	00 d0       	rcall	.+0      	; 0x4322 <f_lseek+0x26>
    4322:	00 d0       	rcall	.+0      	; 0x4324 <f_lseek+0x28>
    4324:	00 d0       	rcall	.+0      	; 0x4326 <f_lseek+0x2a>
    4326:	cd b7       	in	r28, 0x3d	; 61
    4328:	de b7       	in	r29, 0x3e	; 62
    432a:	9e 83       	std	Y+6, r25	; 0x06
    432c:	8d 83       	std	Y+5, r24	; 0x05
    432e:	6a 01       	movw	r12, r20
    4330:	7b 01       	movw	r14, r22
	FRESULT res;


	res = validate(fp);					/* Check validity of the object */
    4332:	0e 94 c7 0b 	call	0x178e	; 0x178e <validate>
    4336:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    4338:	88 23       	and	r24, r24
    433a:	09 f0       	breq	.+2      	; 0x433e <f_lseek+0x42>
    433c:	e6 c1       	rjmp	.+972    	; 0x470a <f_lseek+0x40e>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
    433e:	ad 81       	ldd	r26, Y+5	; 0x05
    4340:	be 81       	ldd	r27, Y+6	; 0x06
    4342:	14 96       	adiw	r26, 0x04	; 4
    4344:	2c 91       	ld	r18, X
    4346:	14 97       	sbiw	r26, 0x04	; 4
    4348:	22 23       	and	r18, r18
    434a:	0c f4       	brge	.+2      	; 0x434e <f_lseek+0x52>
    434c:	dd c1       	rjmp	.+954    	; 0x4708 <f_lseek+0x40c>

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    434e:	1a 96       	adiw	r26, 0x0a	; 10
    4350:	8d 91       	ld	r24, X+
    4352:	9d 91       	ld	r25, X+
    4354:	0d 90       	ld	r0, X+
    4356:	bc 91       	ld	r27, X
    4358:	a0 2d       	mov	r26, r0
    435a:	8c 15       	cp	r24, r12
    435c:	9d 05       	cpc	r25, r13
    435e:	ae 05       	cpc	r26, r14
    4360:	bf 05       	cpc	r27, r15
    4362:	20 f4       	brcc	.+8      	; 0x436c <f_lseek+0x70>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
    4364:	21 fd       	sbrc	r18, 1
    4366:	02 c0       	rjmp	.+4      	; 0x436c <f_lseek+0x70>
#endif
			) ofs = fp->fsize;
    4368:	6c 01       	movw	r12, r24
    436a:	7d 01       	movw	r14, r26

		ifptr = fp->fptr;
    436c:	ed 81       	ldd	r30, Y+5	; 0x05
    436e:	fe 81       	ldd	r31, Y+6	; 0x06
    4370:	46 81       	ldd	r20, Z+6	; 0x06
    4372:	57 81       	ldd	r21, Z+7	; 0x07
    4374:	60 85       	ldd	r22, Z+8	; 0x08
    4376:	71 85       	ldd	r23, Z+9	; 0x09
		fp->fptr = nsect = 0;
    4378:	16 82       	std	Z+6, r1	; 0x06
    437a:	17 82       	std	Z+7, r1	; 0x07
    437c:	10 86       	std	Z+8, r1	; 0x08
    437e:	11 86       	std	Z+9, r1	; 0x09
		if (ofs) {
    4380:	c1 14       	cp	r12, r1
    4382:	d1 04       	cpc	r13, r1
    4384:	e1 04       	cpc	r14, r1
    4386:	f1 04       	cpc	r15, r1
    4388:	09 f4       	brne	.+2      	; 0x438c <f_lseek+0x90>
    438a:	bf c1       	rjmp	.+894    	; 0x470a <f_lseek+0x40e>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    438c:	20 80       	ld	r2, Z
    438e:	31 80       	ldd	r3, Z+1	; 0x01
    4390:	f1 01       	movw	r30, r2
    4392:	82 81       	ldd	r24, Z+2	; 0x02
    4394:	90 e0       	ldi	r25, 0x00	; 0
    4396:	a0 e0       	ldi	r26, 0x00	; 0
    4398:	b0 e0       	ldi	r27, 0x00	; 0
    439a:	4c 01       	movw	r8, r24
    439c:	5d 01       	movw	r10, r26
    439e:	07 2e       	mov	r0, r23
    43a0:	79 e0       	ldi	r23, 0x09	; 9
    43a2:	88 0c       	add	r8, r8
    43a4:	99 1c       	adc	r9, r9
    43a6:	aa 1c       	adc	r10, r10
    43a8:	bb 1c       	adc	r11, r11
    43aa:	7a 95       	dec	r23
    43ac:	d1 f7       	brne	.-12     	; 0x43a2 <f_lseek+0xa6>
    43ae:	70 2d       	mov	r23, r0
			if (ifptr > 0 &&
    43b0:	41 15       	cp	r20, r1
    43b2:	51 05       	cpc	r21, r1
    43b4:	61 05       	cpc	r22, r1
    43b6:	71 05       	cpc	r23, r1
    43b8:	f1 f1       	breq	.+124    	; 0x4436 <f_lseek+0x13a>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
    43ba:	2a 01       	movw	r4, r20
    43bc:	3b 01       	movw	r6, r22
    43be:	08 94       	sec
    43c0:	41 08       	sbc	r4, r1
    43c2:	51 08       	sbc	r5, r1
    43c4:	61 08       	sbc	r6, r1
    43c6:	71 08       	sbc	r7, r1
    43c8:	c7 01       	movw	r24, r14
    43ca:	b6 01       	movw	r22, r12
    43cc:	61 50       	subi	r22, 0x01	; 1
    43ce:	70 40       	sbci	r23, 0x00	; 0
    43d0:	80 40       	sbci	r24, 0x00	; 0
    43d2:	90 40       	sbci	r25, 0x00	; 0
    43d4:	a5 01       	movw	r20, r10
    43d6:	94 01       	movw	r18, r8
    43d8:	0e 94 4f 2c 	call	0x589e	; 0x589e <__udivmodsi4>
    43dc:	29 83       	std	Y+1, r18	; 0x01
    43de:	3a 83       	std	Y+2, r19	; 0x02
    43e0:	4b 83       	std	Y+3, r20	; 0x03
    43e2:	5c 83       	std	Y+4, r21	; 0x04
    43e4:	c3 01       	movw	r24, r6
    43e6:	b2 01       	movw	r22, r4
    43e8:	a5 01       	movw	r20, r10
    43ea:	94 01       	movw	r18, r8
    43ec:	0e 94 4f 2c 	call	0x589e	; 0x589e <__udivmodsi4>

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
    43f0:	89 81       	ldd	r24, Y+1	; 0x01
    43f2:	9a 81       	ldd	r25, Y+2	; 0x02
    43f4:	ab 81       	ldd	r26, Y+3	; 0x03
    43f6:	bc 81       	ldd	r27, Y+4	; 0x04
    43f8:	82 17       	cp	r24, r18
    43fa:	93 07       	cpc	r25, r19
    43fc:	a4 07       	cpc	r26, r20
    43fe:	b5 07       	cpc	r27, r21
    4400:	d0 f0       	brcs	.+52     	; 0x4436 <f_lseek+0x13a>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    4402:	88 27       	eor	r24, r24
    4404:	99 27       	eor	r25, r25
    4406:	dc 01       	movw	r26, r24
    4408:	88 19       	sub	r24, r8
    440a:	99 09       	sbc	r25, r9
    440c:	aa 09       	sbc	r26, r10
    440e:	bb 09       	sbc	r27, r11
    4410:	84 21       	and	r24, r4
    4412:	95 21       	and	r25, r5
    4414:	a6 21       	and	r26, r6
    4416:	b7 21       	and	r27, r7
    4418:	ed 81       	ldd	r30, Y+5	; 0x05
    441a:	fe 81       	ldd	r31, Y+6	; 0x06
    441c:	86 83       	std	Z+6, r24	; 0x06
    441e:	97 83       	std	Z+7, r25	; 0x07
    4420:	a0 87       	std	Z+8, r26	; 0x08
    4422:	b1 87       	std	Z+9, r27	; 0x09
				ofs -= fp->fptr;
    4424:	c8 1a       	sub	r12, r24
    4426:	d9 0a       	sbc	r13, r25
    4428:	ea 0a       	sbc	r14, r26
    442a:	fb 0a       	sbc	r15, r27
				clst = fp->clust;
    442c:	42 89       	ldd	r20, Z+18	; 0x12
    442e:	53 89       	ldd	r21, Z+19	; 0x13
    4430:	64 89       	ldd	r22, Z+20	; 0x14
    4432:	75 89       	ldd	r23, Z+21	; 0x15
    4434:	42 c0       	rjmp	.+132    	; 0x44ba <f_lseek+0x1be>
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
    4436:	ad 81       	ldd	r26, Y+5	; 0x05
    4438:	be 81       	ldd	r27, Y+6	; 0x06
    443a:	1e 96       	adiw	r26, 0x0e	; 14
    443c:	4d 91       	ld	r20, X+
    443e:	5d 91       	ld	r21, X+
    4440:	6d 91       	ld	r22, X+
    4442:	7c 91       	ld	r23, X
    4444:	51 97       	sbiw	r26, 0x11	; 17
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
    4446:	41 15       	cp	r20, r1
    4448:	51 05       	cpc	r21, r1
    444a:	61 05       	cpc	r22, r1
    444c:	71 05       	cpc	r23, r1
    444e:	69 f5       	brne	.+90     	; 0x44aa <f_lseek+0x1ae>
					clst = create_chain(fp->fs, 0);
    4450:	c1 01       	movw	r24, r2
    4452:	40 e0       	ldi	r20, 0x00	; 0
    4454:	50 e0       	ldi	r21, 0x00	; 0
    4456:	ba 01       	movw	r22, r20
    4458:	0e 94 4a 15 	call	0x2a94	; 0x2a94 <create_chain>
    445c:	ab 01       	movw	r20, r22
    445e:	bc 01       	movw	r22, r24
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    4460:	41 30       	cpi	r20, 0x01	; 1
    4462:	51 05       	cpc	r21, r1
    4464:	61 05       	cpc	r22, r1
    4466:	71 05       	cpc	r23, r1
    4468:	39 f4       	brne	.+14     	; 0x4478 <f_lseek+0x17c>
    446a:	ed 81       	ldd	r30, Y+5	; 0x05
    446c:	fe 81       	ldd	r31, Y+6	; 0x06
    446e:	84 81       	ldd	r24, Z+4	; 0x04
    4470:	80 68       	ori	r24, 0x80	; 128
    4472:	84 83       	std	Z+4, r24	; 0x04
    4474:	12 e0       	ldi	r17, 0x02	; 2
    4476:	49 c1       	rjmp	.+658    	; 0x470a <f_lseek+0x40e>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    4478:	4f 3f       	cpi	r20, 0xFF	; 255
    447a:	ff ef       	ldi	r31, 0xFF	; 255
    447c:	5f 07       	cpc	r21, r31
    447e:	ff ef       	ldi	r31, 0xFF	; 255
    4480:	6f 07       	cpc	r22, r31
    4482:	ff ef       	ldi	r31, 0xFF	; 255
    4484:	7f 07       	cpc	r23, r31
    4486:	59 f4       	brne	.+22     	; 0x449e <f_lseek+0x1a2>
    4488:	ad 81       	ldd	r26, Y+5	; 0x05
    448a:	be 81       	ldd	r27, Y+6	; 0x06
    448c:	14 96       	adiw	r26, 0x04	; 4
    448e:	8c 91       	ld	r24, X
    4490:	14 97       	sbiw	r26, 0x04	; 4
    4492:	80 68       	ori	r24, 0x80	; 128
    4494:	14 96       	adiw	r26, 0x04	; 4
    4496:	8c 93       	st	X, r24
    4498:	14 97       	sbiw	r26, 0x04	; 4
    449a:	11 e0       	ldi	r17, 0x01	; 1
    449c:	36 c1       	rjmp	.+620    	; 0x470a <f_lseek+0x40e>
					fp->sclust = clst;
    449e:	ed 81       	ldd	r30, Y+5	; 0x05
    44a0:	fe 81       	ldd	r31, Y+6	; 0x06
    44a2:	46 87       	std	Z+14, r20	; 0x0e
    44a4:	57 87       	std	Z+15, r21	; 0x0f
    44a6:	60 8b       	std	Z+16, r22	; 0x10
    44a8:	71 8b       	std	Z+17, r23	; 0x11
				}
#endif
				fp->clust = clst;
    44aa:	ad 81       	ldd	r26, Y+5	; 0x05
    44ac:	be 81       	ldd	r27, Y+6	; 0x06
    44ae:	52 96       	adiw	r26, 0x12	; 18
    44b0:	4d 93       	st	X+, r20
    44b2:	5d 93       	st	X+, r21
    44b4:	6d 93       	st	X+, r22
    44b6:	7c 93       	st	X, r23
    44b8:	55 97       	sbiw	r26, 0x15	; 21
			}
			if (clst != 0) {
    44ba:	41 15       	cp	r20, r1
    44bc:	51 05       	cpc	r21, r1
    44be:	61 05       	cpc	r22, r1
    44c0:	71 05       	cpc	r23, r1
    44c2:	09 f4       	brne	.+2      	; 0x44c6 <f_lseek+0x1ca>
    44c4:	aa c0       	rjmp	.+340    	; 0x461a <f_lseek+0x31e>
				while (ofs > bcs) {						/* Cluster following loop */
    44c6:	8c 14       	cp	r8, r12
    44c8:	9d 04       	cpc	r9, r13
    44ca:	ae 04       	cpc	r10, r14
    44cc:	bf 04       	cpc	r11, r15
    44ce:	08 f0       	brcs	.+2      	; 0x44d2 <f_lseek+0x1d6>
    44d0:	68 c0       	rjmp	.+208    	; 0x45a2 <f_lseek+0x2a6>
    44d2:	4d 80       	ldd	r4, Y+5	; 0x05
    44d4:	5e 80       	ldd	r5, Y+6	; 0x06
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    44d6:	f2 01       	movw	r30, r4
    44d8:	84 81       	ldd	r24, Z+4	; 0x04
    44da:	81 ff       	sbrs	r24, 1
    44dc:	0c c0       	rjmp	.+24     	; 0x44f6 <f_lseek+0x1fa>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
    44de:	80 81       	ld	r24, Z
    44e0:	91 81       	ldd	r25, Z+1	; 0x01
    44e2:	0e 94 4a 15 	call	0x2a94	; 0x2a94 <create_chain>
    44e6:	ab 01       	movw	r20, r22
    44e8:	bc 01       	movw	r22, r24
						if (clst == 0) {				/* When disk gets full, clip file size */
    44ea:	41 15       	cp	r20, r1
    44ec:	51 05       	cpc	r21, r1
    44ee:	61 05       	cpc	r22, r1
    44f0:	71 05       	cpc	r23, r1
    44f2:	39 f4       	brne	.+14     	; 0x4502 <f_lseek+0x206>
    44f4:	52 c0       	rjmp	.+164    	; 0x459a <f_lseek+0x29e>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    44f6:	80 81       	ld	r24, Z
    44f8:	91 81       	ldd	r25, Z+1	; 0x01
    44fa:	0e 94 21 12 	call	0x2442	; 0x2442 <get_fat>
    44fe:	ab 01       	movw	r20, r22
    4500:	bc 01       	movw	r22, r24
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    4502:	4f 3f       	cpi	r20, 0xFF	; 255
    4504:	bf ef       	ldi	r27, 0xFF	; 255
    4506:	5b 07       	cpc	r21, r27
    4508:	bf ef       	ldi	r27, 0xFF	; 255
    450a:	6b 07       	cpc	r22, r27
    450c:	bf ef       	ldi	r27, 0xFF	; 255
    450e:	7b 07       	cpc	r23, r27
    4510:	41 f4       	brne	.+16     	; 0x4522 <f_lseek+0x226>
    4512:	5e 82       	std	Y+6, r5	; 0x06
    4514:	4d 82       	std	Y+5, r4	; 0x05
    4516:	f2 01       	movw	r30, r4
    4518:	84 81       	ldd	r24, Z+4	; 0x04
    451a:	80 68       	ori	r24, 0x80	; 128
    451c:	84 83       	std	Z+4, r24	; 0x04
    451e:	11 e0       	ldi	r17, 0x01	; 1
    4520:	f4 c0       	rjmp	.+488    	; 0x470a <f_lseek+0x40e>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    4522:	42 30       	cpi	r20, 0x02	; 2
    4524:	51 05       	cpc	r21, r1
    4526:	61 05       	cpc	r22, r1
    4528:	71 05       	cpc	r23, r1
    452a:	60 f0       	brcs	.+24     	; 0x4544 <f_lseek+0x248>
    452c:	d2 01       	movw	r26, r4
    452e:	ed 91       	ld	r30, X+
    4530:	fc 91       	ld	r31, X
    4532:	82 8d       	ldd	r24, Z+26	; 0x1a
    4534:	93 8d       	ldd	r25, Z+27	; 0x1b
    4536:	a4 8d       	ldd	r26, Z+28	; 0x1c
    4538:	b5 8d       	ldd	r27, Z+29	; 0x1d
    453a:	48 17       	cp	r20, r24
    453c:	59 07       	cpc	r21, r25
    453e:	6a 07       	cpc	r22, r26
    4540:	7b 07       	cpc	r23, r27
    4542:	40 f0       	brcs	.+16     	; 0x4554 <f_lseek+0x258>
    4544:	5e 82       	std	Y+6, r5	; 0x06
    4546:	4d 82       	std	Y+5, r4	; 0x05
    4548:	f2 01       	movw	r30, r4
    454a:	84 81       	ldd	r24, Z+4	; 0x04
    454c:	80 68       	ori	r24, 0x80	; 128
    454e:	84 83       	std	Z+4, r24	; 0x04
    4550:	12 e0       	ldi	r17, 0x02	; 2
    4552:	db c0       	rjmp	.+438    	; 0x470a <f_lseek+0x40e>
					fp->clust = clst;
    4554:	d2 01       	movw	r26, r4
    4556:	52 96       	adiw	r26, 0x12	; 18
    4558:	4d 93       	st	X+, r20
    455a:	5d 93       	st	X+, r21
    455c:	6d 93       	st	X+, r22
    455e:	7c 93       	st	X, r23
    4560:	55 97       	sbiw	r26, 0x15	; 21
					fp->fptr += bcs;
    4562:	16 96       	adiw	r26, 0x06	; 6
    4564:	8d 91       	ld	r24, X+
    4566:	9d 91       	ld	r25, X+
    4568:	0d 90       	ld	r0, X+
    456a:	bc 91       	ld	r27, X
    456c:	a0 2d       	mov	r26, r0
    456e:	88 0d       	add	r24, r8
    4570:	99 1d       	adc	r25, r9
    4572:	aa 1d       	adc	r26, r10
    4574:	bb 1d       	adc	r27, r11
    4576:	f2 01       	movw	r30, r4
    4578:	86 83       	std	Z+6, r24	; 0x06
    457a:	97 83       	std	Z+7, r25	; 0x07
    457c:	a0 87       	std	Z+8, r26	; 0x08
    457e:	b1 87       	std	Z+9, r27	; 0x09
					ofs -= bcs;
    4580:	c8 18       	sub	r12, r8
    4582:	d9 08       	sbc	r13, r9
    4584:	ea 08       	sbc	r14, r10
    4586:	fb 08       	sbc	r15, r11
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
    4588:	8c 14       	cp	r8, r12
    458a:	9d 04       	cpc	r9, r13
    458c:	ae 04       	cpc	r10, r14
    458e:	bf 04       	cpc	r11, r15
    4590:	08 f4       	brcc	.+2      	; 0x4594 <f_lseek+0x298>
    4592:	a1 cf       	rjmp	.-190    	; 0x44d6 <f_lseek+0x1da>
    4594:	5e 82       	std	Y+6, r5	; 0x06
    4596:	4d 82       	std	Y+5, r4	; 0x05
    4598:	04 c0       	rjmp	.+8      	; 0x45a2 <f_lseek+0x2a6>
    459a:	5e 82       	std	Y+6, r5	; 0x06
    459c:	4d 82       	std	Y+5, r4	; 0x05
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
						if (clst == 0) {				/* When disk gets full, clip file size */
							ofs = bcs; break;
    459e:	75 01       	movw	r14, r10
    45a0:	64 01       	movw	r12, r8
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
    45a2:	ed 81       	ldd	r30, Y+5	; 0x05
    45a4:	fe 81       	ldd	r31, Y+6	; 0x06
    45a6:	86 81       	ldd	r24, Z+6	; 0x06
    45a8:	97 81       	ldd	r25, Z+7	; 0x07
    45aa:	a0 85       	ldd	r26, Z+8	; 0x08
    45ac:	b1 85       	ldd	r27, Z+9	; 0x09
    45ae:	8c 0d       	add	r24, r12
    45b0:	9d 1d       	adc	r25, r13
    45b2:	ae 1d       	adc	r26, r14
    45b4:	bf 1d       	adc	r27, r15
    45b6:	86 83       	std	Z+6, r24	; 0x06
    45b8:	97 83       	std	Z+7, r25	; 0x07
    45ba:	a0 87       	std	Z+8, r26	; 0x08
    45bc:	b1 87       	std	Z+9, r27	; 0x09
				if (ofs % SS(fp->fs)) {
    45be:	d7 01       	movw	r26, r14
    45c0:	c6 01       	movw	r24, r12
    45c2:	91 70       	andi	r25, 0x01	; 1
    45c4:	a0 70       	andi	r26, 0x00	; 0
    45c6:	b0 70       	andi	r27, 0x00	; 0
    45c8:	00 97       	sbiw	r24, 0x00	; 0
    45ca:	a1 05       	cpc	r26, r1
    45cc:	b1 05       	cpc	r27, r1
    45ce:	49 f1       	breq	.+82     	; 0x4622 <f_lseek+0x326>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    45d0:	80 81       	ld	r24, Z
    45d2:	91 81       	ldd	r25, Z+1	; 0x01
    45d4:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <clust2sect>
    45d8:	dc 01       	movw	r26, r24
    45da:	cb 01       	movw	r24, r22
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    45dc:	00 97       	sbiw	r24, 0x00	; 0
    45de:	a1 05       	cpc	r26, r1
    45e0:	b1 05       	cpc	r27, r1
    45e2:	59 f4       	brne	.+22     	; 0x45fa <f_lseek+0x2fe>
    45e4:	ad 81       	ldd	r26, Y+5	; 0x05
    45e6:	be 81       	ldd	r27, Y+6	; 0x06
    45e8:	14 96       	adiw	r26, 0x04	; 4
    45ea:	8c 91       	ld	r24, X
    45ec:	14 97       	sbiw	r26, 0x04	; 4
    45ee:	80 68       	ori	r24, 0x80	; 128
    45f0:	14 96       	adiw	r26, 0x04	; 4
    45f2:	8c 93       	st	X, r24
    45f4:	14 97       	sbiw	r26, 0x04	; 4
    45f6:	12 e0       	ldi	r17, 0x02	; 2
    45f8:	88 c0       	rjmp	.+272    	; 0x470a <f_lseek+0x40e>
					nsect += ofs / SS(fp->fs);
    45fa:	46 01       	movw	r8, r12
    45fc:	57 01       	movw	r10, r14
    45fe:	07 2e       	mov	r0, r23
    4600:	79 e0       	ldi	r23, 0x09	; 9
    4602:	b6 94       	lsr	r11
    4604:	a7 94       	ror	r10
    4606:	97 94       	ror	r9
    4608:	87 94       	ror	r8
    460a:	7a 95       	dec	r23
    460c:	d1 f7       	brne	.-12     	; 0x4602 <f_lseek+0x306>
    460e:	70 2d       	mov	r23, r0
    4610:	88 0e       	add	r8, r24
    4612:	99 1e       	adc	r9, r25
    4614:	aa 1e       	adc	r10, r26
    4616:	bb 1e       	adc	r11, r27
    4618:	07 c0       	rjmp	.+14     	; 0x4628 <f_lseek+0x32c>
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
    461a:	88 24       	eor	r8, r8
    461c:	99 24       	eor	r9, r9
    461e:	54 01       	movw	r10, r8
    4620:	03 c0       	rjmp	.+6      	; 0x4628 <f_lseek+0x32c>
    4622:	88 24       	eor	r8, r8
    4624:	99 24       	eor	r9, r9
    4626:	54 01       	movw	r10, r8
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
					nsect += ofs / SS(fp->fs);
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    4628:	ed 81       	ldd	r30, Y+5	; 0x05
    462a:	fe 81       	ldd	r31, Y+6	; 0x06
    462c:	86 81       	ldd	r24, Z+6	; 0x06
    462e:	97 81       	ldd	r25, Z+7	; 0x07
    4630:	a0 85       	ldd	r26, Z+8	; 0x08
    4632:	b1 85       	ldd	r27, Z+9	; 0x09
    4634:	91 70       	andi	r25, 0x01	; 1
    4636:	a0 70       	andi	r26, 0x00	; 0
    4638:	b0 70       	andi	r27, 0x00	; 0
    463a:	00 97       	sbiw	r24, 0x00	; 0
    463c:	a1 05       	cpc	r26, r1
    463e:	b1 05       	cpc	r27, r1
    4640:	09 f4       	brne	.+2      	; 0x4644 <f_lseek+0x348>
    4642:	4b c0       	rjmp	.+150    	; 0x46da <f_lseek+0x3de>
    4644:	c6 88       	ldd	r12, Z+22	; 0x16
    4646:	d7 88       	ldd	r13, Z+23	; 0x17
    4648:	e0 8c       	ldd	r14, Z+24	; 0x18
    464a:	f1 8c       	ldd	r15, Z+25	; 0x19
    464c:	c8 14       	cp	r12, r8
    464e:	d9 04       	cpc	r13, r9
    4650:	ea 04       	cpc	r14, r10
    4652:	fb 04       	cpc	r15, r11
    4654:	09 f4       	brne	.+2      	; 0x4658 <f_lseek+0x35c>
    4656:	41 c0       	rjmp	.+130    	; 0x46da <f_lseek+0x3de>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
    4658:	84 81       	ldd	r24, Z+4	; 0x04
    465a:	86 ff       	sbrs	r24, 6
    465c:	1f c0       	rjmp	.+62     	; 0x469c <f_lseek+0x3a0>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    465e:	01 90       	ld	r0, Z+
    4660:	f0 81       	ld	r31, Z
    4662:	e0 2d       	mov	r30, r0
    4664:	6d 81       	ldd	r22, Y+5	; 0x05
    4666:	7e 81       	ldd	r23, Y+6	; 0x06
    4668:	60 5e       	subi	r22, 0xE0	; 224
    466a:	7f 4f       	sbci	r23, 0xFF	; 255
    466c:	81 81       	ldd	r24, Z+1	; 0x01
    466e:	a7 01       	movw	r20, r14
    4670:	96 01       	movw	r18, r12
    4672:	01 e0       	ldi	r16, 0x01	; 1
    4674:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    4678:	88 23       	and	r24, r24
    467a:	59 f0       	breq	.+22     	; 0x4692 <f_lseek+0x396>
					ABORT(fp->fs, FR_DISK_ERR);
    467c:	ad 81       	ldd	r26, Y+5	; 0x05
    467e:	be 81       	ldd	r27, Y+6	; 0x06
    4680:	14 96       	adiw	r26, 0x04	; 4
    4682:	8c 91       	ld	r24, X
    4684:	14 97       	sbiw	r26, 0x04	; 4
    4686:	80 68       	ori	r24, 0x80	; 128
    4688:	14 96       	adiw	r26, 0x04	; 4
    468a:	8c 93       	st	X, r24
    468c:	14 97       	sbiw	r26, 0x04	; 4
    468e:	11 e0       	ldi	r17, 0x01	; 1
    4690:	3c c0       	rjmp	.+120    	; 0x470a <f_lseek+0x40e>
				fp->flag &= ~FA__DIRTY;
    4692:	ed 81       	ldd	r30, Y+5	; 0x05
    4694:	fe 81       	ldd	r31, Y+6	; 0x06
    4696:	84 81       	ldd	r24, Z+4	; 0x04
    4698:	8f 7b       	andi	r24, 0xBF	; 191
    469a:	84 83       	std	Z+4, r24	; 0x04
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
    469c:	ad 81       	ldd	r26, Y+5	; 0x05
    469e:	be 81       	ldd	r27, Y+6	; 0x06
    46a0:	ed 91       	ld	r30, X+
    46a2:	fc 91       	ld	r31, X
    46a4:	11 97       	sbiw	r26, 0x01	; 1
    46a6:	bd 01       	movw	r22, r26
    46a8:	60 5e       	subi	r22, 0xE0	; 224
    46aa:	7f 4f       	sbci	r23, 0xFF	; 255
    46ac:	81 81       	ldd	r24, Z+1	; 0x01
    46ae:	a5 01       	movw	r20, r10
    46b0:	94 01       	movw	r18, r8
    46b2:	01 e0       	ldi	r16, 0x01	; 1
    46b4:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    46b8:	88 23       	and	r24, r24
    46ba:	39 f0       	breq	.+14     	; 0x46ca <f_lseek+0x3ce>
				ABORT(fp->fs, FR_DISK_ERR);
    46bc:	ed 81       	ldd	r30, Y+5	; 0x05
    46be:	fe 81       	ldd	r31, Y+6	; 0x06
    46c0:	84 81       	ldd	r24, Z+4	; 0x04
    46c2:	80 68       	ori	r24, 0x80	; 128
    46c4:	84 83       	std	Z+4, r24	; 0x04
    46c6:	11 e0       	ldi	r17, 0x01	; 1
    46c8:	20 c0       	rjmp	.+64     	; 0x470a <f_lseek+0x40e>
#endif
			fp->dsect = nsect;
    46ca:	ad 81       	ldd	r26, Y+5	; 0x05
    46cc:	be 81       	ldd	r27, Y+6	; 0x06
    46ce:	56 96       	adiw	r26, 0x16	; 22
    46d0:	8d 92       	st	X+, r8
    46d2:	9d 92       	st	X+, r9
    46d4:	ad 92       	st	X+, r10
    46d6:	bc 92       	st	X, r11
    46d8:	59 97       	sbiw	r26, 0x19	; 25
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
    46da:	ed 81       	ldd	r30, Y+5	; 0x05
    46dc:	fe 81       	ldd	r31, Y+6	; 0x06
    46de:	86 81       	ldd	r24, Z+6	; 0x06
    46e0:	97 81       	ldd	r25, Z+7	; 0x07
    46e2:	a0 85       	ldd	r26, Z+8	; 0x08
    46e4:	b1 85       	ldd	r27, Z+9	; 0x09
    46e6:	42 85       	ldd	r20, Z+10	; 0x0a
    46e8:	53 85       	ldd	r21, Z+11	; 0x0b
    46ea:	64 85       	ldd	r22, Z+12	; 0x0c
    46ec:	75 85       	ldd	r23, Z+13	; 0x0d
    46ee:	48 17       	cp	r20, r24
    46f0:	59 07       	cpc	r21, r25
    46f2:	6a 07       	cpc	r22, r26
    46f4:	7b 07       	cpc	r23, r27
    46f6:	48 f4       	brcc	.+18     	; 0x470a <f_lseek+0x40e>
			fp->fsize = fp->fptr;
    46f8:	82 87       	std	Z+10, r24	; 0x0a
    46fa:	93 87       	std	Z+11, r25	; 0x0b
    46fc:	a4 87       	std	Z+12, r26	; 0x0c
    46fe:	b5 87       	std	Z+13, r27	; 0x0d
			fp->flag |= FA__WRITTEN;
    4700:	84 81       	ldd	r24, Z+4	; 0x04
    4702:	80 62       	ori	r24, 0x20	; 32
    4704:	84 83       	std	Z+4, r24	; 0x04
    4706:	01 c0       	rjmp	.+2      	; 0x470a <f_lseek+0x40e>


	res = validate(fp);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)			/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    4708:	12 e0       	ldi	r17, 0x02	; 2
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
    470a:	81 2f       	mov	r24, r17
    470c:	26 96       	adiw	r28, 0x06	; 6
    470e:	0f b6       	in	r0, 0x3f	; 63
    4710:	f8 94       	cli
    4712:	de bf       	out	0x3e, r29	; 62
    4714:	0f be       	out	0x3f, r0	; 63
    4716:	cd bf       	out	0x3d, r28	; 61
    4718:	df 91       	pop	r29
    471a:	cf 91       	pop	r28
    471c:	1f 91       	pop	r17
    471e:	0f 91       	pop	r16
    4720:	ff 90       	pop	r15
    4722:	ef 90       	pop	r14
    4724:	df 90       	pop	r13
    4726:	cf 90       	pop	r12
    4728:	bf 90       	pop	r11
    472a:	af 90       	pop	r10
    472c:	9f 90       	pop	r9
    472e:	8f 90       	pop	r8
    4730:	7f 90       	pop	r7
    4732:	6f 90       	pop	r6
    4734:	5f 90       	pop	r5
    4736:	4f 90       	pop	r4
    4738:	3f 90       	pop	r3
    473a:	2f 90       	pop	r2
    473c:	08 95       	ret

0000473e <f_opendir>:

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const TCHAR *path	/* Pointer to the directory path */
)
{
    473e:	ef 92       	push	r14
    4740:	ff 92       	push	r15
    4742:	0f 93       	push	r16
    4744:	1f 93       	push	r17
    4746:	cf 93       	push	r28
    4748:	df 93       	push	r29
    474a:	cd b7       	in	r28, 0x3d	; 61
    474c:	de b7       	in	r29, 0x3e	; 62
    474e:	2e 97       	sbiw	r28, 0x0e	; 14
    4750:	0f b6       	in	r0, 0x3f	; 63
    4752:	f8 94       	cli
    4754:	de bf       	out	0x3e, r29	; 62
    4756:	0f be       	out	0x3f, r0	; 63
    4758:	cd bf       	out	0x3d, r28	; 61
    475a:	8c 01       	movw	r16, r24
    475c:	7e 87       	std	Y+14, r23	; 0x0e
    475e:	6d 87       	std	Y+13, r22	; 0x0d
	FRESULT res;
	FATFS *fs;
	DEF_NAMEBUF;


	if (!dj) return FR_INVALID_OBJECT;
    4760:	00 97       	sbiw	r24, 0x00	; 0
    4762:	09 f4       	brne	.+2      	; 0x4766 <f_opendir+0x28>
    4764:	4c c0       	rjmp	.+152    	; 0x47fe <f_opendir+0xc0>

	res = chk_mounted(&path, &dj->fs, 0);
    4766:	ce 01       	movw	r24, r28
    4768:	0d 96       	adiw	r24, 0x0d	; 13
    476a:	b8 01       	movw	r22, r16
    476c:	40 e0       	ldi	r20, 0x00	; 0
    476e:	0e 94 84 0c 	call	0x1908	; 0x1908 <chk_mounted>
	fs = dj->fs;
    4772:	d8 01       	movw	r26, r16
    4774:	ed 90       	ld	r14, X+
    4776:	fc 90       	ld	r15, X
    4778:	11 97       	sbiw	r26, 0x01	; 1
	if (res == FR_OK) {
    477a:	88 23       	and	r24, r24
    477c:	e1 f5       	brne	.+120    	; 0x47f6 <f_opendir+0xb8>
		INIT_BUF(*dj);
    477e:	ce 01       	movw	r24, r28
    4780:	01 96       	adiw	r24, 0x01	; 1
    4782:	55 96       	adiw	r26, 0x15	; 21
    4784:	9c 93       	st	X, r25
    4786:	8e 93       	st	-X, r24
    4788:	54 97       	sbiw	r26, 0x14	; 20
		res = follow_path(dj, path);			/* Follow the path to the directory */
    478a:	6d 85       	ldd	r22, Y+13	; 0x0d
    478c:	7e 85       	ldd	r23, Y+14	; 0x0e
    478e:	c8 01       	movw	r24, r16
    4790:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <follow_path>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
    4794:	88 23       	and	r24, r24
    4796:	11 f5       	brne	.+68     	; 0x47dc <f_opendir+0x9e>
			if (dj->dir) {						/* It is not the root dir */
    4798:	d8 01       	movw	r26, r16
    479a:	52 96       	adiw	r26, 0x12	; 18
    479c:	ed 91       	ld	r30, X+
    479e:	fc 91       	ld	r31, X
    47a0:	53 97       	sbiw	r26, 0x13	; 19
    47a2:	30 97       	sbiw	r30, 0x00	; 0
    47a4:	71 f0       	breq	.+28     	; 0x47c2 <f_opendir+0x84>
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
    47a6:	83 85       	ldd	r24, Z+11	; 0x0b
    47a8:	84 ff       	sbrs	r24, 4
    47aa:	1b c0       	rjmp	.+54     	; 0x47e2 <f_opendir+0xa4>
					dj->sclust = ld_clust(fs, dj->dir);
    47ac:	c7 01       	movw	r24, r14
    47ae:	bf 01       	movw	r22, r30
    47b0:	0e 94 07 0b 	call	0x160e	; 0x160e <ld_clust>
    47b4:	dc 01       	movw	r26, r24
    47b6:	cb 01       	movw	r24, r22
    47b8:	f8 01       	movw	r30, r16
    47ba:	86 83       	std	Z+6, r24	; 0x06
    47bc:	97 83       	std	Z+7, r25	; 0x07
    47be:	a0 87       	std	Z+8, r26	; 0x08
    47c0:	b1 87       	std	Z+9, r27	; 0x09
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dj->id = fs->id;
    47c2:	d7 01       	movw	r26, r14
    47c4:	16 96       	adiw	r26, 0x06	; 6
    47c6:	8d 91       	ld	r24, X+
    47c8:	9c 91       	ld	r25, X
    47ca:	17 97       	sbiw	r26, 0x07	; 7
    47cc:	f8 01       	movw	r30, r16
    47ce:	93 83       	std	Z+3, r25	; 0x03
    47d0:	82 83       	std	Z+2, r24	; 0x02
				res = dir_sdi(dj, 0);			/* Rewind dir */
    47d2:	c8 01       	movw	r24, r16
    47d4:	60 e0       	ldi	r22, 0x00	; 0
    47d6:	70 e0       	ldi	r23, 0x00	; 0
    47d8:	0e 94 58 13 	call	0x26b0	; 0x26b0 <dir_sdi>
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    47dc:	84 30       	cpi	r24, 0x04	; 4
    47de:	11 f4       	brne	.+4      	; 0x47e4 <f_opendir+0xa6>
    47e0:	04 c0       	rjmp	.+8      	; 0x47ea <f_opendir+0xac>
		if (res == FR_OK) {						/* Follow completed */
			if (dj->dir) {						/* It is not the root dir */
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
					dj->sclust = ld_clust(fs, dj->dir);
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
    47e2:	85 e0       	ldi	r24, 0x05	; 5
				dj->id = fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
    47e4:	88 23       	and	r24, r24
    47e6:	61 f0       	breq	.+24     	; 0x4800 <f_opendir+0xc2>
    47e8:	01 c0       	rjmp	.+2      	; 0x47ec <f_opendir+0xae>
			if (res == FR_OK) {
				dj->id = fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    47ea:	85 e0       	ldi	r24, 0x05	; 5
		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
    47ec:	d8 01       	movw	r26, r16
    47ee:	11 96       	adiw	r26, 0x01	; 1
    47f0:	1c 92       	st	X, r1
    47f2:	1e 92       	st	-X, r1
    47f4:	05 c0       	rjmp	.+10     	; 0x4800 <f_opendir+0xc2>
	} else {
		dj->fs = 0;
    47f6:	f8 01       	movw	r30, r16
    47f8:	11 82       	std	Z+1, r1	; 0x01
    47fa:	10 82       	st	Z, r1
    47fc:	01 c0       	rjmp	.+2      	; 0x4800 <f_opendir+0xc2>
	FRESULT res;
	FATFS *fs;
	DEF_NAMEBUF;


	if (!dj) return FR_INVALID_OBJECT;
    47fe:	89 e0       	ldi	r24, 0x09	; 9
	} else {
		dj->fs = 0;
	}

	LEAVE_FF(fs, res);
}
    4800:	2e 96       	adiw	r28, 0x0e	; 14
    4802:	0f b6       	in	r0, 0x3f	; 63
    4804:	f8 94       	cli
    4806:	de bf       	out	0x3e, r29	; 62
    4808:	0f be       	out	0x3f, r0	; 63
    480a:	cd bf       	out	0x3d, r28	; 61
    480c:	df 91       	pop	r29
    480e:	cf 91       	pop	r28
    4810:	1f 91       	pop	r17
    4812:	0f 91       	pop	r16
    4814:	ff 90       	pop	r15
    4816:	ef 90       	pop	r14
    4818:	08 95       	ret

0000481a <f_readdir>:

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
    481a:	cf 92       	push	r12
    481c:	df 92       	push	r13
    481e:	ef 92       	push	r14
    4820:	ff 92       	push	r15
    4822:	1f 93       	push	r17
    4824:	cf 93       	push	r28
    4826:	df 93       	push	r29
    4828:	cd b7       	in	r28, 0x3d	; 61
    482a:	de b7       	in	r29, 0x3e	; 62
    482c:	2c 97       	sbiw	r28, 0x0c	; 12
    482e:	0f b6       	in	r0, 0x3f	; 63
    4830:	f8 94       	cli
    4832:	de bf       	out	0x3e, r29	; 62
    4834:	0f be       	out	0x3f, r0	; 63
    4836:	cd bf       	out	0x3d, r28	; 61
    4838:	7c 01       	movw	r14, r24
    483a:	6b 01       	movw	r12, r22
	FRESULT res;
	DEF_NAMEBUF;


	res = validate(dj);						/* Check validity of the object */
    483c:	0e 94 c7 0b 	call	0x178e	; 0x178e <validate>
    4840:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    4842:	88 23       	and	r24, r24
    4844:	81 f5       	brne	.+96     	; 0x48a6 <f_readdir+0x8c>
		if (!fno) {
    4846:	c1 14       	cp	r12, r1
    4848:	d1 04       	cpc	r13, r1
    484a:	39 f4       	brne	.+14     	; 0x485a <f_readdir+0x40>
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
    484c:	c7 01       	movw	r24, r14
    484e:	60 e0       	ldi	r22, 0x00	; 0
    4850:	70 e0       	ldi	r23, 0x00	; 0
    4852:	0e 94 58 13 	call	0x26b0	; 0x26b0 <dir_sdi>
    4856:	18 2f       	mov	r17, r24
    4858:	26 c0       	rjmp	.+76     	; 0x48a6 <f_readdir+0x8c>
		} else {
			INIT_BUF(*dj);
    485a:	ce 01       	movw	r24, r28
    485c:	01 96       	adiw	r24, 0x01	; 1
    485e:	f7 01       	movw	r30, r14
    4860:	95 8b       	std	Z+21, r25	; 0x15
    4862:	84 8b       	std	Z+20, r24	; 0x14
			res = dir_read(dj);				/* Read an directory item */
    4864:	c7 01       	movw	r24, r14
    4866:	0e 94 3b 1a 	call	0x3476	; 0x3476 <dir_read>
			if (res == FR_NO_FILE) {		/* Reached end of dir */
    486a:	84 30       	cpi	r24, 0x04	; 4
    486c:	31 f4       	brne	.+12     	; 0x487a <f_readdir+0x60>
				dj->sect = 0;
    486e:	f7 01       	movw	r30, r14
    4870:	16 86       	std	Z+14, r1	; 0x0e
    4872:	17 86       	std	Z+15, r1	; 0x0f
    4874:	10 8a       	std	Z+16, r1	; 0x10
    4876:	11 8a       	std	Z+17, r1	; 0x11
    4878:	02 c0       	rjmp	.+4      	; 0x487e <f_readdir+0x64>
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
    487a:	88 23       	and	r24, r24
    487c:	89 f4       	brne	.+34     	; 0x48a0 <f_readdir+0x86>
				get_fileinfo(dj, fno);		/* Get the object information */
    487e:	c7 01       	movw	r24, r14
    4880:	b6 01       	movw	r22, r12
    4882:	0e 94 35 0b 	call	0x166a	; 0x166a <get_fileinfo>
				res = dir_next(dj, 0);		/* Increment index for next */
    4886:	c7 01       	movw	r24, r14
    4888:	60 e0       	ldi	r22, 0x00	; 0
    488a:	70 e0       	ldi	r23, 0x00	; 0
    488c:	0e 94 6c 16 	call	0x2cd8	; 0x2cd8 <dir_next>
				if (res == FR_NO_FILE) {
    4890:	84 30       	cpi	r24, 0x04	; 4
    4892:	41 f4       	brne	.+16     	; 0x48a4 <f_readdir+0x8a>
					dj->sect = 0;
    4894:	f7 01       	movw	r30, r14
    4896:	16 86       	std	Z+14, r1	; 0x0e
    4898:	17 86       	std	Z+15, r1	; 0x0f
    489a:	10 8a       	std	Z+16, r1	; 0x10
    489c:	11 8a       	std	Z+17, r1	; 0x11
    489e:	03 c0       	rjmp	.+6      	; 0x48a6 <f_readdir+0x8c>
	if (res == FR_OK) {
		if (!fno) {
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
		} else {
			INIT_BUF(*dj);
			res = dir_read(dj);				/* Read an directory item */
    48a0:	18 2f       	mov	r17, r24
    48a2:	01 c0       	rjmp	.+2      	; 0x48a6 <f_readdir+0x8c>
				dj->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj, 0);		/* Increment index for next */
    48a4:	18 2f       	mov	r17, r24
			FREE_BUF();
		}
	}

	LEAVE_FF(dj->fs, res);
}
    48a6:	81 2f       	mov	r24, r17
    48a8:	2c 96       	adiw	r28, 0x0c	; 12
    48aa:	0f b6       	in	r0, 0x3f	; 63
    48ac:	f8 94       	cli
    48ae:	de bf       	out	0x3e, r29	; 62
    48b0:	0f be       	out	0x3f, r0	; 63
    48b2:	cd bf       	out	0x3d, r28	; 61
    48b4:	df 91       	pop	r29
    48b6:	cf 91       	pop	r28
    48b8:	1f 91       	pop	r17
    48ba:	ff 90       	pop	r15
    48bc:	ef 90       	pop	r14
    48be:	df 90       	pop	r13
    48c0:	cf 90       	pop	r12
    48c2:	08 95       	ret

000048c4 <f_stat>:

FRESULT f_stat (
	const TCHAR *path,	/* Pointer to the file path */
	FILINFO *fno		/* Pointer to file information to return */
)
{
    48c4:	ef 92       	push	r14
    48c6:	ff 92       	push	r15
    48c8:	1f 93       	push	r17
    48ca:	cf 93       	push	r28
    48cc:	df 93       	push	r29
    48ce:	cd b7       	in	r28, 0x3d	; 61
    48d0:	de b7       	in	r29, 0x3e	; 62
    48d2:	a4 97       	sbiw	r28, 0x24	; 36
    48d4:	0f b6       	in	r0, 0x3f	; 63
    48d6:	f8 94       	cli
    48d8:	de bf       	out	0x3e, r29	; 62
    48da:	0f be       	out	0x3f, r0	; 63
    48dc:	cd bf       	out	0x3d, r28	; 61
    48de:	9c a3       	lds	r25, 0x5c
    48e0:	8b a3       	lds	r24, 0x5b
    48e2:	7b 01       	movw	r14, r22
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
    48e4:	ce 01       	movw	r24, r28
    48e6:	83 96       	adiw	r24, 0x23	; 35
    48e8:	be 01       	movw	r22, r28
    48ea:	6f 5f       	subi	r22, 0xFF	; 255
    48ec:	7f 4f       	sbci	r23, 0xFF	; 255
    48ee:	40 e0       	ldi	r20, 0x00	; 0
    48f0:	0e 94 84 0c 	call	0x1908	; 0x1908 <chk_mounted>
    48f4:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    48f6:	88 23       	and	r24, r24
    48f8:	c1 f4       	brne	.+48     	; 0x492a <f_stat+0x66>
		INIT_BUF(dj);
    48fa:	ce 01       	movw	r24, r28
    48fc:	47 96       	adiw	r24, 0x17	; 23
    48fe:	9e 8b       	std	Y+22, r25	; 0x16
    4900:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    4902:	6b a1       	lds	r22, 0x4b
    4904:	7c a1       	lds	r23, 0x4c
    4906:	ce 01       	movw	r24, r28
    4908:	01 96       	adiw	r24, 0x01	; 1
    490a:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <follow_path>
    490e:	18 2f       	mov	r17, r24
		if (res == FR_OK) {				/* Follow completed */
    4910:	88 23       	and	r24, r24
    4912:	59 f4       	brne	.+22     	; 0x492a <f_stat+0x66>
			if (dj.dir)		/* Found an object */
    4914:	8b 89       	ldd	r24, Y+19	; 0x13
    4916:	9c 89       	ldd	r25, Y+20	; 0x14
    4918:	00 97       	sbiw	r24, 0x00	; 0
    491a:	31 f0       	breq	.+12     	; 0x4928 <f_stat+0x64>
				get_fileinfo(&dj, fno);
    491c:	ce 01       	movw	r24, r28
    491e:	01 96       	adiw	r24, 0x01	; 1
    4920:	b7 01       	movw	r22, r14
    4922:	0e 94 35 0b 	call	0x166a	; 0x166a <get_fileinfo>
    4926:	01 c0       	rjmp	.+2      	; 0x492a <f_stat+0x66>
			else			/* It is root dir */
				res = FR_INVALID_NAME;
    4928:	16 e0       	ldi	r17, 0x06	; 6
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    492a:	81 2f       	mov	r24, r17
    492c:	a4 96       	adiw	r28, 0x24	; 36
    492e:	0f b6       	in	r0, 0x3f	; 63
    4930:	f8 94       	cli
    4932:	de bf       	out	0x3e, r29	; 62
    4934:	0f be       	out	0x3f, r0	; 63
    4936:	cd bf       	out	0x3d, r28	; 61
    4938:	df 91       	pop	r29
    493a:	cf 91       	pop	r28
    493c:	1f 91       	pop	r17
    493e:	ff 90       	pop	r15
    4940:	ef 90       	pop	r14
    4942:	08 95       	ret

00004944 <f_getfree>:
FRESULT f_getfree (
	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
)
{
    4944:	2f 92       	push	r2
    4946:	3f 92       	push	r3
    4948:	4f 92       	push	r4
    494a:	5f 92       	push	r5
    494c:	6f 92       	push	r6
    494e:	7f 92       	push	r7
    4950:	8f 92       	push	r8
    4952:	9f 92       	push	r9
    4954:	af 92       	push	r10
    4956:	bf 92       	push	r11
    4958:	cf 92       	push	r12
    495a:	df 92       	push	r13
    495c:	ef 92       	push	r14
    495e:	ff 92       	push	r15
    4960:	0f 93       	push	r16
    4962:	1f 93       	push	r17
    4964:	cf 93       	push	r28
    4966:	df 93       	push	r29
    4968:	cd b7       	in	r28, 0x3d	; 61
    496a:	de b7       	in	r29, 0x3e	; 62
    496c:	2c 97       	sbiw	r28, 0x0c	; 12
    496e:	0f b6       	in	r0, 0x3f	; 63
    4970:	f8 94       	cli
    4972:	de bf       	out	0x3e, r29	; 62
    4974:	0f be       	out	0x3f, r0	; 63
    4976:	cd bf       	out	0x3d, r28	; 61
    4978:	9a 83       	std	Y+2, r25	; 0x02
    497a:	89 83       	std	Y+1, r24	; 0x01
    497c:	78 87       	std	Y+8, r23	; 0x08
    497e:	6f 83       	std	Y+7, r22	; 0x07
    4980:	8a 01       	movw	r16, r20
	UINT i;
	BYTE fat, *p;


	/* Get drive number */
	res = chk_mounted(&path, fatfs, 0);
    4982:	ce 01       	movw	r24, r28
    4984:	01 96       	adiw	r24, 0x01	; 1
    4986:	ba 01       	movw	r22, r20
    4988:	40 e0       	ldi	r20, 0x00	; 0
    498a:	0e 94 84 0c 	call	0x1908	; 0x1908 <chk_mounted>
    498e:	b8 2e       	mov	r11, r24
	fs = *fatfs;
    4990:	d8 01       	movw	r26, r16
    4992:	8d 90       	ld	r8, X+
    4994:	9c 90       	ld	r9, X
    4996:	11 97       	sbiw	r26, 0x01	; 1
	if (res == FR_OK) {
    4998:	88 23       	and	r24, r24
    499a:	09 f0       	breq	.+2      	; 0x499e <f_getfree+0x5a>
    499c:	03 c1       	rjmp	.+518    	; 0x4ba4 <f_getfree+0x260>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
    499e:	f4 01       	movw	r30, r8
    49a0:	86 85       	ldd	r24, Z+14	; 0x0e
    49a2:	97 85       	ldd	r25, Z+15	; 0x0f
    49a4:	a0 89       	ldd	r26, Z+16	; 0x10
    49a6:	b1 89       	ldd	r27, Z+17	; 0x11
    49a8:	c2 8c       	ldd	r12, Z+26	; 0x1a
    49aa:	d3 8c       	ldd	r13, Z+27	; 0x1b
    49ac:	e4 8c       	ldd	r14, Z+28	; 0x1c
    49ae:	f5 8c       	ldd	r15, Z+29	; 0x1d
    49b0:	b7 01       	movw	r22, r14
    49b2:	a6 01       	movw	r20, r12
    49b4:	42 50       	subi	r20, 0x02	; 2
    49b6:	50 40       	sbci	r21, 0x00	; 0
    49b8:	60 40       	sbci	r22, 0x00	; 0
    49ba:	70 40       	sbci	r23, 0x00	; 0
    49bc:	48 17       	cp	r20, r24
    49be:	59 07       	cpc	r21, r25
    49c0:	6a 07       	cpc	r22, r26
    49c2:	7b 07       	cpc	r23, r27
    49c4:	38 f0       	brcs	.+14     	; 0x49d4 <f_getfree+0x90>
			*nclst = fs->free_clust;
    49c6:	ef 81       	ldd	r30, Y+7	; 0x07
    49c8:	f8 85       	ldd	r31, Y+8	; 0x08
    49ca:	80 83       	st	Z, r24
    49cc:	91 83       	std	Z+1, r25	; 0x01
    49ce:	a2 83       	std	Z+2, r26	; 0x02
    49d0:	b3 83       	std	Z+3, r27	; 0x03
    49d2:	e8 c0       	rjmp	.+464    	; 0x4ba4 <f_getfree+0x260>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
    49d4:	a0 80       	ld	r10, Z
			n = 0;
			if (fat == FS_FAT12) {
    49d6:	b1 e0       	ldi	r27, 0x01	; 1
    49d8:	ab 16       	cp	r10, r27
    49da:	d9 f5       	brne	.+118    	; 0x4a52 <f_getfree+0x10e>
    49dc:	cc 24       	eor	r12, r12
    49de:	dd 24       	eor	r13, r13
    49e0:	76 01       	movw	r14, r12
    49e2:	68 94       	set
    49e4:	c1 f8       	bld	r12, 1
    49e6:	44 24       	eor	r4, r4
    49e8:	55 24       	eor	r5, r5
    49ea:	32 01       	movw	r6, r4
				clst = 2;
				do {
					stat = get_fat(fs, clst);
    49ec:	c4 01       	movw	r24, r8
    49ee:	b7 01       	movw	r22, r14
    49f0:	a6 01       	movw	r20, r12
    49f2:	0e 94 21 12 	call	0x2442	; 0x2442 <get_fat>
    49f6:	dc 01       	movw	r26, r24
    49f8:	cb 01       	movw	r24, r22
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
    49fa:	8f 3f       	cpi	r24, 0xFF	; 255
    49fc:	ef ef       	ldi	r30, 0xFF	; 255
    49fe:	9e 07       	cpc	r25, r30
    4a00:	ef ef       	ldi	r30, 0xFF	; 255
    4a02:	ae 07       	cpc	r26, r30
    4a04:	ef ef       	ldi	r30, 0xFF	; 255
    4a06:	be 07       	cpc	r27, r30
    4a08:	09 f4       	brne	.+2      	; 0x4a0c <f_getfree+0xc8>
    4a0a:	b0 c0       	rjmp	.+352    	; 0x4b6c <f_getfree+0x228>
					if (stat == 1) { res = FR_INT_ERR; break; }
    4a0c:	81 30       	cpi	r24, 0x01	; 1
    4a0e:	91 05       	cpc	r25, r1
    4a10:	a1 05       	cpc	r26, r1
    4a12:	b1 05       	cpc	r27, r1
    4a14:	09 f4       	brne	.+2      	; 0x4a18 <f_getfree+0xd4>
    4a16:	ad c0       	rjmp	.+346    	; 0x4b72 <f_getfree+0x22e>
					if (stat == 0) n++;
    4a18:	00 97       	sbiw	r24, 0x00	; 0
    4a1a:	a1 05       	cpc	r26, r1
    4a1c:	b1 05       	cpc	r27, r1
    4a1e:	29 f4       	brne	.+10     	; 0x4a2a <f_getfree+0xe6>
    4a20:	08 94       	sec
    4a22:	41 1c       	adc	r4, r1
    4a24:	51 1c       	adc	r5, r1
    4a26:	61 1c       	adc	r6, r1
    4a28:	71 1c       	adc	r7, r1
				} while (++clst < fs->n_fatent);
    4a2a:	08 94       	sec
    4a2c:	c1 1c       	adc	r12, r1
    4a2e:	d1 1c       	adc	r13, r1
    4a30:	e1 1c       	adc	r14, r1
    4a32:	f1 1c       	adc	r15, r1
    4a34:	f4 01       	movw	r30, r8
    4a36:	82 8d       	ldd	r24, Z+26	; 0x1a
    4a38:	93 8d       	ldd	r25, Z+27	; 0x1b
    4a3a:	a4 8d       	ldd	r26, Z+28	; 0x1c
    4a3c:	b5 8d       	ldd	r27, Z+29	; 0x1d
    4a3e:	c8 16       	cp	r12, r24
    4a40:	d9 06       	cpc	r13, r25
    4a42:	ea 06       	cpc	r14, r26
    4a44:	fb 06       	cpc	r15, r27
    4a46:	90 f2       	brcs	.-92     	; 0x49ec <f_getfree+0xa8>
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
    4a48:	46 86       	std	Z+14, r4	; 0x0e
    4a4a:	57 86       	std	Z+15, r5	; 0x0f
    4a4c:	60 8a       	std	Z+16, r6	; 0x10
    4a4e:	71 8a       	std	Z+17, r7	; 0x11
    4a50:	a2 c0       	rjmp	.+324    	; 0x4b96 <f_getfree+0x252>
					if (stat == 1) { res = FR_INT_ERR; break; }
					if (stat == 0) n++;
				} while (++clst < fs->n_fatent);
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
    4a52:	82 a1       	lds	r24, 0x42
    4a54:	93 a1       	lds	r25, 0x43
    4a56:	a4 a1       	lds	r26, 0x44
    4a58:	b5 a1       	lds	r27, 0x45
    4a5a:	8b 83       	std	Y+3, r24	; 0x03
    4a5c:	9c 83       	std	Y+4, r25	; 0x04
    4a5e:	ad 83       	std	Y+5, r26	; 0x05
    4a60:	be 83       	std	Y+6, r27	; 0x06
				i = 0; p = 0;
    4a62:	e0 e0       	ldi	r30, 0x00	; 0
    4a64:	f0 e0       	ldi	r31, 0x00	; 0
    4a66:	00 e0       	ldi	r16, 0x00	; 0
    4a68:	10 e0       	ldi	r17, 0x00	; 0
    4a6a:	98 01       	movw	r18, r16
		if (fs->free_clust <= fs->n_fatent - 2) {
			*nclst = fs->free_clust;
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
			n = 0;
    4a6c:	44 24       	eor	r4, r4
    4a6e:	55 24       	eor	r5, r5
    4a70:	32 01       	movw	r6, r4
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
    4a72:	a4 01       	movw	r20, r8
    4a74:	4e 5c       	subi	r20, 0xCE	; 206
    4a76:	5f 4f       	sbci	r21, 0xFF	; 255
    4a78:	5c 87       	std	Y+12, r21	; 0x0c
    4a7a:	4b 87       	std	Y+11, r20	; 0x0b
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
    4a7c:	01 15       	cp	r16, r1
    4a7e:	11 05       	cpc	r17, r1
    4a80:	21 05       	cpc	r18, r1
    4a82:	31 05       	cpc	r19, r1
    4a84:	d9 f4       	brne	.+54     	; 0x4abc <f_getfree+0x178>
						res = move_window(fs, sect++);
    4a86:	c4 01       	movw	r24, r8
    4a88:	4b 81       	ldd	r20, Y+3	; 0x03
    4a8a:	5c 81       	ldd	r21, Y+4	; 0x04
    4a8c:	6d 81       	ldd	r22, Y+5	; 0x05
    4a8e:	7e 81       	ldd	r23, Y+6	; 0x06
    4a90:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
						if (res != FR_OK) break;
    4a94:	88 23       	and	r24, r24
    4a96:	09 f0       	breq	.+2      	; 0x4a9a <f_getfree+0x156>
    4a98:	70 c0       	rjmp	.+224    	; 0x4b7a <f_getfree+0x236>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
    4a9a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a9c:	9c 81       	ldd	r25, Y+4	; 0x04
    4a9e:	ad 81       	ldd	r26, Y+5	; 0x05
    4aa0:	be 81       	ldd	r27, Y+6	; 0x06
    4aa2:	01 96       	adiw	r24, 0x01	; 1
    4aa4:	a1 1d       	adc	r26, r1
    4aa6:	b1 1d       	adc	r27, r1
    4aa8:	8b 83       	std	Y+3, r24	; 0x03
    4aaa:	9c 83       	std	Y+4, r25	; 0x04
    4aac:	ad 83       	std	Y+5, r26	; 0x05
    4aae:	be 83       	std	Y+6, r27	; 0x06
						if (res != FR_OK) break;
						p = fs->win;
    4ab0:	eb 85       	ldd	r30, Y+11	; 0x0b
    4ab2:	fc 85       	ldd	r31, Y+12	; 0x0c
						i = SS(fs);
    4ab4:	00 e0       	ldi	r16, 0x00	; 0
    4ab6:	12 e0       	ldi	r17, 0x02	; 2
    4ab8:	20 e0       	ldi	r18, 0x00	; 0
    4aba:	30 e0       	ldi	r19, 0x00	; 0
					}
					if (fat == FS_FAT16) {
    4abc:	92 e0       	ldi	r25, 0x02	; 2
    4abe:	a9 16       	cp	r10, r25
    4ac0:	b1 f4       	brne	.+44     	; 0x4aee <f_getfree+0x1aa>
						if (LD_WORD(p) == 0) n++;
    4ac2:	a1 81       	ldd	r26, Z+1	; 0x01
    4ac4:	aa 87       	std	Y+10, r26	; 0x0a
    4ac6:	19 86       	std	Y+9, r1	; 0x09
    4ac8:	80 81       	ld	r24, Z
    4aca:	90 e0       	ldi	r25, 0x00	; 0
    4acc:	49 85       	ldd	r20, Y+9	; 0x09
    4ace:	5a 85       	ldd	r21, Y+10	; 0x0a
    4ad0:	84 2b       	or	r24, r20
    4ad2:	95 2b       	or	r25, r21
    4ad4:	00 97       	sbiw	r24, 0x00	; 0
    4ad6:	29 f4       	brne	.+10     	; 0x4ae2 <f_getfree+0x19e>
    4ad8:	08 94       	sec
    4ada:	41 1c       	adc	r4, r1
    4adc:	51 1c       	adc	r5, r1
    4ade:	61 1c       	adc	r6, r1
    4ae0:	71 1c       	adc	r7, r1
						p += 2; i -= 2;
    4ae2:	32 96       	adiw	r30, 0x02	; 2
    4ae4:	02 50       	subi	r16, 0x02	; 2
    4ae6:	10 40       	sbci	r17, 0x00	; 0
    4ae8:	20 40       	sbci	r18, 0x00	; 0
    4aea:	30 40       	sbci	r19, 0x00	; 0
    4aec:	33 c0       	rjmp	.+102    	; 0x4b54 <f_getfree+0x210>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
    4aee:	83 81       	ldd	r24, Z+3	; 0x03
    4af0:	90 e0       	ldi	r25, 0x00	; 0
    4af2:	a0 e0       	ldi	r26, 0x00	; 0
    4af4:	b0 e0       	ldi	r27, 0x00	; 0
    4af6:	78 2f       	mov	r23, r24
    4af8:	66 27       	eor	r22, r22
    4afa:	55 27       	eor	r21, r21
    4afc:	44 27       	eor	r20, r20
    4afe:	82 81       	ldd	r24, Z+2	; 0x02
    4b00:	90 e0       	ldi	r25, 0x00	; 0
    4b02:	a0 e0       	ldi	r26, 0x00	; 0
    4b04:	b0 e0       	ldi	r27, 0x00	; 0
    4b06:	dc 01       	movw	r26, r24
    4b08:	99 27       	eor	r25, r25
    4b0a:	88 27       	eor	r24, r24
    4b0c:	48 2b       	or	r20, r24
    4b0e:	59 2b       	or	r21, r25
    4b10:	6a 2b       	or	r22, r26
    4b12:	7b 2b       	or	r23, r27
    4b14:	80 81       	ld	r24, Z
    4b16:	90 e0       	ldi	r25, 0x00	; 0
    4b18:	a0 e0       	ldi	r26, 0x00	; 0
    4b1a:	b0 e0       	ldi	r27, 0x00	; 0
    4b1c:	84 2b       	or	r24, r20
    4b1e:	95 2b       	or	r25, r21
    4b20:	a6 2b       	or	r26, r22
    4b22:	b7 2b       	or	r27, r23
    4b24:	31 80       	ldd	r3, Z+1	; 0x01
    4b26:	22 24       	eor	r2, r2
    4b28:	a1 01       	movw	r20, r2
    4b2a:	60 e0       	ldi	r22, 0x00	; 0
    4b2c:	70 e0       	ldi	r23, 0x00	; 0
    4b2e:	84 2b       	or	r24, r20
    4b30:	95 2b       	or	r25, r21
    4b32:	a6 2b       	or	r26, r22
    4b34:	b7 2b       	or	r27, r23
    4b36:	bf 70       	andi	r27, 0x0F	; 15
    4b38:	00 97       	sbiw	r24, 0x00	; 0
    4b3a:	a1 05       	cpc	r26, r1
    4b3c:	b1 05       	cpc	r27, r1
    4b3e:	29 f4       	brne	.+10     	; 0x4b4a <f_getfree+0x206>
    4b40:	08 94       	sec
    4b42:	41 1c       	adc	r4, r1
    4b44:	51 1c       	adc	r5, r1
    4b46:	61 1c       	adc	r6, r1
    4b48:	71 1c       	adc	r7, r1
						p += 4; i -= 4;
    4b4a:	34 96       	adiw	r30, 0x04	; 4
    4b4c:	04 50       	subi	r16, 0x04	; 4
    4b4e:	10 40       	sbci	r17, 0x00	; 0
    4b50:	20 40       	sbci	r18, 0x00	; 0
    4b52:	30 40       	sbci	r19, 0x00	; 0
					}
				} while (--clst);
    4b54:	08 94       	sec
    4b56:	c1 08       	sbc	r12, r1
    4b58:	d1 08       	sbc	r13, r1
    4b5a:	e1 08       	sbc	r14, r1
    4b5c:	f1 08       	sbc	r15, r1
    4b5e:	c1 14       	cp	r12, r1
    4b60:	d1 04       	cpc	r13, r1
    4b62:	e1 04       	cpc	r14, r1
    4b64:	f1 04       	cpc	r15, r1
    4b66:	09 f0       	breq	.+2      	; 0x4b6a <f_getfree+0x226>
    4b68:	89 cf       	rjmp	.-238    	; 0x4a7c <f_getfree+0x138>
    4b6a:	08 c0       	rjmp	.+16     	; 0x4b7c <f_getfree+0x238>
			n = 0;
			if (fat == FS_FAT12) {
				clst = 2;
				do {
					stat = get_fat(fs, clst);
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
    4b6c:	bb 24       	eor	r11, r11
    4b6e:	b3 94       	inc	r11
    4b70:	05 c0       	rjmp	.+10     	; 0x4b7c <f_getfree+0x238>
					if (stat == 1) { res = FR_INT_ERR; break; }
    4b72:	bb 24       	eor	r11, r11
    4b74:	68 94       	set
    4b76:	b1 f8       	bld	r11, 1
    4b78:	01 c0       	rjmp	.+2      	; 0x4b7c <f_getfree+0x238>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
    4b7a:	b8 2e       	mov	r11, r24
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
    4b7c:	d4 01       	movw	r26, r8
    4b7e:	1e 96       	adiw	r26, 0x0e	; 14
    4b80:	4d 92       	st	X+, r4
    4b82:	5d 92       	st	X+, r5
    4b84:	6d 92       	st	X+, r6
    4b86:	7c 92       	st	X, r7
    4b88:	51 97       	sbiw	r26, 0x11	; 17
			if (fat == FS_FAT32) fs->fsi_flag = 1;
    4b8a:	b3 e0       	ldi	r27, 0x03	; 3
    4b8c:	ab 16       	cp	r10, r27
    4b8e:	19 f4       	brne	.+6      	; 0x4b96 <f_getfree+0x252>
    4b90:	81 e0       	ldi	r24, 0x01	; 1
    4b92:	f4 01       	movw	r30, r8
    4b94:	85 83       	std	Z+5, r24	; 0x05
			*nclst = n;
    4b96:	af 81       	ldd	r26, Y+7	; 0x07
    4b98:	b8 85       	ldd	r27, Y+8	; 0x08
    4b9a:	4d 92       	st	X+, r4
    4b9c:	5d 92       	st	X+, r5
    4b9e:	6d 92       	st	X+, r6
    4ba0:	7c 92       	st	X, r7
    4ba2:	13 97       	sbiw	r26, 0x03	; 3
		}
	}
	LEAVE_FF(fs, res);
}
    4ba4:	8b 2d       	mov	r24, r11
    4ba6:	2c 96       	adiw	r28, 0x0c	; 12
    4ba8:	0f b6       	in	r0, 0x3f	; 63
    4baa:	f8 94       	cli
    4bac:	de bf       	out	0x3e, r29	; 62
    4bae:	0f be       	out	0x3f, r0	; 63
    4bb0:	cd bf       	out	0x3d, r28	; 61
    4bb2:	df 91       	pop	r29
    4bb4:	cf 91       	pop	r28
    4bb6:	1f 91       	pop	r17
    4bb8:	0f 91       	pop	r16
    4bba:	ff 90       	pop	r15
    4bbc:	ef 90       	pop	r14
    4bbe:	df 90       	pop	r13
    4bc0:	cf 90       	pop	r12
    4bc2:	bf 90       	pop	r11
    4bc4:	af 90       	pop	r10
    4bc6:	9f 90       	pop	r9
    4bc8:	8f 90       	pop	r8
    4bca:	7f 90       	pop	r7
    4bcc:	6f 90       	pop	r6
    4bce:	5f 90       	pop	r5
    4bd0:	4f 90       	pop	r4
    4bd2:	3f 90       	pop	r3
    4bd4:	2f 90       	pop	r2
    4bd6:	08 95       	ret

00004bd8 <f_truncate>:
/*-----------------------------------------------------------------------*/

FRESULT f_truncate (
	FIL *fp		/* Pointer to the file object */
)
{
    4bd8:	cf 92       	push	r12
    4bda:	df 92       	push	r13
    4bdc:	ef 92       	push	r14
    4bde:	ff 92       	push	r15
    4be0:	0f 93       	push	r16
    4be2:	1f 93       	push	r17
    4be4:	cf 93       	push	r28
    4be6:	df 93       	push	r29
    4be8:	ec 01       	movw	r28, r24
	FRESULT res;
	DWORD ncl;


	if (!fp) return FR_INVALID_OBJECT;
    4bea:	00 97       	sbiw	r24, 0x00	; 0
    4bec:	09 f4       	brne	.+2      	; 0x4bf0 <f_truncate+0x18>
    4bee:	69 c0       	rjmp	.+210    	; 0x4cc2 <f_truncate+0xea>

	res = validate(fp);						/* Check validity of the object */
    4bf0:	0e 94 c7 0b 	call	0x178e	; 0x178e <validate>
	if (res == FR_OK) {
    4bf4:	88 23       	and	r24, r24
    4bf6:	09 f0       	breq	.+2      	; 0x4bfa <f_truncate+0x22>
    4bf8:	65 c0       	rjmp	.+202    	; 0x4cc4 <f_truncate+0xec>
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
    4bfa:	9c 81       	ldd	r25, Y+4	; 0x04
    4bfc:	99 23       	and	r25, r25
    4bfe:	24 f0       	brlt	.+8      	; 0x4c08 <f_truncate+0x30>
			res = FR_INT_ERR;
		} else {
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
    4c00:	91 fd       	sbrc	r25, 1
    4c02:	69 c0       	rjmp	.+210    	; 0x4cd6 <f_truncate+0xfe>
				res = FR_DENIED;
    4c04:	87 e0       	ldi	r24, 0x07	; 7
    4c06:	5e c0       	rjmp	.+188    	; 0x4cc4 <f_truncate+0xec>
	if (!fp) return FR_INVALID_OBJECT;

	res = validate(fp);						/* Check validity of the object */
	if (res == FR_OK) {
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
			res = FR_INT_ERR;
    4c08:	82 e0       	ldi	r24, 0x02	; 2
    4c0a:	5c c0       	rjmp	.+184    	; 0x4cc4 <f_truncate+0xec>
				res = FR_DENIED;
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
    4c0c:	4a 87       	std	Y+10, r20	; 0x0a
    4c0e:	5b 87       	std	Y+11, r21	; 0x0b
    4c10:	6c 87       	std	Y+12, r22	; 0x0c
    4c12:	7d 87       	std	Y+13, r23	; 0x0d
			fp->flag |= FA__WRITTEN;
    4c14:	8c 81       	ldd	r24, Y+4	; 0x04
    4c16:	80 62       	ori	r24, 0x20	; 32
    4c18:	8c 83       	std	Y+4, r24	; 0x04
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
    4c1a:	41 15       	cp	r20, r1
    4c1c:	51 05       	cpc	r21, r1
    4c1e:	61 05       	cpc	r22, r1
    4c20:	71 05       	cpc	r23, r1
    4c22:	69 f4       	brne	.+26     	; 0x4c3e <f_truncate+0x66>
				res = remove_chain(fp->fs, fp->sclust);
    4c24:	4e 85       	ldd	r20, Y+14	; 0x0e
    4c26:	5f 85       	ldd	r21, Y+15	; 0x0f
    4c28:	68 89       	ldd	r22, Y+16	; 0x10
    4c2a:	79 89       	ldd	r23, Y+17	; 0x11
    4c2c:	88 81       	ld	r24, Y
    4c2e:	99 81       	ldd	r25, Y+1	; 0x01
    4c30:	0e 94 6b 1a 	call	0x34d6	; 0x34d6 <remove_chain>
				fp->sclust = 0;
    4c34:	1e 86       	std	Y+14, r1	; 0x0e
    4c36:	1f 86       	std	Y+15, r1	; 0x0f
    4c38:	18 8a       	std	Y+16, r1	; 0x10
    4c3a:	19 8a       	std	Y+17, r1	; 0x11
    4c3c:	3c c0       	rjmp	.+120    	; 0x4cb6 <f_truncate+0xde>
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
    4c3e:	4a 89       	ldd	r20, Y+18	; 0x12
    4c40:	5b 89       	ldd	r21, Y+19	; 0x13
    4c42:	6c 89       	ldd	r22, Y+20	; 0x14
    4c44:	7d 89       	ldd	r23, Y+21	; 0x15
    4c46:	88 81       	ld	r24, Y
    4c48:	99 81       	ldd	r25, Y+1	; 0x01
    4c4a:	0e 94 21 12 	call	0x2442	; 0x2442 <get_fat>
    4c4e:	6b 01       	movw	r12, r22
    4c50:	7c 01       	movw	r14, r24
				res = FR_OK;
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
    4c52:	81 e0       	ldi	r24, 0x01	; 1
    4c54:	c8 16       	cp	r12, r24
    4c56:	d1 04       	cpc	r13, r1
    4c58:	e1 04       	cpc	r14, r1
    4c5a:	f1 04       	cpc	r15, r1
    4c5c:	09 f4       	brne	.+2      	; 0x4c60 <f_truncate+0x88>
    4c5e:	4a c0       	rjmp	.+148    	; 0x4cf4 <f_truncate+0x11c>
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
				res = remove_chain(fp->fs, fp->sclust);
				fp->sclust = 0;
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
				res = FR_OK;
    4c60:	81 e0       	ldi	r24, 0x01	; 1
    4c62:	9f ef       	ldi	r25, 0xFF	; 255
    4c64:	c9 16       	cp	r12, r25
    4c66:	9f ef       	ldi	r25, 0xFF	; 255
    4c68:	d9 06       	cpc	r13, r25
    4c6a:	9f ef       	ldi	r25, 0xFF	; 255
    4c6c:	e9 06       	cpc	r14, r25
    4c6e:	9f ef       	ldi	r25, 0xFF	; 255
    4c70:	f9 06       	cpc	r15, r25
    4c72:	09 f0       	breq	.+2      	; 0x4c76 <f_truncate+0x9e>
    4c74:	80 e0       	ldi	r24, 0x00	; 0
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
				if (res == FR_OK && ncl < fp->fs->n_fatent) {
    4c76:	88 23       	and	r24, r24
    4c78:	01 f5       	brne	.+64     	; 0x4cba <f_truncate+0xe2>
    4c7a:	e8 81       	ld	r30, Y
    4c7c:	f9 81       	ldd	r31, Y+1	; 0x01
    4c7e:	42 8d       	ldd	r20, Z+26	; 0x1a
    4c80:	53 8d       	ldd	r21, Z+27	; 0x1b
    4c82:	64 8d       	ldd	r22, Z+28	; 0x1c
    4c84:	75 8d       	ldd	r23, Z+29	; 0x1d
    4c86:	c4 16       	cp	r12, r20
    4c88:	d5 06       	cpc	r13, r21
    4c8a:	e6 06       	cpc	r14, r22
    4c8c:	f7 06       	cpc	r15, r23
    4c8e:	d0 f4       	brcc	.+52     	; 0x4cc4 <f_truncate+0xec>
					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
    4c90:	4a 89       	ldd	r20, Y+18	; 0x12
    4c92:	5b 89       	ldd	r21, Y+19	; 0x13
    4c94:	6c 89       	ldd	r22, Y+20	; 0x14
    4c96:	7d 89       	ldd	r23, Y+21	; 0x15
    4c98:	cf 01       	movw	r24, r30
    4c9a:	0f ef       	ldi	r16, 0xFF	; 255
    4c9c:	1f ef       	ldi	r17, 0xFF	; 255
    4c9e:	2f ef       	ldi	r18, 0xFF	; 255
    4ca0:	3f e0       	ldi	r19, 0x0F	; 15
    4ca2:	0e 94 3b 14 	call	0x2876	; 0x2876 <put_fat>
					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
    4ca6:	88 23       	and	r24, r24
    4ca8:	41 f4       	brne	.+16     	; 0x4cba <f_truncate+0xe2>
    4caa:	88 81       	ld	r24, Y
    4cac:	99 81       	ldd	r25, Y+1	; 0x01
    4cae:	b7 01       	movw	r22, r14
    4cb0:	a6 01       	movw	r20, r12
    4cb2:	0e 94 6b 1a 	call	0x34d6	; 0x34d6 <remove_chain>
				}
			}
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
    4cb6:	88 23       	and	r24, r24
    4cb8:	29 f0       	breq	.+10     	; 0x4cc4 <f_truncate+0xec>
    4cba:	9c 81       	ldd	r25, Y+4	; 0x04
    4cbc:	90 68       	ori	r25, 0x80	; 128
    4cbe:	9c 83       	std	Y+4, r25	; 0x04
    4cc0:	01 c0       	rjmp	.+2      	; 0x4cc4 <f_truncate+0xec>
{
	FRESULT res;
	DWORD ncl;


	if (!fp) return FR_INVALID_OBJECT;
    4cc2:	89 e0       	ldi	r24, 0x09	; 9
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
	}

	LEAVE_FF(fp->fs, res);
}
    4cc4:	df 91       	pop	r29
    4cc6:	cf 91       	pop	r28
    4cc8:	1f 91       	pop	r17
    4cca:	0f 91       	pop	r16
    4ccc:	ff 90       	pop	r15
    4cce:	ef 90       	pop	r14
    4cd0:	df 90       	pop	r13
    4cd2:	cf 90       	pop	r12
    4cd4:	08 95       	ret
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
				res = FR_DENIED;
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
    4cd6:	4e 81       	ldd	r20, Y+6	; 0x06
    4cd8:	5f 81       	ldd	r21, Y+7	; 0x07
    4cda:	68 85       	ldd	r22, Y+8	; 0x08
    4cdc:	79 85       	ldd	r23, Y+9	; 0x09
    4cde:	0a 85       	ldd	r16, Y+10	; 0x0a
    4ce0:	1b 85       	ldd	r17, Y+11	; 0x0b
    4ce2:	2c 85       	ldd	r18, Y+12	; 0x0c
    4ce4:	3d 85       	ldd	r19, Y+13	; 0x0d
    4ce6:	40 17       	cp	r20, r16
    4ce8:	51 07       	cpc	r21, r17
    4cea:	62 07       	cpc	r22, r18
    4cec:	73 07       	cpc	r23, r19
    4cee:	08 f4       	brcc	.+2      	; 0x4cf2 <f_truncate+0x11a>
    4cf0:	8d cf       	rjmp	.-230    	; 0x4c0c <f_truncate+0x34>
    4cf2:	e8 cf       	rjmp	.-48     	; 0x4cc4 <f_truncate+0xec>
				fp->sclust = 0;
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
				res = FR_OK;
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
    4cf4:	82 e0       	ldi	r24, 0x02	; 2
    4cf6:	e1 cf       	rjmp	.-62     	; 0x4cba <f_truncate+0xe2>

00004cf8 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR *path		/* Pointer to the file or directory path */
)
{
    4cf8:	cf 92       	push	r12
    4cfa:	df 92       	push	r13
    4cfc:	ef 92       	push	r14
    4cfe:	ff 92       	push	r15
    4d00:	1f 93       	push	r17
    4d02:	cf 93       	push	r28
    4d04:	df 93       	push	r29
    4d06:	cd b7       	in	r28, 0x3d	; 61
    4d08:	de b7       	in	r29, 0x3e	; 62
    4d0a:	ea 97       	sbiw	r28, 0x3a	; 58
    4d0c:	0f b6       	in	r0, 0x3f	; 63
    4d0e:	f8 94       	cli
    4d10:	de bf       	out	0x3e, r29	; 62
    4d12:	0f be       	out	0x3f, r0	; 63
    4d14:	cd bf       	out	0x3d, r28	; 61
    4d16:	9a af       	sts	0x7a, r25
    4d18:	89 af       	sts	0x79, r24
	BYTE *dir;
	DWORD dclst;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4d1a:	ce 01       	movw	r24, r28
    4d1c:	c9 96       	adiw	r24, 0x39	; 57
    4d1e:	be 01       	movw	r22, r28
    4d20:	6f 5f       	subi	r22, 0xFF	; 255
    4d22:	7f 4f       	sbci	r23, 0xFF	; 255
    4d24:	41 e0       	ldi	r20, 0x01	; 1
    4d26:	0e 94 84 0c 	call	0x1908	; 0x1908 <chk_mounted>
	if (res == FR_OK) {
    4d2a:	88 23       	and	r24, r24
    4d2c:	09 f0       	breq	.+2      	; 0x4d30 <f_unlink+0x38>
    4d2e:	63 c0       	rjmp	.+198    	; 0x4df6 <f_unlink+0xfe>
		INIT_BUF(dj);
    4d30:	ce 01       	movw	r24, r28
    4d32:	8d 96       	adiw	r24, 0x2d	; 45
    4d34:	9e 8b       	std	Y+22, r25	; 0x16
    4d36:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the file path */
    4d38:	69 ad       	sts	0x69, r22
    4d3a:	7a ad       	sts	0x6a, r23
    4d3c:	ce 01       	movw	r24, r28
    4d3e:	01 96       	adiw	r24, 0x01	; 1
    4d40:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <follow_path>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    4d44:	88 23       	and	r24, r24
    4d46:	09 f0       	breq	.+2      	; 0x4d4a <f_unlink+0x52>
    4d48:	56 c0       	rjmp	.+172    	; 0x4df6 <f_unlink+0xfe>
    4d4a:	ed 89       	ldd	r30, Y+21	; 0x15
    4d4c:	fe 89       	ldd	r31, Y+22	; 0x16
    4d4e:	83 85       	ldd	r24, Z+11	; 0x0b
    4d50:	85 ff       	sbrs	r24, 5
    4d52:	5f c0       	rjmp	.+190    	; 0x4e12 <f_unlink+0x11a>
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
    4d54:	86 e0       	ldi	r24, 0x06	; 6
    4d56:	4f c0       	rjmp	.+158    	; 0x4df6 <f_unlink+0xfe>
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
    4d58:	fb 01       	movw	r30, r22
    4d5a:	13 85       	ldd	r17, Z+11	; 0x0b
    4d5c:	10 ff       	sbrs	r17, 0
    4d5e:	60 c0       	rjmp	.+192    	; 0x4e20 <f_unlink+0x128>
					res = FR_DENIED;		/* Cannot remove R/O object */
    4d60:	87 e0       	ldi	r24, 0x07	; 7
    4d62:	49 c0       	rjmp	.+146    	; 0x4df6 <f_unlink+0xfe>
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
    4d64:	86 e0       	ldi	r24, 0x06	; 6
    4d66:	47 c0       	rjmp	.+142    	; 0x4df6 <f_unlink+0xfe>
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = ld_clust(dj.fs, dir);
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
				if (dclst < 2) {
    4d68:	f2 e0       	ldi	r31, 0x02	; 2
    4d6a:	cf 16       	cp	r12, r31
    4d6c:	d1 04       	cpc	r13, r1
    4d6e:	e1 04       	cpc	r14, r1
    4d70:	f1 04       	cpc	r15, r1
    4d72:	08 f4       	brcc	.+2      	; 0x4d76 <f_unlink+0x7e>
    4d74:	5e c0       	rjmp	.+188    	; 0x4e32 <f_unlink+0x13a>
					res = FR_INT_ERR;
				} else {
					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
    4d76:	ce 01       	movw	r24, r28
    4d78:	47 96       	adiw	r24, 0x17	; 23
    4d7a:	be 01       	movw	r22, r28
    4d7c:	6f 5f       	subi	r22, 0xFF	; 255
    4d7e:	7f 4f       	sbci	r23, 0xFF	; 255
    4d80:	26 e1       	ldi	r18, 0x16	; 22
    4d82:	30 e0       	ldi	r19, 0x00	; 0
    4d84:	40 e0       	ldi	r20, 0x00	; 0
    4d86:	50 e0       	ldi	r21, 0x00	; 0
    4d88:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <mem_cpy>
					sdj.sclust = dclst;
    4d8c:	cd 8e       	std	Y+29, r12	; 0x1d
    4d8e:	de 8e       	std	Y+30, r13	; 0x1e
    4d90:	ef 8e       	std	Y+31, r14	; 0x1f
    4d92:	f8 a2       	lds	r31, 0x98
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
    4d94:	ce 01       	movw	r24, r28
    4d96:	47 96       	adiw	r24, 0x17	; 23
    4d98:	62 e0       	ldi	r22, 0x02	; 2
    4d9a:	70 e0       	ldi	r23, 0x00	; 0
    4d9c:	0e 94 58 13 	call	0x26b0	; 0x26b0 <dir_sdi>
					if (res == FR_OK) {
    4da0:	88 23       	and	r24, r24
    4da2:	49 f5       	brne	.+82     	; 0x4df6 <f_unlink+0xfe>
						res = dir_read(&sdj);
    4da4:	ce 01       	movw	r24, r28
    4da6:	47 96       	adiw	r24, 0x17	; 23
    4da8:	0e 94 3b 1a 	call	0x3476	; 0x3476 <dir_read>
						if (res == FR_OK		/* Not empty dir */
    4dac:	88 23       	and	r24, r24
    4dae:	71 f0       	breq	.+28     	; 0x4dcc <f_unlink+0xd4>
#if _FS_RPATH
						|| dclst == dj.fs->cdir	/* Current dir */
    4db0:	e9 81       	ldd	r30, Y+1	; 0x01
    4db2:	fa 81       	ldd	r31, Y+2	; 0x02
    4db4:	46 89       	ldd	r20, Z+22	; 0x16
    4db6:	57 89       	ldd	r21, Z+23	; 0x17
    4db8:	60 8d       	ldd	r22, Z+24	; 0x18
    4dba:	71 8d       	ldd	r23, Z+25	; 0x19
    4dbc:	4c 15       	cp	r20, r12
    4dbe:	5d 05       	cpc	r21, r13
    4dc0:	6e 05       	cpc	r22, r14
    4dc2:	7f 05       	cpc	r23, r15
    4dc4:	29 f0       	breq	.+10     	; 0x4dd0 <f_unlink+0xd8>
#endif
						) res = FR_DENIED;
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
    4dc6:	84 30       	cpi	r24, 0x04	; 4
    4dc8:	b1 f1       	breq	.+108    	; 0x4e36 <f_unlink+0x13e>
    4dca:	15 c0       	rjmp	.+42     	; 0x4df6 <f_unlink+0xfe>
					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
					sdj.sclust = dclst;
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
					if (res == FR_OK) {
						res = dir_read(&sdj);
						if (res == FR_OK		/* Not empty dir */
    4dcc:	87 e0       	ldi	r24, 0x07	; 7
    4dce:	13 c0       	rjmp	.+38     	; 0x4df6 <f_unlink+0xfe>
#if _FS_RPATH
						|| dclst == dj.fs->cdir	/* Current dir */
    4dd0:	87 e0       	ldi	r24, 0x07	; 7
    4dd2:	11 c0       	rjmp	.+34     	; 0x4df6 <f_unlink+0xfe>
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
				if (res == FR_OK) {
					if (dclst)				/* Remove the cluster chain if exist */
    4dd4:	c1 14       	cp	r12, r1
    4dd6:	d1 04       	cpc	r13, r1
    4dd8:	e1 04       	cpc	r14, r1
    4dda:	f1 04       	cpc	r15, r1
    4ddc:	41 f0       	breq	.+16     	; 0x4dee <f_unlink+0xf6>
						res = remove_chain(dj.fs, dclst);
    4dde:	89 81       	ldd	r24, Y+1	; 0x01
    4de0:	9a 81       	ldd	r25, Y+2	; 0x02
    4de2:	b7 01       	movw	r22, r14
    4de4:	a6 01       	movw	r20, r12
    4de6:	0e 94 6b 1a 	call	0x34d6	; 0x34d6 <remove_chain>
					if (res == FR_OK) res = sync(dj.fs);
    4dea:	88 23       	and	r24, r24
    4dec:	21 f4       	brne	.+8      	; 0x4df6 <f_unlink+0xfe>
    4dee:	89 81       	ldd	r24, Y+1	; 0x01
    4df0:	9a 81       	ldd	r25, Y+2	; 0x02
    4df2:	0e 94 59 11 	call	0x22b2	; 0x22b2 <sync>
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(dj.fs, res);
}
    4df6:	ea 96       	adiw	r28, 0x3a	; 58
    4df8:	0f b6       	in	r0, 0x3f	; 63
    4dfa:	f8 94       	cli
    4dfc:	de bf       	out	0x3e, r29	; 62
    4dfe:	0f be       	out	0x3f, r0	; 63
    4e00:	cd bf       	out	0x3d, r28	; 61
    4e02:	df 91       	pop	r29
    4e04:	cf 91       	pop	r28
    4e06:	1f 91       	pop	r17
    4e08:	ff 90       	pop	r15
    4e0a:	ef 90       	pop	r14
    4e0c:	df 90       	pop	r13
    4e0e:	cf 90       	pop	r12
    4e10:	08 95       	ret
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
    4e12:	6b 89       	ldd	r22, Y+19	; 0x13
    4e14:	7c 89       	ldd	r23, Y+20	; 0x14
			if (!dir) {
    4e16:	61 15       	cp	r22, r1
    4e18:	71 05       	cpc	r23, r1
    4e1a:	09 f0       	breq	.+2      	; 0x4e1e <f_unlink+0x126>
    4e1c:	9d cf       	rjmp	.-198    	; 0x4d58 <f_unlink+0x60>
    4e1e:	a2 cf       	rjmp	.-188    	; 0x4d64 <f_unlink+0x6c>
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = ld_clust(dj.fs, dir);
    4e20:	89 81       	ldd	r24, Y+1	; 0x01
    4e22:	9a 81       	ldd	r25, Y+2	; 0x02
    4e24:	0e 94 07 0b 	call	0x160e	; 0x160e <ld_clust>
    4e28:	6b 01       	movw	r12, r22
    4e2a:	7c 01       	movw	r14, r24
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
    4e2c:	14 fd       	sbrc	r17, 4
    4e2e:	9c cf       	rjmp	.-200    	; 0x4d68 <f_unlink+0x70>
    4e30:	02 c0       	rjmp	.+4      	; 0x4e36 <f_unlink+0x13e>
				if (dclst < 2) {
					res = FR_INT_ERR;
    4e32:	82 e0       	ldi	r24, 0x02	; 2
    4e34:	e0 cf       	rjmp	.-64     	; 0x4df6 <f_unlink+0xfe>
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
    4e36:	ce 01       	movw	r24, r28
    4e38:	01 96       	adiw	r24, 0x01	; 1
    4e3a:	0e 94 1d 14 	call	0x283a	; 0x283a <dir_remove>
				if (res == FR_OK) {
    4e3e:	88 23       	and	r24, r24
    4e40:	49 f2       	breq	.-110    	; 0x4dd4 <f_unlink+0xdc>
    4e42:	d9 cf       	rjmp	.-78     	; 0x4df6 <f_unlink+0xfe>

00004e44 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR *path		/* Pointer to the directory path */
)
{
    4e44:	2f 92       	push	r2
    4e46:	3f 92       	push	r3
    4e48:	4f 92       	push	r4
    4e4a:	5f 92       	push	r5
    4e4c:	6f 92       	push	r6
    4e4e:	7f 92       	push	r7
    4e50:	8f 92       	push	r8
    4e52:	9f 92       	push	r9
    4e54:	af 92       	push	r10
    4e56:	bf 92       	push	r11
    4e58:	cf 92       	push	r12
    4e5a:	df 92       	push	r13
    4e5c:	ef 92       	push	r14
    4e5e:	ff 92       	push	r15
    4e60:	0f 93       	push	r16
    4e62:	1f 93       	push	r17
    4e64:	cf 93       	push	r28
    4e66:	df 93       	push	r29
    4e68:	cd b7       	in	r28, 0x3d	; 61
    4e6a:	de b7       	in	r29, 0x3e	; 62
    4e6c:	a8 97       	sbiw	r28, 0x28	; 40
    4e6e:	0f b6       	in	r0, 0x3f	; 63
    4e70:	f8 94       	cli
    4e72:	de bf       	out	0x3e, r29	; 62
    4e74:	0f be       	out	0x3f, r0	; 63
    4e76:	cd bf       	out	0x3d, r28	; 61
    4e78:	9c a3       	lds	r25, 0x5c
    4e7a:	8b a3       	lds	r24, 0x5b
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tim = get_fattime();
    4e7c:	0e 94 e7 11 	call	0x23ce	; 0x23ce <get_fattime>
    4e80:	6b 01       	movw	r12, r22
    4e82:	7c 01       	movw	r14, r24
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4e84:	ce 01       	movw	r24, r28
    4e86:	83 96       	adiw	r24, 0x23	; 35
    4e88:	be 01       	movw	r22, r28
    4e8a:	6f 5f       	subi	r22, 0xFF	; 255
    4e8c:	7f 4f       	sbci	r23, 0xFF	; 255
    4e8e:	41 e0       	ldi	r20, 0x01	; 1
    4e90:	0e 94 84 0c 	call	0x1908	; 0x1908 <chk_mounted>
    4e94:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    4e96:	88 23       	and	r24, r24
    4e98:	09 f0       	breq	.+2      	; 0x4e9c <f_mkdir+0x58>
    4e9a:	f6 c0       	rjmp	.+492    	; 0x5088 <f_mkdir+0x244>
		INIT_BUF(dj);
    4e9c:	ce 01       	movw	r24, r28
    4e9e:	47 96       	adiw	r24, 0x17	; 23
    4ea0:	9e 8b       	std	Y+22, r25	; 0x16
    4ea2:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);			/* Follow the file path */
    4ea4:	6b a1       	lds	r22, 0x4b
    4ea6:	7c a1       	lds	r23, 0x4c
    4ea8:	ce 01       	movw	r24, r28
    4eaa:	01 96       	adiw	r24, 0x01	; 1
    4eac:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <follow_path>
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
    4eb0:	88 23       	and	r24, r24
    4eb2:	49 f0       	breq	.+18     	; 0x4ec6 <f_mkdir+0x82>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
    4eb4:	84 30       	cpi	r24, 0x04	; 4
    4eb6:	41 f4       	brne	.+16     	; 0x4ec8 <f_mkdir+0x84>
    4eb8:	ed 89       	ldd	r30, Y+21	; 0x15
    4eba:	fe 89       	ldd	r31, Y+22	; 0x16
    4ebc:	83 85       	ldd	r24, Z+11	; 0x0b
    4ebe:	85 ff       	sbrs	r24, 5
    4ec0:	fd c0       	rjmp	.+506    	; 0x50bc <f_mkdir+0x278>
			res = FR_INVALID_NAME;
    4ec2:	86 e0       	ldi	r24, 0x06	; 6
    4ec4:	01 c0       	rjmp	.+2      	; 0x4ec8 <f_mkdir+0x84>

	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
    4ec6:	88 e0       	ldi	r24, 0x08	; 8
				ST_DWORD(dir+DIR_WrtTime, tim);
				st_clust(dir, dcl);
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
    4ec8:	18 2f       	mov	r17, r24
    4eca:	de c0       	rjmp	.+444    	; 0x5088 <f_mkdir+0x244>
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
			if (dcl == 1) res = FR_INT_ERR;
    4ecc:	81 e0       	ldi	r24, 0x01	; 1
    4ece:	48 16       	cp	r4, r24
    4ed0:	51 04       	cpc	r5, r1
    4ed2:	61 04       	cpc	r6, r1
    4ed4:	71 04       	cpc	r7, r1
    4ed6:	09 f4       	brne	.+2      	; 0x4eda <f_mkdir+0x96>
    4ed8:	01 c1       	rjmp	.+514    	; 0x50dc <f_mkdir+0x298>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
    4eda:	ef ef       	ldi	r30, 0xFF	; 255
    4edc:	4e 16       	cp	r4, r30
    4ede:	ef ef       	ldi	r30, 0xFF	; 255
    4ee0:	5e 06       	cpc	r5, r30
    4ee2:	ef ef       	ldi	r30, 0xFF	; 255
    4ee4:	6e 06       	cpc	r6, r30
    4ee6:	ef ef       	ldi	r30, 0xFF	; 255
    4ee8:	7e 06       	cpc	r7, r30
    4eea:	09 f4       	brne	.+2      	; 0x4eee <f_mkdir+0xaa>
    4eec:	f9 c0       	rjmp	.+498    	; 0x50e0 <f_mkdir+0x29c>
    4eee:	01 c0       	rjmp	.+2      	; 0x4ef2 <f_mkdir+0xae>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
    4ef0:	17 e0       	ldi	r17, 0x07	; 7
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
			if (res == FR_OK)					/* Flush FAT */
    4ef2:	11 23       	and	r17, r17
    4ef4:	09 f0       	breq	.+2      	; 0x4ef8 <f_mkdir+0xb4>
    4ef6:	a8 c0       	rjmp	.+336    	; 0x5048 <f_mkdir+0x204>
				res = move_window(dj.fs, 0);
    4ef8:	89 81       	ldd	r24, Y+1	; 0x01
    4efa:	9a 81       	ldd	r25, Y+2	; 0x02
    4efc:	40 e0       	ldi	r20, 0x00	; 0
    4efe:	50 e0       	ldi	r21, 0x00	; 0
    4f00:	ba 01       	movw	r22, r20
    4f02:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
    4f06:	18 2f       	mov	r17, r24
			if (res == FR_OK) {					/* Initialize the new directory table */
    4f08:	88 23       	and	r24, r24
    4f0a:	09 f0       	breq	.+2      	; 0x4f0e <f_mkdir+0xca>
    4f0c:	9d c0       	rjmp	.+314    	; 0x5048 <f_mkdir+0x204>
				dsc = clust2sect(dj.fs, dcl);
    4f0e:	09 81       	ldd	r16, Y+1	; 0x01
    4f10:	1a 81       	ldd	r17, Y+2	; 0x02
    4f12:	c8 01       	movw	r24, r16
    4f14:	b3 01       	movw	r22, r6
    4f16:	a2 01       	movw	r20, r4
    4f18:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <clust2sect>
    4f1c:	4b 01       	movw	r8, r22
    4f1e:	5c 01       	movw	r10, r24
				dir = dj.fs->win;
    4f20:	0f 2e       	mov	r0, r31
    4f22:	f2 e3       	ldi	r31, 0x32	; 50
    4f24:	2f 2e       	mov	r2, r31
    4f26:	33 24       	eor	r3, r3
    4f28:	f0 2d       	mov	r31, r0
    4f2a:	20 0e       	add	r2, r16
    4f2c:	31 1e       	adc	r3, r17
				mem_set(dir, 0, SS(dj.fs));
    4f2e:	c1 01       	movw	r24, r2
    4f30:	60 e0       	ldi	r22, 0x00	; 0
    4f32:	70 e0       	ldi	r23, 0x00	; 0
    4f34:	20 e0       	ldi	r18, 0x00	; 0
    4f36:	32 e0       	ldi	r19, 0x02	; 2
    4f38:	40 e0       	ldi	r20, 0x00	; 0
    4f3a:	50 e0       	ldi	r21, 0x00	; 0
    4f3c:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <mem_set>
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
    4f40:	c1 01       	movw	r24, r2
    4f42:	60 e2       	ldi	r22, 0x20	; 32
    4f44:	70 e0       	ldi	r23, 0x00	; 0
    4f46:	2b e0       	ldi	r18, 0x0B	; 11
    4f48:	30 e0       	ldi	r19, 0x00	; 0
    4f4a:	40 e0       	ldi	r20, 0x00	; 0
    4f4c:	50 e0       	ldi	r21, 0x00	; 0
    4f4e:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <mem_set>
				dir[DIR_Name] = '.';
    4f52:	8e e2       	ldi	r24, 0x2E	; 46
    4f54:	f8 01       	movw	r30, r16
    4f56:	82 ab       	sts	0x52, r24
				dir[DIR_Attr] = AM_DIR;
    4f58:	80 e1       	ldi	r24, 0x10	; 16
    4f5a:	85 af       	sts	0x75, r24
				ST_DWORD(dir+DIR_WrtTime, tim);
    4f5c:	cd a2       	lds	r28, 0x9d
    4f5e:	e8 5b       	subi	r30, 0xB8	; 184
    4f60:	ff 4f       	sbci	r31, 0xFF	; 255
    4f62:	c0 82       	st	Z, r12
    4f64:	8d 2d       	mov	r24, r13
    4f66:	99 27       	eor	r25, r25
    4f68:	8e a3       	lds	r24, 0x5e
    4f6a:	f8 01       	movw	r30, r16
    4f6c:	e7 5b       	subi	r30, 0xB7	; 183
    4f6e:	ff 4f       	sbci	r31, 0xFF	; 255
    4f70:	80 83       	st	Z, r24
    4f72:	c7 01       	movw	r24, r14
    4f74:	aa 27       	eor	r26, r26
    4f76:	bb 27       	eor	r27, r27
    4f78:	8f a3       	lds	r24, 0x5f
    4f7a:	f8 01       	movw	r30, r16
    4f7c:	e6 5b       	subi	r30, 0xB6	; 182
    4f7e:	ff 4f       	sbci	r31, 0xFF	; 255
    4f80:	80 83       	st	Z, r24
    4f82:	cf 2c       	mov	r12, r15
    4f84:	dd 24       	eor	r13, r13
    4f86:	ee 24       	eor	r14, r14
    4f88:	ff 24       	eor	r15, r15
    4f8a:	c8 a6       	lds	r28, 0xb8
    4f8c:	f8 01       	movw	r30, r16
    4f8e:	e5 5b       	subi	r30, 0xB5	; 181
    4f90:	ff 4f       	sbci	r31, 0xFF	; 255
    4f92:	c0 82       	st	Z, r12
				st_clust(dir, dcl);
    4f94:	c1 01       	movw	r24, r2
    4f96:	b3 01       	movw	r22, r6
    4f98:	a2 01       	movw	r20, r4
    4f9a:	0e 94 2c 0b 	call	0x1658	; 0x1658 <st_clust>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
    4f9e:	0f 2e       	mov	r0, r31
    4fa0:	f2 e5       	ldi	r31, 0x52	; 82
    4fa2:	cf 2e       	mov	r12, r31
    4fa4:	dd 24       	eor	r13, r13
    4fa6:	f0 2d       	mov	r31, r0
    4fa8:	c0 0e       	add	r12, r16
    4faa:	d1 1e       	adc	r13, r17
    4fac:	c6 01       	movw	r24, r12
    4fae:	b1 01       	movw	r22, r2
    4fb0:	20 e2       	ldi	r18, 0x20	; 32
    4fb2:	30 e0       	ldi	r19, 0x00	; 0
    4fb4:	40 e0       	ldi	r20, 0x00	; 0
    4fb6:	50 e0       	ldi	r21, 0x00	; 0
    4fb8:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <mem_cpy>
				dir[33] = '.'; pcl = dj.sclust;
    4fbc:	f8 01       	movw	r30, r16
    4fbe:	ed 5a       	subi	r30, 0xAD	; 173
    4fc0:	ff 4f       	sbci	r31, 0xFF	; 255
    4fc2:	8e e2       	ldi	r24, 0x2E	; 46
    4fc4:	80 83       	st	Z, r24
    4fc6:	4f 81       	ldd	r20, Y+7	; 0x07
    4fc8:	58 85       	ldd	r21, Y+8	; 0x08
    4fca:	69 85       	ldd	r22, Y+9	; 0x09
    4fcc:	7a 85       	ldd	r23, Y+10	; 0x0a
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
    4fce:	e9 81       	ldd	r30, Y+1	; 0x01
    4fd0:	fa 81       	ldd	r31, Y+2	; 0x02
    4fd2:	80 81       	ld	r24, Z
    4fd4:	83 30       	cpi	r24, 0x03	; 3
    4fd6:	61 f4       	brne	.+24     	; 0x4ff0 <f_mkdir+0x1ac>
    4fd8:	86 a1       	lds	r24, 0x46
    4fda:	97 a1       	lds	r25, 0x47
    4fdc:	a0 a5       	lds	r26, 0x60
    4fde:	b1 a5       	lds	r27, 0x61
    4fe0:	84 17       	cp	r24, r20
    4fe2:	95 07       	cpc	r25, r21
    4fe4:	a6 07       	cpc	r26, r22
    4fe6:	b7 07       	cpc	r27, r23
    4fe8:	19 f4       	brne	.+6      	; 0x4ff0 <f_mkdir+0x1ac>
					pcl = 0;
    4fea:	40 e0       	ldi	r20, 0x00	; 0
    4fec:	50 e0       	ldi	r21, 0x00	; 0
    4fee:	ba 01       	movw	r22, r20
				st_clust(dir+SZ_DIR, pcl);
    4ff0:	c6 01       	movw	r24, r12
    4ff2:	0e 94 2c 0b 	call	0x1658	; 0x1658 <st_clust>
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
    4ff6:	e9 81       	ldd	r30, Y+1	; 0x01
    4ff8:	fa 81       	ldd	r31, Y+2	; 0x02
    4ffa:	02 81       	ldd	r16, Z+2	; 0x02
    4ffc:	00 23       	and	r16, r16
    4ffe:	09 f4       	brne	.+2      	; 0x5002 <f_mkdir+0x1be>
    5000:	71 c0       	rjmp	.+226    	; 0x50e4 <f_mkdir+0x2a0>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
    5002:	cc 24       	eor	r12, r12
    5004:	c3 94       	inc	r12
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
    5006:	89 81       	ldd	r24, Y+1	; 0x01
    5008:	9a 81       	ldd	r25, Y+2	; 0x02
    500a:	fc 01       	movw	r30, r24
    500c:	86 a6       	lds	r24, 0xb6
    500e:	97 a6       	lds	r25, 0xb7
    5010:	a0 aa       	sts	0x90, r26
    5012:	b1 aa       	sts	0x91, r27
    5014:	08 94       	sec
    5016:	81 1c       	adc	r8, r1
    5018:	91 1c       	adc	r9, r1
    501a:	a1 1c       	adc	r10, r1
    501c:	b1 1c       	adc	r11, r1
					dj.fs->wflag = 1;
    501e:	c4 82       	std	Z+4, r12	; 0x04
					res = move_window(dj.fs, 0);
    5020:	40 e0       	ldi	r20, 0x00	; 0
    5022:	50 e0       	ldi	r21, 0x00	; 0
    5024:	ba 01       	movw	r22, r20
    5026:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
    502a:	18 2f       	mov	r17, r24
					if (res != FR_OK) break;
    502c:	88 23       	and	r24, r24
    502e:	61 f4       	brne	.+24     	; 0x5048 <f_mkdir+0x204>
					mem_set(dir, 0, SS(dj.fs));
    5030:	c1 01       	movw	r24, r2
    5032:	60 e0       	ldi	r22, 0x00	; 0
    5034:	70 e0       	ldi	r23, 0x00	; 0
    5036:	20 e0       	ldi	r18, 0x00	; 0
    5038:	32 e0       	ldi	r19, 0x02	; 2
    503a:	40 e0       	ldi	r20, 0x00	; 0
    503c:	50 e0       	ldi	r21, 0x00	; 0
    503e:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <mem_set>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
    5042:	01 50       	subi	r16, 0x01	; 1
    5044:	01 f7       	brne	.-64     	; 0x5006 <f_mkdir+0x1c2>
    5046:	4e c0       	rjmp	.+156    	; 0x50e4 <f_mkdir+0x2a0>
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
    5048:	89 81       	ldd	r24, Y+1	; 0x01
    504a:	9a 81       	ldd	r25, Y+2	; 0x02
    504c:	b3 01       	movw	r22, r6
    504e:	a2 01       	movw	r20, r4
    5050:	0e 94 6b 1a 	call	0x34d6	; 0x34d6 <remove_chain>
    5054:	19 c0       	rjmp	.+50     	; 0x5088 <f_mkdir+0x244>
			} else {
				dir = dj.dir;
    5056:	eb 89       	ldd	r30, Y+19	; 0x13
    5058:	fc 89       	ldd	r31, Y+20	; 0x14
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
    505a:	80 e1       	ldi	r24, 0x10	; 16
    505c:	83 87       	std	Z+11, r24	; 0x0b
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
    505e:	8d a1       	lds	r24, 0x4d
    5060:	86 8b       	std	Z+22, r24	; 0x16
    5062:	8e a1       	lds	r24, 0x4e
    5064:	87 8b       	std	Z+23, r24	; 0x17
    5066:	8f a1       	lds	r24, 0x4f
    5068:	80 8f       	std	Z+24, r24	; 0x18
    506a:	88 a5       	lds	r24, 0x68
    506c:	81 8f       	std	Z+25, r24	; 0x19
				st_clust(dir, dcl);					/* Table start cluster */
    506e:	cf 01       	movw	r24, r30
    5070:	b3 01       	movw	r22, r6
    5072:	a2 01       	movw	r20, r4
    5074:	0e 94 2c 0b 	call	0x1658	; 0x1658 <st_clust>
				dj.fs->wflag = 1;
    5078:	89 81       	ldd	r24, Y+1	; 0x01
    507a:	9a 81       	ldd	r25, Y+2	; 0x02
    507c:	21 e0       	ldi	r18, 0x01	; 1
    507e:	fc 01       	movw	r30, r24
    5080:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    5082:	0e 94 59 11 	call	0x22b2	; 0x22b2 <sync>
    5086:	18 2f       	mov	r17, r24
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    5088:	81 2f       	mov	r24, r17
    508a:	a8 96       	adiw	r28, 0x28	; 40
    508c:	0f b6       	in	r0, 0x3f	; 63
    508e:	f8 94       	cli
    5090:	de bf       	out	0x3e, r29	; 62
    5092:	0f be       	out	0x3f, r0	; 63
    5094:	cd bf       	out	0x3d, r28	; 61
    5096:	df 91       	pop	r29
    5098:	cf 91       	pop	r28
    509a:	1f 91       	pop	r17
    509c:	0f 91       	pop	r16
    509e:	ff 90       	pop	r15
    50a0:	ef 90       	pop	r14
    50a2:	df 90       	pop	r13
    50a4:	cf 90       	pop	r12
    50a6:	bf 90       	pop	r11
    50a8:	af 90       	pop	r10
    50aa:	9f 90       	pop	r9
    50ac:	8f 90       	pop	r8
    50ae:	7f 90       	pop	r7
    50b0:	6f 90       	pop	r6
    50b2:	5f 90       	pop	r5
    50b4:	4f 90       	pop	r4
    50b6:	3f 90       	pop	r3
    50b8:	2f 90       	pop	r2
    50ba:	08 95       	ret
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
    50bc:	89 81       	ldd	r24, Y+1	; 0x01
    50be:	9a 81       	ldd	r25, Y+2	; 0x02
    50c0:	40 e0       	ldi	r20, 0x00	; 0
    50c2:	50 e0       	ldi	r21, 0x00	; 0
    50c4:	ba 01       	movw	r22, r20
    50c6:	0e 94 4a 15 	call	0x2a94	; 0x2a94 <create_chain>
    50ca:	2b 01       	movw	r4, r22
    50cc:	3c 01       	movw	r6, r24
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
    50ce:	61 15       	cp	r22, r1
    50d0:	71 05       	cpc	r23, r1
    50d2:	81 05       	cpc	r24, r1
    50d4:	91 05       	cpc	r25, r1
    50d6:	09 f4       	brne	.+2      	; 0x50da <f_mkdir+0x296>
    50d8:	0b cf       	rjmp	.-490    	; 0x4ef0 <f_mkdir+0xac>
    50da:	f8 ce       	rjmp	.-528    	; 0x4ecc <f_mkdir+0x88>
			if (dcl == 1) res = FR_INT_ERR;
    50dc:	12 e0       	ldi	r17, 0x02	; 2
    50de:	b4 cf       	rjmp	.-152    	; 0x5048 <f_mkdir+0x204>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
    50e0:	11 e0       	ldi	r17, 0x01	; 1
    50e2:	b2 cf       	rjmp	.-156    	; 0x5048 <f_mkdir+0x204>
					res = move_window(dj.fs, 0);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
    50e4:	ce 01       	movw	r24, r28
    50e6:	01 96       	adiw	r24, 0x01	; 1
    50e8:	0e 94 da 19 	call	0x33b4	; 0x33b4 <dir_register>
    50ec:	18 2f       	mov	r17, r24
			if (res != FR_OK) {
    50ee:	88 23       	and	r24, r24
    50f0:	09 f4       	brne	.+2      	; 0x50f4 <f_mkdir+0x2b0>
    50f2:	b1 cf       	rjmp	.-158    	; 0x5056 <f_mkdir+0x212>
    50f4:	a9 cf       	rjmp	.-174    	; 0x5048 <f_mkdir+0x204>

000050f6 <f_chmod>:
FRESULT f_chmod (
	const TCHAR *path,	/* Pointer to the file path */
	BYTE value,			/* Attribute bits */
	BYTE mask			/* Attribute mask to change */
)
{
    50f6:	0f 93       	push	r16
    50f8:	1f 93       	push	r17
    50fa:	cf 93       	push	r28
    50fc:	df 93       	push	r29
    50fe:	cd b7       	in	r28, 0x3d	; 61
    5100:	de b7       	in	r29, 0x3e	; 62
    5102:	a4 97       	sbiw	r28, 0x24	; 36
    5104:	0f b6       	in	r0, 0x3f	; 63
    5106:	f8 94       	cli
    5108:	de bf       	out	0x3e, r29	; 62
    510a:	0f be       	out	0x3f, r0	; 63
    510c:	cd bf       	out	0x3d, r28	; 61
    510e:	9c a3       	lds	r25, 0x5c
    5110:	8b a3       	lds	r24, 0x5b
    5112:	06 2f       	mov	r16, r22
    5114:	14 2f       	mov	r17, r20
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    5116:	ce 01       	movw	r24, r28
    5118:	83 96       	adiw	r24, 0x23	; 35
    511a:	be 01       	movw	r22, r28
    511c:	6f 5f       	subi	r22, 0xFF	; 255
    511e:	7f 4f       	sbci	r23, 0xFF	; 255
    5120:	41 e0       	ldi	r20, 0x01	; 1
    5122:	0e 94 84 0c 	call	0x1908	; 0x1908 <chk_mounted>
	if (res == FR_OK) {
    5126:	88 23       	and	r24, r24
    5128:	29 f5       	brne	.+74     	; 0x5174 <f_chmod+0x7e>
		INIT_BUF(dj);
    512a:	ce 01       	movw	r24, r28
    512c:	47 96       	adiw	r24, 0x17	; 23
    512e:	9e 8b       	std	Y+22, r25	; 0x16
    5130:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the file path */
    5132:	6b a1       	lds	r22, 0x4b
    5134:	7c a1       	lds	r23, 0x4c
    5136:	ce 01       	movw	r24, r28
    5138:	01 96       	adiw	r24, 0x01	; 1
    513a:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <follow_path>
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    513e:	88 23       	and	r24, r24
    5140:	c9 f4       	brne	.+50     	; 0x5174 <f_chmod+0x7e>
    5142:	ed 89       	ldd	r30, Y+21	; 0x15
    5144:	fe 89       	ldd	r31, Y+22	; 0x16
    5146:	83 85       	ldd	r24, Z+11	; 0x0b
    5148:	85 ff       	sbrs	r24, 5
    514a:	1f c0       	rjmp	.+62     	; 0x518a <f_chmod+0x94>
			res = FR_INVALID_NAME;
    514c:	86 e0       	ldi	r24, 0x06	; 6
    514e:	12 c0       	rjmp	.+36     	; 0x5174 <f_chmod+0x7e>
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
			} else {						/* File or sub directory */
				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
    5150:	17 72       	andi	r17, 0x27	; 39
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
    5152:	91 2f       	mov	r25, r17
    5154:	90 95       	com	r25
    5156:	83 85       	ldd	r24, Z+11	; 0x0b
    5158:	89 23       	and	r24, r25
    515a:	01 23       	and	r16, r17
    515c:	18 2f       	mov	r17, r24
    515e:	10 2b       	or	r17, r16
    5160:	13 87       	std	Z+11, r17	; 0x0b
				dj.fs->wflag = 1;
    5162:	89 81       	ldd	r24, Y+1	; 0x01
    5164:	9a 81       	ldd	r25, Y+2	; 0x02
    5166:	21 e0       	ldi	r18, 0x01	; 1
    5168:	fc 01       	movw	r30, r24
    516a:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    516c:	0e 94 59 11 	call	0x22b2	; 0x22b2 <sync>
    5170:	01 c0       	rjmp	.+2      	; 0x5174 <f_chmod+0x7e>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
    5172:	86 e0       	ldi	r24, 0x06	; 6
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
    5174:	a4 96       	adiw	r28, 0x24	; 36
    5176:	0f b6       	in	r0, 0x3f	; 63
    5178:	f8 94       	cli
    517a:	de bf       	out	0x3e, r29	; 62
    517c:	0f be       	out	0x3f, r0	; 63
    517e:	cd bf       	out	0x3d, r28	; 61
    5180:	df 91       	pop	r29
    5182:	cf 91       	pop	r28
    5184:	1f 91       	pop	r17
    5186:	0f 91       	pop	r16
    5188:	08 95       	ret
		res = follow_path(&dj, path);		/* Follow the file path */
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
    518a:	eb 89       	ldd	r30, Y+19	; 0x13
    518c:	fc 89       	ldd	r31, Y+20	; 0x14
			if (!dir) {						/* Is it a root directory? */
    518e:	30 97       	sbiw	r30, 0x00	; 0
    5190:	f9 f6       	brne	.-66     	; 0x5150 <f_chmod+0x5a>
    5192:	ef cf       	rjmp	.-34     	; 0x5172 <f_chmod+0x7c>

00005194 <f_utime>:

FRESULT f_utime (
	const TCHAR *path,	/* Pointer to the file/directory name */
	const FILINFO *fno	/* Pointer to the time stamp to be set */
)
{
    5194:	0f 93       	push	r16
    5196:	1f 93       	push	r17
    5198:	cf 93       	push	r28
    519a:	df 93       	push	r29
    519c:	cd b7       	in	r28, 0x3d	; 61
    519e:	de b7       	in	r29, 0x3e	; 62
    51a0:	a4 97       	sbiw	r28, 0x24	; 36
    51a2:	0f b6       	in	r0, 0x3f	; 63
    51a4:	f8 94       	cli
    51a6:	de bf       	out	0x3e, r29	; 62
    51a8:	0f be       	out	0x3f, r0	; 63
    51aa:	cd bf       	out	0x3d, r28	; 61
    51ac:	9c a3       	lds	r25, 0x5c
    51ae:	8b a3       	lds	r24, 0x5b
    51b0:	8b 01       	movw	r16, r22
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    51b2:	ce 01       	movw	r24, r28
    51b4:	83 96       	adiw	r24, 0x23	; 35
    51b6:	be 01       	movw	r22, r28
    51b8:	6f 5f       	subi	r22, 0xFF	; 255
    51ba:	7f 4f       	sbci	r23, 0xFF	; 255
    51bc:	41 e0       	ldi	r20, 0x01	; 1
    51be:	0e 94 84 0c 	call	0x1908	; 0x1908 <chk_mounted>
	if (res == FR_OK) {
    51c2:	88 23       	and	r24, r24
    51c4:	61 f5       	brne	.+88     	; 0x521e <f_utime+0x8a>
		INIT_BUF(dj);
    51c6:	ce 01       	movw	r24, r28
    51c8:	47 96       	adiw	r24, 0x17	; 23
    51ca:	9e 8b       	std	Y+22, r25	; 0x16
    51cc:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    51ce:	6b a1       	lds	r22, 0x4b
    51d0:	7c a1       	lds	r23, 0x4c
    51d2:	ce 01       	movw	r24, r28
    51d4:	01 96       	adiw	r24, 0x01	; 1
    51d6:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <follow_path>
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    51da:	88 23       	and	r24, r24
    51dc:	01 f5       	brne	.+64     	; 0x521e <f_utime+0x8a>
    51de:	ed 89       	ldd	r30, Y+21	; 0x15
    51e0:	fe 89       	ldd	r31, Y+22	; 0x16
    51e2:	83 85       	ldd	r24, Z+11	; 0x0b
    51e4:	85 ff       	sbrs	r24, 5
    51e6:	26 c0       	rjmp	.+76     	; 0x5234 <f_utime+0xa0>
			res = FR_INVALID_NAME;
    51e8:	86 e0       	ldi	r24, 0x06	; 6
    51ea:	19 c0       	rjmp	.+50     	; 0x521e <f_utime+0x8a>
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {					/* Root directory */
				res = FR_INVALID_NAME;
			} else {					/* File or sub-directory */
				ST_WORD(dir+DIR_WrtTime, fno->ftime);
    51ec:	d8 01       	movw	r26, r16
    51ee:	16 96       	adiw	r26, 0x06	; 6
    51f0:	8c 91       	ld	r24, X
    51f2:	16 97       	sbiw	r26, 0x06	; 6
    51f4:	86 8b       	std	Z+22, r24	; 0x16
    51f6:	17 96       	adiw	r26, 0x07	; 7
    51f8:	8c 91       	ld	r24, X
    51fa:	17 97       	sbiw	r26, 0x07	; 7
    51fc:	87 8b       	std	Z+23, r24	; 0x17
				ST_WORD(dir+DIR_WrtDate, fno->fdate);
    51fe:	14 96       	adiw	r26, 0x04	; 4
    5200:	8c 91       	ld	r24, X
    5202:	14 97       	sbiw	r26, 0x04	; 4
    5204:	80 8f       	std	Z+24, r24	; 0x18
    5206:	15 96       	adiw	r26, 0x05	; 5
    5208:	8c 91       	ld	r24, X
    520a:	81 8f       	std	Z+25, r24	; 0x19
				dj.fs->wflag = 1;
    520c:	89 81       	ldd	r24, Y+1	; 0x01
    520e:	9a 81       	ldd	r25, Y+2	; 0x02
    5210:	21 e0       	ldi	r18, 0x01	; 1
    5212:	fc 01       	movw	r30, r24
    5214:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    5216:	0e 94 59 11 	call	0x22b2	; 0x22b2 <sync>
    521a:	01 c0       	rjmp	.+2      	; 0x521e <f_utime+0x8a>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {					/* Root directory */
				res = FR_INVALID_NAME;
    521c:	86 e0       	ldi	r24, 0x06	; 6
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
    521e:	a4 96       	adiw	r28, 0x24	; 36
    5220:	0f b6       	in	r0, 0x3f	; 63
    5222:	f8 94       	cli
    5224:	de bf       	out	0x3e, r29	; 62
    5226:	0f be       	out	0x3f, r0	; 63
    5228:	cd bf       	out	0x3d, r28	; 61
    522a:	df 91       	pop	r29
    522c:	cf 91       	pop	r28
    522e:	1f 91       	pop	r17
    5230:	0f 91       	pop	r16
    5232:	08 95       	ret
		res = follow_path(&dj, path);	/* Follow the file path */
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
    5234:	eb 89       	ldd	r30, Y+19	; 0x13
    5236:	fc 89       	ldd	r31, Y+20	; 0x14
			if (!dir) {					/* Root directory */
    5238:	30 97       	sbiw	r30, 0x00	; 0
    523a:	c1 f6       	brne	.-80     	; 0x51ec <f_utime+0x58>
    523c:	ef cf       	rjmp	.-34     	; 0x521c <f_utime+0x88>

0000523e <f_rename>:

FRESULT f_rename (
	const TCHAR *path_old,	/* Pointer to the old name */
	const TCHAR *path_new	/* Pointer to the new name */
)
{
    523e:	ef 92       	push	r14
    5240:	ff 92       	push	r15
    5242:	0f 93       	push	r16
    5244:	1f 93       	push	r17
    5246:	cf 93       	push	r28
    5248:	df 93       	push	r29
    524a:	cd b7       	in	r28, 0x3d	; 61
    524c:	de b7       	in	r29, 0x3e	; 62
    524e:	cf 54       	subi	r28, 0x4F	; 79
    5250:	d0 40       	sbci	r29, 0x00	; 0
    5252:	0f b6       	in	r0, 0x3f	; 63
    5254:	f8 94       	cli
    5256:	de bf       	out	0x3e, r29	; 62
    5258:	0f be       	out	0x3f, r0	; 63
    525a:	cd bf       	out	0x3d, r28	; 61
    525c:	60 96       	adiw	r28, 0x10	; 16
    525e:	9f af       	sts	0x7f, r25
    5260:	8e af       	sts	0x7e, r24
    5262:	60 97       	sbiw	r28, 0x10	; 16
    5264:	8b 01       	movw	r16, r22
	BYTE buf[21], *dir;
	DWORD dw;
	DEF_NAMEBUF;


	res = chk_mounted(&path_old, &djo.fs, 1);
    5266:	ce 01       	movw	r24, r28
    5268:	82 5b       	subi	r24, 0xB2	; 178
    526a:	9f 4f       	sbci	r25, 0xFF	; 255
    526c:	be 01       	movw	r22, r28
    526e:	6f 5f       	subi	r22, 0xFF	; 255
    5270:	7f 4f       	sbci	r23, 0xFF	; 255
    5272:	41 e0       	ldi	r20, 0x01	; 1
    5274:	0e 94 84 0c 	call	0x1908	; 0x1908 <chk_mounted>
	if (res == FR_OK) {
    5278:	88 23       	and	r24, r24
    527a:	09 f0       	breq	.+2      	; 0x527e <f_rename+0x40>
    527c:	b7 c0       	rjmp	.+366    	; 0x53ec <f_rename+0x1ae>
		djn.fs = djo.fs;
    527e:	89 81       	ldd	r24, Y+1	; 0x01
    5280:	9a 81       	ldd	r25, Y+2	; 0x02
    5282:	98 8f       	std	Y+24, r25	; 0x18
    5284:	8f 8b       	std	Y+23, r24	; 0x17
		INIT_BUF(djo);
    5286:	ce 01       	movw	r24, r28
    5288:	8e 5b       	subi	r24, 0xBE	; 190
    528a:	9f 4f       	sbci	r25, 0xFF	; 255
    528c:	9e 8b       	std	Y+22, r25	; 0x16
    528e:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&djo, path_old);		/* Check old object */
    5290:	60 96       	adiw	r28, 0x10	; 16
    5292:	6e ad       	sts	0x6e, r22
    5294:	7f ad       	sts	0x6f, r23
    5296:	60 97       	sbiw	r28, 0x10	; 16
    5298:	ce 01       	movw	r24, r28
    529a:	01 96       	adiw	r24, 0x01	; 1
    529c:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <follow_path>
		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
    52a0:	88 23       	and	r24, r24
    52a2:	09 f0       	breq	.+2      	; 0x52a6 <f_rename+0x68>
    52a4:	a3 c0       	rjmp	.+326    	; 0x53ec <f_rename+0x1ae>
    52a6:	ed 89       	ldd	r30, Y+21	; 0x15
    52a8:	fe 89       	ldd	r31, Y+22	; 0x16
    52aa:	83 85       	ldd	r24, Z+11	; 0x0b
    52ac:	85 ff       	sbrs	r24, 5
    52ae:	ac c0       	rjmp	.+344    	; 0x5408 <f_rename+0x1ca>
			res = FR_INVALID_NAME;
    52b0:	86 e0       	ldi	r24, 0x06	; 6
    52b2:	9c c0       	rjmp	.+312    	; 0x53ec <f_rename+0x1ae>
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
    52b4:	65 5f       	subi	r22, 0xF5	; 245
    52b6:	7f 4f       	sbci	r23, 0xFF	; 255
    52b8:	ce 01       	movw	r24, r28
    52ba:	8d 96       	adiw	r24, 0x2d	; 45
    52bc:	25 e1       	ldi	r18, 0x15	; 21
    52be:	30 e0       	ldi	r19, 0x00	; 0
    52c0:	40 e0       	ldi	r20, 0x00	; 0
    52c2:	50 e0       	ldi	r21, 0x00	; 0
    52c4:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <mem_cpy>
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
    52c8:	ce 01       	movw	r24, r28
    52ca:	47 96       	adiw	r24, 0x17	; 23
    52cc:	be 01       	movw	r22, r28
    52ce:	6f 5f       	subi	r22, 0xFF	; 255
    52d0:	7f 4f       	sbci	r23, 0xFF	; 255
    52d2:	26 e1       	ldi	r18, 0x16	; 22
    52d4:	30 e0       	ldi	r19, 0x00	; 0
    52d6:	40 e0       	ldi	r20, 0x00	; 0
    52d8:	50 e0       	ldi	r21, 0x00	; 0
    52da:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <mem_cpy>
				res = follow_path(&djn, path_new);
    52de:	ce 01       	movw	r24, r28
    52e0:	47 96       	adiw	r24, 0x17	; 23
    52e2:	b8 01       	movw	r22, r16
    52e4:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <follow_path>
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
    52e8:	88 23       	and	r24, r24
    52ea:	09 f4       	brne	.+2      	; 0x52ee <f_rename+0xb0>
    52ec:	7c c0       	rjmp	.+248    	; 0x53e6 <f_rename+0x1a8>
				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
    52ee:	84 30       	cpi	r24, 0x04	; 4
    52f0:	09 f0       	breq	.+2      	; 0x52f4 <f_rename+0xb6>
    52f2:	7c c0       	rjmp	.+248    	; 0x53ec <f_rename+0x1ae>
/* Start critical section that an interruption or error can cause cross-link */
					res = dir_register(&djn);			/* Register the new entry */
    52f4:	ce 01       	movw	r24, r28
    52f6:	47 96       	adiw	r24, 0x17	; 23
    52f8:	0e 94 da 19 	call	0x33b4	; 0x33b4 <dir_register>
					if (res == FR_OK) {
    52fc:	88 23       	and	r24, r24
    52fe:	09 f0       	breq	.+2      	; 0x5302 <f_rename+0xc4>
    5300:	75 c0       	rjmp	.+234    	; 0x53ec <f_rename+0x1ae>
						dir = djn.dir;					/* Copy object information except for name */
    5302:	09 a5       	lds	r16, 0x69
    5304:	1a a5       	lds	r17, 0x6a
						mem_cpy(dir+13, buf+2, 19);
    5306:	c8 01       	movw	r24, r16
    5308:	0d 96       	adiw	r24, 0x0d	; 13
    530a:	be 01       	movw	r22, r28
    530c:	61 5d       	subi	r22, 0xD1	; 209
    530e:	7f 4f       	sbci	r23, 0xFF	; 255
    5310:	23 e1       	ldi	r18, 0x13	; 19
    5312:	30 e0       	ldi	r19, 0x00	; 0
    5314:	40 e0       	ldi	r20, 0x00	; 0
    5316:	50 e0       	ldi	r21, 0x00	; 0
    5318:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <mem_cpy>
						dir[DIR_Attr] = buf[0] | AM_ARC;
    531c:	8d a5       	lds	r24, 0x6d
    531e:	80 62       	ori	r24, 0x20	; 32
    5320:	f8 01       	movw	r30, r16
    5322:	83 87       	std	Z+11, r24	; 0x0b
						djo.fs->wflag = 1;
    5324:	e9 80       	ldd	r14, Y+1	; 0x01
    5326:	fa 80       	ldd	r15, Y+2	; 0x02
    5328:	81 e0       	ldi	r24, 0x01	; 1
    532a:	f7 01       	movw	r30, r14
    532c:	84 83       	std	Z+4, r24	; 0x04
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
    532e:	4f 81       	ldd	r20, Y+7	; 0x07
    5330:	58 85       	ldd	r21, Y+8	; 0x08
    5332:	69 85       	ldd	r22, Y+9	; 0x09
    5334:	7a 85       	ldd	r23, Y+10	; 0x0a
    5336:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5338:	9e 8d       	ldd	r25, Y+30	; 0x1e
    533a:	af 8d       	ldd	r26, Y+31	; 0x1f
    533c:	b8 a1       	lds	r27, 0x48
    533e:	48 17       	cp	r20, r24
    5340:	59 07       	cpc	r21, r25
    5342:	6a 07       	cpc	r22, r26
    5344:	7b 07       	cpc	r23, r27
    5346:	09 f4       	brne	.+2      	; 0x534a <f_rename+0x10c>
    5348:	43 c0       	rjmp	.+134    	; 0x53d0 <f_rename+0x192>
    534a:	f8 01       	movw	r30, r16
    534c:	83 85       	ldd	r24, Z+11	; 0x0b
    534e:	84 ff       	sbrs	r24, 4
    5350:	3f c0       	rjmp	.+126    	; 0x53d0 <f_rename+0x192>
							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
    5352:	c7 01       	movw	r24, r14
    5354:	b8 01       	movw	r22, r16
    5356:	0e 94 07 0b 	call	0x160e	; 0x160e <ld_clust>
    535a:	ab 01       	movw	r20, r22
    535c:	bc 01       	movw	r22, r24
    535e:	c7 01       	movw	r24, r14
    5360:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <clust2sect>
    5364:	ab 01       	movw	r20, r22
    5366:	bc 01       	movw	r22, r24
							if (!dw) {
    5368:	41 15       	cp	r20, r1
    536a:	51 05       	cpc	r21, r1
    536c:	61 05       	cpc	r22, r1
    536e:	71 05       	cpc	r23, r1
    5370:	09 f4       	brne	.+2      	; 0x5374 <f_rename+0x136>
    5372:	51 c0       	rjmp	.+162    	; 0x5416 <f_rename+0x1d8>
								res = FR_INT_ERR;
							} else {
								res = move_window(djo.fs, dw);
    5374:	c7 01       	movw	r24, r14
    5376:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <move_window>
								dir = djo.fs->win+SZ_DIR;	/* .. entry */
    537a:	e9 81       	ldd	r30, Y+1	; 0x01
    537c:	fa 81       	ldd	r31, Y+2	; 0x02
								if (res == FR_OK && dir[1] == '.') {
    537e:	88 23       	and	r24, r24
    5380:	a9 f5       	brne	.+106    	; 0x53ec <f_rename+0x1ae>
    5382:	df 01       	movw	r26, r30
    5384:	ad 5a       	subi	r26, 0xAD	; 173
    5386:	bf 4f       	sbci	r27, 0xFF	; 255
    5388:	8c 91       	ld	r24, X
    538a:	8e 32       	cpi	r24, 0x2E	; 46
    538c:	09 f5       	brne	.+66     	; 0x53d0 <f_rename+0x192>
									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
    538e:	80 81       	ld	r24, Z
    5390:	83 30       	cpi	r24, 0x03	; 3
    5392:	69 f4       	brne	.+26     	; 0x53ae <f_rename+0x170>
    5394:	4d 8d       	ldd	r20, Y+29	; 0x1d
    5396:	5e 8d       	ldd	r21, Y+30	; 0x1e
    5398:	6f 8d       	ldd	r22, Y+31	; 0x1f
    539a:	78 a1       	lds	r23, 0x48
    539c:	86 a1       	lds	r24, 0x46
    539e:	97 a1       	lds	r25, 0x47
    53a0:	a0 a5       	lds	r26, 0x60
    53a2:	b1 a5       	lds	r27, 0x61
    53a4:	48 17       	cp	r20, r24
    53a6:	59 07       	cpc	r21, r25
    53a8:	6a 07       	cpc	r22, r26
    53aa:	7b 07       	cpc	r23, r27
    53ac:	29 f0       	breq	.+10     	; 0x53b8 <f_rename+0x17a>
    53ae:	4d 8d       	ldd	r20, Y+29	; 0x1d
    53b0:	5e 8d       	ldd	r21, Y+30	; 0x1e
    53b2:	6f 8d       	ldd	r22, Y+31	; 0x1f
    53b4:	78 a1       	lds	r23, 0x48
    53b6:	03 c0       	rjmp	.+6      	; 0x53be <f_rename+0x180>
    53b8:	40 e0       	ldi	r20, 0x00	; 0
    53ba:	50 e0       	ldi	r21, 0x00	; 0
    53bc:	ba 01       	movw	r22, r20
									st_clust(dir, dw);
    53be:	cf 01       	movw	r24, r30
    53c0:	8e 5a       	subi	r24, 0xAE	; 174
    53c2:	9f 4f       	sbci	r25, 0xFF	; 255
    53c4:	0e 94 2c 0b 	call	0x1658	; 0x1658 <st_clust>
									djo.fs->wflag = 1;
    53c8:	e9 81       	ldd	r30, Y+1	; 0x01
    53ca:	fa 81       	ldd	r31, Y+2	; 0x02
    53cc:	81 e0       	ldi	r24, 0x01	; 1
    53ce:	84 83       	std	Z+4, r24	; 0x04
								}
							}
						}
						if (res == FR_OK) {
							res = dir_remove(&djo);		/* Remove old entry */
    53d0:	ce 01       	movw	r24, r28
    53d2:	01 96       	adiw	r24, 0x01	; 1
    53d4:	0e 94 1d 14 	call	0x283a	; 0x283a <dir_remove>
							if (res == FR_OK)
    53d8:	88 23       	and	r24, r24
    53da:	41 f4       	brne	.+16     	; 0x53ec <f_rename+0x1ae>
								res = sync(djo.fs);
    53dc:	89 81       	ldd	r24, Y+1	; 0x01
    53de:	9a 81       	ldd	r25, Y+2	; 0x02
    53e0:	0e 94 59 11 	call	0x22b2	; 0x22b2 <sync>
    53e4:	03 c0       	rjmp	.+6      	; 0x53ec <f_rename+0x1ae>
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
				res = follow_path(&djn, path_new);
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
    53e6:	88 e0       	ldi	r24, 0x08	; 8
    53e8:	01 c0       	rjmp	.+2      	; 0x53ec <f_rename+0x1ae>
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
    53ea:	84 e0       	ldi	r24, 0x04	; 4
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(djo.fs, res);
}
    53ec:	c1 5b       	subi	r28, 0xB1	; 177
    53ee:	df 4f       	sbci	r29, 0xFF	; 255
    53f0:	0f b6       	in	r0, 0x3f	; 63
    53f2:	f8 94       	cli
    53f4:	de bf       	out	0x3e, r29	; 62
    53f6:	0f be       	out	0x3f, r0	; 63
    53f8:	cd bf       	out	0x3d, r28	; 61
    53fa:	df 91       	pop	r29
    53fc:	cf 91       	pop	r28
    53fe:	1f 91       	pop	r17
    5400:	0f 91       	pop	r16
    5402:	ff 90       	pop	r15
    5404:	ef 90       	pop	r14
    5406:	08 95       	ret
			res = FR_INVALID_NAME;
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
    5408:	6b 89       	ldd	r22, Y+19	; 0x13
    540a:	7c 89       	ldd	r23, Y+20	; 0x14
    540c:	61 15       	cp	r22, r1
    540e:	71 05       	cpc	r23, r1
    5410:	09 f0       	breq	.+2      	; 0x5414 <f_rename+0x1d6>
    5412:	50 cf       	rjmp	.-352    	; 0x52b4 <f_rename+0x76>
    5414:	ea cf       	rjmp	.-44     	; 0x53ea <f_rename+0x1ac>
						dir[DIR_Attr] = buf[0] | AM_ARC;
						djo.fs->wflag = 1;
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
							if (!dw) {
								res = FR_INT_ERR;
    5416:	82 e0       	ldi	r24, 0x02	; 2
    5418:	e9 cf       	rjmp	.-46     	; 0x53ec <f_rename+0x1ae>

0000541a <InitSCCB>:
Function: Initial the SCCB port in AVR
-----------------------------------------------
*/
void InitSCCB(void)
{
	SCCB_DDR|=(1<<SCCB_SIO_C)|(1<<SCCB_SIO_D);  //|(1<<FIFO_WEN)|(1<<FIFO_nRRST)|(1<<FIFO_RCLK);
    541a:	8a b1       	in	r24, 0x0a	; 10
    541c:	83 60       	ori	r24, 0x03	; 3
    541e:	8a b9       	out	0x0a, r24	; 10
	SCCB_PORT|=(1<<SCCB_SIO_C)|(1<<SCCB_SIO_D);
    5420:	8b b1       	in	r24, 0x0b	; 11
    5422:	83 60       	ori	r24, 0x03	; 3
    5424:	8b b9       	out	0x0b, r24	; 11
}
    5426:	08 95       	ret

00005428 <startSCCB>:
Function: Generate the start phase for SCCB following the datasheet
-----------------------------------------------
*/
void startSCCB(void)
{
	SIO_D_SET;     
    5428:	59 9a       	sbi	0x0b, 1	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    542a:	8b e2       	ldi	r24, 0x2B	; 43
    542c:	91 e0       	ldi	r25, 0x01	; 1
    542e:	01 97       	sbiw	r24, 0x01	; 1
    5430:	f1 f7       	brne	.-4      	; 0x542e <startSCCB+0x6>
    5432:	00 c0       	rjmp	.+0      	; 0x5434 <startSCCB+0xc>
    5434:	00 00       	nop
    _delay_us(100);

    SIO_C_SET;
    5436:	58 9a       	sbi	0x0b, 0	; 11
    5438:	8b e2       	ldi	r24, 0x2B	; 43
    543a:	91 e0       	ldi	r25, 0x01	; 1
    543c:	01 97       	sbiw	r24, 0x01	; 1
    543e:	f1 f7       	brne	.-4      	; 0x543c <startSCCB+0x14>
    5440:	00 c0       	rjmp	.+0      	; 0x5442 <startSCCB+0x1a>
    5442:	00 00       	nop
    _delay_us(100);
 
    SIO_D_CLR;
    5444:	59 98       	cbi	0x0b, 1	; 11
    5446:	8b e2       	ldi	r24, 0x2B	; 43
    5448:	91 e0       	ldi	r25, 0x01	; 1
    544a:	01 97       	sbiw	r24, 0x01	; 1
    544c:	f1 f7       	brne	.-4      	; 0x544a <startSCCB+0x22>
    544e:	00 c0       	rjmp	.+0      	; 0x5450 <startSCCB+0x28>
    5450:	00 00       	nop
    _delay_us(100);

    SIO_C_CLR;
    5452:	58 98       	cbi	0x0b, 0	; 11
    5454:	8b e2       	ldi	r24, 0x2B	; 43
    5456:	91 e0       	ldi	r25, 0x01	; 1
    5458:	01 97       	sbiw	r24, 0x01	; 1
    545a:	f1 f7       	brne	.-4      	; 0x5458 <startSCCB+0x30>
    545c:	00 c0       	rjmp	.+0      	; 0x545e <startSCCB+0x36>
    545e:	00 00       	nop
    _delay_us(100);


}
    5460:	08 95       	ret

00005462 <stopSCCB>:
Function: Generate the stop phase of SCCB following the datasheet
-----------------------------------------------
*/
void stopSCCB(void)
{
	SIO_D_CLR;
    5462:	59 98       	cbi	0x0b, 1	; 11
    5464:	8b e2       	ldi	r24, 0x2B	; 43
    5466:	91 e0       	ldi	r25, 0x01	; 1
    5468:	01 97       	sbiw	r24, 0x01	; 1
    546a:	f1 f7       	brne	.-4      	; 0x5468 <stopSCCB+0x6>
    546c:	00 c0       	rjmp	.+0      	; 0x546e <stopSCCB+0xc>
    546e:	00 00       	nop
    _delay_us(100);
 
    SIO_C_SET;
    5470:	58 9a       	sbi	0x0b, 0	; 11
    5472:	8b e2       	ldi	r24, 0x2B	; 43
    5474:	91 e0       	ldi	r25, 0x01	; 1
    5476:	01 97       	sbiw	r24, 0x01	; 1
    5478:	f1 f7       	brne	.-4      	; 0x5476 <stopSCCB+0x14>
    547a:	00 c0       	rjmp	.+0      	; 0x547c <stopSCCB+0x1a>
    547c:	00 00       	nop
    _delay_us(100);
  

    SIO_D_SET;
    547e:	59 9a       	sbi	0x0b, 1	; 11
    5480:	8b e2       	ldi	r24, 0x2B	; 43
    5482:	91 e0       	ldi	r25, 0x01	; 1
    5484:	01 97       	sbiw	r24, 0x01	; 1
    5486:	f1 f7       	brne	.-4      	; 0x5484 <stopSCCB+0x22>
    5488:	00 c0       	rjmp	.+0      	; 0x548a <stopSCCB+0x28>
    548a:	00 00       	nop
    _delay_us(100);
 //   SCCB_DDR&= ~(SCCB_SIO_D);

}
    548c:	08 95       	ret

0000548e <noAck>:
-----------------------------------------------
*/
void noAck(void)
{
	
	SIO_D_SET;
    548e:	59 9a       	sbi	0x0b, 1	; 11
    5490:	8b e2       	ldi	r24, 0x2B	; 43
    5492:	91 e0       	ldi	r25, 0x01	; 1
    5494:	01 97       	sbiw	r24, 0x01	; 1
    5496:	f1 f7       	brne	.-4      	; 0x5494 <noAck+0x6>
    5498:	00 c0       	rjmp	.+0      	; 0x549a <noAck+0xc>
    549a:	00 00       	nop
	_delay_us(100);
	
	SIO_C_SET;
    549c:	58 9a       	sbi	0x0b, 0	; 11
    549e:	8b e2       	ldi	r24, 0x2B	; 43
    54a0:	91 e0       	ldi	r25, 0x01	; 1
    54a2:	01 97       	sbiw	r24, 0x01	; 1
    54a4:	f1 f7       	brne	.-4      	; 0x54a2 <noAck+0x14>
    54a6:	00 c0       	rjmp	.+0      	; 0x54a8 <noAck+0x1a>
    54a8:	00 00       	nop
	_delay_us(100);
	
	SIO_C_CLR;
    54aa:	58 98       	cbi	0x0b, 0	; 11
    54ac:	8b e2       	ldi	r24, 0x2B	; 43
    54ae:	91 e0       	ldi	r25, 0x01	; 1
    54b0:	01 97       	sbiw	r24, 0x01	; 1
    54b2:	f1 f7       	brne	.-4      	; 0x54b0 <noAck+0x22>
    54b4:	00 c0       	rjmp	.+0      	; 0x54b6 <noAck+0x28>
    54b6:	00 00       	nop
	_delay_us(100);
	
	SIO_D_CLR;
    54b8:	59 98       	cbi	0x0b, 1	; 11
    54ba:	8b e2       	ldi	r24, 0x2B	; 43
    54bc:	91 e0       	ldi	r25, 0x01	; 1
    54be:	01 97       	sbiw	r24, 0x01	; 1
    54c0:	f1 f7       	brne	.-4      	; 0x54be <noAck+0x30>
    54c2:	00 c0       	rjmp	.+0      	; 0x54c4 <noAck+0x36>
    54c4:	00 00       	nop
	_delay_us(100);

}
    54c6:	08 95       	ret

000054c8 <SCCBwriteByte>:
-----------------------------------------------
Function: Write one Byte data through SCCB
-----------------------------------------------
*/
unsigned char SCCBwriteByte(unsigned char m_data)
{
    54c8:	20 e0       	ldi	r18, 0x00	; 0
    54ca:	30 e0       	ldi	r19, 0x00	; 0
	unsigned char j,tem;

	for(j=0;j<8;j++)
	{
		if((m_data<<j)&0x80)
    54cc:	90 e0       	ldi	r25, 0x00	; 0
    54ce:	ac 01       	movw	r20, r24
    54d0:	02 2e       	mov	r0, r18
    54d2:	02 c0       	rjmp	.+4      	; 0x54d8 <SCCBwriteByte+0x10>
    54d4:	44 0f       	add	r20, r20
    54d6:	55 1f       	adc	r21, r21
    54d8:	0a 94       	dec	r0
    54da:	e2 f7       	brpl	.-8      	; 0x54d4 <SCCBwriteByte+0xc>
    54dc:	47 ff       	sbrs	r20, 7
    54de:	02 c0       	rjmp	.+4      	; 0x54e4 <SCCBwriteByte+0x1c>
		{
			SIO_D_SET;
    54e0:	59 9a       	sbi	0x0b, 1	; 11
    54e2:	01 c0       	rjmp	.+2      	; 0x54e6 <SCCBwriteByte+0x1e>
		}
		else
		{
			SIO_D_CLR;
    54e4:	59 98       	cbi	0x0b, 1	; 11
    54e6:	eb e2       	ldi	r30, 0x2B	; 43
    54e8:	f1 e0       	ldi	r31, 0x01	; 1
    54ea:	31 97       	sbiw	r30, 0x01	; 1
    54ec:	f1 f7       	brne	.-4      	; 0x54ea <SCCBwriteByte+0x22>
    54ee:	00 c0       	rjmp	.+0      	; 0x54f0 <SCCBwriteByte+0x28>
    54f0:	00 00       	nop
		}
		_delay_us(100);
		SIO_C_SET;
    54f2:	58 9a       	sbi	0x0b, 0	; 11
    54f4:	eb e2       	ldi	r30, 0x2B	; 43
    54f6:	f1 e0       	ldi	r31, 0x01	; 1
    54f8:	31 97       	sbiw	r30, 0x01	; 1
    54fa:	f1 f7       	brne	.-4      	; 0x54f8 <SCCBwriteByte+0x30>
    54fc:	00 c0       	rjmp	.+0      	; 0x54fe <SCCBwriteByte+0x36>
    54fe:	00 00       	nop
		_delay_us(100);
		SIO_C_CLR;
    5500:	58 98       	cbi	0x0b, 0	; 11
    5502:	eb e2       	ldi	r30, 0x2B	; 43
    5504:	f1 e0       	ldi	r31, 0x01	; 1
    5506:	31 97       	sbiw	r30, 0x01	; 1
    5508:	f1 f7       	brne	.-4      	; 0x5506 <SCCBwriteByte+0x3e>
    550a:	00 c0       	rjmp	.+0      	; 0x550c <SCCBwriteByte+0x44>
    550c:	00 00       	nop
    550e:	2f 5f       	subi	r18, 0xFF	; 255
    5510:	3f 4f       	sbci	r19, 0xFF	; 255
*/
unsigned char SCCBwriteByte(unsigned char m_data)
{
	unsigned char j,tem;

	for(j=0;j<8;j++)
    5512:	28 30       	cpi	r18, 0x08	; 8
    5514:	31 05       	cpc	r19, r1
    5516:	d9 f6       	brne	.-74     	; 0x54ce <SCCBwriteByte+0x6>
    5518:	8b e2       	ldi	r24, 0x2B	; 43
    551a:	91 e0       	ldi	r25, 0x01	; 1
    551c:	01 97       	sbiw	r24, 0x01	; 1
    551e:	f1 f7       	brne	.-4      	; 0x551c <SCCBwriteByte+0x54>
    5520:	00 c0       	rjmp	.+0      	; 0x5522 <SCCBwriteByte+0x5a>
    5522:	00 00       	nop
		_delay_us(100);

	}
	_delay_us(100);
	
	SIO_D_IN;	//Set SDA as input
    5524:	51 98       	cbi	0x0a, 1	; 10
    5526:	eb e2       	ldi	r30, 0x2B	; 43
    5528:	f1 e0       	ldi	r31, 0x01	; 1
    552a:	31 97       	sbiw	r30, 0x01	; 1
    552c:	f1 f7       	brne	.-4      	; 0x552a <SCCBwriteByte+0x62>
    552e:	00 c0       	rjmp	.+0      	; 0x5530 <SCCBwriteByte+0x68>
    5530:	00 00       	nop
	_delay_us(100);
	SIO_C_SET;
    5532:	58 9a       	sbi	0x0b, 0	; 11
    5534:	87 eb       	ldi	r24, 0xB7	; 183
    5536:	9b e0       	ldi	r25, 0x0B	; 11
    5538:	01 97       	sbiw	r24, 0x01	; 1
    553a:	f1 f7       	brne	.-4      	; 0x5538 <SCCBwriteByte+0x70>
    553c:	00 c0       	rjmp	.+0      	; 0x553e <SCCBwriteByte+0x76>
    553e:	00 00       	nop
	_delay_us(1000);
	if(SIO_D_STATE)
    5540:	99 b1       	in	r25, 0x09	; 9
	}
	else
	{
		tem=1;   //SDA=0 send succeed, reture 1
	}
	SIO_C_CLR;
    5542:	58 98       	cbi	0x0b, 0	; 11
    5544:	eb e2       	ldi	r30, 0x2B	; 43
    5546:	f1 e0       	ldi	r31, 0x01	; 1
    5548:	31 97       	sbiw	r30, 0x01	; 1
    554a:	f1 f7       	brne	.-4      	; 0x5548 <SCCBwriteByte+0x80>
    554c:	00 c0       	rjmp	.+0      	; 0x554e <SCCBwriteByte+0x86>
    554e:	00 00       	nop
	_delay_us(100);	
    SIO_D_OUT;	//Set SDA as output
    5550:	51 9a       	sbi	0x0a, 1	; 10
	_delay_us(100);
	SIO_C_SET;
	_delay_us(1000);
	if(SIO_D_STATE)
	{
		tem=0;   //SDA=1 send fail, return 0
    5552:	81 e0       	ldi	r24, 0x01	; 1
    5554:	91 fd       	sbrc	r25, 1
    5556:	80 e0       	ldi	r24, 0x00	; 0
	SIO_C_CLR;
	_delay_us(100);	
    SIO_D_OUT;	//Set SDA as output

	return(tem);  
}
    5558:	08 95       	ret

0000555a <SCCBreadByte>:
unsigned char SCCBreadByte(void)
{
	unsigned char read,j;
	read=0x00;
	
	SIO_D_IN;/*SDA*/
    555a:	51 98       	cbi	0x0a, 1	; 10
    555c:	8b e2       	ldi	r24, 0x2B	; 43
    555e:	91 e0       	ldi	r25, 0x01	; 1
    5560:	01 97       	sbiw	r24, 0x01	; 1
    5562:	f1 f7       	brne	.-4      	; 0x5560 <SCCBreadByte+0x6>
    5564:	00 c0       	rjmp	.+0      	; 0x5566 <SCCBreadByte+0xc>
    5566:	00 00       	nop
    5568:	98 e0       	ldi	r25, 0x08	; 8
-----------------------------------------------
*/
unsigned char SCCBreadByte(void)
{
	unsigned char read,j;
	read=0x00;
    556a:	80 e0       	ldi	r24, 0x00	; 0
    556c:	eb e2       	ldi	r30, 0x2B	; 43
    556e:	f1 e0       	ldi	r31, 0x01	; 1
    5570:	31 97       	sbiw	r30, 0x01	; 1
    5572:	f1 f7       	brne	.-4      	; 0x5570 <SCCBreadByte+0x16>
    5574:	00 c0       	rjmp	.+0      	; 0x5576 <SCCBreadByte+0x1c>
    5576:	00 00       	nop
	SIO_D_IN;/*SDA*/
	_delay_us(100);
	for(j=8;j>0;j--) //8
	{		     
		_delay_us(100);
		SIO_C_SET;
    5578:	58 9a       	sbi	0x0b, 0	; 11
    557a:	eb e2       	ldi	r30, 0x2B	; 43
    557c:	f1 e0       	ldi	r31, 0x01	; 1
    557e:	31 97       	sbiw	r30, 0x01	; 1
    5580:	f1 f7       	brne	.-4      	; 0x557e <SCCBreadByte+0x24>
    5582:	00 c0       	rjmp	.+0      	; 0x5584 <SCCBreadByte+0x2a>
    5584:	00 00       	nop
		_delay_us(100);
		read=read<<1;
    5586:	88 0f       	add	r24, r24
		if(SIO_D_STATE) 
    5588:	49 99       	sbic	0x09, 1	; 9
		{
			read=read+1;
    558a:	8f 5f       	subi	r24, 0xFF	; 255
		}
		SIO_C_CLR;
    558c:	58 98       	cbi	0x0b, 0	; 11
    558e:	eb e2       	ldi	r30, 0x2B	; 43
    5590:	f1 e0       	ldi	r31, 0x01	; 1
    5592:	31 97       	sbiw	r30, 0x01	; 1
    5594:	f1 f7       	brne	.-4      	; 0x5592 <SCCBreadByte+0x38>
    5596:	00 c0       	rjmp	.+0      	; 0x5598 <SCCBreadByte+0x3e>
    5598:	00 00       	nop
    559a:	91 50       	subi	r25, 0x01	; 1
	unsigned char read,j;
	read=0x00;
	
	SIO_D_IN;/*SDA*/
	_delay_us(100);
	for(j=8;j>0;j--) //8
    559c:	39 f7       	brne	.-50     	; 0x556c <SCCBreadByte+0x12>
		}
		SIO_C_CLR;
		_delay_us(100);
	}	
	return(read);
}
    559e:	08 95       	ret

000055a0 <TWI_Master_Initialise>:
		DDRC = 0x00;
		PORTC = (1 << PC0) | (1 << PC1);
	#else
		#pragma message("External I2C Pull Ups Required.")
	#endif
	TWBR = TWI_TWBR;                                  // Set bit rate register (Baudrate). Defined in header file.
    55a0:	84 e3       	ldi	r24, 0x34	; 52
    55a2:	80 93 b8 00 	sts	0x00B8, r24
	// TWSR = TWI_TWPS;                                  // Not used. Driver presumes prescaler to be 00.
	TWDR = 0xFF;                                      // Default content = SDA released.
    55a6:	8f ef       	ldi	r24, 0xFF	; 255
    55a8:	80 93 bb 00 	sts	0x00BB, r24
	TWCR =	(1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
    55ac:	84 e0       	ldi	r24, 0x04	; 4
    55ae:	80 93 bc 00 	sts	0x00BC, r24
			(0<<TWIE)|(0<<TWINT)|                      // Disable Interupt.
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests.
			(0<<TWWC);                                 //
}    
    55b2:	08 95       	ret

000055b4 <TWI_Transceiver_Busy>:
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
    55b4:	80 91 bc 00 	lds	r24, 0x00BC
}
    55b8:	81 70       	andi	r24, 0x01	; 1
    55ba:	08 95       	ret

000055bc <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
    55bc:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <TWI_Transceiver_Busy>
    55c0:	88 23       	and	r24, r24
    55c2:	e1 f7       	brne	.-8      	; 0x55bc <TWI_Get_State_Info>
  return ( TWI_state );                         // Return error state.
}
    55c4:	80 91 1e 04 	lds	r24, 0x041E
    55c8:	08 95       	ret

000055ca <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
    55ca:	0f 93       	push	r16
    55cc:	1f 93       	push	r17
    55ce:	cf 93       	push	r28
    55d0:	8c 01       	movw	r16, r24
    55d2:	c6 2f       	mov	r28, r22
  unsigned char temp;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    55d4:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <TWI_Transceiver_Busy>
    55d8:	88 23       	and	r24, r24
    55da:	e1 f7       	brne	.-8      	; 0x55d4 <TWI_Start_Transceiver_With_Data+0xa>

  TWI_msgSize = msgSize;                        // Number of data to transmit.
    55dc:	c0 93 29 04 	sts	0x0429, r28
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
    55e0:	f8 01       	movw	r30, r16
    55e2:	80 81       	ld	r24, Z
    55e4:	80 93 2a 04 	sts	0x042A, r24
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
    55e8:	80 fd       	sbrc	r24, 0
    55ea:	0c c0       	rjmp	.+24     	; 0x5604 <TWI_Start_Transceiver_With_Data+0x3a>
  {
    for ( temp = 1; temp < msgSize; temp++ )
    55ec:	c2 30       	cpi	r28, 0x02	; 2
    55ee:	50 f0       	brcs	.+20     	; 0x5604 <TWI_Start_Transceiver_With_Data+0x3a>
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    55f0:	d8 01       	movw	r26, r16
    55f2:	11 96       	adiw	r26, 0x01	; 1

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    55f4:	eb e2       	ldi	r30, 0x2B	; 43
    55f6:	f4 e0       	ldi	r31, 0x04	; 4
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    55f8:	81 e0       	ldi	r24, 0x01	; 1
  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
      TWI_buf[ temp ] = msg[ temp ];
    55fa:	9d 91       	ld	r25, X+
    55fc:	91 93       	st	Z+, r25

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    55fe:	8f 5f       	subi	r24, 0xFF	; 255
    5600:	8c 17       	cp	r24, r28
    5602:	d9 f7       	brne	.-10     	; 0x55fa <TWI_Start_Transceiver_With_Data+0x30>
      TWI_buf[ temp ] = msg[ temp ];
  }
  TWI_statusReg.all = 0;      
    5604:	10 92 28 04 	sts	0x0428, r1
  TWI_state         = TWI_NO_STATE ;
    5608:	88 ef       	ldi	r24, 0xF8	; 248
    560a:	80 93 1e 04 	sts	0x041E, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    560e:	85 ea       	ldi	r24, 0xA5	; 165
    5610:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    5614:	cf 91       	pop	r28
    5616:	1f 91       	pop	r17
    5618:	0f 91       	pop	r16
    561a:	08 95       	ret

0000561c <TWI_Start_Transceiver>:
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    561c:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <TWI_Transceiver_Busy>
    5620:	88 23       	and	r24, r24
    5622:	e1 f7       	brne	.-8      	; 0x561c <TWI_Start_Transceiver>
  TWI_statusReg.all = 0;      
    5624:	10 92 28 04 	sts	0x0428, r1
  TWI_state         = TWI_NO_STATE ;
    5628:	88 ef       	ldi	r24, 0xF8	; 248
    562a:	80 93 1e 04 	sts	0x041E, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    562e:	85 ea       	ldi	r24, 0xA5	; 165
    5630:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    5634:	08 95       	ret

00005636 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    5636:	1f 93       	push	r17
    5638:	cf 93       	push	r28
    563a:	df 93       	push	r29
    563c:	d8 2f       	mov	r29, r24
    563e:	19 2f       	mov	r17, r25
    5640:	c6 2f       	mov	r28, r22
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    5642:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <TWI_Transceiver_Busy>
    5646:	88 23       	and	r24, r24
    5648:	e1 f7       	brne	.-8      	; 0x5642 <TWI_Get_Data_From_Transceiver+0xc>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    564a:	80 91 28 04 	lds	r24, 0x0428
    564e:	80 ff       	sbrs	r24, 0
    5650:	0d c0       	rjmp	.+26     	; 0x566c <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    5652:	cc 23       	and	r28, r28
    5654:	59 f0       	breq	.+22     	; 0x566c <TWI_Get_Data_From_Transceiver+0x36>
    5656:	aa e2       	ldi	r26, 0x2A	; 42
    5658:	b4 e0       	ldi	r27, 0x04	; 4
    565a:	9d 2f       	mov	r25, r29
    565c:	ed 2f       	mov	r30, r29
    565e:	f1 2f       	mov	r31, r17
    {
      msg[ i ] = TWI_buf[ i ];
    5660:	8d 91       	ld	r24, X+
    5662:	81 93       	st	Z+, r24

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    5664:	8e 2f       	mov	r24, r30
    5666:	89 1b       	sub	r24, r25
    5668:	8c 17       	cp	r24, r28
    566a:	d0 f3       	brcs	.-12     	; 0x5660 <TWI_Get_Data_From_Transceiver+0x2a>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    566c:	80 91 28 04 	lds	r24, 0x0428
}
    5670:	81 70       	andi	r24, 0x01	; 1
    5672:	df 91       	pop	r29
    5674:	cf 91       	pop	r28
    5676:	1f 91       	pop	r17
    5678:	08 95       	ret

0000567a <__vector_26>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/

ISR(TWI_vect)
{
    567a:	1f 92       	push	r1
    567c:	0f 92       	push	r0
    567e:	0f b6       	in	r0, 0x3f	; 63
    5680:	0f 92       	push	r0
    5682:	11 24       	eor	r1, r1
    5684:	2f 93       	push	r18
    5686:	3f 93       	push	r19
    5688:	8f 93       	push	r24
    568a:	9f 93       	push	r25
    568c:	ef 93       	push	r30
    568e:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    5690:	80 91 b9 00 	lds	r24, 0x00B9
    5694:	88 32       	cpi	r24, 0x28	; 40
    5696:	d1 f0       	breq	.+52     	; 0x56cc <__vector_26+0x52>
    5698:	89 32       	cpi	r24, 0x29	; 41
    569a:	40 f4       	brcc	.+16     	; 0x56ac <__vector_26+0x32>
    569c:	80 31       	cpi	r24, 0x10	; 16
    569e:	a1 f0       	breq	.+40     	; 0x56c8 <__vector_26+0x4e>
    56a0:	88 31       	cpi	r24, 0x18	; 24
    56a2:	a1 f0       	breq	.+40     	; 0x56cc <__vector_26+0x52>
    56a4:	88 30       	cpi	r24, 0x08	; 8
    56a6:	09 f0       	breq	.+2      	; 0x56aa <__vector_26+0x30>
    56a8:	61 c0       	rjmp	.+194    	; 0x576c <__vector_26+0xf2>
    56aa:	0e c0       	rjmp	.+28     	; 0x56c8 <__vector_26+0x4e>
    56ac:	80 34       	cpi	r24, 0x40	; 64
    56ae:	b9 f1       	breq	.+110    	; 0x571e <__vector_26+0xa4>
    56b0:	81 34       	cpi	r24, 0x41	; 65
    56b2:	20 f4       	brcc	.+8      	; 0x56bc <__vector_26+0x42>
    56b4:	88 33       	cpi	r24, 0x38	; 56
    56b6:	09 f0       	breq	.+2      	; 0x56ba <__vector_26+0x40>
    56b8:	59 c0       	rjmp	.+178    	; 0x576c <__vector_26+0xf2>
    56ba:	54 c0       	rjmp	.+168    	; 0x5764 <__vector_26+0xea>
    56bc:	80 35       	cpi	r24, 0x50	; 80
    56be:	19 f1       	breq	.+70     	; 0x5706 <__vector_26+0x8c>
    56c0:	88 35       	cpi	r24, 0x58	; 88
    56c2:	09 f0       	breq	.+2      	; 0x56c6 <__vector_26+0x4c>
    56c4:	53 c0       	rjmp	.+166    	; 0x576c <__vector_26+0xf2>
    56c6:	3d c0       	rjmp	.+122    	; 0x5742 <__vector_26+0xc8>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    56c8:	10 92 2e 04 	sts	0x042E, r1
    case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    56cc:	80 91 2e 04 	lds	r24, 0x042E
    56d0:	90 91 29 04 	lds	r25, 0x0429
    56d4:	89 17       	cp	r24, r25
    56d6:	70 f4       	brcc	.+28     	; 0x56f4 <__vector_26+0x7a>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    56d8:	e8 2f       	mov	r30, r24
    56da:	f0 e0       	ldi	r31, 0x00	; 0
    56dc:	e6 5d       	subi	r30, 0xD6	; 214
    56de:	fb 4f       	sbci	r31, 0xFB	; 251
    56e0:	90 81       	ld	r25, Z
    56e2:	90 93 bb 00 	sts	0x00BB, r25
    56e6:	8f 5f       	subi	r24, 0xFF	; 255
    56e8:	80 93 2e 04 	sts	0x042E, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    56ec:	85 e8       	ldi	r24, 0x85	; 133
    56ee:	80 93 bc 00 	sts	0x00BC, r24
    56f2:	43 c0       	rjmp	.+134    	; 0x577a <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    56f4:	80 91 28 04 	lds	r24, 0x0428
    56f8:	81 60       	ori	r24, 0x01	; 1
    56fa:	80 93 28 04 	sts	0x0428, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    56fe:	84 e9       	ldi	r24, 0x94	; 148
    5700:	80 93 bc 00 	sts	0x00BC, r24
    5704:	3a c0       	rjmp	.+116    	; 0x577a <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    5706:	80 91 2e 04 	lds	r24, 0x042E
    570a:	90 91 bb 00 	lds	r25, 0x00BB
    570e:	e8 2f       	mov	r30, r24
    5710:	f0 e0       	ldi	r31, 0x00	; 0
    5712:	e6 5d       	subi	r30, 0xD6	; 214
    5714:	fb 4f       	sbci	r31, 0xFB	; 251
    5716:	90 83       	st	Z, r25
    5718:	8f 5f       	subi	r24, 0xFF	; 255
    571a:	80 93 2e 04 	sts	0x042E, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    571e:	20 91 2e 04 	lds	r18, 0x042E
    5722:	30 e0       	ldi	r19, 0x00	; 0
    5724:	80 91 29 04 	lds	r24, 0x0429
    5728:	90 e0       	ldi	r25, 0x00	; 0
    572a:	01 97       	sbiw	r24, 0x01	; 1
    572c:	28 17       	cp	r18, r24
    572e:	39 07       	cpc	r19, r25
    5730:	24 f4       	brge	.+8      	; 0x573a <__vector_26+0xc0>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    5732:	85 ec       	ldi	r24, 0xC5	; 197
    5734:	80 93 bc 00 	sts	0x00BC, r24
    5738:	20 c0       	rjmp	.+64     	; 0x577a <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    573a:	85 e8       	ldi	r24, 0x85	; 133
    573c:	80 93 bc 00 	sts	0x00BC, r24
    5740:	1c c0       	rjmp	.+56     	; 0x577a <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    5742:	80 91 bb 00 	lds	r24, 0x00BB
    5746:	e0 91 2e 04 	lds	r30, 0x042E
    574a:	f0 e0       	ldi	r31, 0x00	; 0
    574c:	e6 5d       	subi	r30, 0xD6	; 214
    574e:	fb 4f       	sbci	r31, 0xFB	; 251
    5750:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    5752:	80 91 28 04 	lds	r24, 0x0428
    5756:	81 60       	ori	r24, 0x01	; 1
    5758:	80 93 28 04 	sts	0x0428, r24
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    575c:	84 e9       	ldi	r24, 0x94	; 148
    575e:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    5762:	0b c0       	rjmp	.+22     	; 0x577a <__vector_26+0x100>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    5764:	85 ea       	ldi	r24, 0xA5	; 165
    5766:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    576a:	07 c0       	rjmp	.+14     	; 0x577a <__vector_26+0x100>
    case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
//    case TWI_NO_STATE              // No relevant state information available; TWINT = 0
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    576c:	80 91 b9 00 	lds	r24, 0x00B9
    5770:	80 93 1e 04 	sts	0x041E, r24
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    5774:	84 e0       	ldi	r24, 0x04	; 4
    5776:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    577a:	ff 91       	pop	r31
    577c:	ef 91       	pop	r30
    577e:	9f 91       	pop	r25
    5780:	8f 91       	pop	r24
    5782:	3f 91       	pop	r19
    5784:	2f 91       	pop	r18
    5786:	0f 90       	pop	r0
    5788:	0f be       	out	0x3f, r0	; 63
    578a:	0f 90       	pop	r0
    578c:	1f 90       	pop	r1
    578e:	18 95       	reti

00005790 <USART0_Init>:

void USART0_Init()
{
	uint16_t ubrr = UBBR;
	//Set baud rate
	UBRR0H = (unsigned char)(ubrr >>8);
    5790:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (unsigned char)ubrr ;
    5794:	8c e0       	ldi	r24, 0x0C	; 12
    5796:	80 93 c4 00 	sts	0x00C4, r24
	//Enable receiver and transmitter
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    579a:	88 e1       	ldi	r24, 0x18	; 24
    579c:	80 93 c1 00 	sts	0x00C1, r24
	
	UCSR0C = 0x06; //set asynchronous, no parity, one stop bit, 8 bit transfer.
    57a0:	86 e0       	ldi	r24, 0x06	; 6
    57a2:	80 93 c2 00 	sts	0x00C2, r24
	
	//UCSR0B |= (1 << RXCIE0) | (1 << TXCIE0); //set RX and TX interrupt on
}
    57a6:	08 95       	ret

000057a8 <Usart_SendChar>:
void Usart_SendChar(char data) 
{
    // Wait for empty transmit buffer
    while ( !(UCSR0A & (1 << UDRE0)) );
    57a8:	e0 ec       	ldi	r30, 0xC0	; 192
    57aa:	f0 e0       	ldi	r31, 0x00	; 0
    57ac:	90 81       	ld	r25, Z
    57ae:	95 ff       	sbrs	r25, 5
    57b0:	fd cf       	rjmp	.-6      	; 0x57ac <Usart_SendChar+0x4>
    // Start transmission
    UDR0 = data; 
    57b2:	80 93 c6 00 	sts	0x00C6, r24
}
    57b6:	08 95       	ret

000057b8 <Usart_Receive>:
unsigned char Usart_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
    57b8:	e0 ec       	ldi	r30, 0xC0	; 192
    57ba:	f0 e0       	ldi	r31, 0x00	; 0
    57bc:	80 81       	ld	r24, Z
    57be:	88 23       	and	r24, r24
    57c0:	ec f7       	brge	.-6      	; 0x57bc <Usart_Receive+0x4>
	;
	/* Get and return received data from buffer */
	//Usart_SendChar(UDR0);
	return UDR0;
    57c2:	80 91 c6 00 	lds	r24, 0x00C6
}
    57c6:	08 95       	ret

000057c8 <Usart_printf>:
//to use this copy the following as a global- 
//		static FILE mystdout = FDEV_SETUP_STREAM(Usart_printf, NULL, _FDEV_SETUP_WRITE);
// and add this line at the beginning of main:
//		stdout = &mystdout;
//	stdio.h must be used.
int Usart_printf(char var, FILE *stream) {
    57c8:	cf 93       	push	r28
    57ca:	c8 2f       	mov	r28, r24
    // translate \n to \r for br@y++ terminal
    if (var == '\n') Usart_SendChar('\r');
    57cc:	8a 30       	cpi	r24, 0x0A	; 10
    57ce:	19 f4       	brne	.+6      	; 0x57d6 <Usart_printf+0xe>
    57d0:	8d e0       	ldi	r24, 0x0D	; 13
    57d2:	0e 94 d4 2b 	call	0x57a8	; 0x57a8 <Usart_SendChar>
    Usart_SendChar(var);
    57d6:	8c 2f       	mov	r24, r28
    57d8:	0e 94 d4 2b 	call	0x57a8	; 0x57a8 <Usart_SendChar>
    return 0;
}
    57dc:	80 e0       	ldi	r24, 0x00	; 0
    57de:	90 e0       	ldi	r25, 0x00	; 0
    57e0:	cf 91       	pop	r28
    57e2:	08 95       	ret

000057e4 <Usart_get_line>:

void Usart_get_line (char *buff, int len)
{
    57e4:	ef 92       	push	r14
    57e6:	ff 92       	push	r15
    57e8:	0f 93       	push	r16
    57ea:	1f 93       	push	r17
    57ec:	cf 93       	push	r28
    57ee:	df 93       	push	r29
    57f0:	7c 01       	movw	r14, r24
	cli();
    57f2:	f8 94       	cli
	char c;
	int i = 0;
    57f4:	c0 e0       	ldi	r28, 0x00	; 0
    57f6:	d0 e0       	ldi	r29, 0x00	; 0
		if ((c == '\b') && i) {
			i--;
			Usart_SendChar(c);
			continue;
		}
		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    57f8:	8b 01       	movw	r16, r22
    57fa:	01 50       	subi	r16, 0x01	; 1
    57fc:	10 40       	sbci	r17, 0x00	; 0
	char c;
	int i = 0;


	for (;;) {
		c = Usart_Receive();
    57fe:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <Usart_Receive>
		if (c == '\r') break;
    5802:	8d 30       	cpi	r24, 0x0D	; 13
    5804:	a9 f0       	breq	.+42     	; 0x5830 <Usart_get_line+0x4c>
		if ((c == '\b') && i) {
    5806:	88 30       	cpi	r24, 0x08	; 8
    5808:	31 f4       	brne	.+12     	; 0x5816 <Usart_get_line+0x32>
    580a:	20 97       	sbiw	r28, 0x00	; 0
    580c:	c1 f3       	breq	.-16     	; 0x57fe <Usart_get_line+0x1a>
			i--;
    580e:	21 97       	sbiw	r28, 0x01	; 1
			Usart_SendChar(c);
    5810:	0e 94 d4 2b 	call	0x57a8	; 0x57a8 <Usart_SendChar>
			continue;
    5814:	f4 cf       	rjmp	.-24     	; 0x57fe <Usart_get_line+0x1a>
		}
		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    5816:	80 32       	cpi	r24, 0x20	; 32
    5818:	90 f3       	brcs	.-28     	; 0x57fe <Usart_get_line+0x1a>
    581a:	c0 17       	cp	r28, r16
    581c:	d1 07       	cpc	r29, r17
    581e:	7c f7       	brge	.-34     	; 0x57fe <Usart_get_line+0x1a>
			buff[i++] = c;
    5820:	f7 01       	movw	r30, r14
    5822:	ec 0f       	add	r30, r28
    5824:	fd 1f       	adc	r31, r29
    5826:	80 83       	st	Z, r24
    5828:	21 96       	adiw	r28, 0x01	; 1
			Usart_SendChar(c);
    582a:	0e 94 d4 2b 	call	0x57a8	; 0x57a8 <Usart_SendChar>
    582e:	e7 cf       	rjmp	.-50     	; 0x57fe <Usart_get_line+0x1a>
		}
	}
	buff[i] = 0;
    5830:	ce 0d       	add	r28, r14
    5832:	df 1d       	adc	r29, r15
    5834:	18 82       	st	Y, r1
	Usart_SendChar('\n');
    5836:	8a e0       	ldi	r24, 0x0A	; 10
    5838:	0e 94 d4 2b 	call	0x57a8	; 0x57a8 <Usart_SendChar>
	sei();
    583c:	78 94       	sei
}
    583e:	df 91       	pop	r29
    5840:	cf 91       	pop	r28
    5842:	1f 91       	pop	r17
    5844:	0f 91       	pop	r16
    5846:	ff 90       	pop	r15
    5848:	ef 90       	pop	r14
    584a:	08 95       	ret

0000584c <USART0_Senduint16>:
void USART0_Senduint16 (uint16_t Data)
{
    584c:	cf 93       	push	r28
    584e:	c8 2f       	mov	r28, r24
	Usart_SendChar(Data >> 8);
    5850:	89 2f       	mov	r24, r25
    5852:	0e 94 d4 2b 	call	0x57a8	; 0x57a8 <Usart_SendChar>
	Usart_SendChar(Data & 0xFF);
    5856:	8c 2f       	mov	r24, r28
    5858:	0e 94 d4 2b 	call	0x57a8	; 0x57a8 <Usart_SendChar>
    585c:	cf 91       	pop	r28
    585e:	08 95       	ret

00005860 <__mulsi3>:
    5860:	62 9f       	mul	r22, r18
    5862:	d0 01       	movw	r26, r0
    5864:	73 9f       	mul	r23, r19
    5866:	f0 01       	movw	r30, r0
    5868:	82 9f       	mul	r24, r18
    586a:	e0 0d       	add	r30, r0
    586c:	f1 1d       	adc	r31, r1
    586e:	64 9f       	mul	r22, r20
    5870:	e0 0d       	add	r30, r0
    5872:	f1 1d       	adc	r31, r1
    5874:	92 9f       	mul	r25, r18
    5876:	f0 0d       	add	r31, r0
    5878:	83 9f       	mul	r24, r19
    587a:	f0 0d       	add	r31, r0
    587c:	74 9f       	mul	r23, r20
    587e:	f0 0d       	add	r31, r0
    5880:	65 9f       	mul	r22, r21
    5882:	f0 0d       	add	r31, r0
    5884:	99 27       	eor	r25, r25
    5886:	72 9f       	mul	r23, r18
    5888:	b0 0d       	add	r27, r0
    588a:	e1 1d       	adc	r30, r1
    588c:	f9 1f       	adc	r31, r25
    588e:	63 9f       	mul	r22, r19
    5890:	b0 0d       	add	r27, r0
    5892:	e1 1d       	adc	r30, r1
    5894:	f9 1f       	adc	r31, r25
    5896:	bd 01       	movw	r22, r26
    5898:	cf 01       	movw	r24, r30
    589a:	11 24       	eor	r1, r1
    589c:	08 95       	ret

0000589e <__udivmodsi4>:
    589e:	a1 e2       	ldi	r26, 0x21	; 33
    58a0:	1a 2e       	mov	r1, r26
    58a2:	aa 1b       	sub	r26, r26
    58a4:	bb 1b       	sub	r27, r27
    58a6:	fd 01       	movw	r30, r26
    58a8:	0d c0       	rjmp	.+26     	; 0x58c4 <__udivmodsi4_ep>

000058aa <__udivmodsi4_loop>:
    58aa:	aa 1f       	adc	r26, r26
    58ac:	bb 1f       	adc	r27, r27
    58ae:	ee 1f       	adc	r30, r30
    58b0:	ff 1f       	adc	r31, r31
    58b2:	a2 17       	cp	r26, r18
    58b4:	b3 07       	cpc	r27, r19
    58b6:	e4 07       	cpc	r30, r20
    58b8:	f5 07       	cpc	r31, r21
    58ba:	20 f0       	brcs	.+8      	; 0x58c4 <__udivmodsi4_ep>
    58bc:	a2 1b       	sub	r26, r18
    58be:	b3 0b       	sbc	r27, r19
    58c0:	e4 0b       	sbc	r30, r20
    58c2:	f5 0b       	sbc	r31, r21

000058c4 <__udivmodsi4_ep>:
    58c4:	66 1f       	adc	r22, r22
    58c6:	77 1f       	adc	r23, r23
    58c8:	88 1f       	adc	r24, r24
    58ca:	99 1f       	adc	r25, r25
    58cc:	1a 94       	dec	r1
    58ce:	69 f7       	brne	.-38     	; 0x58aa <__udivmodsi4_loop>
    58d0:	60 95       	com	r22
    58d2:	70 95       	com	r23
    58d4:	80 95       	com	r24
    58d6:	90 95       	com	r25
    58d8:	9b 01       	movw	r18, r22
    58da:	ac 01       	movw	r20, r24
    58dc:	bd 01       	movw	r22, r26
    58de:	cf 01       	movw	r24, r30
    58e0:	08 95       	ret

000058e2 <sprintf>:
    58e2:	ae e0       	ldi	r26, 0x0E	; 14
    58e4:	b0 e0       	ldi	r27, 0x00	; 0
    58e6:	e7 e7       	ldi	r30, 0x77	; 119
    58e8:	fc e2       	ldi	r31, 0x2C	; 44
    58ea:	0c 94 1f 2f 	jmp	0x5e3e	; 0x5e3e <__prologue_saves__+0x1c>
    58ee:	0d 89       	ldd	r16, Y+21	; 0x15
    58f0:	1e 89       	ldd	r17, Y+22	; 0x16
    58f2:	86 e0       	ldi	r24, 0x06	; 6
    58f4:	8c 83       	std	Y+4, r24	; 0x04
    58f6:	1a 83       	std	Y+2, r17	; 0x02
    58f8:	09 83       	std	Y+1, r16	; 0x01
    58fa:	8f ef       	ldi	r24, 0xFF	; 255
    58fc:	9f e7       	ldi	r25, 0x7F	; 127
    58fe:	9e 83       	std	Y+6, r25	; 0x06
    5900:	8d 83       	std	Y+5, r24	; 0x05
    5902:	ae 01       	movw	r20, r28
    5904:	47 5e       	subi	r20, 0xE7	; 231
    5906:	5f 4f       	sbci	r21, 0xFF	; 255
    5908:	ce 01       	movw	r24, r28
    590a:	01 96       	adiw	r24, 0x01	; 1
    590c:	6f 89       	ldd	r22, Y+23	; 0x17
    590e:	78 8d       	ldd	r23, Y+24	; 0x18
    5910:	0e 94 93 2c 	call	0x5926	; 0x5926 <vfprintf>
    5914:	ef 81       	ldd	r30, Y+7	; 0x07
    5916:	f8 85       	ldd	r31, Y+8	; 0x08
    5918:	e0 0f       	add	r30, r16
    591a:	f1 1f       	adc	r31, r17
    591c:	10 82       	st	Z, r1
    591e:	2e 96       	adiw	r28, 0x0e	; 14
    5920:	e4 e0       	ldi	r30, 0x04	; 4
    5922:	0c 94 3b 2f 	jmp	0x5e76	; 0x5e76 <__epilogue_restores__+0x1c>

00005926 <vfprintf>:
    5926:	ad e0       	ldi	r26, 0x0D	; 13
    5928:	b0 e0       	ldi	r27, 0x00	; 0
    592a:	e9 e9       	ldi	r30, 0x99	; 153
    592c:	fc e2       	ldi	r31, 0x2C	; 44
    592e:	0c 94 11 2f 	jmp	0x5e22	; 0x5e22 <__prologue_saves__>
    5932:	3c 01       	movw	r6, r24
    5934:	7d 87       	std	Y+13, r23	; 0x0d
    5936:	6c 87       	std	Y+12, r22	; 0x0c
    5938:	5a 01       	movw	r10, r20
    593a:	fc 01       	movw	r30, r24
    593c:	17 82       	std	Z+7, r1	; 0x07
    593e:	16 82       	std	Z+6, r1	; 0x06
    5940:	83 81       	ldd	r24, Z+3	; 0x03
    5942:	81 ff       	sbrs	r24, 1
    5944:	c8 c1       	rjmp	.+912    	; 0x5cd6 <vfprintf+0x3b0>
    5946:	2e 01       	movw	r4, r28
    5948:	08 94       	sec
    594a:	41 1c       	adc	r4, r1
    594c:	51 1c       	adc	r5, r1
    594e:	f3 01       	movw	r30, r6
    5950:	93 81       	ldd	r25, Z+3	; 0x03
    5952:	ec 85       	ldd	r30, Y+12	; 0x0c
    5954:	fd 85       	ldd	r31, Y+13	; 0x0d
    5956:	93 fd       	sbrc	r25, 3
    5958:	85 91       	lpm	r24, Z+
    595a:	93 ff       	sbrs	r25, 3
    595c:	81 91       	ld	r24, Z+
    595e:	fd 87       	std	Y+13, r31	; 0x0d
    5960:	ec 87       	std	Y+12, r30	; 0x0c
    5962:	88 23       	and	r24, r24
    5964:	09 f4       	brne	.+2      	; 0x5968 <vfprintf+0x42>
    5966:	b3 c1       	rjmp	.+870    	; 0x5cce <vfprintf+0x3a8>
    5968:	85 32       	cpi	r24, 0x25	; 37
    596a:	41 f4       	brne	.+16     	; 0x597c <vfprintf+0x56>
    596c:	93 fd       	sbrc	r25, 3
    596e:	85 91       	lpm	r24, Z+
    5970:	93 ff       	sbrs	r25, 3
    5972:	81 91       	ld	r24, Z+
    5974:	fd 87       	std	Y+13, r31	; 0x0d
    5976:	ec 87       	std	Y+12, r30	; 0x0c
    5978:	85 32       	cpi	r24, 0x25	; 37
    597a:	29 f4       	brne	.+10     	; 0x5986 <vfprintf+0x60>
    597c:	90 e0       	ldi	r25, 0x00	; 0
    597e:	b3 01       	movw	r22, r6
    5980:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <fputc>
    5984:	e4 cf       	rjmp	.-56     	; 0x594e <vfprintf+0x28>
    5986:	ff 24       	eor	r15, r15
    5988:	ee 24       	eor	r14, r14
    598a:	10 e0       	ldi	r17, 0x00	; 0
    598c:	10 32       	cpi	r17, 0x20	; 32
    598e:	b0 f4       	brcc	.+44     	; 0x59bc <vfprintf+0x96>
    5990:	8b 32       	cpi	r24, 0x2B	; 43
    5992:	69 f0       	breq	.+26     	; 0x59ae <vfprintf+0x88>
    5994:	8c 32       	cpi	r24, 0x2C	; 44
    5996:	28 f4       	brcc	.+10     	; 0x59a2 <vfprintf+0x7c>
    5998:	80 32       	cpi	r24, 0x20	; 32
    599a:	51 f0       	breq	.+20     	; 0x59b0 <vfprintf+0x8a>
    599c:	83 32       	cpi	r24, 0x23	; 35
    599e:	71 f4       	brne	.+28     	; 0x59bc <vfprintf+0x96>
    59a0:	0b c0       	rjmp	.+22     	; 0x59b8 <vfprintf+0x92>
    59a2:	8d 32       	cpi	r24, 0x2D	; 45
    59a4:	39 f0       	breq	.+14     	; 0x59b4 <vfprintf+0x8e>
    59a6:	80 33       	cpi	r24, 0x30	; 48
    59a8:	49 f4       	brne	.+18     	; 0x59bc <vfprintf+0x96>
    59aa:	11 60       	ori	r17, 0x01	; 1
    59ac:	2c c0       	rjmp	.+88     	; 0x5a06 <vfprintf+0xe0>
    59ae:	12 60       	ori	r17, 0x02	; 2
    59b0:	14 60       	ori	r17, 0x04	; 4
    59b2:	29 c0       	rjmp	.+82     	; 0x5a06 <vfprintf+0xe0>
    59b4:	18 60       	ori	r17, 0x08	; 8
    59b6:	27 c0       	rjmp	.+78     	; 0x5a06 <vfprintf+0xe0>
    59b8:	10 61       	ori	r17, 0x10	; 16
    59ba:	25 c0       	rjmp	.+74     	; 0x5a06 <vfprintf+0xe0>
    59bc:	17 fd       	sbrc	r17, 7
    59be:	2e c0       	rjmp	.+92     	; 0x5a1c <vfprintf+0xf6>
    59c0:	28 2f       	mov	r18, r24
    59c2:	20 53       	subi	r18, 0x30	; 48
    59c4:	2a 30       	cpi	r18, 0x0A	; 10
    59c6:	98 f4       	brcc	.+38     	; 0x59ee <vfprintf+0xc8>
    59c8:	16 ff       	sbrs	r17, 6
    59ca:	08 c0       	rjmp	.+16     	; 0x59dc <vfprintf+0xb6>
    59cc:	8f 2d       	mov	r24, r15
    59ce:	88 0f       	add	r24, r24
    59d0:	f8 2e       	mov	r15, r24
    59d2:	ff 0c       	add	r15, r15
    59d4:	ff 0c       	add	r15, r15
    59d6:	f8 0e       	add	r15, r24
    59d8:	f2 0e       	add	r15, r18
    59da:	15 c0       	rjmp	.+42     	; 0x5a06 <vfprintf+0xe0>
    59dc:	8e 2d       	mov	r24, r14
    59de:	88 0f       	add	r24, r24
    59e0:	e8 2e       	mov	r14, r24
    59e2:	ee 0c       	add	r14, r14
    59e4:	ee 0c       	add	r14, r14
    59e6:	e8 0e       	add	r14, r24
    59e8:	e2 0e       	add	r14, r18
    59ea:	10 62       	ori	r17, 0x20	; 32
    59ec:	0c c0       	rjmp	.+24     	; 0x5a06 <vfprintf+0xe0>
    59ee:	8e 32       	cpi	r24, 0x2E	; 46
    59f0:	21 f4       	brne	.+8      	; 0x59fa <vfprintf+0xd4>
    59f2:	16 fd       	sbrc	r17, 6
    59f4:	6c c1       	rjmp	.+728    	; 0x5cce <vfprintf+0x3a8>
    59f6:	10 64       	ori	r17, 0x40	; 64
    59f8:	06 c0       	rjmp	.+12     	; 0x5a06 <vfprintf+0xe0>
    59fa:	8c 36       	cpi	r24, 0x6C	; 108
    59fc:	11 f4       	brne	.+4      	; 0x5a02 <vfprintf+0xdc>
    59fe:	10 68       	ori	r17, 0x80	; 128
    5a00:	02 c0       	rjmp	.+4      	; 0x5a06 <vfprintf+0xe0>
    5a02:	88 36       	cpi	r24, 0x68	; 104
    5a04:	59 f4       	brne	.+22     	; 0x5a1c <vfprintf+0xf6>
    5a06:	ec 85       	ldd	r30, Y+12	; 0x0c
    5a08:	fd 85       	ldd	r31, Y+13	; 0x0d
    5a0a:	93 fd       	sbrc	r25, 3
    5a0c:	85 91       	lpm	r24, Z+
    5a0e:	93 ff       	sbrs	r25, 3
    5a10:	81 91       	ld	r24, Z+
    5a12:	fd 87       	std	Y+13, r31	; 0x0d
    5a14:	ec 87       	std	Y+12, r30	; 0x0c
    5a16:	88 23       	and	r24, r24
    5a18:	09 f0       	breq	.+2      	; 0x5a1c <vfprintf+0xf6>
    5a1a:	b8 cf       	rjmp	.-144    	; 0x598c <vfprintf+0x66>
    5a1c:	98 2f       	mov	r25, r24
    5a1e:	95 54       	subi	r25, 0x45	; 69
    5a20:	93 30       	cpi	r25, 0x03	; 3
    5a22:	18 f0       	brcs	.+6      	; 0x5a2a <vfprintf+0x104>
    5a24:	90 52       	subi	r25, 0x20	; 32
    5a26:	93 30       	cpi	r25, 0x03	; 3
    5a28:	38 f4       	brcc	.+14     	; 0x5a38 <vfprintf+0x112>
    5a2a:	24 e0       	ldi	r18, 0x04	; 4
    5a2c:	30 e0       	ldi	r19, 0x00	; 0
    5a2e:	a2 0e       	add	r10, r18
    5a30:	b3 1e       	adc	r11, r19
    5a32:	3f e3       	ldi	r19, 0x3F	; 63
    5a34:	39 83       	std	Y+1, r19	; 0x01
    5a36:	0f c0       	rjmp	.+30     	; 0x5a56 <vfprintf+0x130>
    5a38:	83 36       	cpi	r24, 0x63	; 99
    5a3a:	31 f0       	breq	.+12     	; 0x5a48 <vfprintf+0x122>
    5a3c:	83 37       	cpi	r24, 0x73	; 115
    5a3e:	81 f0       	breq	.+32     	; 0x5a60 <vfprintf+0x13a>
    5a40:	83 35       	cpi	r24, 0x53	; 83
    5a42:	09 f0       	breq	.+2      	; 0x5a46 <vfprintf+0x120>
    5a44:	5a c0       	rjmp	.+180    	; 0x5afa <vfprintf+0x1d4>
    5a46:	22 c0       	rjmp	.+68     	; 0x5a8c <vfprintf+0x166>
    5a48:	f5 01       	movw	r30, r10
    5a4a:	80 81       	ld	r24, Z
    5a4c:	89 83       	std	Y+1, r24	; 0x01
    5a4e:	22 e0       	ldi	r18, 0x02	; 2
    5a50:	30 e0       	ldi	r19, 0x00	; 0
    5a52:	a2 0e       	add	r10, r18
    5a54:	b3 1e       	adc	r11, r19
    5a56:	21 e0       	ldi	r18, 0x01	; 1
    5a58:	c2 2e       	mov	r12, r18
    5a5a:	d1 2c       	mov	r13, r1
    5a5c:	42 01       	movw	r8, r4
    5a5e:	14 c0       	rjmp	.+40     	; 0x5a88 <vfprintf+0x162>
    5a60:	92 e0       	ldi	r25, 0x02	; 2
    5a62:	29 2e       	mov	r2, r25
    5a64:	31 2c       	mov	r3, r1
    5a66:	2a 0c       	add	r2, r10
    5a68:	3b 1c       	adc	r3, r11
    5a6a:	f5 01       	movw	r30, r10
    5a6c:	80 80       	ld	r8, Z
    5a6e:	91 80       	ldd	r9, Z+1	; 0x01
    5a70:	16 ff       	sbrs	r17, 6
    5a72:	03 c0       	rjmp	.+6      	; 0x5a7a <vfprintf+0x154>
    5a74:	6f 2d       	mov	r22, r15
    5a76:	70 e0       	ldi	r23, 0x00	; 0
    5a78:	02 c0       	rjmp	.+4      	; 0x5a7e <vfprintf+0x158>
    5a7a:	6f ef       	ldi	r22, 0xFF	; 255
    5a7c:	7f ef       	ldi	r23, 0xFF	; 255
    5a7e:	c4 01       	movw	r24, r8
    5a80:	0e 94 7c 2e 	call	0x5cf8	; 0x5cf8 <strnlen>
    5a84:	6c 01       	movw	r12, r24
    5a86:	51 01       	movw	r10, r2
    5a88:	1f 77       	andi	r17, 0x7F	; 127
    5a8a:	15 c0       	rjmp	.+42     	; 0x5ab6 <vfprintf+0x190>
    5a8c:	82 e0       	ldi	r24, 0x02	; 2
    5a8e:	28 2e       	mov	r2, r24
    5a90:	31 2c       	mov	r3, r1
    5a92:	2a 0c       	add	r2, r10
    5a94:	3b 1c       	adc	r3, r11
    5a96:	f5 01       	movw	r30, r10
    5a98:	80 80       	ld	r8, Z
    5a9a:	91 80       	ldd	r9, Z+1	; 0x01
    5a9c:	16 ff       	sbrs	r17, 6
    5a9e:	03 c0       	rjmp	.+6      	; 0x5aa6 <vfprintf+0x180>
    5aa0:	6f 2d       	mov	r22, r15
    5aa2:	70 e0       	ldi	r23, 0x00	; 0
    5aa4:	02 c0       	rjmp	.+4      	; 0x5aaa <vfprintf+0x184>
    5aa6:	6f ef       	ldi	r22, 0xFF	; 255
    5aa8:	7f ef       	ldi	r23, 0xFF	; 255
    5aaa:	c4 01       	movw	r24, r8
    5aac:	0e 94 71 2e 	call	0x5ce2	; 0x5ce2 <strnlen_P>
    5ab0:	6c 01       	movw	r12, r24
    5ab2:	10 68       	ori	r17, 0x80	; 128
    5ab4:	51 01       	movw	r10, r2
    5ab6:	13 fd       	sbrc	r17, 3
    5ab8:	1c c0       	rjmp	.+56     	; 0x5af2 <vfprintf+0x1cc>
    5aba:	06 c0       	rjmp	.+12     	; 0x5ac8 <vfprintf+0x1a2>
    5abc:	80 e2       	ldi	r24, 0x20	; 32
    5abe:	90 e0       	ldi	r25, 0x00	; 0
    5ac0:	b3 01       	movw	r22, r6
    5ac2:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <fputc>
    5ac6:	ea 94       	dec	r14
    5ac8:	8e 2d       	mov	r24, r14
    5aca:	90 e0       	ldi	r25, 0x00	; 0
    5acc:	c8 16       	cp	r12, r24
    5ace:	d9 06       	cpc	r13, r25
    5ad0:	a8 f3       	brcs	.-22     	; 0x5abc <vfprintf+0x196>
    5ad2:	0f c0       	rjmp	.+30     	; 0x5af2 <vfprintf+0x1cc>
    5ad4:	f4 01       	movw	r30, r8
    5ad6:	17 fd       	sbrc	r17, 7
    5ad8:	85 91       	lpm	r24, Z+
    5ada:	17 ff       	sbrs	r17, 7
    5adc:	81 91       	ld	r24, Z+
    5ade:	4f 01       	movw	r8, r30
    5ae0:	90 e0       	ldi	r25, 0x00	; 0
    5ae2:	b3 01       	movw	r22, r6
    5ae4:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <fputc>
    5ae8:	e1 10       	cpse	r14, r1
    5aea:	ea 94       	dec	r14
    5aec:	08 94       	sec
    5aee:	c1 08       	sbc	r12, r1
    5af0:	d1 08       	sbc	r13, r1
    5af2:	c1 14       	cp	r12, r1
    5af4:	d1 04       	cpc	r13, r1
    5af6:	71 f7       	brne	.-36     	; 0x5ad4 <vfprintf+0x1ae>
    5af8:	e7 c0       	rjmp	.+462    	; 0x5cc8 <vfprintf+0x3a2>
    5afa:	84 36       	cpi	r24, 0x64	; 100
    5afc:	11 f0       	breq	.+4      	; 0x5b02 <vfprintf+0x1dc>
    5afe:	89 36       	cpi	r24, 0x69	; 105
    5b00:	51 f5       	brne	.+84     	; 0x5b56 <vfprintf+0x230>
    5b02:	f5 01       	movw	r30, r10
    5b04:	17 ff       	sbrs	r17, 7
    5b06:	07 c0       	rjmp	.+14     	; 0x5b16 <vfprintf+0x1f0>
    5b08:	80 81       	ld	r24, Z
    5b0a:	91 81       	ldd	r25, Z+1	; 0x01
    5b0c:	a2 81       	ldd	r26, Z+2	; 0x02
    5b0e:	b3 81       	ldd	r27, Z+3	; 0x03
    5b10:	24 e0       	ldi	r18, 0x04	; 4
    5b12:	30 e0       	ldi	r19, 0x00	; 0
    5b14:	08 c0       	rjmp	.+16     	; 0x5b26 <vfprintf+0x200>
    5b16:	80 81       	ld	r24, Z
    5b18:	91 81       	ldd	r25, Z+1	; 0x01
    5b1a:	aa 27       	eor	r26, r26
    5b1c:	97 fd       	sbrc	r25, 7
    5b1e:	a0 95       	com	r26
    5b20:	ba 2f       	mov	r27, r26
    5b22:	22 e0       	ldi	r18, 0x02	; 2
    5b24:	30 e0       	ldi	r19, 0x00	; 0
    5b26:	a2 0e       	add	r10, r18
    5b28:	b3 1e       	adc	r11, r19
    5b2a:	01 2f       	mov	r16, r17
    5b2c:	0f 76       	andi	r16, 0x6F	; 111
    5b2e:	b7 ff       	sbrs	r27, 7
    5b30:	08 c0       	rjmp	.+16     	; 0x5b42 <vfprintf+0x21c>
    5b32:	b0 95       	com	r27
    5b34:	a0 95       	com	r26
    5b36:	90 95       	com	r25
    5b38:	81 95       	neg	r24
    5b3a:	9f 4f       	sbci	r25, 0xFF	; 255
    5b3c:	af 4f       	sbci	r26, 0xFF	; 255
    5b3e:	bf 4f       	sbci	r27, 0xFF	; 255
    5b40:	00 68       	ori	r16, 0x80	; 128
    5b42:	bc 01       	movw	r22, r24
    5b44:	cd 01       	movw	r24, r26
    5b46:	a2 01       	movw	r20, r4
    5b48:	2a e0       	ldi	r18, 0x0A	; 10
    5b4a:	30 e0       	ldi	r19, 0x00	; 0
    5b4c:	0e 94 b3 2e 	call	0x5d66	; 0x5d66 <__ultoa_invert>
    5b50:	d8 2e       	mov	r13, r24
    5b52:	d4 18       	sub	r13, r4
    5b54:	3f c0       	rjmp	.+126    	; 0x5bd4 <vfprintf+0x2ae>
    5b56:	85 37       	cpi	r24, 0x75	; 117
    5b58:	21 f4       	brne	.+8      	; 0x5b62 <vfprintf+0x23c>
    5b5a:	1f 7e       	andi	r17, 0xEF	; 239
    5b5c:	2a e0       	ldi	r18, 0x0A	; 10
    5b5e:	30 e0       	ldi	r19, 0x00	; 0
    5b60:	20 c0       	rjmp	.+64     	; 0x5ba2 <vfprintf+0x27c>
    5b62:	19 7f       	andi	r17, 0xF9	; 249
    5b64:	8f 36       	cpi	r24, 0x6F	; 111
    5b66:	a9 f0       	breq	.+42     	; 0x5b92 <vfprintf+0x26c>
    5b68:	80 37       	cpi	r24, 0x70	; 112
    5b6a:	20 f4       	brcc	.+8      	; 0x5b74 <vfprintf+0x24e>
    5b6c:	88 35       	cpi	r24, 0x58	; 88
    5b6e:	09 f0       	breq	.+2      	; 0x5b72 <vfprintf+0x24c>
    5b70:	ae c0       	rjmp	.+348    	; 0x5cce <vfprintf+0x3a8>
    5b72:	0b c0       	rjmp	.+22     	; 0x5b8a <vfprintf+0x264>
    5b74:	80 37       	cpi	r24, 0x70	; 112
    5b76:	21 f0       	breq	.+8      	; 0x5b80 <vfprintf+0x25a>
    5b78:	88 37       	cpi	r24, 0x78	; 120
    5b7a:	09 f0       	breq	.+2      	; 0x5b7e <vfprintf+0x258>
    5b7c:	a8 c0       	rjmp	.+336    	; 0x5cce <vfprintf+0x3a8>
    5b7e:	01 c0       	rjmp	.+2      	; 0x5b82 <vfprintf+0x25c>
    5b80:	10 61       	ori	r17, 0x10	; 16
    5b82:	14 ff       	sbrs	r17, 4
    5b84:	09 c0       	rjmp	.+18     	; 0x5b98 <vfprintf+0x272>
    5b86:	14 60       	ori	r17, 0x04	; 4
    5b88:	07 c0       	rjmp	.+14     	; 0x5b98 <vfprintf+0x272>
    5b8a:	14 ff       	sbrs	r17, 4
    5b8c:	08 c0       	rjmp	.+16     	; 0x5b9e <vfprintf+0x278>
    5b8e:	16 60       	ori	r17, 0x06	; 6
    5b90:	06 c0       	rjmp	.+12     	; 0x5b9e <vfprintf+0x278>
    5b92:	28 e0       	ldi	r18, 0x08	; 8
    5b94:	30 e0       	ldi	r19, 0x00	; 0
    5b96:	05 c0       	rjmp	.+10     	; 0x5ba2 <vfprintf+0x27c>
    5b98:	20 e1       	ldi	r18, 0x10	; 16
    5b9a:	30 e0       	ldi	r19, 0x00	; 0
    5b9c:	02 c0       	rjmp	.+4      	; 0x5ba2 <vfprintf+0x27c>
    5b9e:	20 e1       	ldi	r18, 0x10	; 16
    5ba0:	32 e0       	ldi	r19, 0x02	; 2
    5ba2:	f5 01       	movw	r30, r10
    5ba4:	17 ff       	sbrs	r17, 7
    5ba6:	07 c0       	rjmp	.+14     	; 0x5bb6 <vfprintf+0x290>
    5ba8:	60 81       	ld	r22, Z
    5baa:	71 81       	ldd	r23, Z+1	; 0x01
    5bac:	82 81       	ldd	r24, Z+2	; 0x02
    5bae:	93 81       	ldd	r25, Z+3	; 0x03
    5bb0:	44 e0       	ldi	r20, 0x04	; 4
    5bb2:	50 e0       	ldi	r21, 0x00	; 0
    5bb4:	06 c0       	rjmp	.+12     	; 0x5bc2 <vfprintf+0x29c>
    5bb6:	60 81       	ld	r22, Z
    5bb8:	71 81       	ldd	r23, Z+1	; 0x01
    5bba:	80 e0       	ldi	r24, 0x00	; 0
    5bbc:	90 e0       	ldi	r25, 0x00	; 0
    5bbe:	42 e0       	ldi	r20, 0x02	; 2
    5bc0:	50 e0       	ldi	r21, 0x00	; 0
    5bc2:	a4 0e       	add	r10, r20
    5bc4:	b5 1e       	adc	r11, r21
    5bc6:	a2 01       	movw	r20, r4
    5bc8:	0e 94 b3 2e 	call	0x5d66	; 0x5d66 <__ultoa_invert>
    5bcc:	d8 2e       	mov	r13, r24
    5bce:	d4 18       	sub	r13, r4
    5bd0:	01 2f       	mov	r16, r17
    5bd2:	0f 77       	andi	r16, 0x7F	; 127
    5bd4:	06 ff       	sbrs	r16, 6
    5bd6:	09 c0       	rjmp	.+18     	; 0x5bea <vfprintf+0x2c4>
    5bd8:	0e 7f       	andi	r16, 0xFE	; 254
    5bda:	df 14       	cp	r13, r15
    5bdc:	30 f4       	brcc	.+12     	; 0x5bea <vfprintf+0x2c4>
    5bde:	04 ff       	sbrs	r16, 4
    5be0:	06 c0       	rjmp	.+12     	; 0x5bee <vfprintf+0x2c8>
    5be2:	02 fd       	sbrc	r16, 2
    5be4:	04 c0       	rjmp	.+8      	; 0x5bee <vfprintf+0x2c8>
    5be6:	0f 7e       	andi	r16, 0xEF	; 239
    5be8:	02 c0       	rjmp	.+4      	; 0x5bee <vfprintf+0x2c8>
    5bea:	1d 2d       	mov	r17, r13
    5bec:	01 c0       	rjmp	.+2      	; 0x5bf0 <vfprintf+0x2ca>
    5bee:	1f 2d       	mov	r17, r15
    5bf0:	80 2f       	mov	r24, r16
    5bf2:	90 e0       	ldi	r25, 0x00	; 0
    5bf4:	04 ff       	sbrs	r16, 4
    5bf6:	0c c0       	rjmp	.+24     	; 0x5c10 <vfprintf+0x2ea>
    5bf8:	fe 01       	movw	r30, r28
    5bfa:	ed 0d       	add	r30, r13
    5bfc:	f1 1d       	adc	r31, r1
    5bfe:	20 81       	ld	r18, Z
    5c00:	20 33       	cpi	r18, 0x30	; 48
    5c02:	11 f4       	brne	.+4      	; 0x5c08 <vfprintf+0x2e2>
    5c04:	09 7e       	andi	r16, 0xE9	; 233
    5c06:	09 c0       	rjmp	.+18     	; 0x5c1a <vfprintf+0x2f4>
    5c08:	02 ff       	sbrs	r16, 2
    5c0a:	06 c0       	rjmp	.+12     	; 0x5c18 <vfprintf+0x2f2>
    5c0c:	1e 5f       	subi	r17, 0xFE	; 254
    5c0e:	05 c0       	rjmp	.+10     	; 0x5c1a <vfprintf+0x2f4>
    5c10:	86 78       	andi	r24, 0x86	; 134
    5c12:	90 70       	andi	r25, 0x00	; 0
    5c14:	00 97       	sbiw	r24, 0x00	; 0
    5c16:	09 f0       	breq	.+2      	; 0x5c1a <vfprintf+0x2f4>
    5c18:	1f 5f       	subi	r17, 0xFF	; 255
    5c1a:	80 2e       	mov	r8, r16
    5c1c:	99 24       	eor	r9, r9
    5c1e:	03 fd       	sbrc	r16, 3
    5c20:	12 c0       	rjmp	.+36     	; 0x5c46 <vfprintf+0x320>
    5c22:	00 ff       	sbrs	r16, 0
    5c24:	0d c0       	rjmp	.+26     	; 0x5c40 <vfprintf+0x31a>
    5c26:	fd 2c       	mov	r15, r13
    5c28:	1e 15       	cp	r17, r14
    5c2a:	50 f4       	brcc	.+20     	; 0x5c40 <vfprintf+0x31a>
    5c2c:	fe 0c       	add	r15, r14
    5c2e:	f1 1a       	sub	r15, r17
    5c30:	1e 2d       	mov	r17, r14
    5c32:	06 c0       	rjmp	.+12     	; 0x5c40 <vfprintf+0x31a>
    5c34:	80 e2       	ldi	r24, 0x20	; 32
    5c36:	90 e0       	ldi	r25, 0x00	; 0
    5c38:	b3 01       	movw	r22, r6
    5c3a:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <fputc>
    5c3e:	1f 5f       	subi	r17, 0xFF	; 255
    5c40:	1e 15       	cp	r17, r14
    5c42:	c0 f3       	brcs	.-16     	; 0x5c34 <vfprintf+0x30e>
    5c44:	04 c0       	rjmp	.+8      	; 0x5c4e <vfprintf+0x328>
    5c46:	1e 15       	cp	r17, r14
    5c48:	10 f4       	brcc	.+4      	; 0x5c4e <vfprintf+0x328>
    5c4a:	e1 1a       	sub	r14, r17
    5c4c:	01 c0       	rjmp	.+2      	; 0x5c50 <vfprintf+0x32a>
    5c4e:	ee 24       	eor	r14, r14
    5c50:	84 fe       	sbrs	r8, 4
    5c52:	0f c0       	rjmp	.+30     	; 0x5c72 <vfprintf+0x34c>
    5c54:	80 e3       	ldi	r24, 0x30	; 48
    5c56:	90 e0       	ldi	r25, 0x00	; 0
    5c58:	b3 01       	movw	r22, r6
    5c5a:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <fputc>
    5c5e:	82 fe       	sbrs	r8, 2
    5c60:	1f c0       	rjmp	.+62     	; 0x5ca0 <vfprintf+0x37a>
    5c62:	81 fe       	sbrs	r8, 1
    5c64:	03 c0       	rjmp	.+6      	; 0x5c6c <vfprintf+0x346>
    5c66:	88 e5       	ldi	r24, 0x58	; 88
    5c68:	90 e0       	ldi	r25, 0x00	; 0
    5c6a:	10 c0       	rjmp	.+32     	; 0x5c8c <vfprintf+0x366>
    5c6c:	88 e7       	ldi	r24, 0x78	; 120
    5c6e:	90 e0       	ldi	r25, 0x00	; 0
    5c70:	0d c0       	rjmp	.+26     	; 0x5c8c <vfprintf+0x366>
    5c72:	c4 01       	movw	r24, r8
    5c74:	86 78       	andi	r24, 0x86	; 134
    5c76:	90 70       	andi	r25, 0x00	; 0
    5c78:	00 97       	sbiw	r24, 0x00	; 0
    5c7a:	91 f0       	breq	.+36     	; 0x5ca0 <vfprintf+0x37a>
    5c7c:	81 fc       	sbrc	r8, 1
    5c7e:	02 c0       	rjmp	.+4      	; 0x5c84 <vfprintf+0x35e>
    5c80:	80 e2       	ldi	r24, 0x20	; 32
    5c82:	01 c0       	rjmp	.+2      	; 0x5c86 <vfprintf+0x360>
    5c84:	8b e2       	ldi	r24, 0x2B	; 43
    5c86:	07 fd       	sbrc	r16, 7
    5c88:	8d e2       	ldi	r24, 0x2D	; 45
    5c8a:	90 e0       	ldi	r25, 0x00	; 0
    5c8c:	b3 01       	movw	r22, r6
    5c8e:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <fputc>
    5c92:	06 c0       	rjmp	.+12     	; 0x5ca0 <vfprintf+0x37a>
    5c94:	80 e3       	ldi	r24, 0x30	; 48
    5c96:	90 e0       	ldi	r25, 0x00	; 0
    5c98:	b3 01       	movw	r22, r6
    5c9a:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <fputc>
    5c9e:	fa 94       	dec	r15
    5ca0:	df 14       	cp	r13, r15
    5ca2:	c0 f3       	brcs	.-16     	; 0x5c94 <vfprintf+0x36e>
    5ca4:	da 94       	dec	r13
    5ca6:	f2 01       	movw	r30, r4
    5ca8:	ed 0d       	add	r30, r13
    5caa:	f1 1d       	adc	r31, r1
    5cac:	80 81       	ld	r24, Z
    5cae:	90 e0       	ldi	r25, 0x00	; 0
    5cb0:	b3 01       	movw	r22, r6
    5cb2:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <fputc>
    5cb6:	dd 20       	and	r13, r13
    5cb8:	a9 f7       	brne	.-22     	; 0x5ca4 <vfprintf+0x37e>
    5cba:	06 c0       	rjmp	.+12     	; 0x5cc8 <vfprintf+0x3a2>
    5cbc:	80 e2       	ldi	r24, 0x20	; 32
    5cbe:	90 e0       	ldi	r25, 0x00	; 0
    5cc0:	b3 01       	movw	r22, r6
    5cc2:	0e 94 87 2e 	call	0x5d0e	; 0x5d0e <fputc>
    5cc6:	ea 94       	dec	r14
    5cc8:	ee 20       	and	r14, r14
    5cca:	c1 f7       	brne	.-16     	; 0x5cbc <vfprintf+0x396>
    5ccc:	40 ce       	rjmp	.-896    	; 0x594e <vfprintf+0x28>
    5cce:	f3 01       	movw	r30, r6
    5cd0:	86 81       	ldd	r24, Z+6	; 0x06
    5cd2:	97 81       	ldd	r25, Z+7	; 0x07
    5cd4:	02 c0       	rjmp	.+4      	; 0x5cda <vfprintf+0x3b4>
    5cd6:	8f ef       	ldi	r24, 0xFF	; 255
    5cd8:	9f ef       	ldi	r25, 0xFF	; 255
    5cda:	2d 96       	adiw	r28, 0x0d	; 13
    5cdc:	e2 e1       	ldi	r30, 0x12	; 18
    5cde:	0c 94 2d 2f 	jmp	0x5e5a	; 0x5e5a <__epilogue_restores__>

00005ce2 <strnlen_P>:
    5ce2:	fc 01       	movw	r30, r24
    5ce4:	05 90       	lpm	r0, Z+
    5ce6:	61 50       	subi	r22, 0x01	; 1
    5ce8:	70 40       	sbci	r23, 0x00	; 0
    5cea:	01 10       	cpse	r0, r1
    5cec:	d8 f7       	brcc	.-10     	; 0x5ce4 <strnlen_P+0x2>
    5cee:	80 95       	com	r24
    5cf0:	90 95       	com	r25
    5cf2:	8e 0f       	add	r24, r30
    5cf4:	9f 1f       	adc	r25, r31
    5cf6:	08 95       	ret

00005cf8 <strnlen>:
    5cf8:	fc 01       	movw	r30, r24
    5cfa:	61 50       	subi	r22, 0x01	; 1
    5cfc:	70 40       	sbci	r23, 0x00	; 0
    5cfe:	01 90       	ld	r0, Z+
    5d00:	01 10       	cpse	r0, r1
    5d02:	d8 f7       	brcc	.-10     	; 0x5cfa <strnlen+0x2>
    5d04:	80 95       	com	r24
    5d06:	90 95       	com	r25
    5d08:	8e 0f       	add	r24, r30
    5d0a:	9f 1f       	adc	r25, r31
    5d0c:	08 95       	ret

00005d0e <fputc>:
    5d0e:	0f 93       	push	r16
    5d10:	1f 93       	push	r17
    5d12:	cf 93       	push	r28
    5d14:	df 93       	push	r29
    5d16:	8c 01       	movw	r16, r24
    5d18:	eb 01       	movw	r28, r22
    5d1a:	8b 81       	ldd	r24, Y+3	; 0x03
    5d1c:	81 ff       	sbrs	r24, 1
    5d1e:	1b c0       	rjmp	.+54     	; 0x5d56 <fputc+0x48>
    5d20:	82 ff       	sbrs	r24, 2
    5d22:	0d c0       	rjmp	.+26     	; 0x5d3e <fputc+0x30>
    5d24:	2e 81       	ldd	r18, Y+6	; 0x06
    5d26:	3f 81       	ldd	r19, Y+7	; 0x07
    5d28:	8c 81       	ldd	r24, Y+4	; 0x04
    5d2a:	9d 81       	ldd	r25, Y+5	; 0x05
    5d2c:	28 17       	cp	r18, r24
    5d2e:	39 07       	cpc	r19, r25
    5d30:	64 f4       	brge	.+24     	; 0x5d4a <fputc+0x3c>
    5d32:	e8 81       	ld	r30, Y
    5d34:	f9 81       	ldd	r31, Y+1	; 0x01
    5d36:	01 93       	st	Z+, r16
    5d38:	f9 83       	std	Y+1, r31	; 0x01
    5d3a:	e8 83       	st	Y, r30
    5d3c:	06 c0       	rjmp	.+12     	; 0x5d4a <fputc+0x3c>
    5d3e:	e8 85       	ldd	r30, Y+8	; 0x08
    5d40:	f9 85       	ldd	r31, Y+9	; 0x09
    5d42:	80 2f       	mov	r24, r16
    5d44:	09 95       	icall
    5d46:	00 97       	sbiw	r24, 0x00	; 0
    5d48:	31 f4       	brne	.+12     	; 0x5d56 <fputc+0x48>
    5d4a:	8e 81       	ldd	r24, Y+6	; 0x06
    5d4c:	9f 81       	ldd	r25, Y+7	; 0x07
    5d4e:	01 96       	adiw	r24, 0x01	; 1
    5d50:	9f 83       	std	Y+7, r25	; 0x07
    5d52:	8e 83       	std	Y+6, r24	; 0x06
    5d54:	02 c0       	rjmp	.+4      	; 0x5d5a <fputc+0x4c>
    5d56:	0f ef       	ldi	r16, 0xFF	; 255
    5d58:	1f ef       	ldi	r17, 0xFF	; 255
    5d5a:	c8 01       	movw	r24, r16
    5d5c:	df 91       	pop	r29
    5d5e:	cf 91       	pop	r28
    5d60:	1f 91       	pop	r17
    5d62:	0f 91       	pop	r16
    5d64:	08 95       	ret

00005d66 <__ultoa_invert>:
    5d66:	fa 01       	movw	r30, r20
    5d68:	aa 27       	eor	r26, r26
    5d6a:	28 30       	cpi	r18, 0x08	; 8
    5d6c:	51 f1       	breq	.+84     	; 0x5dc2 <__ultoa_invert+0x5c>
    5d6e:	20 31       	cpi	r18, 0x10	; 16
    5d70:	81 f1       	breq	.+96     	; 0x5dd2 <__ultoa_invert+0x6c>
    5d72:	e8 94       	clt
    5d74:	6f 93       	push	r22
    5d76:	6e 7f       	andi	r22, 0xFE	; 254
    5d78:	6e 5f       	subi	r22, 0xFE	; 254
    5d7a:	7f 4f       	sbci	r23, 0xFF	; 255
    5d7c:	8f 4f       	sbci	r24, 0xFF	; 255
    5d7e:	9f 4f       	sbci	r25, 0xFF	; 255
    5d80:	af 4f       	sbci	r26, 0xFF	; 255
    5d82:	b1 e0       	ldi	r27, 0x01	; 1
    5d84:	3e d0       	rcall	.+124    	; 0x5e02 <__ultoa_invert+0x9c>
    5d86:	b4 e0       	ldi	r27, 0x04	; 4
    5d88:	3c d0       	rcall	.+120    	; 0x5e02 <__ultoa_invert+0x9c>
    5d8a:	67 0f       	add	r22, r23
    5d8c:	78 1f       	adc	r23, r24
    5d8e:	89 1f       	adc	r24, r25
    5d90:	9a 1f       	adc	r25, r26
    5d92:	a1 1d       	adc	r26, r1
    5d94:	68 0f       	add	r22, r24
    5d96:	79 1f       	adc	r23, r25
    5d98:	8a 1f       	adc	r24, r26
    5d9a:	91 1d       	adc	r25, r1
    5d9c:	a1 1d       	adc	r26, r1
    5d9e:	6a 0f       	add	r22, r26
    5da0:	71 1d       	adc	r23, r1
    5da2:	81 1d       	adc	r24, r1
    5da4:	91 1d       	adc	r25, r1
    5da6:	a1 1d       	adc	r26, r1
    5da8:	20 d0       	rcall	.+64     	; 0x5dea <__ultoa_invert+0x84>
    5daa:	09 f4       	brne	.+2      	; 0x5dae <__ultoa_invert+0x48>
    5dac:	68 94       	set
    5dae:	3f 91       	pop	r19
    5db0:	2a e0       	ldi	r18, 0x0A	; 10
    5db2:	26 9f       	mul	r18, r22
    5db4:	11 24       	eor	r1, r1
    5db6:	30 19       	sub	r19, r0
    5db8:	30 5d       	subi	r19, 0xD0	; 208
    5dba:	31 93       	st	Z+, r19
    5dbc:	de f6       	brtc	.-74     	; 0x5d74 <__ultoa_invert+0xe>
    5dbe:	cf 01       	movw	r24, r30
    5dc0:	08 95       	ret
    5dc2:	46 2f       	mov	r20, r22
    5dc4:	47 70       	andi	r20, 0x07	; 7
    5dc6:	40 5d       	subi	r20, 0xD0	; 208
    5dc8:	41 93       	st	Z+, r20
    5dca:	b3 e0       	ldi	r27, 0x03	; 3
    5dcc:	0f d0       	rcall	.+30     	; 0x5dec <__ultoa_invert+0x86>
    5dce:	c9 f7       	brne	.-14     	; 0x5dc2 <__ultoa_invert+0x5c>
    5dd0:	f6 cf       	rjmp	.-20     	; 0x5dbe <__ultoa_invert+0x58>
    5dd2:	46 2f       	mov	r20, r22
    5dd4:	4f 70       	andi	r20, 0x0F	; 15
    5dd6:	40 5d       	subi	r20, 0xD0	; 208
    5dd8:	4a 33       	cpi	r20, 0x3A	; 58
    5dda:	18 f0       	brcs	.+6      	; 0x5de2 <__ultoa_invert+0x7c>
    5ddc:	49 5d       	subi	r20, 0xD9	; 217
    5dde:	31 fd       	sbrc	r19, 1
    5de0:	40 52       	subi	r20, 0x20	; 32
    5de2:	41 93       	st	Z+, r20
    5de4:	02 d0       	rcall	.+4      	; 0x5dea <__ultoa_invert+0x84>
    5de6:	a9 f7       	brne	.-22     	; 0x5dd2 <__ultoa_invert+0x6c>
    5de8:	ea cf       	rjmp	.-44     	; 0x5dbe <__ultoa_invert+0x58>
    5dea:	b4 e0       	ldi	r27, 0x04	; 4
    5dec:	a6 95       	lsr	r26
    5dee:	97 95       	ror	r25
    5df0:	87 95       	ror	r24
    5df2:	77 95       	ror	r23
    5df4:	67 95       	ror	r22
    5df6:	ba 95       	dec	r27
    5df8:	c9 f7       	brne	.-14     	; 0x5dec <__ultoa_invert+0x86>
    5dfa:	00 97       	sbiw	r24, 0x00	; 0
    5dfc:	61 05       	cpc	r22, r1
    5dfe:	71 05       	cpc	r23, r1
    5e00:	08 95       	ret
    5e02:	9b 01       	movw	r18, r22
    5e04:	ac 01       	movw	r20, r24
    5e06:	0a 2e       	mov	r0, r26
    5e08:	06 94       	lsr	r0
    5e0a:	57 95       	ror	r21
    5e0c:	47 95       	ror	r20
    5e0e:	37 95       	ror	r19
    5e10:	27 95       	ror	r18
    5e12:	ba 95       	dec	r27
    5e14:	c9 f7       	brne	.-14     	; 0x5e08 <__ultoa_invert+0xa2>
    5e16:	62 0f       	add	r22, r18
    5e18:	73 1f       	adc	r23, r19
    5e1a:	84 1f       	adc	r24, r20
    5e1c:	95 1f       	adc	r25, r21
    5e1e:	a0 1d       	adc	r26, r0
    5e20:	08 95       	ret

00005e22 <__prologue_saves__>:
    5e22:	2f 92       	push	r2
    5e24:	3f 92       	push	r3
    5e26:	4f 92       	push	r4
    5e28:	5f 92       	push	r5
    5e2a:	6f 92       	push	r6
    5e2c:	7f 92       	push	r7
    5e2e:	8f 92       	push	r8
    5e30:	9f 92       	push	r9
    5e32:	af 92       	push	r10
    5e34:	bf 92       	push	r11
    5e36:	cf 92       	push	r12
    5e38:	df 92       	push	r13
    5e3a:	ef 92       	push	r14
    5e3c:	ff 92       	push	r15
    5e3e:	0f 93       	push	r16
    5e40:	1f 93       	push	r17
    5e42:	cf 93       	push	r28
    5e44:	df 93       	push	r29
    5e46:	cd b7       	in	r28, 0x3d	; 61
    5e48:	de b7       	in	r29, 0x3e	; 62
    5e4a:	ca 1b       	sub	r28, r26
    5e4c:	db 0b       	sbc	r29, r27
    5e4e:	0f b6       	in	r0, 0x3f	; 63
    5e50:	f8 94       	cli
    5e52:	de bf       	out	0x3e, r29	; 62
    5e54:	0f be       	out	0x3f, r0	; 63
    5e56:	cd bf       	out	0x3d, r28	; 61
    5e58:	09 94       	ijmp

00005e5a <__epilogue_restores__>:
    5e5a:	2a 88       	ldd	r2, Y+18	; 0x12
    5e5c:	39 88       	ldd	r3, Y+17	; 0x11
    5e5e:	48 88       	ldd	r4, Y+16	; 0x10
    5e60:	5f 84       	ldd	r5, Y+15	; 0x0f
    5e62:	6e 84       	ldd	r6, Y+14	; 0x0e
    5e64:	7d 84       	ldd	r7, Y+13	; 0x0d
    5e66:	8c 84       	ldd	r8, Y+12	; 0x0c
    5e68:	9b 84       	ldd	r9, Y+11	; 0x0b
    5e6a:	aa 84       	ldd	r10, Y+10	; 0x0a
    5e6c:	b9 84       	ldd	r11, Y+9	; 0x09
    5e6e:	c8 84       	ldd	r12, Y+8	; 0x08
    5e70:	df 80       	ldd	r13, Y+7	; 0x07
    5e72:	ee 80       	ldd	r14, Y+6	; 0x06
    5e74:	fd 80       	ldd	r15, Y+5	; 0x05
    5e76:	0c 81       	ldd	r16, Y+4	; 0x04
    5e78:	1b 81       	ldd	r17, Y+3	; 0x03
    5e7a:	aa 81       	ldd	r26, Y+2	; 0x02
    5e7c:	b9 81       	ldd	r27, Y+1	; 0x01
    5e7e:	ce 0f       	add	r28, r30
    5e80:	d1 1d       	adc	r29, r1
    5e82:	0f b6       	in	r0, 0x3f	; 63
    5e84:	f8 94       	cli
    5e86:	de bf       	out	0x3e, r29	; 62
    5e88:	0f be       	out	0x3f, r0	; 63
    5e8a:	cd bf       	out	0x3d, r28	; 61
    5e8c:	ed 01       	movw	r28, r26
    5e8e:	08 95       	ret

00005e90 <_exit>:
    5e90:	f8 94       	cli

00005e92 <__stop_program>:
    5e92:	ff cf       	rjmp	.-2      	; 0x5e92 <__stop_program>
