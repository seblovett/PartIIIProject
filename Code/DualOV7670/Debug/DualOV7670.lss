
DualOV7670.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000002f0  00800100  00005d6a  00005dfe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005d6a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000a9f  008003f0  008003f0  000060ee  2**0
                  ALLOC
  3 .stab         00000c84  00000000  00000000  000060f0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001b6  00000000  00000000  00006d74  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000002a0  00000000  00000000  00006f30  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005b54  00000000  00000000  000071d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000165f  00000000  00000000  0000cd24  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000249b  00000000  00000000  0000e383  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000118c  00000000  00000000  00010820  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000c8c  00000000  00000000  000119ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006d48  00000000  00000000  00012638  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000158  00000000  00000000  00019380  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 82 05 	jmp	0xb04	; 0xb04 <__vector_1>
       8:	0c 94 ad 05 	jmp	0xb5a	; 0xb5a <__vector_2>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 26 08 	jmp	0x104c	; 0x104c <__vector_16>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 65 2a 	jmp	0x54ca	; 0x54ca <__vector_26>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d0 e1       	ldi	r29, 0x10	; 16
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	13 e0       	ldi	r17, 0x03	; 3
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	ea e6       	ldi	r30, 0x6A	; 106
      90:	fd e5       	ldi	r31, 0x5D	; 93
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	a0 3f       	cpi	r26, 0xF0	; 240
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	1e e0       	ldi	r17, 0x0E	; 14
      a0:	a0 ef       	ldi	r26, 0xF0	; 240
      a2:	b3 e0       	ldi	r27, 0x03	; 3
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	af 38       	cpi	r26, 0x8F	; 143
      aa:	b1 07       	cpc	r27, r17
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 68 08 	call	0x10d0	; 0x10d0 <main>
      b2:	0c 94 b3 2e 	jmp	0x5d66	; 0x5d66 <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <WriteBMPHeader>:
										};



FRESULT WriteBMPHeader(FIL *File)
{
      ba:	0f 93       	push	r16
      bc:	1f 93       	push	r17
      be:	cf 93       	push	r28
      c0:	df 93       	push	r29
      c2:	00 d0       	rcall	.+0      	; 0xc4 <WriteBMPHeader+0xa>
      c4:	00 d0       	rcall	.+0      	; 0xc6 <WriteBMPHeader+0xc>
      c6:	cd b7       	in	r28, 0x3d	; 61
      c8:	de b7       	in	r29, 0x3e	; 62
      ca:	8c 01       	movw	r16, r24
	uint32_t p;
	FRESULT f; 
	
	f_lseek(File, 0);
      cc:	40 e0       	ldi	r20, 0x00	; 0
      ce:	50 e0       	ldi	r21, 0x00	; 0
      d0:	ba 01       	movw	r22, r20
      d2:	0e 94 a6 20 	call	0x414c	; 0x414c <f_lseek>
	f = f_write(File, BMPHeader, BMPHEADERSIZE, &p);
      d6:	c8 01       	movw	r24, r16
      d8:	60 e0       	ldi	r22, 0x00	; 0
      da:	71 e0       	ldi	r23, 0x01	; 1
      dc:	2e e0       	ldi	r18, 0x0E	; 14
      de:	30 e0       	ldi	r19, 0x00	; 0
      e0:	40 e0       	ldi	r20, 0x00	; 0
      e2:	50 e0       	ldi	r21, 0x00	; 0
      e4:	8e 01       	movw	r16, r28
      e6:	0f 5f       	subi	r16, 0xFF	; 255
      e8:	1f 4f       	sbci	r17, 0xFF	; 255
      ea:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <f_write>
	
	return f;
}
      ee:	0f 90       	pop	r0
      f0:	0f 90       	pop	r0
      f2:	0f 90       	pop	r0
      f4:	0f 90       	pop	r0
      f6:	df 91       	pop	r29
      f8:	cf 91       	pop	r28
      fa:	1f 91       	pop	r17
      fc:	0f 91       	pop	r16
      fe:	08 95       	ret

00000100 <WriteDIBHeader>:

FRESULT WriteDIBHeader(FIL *File)
{
     100:	0f 93       	push	r16
     102:	1f 93       	push	r17
     104:	cf 93       	push	r28
     106:	df 93       	push	r29
     108:	00 d0       	rcall	.+0      	; 0x10a <WriteDIBHeader+0xa>
     10a:	00 d0       	rcall	.+0      	; 0x10c <WriteDIBHeader+0xc>
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
     110:	8c 01       	movw	r16, r24
	uint32_t p;
	FRESULT f;
	
	f_lseek(File, BMPHEADERSIZE);//place just after the bitmap header
     112:	4e e0       	ldi	r20, 0x0E	; 14
     114:	50 e0       	ldi	r21, 0x00	; 0
     116:	60 e0       	ldi	r22, 0x00	; 0
     118:	70 e0       	ldi	r23, 0x00	; 0
     11a:	0e 94 a6 20 	call	0x414c	; 0x414c <f_lseek>
	f = f_write(File, DIBHead, DIBHEADERSIZE, &p);
     11e:	c8 01       	movw	r24, r16
     120:	6e e0       	ldi	r22, 0x0E	; 14
     122:	71 e0       	ldi	r23, 0x01	; 1
     124:	2c e7       	ldi	r18, 0x7C	; 124
     126:	30 e0       	ldi	r19, 0x00	; 0
     128:	40 e0       	ldi	r20, 0x00	; 0
     12a:	50 e0       	ldi	r21, 0x00	; 0
     12c:	8e 01       	movw	r16, r28
     12e:	0f 5f       	subi	r16, 0xFF	; 255
     130:	1f 4f       	sbci	r17, 0xFF	; 255
     132:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <f_write>
	return f;
}
     136:	0f 90       	pop	r0
     138:	0f 90       	pop	r0
     13a:	0f 90       	pop	r0
     13c:	0f 90       	pop	r0
     13e:	df 91       	pop	r29
     140:	cf 91       	pop	r28
     142:	1f 91       	pop	r17
     144:	0f 91       	pop	r16
     146:	08 95       	ret

00000148 <IO_Init>:
#include "Config.h"
#include <avr/io.h>
void IO_Init(void)
{
	//initialise timer 0 to interrupt every 10 ms
	TIMSK0 |= (1 << OCIE0A);
     148:	ee e6       	ldi	r30, 0x6E	; 110
     14a:	f0 e0       	ldi	r31, 0x00	; 0
     14c:	80 81       	ld	r24, Z
     14e:	82 60       	ori	r24, 0x02	; 2
     150:	80 83       	st	Z, r24
	TCCR0A |= (1 << WGM01);
     152:	84 b5       	in	r24, 0x24	; 36
     154:	82 60       	ori	r24, 0x02	; 2
     156:	84 bd       	out	0x24, r24	; 36
	OCR0A = 117; //10ms interrupt at 12MHz
     158:	85 e7       	ldi	r24, 0x75	; 117
     15a:	87 bd       	out	0x27, r24	; 39
	TCCR0B |= (1 << CS02) | (1 << CS00);
     15c:	85 b5       	in	r24, 0x25	; 37
     15e:	85 60       	ori	r24, 0x05	; 5
     160:	85 bd       	out	0x25, r24	; 37
	
	
	DDRA = 0x00;
     162:	11 b8       	out	0x01, r1	; 1
	//PORTB = 0xBF;
	DDRC = 0xFC;
     164:	8c ef       	ldi	r24, 0xFC	; 252
     166:	87 b9       	out	0x07, r24	; 7
	DDRD = 0xF2;
     168:	82 ef       	ldi	r24, 0xF2	; 242
     16a:	8a b9       	out	0x0a, r24	; 10
	
	
	
	//set int0 and int1 to trigger on falling edge
	EIMSK = (1 << INT0) | (1 << INT1);				//Enable INT0 and INT1
     16c:	83 e0       	ldi	r24, 0x03	; 3
     16e:	8d bb       	out	0x1d, r24	; 29
	EICRA = (1 << ISC01) | (1 << ISC11);			//Trigger INT0 and INT1 on the falling edge
     170:	8a e0       	ldi	r24, 0x0A	; 10
     172:	80 93 69 00 	sts	0x0069, r24
     176:	08 95       	ret

00000178 <power_off>:
}

static
void power_off (void)
{
	SPCR = 0;				/* Disable SPI function */
     178:	1c bc       	out	0x2c, r1	; 44
// 	DDRB  &= ~0b00110111;	/* Set SCK/MOSI/CS as hi-z, INS#/WP as pull-up */
// 	PORTB &= ~0b00000111;
// 	PORTB |=  0b00110000;


	PORTB = ~0b00010000;      // SS high
     17a:	8f ee       	ldi	r24, 0xEF	; 239
     17c:	85 b9       	out	0x05, r24	; 5
	DDRB =  ~(uint8_t)0b10110000;      // !SS,SCK and MOSI outputs
     17e:	8f e4       	ldi	r24, 0x4F	; 79
     180:	84 b9       	out	0x04, r24	; 4
// 	{	/* Remove this block if no socket power control */
// 		PORTE |= _BV(7);		/* Socket power off (PE7=high) */
// 		for (Timer1 = 20; Timer1; );	/* Wait for 20ms */
// 	}
}
     182:	08 95       	ret

00000184 <xchg_spi>:
static
BYTE xchg_spi (		/* Returns received data */
	BYTE dat		/* Data to be sent */
)
{
	SPDR = dat;
     184:	8e bd       	out	0x2e, r24	; 46
	loop_until_bit_is_set(SPSR, SPIF);
     186:	0d b4       	in	r0, 0x2d	; 45
     188:	07 fe       	sbrs	r0, 7
     18a:	fd cf       	rjmp	.-6      	; 0x186 <xchg_spi+0x2>
	return SPDR;
     18c:	8e b5       	in	r24, 0x2e	; 46
}
     18e:	08 95       	ret

00000190 <wait_ready>:
int wait_ready (void)	/* 1:OK, 0:Timeout */
{
	BYTE d;


	Timer2 = 50;	/* Wait for ready in timeout of 500ms */
     190:	82 e3       	ldi	r24, 0x32	; 50
     192:	80 93 f0 03 	sts	0x03F0, r24
	do
		d = xchg_spi(0xFF);
     196:	8f ef       	ldi	r24, 0xFF	; 255
     198:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	while (d != 0xFF && Timer2);
     19c:	8f 3f       	cpi	r24, 0xFF	; 255
     19e:	21 f0       	breq	.+8      	; 0x1a8 <wait_ready+0x18>
     1a0:	90 91 f0 03 	lds	r25, 0x03F0
     1a4:	99 23       	and	r25, r25
     1a6:	b9 f7       	brne	.-18     	; 0x196 <wait_ready+0x6>

	return (d == 0xFF) ? 1 : 0;
     1a8:	21 e0       	ldi	r18, 0x01	; 1
     1aa:	30 e0       	ldi	r19, 0x00	; 0
     1ac:	8f 3f       	cpi	r24, 0xFF	; 255
     1ae:	11 f0       	breq	.+4      	; 0x1b4 <wait_ready+0x24>
     1b0:	20 e0       	ldi	r18, 0x00	; 0
     1b2:	30 e0       	ldi	r19, 0x00	; 0
}
     1b4:	82 2f       	mov	r24, r18
     1b6:	93 2f       	mov	r25, r19
     1b8:	08 95       	ret

000001ba <deselect>:
/*-----------------------------------------------------------------------*/

static
void deselect (void)
{
	CS_HIGH();
     1ba:	2c 9a       	sbi	0x05, 4	; 5
	xchg_spi(0xFF);	/* Dummy clock (force DO hi-z for multiple slave SPI) */
     1bc:	8f ef       	ldi	r24, 0xFF	; 255
     1be:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
}
     1c2:	08 95       	ret

000001c4 <select>:
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:Successful, 0:Timeout */
{
	CS_LOW();
     1c4:	2c 98       	cbi	0x05, 4	; 5
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */
     1c6:	8f ef       	ldi	r24, 0xFF	; 255
     1c8:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>

	if (wait_ready()) return 1;	/* OK */
     1cc:	0e 94 c8 00 	call	0x190	; 0x190 <wait_ready>
     1d0:	00 97       	sbiw	r24, 0x00	; 0
     1d2:	29 f4       	brne	.+10     	; 0x1de <select+0x1a>
	deselect();
     1d4:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
	return 0;	/* Timeout */
     1d8:	80 e0       	ldi	r24, 0x00	; 0
     1da:	90 e0       	ldi	r25, 0x00	; 0
     1dc:	08 95       	ret
int select (void)	/* 1:Successful, 0:Timeout */
{
	CS_LOW();
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */

	if (wait_ready()) return 1;	/* OK */
     1de:	81 e0       	ldi	r24, 0x01	; 1
     1e0:	90 e0       	ldi	r25, 0x00	; 0
	deselect();
	return 0;	/* Timeout */
}
     1e2:	08 95       	ret

000001e4 <rcvr_datablock>:
static
int rcvr_datablock (
	BYTE *buff,			/* Data buffer to store received data */
	UINT btr			/* Byte count (must be multiple of 4) */
)
{
     1e4:	cf 92       	push	r12
     1e6:	df 92       	push	r13
     1e8:	ef 92       	push	r14
     1ea:	ff 92       	push	r15
     1ec:	cf 93       	push	r28
     1ee:	df 93       	push	r29
     1f0:	ec 01       	movw	r28, r24
     1f2:	6a 01       	movw	r12, r20
     1f4:	7b 01       	movw	r14, r22
	BYTE token;


	Timer1 = 20;
     1f6:	84 e1       	ldi	r24, 0x14	; 20
     1f8:	80 93 f1 03 	sts	0x03F1, r24
	do {							/* Wait for data packet in timeout of 200ms */
		token = xchg_spi(0xFF);
     1fc:	8f ef       	ldi	r24, 0xFF	; 255
     1fe:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	} while ((token == 0xFF) && Timer1);
     202:	8f 3f       	cpi	r24, 0xFF	; 255
     204:	39 f4       	brne	.+14     	; 0x214 <rcvr_datablock+0x30>
     206:	80 91 f1 03 	lds	r24, 0x03F1
     20a:	88 23       	and	r24, r24
     20c:	b9 f7       	brne	.-18     	; 0x1fc <rcvr_datablock+0x18>
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */
     20e:	80 e0       	ldi	r24, 0x00	; 0
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	28 c0       	rjmp	.+80     	; 0x264 <rcvr_datablock+0x80>
     214:	8e 3f       	cpi	r24, 0xFE	; 254
     216:	21 f5       	brne	.+72     	; 0x260 <rcvr_datablock+0x7c>
	BYTE *p,	/* Data buffer */
	UINT cnt	/* Size of data block */
)
{
	do {
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
     218:	8f ef       	ldi	r24, 0xFF	; 255
     21a:	8e bd       	out	0x2e, r24	; 46
     21c:	0d b4       	in	r0, 0x2d	; 45
     21e:	07 fe       	sbrs	r0, 7
     220:	fd cf       	rjmp	.-6      	; 0x21c <rcvr_datablock+0x38>
     222:	9e b5       	in	r25, 0x2e	; 46
     224:	98 83       	st	Y, r25
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
     226:	8e bd       	out	0x2e, r24	; 46
     228:	0d b4       	in	r0, 0x2d	; 45
     22a:	07 fe       	sbrs	r0, 7
     22c:	fd cf       	rjmp	.-6      	; 0x228 <rcvr_datablock+0x44>
     22e:	9e b5       	in	r25, 0x2e	; 46
     230:	99 83       	std	Y+1, r25	; 0x01
/*-----------------------------------------------------------------------*/
/* Receive a data packet from MMC                                        */
/*-----------------------------------------------------------------------*/

static
int rcvr_datablock (
     232:	22 96       	adiw	r28, 0x02	; 2
)
{
	do {
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
	} while (cnt -= 2);
     234:	2e ef       	ldi	r18, 0xFE	; 254
     236:	3f ef       	ldi	r19, 0xFF	; 255
     238:	4f ef       	ldi	r20, 0xFF	; 255
     23a:	5f ef       	ldi	r21, 0xFF	; 255
     23c:	c2 0e       	add	r12, r18
     23e:	d3 1e       	adc	r13, r19
     240:	e4 1e       	adc	r14, r20
     242:	f5 1e       	adc	r15, r21
     244:	c1 14       	cp	r12, r1
     246:	d1 04       	cpc	r13, r1
     248:	e1 04       	cpc	r14, r1
     24a:	f1 04       	cpc	r15, r1
     24c:	31 f7       	brne	.-52     	; 0x21a <rcvr_datablock+0x36>
		token = xchg_spi(0xFF);
	} while ((token == 0xFF) && Timer1);
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */

	rcvr_spi_multi(buff, btr);		/* Receive the data block into buffer */
	xchg_spi(0xFF);					/* Discard CRC */
     24e:	8f ef       	ldi	r24, 0xFF	; 255
     250:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi(0xFF);
     254:	8f ef       	ldi	r24, 0xFF	; 255
     256:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>

	return 1;						/* Return with success */
     25a:	81 e0       	ldi	r24, 0x01	; 1
     25c:	90 e0       	ldi	r25, 0x00	; 0
     25e:	02 c0       	rjmp	.+4      	; 0x264 <rcvr_datablock+0x80>

	Timer1 = 20;
	do {							/* Wait for data packet in timeout of 200ms */
		token = xchg_spi(0xFF);
	} while ((token == 0xFF) && Timer1);
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */
     260:	80 e0       	ldi	r24, 0x00	; 0
     262:	90 e0       	ldi	r25, 0x00	; 0
	rcvr_spi_multi(buff, btr);		/* Receive the data block into buffer */
	xchg_spi(0xFF);					/* Discard CRC */
	xchg_spi(0xFF);

	return 1;						/* Return with success */
}
     264:	df 91       	pop	r29
     266:	cf 91       	pop	r28
     268:	ff 90       	pop	r15
     26a:	ef 90       	pop	r14
     26c:	df 90       	pop	r13
     26e:	cf 90       	pop	r12
     270:	08 95       	ret

00000272 <xmit_datablock>:
static
int xmit_datablock (
	const BYTE *buff,	/* 512 byte data block to be transmitted */
	BYTE token			/* Data/Stop token */
)
{
     272:	1f 93       	push	r17
     274:	cf 93       	push	r28
     276:	df 93       	push	r29
     278:	ec 01       	movw	r28, r24
     27a:	16 2f       	mov	r17, r22
	BYTE resp;


	if (!wait_ready()) return 0;
     27c:	0e 94 c8 00 	call	0x190	; 0x190 <wait_ready>
     280:	00 97       	sbiw	r24, 0x00	; 0
     282:	41 f1       	breq	.+80     	; 0x2d4 <xmit_datablock+0x62>

	xchg_spi(token);					/* Xmit data token */
     284:	81 2f       	mov	r24, r17
     286:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	if (token != 0xFD) {	/* Is data token */
     28a:	1d 3f       	cpi	r17, 0xFD	; 253
     28c:	31 f1       	breq	.+76     	; 0x2da <xmit_datablock+0x68>
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     28e:	ce 01       	movw	r24, r28
     290:	80 50       	subi	r24, 0x00	; 0
     292:	9e 4f       	sbci	r25, 0xFE	; 254
	const BYTE *p,	/* Data block to be sent */
	UINT cnt		/* Size of data block */
)
{
	do {
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     294:	28 81       	ld	r18, Y
     296:	2e bd       	out	0x2e, r18	; 46
     298:	0d b4       	in	r0, 0x2d	; 45
     29a:	07 fe       	sbrs	r0, 7
     29c:	fd cf       	rjmp	.-6      	; 0x298 <xmit_datablock+0x26>
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     29e:	29 81       	ldd	r18, Y+1	; 0x01
     2a0:	2e bd       	out	0x2e, r18	; 46
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     2a2:	22 96       	adiw	r28, 0x02	; 2
	UINT cnt		/* Size of data block */
)
{
	do {
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     2a4:	0d b4       	in	r0, 0x2d	; 45
     2a6:	07 fe       	sbrs	r0, 7
     2a8:	fd cf       	rjmp	.-6      	; 0x2a4 <xmit_datablock+0x32>
	} while (cnt -= 2);
     2aa:	8c 17       	cp	r24, r28
     2ac:	9d 07       	cpc	r25, r29
     2ae:	91 f7       	brne	.-28     	; 0x294 <xmit_datablock+0x22>
	if (!wait_ready()) return 0;

	xchg_spi(token);					/* Xmit data token */
	if (token != 0xFD) {	/* Is data token */
		xmit_spi_multi(buff, 512);		/* Xmit the data block to the MMC */
		xchg_spi(0xFF);					/* CRC (Dummy) */
     2b0:	8f ef       	ldi	r24, 0xFF	; 255
     2b2:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
		xchg_spi(0xFF);
     2b6:	8f ef       	ldi	r24, 0xFF	; 255
     2b8:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
		resp = xchg_spi(0xFF);			/* Reveive data response */
     2bc:	8f ef       	ldi	r24, 0xFF	; 255
     2be:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
     2c2:	8f 71       	andi	r24, 0x1F	; 31
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     2c4:	21 e0       	ldi	r18, 0x01	; 1
     2c6:	30 e0       	ldi	r19, 0x00	; 0
     2c8:	85 30       	cpi	r24, 0x05	; 5
     2ca:	11 f0       	breq	.+4      	; 0x2d0 <xmit_datablock+0x5e>
     2cc:	20 e0       	ldi	r18, 0x00	; 0
     2ce:	30 e0       	ldi	r19, 0x00	; 0
)
{
	BYTE resp;


	if (!wait_ready()) return 0;
     2d0:	c9 01       	movw	r24, r18
     2d2:	05 c0       	rjmp	.+10     	; 0x2de <xmit_datablock+0x6c>
     2d4:	80 e0       	ldi	r24, 0x00	; 0
     2d6:	90 e0       	ldi	r25, 0x00	; 0
     2d8:	02 c0       	rjmp	.+4      	; 0x2de <xmit_datablock+0x6c>
		resp = xchg_spi(0xFF);			/* Reveive data response */
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
			return 0;
	}

	return 1;
     2da:	81 e0       	ldi	r24, 0x01	; 1
     2dc:	90 e0       	ldi	r25, 0x00	; 0
}
     2de:	df 91       	pop	r29
     2e0:	cf 91       	pop	r28
     2e2:	1f 91       	pop	r17
     2e4:	08 95       	ret

000002e6 <send_cmd>:
static
BYTE send_cmd (		/* Returns R1 resp (bit7==1:Send failed) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
     2e6:	ff 92       	push	r15
     2e8:	0f 93       	push	r16
     2ea:	1f 93       	push	r17
     2ec:	cf 93       	push	r28
     2ee:	df 93       	push	r29
     2f0:	c8 2f       	mov	r28, r24
     2f2:	d4 2f       	mov	r29, r20
     2f4:	15 2f       	mov	r17, r21
     2f6:	06 2f       	mov	r16, r22
     2f8:	f7 2e       	mov	r15, r23
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
     2fa:	88 23       	and	r24, r24
     2fc:	4c f4       	brge	.+18     	; 0x310 <send_cmd+0x2a>
		cmd &= 0x7F;
		res = send_cmd(CMD55, 0);
     2fe:	87 e3       	ldi	r24, 0x37	; 55
     300:	40 e0       	ldi	r20, 0x00	; 0
     302:	50 e0       	ldi	r21, 0x00	; 0
     304:	ba 01       	movw	r22, r20
     306:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
		if (res > 1) return res;
     30a:	82 30       	cpi	r24, 0x02	; 2
     30c:	68 f5       	brcc	.+90     	; 0x368 <send_cmd+0x82>
{
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
     30e:	cf 77       	andi	r28, 0x7F	; 127
		res = send_cmd(CMD55, 0);
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	deselect();
     310:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
	if (!select()) return 0xFF;
     314:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <select>
     318:	00 97       	sbiw	r24, 0x00	; 0
     31a:	29 f1       	breq	.+74     	; 0x366 <send_cmd+0x80>

	/* Send command packet */
	xchg_spi(0x40 | cmd);				/* Start + Command index */
     31c:	8c 2f       	mov	r24, r28
     31e:	80 64       	ori	r24, 0x40	; 64
     320:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
     324:	8f 2d       	mov	r24, r15
     326:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
     32a:	80 2f       	mov	r24, r16
     32c:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
     330:	81 2f       	mov	r24, r17
     332:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
     336:	8d 2f       	mov	r24, r29
     338:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) + Stop */
     33c:	cc 23       	and	r28, r28
     33e:	f1 f0       	breq	.+60     	; 0x37c <send_cmd+0x96>
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) Stop */
     340:	c8 30       	cpi	r28, 0x08	; 8
     342:	c1 f0       	breq	.+48     	; 0x374 <send_cmd+0x8e>
	xchg_spi(n);
     344:	81 e0       	ldi	r24, 0x01	; 1
     346:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>

	/* Receive command response */
	if (cmd == CMD12) xchg_spi(0xFF);		/* Skip a stuff byte when stop reading */
     34a:	cc 30       	cpi	r28, 0x0C	; 12
     34c:	19 f4       	brne	.+6      	; 0x354 <send_cmd+0x6e>
     34e:	8f ef       	ldi	r24, 0xFF	; 255
     350:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
static
BYTE send_cmd (		/* Returns R1 resp (bit7==1:Send failed) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
     354:	ca e0       	ldi	r28, 0x0A	; 10

	/* Receive command response */
	if (cmd == CMD12) xchg_spi(0xFF);		/* Skip a stuff byte when stop reading */
	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do
		res = xchg_spi(0xFF);
     356:	8f ef       	ldi	r24, 0xFF	; 255
     358:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	while ((res & 0x80) && --n);
     35c:	88 23       	and	r24, r24
     35e:	24 f4       	brge	.+8      	; 0x368 <send_cmd+0x82>
     360:	c1 50       	subi	r28, 0x01	; 1
     362:	c9 f7       	brne	.-14     	; 0x356 <send_cmd+0x70>
     364:	01 c0       	rjmp	.+2      	; 0x368 <send_cmd+0x82>
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	deselect();
	if (!select()) return 0xFF;
     366:	8f ef       	ldi	r24, 0xFF	; 255
	do
		res = xchg_spi(0xFF);
	while ((res & 0x80) && --n);

	return res;			/* Return with the response value */
}
     368:	df 91       	pop	r29
     36a:	cf 91       	pop	r28
     36c:	1f 91       	pop	r17
     36e:	0f 91       	pop	r16
     370:	ff 90       	pop	r15
     372:	08 95       	ret
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) + Stop */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) Stop */
	xchg_spi(n);
     374:	87 e8       	ldi	r24, 0x87	; 135
     376:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     37a:	ec cf       	rjmp	.-40     	; 0x354 <send_cmd+0x6e>
     37c:	85 e9       	ldi	r24, 0x95	; 149
     37e:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     382:	e8 cf       	rjmp	.-48     	; 0x354 <send_cmd+0x6e>

00000384 <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
     384:	cf 92       	push	r12
     386:	df 92       	push	r13
     388:	ef 92       	push	r14
     38a:	ff 92       	push	r15
     38c:	0f 93       	push	r16
     38e:	1f 93       	push	r17
     390:	cf 93       	push	r28
     392:	df 93       	push	r29
     394:	00 d0       	rcall	.+0      	; 0x396 <disk_initialize+0x12>
     396:	00 d0       	rcall	.+0      	; 0x398 <disk_initialize+0x14>
     398:	cd b7       	in	r28, 0x3d	; 61
     39a:	de b7       	in	r29, 0x3e	; 62
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only single drive */
     39c:	88 23       	and	r24, r24
     39e:	09 f0       	breq	.+2      	; 0x3a2 <disk_initialize+0x1e>
     3a0:	a8 c0       	rjmp	.+336    	; 0x4f2 <disk_initialize+0x16e>
	power_off();						/* Turn off the socket power to reset the card */
     3a2:	0e 94 bc 00 	call	0x178	; 0x178 <power_off>
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
     3a6:	80 91 8a 01 	lds	r24, 0x018A
     3aa:	81 ff       	sbrs	r24, 1
     3ac:	03 c0       	rjmp	.+6      	; 0x3b4 <disk_initialize+0x30>
     3ae:	80 91 8a 01 	lds	r24, 0x018A
     3b2:	a0 c0       	rjmp	.+320    	; 0x4f4 <disk_initialize+0x170>
	// Configure for: PB4 - /SS
	//                PB5 - MOSI
	//                PB6 - MISO
	//                PB7 - SCK

	PORTB = 0b00010000;      // SS high
     3b4:	80 e1       	ldi	r24, 0x10	; 16
     3b6:	85 b9       	out	0x05, r24	; 5
	DDRB =  0b10110000;      // !SS,SCK and MOSI outputs
     3b8:	80 eb       	ldi	r24, 0xB0	; 176
     3ba:	84 b9       	out	0x04, r24	; 4

	/* Set MOSI and SCK output, all others input */
	//DDR_SPI = (1<<DD_MOSI)|(1<<DD_SCK);
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
     3bc:	81 e5       	ldi	r24, 0x51	; 81
     3be:	8c bd       	out	0x2c, r24	; 44

	if (drv) return STA_NOINIT;			/* Supports only single drive */
	power_off();						/* Turn off the socket power to reset the card */
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
	power_on();							/* Turn on the socket power */
	FCLK_SLOW();
     3c0:	82 e5       	ldi	r24, 0x52	; 82
     3c2:	8c bd       	out	0x2c, r24	; 44
     3c4:	0a e0       	ldi	r16, 0x0A	; 10
	for (n = 10; n; n--) xchg_spi(0xFF);	/* 80 dummy clocks */
     3c6:	8f ef       	ldi	r24, 0xFF	; 255
     3c8:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     3cc:	01 50       	subi	r16, 0x01	; 1
     3ce:	d9 f7       	brne	.-10     	; 0x3c6 <disk_initialize+0x42>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
     3d0:	80 e0       	ldi	r24, 0x00	; 0
     3d2:	40 e0       	ldi	r20, 0x00	; 0
     3d4:	50 e0       	ldi	r21, 0x00	; 0
     3d6:	ba 01       	movw	r22, r20
     3d8:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     3dc:	81 30       	cpi	r24, 0x01	; 1
     3de:	09 f0       	breq	.+2      	; 0x3e2 <disk_initialize+0x5e>
     3e0:	9c c0       	rjmp	.+312    	; 0x51a <disk_initialize+0x196>
		Timer1 = 100;						/* Initialization timeout of 1000 msec */
     3e2:	84 e6       	ldi	r24, 0x64	; 100
     3e4:	80 93 f1 03 	sts	0x03F1, r24
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
     3e8:	88 e0       	ldi	r24, 0x08	; 8
     3ea:	4a ea       	ldi	r20, 0xAA	; 170
     3ec:	51 e0       	ldi	r21, 0x01	; 1
     3ee:	60 e0       	ldi	r22, 0x00	; 0
     3f0:	70 e0       	ldi	r23, 0x00	; 0
     3f2:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     3f6:	81 30       	cpi	r24, 0x01	; 1
     3f8:	09 f0       	breq	.+2      	; 0x3fc <disk_initialize+0x78>
     3fa:	42 c0       	rjmp	.+132    	; 0x480 <disk_initialize+0xfc>
     3fc:	6e 01       	movw	r12, r28
     3fe:	08 94       	sec
     400:	c1 1c       	adc	r12, r1
     402:	d1 1c       	adc	r13, r1

/*-----------------------------------------------------------------------*/
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
     404:	8e 01       	movw	r16, r28
     406:	0b 5f       	subi	r16, 0xFB	; 251
     408:	1f 4f       	sbci	r17, 0xFF	; 255
     40a:	76 01       	movw	r14, r12

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		Timer1 = 100;						/* Initialization timeout of 1000 msec */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);		/* Get trailing return value of R7 resp */
     40c:	8f ef       	ldi	r24, 0xFF	; 255
     40e:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     412:	f7 01       	movw	r30, r14
     414:	81 93       	st	Z+, r24
     416:	7f 01       	movw	r14, r30
     418:	e0 17       	cp	r30, r16
     41a:	f1 07       	cpc	r31, r17
     41c:	b9 f7       	brne	.-18     	; 0x40c <disk_initialize+0x88>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	81 30       	cpi	r24, 0x01	; 1
     422:	09 f0       	breq	.+2      	; 0x426 <disk_initialize+0xa2>
     424:	7a c0       	rjmp	.+244    	; 0x51a <disk_initialize+0x196>
     426:	8c 81       	ldd	r24, Y+4	; 0x04
     428:	8a 3a       	cpi	r24, 0xAA	; 170
     42a:	09 f0       	breq	.+2      	; 0x42e <disk_initialize+0xaa>
     42c:	76 c0       	rjmp	.+236    	; 0x51a <disk_initialize+0x196>
				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
     42e:	80 91 f1 03 	lds	r24, 0x03F1
     432:	88 23       	and	r24, r24
     434:	49 f0       	breq	.+18     	; 0x448 <disk_initialize+0xc4>
     436:	89 ea       	ldi	r24, 0xA9	; 169
     438:	40 e0       	ldi	r20, 0x00	; 0
     43a:	50 e0       	ldi	r21, 0x00	; 0
     43c:	60 e0       	ldi	r22, 0x00	; 0
     43e:	70 e4       	ldi	r23, 0x40	; 64
     440:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     444:	88 23       	and	r24, r24
     446:	99 f7       	brne	.-26     	; 0x42e <disk_initialize+0xaa>
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
     448:	80 91 f1 03 	lds	r24, 0x03F1
     44c:	88 23       	and	r24, r24
     44e:	09 f4       	brne	.+2      	; 0x452 <disk_initialize+0xce>
     450:	64 c0       	rjmp	.+200    	; 0x51a <disk_initialize+0x196>
     452:	8a e3       	ldi	r24, 0x3A	; 58
     454:	40 e0       	ldi	r20, 0x00	; 0
     456:	50 e0       	ldi	r21, 0x00	; 0
     458:	ba 01       	movw	r22, r20
     45a:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     45e:	88 23       	and	r24, r24
     460:	09 f0       	breq	.+2      	; 0x464 <disk_initialize+0xe0>
     462:	5b c0       	rjmp	.+182    	; 0x51a <disk_initialize+0x196>
     464:	04 e0       	ldi	r16, 0x04	; 4
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
     466:	8f ef       	ldi	r24, 0xFF	; 255
     468:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     46c:	f6 01       	movw	r30, r12
     46e:	81 93       	st	Z+, r24
     470:	6f 01       	movw	r12, r30
     472:	01 50       	subi	r16, 0x01	; 1
     474:	c1 f7       	brne	.-16     	; 0x466 <disk_initialize+0xe2>
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
     476:	89 81       	ldd	r24, Y+1	; 0x01
     478:	86 fd       	sbrc	r24, 6
     47a:	49 c0       	rjmp	.+146    	; 0x50e <disk_initialize+0x18a>
     47c:	84 e0       	ldi	r24, 0x04	; 4
     47e:	48 c0       	rjmp	.+144    	; 0x510 <disk_initialize+0x18c>
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
     480:	89 ea       	ldi	r24, 0xA9	; 169
     482:	40 e0       	ldi	r20, 0x00	; 0
     484:	50 e0       	ldi	r21, 0x00	; 0
     486:	ba 01       	movw	r22, r20
     488:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     48c:	82 30       	cpi	r24, 0x02	; 2
     48e:	18 f4       	brcc	.+6      	; 0x496 <disk_initialize+0x112>
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
     490:	12 e0       	ldi	r17, 0x02	; 2
     492:	09 ea       	ldi	r16, 0xA9	; 169
     494:	02 c0       	rjmp	.+4      	; 0x49a <disk_initialize+0x116>
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
     496:	11 e0       	ldi	r17, 0x01	; 1
     498:	01 e0       	ldi	r16, 0x01	; 1
			}
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
     49a:	80 91 f1 03 	lds	r24, 0x03F1
     49e:	88 23       	and	r24, r24
     4a0:	41 f0       	breq	.+16     	; 0x4b2 <disk_initialize+0x12e>
     4a2:	80 2f       	mov	r24, r16
     4a4:	40 e0       	ldi	r20, 0x00	; 0
     4a6:	50 e0       	ldi	r21, 0x00	; 0
     4a8:	ba 01       	movw	r22, r20
     4aa:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     4ae:	88 23       	and	r24, r24
     4b0:	a1 f7       	brne	.-24     	; 0x49a <disk_initialize+0x116>
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
     4b2:	80 91 f1 03 	lds	r24, 0x03F1
     4b6:	88 23       	and	r24, r24
     4b8:	81 f1       	breq	.+96     	; 0x51a <disk_initialize+0x196>
     4ba:	80 e1       	ldi	r24, 0x10	; 16
     4bc:	40 e0       	ldi	r20, 0x00	; 0
     4be:	52 e0       	ldi	r21, 0x02	; 2
     4c0:	60 e0       	ldi	r22, 0x00	; 0
     4c2:	70 e0       	ldi	r23, 0x00	; 0
     4c4:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     4c8:	88 23       	and	r24, r24
     4ca:	39 f5       	brne	.+78     	; 0x51a <disk_initialize+0x196>
				ty = 0;
		}
	}
	CardType = ty;
     4cc:	10 93 f2 03 	sts	0x03F2, r17
	deselect();
     4d0:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>

	if (ty) {			/* Initialization succeded */
     4d4:	11 23       	and	r17, r17
     4d6:	41 f0       	breq	.+16     	; 0x4e8 <disk_initialize+0x164>
		Stat &= ~STA_NOINIT;		/* Clear STA_NOINIT */
     4d8:	80 91 8a 01 	lds	r24, 0x018A
     4dc:	8e 7f       	andi	r24, 0xFE	; 254
     4de:	80 93 8a 01 	sts	0x018A, r24
		FCLK_FAST();
     4e2:	80 e5       	ldi	r24, 0x50	; 80
     4e4:	8c bd       	out	0x2c, r24	; 44
     4e6:	02 c0       	rjmp	.+4      	; 0x4ec <disk_initialize+0x168>
	} else {			/* Initialization failed */
		power_off();
     4e8:	0e 94 bc 00 	call	0x178	; 0x178 <power_off>
	}

	return Stat;
     4ec:	80 91 8a 01 	lds	r24, 0x018A
     4f0:	01 c0       	rjmp	.+2      	; 0x4f4 <disk_initialize+0x170>
)
{
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only single drive */
     4f2:	81 e0       	ldi	r24, 0x01	; 1
	} else {			/* Initialization failed */
		power_off();
	}

	return Stat;
}
     4f4:	0f 90       	pop	r0
     4f6:	0f 90       	pop	r0
     4f8:	0f 90       	pop	r0
     4fa:	0f 90       	pop	r0
     4fc:	df 91       	pop	r29
     4fe:	cf 91       	pop	r28
     500:	1f 91       	pop	r17
     502:	0f 91       	pop	r16
     504:	ff 90       	pop	r15
     506:	ef 90       	pop	r14
     508:	df 90       	pop	r13
     50a:	cf 90       	pop	r12
     50c:	08 95       	ret
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);		/* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
     50e:	8c e0       	ldi	r24, 0x0C	; 12
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
     510:	80 93 f2 03 	sts	0x03F2, r24
	deselect();
     514:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
     518:	df cf       	rjmp	.-66     	; 0x4d8 <disk_initialize+0x154>
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
     51a:	10 92 f2 03 	sts	0x03F2, r1
	deselect();
     51e:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
     522:	e2 cf       	rjmp	.-60     	; 0x4e8 <disk_initialize+0x164>

00000524 <disk_status>:

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
     524:	88 23       	and	r24, r24
     526:	19 f4       	brne	.+6      	; 0x52e <disk_status+0xa>
	return Stat;
     528:	80 91 8a 01 	lds	r24, 0x018A
     52c:	08 95       	ret

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
     52e:	81 e0       	ldi	r24, 0x01	; 1
	return Stat;
}
     530:	08 95       	ret

00000532 <disk_read>:
	BYTE drv,			/* Physical drive nmuber (0) */
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
     532:	0f 93       	push	r16
     534:	cf 93       	push	r28
     536:	df 93       	push	r29
     538:	eb 01       	movw	r28, r22
	if (drv || !count) return RES_PARERR;
     53a:	88 23       	and	r24, r24
     53c:	09 f0       	breq	.+2      	; 0x540 <disk_read+0xe>
     53e:	4a c0       	rjmp	.+148    	; 0x5d4 <disk_read+0xa2>
     540:	00 23       	and	r16, r16
     542:	09 f4       	brne	.+2      	; 0x546 <disk_read+0x14>
     544:	49 c0       	rjmp	.+146    	; 0x5d8 <disk_read+0xa6>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     546:	80 91 8a 01 	lds	r24, 0x018A
     54a:	80 fd       	sbrc	r24, 0
     54c:	47 c0       	rjmp	.+142    	; 0x5dc <disk_read+0xaa>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
     54e:	80 91 f2 03 	lds	r24, 0x03F2
     552:	83 fd       	sbrc	r24, 3
     554:	09 c0       	rjmp	.+18     	; 0x568 <disk_read+0x36>
     556:	01 2e       	mov	r0, r17
     558:	19 e0       	ldi	r17, 0x09	; 9
     55a:	22 0f       	add	r18, r18
     55c:	33 1f       	adc	r19, r19
     55e:	44 1f       	adc	r20, r20
     560:	55 1f       	adc	r21, r21
     562:	1a 95       	dec	r17
     564:	d1 f7       	brne	.-12     	; 0x55a <disk_read+0x28>
     566:	10 2d       	mov	r17, r0

	if (count == 1) {	/* Single block read */
     568:	01 30       	cpi	r16, 0x01	; 1
     56a:	89 f4       	brne	.+34     	; 0x58e <disk_read+0x5c>
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
     56c:	81 e1       	ldi	r24, 0x11	; 17
     56e:	ba 01       	movw	r22, r20
     570:	a9 01       	movw	r20, r18
     572:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     576:	88 23       	and	r24, r24
     578:	31 f5       	brne	.+76     	; 0x5c6 <disk_read+0x94>
			&& rcvr_datablock(buff, 512))
     57a:	ce 01       	movw	r24, r28
     57c:	40 e0       	ldi	r20, 0x00	; 0
     57e:	52 e0       	ldi	r21, 0x02	; 2
     580:	60 e0       	ldi	r22, 0x00	; 0
     582:	70 e0       	ldi	r23, 0x00	; 0
     584:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     588:	00 97       	sbiw	r24, 0x00	; 0
     58a:	e1 f4       	brne	.+56     	; 0x5c4 <disk_read+0x92>
     58c:	1c c0       	rjmp	.+56     	; 0x5c6 <disk_read+0x94>
			count = 0;
	}
	else {				/* Multiple block read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
     58e:	82 e1       	ldi	r24, 0x12	; 18
     590:	ba 01       	movw	r22, r20
     592:	a9 01       	movw	r20, r18
     594:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     598:	88 23       	and	r24, r24
     59a:	a9 f4       	brne	.+42     	; 0x5c6 <disk_read+0x94>
			do {
				if (!rcvr_datablock(buff, 512)) break;
     59c:	ce 01       	movw	r24, r28
     59e:	40 e0       	ldi	r20, 0x00	; 0
     5a0:	52 e0       	ldi	r21, 0x02	; 2
     5a2:	60 e0       	ldi	r22, 0x00	; 0
     5a4:	70 e0       	ldi	r23, 0x00	; 0
     5a6:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     5aa:	00 97       	sbiw	r24, 0x00	; 0
     5ac:	21 f0       	breq	.+8      	; 0x5b6 <disk_read+0x84>
				buff += 512;
     5ae:	c0 50       	subi	r28, 0x00	; 0
     5b0:	de 4f       	sbci	r29, 0xFE	; 254
			} while (--count);
     5b2:	01 50       	subi	r16, 0x01	; 1
     5b4:	99 f7       	brne	.-26     	; 0x59c <disk_read+0x6a>
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
     5b6:	8c e0       	ldi	r24, 0x0C	; 12
     5b8:	40 e0       	ldi	r20, 0x00	; 0
     5ba:	50 e0       	ldi	r21, 0x00	; 0
     5bc:	ba 01       	movw	r22, r20
     5be:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     5c2:	01 c0       	rjmp	.+2      	; 0x5c6 <disk_read+0x94>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */

	if (count == 1) {	/* Single block read */
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
			&& rcvr_datablock(buff, 512))
			count = 0;
     5c4:	00 e0       	ldi	r16, 0x00	; 0
				buff += 512;
			} while (--count);
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
		}
	}
	deselect();
     5c6:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>

	return count ? RES_ERROR : RES_OK;
     5ca:	81 e0       	ldi	r24, 0x01	; 1
     5cc:	00 23       	and	r16, r16
     5ce:	39 f4       	brne	.+14     	; 0x5de <disk_read+0xac>
     5d0:	80 e0       	ldi	r24, 0x00	; 0
     5d2:	05 c0       	rjmp	.+10     	; 0x5de <disk_read+0xac>
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
	if (drv || !count) return RES_PARERR;
     5d4:	84 e0       	ldi	r24, 0x04	; 4
     5d6:	03 c0       	rjmp	.+6      	; 0x5de <disk_read+0xac>
     5d8:	84 e0       	ldi	r24, 0x04	; 4
     5da:	01 c0       	rjmp	.+2      	; 0x5de <disk_read+0xac>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     5dc:	83 e0       	ldi	r24, 0x03	; 3
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
     5de:	df 91       	pop	r29
     5e0:	cf 91       	pop	r28
     5e2:	0f 91       	pop	r16
     5e4:	08 95       	ret

000005e6 <disk_write>:
	BYTE drv,			/* Physical drive nmuber (0) */
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
     5e6:	cf 92       	push	r12
     5e8:	df 92       	push	r13
     5ea:	ef 92       	push	r14
     5ec:	ff 92       	push	r15
     5ee:	0f 93       	push	r16
     5f0:	cf 93       	push	r28
     5f2:	df 93       	push	r29
     5f4:	eb 01       	movw	r28, r22
     5f6:	69 01       	movw	r12, r18
     5f8:	7a 01       	movw	r14, r20
	if (drv || !count) return RES_PARERR;
     5fa:	88 23       	and	r24, r24
     5fc:	09 f0       	breq	.+2      	; 0x600 <disk_write+0x1a>
     5fe:	57 c0       	rjmp	.+174    	; 0x6ae <disk_write+0xc8>
     600:	00 23       	and	r16, r16
     602:	09 f4       	brne	.+2      	; 0x606 <disk_write+0x20>
     604:	56 c0       	rjmp	.+172    	; 0x6b2 <disk_write+0xcc>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     606:	80 91 8a 01 	lds	r24, 0x018A
     60a:	80 fd       	sbrc	r24, 0
     60c:	54 c0       	rjmp	.+168    	; 0x6b6 <disk_write+0xd0>
	if (Stat & STA_PROTECT) return RES_WRPRT;
     60e:	80 91 8a 01 	lds	r24, 0x018A
     612:	82 fd       	sbrc	r24, 2
     614:	52 c0       	rjmp	.+164    	; 0x6ba <disk_write+0xd4>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
     616:	80 91 f2 03 	lds	r24, 0x03F2
     61a:	90 e0       	ldi	r25, 0x00	; 0
     61c:	83 fd       	sbrc	r24, 3
     61e:	09 c0       	rjmp	.+18     	; 0x632 <disk_write+0x4c>
     620:	0b 2e       	mov	r0, r27
     622:	b9 e0       	ldi	r27, 0x09	; 9
     624:	cc 0c       	add	r12, r12
     626:	dd 1c       	adc	r13, r13
     628:	ee 1c       	adc	r14, r14
     62a:	ff 1c       	adc	r15, r15
     62c:	ba 95       	dec	r27
     62e:	d1 f7       	brne	.-12     	; 0x624 <disk_write+0x3e>
     630:	b0 2d       	mov	r27, r0

	if (count == 1) {	/* Single block write */
     632:	01 30       	cpi	r16, 0x01	; 1
     634:	71 f4       	brne	.+28     	; 0x652 <disk_write+0x6c>
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
     636:	88 e1       	ldi	r24, 0x18	; 24
     638:	b7 01       	movw	r22, r14
     63a:	a6 01       	movw	r20, r12
     63c:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     640:	88 23       	and	r24, r24
     642:	71 f5       	brne	.+92     	; 0x6a0 <disk_write+0xba>
			&& xmit_datablock(buff, 0xFE))
     644:	ce 01       	movw	r24, r28
     646:	6e ef       	ldi	r22, 0xFE	; 254
     648:	0e 94 39 01 	call	0x272	; 0x272 <xmit_datablock>
     64c:	00 97       	sbiw	r24, 0x00	; 0
     64e:	29 f5       	brne	.+74     	; 0x69a <disk_write+0xb4>
     650:	27 c0       	rjmp	.+78     	; 0x6a0 <disk_write+0xba>
			count = 0;
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
     652:	86 70       	andi	r24, 0x06	; 6
     654:	90 70       	andi	r25, 0x00	; 0
     656:	00 97       	sbiw	r24, 0x00	; 0
     658:	39 f0       	breq	.+14     	; 0x668 <disk_write+0x82>
     65a:	40 2f       	mov	r20, r16
     65c:	50 e0       	ldi	r21, 0x00	; 0
     65e:	60 e0       	ldi	r22, 0x00	; 0
     660:	70 e0       	ldi	r23, 0x00	; 0
     662:	87 e9       	ldi	r24, 0x97	; 151
     664:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
     668:	89 e1       	ldi	r24, 0x19	; 25
     66a:	b7 01       	movw	r22, r14
     66c:	a6 01       	movw	r20, r12
     66e:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     672:	88 23       	and	r24, r24
     674:	a9 f4       	brne	.+42     	; 0x6a0 <disk_write+0xba>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
     676:	ce 01       	movw	r24, r28
     678:	6c ef       	ldi	r22, 0xFC	; 252
     67a:	0e 94 39 01 	call	0x272	; 0x272 <xmit_datablock>
     67e:	00 97       	sbiw	r24, 0x00	; 0
     680:	21 f0       	breq	.+8      	; 0x68a <disk_write+0xa4>
				buff += 512;
     682:	c0 50       	subi	r28, 0x00	; 0
     684:	de 4f       	sbci	r29, 0xFE	; 254
			} while (--count);
     686:	01 50       	subi	r16, 0x01	; 1
     688:	b1 f7       	brne	.-20     	; 0x676 <disk_write+0x90>
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
     68a:	80 e0       	ldi	r24, 0x00	; 0
     68c:	90 e0       	ldi	r25, 0x00	; 0
     68e:	6d ef       	ldi	r22, 0xFD	; 253
     690:	0e 94 39 01 	call	0x272	; 0x272 <xmit_datablock>
     694:	00 97       	sbiw	r24, 0x00	; 0
     696:	19 f0       	breq	.+6      	; 0x69e <disk_write+0xb8>
     698:	03 c0       	rjmp	.+6      	; 0x6a0 <disk_write+0xba>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */

	if (count == 1) {	/* Single block write */
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
			&& xmit_datablock(buff, 0xFE))
			count = 0;
     69a:	00 e0       	ldi	r16, 0x00	; 0
     69c:	01 c0       	rjmp	.+2      	; 0x6a0 <disk_write+0xba>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
				buff += 512;
			} while (--count);
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
				count = 1;
     69e:	01 e0       	ldi	r16, 0x01	; 1
		}
	}
	deselect();
     6a0:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>

	return count ? RES_ERROR : RES_OK;
     6a4:	81 e0       	ldi	r24, 0x01	; 1
     6a6:	00 23       	and	r16, r16
     6a8:	49 f4       	brne	.+18     	; 0x6bc <disk_write+0xd6>
     6aa:	80 e0       	ldi	r24, 0x00	; 0
     6ac:	07 c0       	rjmp	.+14     	; 0x6bc <disk_write+0xd6>
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
	if (drv || !count) return RES_PARERR;
     6ae:	84 e0       	ldi	r24, 0x04	; 4
     6b0:	05 c0       	rjmp	.+10     	; 0x6bc <disk_write+0xd6>
     6b2:	84 e0       	ldi	r24, 0x04	; 4
     6b4:	03 c0       	rjmp	.+6      	; 0x6bc <disk_write+0xd6>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     6b6:	83 e0       	ldi	r24, 0x03	; 3
     6b8:	01 c0       	rjmp	.+2      	; 0x6bc <disk_write+0xd6>
	if (Stat & STA_PROTECT) return RES_WRPRT;
     6ba:	82 e0       	ldi	r24, 0x02	; 2
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
     6bc:	df 91       	pop	r29
     6be:	cf 91       	pop	r28
     6c0:	0f 91       	pop	r16
     6c2:	ff 90       	pop	r15
     6c4:	ef 90       	pop	r14
     6c6:	df 90       	pop	r13
     6c8:	cf 90       	pop	r12
     6ca:	08 95       	ret

000006cc <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
     6cc:	ef 92       	push	r14
     6ce:	ff 92       	push	r15
     6d0:	0f 93       	push	r16
     6d2:	1f 93       	push	r17
     6d4:	cf 93       	push	r28
     6d6:	df 93       	push	r29
     6d8:	cd b7       	in	r28, 0x3d	; 61
     6da:	de b7       	in	r29, 0x3e	; 62
     6dc:	60 97       	sbiw	r28, 0x10	; 16
     6de:	0f b6       	in	r0, 0x3f	; 63
     6e0:	f8 94       	cli
     6e2:	de bf       	out	0x3e, r29	; 62
     6e4:	0f be       	out	0x3f, r0	; 63
     6e6:	cd bf       	out	0x3d, r28	; 61
     6e8:	7a 01       	movw	r14, r20
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	DWORD csize;


	if (drv) return RES_PARERR;
     6ea:	88 23       	and	r24, r24
     6ec:	09 f0       	breq	.+2      	; 0x6f0 <disk_ioctl+0x24>
     6ee:	da c1       	rjmp	.+948    	; 0xaa4 <disk_ioctl+0x3d8>

	res = RES_ERROR;

	if (ctrl == CTRL_POWER) {
     6f0:	65 30       	cpi	r22, 0x05	; 5
     6f2:	89 f4       	brne	.+34     	; 0x716 <disk_ioctl+0x4a>
		switch (ptr[0]) {
     6f4:	fa 01       	movw	r30, r20
     6f6:	80 81       	ld	r24, Z
     6f8:	88 23       	and	r24, r24
     6fa:	21 f0       	breq	.+8      	; 0x704 <disk_ioctl+0x38>
     6fc:	81 30       	cpi	r24, 0x01	; 1
     6fe:	09 f0       	breq	.+2      	; 0x702 <disk_ioctl+0x36>
     700:	d3 c1       	rjmp	.+934    	; 0xaa8 <disk_ioctl+0x3dc>
     702:	04 c0       	rjmp	.+8      	; 0x70c <disk_ioctl+0x40>
		case 0:		/* Sub control code (POWER_OFF) */
			power_off();		/* Power off */
     704:	0e 94 bc 00 	call	0x178	; 0x178 <power_off>
			res = RES_OK;
     708:	00 e0       	ldi	r16, 0x00	; 0
			break;
     70a:	d1 c1       	rjmp	.+930    	; 0xaae <disk_ioctl+0x3e2>
		case 1:		/* Sub control code (POWER_GET) */
			ptr[1] = (BYTE)power_status();
     70c:	81 e0       	ldi	r24, 0x01	; 1
     70e:	fa 01       	movw	r30, r20
     710:	81 83       	std	Z+1, r24	; 0x01
			res = RES_OK;
     712:	00 e0       	ldi	r16, 0x00	; 0
			break;
     714:	cc c1       	rjmp	.+920    	; 0xaae <disk_ioctl+0x3e2>
		default :
			res = RES_PARERR;
		}
	}
	else {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
     716:	80 91 8a 01 	lds	r24, 0x018A
     71a:	80 fd       	sbrc	r24, 0
     71c:	c7 c1       	rjmp	.+910    	; 0xaac <disk_ioctl+0x3e0>

		switch (ctrl) {
     71e:	6a 30       	cpi	r22, 0x0A	; 10
     720:	09 f4       	brne	.+2      	; 0x724 <disk_ioctl+0x58>
     722:	44 c1       	rjmp	.+648    	; 0x9ac <disk_ioctl+0x2e0>
     724:	6b 30       	cpi	r22, 0x0B	; 11
     726:	58 f4       	brcc	.+22     	; 0x73e <disk_ioctl+0x72>
     728:	61 30       	cpi	r22, 0x01	; 1
     72a:	f9 f0       	breq	.+62     	; 0x76a <disk_ioctl+0x9e>
     72c:	61 30       	cpi	r22, 0x01	; 1
     72e:	a0 f0       	brcs	.+40     	; 0x758 <disk_ioctl+0x8c>
     730:	62 30       	cpi	r22, 0x02	; 2
     732:	09 f4       	brne	.+2      	; 0x736 <disk_ioctl+0x6a>
     734:	98 c0       	rjmp	.+304    	; 0x866 <disk_ioctl+0x19a>
     736:	63 30       	cpi	r22, 0x03	; 3
     738:	09 f0       	breq	.+2      	; 0x73c <disk_ioctl+0x70>
     73a:	94 c1       	rjmp	.+808    	; 0xa64 <disk_ioctl+0x398>
     73c:	9b c0       	rjmp	.+310    	; 0x874 <disk_ioctl+0x1a8>
     73e:	6c 30       	cpi	r22, 0x0C	; 12
     740:	09 f4       	brne	.+2      	; 0x744 <disk_ioctl+0x78>
     742:	4f c1       	rjmp	.+670    	; 0x9e2 <disk_ioctl+0x316>
     744:	6c 30       	cpi	r22, 0x0C	; 12
     746:	08 f4       	brcc	.+2      	; 0x74a <disk_ioctl+0x7e>
     748:	37 c1       	rjmp	.+622    	; 0x9b8 <disk_ioctl+0x2ec>
     74a:	6d 30       	cpi	r22, 0x0D	; 13
     74c:	09 f4       	brne	.+2      	; 0x750 <disk_ioctl+0x84>
     74e:	5e c1       	rjmp	.+700    	; 0xa0c <disk_ioctl+0x340>
     750:	6e 30       	cpi	r22, 0x0E	; 14
     752:	09 f0       	breq	.+2      	; 0x756 <disk_ioctl+0x8a>
     754:	87 c1       	rjmp	.+782    	; 0xa64 <disk_ioctl+0x398>
     756:	70 c1       	rjmp	.+736    	; 0xa38 <disk_ioctl+0x36c>
		case CTRL_SYNC :		/* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
			if (select()) {
     758:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <select>
     75c:	00 97       	sbiw	r24, 0x00	; 0
     75e:	09 f4       	brne	.+2      	; 0x762 <disk_ioctl+0x96>
     760:	83 c1       	rjmp	.+774    	; 0xa68 <disk_ioctl+0x39c>
				deselect();
     762:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
				res = RES_OK;
     766:	00 e0       	ldi	r16, 0x00	; 0
     768:	9a c1       	rjmp	.+820    	; 0xa9e <disk_ioctl+0x3d2>
			}
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
     76a:	89 e0       	ldi	r24, 0x09	; 9
     76c:	40 e0       	ldi	r20, 0x00	; 0
     76e:	50 e0       	ldi	r21, 0x00	; 0
     770:	ba 01       	movw	r22, r20
     772:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     776:	88 23       	and	r24, r24
     778:	09 f0       	breq	.+2      	; 0x77c <disk_ioctl+0xb0>
     77a:	78 c1       	rjmp	.+752    	; 0xa6c <disk_ioctl+0x3a0>
     77c:	ce 01       	movw	r24, r28
     77e:	01 96       	adiw	r24, 0x01	; 1
     780:	40 e1       	ldi	r20, 0x10	; 16
     782:	50 e0       	ldi	r21, 0x00	; 0
     784:	60 e0       	ldi	r22, 0x00	; 0
     786:	70 e0       	ldi	r23, 0x00	; 0
     788:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     78c:	00 97       	sbiw	r24, 0x00	; 0
     78e:	09 f4       	brne	.+2      	; 0x792 <disk_ioctl+0xc6>
     790:	6f c1       	rjmp	.+734    	; 0xa70 <disk_ioctl+0x3a4>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
     792:	89 81       	ldd	r24, Y+1	; 0x01
     794:	82 95       	swap	r24
     796:	86 95       	lsr	r24
     798:	86 95       	lsr	r24
     79a:	83 70       	andi	r24, 0x03	; 3
     79c:	81 30       	cpi	r24, 0x01	; 1
     79e:	51 f5       	brne	.+84     	; 0x7f4 <disk_ioctl+0x128>
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
     7a0:	48 85       	ldd	r20, Y+8	; 0x08
     7a2:	50 e0       	ldi	r21, 0x00	; 0
     7a4:	60 e0       	ldi	r22, 0x00	; 0
     7a6:	70 e0       	ldi	r23, 0x00	; 0
     7a8:	4f 73       	andi	r20, 0x3F	; 63
     7aa:	50 70       	andi	r21, 0x00	; 0
     7ac:	60 70       	andi	r22, 0x00	; 0
     7ae:	70 70       	andi	r23, 0x00	; 0
     7b0:	ba 01       	movw	r22, r20
     7b2:	55 27       	eor	r21, r21
     7b4:	44 27       	eor	r20, r20
     7b6:	4f 5f       	subi	r20, 0xFF	; 255
     7b8:	5f 4f       	sbci	r21, 0xFF	; 255
     7ba:	6f 4f       	sbci	r22, 0xFF	; 255
     7bc:	7f 4f       	sbci	r23, 0xFF	; 255
     7be:	99 85       	ldd	r25, Y+9	; 0x09
     7c0:	80 e0       	ldi	r24, 0x00	; 0
     7c2:	2a 85       	ldd	r18, Y+10	; 0x0a
     7c4:	82 0f       	add	r24, r18
     7c6:	91 1d       	adc	r25, r1
     7c8:	a0 e0       	ldi	r26, 0x00	; 0
     7ca:	b0 e0       	ldi	r27, 0x00	; 0
     7cc:	84 0f       	add	r24, r20
     7ce:	95 1f       	adc	r25, r21
     7d0:	a6 1f       	adc	r26, r22
     7d2:	b7 1f       	adc	r27, r23
					*(DWORD*)buff = csize << 10;
     7d4:	07 2e       	mov	r0, r23
     7d6:	7a e0       	ldi	r23, 0x0A	; 10
     7d8:	88 0f       	add	r24, r24
     7da:	99 1f       	adc	r25, r25
     7dc:	aa 1f       	adc	r26, r26
     7de:	bb 1f       	adc	r27, r27
     7e0:	7a 95       	dec	r23
     7e2:	d1 f7       	brne	.-12     	; 0x7d8 <disk_ioctl+0x10c>
     7e4:	70 2d       	mov	r23, r0
     7e6:	f7 01       	movw	r30, r14
     7e8:	80 83       	st	Z, r24
     7ea:	91 83       	std	Z+1, r25	; 0x01
     7ec:	a2 83       	std	Z+2, r26	; 0x02
     7ee:	b3 83       	std	Z+3, r27	; 0x03
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = csize << (n - 9);
				}
				res = RES_OK;
     7f0:	00 e0       	ldi	r16, 0x00	; 0
     7f2:	55 c1       	rjmp	.+682    	; 0xa9e <disk_ioctl+0x3d2>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = csize << 10;
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
     7f4:	29 85       	ldd	r18, Y+9	; 0x09
     7f6:	22 95       	swap	r18
     7f8:	26 95       	lsr	r18
     7fa:	26 95       	lsr	r18
     7fc:	23 70       	andi	r18, 0x03	; 3
     7fe:	88 85       	ldd	r24, Y+8	; 0x08
     800:	90 e0       	ldi	r25, 0x00	; 0
     802:	88 0f       	add	r24, r24
     804:	99 1f       	adc	r25, r25
     806:	88 0f       	add	r24, r24
     808:	99 1f       	adc	r25, r25
     80a:	82 0f       	add	r24, r18
     80c:	91 1d       	adc	r25, r1
     80e:	01 96       	adiw	r24, 0x01	; 1
     810:	2f 81       	ldd	r18, Y+7	; 0x07
     812:	30 e0       	ldi	r19, 0x00	; 0
     814:	23 70       	andi	r18, 0x03	; 3
     816:	30 70       	andi	r19, 0x00	; 0
     818:	32 2f       	mov	r19, r18
     81a:	22 27       	eor	r18, r18
     81c:	33 0f       	add	r19, r19
     81e:	33 0f       	add	r19, r19
     820:	82 0f       	add	r24, r18
     822:	93 1f       	adc	r25, r19
     824:	ac 01       	movw	r20, r24
     826:	60 e0       	ldi	r22, 0x00	; 0
     828:	70 e0       	ldi	r23, 0x00	; 0
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = csize << 10;
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
     82a:	9e 81       	ldd	r25, Y+6	; 0x06
     82c:	9f 70       	andi	r25, 0x0F	; 15
     82e:	8b 85       	ldd	r24, Y+11	; 0x0b
     830:	88 1f       	adc	r24, r24
     832:	88 27       	eor	r24, r24
     834:	88 1f       	adc	r24, r24
     836:	98 0f       	add	r25, r24
     838:	9e 5f       	subi	r25, 0xFE	; 254
     83a:	8a 85       	ldd	r24, Y+10	; 0x0a
     83c:	83 70       	andi	r24, 0x03	; 3
     83e:	88 0f       	add	r24, r24
     840:	89 0f       	add	r24, r25
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = csize << (n - 9);
     842:	90 e0       	ldi	r25, 0x00	; 0
     844:	09 97       	sbiw	r24, 0x09	; 9
     846:	8a 01       	movw	r16, r20
     848:	9b 01       	movw	r18, r22
     84a:	04 c0       	rjmp	.+8      	; 0x854 <disk_ioctl+0x188>
     84c:	00 0f       	add	r16, r16
     84e:	11 1f       	adc	r17, r17
     850:	22 1f       	adc	r18, r18
     852:	33 1f       	adc	r19, r19
     854:	8a 95       	dec	r24
     856:	d2 f7       	brpl	.-12     	; 0x84c <disk_ioctl+0x180>
     858:	f7 01       	movw	r30, r14
     85a:	00 83       	st	Z, r16
     85c:	11 83       	std	Z+1, r17	; 0x01
     85e:	22 83       	std	Z+2, r18	; 0x02
     860:	33 83       	std	Z+3, r19	; 0x03
				}
				res = RES_OK;
     862:	00 e0       	ldi	r16, 0x00	; 0
     864:	1c c1       	rjmp	.+568    	; 0xa9e <disk_ioctl+0x3d2>
			}
			break;

		case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
			*(WORD*)buff = 512;
     866:	80 e0       	ldi	r24, 0x00	; 0
     868:	92 e0       	ldi	r25, 0x02	; 2
     86a:	fa 01       	movw	r30, r20
     86c:	91 83       	std	Z+1, r25	; 0x01
     86e:	80 83       	st	Z, r24
			res = RES_OK;
     870:	00 e0       	ldi	r16, 0x00	; 0
			break;
     872:	15 c1       	rjmp	.+554    	; 0xa9e <disk_ioctl+0x3d2>

		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
			if (CardType & CT_SD2) {	/* SDv2? */
     874:	00 91 f2 03 	lds	r16, 0x03F2
     878:	02 ff       	sbrs	r16, 2
     87a:	31 c0       	rjmp	.+98     	; 0x8de <disk_ioctl+0x212>
				if (send_cmd(ACMD13, 0) == 0) {	/* Read SD status */
     87c:	8d e8       	ldi	r24, 0x8D	; 141
     87e:	40 e0       	ldi	r20, 0x00	; 0
     880:	50 e0       	ldi	r21, 0x00	; 0
     882:	ba 01       	movw	r22, r20
     884:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     888:	88 23       	and	r24, r24
     88a:	09 f0       	breq	.+2      	; 0x88e <disk_ioctl+0x1c2>
     88c:	f3 c0       	rjmp	.+486    	; 0xa74 <disk_ioctl+0x3a8>
					xchg_spi(0xFF);
     88e:	8f ef       	ldi	r24, 0xFF	; 255
     890:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
					if (rcvr_datablock(csd, 16)) {				/* Read partial block */
     894:	ce 01       	movw	r24, r28
     896:	01 96       	adiw	r24, 0x01	; 1
     898:	40 e1       	ldi	r20, 0x10	; 16
     89a:	50 e0       	ldi	r21, 0x00	; 0
     89c:	60 e0       	ldi	r22, 0x00	; 0
     89e:	70 e0       	ldi	r23, 0x00	; 0
     8a0:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     8a4:	00 97       	sbiw	r24, 0x00	; 0
     8a6:	09 f4       	brne	.+2      	; 0x8aa <disk_ioctl+0x1de>
     8a8:	e7 c0       	rjmp	.+462    	; 0xa78 <disk_ioctl+0x3ac>
     8aa:	00 e3       	ldi	r16, 0x30	; 48
						for (n = 64 - 16; n; n--) xchg_spi(0xFF);	/* Purge trailing data */
     8ac:	8f ef       	ldi	r24, 0xFF	; 255
     8ae:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     8b2:	01 50       	subi	r16, 0x01	; 1
     8b4:	d9 f7       	brne	.-10     	; 0x8ac <disk_ioctl+0x1e0>
						*(DWORD*)buff = 16UL << (csd[10] >> 4);
     8b6:	2b 85       	ldd	r18, Y+11	; 0x0b
     8b8:	22 95       	swap	r18
     8ba:	2f 70       	andi	r18, 0x0F	; 15
     8bc:	80 e1       	ldi	r24, 0x10	; 16
     8be:	90 e0       	ldi	r25, 0x00	; 0
     8c0:	a0 e0       	ldi	r26, 0x00	; 0
     8c2:	b0 e0       	ldi	r27, 0x00	; 0
     8c4:	04 c0       	rjmp	.+8      	; 0x8ce <disk_ioctl+0x202>
     8c6:	88 0f       	add	r24, r24
     8c8:	99 1f       	adc	r25, r25
     8ca:	aa 1f       	adc	r26, r26
     8cc:	bb 1f       	adc	r27, r27
     8ce:	2a 95       	dec	r18
     8d0:	d2 f7       	brpl	.-12     	; 0x8c6 <disk_ioctl+0x1fa>
     8d2:	f7 01       	movw	r30, r14
     8d4:	80 83       	st	Z, r24
     8d6:	91 83       	std	Z+1, r25	; 0x01
     8d8:	a2 83       	std	Z+2, r26	; 0x02
     8da:	b3 83       	std	Z+3, r27	; 0x03
     8dc:	e0 c0       	rjmp	.+448    	; 0xa9e <disk_ioctl+0x3d2>
						res = RES_OK;
					}
				}
			} else {					/* SDv1 or MMCv3 */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
     8de:	89 e0       	ldi	r24, 0x09	; 9
     8e0:	40 e0       	ldi	r20, 0x00	; 0
     8e2:	50 e0       	ldi	r21, 0x00	; 0
     8e4:	ba 01       	movw	r22, r20
     8e6:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     8ea:	88 23       	and	r24, r24
     8ec:	09 f0       	breq	.+2      	; 0x8f0 <disk_ioctl+0x224>
     8ee:	c6 c0       	rjmp	.+396    	; 0xa7c <disk_ioctl+0x3b0>
     8f0:	ce 01       	movw	r24, r28
     8f2:	01 96       	adiw	r24, 0x01	; 1
     8f4:	40 e1       	ldi	r20, 0x10	; 16
     8f6:	50 e0       	ldi	r21, 0x00	; 0
     8f8:	60 e0       	ldi	r22, 0x00	; 0
     8fa:	70 e0       	ldi	r23, 0x00	; 0
     8fc:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     900:	00 97       	sbiw	r24, 0x00	; 0
     902:	09 f4       	brne	.+2      	; 0x906 <disk_ioctl+0x23a>
     904:	bd c0       	rjmp	.+378    	; 0xa80 <disk_ioctl+0x3b4>
					if (CardType & CT_SD1) {	/* SDv1 */
     906:	01 ff       	sbrs	r16, 1
     908:	25 c0       	rjmp	.+74     	; 0x954 <disk_ioctl+0x288>
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
     90a:	8c 85       	ldd	r24, Y+12	; 0x0c
     90c:	88 1f       	adc	r24, r24
     90e:	88 27       	eor	r24, r24
     910:	88 1f       	adc	r24, r24
     912:	90 e0       	ldi	r25, 0x00	; 0
     914:	01 96       	adiw	r24, 0x01	; 1
     916:	2b 85       	ldd	r18, Y+11	; 0x0b
     918:	30 e0       	ldi	r19, 0x00	; 0
     91a:	2f 73       	andi	r18, 0x3F	; 63
     91c:	30 70       	andi	r19, 0x00	; 0
     91e:	22 0f       	add	r18, r18
     920:	33 1f       	adc	r19, r19
     922:	28 0f       	add	r18, r24
     924:	39 1f       	adc	r19, r25
     926:	8e 85       	ldd	r24, Y+14	; 0x0e
     928:	82 95       	swap	r24
     92a:	86 95       	lsr	r24
     92c:	86 95       	lsr	r24
     92e:	83 70       	andi	r24, 0x03	; 3
     930:	90 e0       	ldi	r25, 0x00	; 0
     932:	01 97       	sbiw	r24, 0x01	; 1
     934:	89 01       	movw	r16, r18
     936:	02 c0       	rjmp	.+4      	; 0x93c <disk_ioctl+0x270>
     938:	00 0f       	add	r16, r16
     93a:	11 1f       	adc	r17, r17
     93c:	8a 95       	dec	r24
     93e:	e2 f7       	brpl	.-8      	; 0x938 <disk_ioctl+0x26c>
     940:	c8 01       	movw	r24, r16
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	f7 01       	movw	r30, r14
     948:	80 83       	st	Z, r24
     94a:	91 83       	std	Z+1, r25	; 0x01
     94c:	a2 83       	std	Z+2, r26	; 0x02
     94e:	b3 83       	std	Z+3, r27	; 0x03
					} else {					/* MMCv3 */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
					}
					res = RES_OK;
     950:	00 e0       	ldi	r16, 0x00	; 0
     952:	a5 c0       	rjmp	.+330    	; 0xa9e <disk_ioctl+0x3d2>
			} else {					/* SDv1 or MMCv3 */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
					if (CardType & CT_SD1) {	/* SDv1 */
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
					} else {					/* MMCv3 */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
     954:	8c 85       	ldd	r24, Y+12	; 0x0c
     956:	48 2f       	mov	r20, r24
     958:	50 e0       	ldi	r21, 0x00	; 0
     95a:	43 70       	andi	r20, 0x03	; 3
     95c:	50 70       	andi	r21, 0x00	; 0
     95e:	44 0f       	add	r20, r20
     960:	55 1f       	adc	r21, r21
     962:	44 0f       	add	r20, r20
     964:	55 1f       	adc	r21, r21
     966:	44 0f       	add	r20, r20
     968:	55 1f       	adc	r21, r21
     96a:	82 95       	swap	r24
     96c:	86 95       	lsr	r24
     96e:	87 70       	andi	r24, 0x07	; 7
     970:	48 0f       	add	r20, r24
     972:	51 1d       	adc	r21, r1
     974:	4f 5f       	subi	r20, 0xFF	; 255
     976:	5f 4f       	sbci	r21, 0xFF	; 255
     978:	2b 85       	ldd	r18, Y+11	; 0x0b
     97a:	30 e0       	ldi	r19, 0x00	; 0
     97c:	2c 77       	andi	r18, 0x7C	; 124
     97e:	30 70       	andi	r19, 0x00	; 0
     980:	35 95       	asr	r19
     982:	27 95       	ror	r18
     984:	35 95       	asr	r19
     986:	27 95       	ror	r18
     988:	2f 5f       	subi	r18, 0xFF	; 255
     98a:	3f 4f       	sbci	r19, 0xFF	; 255
     98c:	42 9f       	mul	r20, r18
     98e:	c0 01       	movw	r24, r0
     990:	43 9f       	mul	r20, r19
     992:	90 0d       	add	r25, r0
     994:	52 9f       	mul	r21, r18
     996:	90 0d       	add	r25, r0
     998:	11 24       	eor	r1, r1
     99a:	a0 e0       	ldi	r26, 0x00	; 0
     99c:	b0 e0       	ldi	r27, 0x00	; 0
     99e:	f7 01       	movw	r30, r14
     9a0:	80 83       	st	Z, r24
     9a2:	91 83       	std	Z+1, r25	; 0x01
     9a4:	a2 83       	std	Z+2, r26	; 0x02
     9a6:	b3 83       	std	Z+3, r27	; 0x03
					}
					res = RES_OK;
     9a8:	00 e0       	ldi	r16, 0x00	; 0
     9aa:	79 c0       	rjmp	.+242    	; 0xa9e <disk_ioctl+0x3d2>
				}
			}
			break;

		case MMC_GET_TYPE :		/* Get card type flags (1 byte) */
			*ptr = CardType;
     9ac:	80 91 f2 03 	lds	r24, 0x03F2
     9b0:	fa 01       	movw	r30, r20
     9b2:	80 83       	st	Z, r24
			res = RES_OK;
     9b4:	00 e0       	ldi	r16, 0x00	; 0
			break;
     9b6:	73 c0       	rjmp	.+230    	; 0xa9e <disk_ioctl+0x3d2>

		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
     9b8:	89 e0       	ldi	r24, 0x09	; 9
     9ba:	40 e0       	ldi	r20, 0x00	; 0
     9bc:	50 e0       	ldi	r21, 0x00	; 0
     9be:	ba 01       	movw	r22, r20
     9c0:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     9c4:	88 23       	and	r24, r24
     9c6:	09 f0       	breq	.+2      	; 0x9ca <disk_ioctl+0x2fe>
     9c8:	5d c0       	rjmp	.+186    	; 0xa84 <disk_ioctl+0x3b8>
				&& rcvr_datablock(ptr, 16))
     9ca:	c7 01       	movw	r24, r14
     9cc:	40 e1       	ldi	r20, 0x10	; 16
     9ce:	50 e0       	ldi	r21, 0x00	; 0
     9d0:	60 e0       	ldi	r22, 0x00	; 0
     9d2:	70 e0       	ldi	r23, 0x00	; 0
     9d4:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     9d8:	00 97       	sbiw	r24, 0x00	; 0
     9da:	09 f0       	breq	.+2      	; 0x9de <disk_ioctl+0x312>
     9dc:	55 c0       	rjmp	.+170    	; 0xa88 <disk_ioctl+0x3bc>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     9de:	01 e0       	ldi	r16, 0x01	; 1
     9e0:	5e c0       	rjmp	.+188    	; 0xa9e <disk_ioctl+0x3d2>
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
			break;

		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
     9e2:	8a e0       	ldi	r24, 0x0A	; 10
     9e4:	40 e0       	ldi	r20, 0x00	; 0
     9e6:	50 e0       	ldi	r21, 0x00	; 0
     9e8:	ba 01       	movw	r22, r20
     9ea:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     9ee:	88 23       	and	r24, r24
     9f0:	09 f0       	breq	.+2      	; 0x9f4 <disk_ioctl+0x328>
     9f2:	4c c0       	rjmp	.+152    	; 0xa8c <disk_ioctl+0x3c0>
				&& rcvr_datablock(ptr, 16))
     9f4:	c7 01       	movw	r24, r14
     9f6:	40 e1       	ldi	r20, 0x10	; 16
     9f8:	50 e0       	ldi	r21, 0x00	; 0
     9fa:	60 e0       	ldi	r22, 0x00	; 0
     9fc:	70 e0       	ldi	r23, 0x00	; 0
     9fe:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     a02:	00 97       	sbiw	r24, 0x00	; 0
     a04:	09 f0       	breq	.+2      	; 0xa08 <disk_ioctl+0x33c>
     a06:	44 c0       	rjmp	.+136    	; 0xa90 <disk_ioctl+0x3c4>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a08:	01 e0       	ldi	r16, 0x01	; 1
     a0a:	49 c0       	rjmp	.+146    	; 0xa9e <disk_ioctl+0x3d2>
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
			break;

		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
			if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
     a0c:	8a e3       	ldi	r24, 0x3A	; 58
     a0e:	40 e0       	ldi	r20, 0x00	; 0
     a10:	50 e0       	ldi	r21, 0x00	; 0
     a12:	ba 01       	movw	r22, r20
     a14:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     a18:	88 23       	and	r24, r24
     a1a:	e1 f5       	brne	.+120    	; 0xa94 <disk_ioctl+0x3c8>
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
/*-----------------------------------------------------------------------*/

#if _USE_IOCTL
DRESULT disk_ioctl (
     a1c:	87 01       	movw	r16, r14
     a1e:	0c 5f       	subi	r16, 0xFC	; 252
     a20:	1f 4f       	sbci	r17, 0xFF	; 255
				res = RES_OK;
			break;

		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
			if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
				for (n = 4; n; n--) *ptr++ = xchg_spi(0xFF);
     a22:	8f ef       	ldi	r24, 0xFF	; 255
     a24:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     a28:	f7 01       	movw	r30, r14
     a2a:	81 93       	st	Z+, r24
     a2c:	7f 01       	movw	r14, r30
     a2e:	e0 17       	cp	r30, r16
     a30:	f1 07       	cpc	r31, r17
     a32:	b9 f7       	brne	.-18     	; 0xa22 <disk_ioctl+0x356>
				res = RES_OK;
     a34:	00 e0       	ldi	r16, 0x00	; 0
     a36:	33 c0       	rjmp	.+102    	; 0xa9e <disk_ioctl+0x3d2>
			}
			break;

		case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
			if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
     a38:	8d e8       	ldi	r24, 0x8D	; 141
     a3a:	40 e0       	ldi	r20, 0x00	; 0
     a3c:	50 e0       	ldi	r21, 0x00	; 0
     a3e:	ba 01       	movw	r22, r20
     a40:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     a44:	88 23       	and	r24, r24
     a46:	41 f5       	brne	.+80     	; 0xa98 <disk_ioctl+0x3cc>
				xchg_spi(0xFF);
     a48:	8f ef       	ldi	r24, 0xFF	; 255
     a4a:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
				if (rcvr_datablock(ptr, 64))
     a4e:	c7 01       	movw	r24, r14
     a50:	40 e4       	ldi	r20, 0x40	; 64
     a52:	50 e0       	ldi	r21, 0x00	; 0
     a54:	60 e0       	ldi	r22, 0x00	; 0
     a56:	70 e0       	ldi	r23, 0x00	; 0
     a58:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     a5c:	00 97       	sbiw	r24, 0x00	; 0
     a5e:	f1 f4       	brne	.+60     	; 0xa9c <disk_ioctl+0x3d0>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a60:	01 e0       	ldi	r16, 0x01	; 1
     a62:	1d c0       	rjmp	.+58     	; 0xa9e <disk_ioctl+0x3d2>
					res = RES_OK;
			}
			break;

		default:
			res = RES_PARERR;
     a64:	04 e0       	ldi	r16, 0x04	; 4
     a66:	1b c0       	rjmp	.+54     	; 0xa9e <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a68:	01 e0       	ldi	r16, 0x01	; 1
     a6a:	19 c0       	rjmp	.+50     	; 0xa9e <disk_ioctl+0x3d2>
     a6c:	01 e0       	ldi	r16, 0x01	; 1
     a6e:	17 c0       	rjmp	.+46     	; 0xa9e <disk_ioctl+0x3d2>
     a70:	01 e0       	ldi	r16, 0x01	; 1
     a72:	15 c0       	rjmp	.+42     	; 0xa9e <disk_ioctl+0x3d2>
     a74:	01 e0       	ldi	r16, 0x01	; 1
     a76:	13 c0       	rjmp	.+38     	; 0xa9e <disk_ioctl+0x3d2>
     a78:	01 e0       	ldi	r16, 0x01	; 1
     a7a:	11 c0       	rjmp	.+34     	; 0xa9e <disk_ioctl+0x3d2>
     a7c:	01 e0       	ldi	r16, 0x01	; 1
     a7e:	0f c0       	rjmp	.+30     	; 0xa9e <disk_ioctl+0x3d2>
     a80:	01 e0       	ldi	r16, 0x01	; 1
     a82:	0d c0       	rjmp	.+26     	; 0xa9e <disk_ioctl+0x3d2>
     a84:	01 e0       	ldi	r16, 0x01	; 1
     a86:	0b c0       	rjmp	.+22     	; 0xa9e <disk_ioctl+0x3d2>
			break;

		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
     a88:	00 e0       	ldi	r16, 0x00	; 0
     a8a:	09 c0       	rjmp	.+18     	; 0xa9e <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a8c:	01 e0       	ldi	r16, 0x01	; 1
     a8e:	07 c0       	rjmp	.+14     	; 0xa9e <disk_ioctl+0x3d2>
			break;

		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
     a90:	00 e0       	ldi	r16, 0x00	; 0
     a92:	05 c0       	rjmp	.+10     	; 0xa9e <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a94:	01 e0       	ldi	r16, 0x01	; 1
     a96:	03 c0       	rjmp	.+6      	; 0xa9e <disk_ioctl+0x3d2>
     a98:	01 e0       	ldi	r16, 0x01	; 1
     a9a:	01 c0       	rjmp	.+2      	; 0xa9e <disk_ioctl+0x3d2>

		case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
			if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
				xchg_spi(0xFF);
				if (rcvr_datablock(ptr, 64))
					res = RES_OK;
     a9c:	00 e0       	ldi	r16, 0x00	; 0

		default:
			res = RES_PARERR;
		}

		deselect();
     a9e:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
     aa2:	05 c0       	rjmp	.+10     	; 0xaae <disk_ioctl+0x3e2>
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	DWORD csize;


	if (drv) return RES_PARERR;
     aa4:	04 e0       	ldi	r16, 0x04	; 4
     aa6:	03 c0       	rjmp	.+6      	; 0xaae <disk_ioctl+0x3e2>
		case 1:		/* Sub control code (POWER_GET) */
			ptr[1] = (BYTE)power_status();
			res = RES_OK;
			break;
		default :
			res = RES_PARERR;
     aa8:	04 e0       	ldi	r16, 0x04	; 4
     aaa:	01 c0       	rjmp	.+2      	; 0xaae <disk_ioctl+0x3e2>
		}
	}
	else {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
     aac:	03 e0       	ldi	r16, 0x03	; 3

		deselect();
	}

	return res;
}
     aae:	80 2f       	mov	r24, r16
     ab0:	60 96       	adiw	r28, 0x10	; 16
     ab2:	0f b6       	in	r0, 0x3f	; 63
     ab4:	f8 94       	cli
     ab6:	de bf       	out	0x3e, r29	; 62
     ab8:	0f be       	out	0x3f, r0	; 63
     aba:	cd bf       	out	0x3d, r28	; 61
     abc:	df 91       	pop	r29
     abe:	cf 91       	pop	r28
     ac0:	1f 91       	pop	r17
     ac2:	0f 91       	pop	r16
     ac4:	ff 90       	pop	r15
     ac6:	ef 90       	pop	r14
     ac8:	08 95       	ret

00000aca <disk_timerproc>:
void disk_timerproc (void)
{
	BYTE n, s;


	n = Timer1;				/* 100Hz decrement timer */
     aca:	80 91 f1 03 	lds	r24, 0x03F1
	if (n) Timer1 = --n;
     ace:	88 23       	and	r24, r24
     ad0:	19 f0       	breq	.+6      	; 0xad8 <disk_timerproc+0xe>
     ad2:	81 50       	subi	r24, 0x01	; 1
     ad4:	80 93 f1 03 	sts	0x03F1, r24
	n = Timer2;
     ad8:	80 91 f0 03 	lds	r24, 0x03F0
	if (n) Timer2 = --n;
     adc:	88 23       	and	r24, r24
     ade:	19 f0       	breq	.+6      	; 0xae6 <disk_timerproc+0x1c>
     ae0:	81 50       	subi	r24, 0x01	; 1
     ae2:	80 93 f0 03 	sts	0x03F0, r24

	s = Stat;
     ae6:	80 91 8a 01 	lds	r24, 0x018A

	if (SOCKWP)				/* Write protected */
     aea:	18 9b       	sbis	0x03, 0	; 3
     aec:	02 c0       	rjmp	.+4      	; 0xaf2 <disk_timerproc+0x28>
		s |= STA_PROTECT;
     aee:	84 60       	ori	r24, 0x04	; 4
     af0:	01 c0       	rjmp	.+2      	; 0xaf4 <disk_timerproc+0x2a>
	else					/* Write enabled */
		s &= ~STA_PROTECT;
     af2:	8b 7f       	andi	r24, 0xFB	; 251

	if (SOCKINS)			/* Card inserted */
     af4:	19 99       	sbic	0x03, 1	; 3
     af6:	02 c0       	rjmp	.+4      	; 0xafc <disk_timerproc+0x32>
		s &= ~STA_NODISK;
     af8:	8d 7f       	andi	r24, 0xFD	; 253
     afa:	01 c0       	rjmp	.+2      	; 0xafe <disk_timerproc+0x34>
	else					/* Socket empty */
		s |= (STA_NODISK | STA_NOINIT);
     afc:	83 60       	ori	r24, 0x03	; 3

	Stat = s;				/* Update MMC status */
     afe:	80 93 8a 01 	sts	0x018A, r24
}
     b02:	08 95       	ret

00000b04 <__vector_1>:



//ISR for controlling WEN.
ISR(INT0_vect)
{
     b04:	1f 92       	push	r1
     b06:	0f 92       	push	r0
     b08:	0f b6       	in	r0, 0x3f	; 63
     b0a:	0f 92       	push	r0
     b0c:	11 24       	eor	r1, r1
     b0e:	8f 93       	push	r24
	//printf("ISR INT0 Entered\n");
	if (VSYNC_0_Count==1)//start a frame read
     b10:	80 91 ff 03 	lds	r24, 0x03FF
     b14:	81 30       	cpi	r24, 0x01	; 1
     b16:	39 f4       	brne	.+14     	; 0xb26 <__vector_1+0x22>
	{
		FIFO_WEN_0_SET;
     b18:	5e 9a       	sbi	0x0b, 6	; 11
		VSYNC_0_Count++;
     b1a:	80 91 ff 03 	lds	r24, 0x03FF
     b1e:	8f 5f       	subi	r24, 0xFF	; 255
     b20:	80 93 ff 03 	sts	0x03FF, r24
     b24:	14 c0       	rjmp	.+40     	; 0xb4e <__vector_1+0x4a>
	}
	else if (VSYNC_0_Count==2)//end a frame read
     b26:	80 91 ff 03 	lds	r24, 0x03FF
     b2a:	82 30       	cpi	r24, 0x02	; 2
     b2c:	39 f4       	brne	.+14     	; 0xb3c <__vector_1+0x38>
	{
		FIFO_WEN_0_CLR;
     b2e:	5e 98       	cbi	0x0b, 6	; 11
		VSYNC_0_Count++;
     b30:	80 91 ff 03 	lds	r24, 0x03FF
     b34:	8f 5f       	subi	r24, 0xFF	; 255
     b36:	80 93 ff 03 	sts	0x03FF, r24
     b3a:	09 c0       	rjmp	.+18     	; 0xb4e <__vector_1+0x4a>
	}
	else if(VSYNC_0_Count == 3)
     b3c:	80 91 ff 03 	lds	r24, 0x03FF
     b40:	83 30       	cpi	r24, 0x03	; 3
     b42:	11 f4       	brne	.+4      	; 0xb48 <__vector_1+0x44>
	{
		FIFO_WEN_0_CLR;
     b44:	5e 98       	cbi	0x0b, 6	; 11
     b46:	03 c0       	rjmp	.+6      	; 0xb4e <__vector_1+0x4a>
	}
	else
	{
		FIFO_WEN_0_CLR
     b48:	5e 98       	cbi	0x0b, 6	; 11
		VSYNC_0_Count = 0;//wait for a read to be started
     b4a:	10 92 ff 03 	sts	0x03FF, r1
	}
}
     b4e:	8f 91       	pop	r24
     b50:	0f 90       	pop	r0
     b52:	0f be       	out	0x3f, r0	; 63
     b54:	0f 90       	pop	r0
     b56:	1f 90       	pop	r1
     b58:	18 95       	reti

00000b5a <__vector_2>:
//ISR for controlling WEN.
ISR(INT1_vect)
{
     b5a:	1f 92       	push	r1
     b5c:	0f 92       	push	r0
     b5e:	0f b6       	in	r0, 0x3f	; 63
     b60:	0f 92       	push	r0
     b62:	11 24       	eor	r1, r1
     b64:	8f 93       	push	r24
	//printf("ISR INT1 Entered\n");
	if (VSYNC_1_Count==1)//start a frame read
     b66:	80 91 40 0c 	lds	r24, 0x0C40
     b6a:	81 30       	cpi	r24, 0x01	; 1
     b6c:	39 f4       	brne	.+14     	; 0xb7c <__vector_2+0x22>
	{
		FIFO_WEN_1_SET;
     b6e:	44 9a       	sbi	0x08, 4	; 8
		VSYNC_1_Count++;
     b70:	80 91 40 0c 	lds	r24, 0x0C40
     b74:	8f 5f       	subi	r24, 0xFF	; 255
     b76:	80 93 40 0c 	sts	0x0C40, r24
     b7a:	14 c0       	rjmp	.+40     	; 0xba4 <__vector_2+0x4a>
	}
	else if (VSYNC_1_Count==2)//end a frame read
     b7c:	80 91 40 0c 	lds	r24, 0x0C40
     b80:	82 30       	cpi	r24, 0x02	; 2
     b82:	39 f4       	brne	.+14     	; 0xb92 <__vector_2+0x38>
	{
		FIFO_WEN_1_CLR;
     b84:	44 98       	cbi	0x08, 4	; 8
		VSYNC_1_Count++;
     b86:	80 91 40 0c 	lds	r24, 0x0C40
     b8a:	8f 5f       	subi	r24, 0xFF	; 255
     b8c:	80 93 40 0c 	sts	0x0C40, r24
     b90:	09 c0       	rjmp	.+18     	; 0xba4 <__vector_2+0x4a>
	}
	else if(VSYNC_1_Count == 3)
     b92:	80 91 40 0c 	lds	r24, 0x0C40
     b96:	83 30       	cpi	r24, 0x03	; 3
     b98:	11 f4       	brne	.+4      	; 0xb9e <__vector_2+0x44>
	{
		FIFO_WEN_1_CLR;
     b9a:	44 98       	cbi	0x08, 4	; 8
     b9c:	03 c0       	rjmp	.+6      	; 0xba4 <__vector_2+0x4a>
	}
	else
	{
		FIFO_WEN_1_CLR
     b9e:	44 98       	cbi	0x08, 4	; 8
		VSYNC_1_Count = 0;//wait for a read to be started
     ba0:	10 92 40 0c 	sts	0x0C40, r1
	}
}
     ba4:	8f 91       	pop	r24
     ba6:	0f 90       	pop	r0
     ba8:	0f be       	out	0x3f, r0	; 63
     baa:	0f 90       	pop	r0
     bac:	1f 90       	pop	r1
     bae:	18 95       	reti

00000bb0 <wrOV7670Reg>:

//Write Register Method
unsigned char wrOV7670Reg(unsigned char regID, unsigned char regDat)
{
     bb0:	cf 93       	push	r28
     bb2:	df 93       	push	r29
     bb4:	00 d0       	rcall	.+0      	; 0xbb6 <wrOV7670Reg+0x6>
     bb6:	00 d0       	rcall	.+0      	; 0xbb8 <wrOV7670Reg+0x8>
     bb8:	cd b7       	in	r28, 0x3d	; 61
     bba:	de b7       	in	r29, 0x3e	; 62
	/*	I2C Traffic Generated:
	 *	S | OV_7670 + W | A | RegID | A | Data | A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE];
	messageBuf[0] = (OV7670_ADDR  <<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consit of General Call code or the TWI slave address.
     bbc:	92 e4       	ldi	r25, 0x42	; 66
     bbe:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for commands.
     bc0:	8a 83       	std	Y+2, r24	; 0x02
	messageBuf[2] = regDat;                        // The second byte is used for the data.
     bc2:	6b 83       	std	Y+3, r22	; 0x03
	TWI_Start_Transceiver_With_Data( messageBuf, 3 );
     bc4:	ce 01       	movw	r24, r28
     bc6:	01 96       	adiw	r24, 0x01	; 1
     bc8:	63 e0       	ldi	r22, 0x03	; 3
     bca:	0e 94 0d 2a 	call	0x541a	; 0x541a <TWI_Start_Transceiver_With_Data>
	
	while(TWI_Transceiver_Busy()) ; //Wait for transceiver to clear
     bce:	0e 94 02 2a 	call	0x5404	; 0x5404 <TWI_Transceiver_Busy>
     bd2:	88 23       	and	r24, r24
     bd4:	e1 f7       	brne	.-8      	; 0xbce <wrOV7670Reg+0x1e>
	
	return TWI_statusReg.lastTransOK;
     bd6:	80 91 f8 03 	lds	r24, 0x03F8
}
     bda:	81 70       	andi	r24, 0x01	; 1
     bdc:	0f 90       	pop	r0
     bde:	0f 90       	pop	r0
     be0:	0f 90       	pop	r0
     be2:	0f 90       	pop	r0
     be4:	df 91       	pop	r29
     be6:	cf 91       	pop	r28
     be8:	08 95       	ret

00000bea <rdOV7670Reg>:

//Read Register Method
unsigned char rdOV7670Reg(unsigned char regID, unsigned char *regDat)
{
     bea:	0f 93       	push	r16
     bec:	1f 93       	push	r17
     bee:	cf 93       	push	r28
     bf0:	df 93       	push	r29
     bf2:	00 d0       	rcall	.+0      	; 0xbf4 <rdOV7670Reg+0xa>
     bf4:	00 d0       	rcall	.+0      	; 0xbf6 <rdOV7670Reg+0xc>
     bf6:	cd b7       	in	r28, 0x3d	; 61
     bf8:	de b7       	in	r29, 0x3e	; 62
     bfa:	8b 01       	movw	r16, r22
	 *	S	|	OV_ADDR + W	| A | RegID | A | P |
	 *	S	|	OV_ADDR + R | A | Data	|~A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE]; //Initialise a buffer
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
     bfc:	92 e4       	ldi	r25, 0x42	; 66
     bfe:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for Address Pointer.
     c00:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
     c02:	ce 01       	movw	r24, r28
     c04:	01 96       	adiw	r24, 0x01	; 1
     c06:	62 e0       	ldi	r22, 0x02	; 2
     c08:	0e 94 0d 2a 	call	0x541a	; 0x541a <TWI_Start_Transceiver_With_Data>
	
	// Request/collect the data from the Slave
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
     c0c:	83 e4       	ldi	r24, 0x43	; 67
     c0e:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );              
     c10:	ce 01       	movw	r24, r28
     c12:	01 96       	adiw	r24, 0x01	; 1
     c14:	62 e0       	ldi	r22, 0x02	; 2
     c16:	0e 94 0d 2a 	call	0x541a	; 0x541a <TWI_Start_Transceiver_With_Data>
    
	// Get the received data from the transceiver buffer
	TWI_Get_Data_From_Transceiver( messageBuf, 2 );
     c1a:	ce 01       	movw	r24, r28
     c1c:	01 96       	adiw	r24, 0x01	; 1
     c1e:	62 e0       	ldi	r22, 0x02	; 2
     c20:	0e 94 43 2a 	call	0x5486	; 0x5486 <TWI_Get_Data_From_Transceiver>
	*regDat = messageBuf[1];       
     c24:	8a 81       	ldd	r24, Y+2	; 0x02
     c26:	f8 01       	movw	r30, r16
     c28:	80 83       	st	Z, r24
	return TWI_statusReg.lastTransOK;
     c2a:	80 91 f8 03 	lds	r24, 0x03F8
}
     c2e:	81 70       	andi	r24, 0x01	; 1
     c30:	0f 90       	pop	r0
     c32:	0f 90       	pop	r0
     c34:	0f 90       	pop	r0
     c36:	0f 90       	pop	r0
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	1f 91       	pop	r17
     c3e:	0f 91       	pop	r16
     c40:	08 95       	ret

00000c42 <OV7670_init>:


unsigned char OV7670_init()
{
     c42:	0f 93       	push	r16
     c44:	1f 93       	push	r17
     c46:	cf 93       	push	r28
     c48:	df 93       	push	r29
	uint8_t i = 0;
	if(0==wrOV7670Reg(OV_COM7, 0x80)) //Reset Camera
     c4a:	82 e1       	ldi	r24, 0x12	; 18
     c4c:	60 e8       	ldi	r22, 0x80	; 128
     c4e:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <wrOV7670Reg>
     c52:	88 23       	and	r24, r24
     c54:	f1 f0       	breq	.+60     	; 0xc92 <OV7670_init+0x50>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     c56:	8f e2       	ldi	r24, 0x2F	; 47
     c58:	95 e7       	ldi	r25, 0x75	; 117
     c5a:	01 97       	sbiw	r24, 0x01	; 1
     c5c:	f1 f7       	brne	.-4      	; 0xc5a <OV7670_init+0x18>
     c5e:	00 c0       	rjmp	.+0      	; 0xc60 <OV7670_init+0x1e>
     c60:	00 00       	nop
     c62:	c8 e9       	ldi	r28, 0x98	; 152
     c64:	d1 e0       	ldi	r29, 0x01	; 1
	*regDat = messageBuf[1];       
	return TWI_statusReg.lastTransOK;
}


unsigned char OV7670_init()
     c66:	06 ee       	ldi	r16, 0xE6	; 230
     c68:	12 e0       	ldi	r17, 0x02	; 2
     c6a:	fe 01       	movw	r30, r28
     c6c:	31 97       	sbiw	r30, 0x01	; 1
		return 1;
	}
	_delay_ms(10);
	for(i=0; i<SETTINGS_LENGTH; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
     c6e:	80 81       	ld	r24, Z
     c70:	68 81       	ld	r22, Y
     c72:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <wrOV7670Reg>
     c76:	88 23       	and	r24, r24
     c78:	71 f0       	breq	.+28     	; 0xc96 <OV7670_init+0x54>
     c7a:	87 eb       	ldi	r24, 0xB7	; 183
     c7c:	9b e0       	ldi	r25, 0x0B	; 11
     c7e:	01 97       	sbiw	r24, 0x01	; 1
     c80:	f1 f7       	brne	.-4      	; 0xc7e <OV7670_init+0x3c>
     c82:	00 c0       	rjmp	.+0      	; 0xc84 <OV7670_init+0x42>
     c84:	00 00       	nop
     c86:	22 96       	adiw	r28, 0x02	; 2
	if(0==wrOV7670Reg(OV_COM7, 0x80)) //Reset Camera
	{
		return 1;
	}
	_delay_ms(10);
	for(i=0; i<SETTINGS_LENGTH; i++)
     c88:	c0 17       	cp	r28, r16
     c8a:	d1 07       	cpc	r29, r17
     c8c:	71 f7       	brne	.-36     	; 0xc6a <OV7670_init+0x28>
			return 1;
		}
		_delay_ms(1);
	}
	
	return 0;
     c8e:	80 e0       	ldi	r24, 0x00	; 0
     c90:	03 c0       	rjmp	.+6      	; 0xc98 <OV7670_init+0x56>
unsigned char OV7670_init()
{
	uint8_t i = 0;
	if(0==wrOV7670Reg(OV_COM7, 0x80)) //Reset Camera
	{
		return 1;
     c92:	81 e0       	ldi	r24, 0x01	; 1
     c94:	01 c0       	rjmp	.+2      	; 0xc98 <OV7670_init+0x56>
	_delay_ms(10);
	for(i=0; i<SETTINGS_LENGTH; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
		{
			return 1;
     c96:	81 e0       	ldi	r24, 0x01	; 1
		}
		_delay_ms(1);
	}
	
	return 0;
}
     c98:	df 91       	pop	r29
     c9a:	cf 91       	pop	r28
     c9c:	1f 91       	pop	r17
     c9e:	0f 91       	pop	r16
     ca0:	08 95       	ret

00000ca2 <FIFO_init>:

void FIFO_init( void )
{
	//Reset Buffer 0
	FIFO_WRST_0_CLR;
     ca2:	5f 98       	cbi	0x0b, 7	; 11
	FIFO_RCLK_0_CLR;
     ca4:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nOE_0_CLR;
     ca6:	46 98       	cbi	0x08, 6	; 8
	FIFO_nRRST_0_SET;
     ca8:	5d 9a       	sbi	0x0b, 5	; 11
	FIFO_WEN_0_CLR;
     caa:	5e 98       	cbi	0x0b, 6	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     cac:	88 e2       	ldi	r24, 0x28	; 40
     cae:	8a 95       	dec	r24
     cb0:	f1 f7       	brne	.-4      	; 0xcae <FIFO_init+0xc>
	_delay_us(10);
	FIFO_RCLK_0_SET;
     cb2:	5c 9a       	sbi	0x0b, 4	; 11
     cb4:	88 e2       	ldi	r24, 0x28	; 40
     cb6:	8a 95       	dec	r24
     cb8:	f1 f7       	brne	.-4      	; 0xcb6 <FIFO_init+0x14>
	_delay_us(10);
	FIFO_RCLK_0_CLR;
     cba:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_0_CLR;
     cbc:	5d 98       	cbi	0x0b, 5	; 11
     cbe:	88 e2       	ldi	r24, 0x28	; 40
     cc0:	8a 95       	dec	r24
     cc2:	f1 f7       	brne	.-4      	; 0xcc0 <FIFO_init+0x1e>
	_delay_us(10);
	FIFO_RCLK_0_SET;
     cc4:	5c 9a       	sbi	0x0b, 4	; 11
     cc6:	88 e2       	ldi	r24, 0x28	; 40
     cc8:	8a 95       	dec	r24
     cca:	f1 f7       	brne	.-4      	; 0xcc8 <FIFO_init+0x26>
	_delay_us(10);
	FIFO_RCLK_0_CLR;
     ccc:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_0_SET;
     cce:	5d 9a       	sbi	0x0b, 5	; 11
     cd0:	88 e2       	ldi	r24, 0x28	; 40
     cd2:	8a 95       	dec	r24
     cd4:	f1 f7       	brne	.-4      	; 0xcd2 <FIFO_init+0x30>
	_delay_us(10);
	FIFO_WRST_0_SET;
     cd6:	5f 9a       	sbi	0x0b, 7	; 11
	
	//Reset Buffer 1
	FIFO_WRST_1_CLR;
     cd8:	45 98       	cbi	0x08, 5	; 8
	FIFO_RCLK_1_CLR;
     cda:	42 98       	cbi	0x08, 2	; 8
	FIFO_nOE_1_CLR;
     cdc:	47 98       	cbi	0x08, 7	; 8
	FIFO_nRRST_1_SET;
     cde:	43 9a       	sbi	0x08, 3	; 8
	FIFO_WEN_1_CLR;
     ce0:	44 98       	cbi	0x08, 4	; 8
     ce2:	88 e2       	ldi	r24, 0x28	; 40
     ce4:	8a 95       	dec	r24
     ce6:	f1 f7       	brne	.-4      	; 0xce4 <FIFO_init+0x42>
	_delay_us(10);
	FIFO_RCLK_1_SET;
     ce8:	42 9a       	sbi	0x08, 2	; 8
     cea:	88 e2       	ldi	r24, 0x28	; 40
     cec:	8a 95       	dec	r24
     cee:	f1 f7       	brne	.-4      	; 0xcec <FIFO_init+0x4a>
	_delay_us(10);
	FIFO_RCLK_1_CLR;
     cf0:	42 98       	cbi	0x08, 2	; 8
	FIFO_nRRST_1_CLR;
     cf2:	43 98       	cbi	0x08, 3	; 8
     cf4:	88 e2       	ldi	r24, 0x28	; 40
     cf6:	8a 95       	dec	r24
     cf8:	f1 f7       	brne	.-4      	; 0xcf6 <FIFO_init+0x54>
	_delay_us(10);
	FIFO_RCLK_1_SET;
     cfa:	42 9a       	sbi	0x08, 2	; 8
     cfc:	88 e2       	ldi	r24, 0x28	; 40
     cfe:	8a 95       	dec	r24
     d00:	f1 f7       	brne	.-4      	; 0xcfe <FIFO_init+0x5c>
	_delay_us(10);
	FIFO_RCLK_1_CLR;
     d02:	42 98       	cbi	0x08, 2	; 8
	FIFO_nRRST_1_SET;
     d04:	43 9a       	sbi	0x08, 3	; 8
     d06:	88 e2       	ldi	r24, 0x28	; 40
     d08:	8a 95       	dec	r24
     d0a:	f1 f7       	brne	.-4      	; 0xd08 <FIFO_init+0x66>
	_delay_us(10);
	FIFO_WRST_1_SET;
     d0c:	45 9a       	sbi	0x08, 5	; 8

}
     d0e:	08 95       	ret

00000d10 <FIFO_TO_AVR>:
//Write one pixel in AVR
uint16_t FIFO_TO_AVR(uint8_t ID)
{
	uint16_t data = 0;
	
	DDRA = 0;
     d10:	11 b8       	out	0x01, r1	; 1
	if(ID == 1)
     d12:	81 30       	cpi	r24, 0x01	; 1
     d14:	61 f4       	brne	.+24     	; 0xd2e <FIFO_TO_AVR+0x1e>
	{
		FIFO_RCLK_1_SET;
     d16:	42 9a       	sbi	0x08, 2	; 8
		data = PINA;
     d18:	80 b1       	in	r24, 0x00	; 0
		FIFO_RCLK_1_CLR;
     d1a:	42 98       	cbi	0x08, 2	; 8
		data <<= 8;
     d1c:	38 2f       	mov	r19, r24
     d1e:	20 e0       	ldi	r18, 0x00	; 0
		FIFO_RCLK_1_SET;
     d20:	42 9a       	sbi	0x08, 2	; 8
		data |= PINA;
     d22:	80 b1       	in	r24, 0x00	; 0
     d24:	90 e0       	ldi	r25, 0x00	; 0
     d26:	82 2b       	or	r24, r18
     d28:	93 2b       	or	r25, r19
		FIFO_RCLK_1_CLR;
     d2a:	42 98       	cbi	0x08, 2	; 8
     d2c:	08 95       	ret
	}		
	else
	{	
		FIFO_RCLK_0_SET;
     d2e:	5c 9a       	sbi	0x0b, 4	; 11
		data = PINA;
     d30:	80 b1       	in	r24, 0x00	; 0
		FIFO_RCLK_0_CLR;
     d32:	5c 98       	cbi	0x0b, 4	; 11
		data <<= 8;
     d34:	38 2f       	mov	r19, r24
     d36:	20 e0       	ldi	r18, 0x00	; 0
		FIFO_RCLK_0_SET;
     d38:	5c 9a       	sbi	0x0b, 4	; 11
		data |= PINA;
     d3a:	80 b1       	in	r24, 0x00	; 0
     d3c:	90 e0       	ldi	r25, 0x00	; 0
     d3e:	82 2b       	or	r24, r18
     d40:	93 2b       	or	r25, r19
		FIFO_RCLK_0_CLR;
     d42:	5c 98       	cbi	0x0b, 4	; 11
	}		
	return(data);
}
     d44:	08 95       	ret

00000d46 <FIFO_Reset>:


//Resets both pointers
void FIFO_Reset(uint8_t CameraID)
{
	if(CameraID == 0)
     d46:	88 23       	and	r24, r24
     d48:	39 f4       	brne	.+14     	; 0xd58 <FIFO_Reset+0x12>
	{
		FIFO_WRST_0_CLR;
     d4a:	5f 98       	cbi	0x0b, 7	; 11
		FIFO_nRRST_0_CLR;
     d4c:	5d 98       	cbi	0x0b, 5	; 11
		FIFO_RCLK_0_SET;
     d4e:	5c 9a       	sbi	0x0b, 4	; 11
		FIFO_RCLK_0_CLR;
     d50:	5c 98       	cbi	0x0b, 4	; 11
		FIFO_nRRST_0_SET;
     d52:	5d 9a       	sbi	0x0b, 5	; 11
		FIFO_WRST_0_SET;
     d54:	5f 9a       	sbi	0x0b, 7	; 11
     d56:	08 95       	ret
	}
	else
	{
		FIFO_WRST_1_CLR;
     d58:	45 98       	cbi	0x08, 5	; 8
		FIFO_nRRST_1_CLR;
     d5a:	43 98       	cbi	0x08, 3	; 8
		FIFO_RCLK_1_SET;
     d5c:	42 9a       	sbi	0x08, 2	; 8
		FIFO_RCLK_1_CLR;
     d5e:	42 98       	cbi	0x08, 2	; 8
		FIFO_nRRST_1_SET;
     d60:	43 9a       	sbi	0x08, 3	; 8
		FIFO_WRST_1_SET;
     d62:	45 9a       	sbi	0x08, 5	; 8
     d64:	08 95       	ret

00000d66 <LoadImagesToBuffer>:
	}
	
}
void LoadImagesToBuffer()
{
	VSYNC_0_Count = 0;
     d66:	10 92 ff 03 	sts	0x03FF, r1
	VSYNC_1_Count = 0;
     d6a:	10 92 40 0c 	sts	0x0C40, r1
	FIFO_Reset(0);
     d6e:	80 e0       	ldi	r24, 0x00	; 0
     d70:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
	FIFO_Reset(1);
     d74:	81 e0       	ldi	r24, 0x01	; 1
     d76:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
	VSYNC_0_Count = 1;
     d7a:	81 e0       	ldi	r24, 0x01	; 1
     d7c:	80 93 ff 03 	sts	0x03FF, r24
	VSYNC_1_Count = 1;
     d80:	80 93 40 0c 	sts	0x0C40, r24
	
}
     d84:	08 95       	ret

00000d86 <GetImageIfAvailiable>:
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
{
     d86:	2f 92       	push	r2
     d88:	3f 92       	push	r3
     d8a:	4f 92       	push	r4
     d8c:	5f 92       	push	r5
     d8e:	6f 92       	push	r6
     d90:	7f 92       	push	r7
     d92:	8f 92       	push	r8
     d94:	9f 92       	push	r9
     d96:	af 92       	push	r10
     d98:	bf 92       	push	r11
     d9a:	cf 92       	push	r12
     d9c:	df 92       	push	r13
     d9e:	ff 92       	push	r15
     da0:	0f 93       	push	r16
     da2:	1f 93       	push	r17
     da4:	cf 93       	push	r28
     da6:	df 93       	push	r29
     da8:	00 d0       	rcall	.+0      	; 0xdaa <GetImageIfAvailiable+0x24>
     daa:	00 d0       	rcall	.+0      	; 0xdac <GetImageIfAvailiable+0x26>
     dac:	cd b7       	in	r28, 0x3d	; 61
     dae:	de b7       	in	r29, 0x3e	; 62
     db0:	3c 01       	movw	r6, r24
     db2:	f6 2e       	mov	r15, r22

	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
     db4:	66 23       	and	r22, r22
     db6:	31 f4       	brne	.+12     	; 0xdc4 <GetImageIfAvailiable+0x3e>
     db8:	80 91 ff 03 	lds	r24, 0x03FF
     dbc:	83 30       	cpi	r24, 0x03	; 3
     dbe:	69 f0       	breq	.+26     	; 0xdda <GetImageIfAvailiable+0x54>
		FIFO_nOE_1_SET;
		return 0;
	}
	else
	{
		return 2;
     dc0:	82 e0       	ldi	r24, 0x02	; 2
     dc2:	7f c0       	rjmp	.+254    	; 0xec2 <GetImageIfAvailiable+0x13c>
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
{

	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
     dc4:	81 e0       	ldi	r24, 0x01	; 1
     dc6:	68 17       	cp	r22, r24
     dc8:	09 f0       	breq	.+2      	; 0xdcc <GetImageIfAvailiable+0x46>
     dca:	7a c0       	rjmp	.+244    	; 0xec0 <GetImageIfAvailiable+0x13a>
		((CameraID == 1) && (VSYNC_1_Count == 3)) )
     dcc:	80 91 40 0c 	lds	r24, 0x0C40
     dd0:	83 30       	cpi	r24, 0x03	; 3
     dd2:	09 f4       	brne	.+2      	; 0xdd6 <GetImageIfAvailiable+0x50>
     dd4:	8c c0       	rjmp	.+280    	; 0xeee <GetImageIfAvailiable+0x168>
		FIFO_nOE_1_SET;
		return 0;
	}
	else
	{
		return 2;
     dd6:	82 e0       	ldi	r24, 0x02	; 2
     dd8:	74 c0       	rjmp	.+232    	; 0xec2 <GetImageIfAvailiable+0x13c>
	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
		((CameraID == 1) && (VSYNC_1_Count == 3)) )
	{
		
		//Write Bitmap Headers
		WriteBMPHeader(File);
     dda:	c3 01       	movw	r24, r6
     ddc:	0e 94 5d 00 	call	0xba	; 0xba <WriteBMPHeader>
		WriteDIBHeader(File);
     de0:	c3 01       	movw	r24, r6
     de2:	0e 94 80 00 	call	0x100	; 0x100 <WriteDIBHeader>
		if (CameraID == 0)
		{
			//Enable output of Camera 0
			FIFO_nOE_0_CLR;
     de6:	46 98       	cbi	0x08, 6	; 8
			//Reset Read Pointer
			FIFO_nRRST_0_CLR;
     de8:	5d 98       	cbi	0x0b, 5	; 11
			FIFO_RCLK_0_SET;
     dea:	5c 9a       	sbi	0x0b, 4	; 11
			FIFO_RCLK_0_CLR;
     dec:	5c 98       	cbi	0x0b, 4	; 11
			FIFO_nRRST_0_SET;
     dee:	5d 9a       	sbi	0x0b, 5	; 11
	VSYNC_0_Count = 1;
	VSYNC_1_Count = 1;
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
{
     df0:	0f 2e       	mov	r0, r31
     df2:	fa e8       	ldi	r31, 0x8A	; 138
     df4:	8f 2e       	mov	r8, r31
     df6:	f0 e0       	ldi	r31, 0x00	; 0
     df8:	9f 2e       	mov	r9, r31
     dfa:	f0 e0       	ldi	r31, 0x00	; 0
     dfc:	af 2e       	mov	r10, r31
     dfe:	f0 e0       	ldi	r31, 0x00	; 0
     e00:	bf 2e       	mov	r11, r31
     e02:	f0 2d       	mov	r31, r0
		uint32_t pointer;
		uint16_t Temp;
		uint32_t p;
		FRESULT fr;
		//for(j = HEIGHT; j>0; j--)
		for(j = 0; j < HEIGHT; j++)
     e04:	0f 2e       	mov	r0, r31
     e06:	f1 e4       	ldi	r31, 0x41	; 65
     e08:	4f 2e       	mov	r4, r31
     e0a:	f8 e0       	ldi	r31, 0x08	; 8
     e0c:	5f 2e       	mov	r5, r31
     e0e:	f0 2d       	mov	r31, r0
	FIFO_Reset(1);
	VSYNC_0_Count = 1;
	VSYNC_1_Count = 1;
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
     e10:	0f 2e       	mov	r0, r31
     e12:	f1 ec       	ldi	r31, 0xC1	; 193
     e14:	cf 2e       	mov	r12, r31
     e16:	fa e0       	ldi	r31, 0x0A	; 10
     e18:	df 2e       	mov	r13, r31
     e1a:	f0 2d       	mov	r31, r0
				Buff[pointer++] = (uint8_t)Temp >> 8;
				Buff[pointer++] = (uint8_t)Temp;
			}
			pointer = (uint32_t)j * (uint32_t)WIDTH * 2 + BMPHEADERSIZE + DIBHEADERSIZE;
			f_lseek(File, pointer);
			fr = f_write(File, Buff, WIDTH * 2, &p);
     e1c:	0f 2e       	mov	r0, r31
     e1e:	f0 e4       	ldi	r31, 0x40	; 64
     e20:	2f 2e       	mov	r2, r31
     e22:	f8 e0       	ldi	r31, 0x08	; 8
     e24:	3f 2e       	mov	r3, r31
     e26:	f0 2d       	mov	r31, r0
     e28:	3f c0       	rjmp	.+126    	; 0xea8 <GetImageIfAvailiable+0x122>
		for(j = 0; j < HEIGHT; j++)
		{
			pointer = 0;
			for(i = 0; i < WIDTH; i++)
			{
				Temp = FIFO_TO_AVR(CameraID);
     e2a:	8f 2d       	mov	r24, r15
     e2c:	0e 94 88 06 	call	0xd10	; 0xd10 <FIFO_TO_AVR>
	FIFO_Reset(1);
	VSYNC_0_Count = 1;
	VSYNC_1_Count = 1;
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
     e30:	f8 01       	movw	r30, r16
     e32:	31 97       	sbiw	r30, 0x01	; 1
			pointer = 0;
			for(i = 0; i < WIDTH; i++)
			{
				Temp = FIFO_TO_AVR(CameraID);
				//USART0_Senduint16(Temp);
				Buff[pointer++] = (uint8_t)Temp >> 8;
     e34:	10 82       	st	Z, r1
				Buff[pointer++] = (uint8_t)Temp;
     e36:	d8 01       	movw	r26, r16
     e38:	8c 93       	st	X, r24
     e3a:	0e 5f       	subi	r16, 0xFE	; 254
     e3c:	1f 4f       	sbci	r17, 0xFF	; 255
		FRESULT fr;
		//for(j = HEIGHT; j>0; j--)
		for(j = 0; j < HEIGHT; j++)
		{
			pointer = 0;
			for(i = 0; i < WIDTH; i++)
     e3e:	0c 15       	cp	r16, r12
     e40:	1d 05       	cpc	r17, r13
     e42:	99 f7       	brne	.-26     	; 0xe2a <GetImageIfAvailiable+0xa4>
				//USART0_Senduint16(Temp);
				Buff[pointer++] = (uint8_t)Temp >> 8;
				Buff[pointer++] = (uint8_t)Temp;
			}
			pointer = (uint32_t)j * (uint32_t)WIDTH * 2 + BMPHEADERSIZE + DIBHEADERSIZE;
			f_lseek(File, pointer);
     e44:	c3 01       	movw	r24, r6
     e46:	b5 01       	movw	r22, r10
     e48:	a4 01       	movw	r20, r8
     e4a:	0e 94 a6 20 	call	0x414c	; 0x414c <f_lseek>
			fr = f_write(File, Buff, WIDTH * 2, &p);
     e4e:	c3 01       	movw	r24, r6
     e50:	b1 01       	movw	r22, r2
     e52:	20 e8       	ldi	r18, 0x80	; 128
     e54:	32 e0       	ldi	r19, 0x02	; 2
     e56:	40 e0       	ldi	r20, 0x00	; 0
     e58:	50 e0       	ldi	r21, 0x00	; 0
     e5a:	8e 01       	movw	r16, r28
     e5c:	0f 5f       	subi	r16, 0xFF	; 255
     e5e:	1f 4f       	sbci	r17, 0xFF	; 255
     e60:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <f_write>
			if(fr != FR_OK)
     e64:	88 23       	and	r24, r24
     e66:	79 f0       	breq	.+30     	; 0xe86 <GetImageIfAvailiable+0x100>
			{
				printf("Write Fail.\n");
     e68:	8b e8       	ldi	r24, 0x8B	; 139
     e6a:	91 e0       	ldi	r25, 0x01	; 1
     e6c:	0e 94 ae 2b 	call	0x575c	; 0x575c <puts>
				VSYNC_0_Count = 0;
     e70:	10 92 ff 03 	sts	0x03FF, r1
				VSYNC_1_Count = 0;
     e74:	10 92 40 0c 	sts	0x0C40, r1
				FIFO_Reset(CameraID);
     e78:	8f 2d       	mov	r24, r15
     e7a:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
				FIFO_nOE_0_SET;
     e7e:	46 9a       	sbi	0x08, 6	; 8
				FIFO_nOE_1_SET;
     e80:	47 9a       	sbi	0x08, 7	; 8
				return 1;
     e82:	81 e0       	ldi	r24, 0x01	; 1
     e84:	1e c0       	rjmp	.+60     	; 0xec2 <GetImageIfAvailiable+0x13c>
     e86:	80 e8       	ldi	r24, 0x80	; 128
     e88:	92 e0       	ldi	r25, 0x02	; 2
     e8a:	a0 e0       	ldi	r26, 0x00	; 0
     e8c:	b0 e0       	ldi	r27, 0x00	; 0
     e8e:	88 0e       	add	r8, r24
     e90:	99 1e       	adc	r9, r25
     e92:	aa 1e       	adc	r10, r26
     e94:	bb 1e       	adc	r11, r27
		uint32_t pointer;
		uint16_t Temp;
		uint32_t p;
		FRESULT fr;
		//for(j = HEIGHT; j>0; j--)
		for(j = 0; j < HEIGHT; j++)
     e96:	9a e8       	ldi	r25, 0x8A	; 138
     e98:	89 16       	cp	r8, r25
     e9a:	98 e5       	ldi	r25, 0x58	; 88
     e9c:	99 06       	cpc	r9, r25
     e9e:	92 e0       	ldi	r25, 0x02	; 2
     ea0:	a9 06       	cpc	r10, r25
     ea2:	90 e0       	ldi	r25, 0x00	; 0
     ea4:	b9 06       	cpc	r11, r25
     ea6:	11 f0       	breq	.+4      	; 0xeac <GetImageIfAvailiable+0x126>
     ea8:	82 01       	movw	r16, r4
     eaa:	bf cf       	rjmp	.-130    	; 0xe2a <GetImageIfAvailiable+0xa4>
				FIFO_nOE_0_SET;
				FIFO_nOE_1_SET;
				return 1;
			}
		}
		FIFO_Reset(CameraID);
     eac:	8f 2d       	mov	r24, r15
     eae:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
		fr = f_close(File);
     eb2:	c3 01       	movw	r24, r6
     eb4:	0e 94 3a 20 	call	0x4074	; 0x4074 <f_close>
		FIFO_nOE_0_SET;
     eb8:	46 9a       	sbi	0x08, 6	; 8
		FIFO_nOE_1_SET;
     eba:	47 9a       	sbi	0x08, 7	; 8
		return 0;
     ebc:	80 e0       	ldi	r24, 0x00	; 0
     ebe:	01 c0       	rjmp	.+2      	; 0xec2 <GetImageIfAvailiable+0x13c>
	}
	else
	{
		return 2;
     ec0:	82 e0       	ldi	r24, 0x02	; 2
	}
}
     ec2:	0f 90       	pop	r0
     ec4:	0f 90       	pop	r0
     ec6:	0f 90       	pop	r0
     ec8:	0f 90       	pop	r0
     eca:	df 91       	pop	r29
     ecc:	cf 91       	pop	r28
     ece:	1f 91       	pop	r17
     ed0:	0f 91       	pop	r16
     ed2:	ff 90       	pop	r15
     ed4:	df 90       	pop	r13
     ed6:	cf 90       	pop	r12
     ed8:	bf 90       	pop	r11
     eda:	af 90       	pop	r10
     edc:	9f 90       	pop	r9
     ede:	8f 90       	pop	r8
     ee0:	7f 90       	pop	r7
     ee2:	6f 90       	pop	r6
     ee4:	5f 90       	pop	r5
     ee6:	4f 90       	pop	r4
     ee8:	3f 90       	pop	r3
     eea:	2f 90       	pop	r2
     eec:	08 95       	ret
	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
		((CameraID == 1) && (VSYNC_1_Count == 3)) )
	{
		
		//Write Bitmap Headers
		WriteBMPHeader(File);
     eee:	c3 01       	movw	r24, r6
     ef0:	0e 94 5d 00 	call	0xba	; 0xba <WriteBMPHeader>
		WriteDIBHeader(File);
     ef4:	c3 01       	movw	r24, r6
     ef6:	0e 94 80 00 	call	0x100	; 0x100 <WriteDIBHeader>
			FIFO_nRRST_0_SET;
		}		
		else 
		{
			//Enable output of Camera 0
			FIFO_nOE_1_CLR;
     efa:	47 98       	cbi	0x08, 7	; 8
			//Reset Read Pointer
			FIFO_nRRST_1_CLR;
     efc:	43 98       	cbi	0x08, 3	; 8
			FIFO_RCLK_1_SET;
     efe:	42 9a       	sbi	0x08, 2	; 8
			FIFO_RCLK_1_CLR;
     f00:	42 98       	cbi	0x08, 2	; 8
			FIFO_nRRST_1_SET;
     f02:	43 9a       	sbi	0x08, 3	; 8
     f04:	75 cf       	rjmp	.-278    	; 0xdf0 <GetImageIfAvailiable+0x6a>

00000f06 <SCCB_wrOV7670Reg>:
		return 2;
	}
}

unsigned char SCCB_wrOV7670Reg(unsigned char regID, unsigned char regDat)
{
     f06:	cf 93       	push	r28
     f08:	df 93       	push	r29
     f0a:	c8 2f       	mov	r28, r24
     f0c:	d6 2f       	mov	r29, r22
	startSCCB();
     f0e:	0e 94 3c 29 	call	0x5278	; 0x5278 <startSCCB>
	if(0==SCCBwriteByte(0x42))
     f12:	82 e4       	ldi	r24, 0x42	; 66
     f14:	0e 94 8c 29 	call	0x5318	; 0x5318 <SCCBwriteByte>
     f18:	88 23       	and	r24, r24
     f1a:	21 f4       	brne	.+8      	; 0xf24 <SCCB_wrOV7670Reg+0x1e>
	{
		stopSCCB();
     f1c:	0e 94 59 29 	call	0x52b2	; 0x52b2 <stopSCCB>
		return(0);
     f20:	80 e0       	ldi	r24, 0x00	; 0
     f22:	21 c0       	rjmp	.+66     	; 0xf66 <SCCB_wrOV7670Reg+0x60>
     f24:	8b e2       	ldi	r24, 0x2B	; 43
     f26:	91 e0       	ldi	r25, 0x01	; 1
     f28:	01 97       	sbiw	r24, 0x01	; 1
     f2a:	f1 f7       	brne	.-4      	; 0xf28 <SCCB_wrOV7670Reg+0x22>
     f2c:	00 c0       	rjmp	.+0      	; 0xf2e <SCCB_wrOV7670Reg+0x28>
     f2e:	00 00       	nop
	}
	_delay_us(100);
	if(0==SCCBwriteByte(regID))
     f30:	8c 2f       	mov	r24, r28
     f32:	0e 94 8c 29 	call	0x5318	; 0x5318 <SCCBwriteByte>
     f36:	88 23       	and	r24, r24
     f38:	21 f4       	brne	.+8      	; 0xf42 <SCCB_wrOV7670Reg+0x3c>
	{
		stopSCCB();
     f3a:	0e 94 59 29 	call	0x52b2	; 0x52b2 <stopSCCB>
		return(0);
     f3e:	80 e0       	ldi	r24, 0x00	; 0
     f40:	12 c0       	rjmp	.+36     	; 0xf66 <SCCB_wrOV7670Reg+0x60>
     f42:	8b e2       	ldi	r24, 0x2B	; 43
     f44:	91 e0       	ldi	r25, 0x01	; 1
     f46:	01 97       	sbiw	r24, 0x01	; 1
     f48:	f1 f7       	brne	.-4      	; 0xf46 <SCCB_wrOV7670Reg+0x40>
     f4a:	00 c0       	rjmp	.+0      	; 0xf4c <SCCB_wrOV7670Reg+0x46>
     f4c:	00 00       	nop
	}
	_delay_us(100);
	if(0==SCCBwriteByte(regDat))
     f4e:	8d 2f       	mov	r24, r29
     f50:	0e 94 8c 29 	call	0x5318	; 0x5318 <SCCBwriteByte>
     f54:	88 23       	and	r24, r24
     f56:	21 f4       	brne	.+8      	; 0xf60 <SCCB_wrOV7670Reg+0x5a>
	{
		stopSCCB();
     f58:	0e 94 59 29 	call	0x52b2	; 0x52b2 <stopSCCB>
		return(0);
     f5c:	80 e0       	ldi	r24, 0x00	; 0
     f5e:	03 c0       	rjmp	.+6      	; 0xf66 <SCCB_wrOV7670Reg+0x60>
	}
	stopSCCB();
     f60:	0e 94 59 29 	call	0x52b2	; 0x52b2 <stopSCCB>
	
	return(1);
     f64:	81 e0       	ldi	r24, 0x01	; 1
}
     f66:	df 91       	pop	r29
     f68:	cf 91       	pop	r28
     f6a:	08 95       	ret

00000f6c <SCCB_rdOV7670Reg>:

//Read the OV7670 Registers

unsigned char SCCB_rdOV7670Reg(unsigned regID, unsigned char *regDat)
{
     f6c:	1f 93       	push	r17
     f6e:	cf 93       	push	r28
     f70:	df 93       	push	r29
     f72:	18 2f       	mov	r17, r24
     f74:	eb 01       	movw	r28, r22
	//Using write operate to set the Register Address
	startSCCB();
     f76:	0e 94 3c 29 	call	0x5278	; 0x5278 <startSCCB>
	if(0==SCCBwriteByte(0x42))
     f7a:	82 e4       	ldi	r24, 0x42	; 66
     f7c:	0e 94 8c 29 	call	0x5318	; 0x5318 <SCCBwriteByte>
     f80:	88 23       	and	r24, r24
     f82:	21 f4       	brne	.+8      	; 0xf8c <SCCB_rdOV7670Reg+0x20>
	{
		stopSCCB();
     f84:	0e 94 59 29 	call	0x52b2	; 0x52b2 <stopSCCB>
		return(0);
     f88:	80 e0       	ldi	r24, 0x00	; 0
     f8a:	30 c0       	rjmp	.+96     	; 0xfec <SCCB_rdOV7670Reg+0x80>
     f8c:	8b e2       	ldi	r24, 0x2B	; 43
     f8e:	91 e0       	ldi	r25, 0x01	; 1
     f90:	01 97       	sbiw	r24, 0x01	; 1
     f92:	f1 f7       	brne	.-4      	; 0xf90 <SCCB_rdOV7670Reg+0x24>
     f94:	00 c0       	rjmp	.+0      	; 0xf96 <SCCB_rdOV7670Reg+0x2a>
     f96:	00 00       	nop
	}
	_delay_us(100);
	if(0==SCCBwriteByte(regID))
     f98:	81 2f       	mov	r24, r17
     f9a:	0e 94 8c 29 	call	0x5318	; 0x5318 <SCCBwriteByte>
     f9e:	88 23       	and	r24, r24
     fa0:	21 f4       	brne	.+8      	; 0xfaa <SCCB_rdOV7670Reg+0x3e>
	{
		stopSCCB();
     fa2:	0e 94 59 29 	call	0x52b2	; 0x52b2 <stopSCCB>
		return(0);
     fa6:	80 e0       	ldi	r24, 0x00	; 0
     fa8:	21 c0       	rjmp	.+66     	; 0xfec <SCCB_rdOV7670Reg+0x80>
	}
	stopSCCB();
     faa:	0e 94 59 29 	call	0x52b2	; 0x52b2 <stopSCCB>
     fae:	8b e2       	ldi	r24, 0x2B	; 43
     fb0:	91 e0       	ldi	r25, 0x01	; 1
     fb2:	01 97       	sbiw	r24, 0x01	; 1
     fb4:	f1 f7       	brne	.-4      	; 0xfb2 <SCCB_rdOV7670Reg+0x46>
     fb6:	00 c0       	rjmp	.+0      	; 0xfb8 <SCCB_rdOV7670Reg+0x4c>
     fb8:	00 00       	nop
	
	_delay_us(100);
	
	//Begin to read
	startSCCB();
     fba:	0e 94 3c 29 	call	0x5278	; 0x5278 <startSCCB>
	if(0==SCCBwriteByte(0x43))
     fbe:	83 e4       	ldi	r24, 0x43	; 67
     fc0:	0e 94 8c 29 	call	0x5318	; 0x5318 <SCCBwriteByte>
     fc4:	88 23       	and	r24, r24
     fc6:	21 f4       	brne	.+8      	; 0xfd0 <SCCB_rdOV7670Reg+0x64>
	{
		stopSCCB();
     fc8:	0e 94 59 29 	call	0x52b2	; 0x52b2 <stopSCCB>
		return(0);
     fcc:	80 e0       	ldi	r24, 0x00	; 0
     fce:	0e c0       	rjmp	.+28     	; 0xfec <SCCB_rdOV7670Reg+0x80>
     fd0:	8b e2       	ldi	r24, 0x2B	; 43
     fd2:	91 e0       	ldi	r25, 0x01	; 1
     fd4:	01 97       	sbiw	r24, 0x01	; 1
     fd6:	f1 f7       	brne	.-4      	; 0xfd4 <SCCB_rdOV7670Reg+0x68>
     fd8:	00 c0       	rjmp	.+0      	; 0xfda <SCCB_rdOV7670Reg+0x6e>
     fda:	00 00       	nop
	}
	_delay_us(100);
	*regDat=SCCBreadByte();
     fdc:	0e 94 d5 29 	call	0x53aa	; 0x53aa <SCCBreadByte>
     fe0:	88 83       	st	Y, r24
	noAck();
     fe2:	0e 94 6f 29 	call	0x52de	; 0x52de <noAck>
	stopSCCB();
     fe6:	0e 94 59 29 	call	0x52b2	; 0x52b2 <stopSCCB>
	return(1);
     fea:	81 e0       	ldi	r24, 0x01	; 1
}
     fec:	df 91       	pop	r29
     fee:	cf 91       	pop	r28
     ff0:	1f 91       	pop	r17
     ff2:	08 95       	ret

00000ff4 <OV7670_SCCB_init>:



// Initial OV7670
unsigned char OV7670_SCCB_init(void)
{
     ff4:	0f 93       	push	r16
     ff6:	1f 93       	push	r17
     ff8:	cf 93       	push	r28
     ffa:	df 93       	push	r29
	unsigned char temp;
	
	unsigned int i=0;

	
	InitSCCB();
     ffc:	0e 94 35 29 	call	0x526a	; 0x526a <InitSCCB>

	temp=0x80;
	if(0==SCCB_wrOV7670Reg(0x12, temp)) //Reset SCCB
    1000:	82 e1       	ldi	r24, 0x12	; 18
    1002:	60 e8       	ldi	r22, 0x80	; 128
    1004:	0e 94 83 07 	call	0xf06	; 0xf06 <SCCB_wrOV7670Reg>
    1008:	88 23       	and	r24, r24
    100a:	c1 f0       	breq	.+48     	; 0x103c <OV7670_SCCB_init+0x48>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    100c:	8f e2       	ldi	r24, 0x2F	; 47
    100e:	95 e7       	ldi	r25, 0x75	; 117
    1010:	01 97       	sbiw	r24, 0x01	; 1
    1012:	f1 f7       	brne	.-4      	; 0x1010 <OV7670_SCCB_init+0x1c>
    1014:	00 c0       	rjmp	.+0      	; 0x1016 <OV7670_SCCB_init+0x22>
    1016:	00 00       	nop
    1018:	c8 e9       	ldi	r28, 0x98	; 152
    101a:	d1 e0       	ldi	r29, 0x01	; 1




// Initial OV7670
unsigned char OV7670_SCCB_init(void)
    101c:	06 ee       	ldi	r16, 0xE6	; 230
    101e:	12 e0       	ldi	r17, 0x02	; 2
    1020:	fe 01       	movw	r30, r28
    1022:	31 97       	sbiw	r30, 0x01	; 1
	}
	_delay_ms(10);

	for(i=0;i<SETTINGS_LENGTH;i++)
	{
		if( 0==SCCB_wrOV7670Reg(default_settings[i][0],default_settings[i][1] ))
    1024:	80 81       	ld	r24, Z
    1026:	68 81       	ld	r22, Y
    1028:	0e 94 83 07 	call	0xf06	; 0xf06 <SCCB_wrOV7670Reg>
    102c:	88 23       	and	r24, r24
    102e:	41 f0       	breq	.+16     	; 0x1040 <OV7670_SCCB_init+0x4c>
    1030:	22 96       	adiw	r28, 0x02	; 2
	{
		return 1 ;
	}
	_delay_ms(10);

	for(i=0;i<SETTINGS_LENGTH;i++)
    1032:	c0 17       	cp	r28, r16
    1034:	d1 07       	cpc	r29, r17
    1036:	a1 f7       	brne	.-24     	; 0x1020 <OV7670_SCCB_init+0x2c>
		{
			return 2;
		}
	}

	return 0; //ok
    1038:	80 e0       	ldi	r24, 0x00	; 0
    103a:	03 c0       	rjmp	.+6      	; 0x1042 <OV7670_SCCB_init+0x4e>
	InitSCCB();

	temp=0x80;
	if(0==SCCB_wrOV7670Reg(0x12, temp)) //Reset SCCB
	{
		return 1 ;
    103c:	81 e0       	ldi	r24, 0x01	; 1
    103e:	01 c0       	rjmp	.+2      	; 0x1042 <OV7670_SCCB_init+0x4e>

	for(i=0;i<SETTINGS_LENGTH;i++)
	{
		if( 0==SCCB_wrOV7670Reg(default_settings[i][0],default_settings[i][1] ))
		{
			return 2;
    1040:	82 e0       	ldi	r24, 0x02	; 2
	}

	return 0; //ok

	
    1042:	df 91       	pop	r29
    1044:	cf 91       	pop	r28
    1046:	1f 91       	pop	r17
    1048:	0f 91       	pop	r16
    104a:	08 95       	ret

0000104c <__vector_16>:

// char Line[100];				/* Console input buffer */
//char Buff[100];			/* Working buffer */

ISR(TIMER0_COMPA_vect)
{
    104c:	1f 92       	push	r1
    104e:	0f 92       	push	r0
    1050:	0f b6       	in	r0, 0x3f	; 63
    1052:	0f 92       	push	r0
    1054:	11 24       	eor	r1, r1
    1056:	2f 93       	push	r18
    1058:	3f 93       	push	r19
    105a:	4f 93       	push	r20
    105c:	5f 93       	push	r21
    105e:	6f 93       	push	r22
    1060:	7f 93       	push	r23
    1062:	8f 93       	push	r24
    1064:	9f 93       	push	r25
    1066:	af 93       	push	r26
    1068:	bf 93       	push	r27
    106a:	ef 93       	push	r30
    106c:	ff 93       	push	r31
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
    106e:	0e 94 65 05 	call	0xaca	; 0xaca <disk_timerproc>
}
    1072:	ff 91       	pop	r31
    1074:	ef 91       	pop	r30
    1076:	bf 91       	pop	r27
    1078:	af 91       	pop	r26
    107a:	9f 91       	pop	r25
    107c:	8f 91       	pop	r24
    107e:	7f 91       	pop	r23
    1080:	6f 91       	pop	r22
    1082:	5f 91       	pop	r21
    1084:	4f 91       	pop	r20
    1086:	3f 91       	pop	r19
    1088:	2f 91       	pop	r18
    108a:	0f 90       	pop	r0
    108c:	0f be       	out	0x3f, r0	; 63
    108e:	0f 90       	pop	r0
    1090:	1f 90       	pop	r1
    1092:	18 95       	reti

00001094 <UI_LEDs>:
#define STATUS_SDErr	0x02
#define STATUS_CAM0Err	0x04
#define STATUS_CAM1Err	0x08
#define STATUS_Exit		0x80
unsigned char UI_LEDs(uint8_t LED)
{
    1094:	cf 93       	push	r28
    1096:	df 93       	push	r29
    1098:	00 d0       	rcall	.+0      	; 0x109a <UI_LEDs+0x6>
    109a:	00 d0       	rcall	.+0      	; 0x109c <UI_LEDs+0x8>
    109c:	cd b7       	in	r28, 0x3d	; 61
    109e:	de b7       	in	r29, 0x3e	; 62
	unsigned char mesbuf[TWI_BUFFER_SIZE];
	mesbuf[0] = (0x15 << TWI_ADR_BITS) | (FALSE << TWI_READ_BIT);
    10a0:	9a e2       	ldi	r25, 0x2A	; 42
    10a2:	99 83       	std	Y+1, r25	; 0x01
	mesbuf[1] = 0x10;
    10a4:	90 e1       	ldi	r25, 0x10	; 16
    10a6:	9a 83       	std	Y+2, r25	; 0x02
	mesbuf[2] = LED;
    10a8:	8b 83       	std	Y+3, r24	; 0x03
	TWI_Start_Transceiver_With_Data(mesbuf, 3);
    10aa:	ce 01       	movw	r24, r28
    10ac:	01 96       	adiw	r24, 0x01	; 1
    10ae:	63 e0       	ldi	r22, 0x03	; 3
    10b0:	0e 94 0d 2a 	call	0x541a	; 0x541a <TWI_Start_Transceiver_With_Data>
	while(TWI_Transceiver_Busy())	;
    10b4:	0e 94 02 2a 	call	0x5404	; 0x5404 <TWI_Transceiver_Busy>
    10b8:	88 23       	and	r24, r24
    10ba:	e1 f7       	brne	.-8      	; 0x10b4 <UI_LEDs+0x20>
	return TWI_statusReg.lastTransOK;
    10bc:	80 91 f8 03 	lds	r24, 0x03F8
}
    10c0:	81 70       	andi	r24, 0x01	; 1
    10c2:	0f 90       	pop	r0
    10c4:	0f 90       	pop	r0
    10c6:	0f 90       	pop	r0
    10c8:	0f 90       	pop	r0
    10ca:	df 91       	pop	r29
    10cc:	cf 91       	pop	r28
    10ce:	08 95       	ret

000010d0 <main>:
int main(void)
{
    10d0:	2f 92       	push	r2
    10d2:	3f 92       	push	r3
    10d4:	4f 92       	push	r4
    10d6:	5f 92       	push	r5
    10d8:	6f 92       	push	r6
    10da:	7f 92       	push	r7
    10dc:	8f 92       	push	r8
    10de:	9f 92       	push	r9
    10e0:	af 92       	push	r10
    10e2:	bf 92       	push	r11
    10e4:	cf 92       	push	r12
    10e6:	df 92       	push	r13
    10e8:	ef 92       	push	r14
    10ea:	ff 92       	push	r15
    10ec:	0f 93       	push	r16
    10ee:	1f 93       	push	r17
    10f0:	cf 93       	push	r28
    10f2:	df 93       	push	r29
    10f4:	00 d0       	rcall	.+0      	; 0x10f6 <main+0x26>
    10f6:	00 d0       	rcall	.+0      	; 0x10f8 <main+0x28>
    10f8:	cd b7       	in	r28, 0x3d	; 61
    10fa:	de b7       	in	r29, 0x3e	; 62
	unsigned long int a = 0;
    10fc:	19 82       	std	Y+1, r1	; 0x01
    10fe:	1a 82       	std	Y+2, r1	; 0x02
    1100:	1b 82       	std	Y+3, r1	; 0x03
    1102:	1c 82       	std	Y+4, r1	; 0x04
	uint8_t b = 0;
	FRESULT fr;
	
	//USART0_Init();
	
	sei();
    1104:	78 94       	sei
	TWI_Master_Initialise();
    1106:	0e 94 f8 29 	call	0x53f0	; 0x53f0 <TWI_Master_Initialise>
	
	UI_LEDs(STATUS_OKAY);
    110a:	81 e0       	ldi	r24, 0x01	; 1
    110c:	0e 94 4a 08 	call	0x1094	; 0x1094 <UI_LEDs>
	
	fr = f_mount(0, &Fatfs[0]);
    1110:	80 e0       	ldi	r24, 0x00	; 0
    1112:	61 e4       	ldi	r22, 0x41	; 65
    1114:	7c e0       	ldi	r23, 0x0C	; 12
    1116:	0e 94 15 1a 	call	0x342a	; 0x342a <f_mount>
	if(fr != FR_OK)
    111a:	88 23       	and	r24, r24
    111c:	21 f0       	breq	.+8      	; 0x1126 <__stack+0x27>
	{
		UI_LEDs(STATUS_SDErr|STATUS_Exit);
    111e:	82 e8       	ldi	r24, 0x82	; 130
    1120:	0e 94 4a 08 	call	0x1094	; 0x1094 <UI_LEDs>
		return 0;
    1124:	5d c1       	rjmp	.+698    	; 0x13e0 <__stack+0x2e1>
	}
	fr = f_open(&Files[0], "/log.txt", FA_WRITE|FA_CREATE_ALWAYS);
    1126:	80 e0       	ldi	r24, 0x00	; 0
    1128:	94 e0       	ldi	r25, 0x04	; 4
    112a:	65 ee       	ldi	r22, 0xE5	; 229
    112c:	72 e0       	ldi	r23, 0x02	; 2
    112e:	4a e0       	ldi	r20, 0x0A	; 10
    1130:	0e 94 2b 1a 	call	0x3456	; 0x3456 <f_open>
	if(fr != FR_OK)
    1134:	88 23       	and	r24, r24
    1136:	21 f0       	breq	.+8      	; 0x1140 <__stack+0x41>
	{
		UI_LEDs(STATUS_SDErr|STATUS_Exit);
    1138:	82 e8       	ldi	r24, 0x82	; 130
    113a:	0e 94 4a 08 	call	0x1094	; 0x1094 <UI_LEDs>
		return 0;
    113e:	50 c1       	rjmp	.+672    	; 0x13e0 <__stack+0x2e1>
	}		
// 	f_lseek(&Files[0], 100);
// 	f_lseek(&Files[0], 0);
	f_close(&Files[0]);
    1140:	0f 2e       	mov	r0, r31
    1142:	f0 e0       	ldi	r31, 0x00	; 0
    1144:	ef 2e       	mov	r14, r31
    1146:	f4 e0       	ldi	r31, 0x04	; 4
    1148:	ff 2e       	mov	r15, r31
    114a:	f0 2d       	mov	r31, r0
    114c:	c7 01       	movw	r24, r14
    114e:	0e 94 3a 20 	call	0x4074	; 0x4074 <f_close>
	f_open(&Files[0], "/log.txt", FA_WRITE);
    1152:	0f 2e       	mov	r0, r31
    1154:	f5 ee       	ldi	r31, 0xE5	; 229
    1156:	cf 2e       	mov	r12, r31
    1158:	f2 e0       	ldi	r31, 0x02	; 2
    115a:	df 2e       	mov	r13, r31
    115c:	f0 2d       	mov	r31, r0
    115e:	c7 01       	movw	r24, r14
    1160:	b6 01       	movw	r22, r12
    1162:	42 e0       	ldi	r20, 0x02	; 2
    1164:	0e 94 2b 1a 	call	0x3456	; 0x3456 <f_open>
	//stdout = &mystdout;
	b = MCUSR;
    1168:	84 b7       	in	r24, 0x34	; 52
	MCUSR = 0;
    116a:	14 be       	out	0x34, r1	; 52
	f_write(&Files[0],"Il Matto Dual Camera\n", sizeof("Il Matto Dual Camera\n"), &a);
    116c:	c7 01       	movw	r24, r14
    116e:	6e ee       	ldi	r22, 0xEE	; 238
    1170:	72 e0       	ldi	r23, 0x02	; 2
    1172:	26 e1       	ldi	r18, 0x16	; 22
    1174:	30 e0       	ldi	r19, 0x00	; 0
    1176:	40 e0       	ldi	r20, 0x00	; 0
    1178:	50 e0       	ldi	r21, 0x00	; 0
    117a:	8e 01       	movw	r16, r28
    117c:	0f 5f       	subi	r16, 0xFF	; 255
    117e:	1f 4f       	sbci	r17, 0xFF	; 255
    1180:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <f_write>
	f_close(&Files[0]);
    1184:	c7 01       	movw	r24, r14
    1186:	0e 94 3a 20 	call	0x4074	; 0x4074 <f_close>
	
	//printf("Initialising IO\n");
	IO_Init();
    118a:	0e 94 a4 00 	call	0x148	; 0x148 <IO_Init>
	//printf("Initialising TWI\n");
	
	//printf("Disk Initialise : %d\n", f_mount(0, &Fatfs[0]));
	f_mount(0, &Fatfs[0]);
    118e:	80 e0       	ldi	r24, 0x00	; 0
    1190:	61 e4       	ldi	r22, 0x41	; 65
    1192:	7c e0       	ldi	r23, 0x0C	; 12
    1194:	0e 94 15 1a 	call	0x342a	; 0x342a <f_mount>
	fr = f_open(&Files[0], "/log.txt", FA_WRITE | FA_CREATE_ALWAYS);
    1198:	c7 01       	movw	r24, r14
    119a:	b6 01       	movw	r22, r12
    119c:	4a e0       	ldi	r20, 0x0A	; 10
    119e:	0e 94 2b 1a 	call	0x3456	; 0x3456 <f_open>
	//printf("Open File : %d\n", fr);
	if (fr != FR_OK)
    11a2:	88 23       	and	r24, r24
    11a4:	09 f0       	breq	.+2      	; 0x11a8 <__stack+0xa9>
    11a6:	1c c1       	rjmp	.+568    	; 0x13e0 <__stack+0x2e1>
		return 0;
	f_write(&Files[0], "System Startup Complete.\n", 26, &a);
    11a8:	67 01       	movw	r12, r14
    11aa:	c7 01       	movw	r24, r14
    11ac:	64 e0       	ldi	r22, 0x04	; 4
    11ae:	73 e0       	ldi	r23, 0x03	; 3
    11b0:	2a e1       	ldi	r18, 0x1A	; 26
    11b2:	30 e0       	ldi	r19, 0x00	; 0
    11b4:	40 e0       	ldi	r20, 0x00	; 0
    11b6:	50 e0       	ldi	r21, 0x00	; 0
    11b8:	8e 01       	movw	r16, r28
    11ba:	0f 5f       	subi	r16, 0xFF	; 255
    11bc:	1f 4f       	sbci	r17, 0xFF	; 255
    11be:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <f_write>
	

	b = OV7670_init();
    11c2:	0e 94 21 06 	call	0xc42	; 0xc42 <OV7670_init>
	//printf("OV7670_1 Initialise result : %d\n", b);
	sprintf(Buff, "OV7670_1 Initialise result : %d\n", b);
    11c6:	00 d0       	rcall	.+0      	; 0x11c8 <__stack+0xc9>
    11c8:	00 d0       	rcall	.+0      	; 0x11ca <__stack+0xcb>
    11ca:	00 d0       	rcall	.+0      	; 0x11cc <__stack+0xcd>
    11cc:	ed b7       	in	r30, 0x3d	; 61
    11ce:	fe b7       	in	r31, 0x3e	; 62
    11d0:	31 96       	adiw	r30, 0x01	; 1
    11d2:	0f 2e       	mov	r0, r31
    11d4:	f0 e4       	ldi	r31, 0x40	; 64
    11d6:	ef 2e       	mov	r14, r31
    11d8:	f8 e0       	ldi	r31, 0x08	; 8
    11da:	ff 2e       	mov	r15, r31
    11dc:	f0 2d       	mov	r31, r0
    11de:	ad b7       	in	r26, 0x3d	; 61
    11e0:	be b7       	in	r27, 0x3e	; 62
    11e2:	12 96       	adiw	r26, 0x02	; 2
    11e4:	fc 92       	st	X, r15
    11e6:	ee 92       	st	-X, r14
    11e8:	11 97       	sbiw	r26, 0x01	; 1
    11ea:	2e e1       	ldi	r18, 0x1E	; 30
    11ec:	33 e0       	ldi	r19, 0x03	; 3
    11ee:	33 83       	std	Z+3, r19	; 0x03
    11f0:	22 83       	std	Z+2, r18	; 0x02
    11f2:	84 83       	std	Z+4, r24	; 0x04
    11f4:	15 82       	std	Z+5, r1	; 0x05
    11f6:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <sprintf>
	f_write(&Files[0], &Buff, sizeof(Buff), &a);
    11fa:	8d b7       	in	r24, 0x3d	; 61
    11fc:	9e b7       	in	r25, 0x3e	; 62
    11fe:	06 96       	adiw	r24, 0x06	; 6
    1200:	0f b6       	in	r0, 0x3f	; 63
    1202:	f8 94       	cli
    1204:	9e bf       	out	0x3e, r25	; 62
    1206:	0f be       	out	0x3f, r0	; 63
    1208:	8d bf       	out	0x3d, r24	; 61
    120a:	c6 01       	movw	r24, r12
    120c:	b7 01       	movw	r22, r14
    120e:	20 e0       	ldi	r18, 0x00	; 0
    1210:	34 e0       	ldi	r19, 0x04	; 4
    1212:	40 e0       	ldi	r20, 0x00	; 0
    1214:	50 e0       	ldi	r21, 0x00	; 0
    1216:	8e 01       	movw	r16, r28
    1218:	0f 5f       	subi	r16, 0xFF	; 255
    121a:	1f 4f       	sbci	r17, 0xFF	; 255
    121c:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <f_write>
	InitSCCB();
    1220:	0e 94 35 29 	call	0x526a	; 0x526a <InitSCCB>
	b = OV7670_SCCB_init();
    1224:	0e 94 fa 07 	call	0xff4	; 0xff4 <OV7670_SCCB_init>
    1228:	a8 2e       	mov	r10, r24
	printf("OV7670_0 Initialise result : %d\n", b);
    122a:	00 d0       	rcall	.+0      	; 0x122c <__stack+0x12d>
    122c:	00 d0       	rcall	.+0      	; 0x122e <__stack+0x12f>
    122e:	ed b7       	in	r30, 0x3d	; 61
    1230:	fe b7       	in	r31, 0x3e	; 62
    1232:	31 96       	adiw	r30, 0x01	; 1
    1234:	0f e3       	ldi	r16, 0x3F	; 63
    1236:	13 e0       	ldi	r17, 0x03	; 3
    1238:	ad b7       	in	r26, 0x3d	; 61
    123a:	be b7       	in	r27, 0x3e	; 62
    123c:	12 96       	adiw	r26, 0x02	; 2
    123e:	1c 93       	st	X, r17
    1240:	0e 93       	st	-X, r16
    1242:	11 97       	sbiw	r26, 0x01	; 1
    1244:	82 83       	std	Z+2, r24	; 0x02
    1246:	13 82       	std	Z+3, r1	; 0x03
    1248:	0e 94 99 2b 	call	0x5732	; 0x5732 <printf>
	sprintf(Buff, "OV7670_0 Initialise result : %d\n", b);
    124c:	00 d0       	rcall	.+0      	; 0x124e <__stack+0x14f>
    124e:	ed b7       	in	r30, 0x3d	; 61
    1250:	fe b7       	in	r31, 0x3e	; 62
    1252:	31 96       	adiw	r30, 0x01	; 1
    1254:	ad b7       	in	r26, 0x3d	; 61
    1256:	be b7       	in	r27, 0x3e	; 62
    1258:	12 96       	adiw	r26, 0x02	; 2
    125a:	fc 92       	st	X, r15
    125c:	ee 92       	st	-X, r14
    125e:	11 97       	sbiw	r26, 0x01	; 1
    1260:	13 83       	std	Z+3, r17	; 0x03
    1262:	02 83       	std	Z+2, r16	; 0x02
    1264:	a4 82       	std	Z+4, r10	; 0x04
    1266:	15 82       	std	Z+5, r1	; 0x05
    1268:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <sprintf>
	f_write(&Files[0], &Buff, sizeof(Buff), &a);
    126c:	8d b7       	in	r24, 0x3d	; 61
    126e:	9e b7       	in	r25, 0x3e	; 62
    1270:	06 96       	adiw	r24, 0x06	; 6
    1272:	0f b6       	in	r0, 0x3f	; 63
    1274:	f8 94       	cli
    1276:	9e bf       	out	0x3e, r25	; 62
    1278:	0f be       	out	0x3f, r0	; 63
    127a:	8d bf       	out	0x3d, r24	; 61
    127c:	c6 01       	movw	r24, r12
    127e:	b7 01       	movw	r22, r14
    1280:	20 e0       	ldi	r18, 0x00	; 0
    1282:	34 e0       	ldi	r19, 0x04	; 4
    1284:	40 e0       	ldi	r20, 0x00	; 0
    1286:	50 e0       	ldi	r21, 0x00	; 0
    1288:	8e 01       	movw	r16, r28
    128a:	0f 5f       	subi	r16, 0xFF	; 255
    128c:	1f 4f       	sbci	r17, 0xFF	; 255
    128e:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <f_write>
	FIFO_init();
    1292:	0e 94 51 06 	call	0xca2	; 0xca2 <FIFO_init>
	f_close(&Files[0]);
    1296:	c6 01       	movw	r24, r12
    1298:	0e 94 3a 20 	call	0x4074	; 0x4074 <f_close>
				printf("Image 1 Taken Successfully!\n");
				break;
			
			case 'P':
				LoadImagesToBuffer();
				while (2 == GetImageIfAvailiable(&Files[0], 1)) ;
    129c:	86 01       	movw	r16, r12
    while(1)
    {
		switch(Usart_Receive())
		{
			case '0':
				f_open(&Files[0], "/image0.bmp", FA_CREATE_ALWAYS | FA_WRITE);
    129e:	0f 2e       	mov	r0, r31
    12a0:	f0 e6       	ldi	r31, 0x60	; 96
    12a2:	ef 2e       	mov	r14, r31
    12a4:	f3 e0       	ldi	r31, 0x03	; 3
    12a6:	ff 2e       	mov	r15, r31
    12a8:	f0 2d       	mov	r31, r0
				printf("Made File\n");
    12aa:	0f 2e       	mov	r0, r31
    12ac:	fc e6       	ldi	r31, 0x6C	; 108
    12ae:	cf 2e       	mov	r12, r31
    12b0:	f3 e0       	ldi	r31, 0x03	; 3
    12b2:	df 2e       	mov	r13, r31
    12b4:	f0 2d       	mov	r31, r0
				f_lseek(&Files[0], BMPFileSize);
				f_lseek(&Files[0], 0);
				f_close(&Files[0]);
				printf("Closed File\n");
    12b6:	0f 2e       	mov	r0, r31
    12b8:	f6 e7       	ldi	r31, 0x76	; 118
    12ba:	af 2e       	mov	r10, r31
    12bc:	f3 e0       	ldi	r31, 0x03	; 3
    12be:	bf 2e       	mov	r11, r31
    12c0:	f0 2d       	mov	r31, r0
				f_open(&Files[0], "/image0.bmp", FA_WRITE);
				printf("Opened File\n");
    12c2:	0f 2e       	mov	r0, r31
    12c4:	f2 e8       	ldi	r31, 0x82	; 130
    12c6:	8f 2e       	mov	r8, r31
    12c8:	f3 e0       	ldi	r31, 0x03	; 3
    12ca:	9f 2e       	mov	r9, r31
    12cc:	f0 2d       	mov	r31, r0
				LoadImagesToBuffer();
				printf("Loaded Images\n");
    12ce:	0f 2e       	mov	r0, r31
    12d0:	fe e8       	ldi	r31, 0x8E	; 142
    12d2:	6f 2e       	mov	r6, r31
    12d4:	f3 e0       	ldi	r31, 0x03	; 3
    12d6:	7f 2e       	mov	r7, r31
    12d8:	f0 2d       	mov	r31, r0
				while (2 == GetImageIfAvailiable(&Files[0], 0)) ;
				printf("Image 0 Taken Successfully!\n");
    12da:	0f 2e       	mov	r0, r31
    12dc:	fc e9       	ldi	r31, 0x9C	; 156
    12de:	2f 2e       	mov	r2, r31
    12e0:	f3 e0       	ldi	r31, 0x03	; 3
    12e2:	3f 2e       	mov	r3, r31
    12e4:	f0 2d       	mov	r31, r0
				break;
				
			case '1':
				f_open(&Files[0], "/image1.bmp", FA_CREATE_ALWAYS | FA_WRITE);
    12e6:	0f 2e       	mov	r0, r31
    12e8:	f8 eb       	ldi	r31, 0xB8	; 184
    12ea:	4f 2e       	mov	r4, r31
    12ec:	f3 e0       	ldi	r31, 0x03	; 3
    12ee:	5f 2e       	mov	r5, r31
    12f0:	f0 2d       	mov	r31, r0
// 	printf("Image 1 Taken Successfully!\n");
// 	while(1);
	
    while(1)
    {
		switch(Usart_Receive())
    12f2:	0e 94 04 2b 	call	0x5608	; 0x5608 <Usart_Receive>
    12f6:	81 33       	cpi	r24, 0x31	; 49
    12f8:	b9 f1       	breq	.+110    	; 0x1368 <__stack+0x269>
    12fa:	80 35       	cpi	r24, 0x50	; 80
    12fc:	09 f4       	brne	.+2      	; 0x1300 <__stack+0x201>
    12fe:	67 c0       	rjmp	.+206    	; 0x13ce <__stack+0x2cf>
    1300:	80 33       	cpi	r24, 0x30	; 48
    1302:	b9 f7       	brne	.-18     	; 0x12f2 <__stack+0x1f3>
		{
			case '0':
				f_open(&Files[0], "/image0.bmp", FA_CREATE_ALWAYS | FA_WRITE);
    1304:	c8 01       	movw	r24, r16
    1306:	b7 01       	movw	r22, r14
    1308:	4a e0       	ldi	r20, 0x0A	; 10
    130a:	0e 94 2b 1a 	call	0x3456	; 0x3456 <f_open>
				printf("Made File\n");
    130e:	c6 01       	movw	r24, r12
    1310:	0e 94 ae 2b 	call	0x575c	; 0x575c <puts>
				f_lseek(&Files[0], BMPFileSize);
    1314:	c8 01       	movw	r24, r16
    1316:	4a e8       	ldi	r20, 0x8A	; 138
    1318:	58 e5       	ldi	r21, 0x58	; 88
    131a:	62 e0       	ldi	r22, 0x02	; 2
    131c:	70 e0       	ldi	r23, 0x00	; 0
    131e:	0e 94 a6 20 	call	0x414c	; 0x414c <f_lseek>
				f_lseek(&Files[0], 0);
    1322:	c8 01       	movw	r24, r16
    1324:	40 e0       	ldi	r20, 0x00	; 0
    1326:	50 e0       	ldi	r21, 0x00	; 0
    1328:	ba 01       	movw	r22, r20
    132a:	0e 94 a6 20 	call	0x414c	; 0x414c <f_lseek>
				f_close(&Files[0]);
    132e:	c8 01       	movw	r24, r16
    1330:	0e 94 3a 20 	call	0x4074	; 0x4074 <f_close>
				printf("Closed File\n");
    1334:	c5 01       	movw	r24, r10
    1336:	0e 94 ae 2b 	call	0x575c	; 0x575c <puts>
				f_open(&Files[0], "/image0.bmp", FA_WRITE);
    133a:	c8 01       	movw	r24, r16
    133c:	b7 01       	movw	r22, r14
    133e:	42 e0       	ldi	r20, 0x02	; 2
    1340:	0e 94 2b 1a 	call	0x3456	; 0x3456 <f_open>
				printf("Opened File\n");
    1344:	c4 01       	movw	r24, r8
    1346:	0e 94 ae 2b 	call	0x575c	; 0x575c <puts>
				LoadImagesToBuffer();
    134a:	0e 94 b3 06 	call	0xd66	; 0xd66 <LoadImagesToBuffer>
				printf("Loaded Images\n");
    134e:	c3 01       	movw	r24, r6
    1350:	0e 94 ae 2b 	call	0x575c	; 0x575c <puts>
				while (2 == GetImageIfAvailiable(&Files[0], 0)) ;
    1354:	c8 01       	movw	r24, r16
    1356:	60 e0       	ldi	r22, 0x00	; 0
    1358:	0e 94 c3 06 	call	0xd86	; 0xd86 <GetImageIfAvailiable>
    135c:	82 30       	cpi	r24, 0x02	; 2
    135e:	d1 f3       	breq	.-12     	; 0x1354 <__stack+0x255>
				printf("Image 0 Taken Successfully!\n");
    1360:	c1 01       	movw	r24, r2
    1362:	0e 94 ae 2b 	call	0x575c	; 0x575c <puts>
				break;
    1366:	c5 cf       	rjmp	.-118    	; 0x12f2 <__stack+0x1f3>
				
			case '1':
				f_open(&Files[0], "/image1.bmp", FA_CREATE_ALWAYS | FA_WRITE);
    1368:	c8 01       	movw	r24, r16
    136a:	b2 01       	movw	r22, r4
    136c:	4a e0       	ldi	r20, 0x0A	; 10
    136e:	0e 94 2b 1a 	call	0x3456	; 0x3456 <f_open>
				printf("Made File\n");
    1372:	c6 01       	movw	r24, r12
    1374:	0e 94 ae 2b 	call	0x575c	; 0x575c <puts>
				f_lseek(&Files[0], BMPFileSize);
    1378:	c8 01       	movw	r24, r16
    137a:	4a e8       	ldi	r20, 0x8A	; 138
    137c:	58 e5       	ldi	r21, 0x58	; 88
    137e:	62 e0       	ldi	r22, 0x02	; 2
    1380:	70 e0       	ldi	r23, 0x00	; 0
    1382:	0e 94 a6 20 	call	0x414c	; 0x414c <f_lseek>
				f_lseek(&Files[0], 0);
    1386:	c8 01       	movw	r24, r16
    1388:	40 e0       	ldi	r20, 0x00	; 0
    138a:	50 e0       	ldi	r21, 0x00	; 0
    138c:	ba 01       	movw	r22, r20
    138e:	0e 94 a6 20 	call	0x414c	; 0x414c <f_lseek>
				f_close(&Files[0]);
    1392:	c8 01       	movw	r24, r16
    1394:	0e 94 3a 20 	call	0x4074	; 0x4074 <f_close>
				printf("Closed File\n");
    1398:	c5 01       	movw	r24, r10
    139a:	0e 94 ae 2b 	call	0x575c	; 0x575c <puts>
				f_open(&Files[0], "/image1.bmp", FA_WRITE);
    139e:	c8 01       	movw	r24, r16
    13a0:	b2 01       	movw	r22, r4
    13a2:	42 e0       	ldi	r20, 0x02	; 2
    13a4:	0e 94 2b 1a 	call	0x3456	; 0x3456 <f_open>
				printf("Opened File\n");
    13a8:	c4 01       	movw	r24, r8
    13aa:	0e 94 ae 2b 	call	0x575c	; 0x575c <puts>
				LoadImagesToBuffer();
    13ae:	0e 94 b3 06 	call	0xd66	; 0xd66 <LoadImagesToBuffer>
				printf("Loaded Images\n");
    13b2:	c3 01       	movw	r24, r6
    13b4:	0e 94 ae 2b 	call	0x575c	; 0x575c <puts>
				while (2 == GetImageIfAvailiable(&Files[0], 1)) ;
    13b8:	c8 01       	movw	r24, r16
    13ba:	61 e0       	ldi	r22, 0x01	; 1
    13bc:	0e 94 c3 06 	call	0xd86	; 0xd86 <GetImageIfAvailiable>
    13c0:	82 30       	cpi	r24, 0x02	; 2
    13c2:	d1 f3       	breq	.-12     	; 0x13b8 <__stack+0x2b9>
				printf("Image 1 Taken Successfully!\n");
    13c4:	84 ec       	ldi	r24, 0xC4	; 196
    13c6:	93 e0       	ldi	r25, 0x03	; 3
    13c8:	0e 94 ae 2b 	call	0x575c	; 0x575c <puts>
				break;
    13cc:	92 cf       	rjmp	.-220    	; 0x12f2 <__stack+0x1f3>
			
			case 'P':
				LoadImagesToBuffer();
    13ce:	0e 94 b3 06 	call	0xd66	; 0xd66 <LoadImagesToBuffer>
				while (2 == GetImageIfAvailiable(&Files[0], 1)) ;
    13d2:	c8 01       	movw	r24, r16
    13d4:	61 e0       	ldi	r22, 0x01	; 1
    13d6:	0e 94 c3 06 	call	0xd86	; 0xd86 <GetImageIfAvailiable>
    13da:	82 30       	cpi	r24, 0x02	; 2
    13dc:	d1 f3       	breq	.-12     	; 0x13d2 <__stack+0x2d3>
    13de:	89 cf       	rjmp	.-238    	; 0x12f2 <__stack+0x1f3>
				break;

			
		}			
    }
    13e0:	80 e0       	ldi	r24, 0x00	; 0
    13e2:	90 e0       	ldi	r25, 0x00	; 0
    13e4:	0f 90       	pop	r0
    13e6:	0f 90       	pop	r0
    13e8:	0f 90       	pop	r0
    13ea:	0f 90       	pop	r0
    13ec:	df 91       	pop	r29
    13ee:	cf 91       	pop	r28
    13f0:	1f 91       	pop	r17
    13f2:	0f 91       	pop	r16
    13f4:	ff 90       	pop	r15
    13f6:	ef 90       	pop	r14
    13f8:	df 90       	pop	r13
    13fa:	cf 90       	pop	r12
    13fc:	bf 90       	pop	r11
    13fe:	af 90       	pop	r10
    1400:	9f 90       	pop	r9
    1402:	8f 90       	pop	r8
    1404:	7f 90       	pop	r7
    1406:	6f 90       	pop	r6
    1408:	5f 90       	pop	r5
    140a:	4f 90       	pop	r4
    140c:	3f 90       	pop	r3
    140e:	2f 90       	pop	r2
    1410:	08 95       	ret

00001412 <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
    1412:	e6 2f       	mov	r30, r22
    1414:	f7 2f       	mov	r31, r23
    1416:	ba 01       	movw	r22, r20
    1418:	a9 01       	movw	r20, r18
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
    141a:	41 15       	cp	r20, r1
    141c:	51 05       	cpc	r21, r1
    141e:	61 05       	cpc	r22, r1
    1420:	71 05       	cpc	r23, r1
    1422:	59 f0       	breq	.+22     	; 0x143a <mem_cpy+0x28>
    1424:	ae 2f       	mov	r26, r30
    1426:	bf 2f       	mov	r27, r31
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    1428:	e8 2f       	mov	r30, r24
    142a:	f9 2f       	mov	r31, r25
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
    142c:	8d 91       	ld	r24, X+
    142e:	81 93       	st	Z+, r24
    1430:	41 50       	subi	r20, 0x01	; 1
    1432:	50 40       	sbci	r21, 0x00	; 0
    1434:	60 40       	sbci	r22, 0x00	; 0
    1436:	70 40       	sbci	r23, 0x00	; 0
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
    1438:	c9 f7       	brne	.-14     	; 0x142c <mem_cpy+0x1a>
    143a:	08 95       	ret

0000143c <mem_set>:
		*d++ = *s++;
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
    143c:	a6 2f       	mov	r26, r22
    143e:	ba 01       	movw	r22, r20
    1440:	a9 01       	movw	r20, r18
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    1442:	41 15       	cp	r20, r1
    1444:	51 05       	cpc	r21, r1
    1446:	61 05       	cpc	r22, r1
    1448:	71 05       	cpc	r23, r1
    144a:	41 f0       	breq	.+16     	; 0x145c <mem_set+0x20>
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    144c:	e8 2f       	mov	r30, r24
    144e:	f9 2f       	mov	r31, r25

	while (cnt--)
		*d++ = (BYTE)val;
    1450:	a1 93       	st	Z+, r26
    1452:	41 50       	subi	r20, 0x01	; 1
    1454:	50 40       	sbci	r21, 0x00	; 0
    1456:	60 40       	sbci	r22, 0x00	; 0
    1458:	70 40       	sbci	r23, 0x00	; 0
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    145a:	d1 f7       	brne	.-12     	; 0x1450 <mem_set+0x14>
    145c:	08 95       	ret

0000145e <ld_clust>:
static
DWORD ld_clust (
	FATFS *fs,	/* Pointer to the fs object */
	BYTE *dir	/* Pointer to the directory entry */
)
{
    145e:	0f 93       	push	r16
    1460:	1f 93       	push	r17
    1462:	dc 01       	movw	r26, r24
    1464:	fb 01       	movw	r30, r22
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
    1466:	93 8d       	ldd	r25, Z+27	; 0x1b
    1468:	80 e0       	ldi	r24, 0x00	; 0
    146a:	02 8d       	ldd	r16, Z+26	; 0x1a
    146c:	10 e0       	ldi	r17, 0x00	; 0
    146e:	08 2b       	or	r16, r24
    1470:	19 2b       	or	r17, r25
    1472:	20 e0       	ldi	r18, 0x00	; 0
    1474:	30 e0       	ldi	r19, 0x00	; 0
	if (fs->fs_type == FS_FAT32)
    1476:	8c 91       	ld	r24, X
    1478:	83 30       	cpi	r24, 0x03	; 3
    147a:	79 f4       	brne	.+30     	; 0x149a <ld_clust+0x3c>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
    147c:	55 89       	ldd	r21, Z+21	; 0x15
    147e:	40 e0       	ldi	r20, 0x00	; 0
    1480:	84 89       	ldd	r24, Z+20	; 0x14
    1482:	90 e0       	ldi	r25, 0x00	; 0
    1484:	84 2b       	or	r24, r20
    1486:	95 2b       	or	r25, r21
    1488:	a0 e0       	ldi	r26, 0x00	; 0
    148a:	b0 e0       	ldi	r27, 0x00	; 0
    148c:	dc 01       	movw	r26, r24
    148e:	99 27       	eor	r25, r25
    1490:	88 27       	eor	r24, r24
    1492:	08 2b       	or	r16, r24
    1494:	19 2b       	or	r17, r25
    1496:	2a 2b       	or	r18, r26
    1498:	3b 2b       	or	r19, r27

	return cl;
}
    149a:	60 2f       	mov	r22, r16
    149c:	71 2f       	mov	r23, r17
    149e:	82 2f       	mov	r24, r18
    14a0:	93 2f       	mov	r25, r19
    14a2:	1f 91       	pop	r17
    14a4:	0f 91       	pop	r16
    14a6:	08 95       	ret

000014a8 <st_clust>:
static
void st_clust (
	BYTE *dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
    14a8:	fc 01       	movw	r30, r24
	ST_WORD(dir+DIR_FstClusLO, cl);
    14aa:	42 8f       	std	Z+26, r20	; 0x1a
    14ac:	53 8f       	std	Z+27, r21	; 0x1b
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
    14ae:	ab 01       	movw	r20, r22
    14b0:	66 27       	eor	r22, r22
    14b2:	77 27       	eor	r23, r23
    14b4:	44 8b       	std	Z+20, r20	; 0x14
    14b6:	55 8b       	std	Z+21, r21	; 0x15
}
    14b8:	08 95       	ret

000014ba <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to the file information to be filled */
)
{
    14ba:	ef 92       	push	r14
    14bc:	ff 92       	push	r15
    14be:	0f 93       	push	r16
    14c0:	1f 93       	push	r17
    14c2:	cf 93       	push	r28
    14c4:	df 93       	push	r29
    14c6:	fc 01       	movw	r30, r24
    14c8:	7b 01       	movw	r14, r22
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
    14ca:	8b 01       	movw	r16, r22
    14cc:	07 5f       	subi	r16, 0xF7	; 247
    14ce:	1f 4f       	sbci	r17, 0xFF	; 255
	if (dj->sect) {
    14d0:	86 85       	ldd	r24, Z+14	; 0x0e
    14d2:	97 85       	ldd	r25, Z+15	; 0x0f
    14d4:	a0 89       	ldd	r26, Z+16	; 0x10
    14d6:	b1 89       	ldd	r27, Z+17	; 0x11
    14d8:	00 97       	sbiw	r24, 0x00	; 0
    14da:	a1 05       	cpc	r26, r1
    14dc:	b1 05       	cpc	r27, r1
    14de:	09 f4       	brne	.+2      	; 0x14e2 <get_fileinfo+0x28>
    14e0:	65 c0       	rjmp	.+202    	; 0x15ac <get_fileinfo+0xf2>
		dir = dj->dir;
    14e2:	c2 89       	ldd	r28, Z+18	; 0x12
    14e4:	d3 89       	ldd	r29, Z+19	; 0x13
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
    14e6:	28 81       	ld	r18, Y
			if (c == ' ') break;
    14e8:	20 32       	cpi	r18, 0x20	; 32
    14ea:	99 f0       	breq	.+38     	; 0x1512 <get_fileinfo+0x58>
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
    14ec:	de 01       	movw	r26, r28
    14ee:	11 96       	adiw	r26, 0x01	; 1
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
    14f0:	f8 01       	movw	r30, r16
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
    14f2:	80 e0       	ldi	r24, 0x00	; 0
    14f4:	90 e0       	ldi	r25, 0x00	; 0
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
    14f6:	35 ee       	ldi	r19, 0xE5	; 229
    14f8:	04 c0       	rjmp	.+8      	; 0x1502 <get_fileinfo+0x48>
	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
    14fa:	2d 91       	ld	r18, X+
    14fc:	01 96       	adiw	r24, 0x01	; 1
			if (c == ' ') break;
    14fe:	20 32       	cpi	r18, 0x20	; 32
    1500:	41 f0       	breq	.+16     	; 0x1512 <get_fileinfo+0x58>
			if (c == NDDE) c = (TCHAR)DDE;
    1502:	25 30       	cpi	r18, 0x05	; 5
    1504:	09 f4       	brne	.+2      	; 0x1508 <get_fileinfo+0x4e>
    1506:	23 2f       	mov	r18, r19
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
    1508:	21 93       	st	Z+, r18
    150a:	8f 01       	movw	r16, r30

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
    150c:	87 30       	cpi	r24, 0x07	; 7
    150e:	91 05       	cpc	r25, r1
    1510:	a1 f7       	brne	.-24     	; 0x14fa <get_fileinfo+0x40>
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
    1512:	88 85       	ldd	r24, Y+8	; 0x08
    1514:	80 32       	cpi	r24, 0x20	; 32
    1516:	81 f0       	breq	.+32     	; 0x1538 <get_fileinfo+0x7e>
			*p++ = '.';
    1518:	8e e2       	ldi	r24, 0x2E	; 46
    151a:	f8 01       	movw	r30, r16
    151c:	80 83       	st	Z, r24
			for (i = 8; i < 11; i++) {
				c = dir[i];
    151e:	88 85       	ldd	r24, Y+8	; 0x08
				if (c == ' ') break;
    1520:	80 32       	cpi	r24, 0x20	; 32
    1522:	09 f0       	breq	.+2      	; 0x1526 <get_fileinfo+0x6c>
    1524:	4c c0       	rjmp	.+152    	; 0x15be <get_fileinfo+0x104>
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
    1526:	0f 5f       	subi	r16, 0xFF	; 255
    1528:	1f 4f       	sbci	r17, 0xFF	; 255
    152a:	06 c0       	rjmp	.+12     	; 0x1538 <get_fileinfo+0x7e>
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
    152c:	8c 01       	movw	r16, r24
    152e:	04 c0       	rjmp	.+8      	; 0x1538 <get_fileinfo+0x7e>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    1530:	f8 01       	movw	r30, r16
    1532:	23 83       	std	Z+3, r18	; 0x03
    1534:	0c 5f       	subi	r16, 0xFC	; 252
    1536:	1f 4f       	sbci	r17, 0xFF	; 255
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
    1538:	8b 85       	ldd	r24, Y+11	; 0x0b
    153a:	f7 01       	movw	r30, r14
    153c:	80 87       	std	Z+8, r24	; 0x08
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
    153e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1540:	90 e0       	ldi	r25, 0x00	; 0
    1542:	a0 e0       	ldi	r26, 0x00	; 0
    1544:	b0 e0       	ldi	r27, 0x00	; 0
    1546:	b8 2f       	mov	r27, r24
    1548:	aa 27       	eor	r26, r26
    154a:	99 27       	eor	r25, r25
    154c:	88 27       	eor	r24, r24
    154e:	4e 8d       	ldd	r20, Y+30	; 0x1e
    1550:	50 e0       	ldi	r21, 0x00	; 0
    1552:	60 e0       	ldi	r22, 0x00	; 0
    1554:	70 e0       	ldi	r23, 0x00	; 0
    1556:	ba 01       	movw	r22, r20
    1558:	55 27       	eor	r21, r21
    155a:	44 27       	eor	r20, r20
    155c:	48 2b       	or	r20, r24
    155e:	59 2b       	or	r21, r25
    1560:	6a 2b       	or	r22, r26
    1562:	7b 2b       	or	r23, r27
    1564:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1566:	90 e0       	ldi	r25, 0x00	; 0
    1568:	a0 e0       	ldi	r26, 0x00	; 0
    156a:	b0 e0       	ldi	r27, 0x00	; 0
    156c:	48 2b       	or	r20, r24
    156e:	59 2b       	or	r21, r25
    1570:	6a 2b       	or	r22, r26
    1572:	7b 2b       	or	r23, r27
    1574:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1576:	80 e0       	ldi	r24, 0x00	; 0
    1578:	a0 e0       	ldi	r26, 0x00	; 0
    157a:	b0 e0       	ldi	r27, 0x00	; 0
    157c:	84 2b       	or	r24, r20
    157e:	95 2b       	or	r25, r21
    1580:	a6 2b       	or	r26, r22
    1582:	b7 2b       	or	r27, r23
    1584:	80 83       	st	Z, r24
    1586:	91 83       	std	Z+1, r25	; 0x01
    1588:	a2 83       	std	Z+2, r26	; 0x02
    158a:	b3 83       	std	Z+3, r27	; 0x03
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
    158c:	39 8d       	ldd	r19, Y+25	; 0x19
    158e:	20 e0       	ldi	r18, 0x00	; 0
    1590:	88 8d       	ldd	r24, Y+24	; 0x18
    1592:	90 e0       	ldi	r25, 0x00	; 0
    1594:	82 2b       	or	r24, r18
    1596:	93 2b       	or	r25, r19
    1598:	95 83       	std	Z+5, r25	; 0x05
    159a:	84 83       	std	Z+4, r24	; 0x04
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
    159c:	9f 89       	ldd	r25, Y+23	; 0x17
    159e:	80 e0       	ldi	r24, 0x00	; 0
    15a0:	2e 89       	ldd	r18, Y+22	; 0x16
    15a2:	30 e0       	ldi	r19, 0x00	; 0
    15a4:	82 2b       	or	r24, r18
    15a6:	93 2b       	or	r25, r19
    15a8:	97 83       	std	Z+7, r25	; 0x07
    15aa:	86 83       	std	Z+6, r24	; 0x06
	}
	*p = 0;		/* Terminate SFN str by a \0 */
    15ac:	f8 01       	movw	r30, r16
    15ae:	10 82       	st	Z, r1
			}
		}
		tp[i] = 0;	/* Terminate the LFN str by a \0 */
	}
#endif
}
    15b0:	df 91       	pop	r29
    15b2:	cf 91       	pop	r28
    15b4:	1f 91       	pop	r17
    15b6:	0f 91       	pop	r16
    15b8:	ff 90       	pop	r15
    15ba:	ef 90       	pop	r14
    15bc:	08 95       	ret
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    15be:	f8 01       	movw	r30, r16
    15c0:	81 83       	std	Z+1, r24	; 0x01
    15c2:	c8 01       	movw	r24, r16
    15c4:	02 96       	adiw	r24, 0x02	; 2
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
    15c6:	29 85       	ldd	r18, Y+9	; 0x09
				if (c == ' ') break;
    15c8:	20 32       	cpi	r18, 0x20	; 32
    15ca:	09 f4       	brne	.+2      	; 0x15ce <get_fileinfo+0x114>
    15cc:	af cf       	rjmp	.-162    	; 0x152c <get_fileinfo+0x72>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    15ce:	22 83       	std	Z+2, r18	; 0x02
    15d0:	c8 01       	movw	r24, r16
    15d2:	03 96       	adiw	r24, 0x03	; 3
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
    15d4:	2a 85       	ldd	r18, Y+10	; 0x0a
				if (c == ' ') break;
    15d6:	20 32       	cpi	r18, 0x20	; 32
    15d8:	09 f0       	breq	.+2      	; 0x15dc <get_fileinfo+0x122>
    15da:	aa cf       	rjmp	.-172    	; 0x1530 <get_fileinfo+0x76>
    15dc:	a7 cf       	rjmp	.-178    	; 0x152c <get_fileinfo+0x72>

000015de <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
    15de:	dc 01       	movw	r26, r24
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
    15e0:	ed 91       	ld	r30, X+
    15e2:	fc 91       	ld	r31, X
    15e4:	11 97       	sbiw	r26, 0x01	; 1
    15e6:	30 97       	sbiw	r30, 0x00	; 0
    15e8:	99 f0       	breq	.+38     	; 0x1610 <validate+0x32>
    15ea:	80 81       	ld	r24, Z
    15ec:	88 23       	and	r24, r24
    15ee:	91 f0       	breq	.+36     	; 0x1614 <validate+0x36>
    15f0:	26 81       	ldd	r18, Z+6	; 0x06
    15f2:	37 81       	ldd	r19, Z+7	; 0x07
    15f4:	12 96       	adiw	r26, 0x02	; 2
    15f6:	8d 91       	ld	r24, X+
    15f8:	9c 91       	ld	r25, X
    15fa:	13 97       	sbiw	r26, 0x03	; 3
    15fc:	28 17       	cp	r18, r24
    15fe:	39 07       	cpc	r19, r25
    1600:	59 f4       	brne	.+22     	; 0x1618 <validate+0x3a>
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
    1602:	81 81       	ldd	r24, Z+1	; 0x01
    1604:	0e 94 92 02 	call	0x524	; 0x524 <disk_status>
    1608:	80 ff       	sbrs	r24, 0
    160a:	08 c0       	rjmp	.+16     	; 0x161c <validate+0x3e>
		return FR_NOT_READY;
    160c:	83 e0       	ldi	r24, 0x03	; 3
    160e:	08 95       	ret
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
		return FR_INVALID_OBJECT;
    1610:	89 e0       	ldi	r24, 0x09	; 9
    1612:	08 95       	ret
    1614:	89 e0       	ldi	r24, 0x09	; 9
    1616:	08 95       	ret
    1618:	89 e0       	ldi	r24, 0x09	; 9
    161a:	08 95       	ret
	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
    161c:	80 e0       	ldi	r24, 0x00	; 0
}
    161e:	08 95       	ret

00001620 <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    1620:	0f 93       	push	r16
    1622:	cf 93       	push	r28
    1624:	df 93       	push	r29
    1626:	ec 01       	movw	r28, r24
    1628:	9a 01       	movw	r18, r20
    162a:	ab 01       	movw	r20, r22
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    162c:	bc 01       	movw	r22, r24
    162e:	6e 5c       	subi	r22, 0xCE	; 206
    1630:	7f 4f       	sbci	r23, 0xFF	; 255
    1632:	89 81       	ldd	r24, Y+1	; 0x01
    1634:	01 e0       	ldi	r16, 0x01	; 1
    1636:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    163a:	88 23       	and	r24, r24
    163c:	09 f0       	breq	.+2      	; 0x1640 <check_fs+0x20>
    163e:	83 c0       	rjmp	.+262    	; 0x1746 <check_fs+0x126>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    1640:	fe 01       	movw	r30, r28
    1642:	ef 5c       	subi	r30, 0xCF	; 207
    1644:	fd 4f       	sbci	r31, 0xFD	; 253
    1646:	90 81       	ld	r25, Z
    1648:	80 e0       	ldi	r24, 0x00	; 0
    164a:	fe 01       	movw	r30, r28
    164c:	e0 5d       	subi	r30, 0xD0	; 208
    164e:	fd 4f       	sbci	r31, 0xFD	; 253
    1650:	20 81       	ld	r18, Z
    1652:	30 e0       	ldi	r19, 0x00	; 0
    1654:	82 2b       	or	r24, r18
    1656:	93 2b       	or	r25, r19
    1658:	2a ea       	ldi	r18, 0xAA	; 170
    165a:	85 35       	cpi	r24, 0x55	; 85
    165c:	92 07       	cpc	r25, r18
    165e:	09 f0       	breq	.+2      	; 0x1662 <check_fs+0x42>
    1660:	74 c0       	rjmp	.+232    	; 0x174a <check_fs+0x12a>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    1662:	fe 01       	movw	r30, r28
    1664:	e5 59       	subi	r30, 0x95	; 149
    1666:	ff 4f       	sbci	r31, 0xFF	; 255
    1668:	80 81       	ld	r24, Z
    166a:	90 e0       	ldi	r25, 0x00	; 0
    166c:	a0 e0       	ldi	r26, 0x00	; 0
    166e:	b0 e0       	ldi	r27, 0x00	; 0
    1670:	b8 2f       	mov	r27, r24
    1672:	aa 27       	eor	r26, r26
    1674:	99 27       	eor	r25, r25
    1676:	88 27       	eor	r24, r24
    1678:	fe 01       	movw	r30, r28
    167a:	e6 59       	subi	r30, 0x96	; 150
    167c:	ff 4f       	sbci	r31, 0xFF	; 255
    167e:	40 81       	ld	r20, Z
    1680:	50 e0       	ldi	r21, 0x00	; 0
    1682:	60 e0       	ldi	r22, 0x00	; 0
    1684:	70 e0       	ldi	r23, 0x00	; 0
    1686:	ba 01       	movw	r22, r20
    1688:	55 27       	eor	r21, r21
    168a:	44 27       	eor	r20, r20
    168c:	48 2b       	or	r20, r24
    168e:	59 2b       	or	r21, r25
    1690:	6a 2b       	or	r22, r26
    1692:	7b 2b       	or	r23, r27
    1694:	fe 01       	movw	r30, r28
    1696:	e8 59       	subi	r30, 0x98	; 152
    1698:	ff 4f       	sbci	r31, 0xFF	; 255
    169a:	80 81       	ld	r24, Z
    169c:	90 e0       	ldi	r25, 0x00	; 0
    169e:	a0 e0       	ldi	r26, 0x00	; 0
    16a0:	b0 e0       	ldi	r27, 0x00	; 0
    16a2:	48 2b       	or	r20, r24
    16a4:	59 2b       	or	r21, r25
    16a6:	6a 2b       	or	r22, r26
    16a8:	7b 2b       	or	r23, r27
    16aa:	fe 01       	movw	r30, r28
    16ac:	e7 59       	subi	r30, 0x97	; 151
    16ae:	ff 4f       	sbci	r31, 0xFF	; 255
    16b0:	90 81       	ld	r25, Z
    16b2:	80 e0       	ldi	r24, 0x00	; 0
    16b4:	a0 e0       	ldi	r26, 0x00	; 0
    16b6:	b0 e0       	ldi	r27, 0x00	; 0
    16b8:	48 2b       	or	r20, r24
    16ba:	59 2b       	or	r21, r25
    16bc:	6a 2b       	or	r22, r26
    16be:	7b 2b       	or	r23, r27
    16c0:	70 70       	andi	r23, 0x00	; 0
    16c2:	46 34       	cpi	r20, 0x46	; 70
    16c4:	81 e4       	ldi	r24, 0x41	; 65
    16c6:	58 07       	cpc	r21, r24
    16c8:	84 e5       	ldi	r24, 0x54	; 84
    16ca:	68 07       	cpc	r22, r24
    16cc:	80 e0       	ldi	r24, 0x00	; 0
    16ce:	78 07       	cpc	r23, r24
    16d0:	f1 f1       	breq	.+124    	; 0x174e <check_fs+0x12e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    16d2:	fe 01       	movw	r30, r28
    16d4:	e9 57       	subi	r30, 0x79	; 121
    16d6:	ff 4f       	sbci	r31, 0xFF	; 255
    16d8:	80 81       	ld	r24, Z
    16da:	90 e0       	ldi	r25, 0x00	; 0
    16dc:	a0 e0       	ldi	r26, 0x00	; 0
    16de:	b0 e0       	ldi	r27, 0x00	; 0
    16e0:	b8 2f       	mov	r27, r24
    16e2:	aa 27       	eor	r26, r26
    16e4:	99 27       	eor	r25, r25
    16e6:	88 27       	eor	r24, r24
    16e8:	fe 01       	movw	r30, r28
    16ea:	ea 57       	subi	r30, 0x7A	; 122
    16ec:	ff 4f       	sbci	r31, 0xFF	; 255
    16ee:	40 81       	ld	r20, Z
    16f0:	50 e0       	ldi	r21, 0x00	; 0
    16f2:	60 e0       	ldi	r22, 0x00	; 0
    16f4:	70 e0       	ldi	r23, 0x00	; 0
    16f6:	ba 01       	movw	r22, r20
    16f8:	55 27       	eor	r21, r21
    16fa:	44 27       	eor	r20, r20
    16fc:	48 2b       	or	r20, r24
    16fe:	59 2b       	or	r21, r25
    1700:	6a 2b       	or	r22, r26
    1702:	7b 2b       	or	r23, r27
    1704:	fe 01       	movw	r30, r28
    1706:	ec 57       	subi	r30, 0x7C	; 124
    1708:	ff 4f       	sbci	r31, 0xFF	; 255
    170a:	80 81       	ld	r24, Z
    170c:	90 e0       	ldi	r25, 0x00	; 0
    170e:	a0 e0       	ldi	r26, 0x00	; 0
    1710:	b0 e0       	ldi	r27, 0x00	; 0
    1712:	48 2b       	or	r20, r24
    1714:	59 2b       	or	r21, r25
    1716:	6a 2b       	or	r22, r26
    1718:	7b 2b       	or	r23, r27
    171a:	cb 57       	subi	r28, 0x7B	; 123
    171c:	df 4f       	sbci	r29, 0xFF	; 255
    171e:	98 81       	ld	r25, Y
    1720:	80 e0       	ldi	r24, 0x00	; 0
    1722:	a0 e0       	ldi	r26, 0x00	; 0
    1724:	b0 e0       	ldi	r27, 0x00	; 0
    1726:	48 2b       	or	r20, r24
    1728:	59 2b       	or	r21, r25
    172a:	6a 2b       	or	r22, r26
    172c:	7b 2b       	or	r23, r27
    172e:	70 70       	andi	r23, 0x00	; 0
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
    1730:	81 e0       	ldi	r24, 0x01	; 1
    1732:	46 34       	cpi	r20, 0x46	; 70
    1734:	91 e4       	ldi	r25, 0x41	; 65
    1736:	59 07       	cpc	r21, r25
    1738:	94 e5       	ldi	r25, 0x54	; 84
    173a:	69 07       	cpc	r22, r25
    173c:	90 e0       	ldi	r25, 0x00	; 0
    173e:	79 07       	cpc	r23, r25
    1740:	39 f4       	brne	.+14     	; 0x1750 <check_fs+0x130>
    1742:	80 e0       	ldi	r24, 0x00	; 0
    1744:	05 c0       	rjmp	.+10     	; 0x1750 <check_fs+0x130>
    1746:	83 e0       	ldi	r24, 0x03	; 3
    1748:	03 c0       	rjmp	.+6      	; 0x1750 <check_fs+0x130>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
    174a:	82 e0       	ldi	r24, 0x02	; 2
    174c:	01 c0       	rjmp	.+2      	; 0x1750 <check_fs+0x130>

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;
    174e:	80 e0       	ldi	r24, 0x00	; 0
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
    1750:	df 91       	pop	r29
    1752:	cf 91       	pop	r28
    1754:	0f 91       	pop	r16
    1756:	08 95       	ret

00001758 <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
    1758:	2f 92       	push	r2
    175a:	3f 92       	push	r3
    175c:	4f 92       	push	r4
    175e:	5f 92       	push	r5
    1760:	6f 92       	push	r6
    1762:	7f 92       	push	r7
    1764:	8f 92       	push	r8
    1766:	9f 92       	push	r9
    1768:	af 92       	push	r10
    176a:	bf 92       	push	r11
    176c:	cf 92       	push	r12
    176e:	df 92       	push	r13
    1770:	ef 92       	push	r14
    1772:	ff 92       	push	r15
    1774:	0f 93       	push	r16
    1776:	1f 93       	push	r17
    1778:	cf 93       	push	r28
    177a:	df 93       	push	r29
    177c:	cd b7       	in	r28, 0x3d	; 61
    177e:	de b7       	in	r29, 0x3e	; 62
    1780:	60 97       	sbiw	r28, 0x10	; 16
    1782:	0f b6       	in	r0, 0x3f	; 63
    1784:	f8 94       	cli
    1786:	de bf       	out	0x3e, r29	; 62
    1788:	0f be       	out	0x3f, r0	; 63
    178a:	cd bf       	out	0x3d, r28	; 61
    178c:	8b 01       	movw	r16, r22
    178e:	d4 2e       	mov	r13, r20
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
    1790:	dc 01       	movw	r26, r24
    1792:	ed 91       	ld	r30, X+
    1794:	fc 91       	ld	r31, X
    1796:	11 97       	sbiw	r26, 0x01	; 1
	FATFS *fs;


	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
    1798:	40 81       	ld	r20, Z
    179a:	50 e0       	ldi	r21, 0x00	; 0
    179c:	40 53       	subi	r20, 0x30	; 48
    179e:	50 40       	sbci	r21, 0x00	; 0
    17a0:	66 27       	eor	r22, r22
    17a2:	57 fd       	sbrc	r21, 7
    17a4:	60 95       	com	r22
    17a6:	76 2f       	mov	r23, r22
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    17a8:	4a 30       	cpi	r20, 0x0A	; 10
    17aa:	51 05       	cpc	r21, r1
    17ac:	61 05       	cpc	r22, r1
    17ae:	71 05       	cpc	r23, r1
    17b0:	48 f4       	brcc	.+18     	; 0x17c4 <chk_mounted+0x6c>
    17b2:	81 81       	ldd	r24, Z+1	; 0x01
    17b4:	8a 33       	cpi	r24, 0x3A	; 58
    17b6:	31 f4       	brne	.+12     	; 0x17c4 <chk_mounted+0x6c>
		p += 2; *path = p;				/* Return pointer to the path name */
    17b8:	cf 01       	movw	r24, r30
    17ba:	02 96       	adiw	r24, 0x02	; 2
    17bc:	11 96       	adiw	r26, 0x01	; 1
    17be:	9c 93       	st	X, r25
    17c0:	8e 93       	st	-X, r24
    17c2:	05 c0       	rjmp	.+10     	; 0x17ce <chk_mounted+0x76>
	} else {							/* No drive number is given */
#if _FS_RPATH
		vol = CurrVol;					/* Use current drive */
    17c4:	40 91 f5 03 	lds	r20, 0x03F5
    17c8:	50 e0       	ldi	r21, 0x00	; 0
    17ca:	60 e0       	ldi	r22, 0x00	; 0
    17cc:	70 e0       	ldi	r23, 0x00	; 0
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
    17ce:	f8 01       	movw	r30, r16
    17d0:	11 82       	std	Z+1, r1	; 0x01
    17d2:	10 82       	st	Z, r1
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    17d4:	41 15       	cp	r20, r1
    17d6:	51 05       	cpc	r21, r1
    17d8:	61 05       	cpc	r22, r1
    17da:	71 05       	cpc	r23, r1
    17dc:	09 f0       	breq	.+2      	; 0x17e0 <chk_mounted+0x88>
    17de:	a3 c3       	rjmp	.+1862   	; 0x1f26 <chk_mounted+0x7ce>
		return FR_INVALID_DRIVE;
	fs = FatFs[vol];					/* Get corresponding file system object */
    17e0:	e0 90 f3 03 	lds	r14, 0x03F3
    17e4:	f0 90 f4 03 	lds	r15, 0x03F4
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    17e8:	e1 14       	cp	r14, r1
    17ea:	f1 04       	cpc	r15, r1
    17ec:	09 f4       	brne	.+2      	; 0x17f0 <chk_mounted+0x98>
    17ee:	9d c3       	rjmp	.+1850   	; 0x1f2a <chk_mounted+0x7d2>

	ENTER_FF(fs);						/* Lock file system */

	*rfs = fs;							/* Return pointer to the corresponding file system object */
    17f0:	f1 82       	std	Z+1, r15	; 0x01
    17f2:	e0 82       	st	Z, r14
	if (fs->fs_type) {					/* If the volume has been mounted */
    17f4:	d7 01       	movw	r26, r14
    17f6:	8c 91       	ld	r24, X
    17f8:	88 23       	and	r24, r24
    17fa:	69 f0       	breq	.+26     	; 0x1816 <chk_mounted+0xbe>
		stat = disk_status(fs->drv);
    17fc:	11 96       	adiw	r26, 0x01	; 1
    17fe:	8c 91       	ld	r24, X
    1800:	0e 94 92 02 	call	0x524	; 0x524 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    1804:	80 fd       	sbrc	r24, 0
    1806:	07 c0       	rjmp	.+14     	; 0x1816 <chk_mounted+0xbe>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
    1808:	dd 20       	and	r13, r13
    180a:	09 f4       	brne	.+2      	; 0x180e <chk_mounted+0xb6>
    180c:	90 c3       	rjmp	.+1824   	; 0x1f2e <chk_mounted+0x7d6>
    180e:	82 fd       	sbrc	r24, 2
    1810:	90 c3       	rjmp	.+1824   	; 0x1f32 <chk_mounted+0x7da>
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
    1812:	80 e0       	ldi	r24, 0x00	; 0
    1814:	af c3       	rjmp	.+1886   	; 0x1f74 <chk_mounted+0x81c>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
    1816:	f7 01       	movw	r30, r14
    1818:	10 82       	st	Z, r1
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    181a:	11 82       	std	Z+1, r1	; 0x01
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
    181c:	80 e0       	ldi	r24, 0x00	; 0
    181e:	0e 94 c2 01 	call	0x384	; 0x384 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    1822:	80 fd       	sbrc	r24, 0
    1824:	88 c3       	rjmp	.+1808   	; 0x1f36 <chk_mounted+0x7de>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    1826:	dd 20       	and	r13, r13
    1828:	11 f0       	breq	.+4      	; 0x182e <chk_mounted+0xd6>
    182a:	82 fd       	sbrc	r24, 2
    182c:	86 c3       	rjmp	.+1804   	; 0x1f3a <chk_mounted+0x7e2>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    182e:	c7 01       	movw	r24, r14
    1830:	40 e0       	ldi	r20, 0x00	; 0
    1832:	50 e0       	ldi	r21, 0x00	; 0
    1834:	ba 01       	movw	r22, r20
    1836:	0e 94 10 0b 	call	0x1620	; 0x1620 <check_fs>
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    183a:	81 30       	cpi	r24, 0x01	; 1
    183c:	e9 f5       	brne	.+122    	; 0x18b8 <chk_mounted+0x160>
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
    183e:	f7 01       	movw	r30, r14
    1840:	ec 50       	subi	r30, 0x0C	; 12
    1842:	fe 4f       	sbci	r31, 0xFE	; 254
    1844:	80 81       	ld	r24, Z
    1846:	88 23       	and	r24, r24
    1848:	09 f4       	brne	.+2      	; 0x184c <chk_mounted+0xf4>
    184a:	79 c3       	rjmp	.+1778   	; 0x1f3e <chk_mounted+0x7e6>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    184c:	f7 01       	movw	r30, r14
    184e:	e5 50       	subi	r30, 0x05	; 5
    1850:	fe 4f       	sbci	r31, 0xFE	; 254
    1852:	80 81       	ld	r24, Z
    1854:	90 e0       	ldi	r25, 0x00	; 0
    1856:	a0 e0       	ldi	r26, 0x00	; 0
    1858:	b0 e0       	ldi	r27, 0x00	; 0
    185a:	b8 2f       	mov	r27, r24
    185c:	aa 27       	eor	r26, r26
    185e:	99 27       	eor	r25, r25
    1860:	88 27       	eor	r24, r24
    1862:	f7 01       	movw	r30, r14
    1864:	e6 50       	subi	r30, 0x06	; 6
    1866:	fe 4f       	sbci	r31, 0xFE	; 254
    1868:	40 81       	ld	r20, Z
    186a:	50 e0       	ldi	r21, 0x00	; 0
    186c:	60 e0       	ldi	r22, 0x00	; 0
    186e:	70 e0       	ldi	r23, 0x00	; 0
    1870:	ba 01       	movw	r22, r20
    1872:	55 27       	eor	r21, r21
    1874:	44 27       	eor	r20, r20
    1876:	84 2b       	or	r24, r20
    1878:	95 2b       	or	r25, r21
    187a:	a6 2b       	or	r26, r22
    187c:	b7 2b       	or	r27, r23
    187e:	f7 01       	movw	r30, r14
    1880:	e8 50       	subi	r30, 0x08	; 8
    1882:	fe 4f       	sbci	r31, 0xFE	; 254
    1884:	40 81       	ld	r20, Z
    1886:	50 e0       	ldi	r21, 0x00	; 0
    1888:	60 e0       	ldi	r22, 0x00	; 0
    188a:	70 e0       	ldi	r23, 0x00	; 0
    188c:	48 2b       	or	r20, r24
    188e:	59 2b       	or	r21, r25
    1890:	6a 2b       	or	r22, r26
    1892:	7b 2b       	or	r23, r27
    1894:	f7 01       	movw	r30, r14
    1896:	e7 50       	subi	r30, 0x07	; 7
    1898:	fe 4f       	sbci	r31, 0xFE	; 254
    189a:	90 81       	ld	r25, Z
    189c:	80 e0       	ldi	r24, 0x00	; 0
    189e:	4c 01       	movw	r8, r24
    18a0:	aa 24       	eor	r10, r10
    18a2:	bb 24       	eor	r11, r11
    18a4:	84 2a       	or	r8, r20
    18a6:	95 2a       	or	r9, r21
    18a8:	a6 2a       	or	r10, r22
    18aa:	b7 2a       	or	r11, r23
			fmt = check_fs(fs, bsect);		/* Check the partition */
    18ac:	c7 01       	movw	r24, r14
    18ae:	b5 01       	movw	r22, r10
    18b0:	a4 01       	movw	r20, r8
    18b2:	0e 94 10 0b 	call	0x1620	; 0x1620 <check_fs>
    18b6:	03 c0       	rjmp	.+6      	; 0x18be <chk_mounted+0x166>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    18b8:	88 24       	eor	r8, r8
    18ba:	99 24       	eor	r9, r9
    18bc:	54 01       	movw	r10, r8
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    18be:	83 30       	cpi	r24, 0x03	; 3
    18c0:	09 f4       	brne	.+2      	; 0x18c4 <chk_mounted+0x16c>
    18c2:	3f c3       	rjmp	.+1662   	; 0x1f42 <chk_mounted+0x7ea>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    18c4:	88 23       	and	r24, r24
    18c6:	09 f0       	breq	.+2      	; 0x18ca <chk_mounted+0x172>
    18c8:	3e c3       	rjmp	.+1660   	; 0x1f46 <chk_mounted+0x7ee>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    18ca:	d7 01       	movw	r26, r14
    18cc:	de 96       	adiw	r26, 0x3e	; 62
    18ce:	9c 91       	ld	r25, X
    18d0:	de 97       	sbiw	r26, 0x3e	; 62
    18d2:	80 e0       	ldi	r24, 0x00	; 0
    18d4:	dd 96       	adiw	r26, 0x3d	; 61
    18d6:	2c 91       	ld	r18, X
    18d8:	dd 97       	sbiw	r26, 0x3d	; 61
    18da:	30 e0       	ldi	r19, 0x00	; 0
    18dc:	82 2b       	or	r24, r18
    18de:	93 2b       	or	r25, r19
    18e0:	b2 e0       	ldi	r27, 0x02	; 2
    18e2:	80 30       	cpi	r24, 0x00	; 0
    18e4:	9b 07       	cpc	r25, r27
    18e6:	09 f0       	breq	.+2      	; 0x18ea <chk_mounted+0x192>
    18e8:	30 c3       	rjmp	.+1632   	; 0x1f4a <chk_mounted+0x7f2>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    18ea:	f7 01       	movw	r30, r14
    18ec:	e7 5b       	subi	r30, 0xB7	; 183
    18ee:	ff 4f       	sbci	r31, 0xFF	; 255
    18f0:	30 81       	ld	r19, Z
    18f2:	20 e0       	ldi	r18, 0x00	; 0
    18f4:	f7 01       	movw	r30, r14
    18f6:	e8 5b       	subi	r30, 0xB8	; 184
    18f8:	ff 4f       	sbci	r31, 0xFF	; 255
    18fa:	80 81       	ld	r24, Z
    18fc:	90 e0       	ldi	r25, 0x00	; 0
    18fe:	82 2b       	or	r24, r18
    1900:	93 2b       	or	r25, r19
    1902:	2c 01       	movw	r4, r24
    1904:	66 24       	eor	r6, r6
    1906:	77 24       	eor	r7, r7
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    1908:	41 14       	cp	r4, r1
    190a:	51 04       	cpc	r5, r1
    190c:	61 04       	cpc	r6, r1
    190e:	71 04       	cpc	r7, r1
    1910:	89 f5       	brne	.+98     	; 0x1974 <chk_mounted+0x21c>
    1912:	f7 01       	movw	r30, r14
    1914:	e7 5a       	subi	r30, 0xA7	; 167
    1916:	ff 4f       	sbci	r31, 0xFF	; 255
    1918:	40 81       	ld	r20, Z
    191a:	50 e0       	ldi	r21, 0x00	; 0
    191c:	60 e0       	ldi	r22, 0x00	; 0
    191e:	70 e0       	ldi	r23, 0x00	; 0
    1920:	74 2f       	mov	r23, r20
    1922:	66 27       	eor	r22, r22
    1924:	55 27       	eor	r21, r21
    1926:	44 27       	eor	r20, r20
    1928:	f7 01       	movw	r30, r14
    192a:	e8 5a       	subi	r30, 0xA8	; 168
    192c:	ff 4f       	sbci	r31, 0xFF	; 255
    192e:	80 81       	ld	r24, Z
    1930:	90 e0       	ldi	r25, 0x00	; 0
    1932:	a0 e0       	ldi	r26, 0x00	; 0
    1934:	b0 e0       	ldi	r27, 0x00	; 0
    1936:	dc 01       	movw	r26, r24
    1938:	99 27       	eor	r25, r25
    193a:	88 27       	eor	r24, r24
    193c:	48 2b       	or	r20, r24
    193e:	59 2b       	or	r21, r25
    1940:	6a 2b       	or	r22, r26
    1942:	7b 2b       	or	r23, r27
    1944:	f7 01       	movw	r30, r14
    1946:	ea 5a       	subi	r30, 0xAA	; 170
    1948:	ff 4f       	sbci	r31, 0xFF	; 255
    194a:	80 81       	ld	r24, Z
    194c:	90 e0       	ldi	r25, 0x00	; 0
    194e:	a0 e0       	ldi	r26, 0x00	; 0
    1950:	b0 e0       	ldi	r27, 0x00	; 0
    1952:	48 2b       	or	r20, r24
    1954:	59 2b       	or	r21, r25
    1956:	6a 2b       	or	r22, r26
    1958:	7b 2b       	or	r23, r27
    195a:	f7 01       	movw	r30, r14
    195c:	e9 5a       	subi	r30, 0xA9	; 169
    195e:	ff 4f       	sbci	r31, 0xFF	; 255
    1960:	90 81       	ld	r25, Z
    1962:	80 e0       	ldi	r24, 0x00	; 0
    1964:	a0 e0       	ldi	r26, 0x00	; 0
    1966:	b0 e0       	ldi	r27, 0x00	; 0
    1968:	2a 01       	movw	r4, r20
    196a:	3b 01       	movw	r6, r22
    196c:	48 2a       	or	r4, r24
    196e:	59 2a       	or	r5, r25
    1970:	6a 2a       	or	r6, r26
    1972:	7b 2a       	or	r7, r27
	fs->fsize = fasize;
    1974:	f7 01       	movw	r30, r14
    1976:	46 8e       	std	Z+30, r4	; 0x1e
    1978:	57 8e       	std	Z+31, r5	; 0x1f
    197a:	60 a2       	lds	r22, 0x90
    197c:	71 a2       	lds	r23, 0x91

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    197e:	ee 5b       	subi	r30, 0xBE	; 190
    1980:	ff 4f       	sbci	r31, 0xFF	; 255
    1982:	c0 80       	ld	r12, Z
    1984:	d7 01       	movw	r26, r14
    1986:	13 96       	adiw	r26, 0x03	; 3
    1988:	cc 92       	st	X, r12
    198a:	13 97       	sbiw	r26, 0x03	; 3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    198c:	8c 2d       	mov	r24, r12
    198e:	81 50       	subi	r24, 0x01	; 1
    1990:	82 30       	cpi	r24, 0x02	; 2
    1992:	08 f0       	brcs	.+2      	; 0x1996 <chk_mounted+0x23e>
    1994:	dc c2       	rjmp	.+1464   	; 0x1f4e <chk_mounted+0x7f6>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    1996:	df 96       	adiw	r26, 0x3f	; 63
    1998:	dc 90       	ld	r13, X
    199a:	df 97       	sbiw	r26, 0x3f	; 63
    199c:	12 96       	adiw	r26, 0x02	; 2
    199e:	dc 92       	st	X, r13
    19a0:	12 97       	sbiw	r26, 0x02	; 2
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    19a2:	dd 20       	and	r13, r13
    19a4:	09 f4       	brne	.+2      	; 0x19a8 <chk_mounted+0x250>
    19a6:	d5 c2       	rjmp	.+1450   	; 0x1f52 <chk_mounted+0x7fa>
    19a8:	8d 2d       	mov	r24, r13
    19aa:	90 e0       	ldi	r25, 0x00	; 0
    19ac:	9c 01       	movw	r18, r24
    19ae:	21 50       	subi	r18, 0x01	; 1
    19b0:	30 40       	sbci	r19, 0x00	; 0
    19b2:	82 23       	and	r24, r18
    19b4:	93 23       	and	r25, r19
    19b6:	00 97       	sbiw	r24, 0x00	; 0
    19b8:	09 f0       	breq	.+2      	; 0x19bc <chk_mounted+0x264>
    19ba:	cd c2       	rjmp	.+1434   	; 0x1f56 <chk_mounted+0x7fe>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    19bc:	f7 01       	movw	r30, r14
    19be:	ec 5b       	subi	r30, 0xBC	; 188
    19c0:	ff 4f       	sbci	r31, 0xFF	; 255
    19c2:	30 81       	ld	r19, Z
    19c4:	20 e0       	ldi	r18, 0x00	; 0
    19c6:	f7 01       	movw	r30, r14
    19c8:	ed 5b       	subi	r30, 0xBD	; 189
    19ca:	ff 4f       	sbci	r31, 0xFF	; 255
    19cc:	80 81       	ld	r24, Z
    19ce:	90 e0       	ldi	r25, 0x00	; 0
    19d0:	19 01       	movw	r2, r18
    19d2:	28 2a       	or	r2, r24
    19d4:	39 2a       	or	r3, r25
    19d6:	f7 01       	movw	r30, r14
    19d8:	31 86       	std	Z+9, r3	; 0x09
    19da:	20 86       	std	Z+8, r2	; 0x08
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    19dc:	c1 01       	movw	r24, r2
    19de:	8f 70       	andi	r24, 0x0F	; 15
    19e0:	90 70       	andi	r25, 0x00	; 0
    19e2:	00 97       	sbiw	r24, 0x00	; 0
    19e4:	09 f0       	breq	.+2      	; 0x19e8 <chk_mounted+0x290>
    19e6:	b9 c2       	rjmp	.+1394   	; 0x1f5a <chk_mounted+0x802>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    19e8:	ea 5b       	subi	r30, 0xBA	; 186
    19ea:	ff 4f       	sbci	r31, 0xFF	; 255
    19ec:	30 81       	ld	r19, Z
    19ee:	20 e0       	ldi	r18, 0x00	; 0
    19f0:	f7 01       	movw	r30, r14
    19f2:	eb 5b       	subi	r30, 0xBB	; 187
    19f4:	ff 4f       	sbci	r31, 0xFF	; 255
    19f6:	80 81       	ld	r24, Z
    19f8:	90 e0       	ldi	r25, 0x00	; 0
    19fa:	82 2b       	or	r24, r18
    19fc:	93 2b       	or	r25, r19
    19fe:	8c 01       	movw	r16, r24
    1a00:	20 e0       	ldi	r18, 0x00	; 0
    1a02:	30 e0       	ldi	r19, 0x00	; 0
    1a04:	09 83       	std	Y+1, r16	; 0x01
    1a06:	1a 83       	std	Y+2, r17	; 0x02
    1a08:	2b 83       	std	Y+3, r18	; 0x03
    1a0a:	3c 83       	std	Y+4, r19	; 0x04
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    1a0c:	01 15       	cp	r16, r1
    1a0e:	11 05       	cpc	r17, r1
    1a10:	21 05       	cpc	r18, r1
    1a12:	31 05       	cpc	r19, r1
    1a14:	a9 f5       	brne	.+106    	; 0x1a80 <chk_mounted+0x328>
    1a16:	f7 01       	movw	r30, r14
    1a18:	eb 5a       	subi	r30, 0xAB	; 171
    1a1a:	ff 4f       	sbci	r31, 0xFF	; 255
    1a1c:	80 81       	ld	r24, Z
    1a1e:	90 e0       	ldi	r25, 0x00	; 0
    1a20:	a0 e0       	ldi	r26, 0x00	; 0
    1a22:	b0 e0       	ldi	r27, 0x00	; 0
    1a24:	78 2f       	mov	r23, r24
    1a26:	66 27       	eor	r22, r22
    1a28:	55 27       	eor	r21, r21
    1a2a:	44 27       	eor	r20, r20
    1a2c:	f7 01       	movw	r30, r14
    1a2e:	ec 5a       	subi	r30, 0xAC	; 172
    1a30:	ff 4f       	sbci	r31, 0xFF	; 255
    1a32:	80 81       	ld	r24, Z
    1a34:	90 e0       	ldi	r25, 0x00	; 0
    1a36:	a0 e0       	ldi	r26, 0x00	; 0
    1a38:	b0 e0       	ldi	r27, 0x00	; 0
    1a3a:	dc 01       	movw	r26, r24
    1a3c:	99 27       	eor	r25, r25
    1a3e:	88 27       	eor	r24, r24
    1a40:	48 2b       	or	r20, r24
    1a42:	59 2b       	or	r21, r25
    1a44:	6a 2b       	or	r22, r26
    1a46:	7b 2b       	or	r23, r27
    1a48:	f7 01       	movw	r30, r14
    1a4a:	ee 5a       	subi	r30, 0xAE	; 174
    1a4c:	ff 4f       	sbci	r31, 0xFF	; 255
    1a4e:	80 81       	ld	r24, Z
    1a50:	90 e0       	ldi	r25, 0x00	; 0
    1a52:	a0 e0       	ldi	r26, 0x00	; 0
    1a54:	b0 e0       	ldi	r27, 0x00	; 0
    1a56:	48 2b       	or	r20, r24
    1a58:	59 2b       	or	r21, r25
    1a5a:	6a 2b       	or	r22, r26
    1a5c:	7b 2b       	or	r23, r27
    1a5e:	f7 01       	movw	r30, r14
    1a60:	ed 5a       	subi	r30, 0xAD	; 173
    1a62:	ff 4f       	sbci	r31, 0xFF	; 255
    1a64:	90 81       	ld	r25, Z
    1a66:	80 e0       	ldi	r24, 0x00	; 0
    1a68:	a0 e0       	ldi	r26, 0x00	; 0
    1a6a:	b0 e0       	ldi	r27, 0x00	; 0
    1a6c:	8a 01       	movw	r16, r20
    1a6e:	9b 01       	movw	r18, r22
    1a70:	08 2b       	or	r16, r24
    1a72:	19 2b       	or	r17, r25
    1a74:	2a 2b       	or	r18, r26
    1a76:	3b 2b       	or	r19, r27
    1a78:	09 83       	std	Y+1, r16	; 0x01
    1a7a:	1a 83       	std	Y+2, r17	; 0x02
    1a7c:	2b 83       	std	Y+3, r18	; 0x03
    1a7e:	3c 83       	std	Y+4, r19	; 0x04

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    1a80:	f7 01       	movw	r30, r14
    1a82:	ef 5b       	subi	r30, 0xBF	; 191
    1a84:	ff 4f       	sbci	r31, 0xFF	; 255
    1a86:	30 81       	ld	r19, Z
    1a88:	20 e0       	ldi	r18, 0x00	; 0
    1a8a:	f7 01       	movw	r30, r14
    1a8c:	e0 5c       	subi	r30, 0xC0	; 192
    1a8e:	ff 4f       	sbci	r31, 0xFF	; 255
    1a90:	80 81       	ld	r24, Z
    1a92:	90 e0       	ldi	r25, 0x00	; 0
    1a94:	89 01       	movw	r16, r18
    1a96:	08 2b       	or	r16, r24
    1a98:	19 2b       	or	r17, r25
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    1a9a:	01 15       	cp	r16, r1
    1a9c:	11 05       	cpc	r17, r1
    1a9e:	09 f4       	brne	.+2      	; 0x1aa2 <chk_mounted+0x34a>
    1aa0:	5e c2       	rjmp	.+1212   	; 0x1f5e <chk_mounted+0x806>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
    1aa2:	2c 2d       	mov	r18, r12
    1aa4:	30 e0       	ldi	r19, 0x00	; 0
    1aa6:	40 e0       	ldi	r20, 0x00	; 0
    1aa8:	50 e0       	ldi	r21, 0x00	; 0
    1aaa:	c3 01       	movw	r24, r6
    1aac:	b2 01       	movw	r22, r4
    1aae:	0e 94 58 2b 	call	0x56b0	; 0x56b0 <__mulsi3>
    1ab2:	6d 87       	std	Y+13, r22	; 0x0d
    1ab4:	7e 87       	std	Y+14, r23	; 0x0e
    1ab6:	8f 87       	std	Y+15, r24	; 0x0f
    1ab8:	98 8b       	std	Y+16, r25	; 0x10

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    1aba:	98 01       	movw	r18, r16
    1abc:	40 e0       	ldi	r20, 0x00	; 0
    1abe:	50 e0       	ldi	r21, 0x00	; 0
    1ac0:	29 87       	std	Y+9, r18	; 0x09
    1ac2:	3a 87       	std	Y+10, r19	; 0x0a
    1ac4:	4b 87       	std	Y+11, r20	; 0x0b
    1ac6:	5c 87       	std	Y+12, r21	; 0x0c
    1ac8:	c1 01       	movw	r24, r2
    1aca:	92 95       	swap	r25
    1acc:	82 95       	swap	r24
    1ace:	8f 70       	andi	r24, 0x0F	; 15
    1ad0:	89 27       	eor	r24, r25
    1ad2:	9f 70       	andi	r25, 0x0F	; 15
    1ad4:	89 27       	eor	r24, r25
    1ad6:	a0 e0       	ldi	r26, 0x00	; 0
    1ad8:	b0 e0       	ldi	r27, 0x00	; 0
    1ada:	82 0f       	add	r24, r18
    1adc:	93 1f       	adc	r25, r19
    1ade:	a4 1f       	adc	r26, r20
    1ae0:	b5 1f       	adc	r27, r21
    1ae2:	0d 85       	ldd	r16, Y+13	; 0x0d
    1ae4:	1e 85       	ldd	r17, Y+14	; 0x0e
    1ae6:	2f 85       	ldd	r18, Y+15	; 0x0f
    1ae8:	38 89       	ldd	r19, Y+16	; 0x10
    1aea:	08 0f       	add	r16, r24
    1aec:	19 1f       	adc	r17, r25
    1aee:	2a 1f       	adc	r18, r26
    1af0:	3b 1f       	adc	r19, r27
    1af2:	0d 83       	std	Y+5, r16	; 0x05
    1af4:	1e 83       	std	Y+6, r17	; 0x06
    1af6:	2f 83       	std	Y+7, r18	; 0x07
    1af8:	38 87       	std	Y+8, r19	; 0x08
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    1afa:	89 81       	ldd	r24, Y+1	; 0x01
    1afc:	9a 81       	ldd	r25, Y+2	; 0x02
    1afe:	ab 81       	ldd	r26, Y+3	; 0x03
    1b00:	bc 81       	ldd	r27, Y+4	; 0x04
    1b02:	80 17       	cp	r24, r16
    1b04:	91 07       	cpc	r25, r17
    1b06:	a2 07       	cpc	r26, r18
    1b08:	b3 07       	cpc	r27, r19
    1b0a:	08 f4       	brcc	.+2      	; 0x1b0e <chk_mounted+0x3b6>
    1b0c:	2a c2       	rjmp	.+1108   	; 0x1f62 <chk_mounted+0x80a>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    1b0e:	bc 01       	movw	r22, r24
    1b10:	cd 01       	movw	r24, r26
    1b12:	60 1b       	sub	r22, r16
    1b14:	71 0b       	sbc	r23, r17
    1b16:	82 0b       	sbc	r24, r18
    1b18:	93 0b       	sbc	r25, r19
    1b1a:	2d 2d       	mov	r18, r13
    1b1c:	30 e0       	ldi	r19, 0x00	; 0
    1b1e:	40 e0       	ldi	r20, 0x00	; 0
    1b20:	50 e0       	ldi	r21, 0x00	; 0
    1b22:	0e 94 77 2b 	call	0x56ee	; 0x56ee <__udivmodsi4>
    1b26:	89 01       	movw	r16, r18
    1b28:	9a 01       	movw	r18, r20
    1b2a:	d9 01       	movw	r26, r18
    1b2c:	c8 01       	movw	r24, r16
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    1b2e:	01 15       	cp	r16, r1
    1b30:	11 05       	cpc	r17, r1
    1b32:	21 05       	cpc	r18, r1
    1b34:	31 05       	cpc	r19, r1
    1b36:	09 f4       	brne	.+2      	; 0x1b3a <chk_mounted+0x3e2>
    1b38:	16 c2       	rjmp	.+1068   	; 0x1f66 <chk_mounted+0x80e>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    1b3a:	06 3f       	cpi	r16, 0xF6	; 246
    1b3c:	ef e0       	ldi	r30, 0x0F	; 15
    1b3e:	1e 07       	cpc	r17, r30
    1b40:	e0 e0       	ldi	r30, 0x00	; 0
    1b42:	2e 07       	cpc	r18, r30
    1b44:	e0 e0       	ldi	r30, 0x00	; 0
    1b46:	3e 07       	cpc	r19, r30
    1b48:	18 f4       	brcc	.+6      	; 0x1b50 <chk_mounted+0x3f8>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
    1b4a:	dd 24       	eor	r13, r13
    1b4c:	d3 94       	inc	r13
    1b4e:	03 c0       	rjmp	.+6      	; 0x1b56 <chk_mounted+0x3fe>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    1b50:	dd 24       	eor	r13, r13
    1b52:	68 94       	set
    1b54:	d1 f8       	bld	r13, 1
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    1b56:	86 3f       	cpi	r24, 0xF6	; 246
    1b58:	ff ef       	ldi	r31, 0xFF	; 255
    1b5a:	9f 07       	cpc	r25, r31
    1b5c:	f0 e0       	ldi	r31, 0x00	; 0
    1b5e:	af 07       	cpc	r26, r31
    1b60:	f0 e0       	ldi	r31, 0x00	; 0
    1b62:	bf 07       	cpc	r27, r31
    1b64:	08 f0       	brcs	.+2      	; 0x1b68 <chk_mounted+0x410>
    1b66:	1f c2       	rjmp	.+1086   	; 0x1fa6 <chk_mounted+0x84e>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    1b68:	b9 01       	movw	r22, r18
    1b6a:	a8 01       	movw	r20, r16
    1b6c:	4e 5f       	subi	r20, 0xFE	; 254
    1b6e:	5f 4f       	sbci	r21, 0xFF	; 255
    1b70:	6f 4f       	sbci	r22, 0xFF	; 255
    1b72:	7f 4f       	sbci	r23, 0xFF	; 255
    1b74:	d7 01       	movw	r26, r14
    1b76:	5a 96       	adiw	r26, 0x1a	; 26
    1b78:	4d 93       	st	X+, r20
    1b7a:	5d 93       	st	X+, r21
    1b7c:	6d 93       	st	X+, r22
    1b7e:	7c 93       	st	X, r23
    1b80:	5d 97       	sbiw	r26, 0x1d	; 29
	fs->database = bsect + sysect;						/* Data start sector */
    1b82:	8d 81       	ldd	r24, Y+5	; 0x05
    1b84:	9e 81       	ldd	r25, Y+6	; 0x06
    1b86:	af 81       	ldd	r26, Y+7	; 0x07
    1b88:	b8 85       	ldd	r27, Y+8	; 0x08
    1b8a:	88 0d       	add	r24, r8
    1b8c:	99 1d       	adc	r25, r9
    1b8e:	aa 1d       	adc	r26, r10
    1b90:	bb 1d       	adc	r27, r11
    1b92:	f7 01       	movw	r30, r14
    1b94:	82 a7       	lds	r24, 0x72
    1b96:	93 a7       	lds	r25, 0x73
    1b98:	a4 a7       	lds	r26, 0x74
    1b9a:	b5 a7       	lds	r27, 0x75
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    1b9c:	89 85       	ldd	r24, Y+9	; 0x09
    1b9e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ba0:	ab 85       	ldd	r26, Y+11	; 0x0b
    1ba2:	bc 85       	ldd	r27, Y+12	; 0x0c
    1ba4:	88 0d       	add	r24, r8
    1ba6:	99 1d       	adc	r25, r9
    1ba8:	aa 1d       	adc	r26, r10
    1baa:	bb 1d       	adc	r27, r11
    1bac:	82 a3       	lds	r24, 0x52
    1bae:	93 a3       	lds	r25, 0x53
    1bb0:	a4 a3       	lds	r26, 0x54
    1bb2:	b5 a3       	lds	r27, 0x55
	if (fmt == FS_FAT32) {
    1bb4:	f3 e0       	ldi	r31, 0x03	; 3
    1bb6:	df 16       	cp	r13, r31
    1bb8:	09 f0       	breq	.+2      	; 0x1bbc <chk_mounted+0x464>
    1bba:	41 c0       	rjmp	.+130    	; 0x1c3e <chk_mounted+0x4e6>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    1bbc:	21 14       	cp	r2, r1
    1bbe:	31 04       	cpc	r3, r1
    1bc0:	09 f0       	breq	.+2      	; 0x1bc4 <chk_mounted+0x46c>
    1bc2:	d3 c1       	rjmp	.+934    	; 0x1f6a <chk_mounted+0x812>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    1bc4:	f7 01       	movw	r30, r14
    1bc6:	ef 59       	subi	r30, 0x9F	; 159
    1bc8:	ff 4f       	sbci	r31, 0xFF	; 255
    1bca:	80 81       	ld	r24, Z
    1bcc:	90 e0       	ldi	r25, 0x00	; 0
    1bce:	a0 e0       	ldi	r26, 0x00	; 0
    1bd0:	b0 e0       	ldi	r27, 0x00	; 0
    1bd2:	38 2f       	mov	r19, r24
    1bd4:	22 27       	eor	r18, r18
    1bd6:	11 27       	eor	r17, r17
    1bd8:	00 27       	eor	r16, r16
    1bda:	f7 01       	movw	r30, r14
    1bdc:	e0 5a       	subi	r30, 0xA0	; 160
    1bde:	ff 4f       	sbci	r31, 0xFF	; 255
    1be0:	80 81       	ld	r24, Z
    1be2:	90 e0       	ldi	r25, 0x00	; 0
    1be4:	a0 e0       	ldi	r26, 0x00	; 0
    1be6:	b0 e0       	ldi	r27, 0x00	; 0
    1be8:	dc 01       	movw	r26, r24
    1bea:	99 27       	eor	r25, r25
    1bec:	88 27       	eor	r24, r24
    1bee:	08 2b       	or	r16, r24
    1bf0:	19 2b       	or	r17, r25
    1bf2:	2a 2b       	or	r18, r26
    1bf4:	3b 2b       	or	r19, r27
    1bf6:	f7 01       	movw	r30, r14
    1bf8:	e2 5a       	subi	r30, 0xA2	; 162
    1bfa:	ff 4f       	sbci	r31, 0xFF	; 255
    1bfc:	80 81       	ld	r24, Z
    1bfe:	90 e0       	ldi	r25, 0x00	; 0
    1c00:	a0 e0       	ldi	r26, 0x00	; 0
    1c02:	b0 e0       	ldi	r27, 0x00	; 0
    1c04:	08 2b       	or	r16, r24
    1c06:	19 2b       	or	r17, r25
    1c08:	2a 2b       	or	r18, r26
    1c0a:	3b 2b       	or	r19, r27
    1c0c:	f7 01       	movw	r30, r14
    1c0e:	e1 5a       	subi	r30, 0xA1	; 161
    1c10:	ff 4f       	sbci	r31, 0xFF	; 255
    1c12:	90 81       	ld	r25, Z
    1c14:	80 e0       	ldi	r24, 0x00	; 0
    1c16:	a0 e0       	ldi	r26, 0x00	; 0
    1c18:	b0 e0       	ldi	r27, 0x00	; 0
    1c1a:	80 2b       	or	r24, r16
    1c1c:	91 2b       	or	r25, r17
    1c1e:	a2 2b       	or	r26, r18
    1c20:	b3 2b       	or	r27, r19
    1c22:	f7 01       	movw	r30, r14
    1c24:	86 a3       	lds	r24, 0x56
    1c26:	97 a3       	lds	r25, 0x57
    1c28:	a0 a7       	lds	r26, 0x70
    1c2a:	b1 a7       	lds	r27, 0x71
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    1c2c:	44 0f       	add	r20, r20
    1c2e:	55 1f       	adc	r21, r21
    1c30:	66 1f       	adc	r22, r22
    1c32:	77 1f       	adc	r23, r23
    1c34:	44 0f       	add	r20, r20
    1c36:	55 1f       	adc	r21, r21
    1c38:	66 1f       	adc	r22, r22
    1c3a:	77 1f       	adc	r23, r23
    1c3c:	2f c0       	rjmp	.+94     	; 0x1c9c <chk_mounted+0x544>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    1c3e:	21 14       	cp	r2, r1
    1c40:	31 04       	cpc	r3, r1
    1c42:	09 f4       	brne	.+2      	; 0x1c46 <chk_mounted+0x4ee>
    1c44:	94 c1       	rjmp	.+808    	; 0x1f6e <chk_mounted+0x816>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    1c46:	0d 85       	ldd	r16, Y+13	; 0x0d
    1c48:	1e 85       	ldd	r17, Y+14	; 0x0e
    1c4a:	2f 85       	ldd	r18, Y+15	; 0x0f
    1c4c:	38 89       	ldd	r19, Y+16	; 0x10
    1c4e:	80 0f       	add	r24, r16
    1c50:	91 1f       	adc	r25, r17
    1c52:	a2 1f       	adc	r26, r18
    1c54:	b3 1f       	adc	r27, r19
    1c56:	f7 01       	movw	r30, r14
    1c58:	86 a3       	lds	r24, 0x56
    1c5a:	97 a3       	lds	r25, 0x57
    1c5c:	a0 a7       	lds	r26, 0x70
    1c5e:	b1 a7       	lds	r27, 0x71
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    1c60:	f2 e0       	ldi	r31, 0x02	; 2
    1c62:	df 16       	cp	r13, r31
    1c64:	29 f4       	brne	.+10     	; 0x1c70 <chk_mounted+0x518>
    1c66:	44 0f       	add	r20, r20
    1c68:	55 1f       	adc	r21, r21
    1c6a:	66 1f       	adc	r22, r22
    1c6c:	77 1f       	adc	r23, r23
    1c6e:	16 c0       	rjmp	.+44     	; 0x1c9c <chk_mounted+0x544>
    1c70:	db 01       	movw	r26, r22
    1c72:	ca 01       	movw	r24, r20
    1c74:	88 0f       	add	r24, r24
    1c76:	99 1f       	adc	r25, r25
    1c78:	aa 1f       	adc	r26, r26
    1c7a:	bb 1f       	adc	r27, r27
    1c7c:	84 0f       	add	r24, r20
    1c7e:	95 1f       	adc	r25, r21
    1c80:	a6 1f       	adc	r26, r22
    1c82:	b7 1f       	adc	r27, r23
    1c84:	b6 95       	lsr	r27
    1c86:	a7 95       	ror	r26
    1c88:	97 95       	ror	r25
    1c8a:	87 95       	ror	r24
    1c8c:	41 70       	andi	r20, 0x01	; 1
    1c8e:	50 70       	andi	r21, 0x00	; 0
    1c90:	60 70       	andi	r22, 0x00	; 0
    1c92:	70 70       	andi	r23, 0x00	; 0
    1c94:	48 0f       	add	r20, r24
    1c96:	59 1f       	adc	r21, r25
    1c98:	6a 1f       	adc	r22, r26
    1c9a:	7b 1f       	adc	r23, r27
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    1c9c:	db 01       	movw	r26, r22
    1c9e:	ca 01       	movw	r24, r20
    1ca0:	81 50       	subi	r24, 0x01	; 1
    1ca2:	9e 4f       	sbci	r25, 0xFE	; 254
    1ca4:	af 4f       	sbci	r26, 0xFF	; 255
    1ca6:	bf 4f       	sbci	r27, 0xFF	; 255
    1ca8:	07 2e       	mov	r0, r23
    1caa:	79 e0       	ldi	r23, 0x09	; 9
    1cac:	b6 95       	lsr	r27
    1cae:	a7 95       	ror	r26
    1cb0:	97 95       	ror	r25
    1cb2:	87 95       	ror	r24
    1cb4:	7a 95       	dec	r23
    1cb6:	d1 f7       	brne	.-12     	; 0x1cac <chk_mounted+0x554>
    1cb8:	70 2d       	mov	r23, r0
    1cba:	48 16       	cp	r4, r24
    1cbc:	59 06       	cpc	r5, r25
    1cbe:	6a 06       	cpc	r6, r26
    1cc0:	7b 06       	cpc	r7, r27
    1cc2:	08 f4       	brcc	.+2      	; 0x1cc6 <chk_mounted+0x56e>
    1cc4:	56 c1       	rjmp	.+684    	; 0x1f72 <chk_mounted+0x81a>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
    1cc6:	8f ef       	ldi	r24, 0xFF	; 255
    1cc8:	9f ef       	ldi	r25, 0xFF	; 255
    1cca:	dc 01       	movw	r26, r24
    1ccc:	f7 01       	movw	r30, r14
    1cce:	86 87       	std	Z+14, r24	; 0x0e
    1cd0:	97 87       	std	Z+15, r25	; 0x0f
    1cd2:	a0 8b       	std	Z+16, r26	; 0x10
    1cd4:	b1 8b       	std	Z+17, r27	; 0x11
	fs->last_clust = 0;
    1cd6:	12 86       	std	Z+10, r1	; 0x0a
    1cd8:	13 86       	std	Z+11, r1	; 0x0b
    1cda:	14 86       	std	Z+12, r1	; 0x0c
    1cdc:	15 86       	std	Z+13, r1	; 0x0d

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
    1cde:	b3 e0       	ldi	r27, 0x03	; 3
    1ce0:	db 16       	cp	r13, r27
    1ce2:	09 f0       	breq	.+2      	; 0x1ce6 <chk_mounted+0x58e>
    1ce4:	03 c1       	rjmp	.+518    	; 0x1eec <chk_mounted+0x794>
	 	fs->fsi_flag = 0;
    1ce6:	15 82       	std	Z+5, r1	; 0x05
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
    1ce8:	ed 59       	subi	r30, 0x9D	; 157
    1cea:	ff 4f       	sbci	r31, 0xFF	; 255
    1cec:	30 81       	ld	r19, Z
    1cee:	20 e0       	ldi	r18, 0x00	; 0
    1cf0:	f7 01       	movw	r30, r14
    1cf2:	ee 59       	subi	r30, 0x9E	; 158
    1cf4:	ff 4f       	sbci	r31, 0xFF	; 255
    1cf6:	80 81       	ld	r24, Z
    1cf8:	90 e0       	ldi	r25, 0x00	; 0
    1cfa:	82 2b       	or	r24, r18
    1cfc:	93 2b       	or	r25, r19
    1cfe:	a0 e0       	ldi	r26, 0x00	; 0
    1d00:	b0 e0       	ldi	r27, 0x00	; 0
    1d02:	a5 01       	movw	r20, r10
    1d04:	94 01       	movw	r18, r8
    1d06:	28 0f       	add	r18, r24
    1d08:	39 1f       	adc	r19, r25
    1d0a:	4a 1f       	adc	r20, r26
    1d0c:	5b 1f       	adc	r21, r27
    1d0e:	d7 01       	movw	r26, r14
    1d10:	52 96       	adiw	r26, 0x12	; 18
    1d12:	2d 93       	st	X+, r18
    1d14:	3d 93       	st	X+, r19
    1d16:	4d 93       	st	X+, r20
    1d18:	5c 93       	st	X, r21
    1d1a:	55 97       	sbiw	r26, 0x15	; 21
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    1d1c:	b7 01       	movw	r22, r14
    1d1e:	6e 5c       	subi	r22, 0xCE	; 206
    1d20:	7f 4f       	sbci	r23, 0xFF	; 255
    1d22:	11 96       	adiw	r26, 0x01	; 1
    1d24:	8c 91       	ld	r24, X
    1d26:	01 e0       	ldi	r16, 0x01	; 1
    1d28:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    1d2c:	88 23       	and	r24, r24
    1d2e:	09 f0       	breq	.+2      	; 0x1d32 <chk_mounted+0x5da>
    1d30:	dd c0       	rjmp	.+442    	; 0x1eec <chk_mounted+0x794>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
    1d32:	f7 01       	movw	r30, r14
    1d34:	ef 5c       	subi	r30, 0xCF	; 207
    1d36:	fd 4f       	sbci	r31, 0xFD	; 253
    1d38:	30 81       	ld	r19, Z
    1d3a:	20 e0       	ldi	r18, 0x00	; 0
    1d3c:	f7 01       	movw	r30, r14
    1d3e:	e0 5d       	subi	r30, 0xD0	; 208
    1d40:	fd 4f       	sbci	r31, 0xFD	; 253
    1d42:	80 81       	ld	r24, Z
    1d44:	90 e0       	ldi	r25, 0x00	; 0
    1d46:	82 2b       	or	r24, r18
    1d48:	93 2b       	or	r25, r19

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    1d4a:	ba ea       	ldi	r27, 0xAA	; 170
    1d4c:	85 35       	cpi	r24, 0x55	; 85
    1d4e:	9b 07       	cpc	r25, r27
    1d50:	09 f0       	breq	.+2      	; 0x1d54 <chk_mounted+0x5fc>
    1d52:	cc c0       	rjmp	.+408    	; 0x1eec <chk_mounted+0x794>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
    1d54:	f7 01       	movw	r30, r14
    1d56:	45 a9       	sts	0x45, r20
    1d58:	50 e0       	ldi	r21, 0x00	; 0
    1d5a:	60 e0       	ldi	r22, 0x00	; 0
    1d5c:	70 e0       	ldi	r23, 0x00	; 0
    1d5e:	74 2f       	mov	r23, r20
    1d60:	66 27       	eor	r22, r22
    1d62:	55 27       	eor	r21, r21
    1d64:	44 27       	eor	r20, r20
    1d66:	84 a9       	sts	0x44, r24
    1d68:	90 e0       	ldi	r25, 0x00	; 0
    1d6a:	a0 e0       	ldi	r26, 0x00	; 0
    1d6c:	b0 e0       	ldi	r27, 0x00	; 0
    1d6e:	dc 01       	movw	r26, r24
    1d70:	99 27       	eor	r25, r25
    1d72:	88 27       	eor	r24, r24
    1d74:	48 2b       	or	r20, r24
    1d76:	59 2b       	or	r21, r25
    1d78:	6a 2b       	or	r22, r26
    1d7a:	7b 2b       	or	r23, r27
    1d7c:	82 a9       	sts	0x42, r24
    1d7e:	90 e0       	ldi	r25, 0x00	; 0
    1d80:	a0 e0       	ldi	r26, 0x00	; 0
    1d82:	b0 e0       	ldi	r27, 0x00	; 0
    1d84:	48 2b       	or	r20, r24
    1d86:	59 2b       	or	r21, r25
    1d88:	6a 2b       	or	r22, r26
    1d8a:	7b 2b       	or	r23, r27
    1d8c:	93 a9       	sts	0x43, r25
    1d8e:	80 e0       	ldi	r24, 0x00	; 0
    1d90:	a0 e0       	ldi	r26, 0x00	; 0
    1d92:	b0 e0       	ldi	r27, 0x00	; 0
    1d94:	84 2b       	or	r24, r20
    1d96:	95 2b       	or	r25, r21
    1d98:	a6 2b       	or	r26, r22
    1d9a:	b7 2b       	or	r27, r23
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
    1d9c:	82 35       	cpi	r24, 0x52	; 82
    1d9e:	f2 e5       	ldi	r31, 0x52	; 82
    1da0:	9f 07       	cpc	r25, r31
    1da2:	f1 e6       	ldi	r31, 0x61	; 97
    1da4:	af 07       	cpc	r26, r31
    1da6:	f1 e4       	ldi	r31, 0x41	; 65
    1da8:	bf 07       	cpc	r27, r31
    1daa:	09 f0       	breq	.+2      	; 0x1dae <chk_mounted+0x656>
    1dac:	9f c0       	rjmp	.+318    	; 0x1eec <chk_mounted+0x794>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
    1dae:	f7 01       	movw	r30, r14
    1db0:	e7 5e       	subi	r30, 0xE7	; 231
    1db2:	fd 4f       	sbci	r31, 0xFD	; 253
    1db4:	80 81       	ld	r24, Z
    1db6:	90 e0       	ldi	r25, 0x00	; 0
    1db8:	a0 e0       	ldi	r26, 0x00	; 0
    1dba:	b0 e0       	ldi	r27, 0x00	; 0
    1dbc:	b8 2f       	mov	r27, r24
    1dbe:	aa 27       	eor	r26, r26
    1dc0:	99 27       	eor	r25, r25
    1dc2:	88 27       	eor	r24, r24
    1dc4:	f7 01       	movw	r30, r14
    1dc6:	e8 5e       	subi	r30, 0xE8	; 232
    1dc8:	fd 4f       	sbci	r31, 0xFD	; 253
    1dca:	40 81       	ld	r20, Z
    1dcc:	50 e0       	ldi	r21, 0x00	; 0
    1dce:	60 e0       	ldi	r22, 0x00	; 0
    1dd0:	70 e0       	ldi	r23, 0x00	; 0
    1dd2:	ba 01       	movw	r22, r20
    1dd4:	55 27       	eor	r21, r21
    1dd6:	44 27       	eor	r20, r20
    1dd8:	84 2b       	or	r24, r20
    1dda:	95 2b       	or	r25, r21
    1ddc:	a6 2b       	or	r26, r22
    1dde:	b7 2b       	or	r27, r23
    1de0:	f7 01       	movw	r30, r14
    1de2:	ea 5e       	subi	r30, 0xEA	; 234
    1de4:	fd 4f       	sbci	r31, 0xFD	; 253
    1de6:	40 81       	ld	r20, Z
    1de8:	50 e0       	ldi	r21, 0x00	; 0
    1dea:	60 e0       	ldi	r22, 0x00	; 0
    1dec:	70 e0       	ldi	r23, 0x00	; 0
    1dee:	48 2b       	or	r20, r24
    1df0:	59 2b       	or	r21, r25
    1df2:	6a 2b       	or	r22, r26
    1df4:	7b 2b       	or	r23, r27
    1df6:	f7 01       	movw	r30, r14
    1df8:	e9 5e       	subi	r30, 0xE9	; 233
    1dfa:	fd 4f       	sbci	r31, 0xFD	; 253
    1dfc:	90 81       	ld	r25, Z
    1dfe:	80 e0       	ldi	r24, 0x00	; 0
    1e00:	a0 e0       	ldi	r26, 0x00	; 0
    1e02:	b0 e0       	ldi	r27, 0x00	; 0
    1e04:	84 2b       	or	r24, r20
    1e06:	95 2b       	or	r25, r21
    1e08:	a6 2b       	or	r26, r22
    1e0a:	b7 2b       	or	r27, r23
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
    1e0c:	82 37       	cpi	r24, 0x72	; 114
    1e0e:	02 e7       	ldi	r16, 0x72	; 114
    1e10:	90 07       	cpc	r25, r16
    1e12:	01 e4       	ldi	r16, 0x41	; 65
    1e14:	a0 07       	cpc	r26, r16
    1e16:	01 e6       	ldi	r16, 0x61	; 97
    1e18:	b0 07       	cpc	r27, r16
    1e1a:	09 f0       	breq	.+2      	; 0x1e1e <chk_mounted+0x6c6>
    1e1c:	67 c0       	rjmp	.+206    	; 0x1eec <chk_mounted+0x794>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
    1e1e:	f7 01       	movw	r30, r14
    1e20:	ef 5d       	subi	r30, 0xDF	; 223
    1e22:	fd 4f       	sbci	r31, 0xFD	; 253
    1e24:	80 81       	ld	r24, Z
    1e26:	90 e0       	ldi	r25, 0x00	; 0
    1e28:	a0 e0       	ldi	r26, 0x00	; 0
    1e2a:	b0 e0       	ldi	r27, 0x00	; 0
    1e2c:	b8 2f       	mov	r27, r24
    1e2e:	aa 27       	eor	r26, r26
    1e30:	99 27       	eor	r25, r25
    1e32:	88 27       	eor	r24, r24
    1e34:	f7 01       	movw	r30, r14
    1e36:	e0 5e       	subi	r30, 0xE0	; 224
    1e38:	fd 4f       	sbci	r31, 0xFD	; 253
    1e3a:	40 81       	ld	r20, Z
    1e3c:	50 e0       	ldi	r21, 0x00	; 0
    1e3e:	60 e0       	ldi	r22, 0x00	; 0
    1e40:	70 e0       	ldi	r23, 0x00	; 0
    1e42:	ba 01       	movw	r22, r20
    1e44:	55 27       	eor	r21, r21
    1e46:	44 27       	eor	r20, r20
    1e48:	84 2b       	or	r24, r20
    1e4a:	95 2b       	or	r25, r21
    1e4c:	a6 2b       	or	r26, r22
    1e4e:	b7 2b       	or	r27, r23
    1e50:	f7 01       	movw	r30, r14
    1e52:	e2 5e       	subi	r30, 0xE2	; 226
    1e54:	fd 4f       	sbci	r31, 0xFD	; 253
    1e56:	40 81       	ld	r20, Z
    1e58:	50 e0       	ldi	r21, 0x00	; 0
    1e5a:	60 e0       	ldi	r22, 0x00	; 0
    1e5c:	70 e0       	ldi	r23, 0x00	; 0
    1e5e:	48 2b       	or	r20, r24
    1e60:	59 2b       	or	r21, r25
    1e62:	6a 2b       	or	r22, r26
    1e64:	7b 2b       	or	r23, r27
    1e66:	f7 01       	movw	r30, r14
    1e68:	e1 5e       	subi	r30, 0xE1	; 225
    1e6a:	fd 4f       	sbci	r31, 0xFD	; 253
    1e6c:	90 81       	ld	r25, Z
    1e6e:	80 e0       	ldi	r24, 0x00	; 0
    1e70:	a0 e0       	ldi	r26, 0x00	; 0
    1e72:	b0 e0       	ldi	r27, 0x00	; 0
    1e74:	84 2b       	or	r24, r20
    1e76:	95 2b       	or	r25, r21
    1e78:	a6 2b       	or	r26, r22
    1e7a:	b7 2b       	or	r27, r23
    1e7c:	f7 01       	movw	r30, r14
    1e7e:	82 87       	std	Z+10, r24	; 0x0a
    1e80:	93 87       	std	Z+11, r25	; 0x0b
    1e82:	a4 87       	std	Z+12, r26	; 0x0c
    1e84:	b5 87       	std	Z+13, r27	; 0x0d
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
    1e86:	e3 5e       	subi	r30, 0xE3	; 227
    1e88:	fd 4f       	sbci	r31, 0xFD	; 253
    1e8a:	80 81       	ld	r24, Z
    1e8c:	90 e0       	ldi	r25, 0x00	; 0
    1e8e:	a0 e0       	ldi	r26, 0x00	; 0
    1e90:	b0 e0       	ldi	r27, 0x00	; 0
    1e92:	b8 2f       	mov	r27, r24
    1e94:	aa 27       	eor	r26, r26
    1e96:	99 27       	eor	r25, r25
    1e98:	88 27       	eor	r24, r24
    1e9a:	f7 01       	movw	r30, r14
    1e9c:	e4 5e       	subi	r30, 0xE4	; 228
    1e9e:	fd 4f       	sbci	r31, 0xFD	; 253
    1ea0:	40 81       	ld	r20, Z
    1ea2:	50 e0       	ldi	r21, 0x00	; 0
    1ea4:	60 e0       	ldi	r22, 0x00	; 0
    1ea6:	70 e0       	ldi	r23, 0x00	; 0
    1ea8:	ba 01       	movw	r22, r20
    1eaa:	55 27       	eor	r21, r21
    1eac:	44 27       	eor	r20, r20
    1eae:	84 2b       	or	r24, r20
    1eb0:	95 2b       	or	r25, r21
    1eb2:	a6 2b       	or	r26, r22
    1eb4:	b7 2b       	or	r27, r23
    1eb6:	f7 01       	movw	r30, r14
    1eb8:	e6 5e       	subi	r30, 0xE6	; 230
    1eba:	fd 4f       	sbci	r31, 0xFD	; 253
    1ebc:	40 81       	ld	r20, Z
    1ebe:	50 e0       	ldi	r21, 0x00	; 0
    1ec0:	60 e0       	ldi	r22, 0x00	; 0
    1ec2:	70 e0       	ldi	r23, 0x00	; 0
    1ec4:	48 2b       	or	r20, r24
    1ec6:	59 2b       	or	r21, r25
    1ec8:	6a 2b       	or	r22, r26
    1eca:	7b 2b       	or	r23, r27
    1ecc:	f7 01       	movw	r30, r14
    1ece:	e5 5e       	subi	r30, 0xE5	; 229
    1ed0:	fd 4f       	sbci	r31, 0xFD	; 253
    1ed2:	90 81       	ld	r25, Z
    1ed4:	80 e0       	ldi	r24, 0x00	; 0
    1ed6:	a0 e0       	ldi	r26, 0x00	; 0
    1ed8:	b0 e0       	ldi	r27, 0x00	; 0
    1eda:	84 2b       	or	r24, r20
    1edc:	95 2b       	or	r25, r21
    1ede:	a6 2b       	or	r26, r22
    1ee0:	b7 2b       	or	r27, r23
    1ee2:	f7 01       	movw	r30, r14
    1ee4:	86 87       	std	Z+14, r24	; 0x0e
    1ee6:	97 87       	std	Z+15, r25	; 0x0f
    1ee8:	a0 8b       	std	Z+16, r26	; 0x10
    1eea:	b1 8b       	std	Z+17, r27	; 0x11
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
    1eec:	d7 01       	movw	r26, r14
    1eee:	dc 92       	st	X, r13
	fs->id = ++Fsid;		/* File system mount ID */
    1ef0:	80 91 f6 03 	lds	r24, 0x03F6
    1ef4:	90 91 f7 03 	lds	r25, 0x03F7
    1ef8:	01 96       	adiw	r24, 0x01	; 1
    1efa:	90 93 f7 03 	sts	0x03F7, r25
    1efe:	80 93 f6 03 	sts	0x03F6, r24
    1f02:	17 96       	adiw	r26, 0x07	; 7
    1f04:	9c 93       	st	X, r25
    1f06:	8e 93       	st	-X, r24
    1f08:	16 97       	sbiw	r26, 0x06	; 6
	fs->winsect = 0;		/* Invalidate sector cache */
    1f0a:	f7 01       	movw	r30, r14
    1f0c:	16 a6       	lds	r17, 0xb6
    1f0e:	17 a6       	lds	r17, 0xb7
    1f10:	10 aa       	sts	0x90, r17
    1f12:	11 aa       	sts	0x91, r17
	fs->wflag = 0;
    1f14:	14 82       	std	Z+4, r1	; 0x04
#if _FS_RPATH
	fs->cdir = 0;			/* Current directory (root dir) */
    1f16:	56 96       	adiw	r26, 0x16	; 22
    1f18:	1d 92       	st	X+, r1
    1f1a:	1d 92       	st	X+, r1
    1f1c:	1d 92       	st	X+, r1
    1f1e:	1c 92       	st	X, r1
    1f20:	59 97       	sbiw	r26, 0x19	; 25
#endif
#if _FS_LOCK				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
    1f22:	80 e0       	ldi	r24, 0x00	; 0
    1f24:	27 c0       	rjmp	.+78     	; 0x1f74 <chk_mounted+0x81c>
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
    1f26:	8b e0       	ldi	r24, 0x0B	; 11
    1f28:	25 c0       	rjmp	.+74     	; 0x1f74 <chk_mounted+0x81c>
	fs = FatFs[vol];					/* Get corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    1f2a:	8c e0       	ldi	r24, 0x0C	; 12
    1f2c:	23 c0       	rjmp	.+70     	; 0x1f74 <chk_mounted+0x81c>
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
    1f2e:	80 e0       	ldi	r24, 0x00	; 0
    1f30:	21 c0       	rjmp	.+66     	; 0x1f74 <chk_mounted+0x81c>
	*rfs = fs;							/* Return pointer to the corresponding file system object */
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
    1f32:	8a e0       	ldi	r24, 0x0A	; 10
    1f34:	1f c0       	rjmp	.+62     	; 0x1f74 <chk_mounted+0x81c>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
    1f36:	83 e0       	ldi	r24, 0x03	; 3
    1f38:	1d c0       	rjmp	.+58     	; 0x1f74 <chk_mounted+0x81c>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
    1f3a:	8a e0       	ldi	r24, 0x0A	; 10
    1f3c:	1b c0       	rjmp	.+54     	; 0x1f74 <chk_mounted+0x81c>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    1f3e:	8d e0       	ldi	r24, 0x0D	; 13
    1f40:	19 c0       	rjmp	.+50     	; 0x1f74 <chk_mounted+0x81c>
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    1f42:	81 e0       	ldi	r24, 0x01	; 1
    1f44:	17 c0       	rjmp	.+46     	; 0x1f74 <chk_mounted+0x81c>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    1f46:	8d e0       	ldi	r24, 0x0D	; 13
    1f48:	15 c0       	rjmp	.+42     	; 0x1f74 <chk_mounted+0x81c>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;
    1f4a:	8d e0       	ldi	r24, 0x0D	; 13
    1f4c:	13 c0       	rjmp	.+38     	; 0x1f74 <chk_mounted+0x81c>
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    1f4e:	8d e0       	ldi	r24, 0x0D	; 13
    1f50:	11 c0       	rjmp	.+34     	; 0x1f74 <chk_mounted+0x81c>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    1f52:	8d e0       	ldi	r24, 0x0D	; 13
    1f54:	0f c0       	rjmp	.+30     	; 0x1f74 <chk_mounted+0x81c>
    1f56:	8d e0       	ldi	r24, 0x0D	; 13
    1f58:	0d c0       	rjmp	.+26     	; 0x1f74 <chk_mounted+0x81c>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    1f5a:	8d e0       	ldi	r24, 0x0D	; 13
    1f5c:	0b c0       	rjmp	.+22     	; 0x1f74 <chk_mounted+0x81c>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    1f5e:	8d e0       	ldi	r24, 0x0D	; 13
    1f60:	09 c0       	rjmp	.+18     	; 0x1f74 <chk_mounted+0x81c>

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    1f62:	8d e0       	ldi	r24, 0x0D	; 13
    1f64:	07 c0       	rjmp	.+14     	; 0x1f74 <chk_mounted+0x81c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    1f66:	8d e0       	ldi	r24, 0x0D	; 13
    1f68:	05 c0       	rjmp	.+10     	; 0x1f74 <chk_mounted+0x81c>
	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    1f6a:	8d e0       	ldi	r24, 0x0D	; 13
    1f6c:	03 c0       	rjmp	.+6      	; 0x1f74 <chk_mounted+0x81c>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    1f6e:	8d e0       	ldi	r24, 0x0D	; 13
    1f70:	01 c0       	rjmp	.+2      	; 0x1f74 <chk_mounted+0x81c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;
    1f72:	8d e0       	ldi	r24, 0x0D	; 13
#if _FS_LOCK				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
}
    1f74:	60 96       	adiw	r28, 0x10	; 16
    1f76:	0f b6       	in	r0, 0x3f	; 63
    1f78:	f8 94       	cli
    1f7a:	de bf       	out	0x3e, r29	; 62
    1f7c:	0f be       	out	0x3f, r0	; 63
    1f7e:	cd bf       	out	0x3d, r28	; 61
    1f80:	df 91       	pop	r29
    1f82:	cf 91       	pop	r28
    1f84:	1f 91       	pop	r17
    1f86:	0f 91       	pop	r16
    1f88:	ff 90       	pop	r15
    1f8a:	ef 90       	pop	r14
    1f8c:	df 90       	pop	r13
    1f8e:	cf 90       	pop	r12
    1f90:	bf 90       	pop	r11
    1f92:	af 90       	pop	r10
    1f94:	9f 90       	pop	r9
    1f96:	8f 90       	pop	r8
    1f98:	7f 90       	pop	r7
    1f9a:	6f 90       	pop	r6
    1f9c:	5f 90       	pop	r5
    1f9e:	4f 90       	pop	r4
    1fa0:	3f 90       	pop	r3
    1fa2:	2f 90       	pop	r2
    1fa4:	08 95       	ret
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    1fa6:	b9 01       	movw	r22, r18
    1fa8:	a8 01       	movw	r20, r16
    1faa:	4e 5f       	subi	r20, 0xFE	; 254
    1fac:	5f 4f       	sbci	r21, 0xFF	; 255
    1fae:	6f 4f       	sbci	r22, 0xFF	; 255
    1fb0:	7f 4f       	sbci	r23, 0xFF	; 255
    1fb2:	f7 01       	movw	r30, r14
    1fb4:	42 8f       	std	Z+26, r20	; 0x1a
    1fb6:	53 8f       	std	Z+27, r21	; 0x1b
    1fb8:	64 8f       	std	Z+28, r22	; 0x1c
    1fba:	75 8f       	std	Z+29, r23	; 0x1d
	fs->database = bsect + sysect;						/* Data start sector */
    1fbc:	8d 81       	ldd	r24, Y+5	; 0x05
    1fbe:	9e 81       	ldd	r25, Y+6	; 0x06
    1fc0:	af 81       	ldd	r26, Y+7	; 0x07
    1fc2:	b8 85       	ldd	r27, Y+8	; 0x08
    1fc4:	88 0d       	add	r24, r8
    1fc6:	99 1d       	adc	r25, r9
    1fc8:	aa 1d       	adc	r26, r10
    1fca:	bb 1d       	adc	r27, r11
    1fcc:	82 a7       	lds	r24, 0x72
    1fce:	93 a7       	lds	r25, 0x73
    1fd0:	a4 a7       	lds	r26, 0x74
    1fd2:	b5 a7       	lds	r27, 0x75
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    1fd4:	89 85       	ldd	r24, Y+9	; 0x09
    1fd6:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fd8:	ab 85       	ldd	r26, Y+11	; 0x0b
    1fda:	bc 85       	ldd	r27, Y+12	; 0x0c
    1fdc:	88 0d       	add	r24, r8
    1fde:	99 1d       	adc	r25, r9
    1fe0:	aa 1d       	adc	r26, r10
    1fe2:	bb 1d       	adc	r27, r11
    1fe4:	82 a3       	lds	r24, 0x52
    1fe6:	93 a3       	lds	r25, 0x53
    1fe8:	a4 a3       	lds	r26, 0x54
    1fea:	b5 a3       	lds	r27, 0x55
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    1fec:	0f 2e       	mov	r0, r31
    1fee:	f3 e0       	ldi	r31, 0x03	; 3
    1ff0:	df 2e       	mov	r13, r31
    1ff2:	f0 2d       	mov	r31, r0
    1ff4:	e3 cd       	rjmp	.-1082   	; 0x1bbc <chk_mounted+0x464>

00001ff6 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
    1ff6:	4f 92       	push	r4
    1ff8:	5f 92       	push	r5
    1ffa:	6f 92       	push	r6
    1ffc:	7f 92       	push	r7
    1ffe:	8f 92       	push	r8
    2000:	9f 92       	push	r9
    2002:	af 92       	push	r10
    2004:	bf 92       	push	r11
    2006:	cf 92       	push	r12
    2008:	df 92       	push	r13
    200a:	ef 92       	push	r14
    200c:	ff 92       	push	r15
    200e:	0f 93       	push	r16
    2010:	cf 93       	push	r28
    2012:	5c 01       	movw	r10, r24
    2014:	2a 01       	movw	r4, r20
    2016:	3b 01       	movw	r6, r22
	DWORD wsect;


	wsect = fs->winsect;
    2018:	fc 01       	movw	r30, r24
    201a:	c6 a4       	lds	r28, 0xa6
    201c:	d7 a4       	lds	r29, 0xa7
    201e:	e0 a8       	sts	0x00, r30
    2020:	f1 a8       	sts	0x81, r31
	if (wsect != sector) {	/* Changed current window */
    2022:	c4 16       	cp	r12, r20
    2024:	d5 06       	cpc	r13, r21
    2026:	e6 06       	cpc	r14, r22
    2028:	f7 06       	cpc	r15, r23
    202a:	09 f4       	brne	.+2      	; 0x202e <move_window+0x38>
    202c:	54 c0       	rjmp	.+168    	; 0x20d6 <move_window+0xe0>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
    202e:	84 81       	ldd	r24, Z+4	; 0x04
    2030:	88 23       	and	r24, r24
    2032:	d1 f1       	breq	.+116    	; 0x20a8 <move_window+0xb2>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    2034:	0f 2e       	mov	r0, r31
    2036:	f2 e3       	ldi	r31, 0x32	; 50
    2038:	8f 2e       	mov	r8, r31
    203a:	99 24       	eor	r9, r9
    203c:	f0 2d       	mov	r31, r0
    203e:	8a 0c       	add	r8, r10
    2040:	9b 1c       	adc	r9, r11
    2042:	81 81       	ldd	r24, Z+1	; 0x01
    2044:	b4 01       	movw	r22, r8
    2046:	a7 01       	movw	r20, r14
    2048:	96 01       	movw	r18, r12
    204a:	01 e0       	ldi	r16, 0x01	; 1
    204c:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    2050:	88 23       	and	r24, r24
    2052:	09 f0       	breq	.+2      	; 0x2056 <move_window+0x60>
    2054:	42 c0       	rjmp	.+132    	; 0x20da <move_window+0xe4>
				return FR_DISK_ERR;
			fs->wflag = 0;
    2056:	f5 01       	movw	r30, r10
    2058:	14 82       	std	Z+4, r1	; 0x04
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    205a:	46 8d       	ldd	r20, Z+30	; 0x1e
    205c:	57 8d       	ldd	r21, Z+31	; 0x1f
    205e:	60 a1       	lds	r22, 0x40
    2060:	71 a1       	lds	r23, 0x41
    2062:	82 a1       	lds	r24, 0x42
    2064:	93 a1       	lds	r25, 0x43
    2066:	a4 a1       	lds	r26, 0x44
    2068:	b5 a1       	lds	r27, 0x45
    206a:	84 0f       	add	r24, r20
    206c:	95 1f       	adc	r25, r21
    206e:	a6 1f       	adc	r26, r22
    2070:	b7 1f       	adc	r27, r23
    2072:	c8 16       	cp	r12, r24
    2074:	d9 06       	cpc	r13, r25
    2076:	ea 06       	cpc	r14, r26
    2078:	fb 06       	cpc	r15, r27
    207a:	b0 f4       	brcc	.+44     	; 0x20a8 <move_window+0xb2>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    207c:	c3 81       	ldd	r28, Z+3	; 0x03
    207e:	c2 30       	cpi	r28, 0x02	; 2
    2080:	98 f0       	brcs	.+38     	; 0x20a8 <move_window+0xb2>
					wsect += fs->fsize;
    2082:	f5 01       	movw	r30, r10
    2084:	86 8d       	ldd	r24, Z+30	; 0x1e
    2086:	97 8d       	ldd	r25, Z+31	; 0x1f
    2088:	a0 a1       	lds	r26, 0x40
    208a:	b1 a1       	lds	r27, 0x41
    208c:	c8 0e       	add	r12, r24
    208e:	d9 1e       	adc	r13, r25
    2090:	ea 1e       	adc	r14, r26
    2092:	fb 1e       	adc	r15, r27
					disk_write(fs->drv, fs->win, wsect, 1);
    2094:	81 81       	ldd	r24, Z+1	; 0x01
    2096:	b4 01       	movw	r22, r8
    2098:	a7 01       	movw	r20, r14
    209a:	96 01       	movw	r18, r12
    209c:	01 e0       	ldi	r16, 0x01	; 1
    209e:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    20a2:	c1 50       	subi	r28, 0x01	; 1
    20a4:	c1 30       	cpi	r28, 0x01	; 1
    20a6:	69 f7       	brne	.-38     	; 0x2082 <move_window+0x8c>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
    20a8:	41 14       	cp	r4, r1
    20aa:	51 04       	cpc	r5, r1
    20ac:	61 04       	cpc	r6, r1
    20ae:	71 04       	cpc	r7, r1
    20b0:	b1 f0       	breq	.+44     	; 0x20de <move_window+0xe8>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    20b2:	b5 01       	movw	r22, r10
    20b4:	6e 5c       	subi	r22, 0xCE	; 206
    20b6:	7f 4f       	sbci	r23, 0xFF	; 255
    20b8:	f5 01       	movw	r30, r10
    20ba:	81 81       	ldd	r24, Z+1	; 0x01
    20bc:	a3 01       	movw	r20, r6
    20be:	92 01       	movw	r18, r4
    20c0:	01 e0       	ldi	r16, 0x01	; 1
    20c2:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    20c6:	88 23       	and	r24, r24
    20c8:	61 f4       	brne	.+24     	; 0x20e2 <move_window+0xec>
				return FR_DISK_ERR;
			fs->winsect = sector;
    20ca:	f5 01       	movw	r30, r10
    20cc:	46 a6       	lds	r20, 0xb6
    20ce:	57 a6       	lds	r21, 0xb7
    20d0:	60 aa       	sts	0x90, r22
    20d2:	71 aa       	sts	0x91, r23
    20d4:	07 c0       	rjmp	.+14     	; 0x20e4 <move_window+0xee>
		}
	}

	return FR_OK;
    20d6:	80 e0       	ldi	r24, 0x00	; 0
    20d8:	05 c0       	rjmp	.+10     	; 0x20e4 <move_window+0xee>
	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
    20da:	81 e0       	ldi	r24, 0x01	; 1
    20dc:	03 c0       	rjmp	.+6      	; 0x20e4 <move_window+0xee>
				return FR_DISK_ERR;
			fs->winsect = sector;
		}
	}

	return FR_OK;
    20de:	80 e0       	ldi	r24, 0x00	; 0
    20e0:	01 c0       	rjmp	.+2      	; 0x20e4 <move_window+0xee>
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
    20e2:	81 e0       	ldi	r24, 0x01	; 1
			fs->winsect = sector;
		}
	}

	return FR_OK;
}
    20e4:	cf 91       	pop	r28
    20e6:	0f 91       	pop	r16
    20e8:	ff 90       	pop	r15
    20ea:	ef 90       	pop	r14
    20ec:	df 90       	pop	r13
    20ee:	cf 90       	pop	r12
    20f0:	bf 90       	pop	r11
    20f2:	af 90       	pop	r10
    20f4:	9f 90       	pop	r9
    20f6:	8f 90       	pop	r8
    20f8:	7f 90       	pop	r7
    20fa:	6f 90       	pop	r6
    20fc:	5f 90       	pop	r5
    20fe:	4f 90       	pop	r4
    2100:	08 95       	ret

00002102 <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
    2102:	ef 92       	push	r14
    2104:	ff 92       	push	r15
    2106:	0f 93       	push	r16
    2108:	1f 93       	push	r17
    210a:	cf 93       	push	r28
    210c:	7c 01       	movw	r14, r24
	FRESULT res;


	res = move_window(fs, 0);
    210e:	40 e0       	ldi	r20, 0x00	; 0
    2110:	50 e0       	ldi	r21, 0x00	; 0
    2112:	ba 01       	movw	r22, r20
    2114:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
    2118:	c8 2f       	mov	r28, r24
	if (res == FR_OK) {
    211a:	88 23       	and	r24, r24
    211c:	09 f0       	breq	.+2      	; 0x2120 <sync+0x1e>
    211e:	78 c0       	rjmp	.+240    	; 0x2210 <sync+0x10e>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    2120:	f7 01       	movw	r30, r14
    2122:	80 81       	ld	r24, Z
    2124:	83 30       	cpi	r24, 0x03	; 3
    2126:	09 f0       	breq	.+2      	; 0x212a <sync+0x28>
    2128:	6a c0       	rjmp	.+212    	; 0x21fe <sync+0xfc>
    212a:	85 81       	ldd	r24, Z+5	; 0x05
    212c:	88 23       	and	r24, r24
    212e:	09 f4       	brne	.+2      	; 0x2132 <sync+0x30>
    2130:	66 c0       	rjmp	.+204    	; 0x21fe <sync+0xfc>
			fs->winsect = 0;
    2132:	16 a6       	lds	r17, 0xb6
    2134:	17 a6       	lds	r17, 0xb7
    2136:	10 aa       	sts	0x90, r17
    2138:	11 aa       	sts	0x91, r17
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
    213a:	87 01       	movw	r16, r14
    213c:	0e 5c       	subi	r16, 0xCE	; 206
    213e:	1f 4f       	sbci	r17, 0xFF	; 255
    2140:	c8 01       	movw	r24, r16
    2142:	60 e0       	ldi	r22, 0x00	; 0
    2144:	70 e0       	ldi	r23, 0x00	; 0
    2146:	20 e0       	ldi	r18, 0x00	; 0
    2148:	32 e0       	ldi	r19, 0x02	; 2
    214a:	40 e0       	ldi	r20, 0x00	; 0
    214c:	50 e0       	ldi	r21, 0x00	; 0
    214e:	0e 94 1e 0a 	call	0x143c	; 0x143c <mem_set>
			ST_WORD(fs->win+BS_55AA, 0xAA55);
    2152:	f7 01       	movw	r30, r14
    2154:	e0 5d       	subi	r30, 0xD0	; 208
    2156:	fd 4f       	sbci	r31, 0xFD	; 253
    2158:	85 e5       	ldi	r24, 0x55	; 85
    215a:	80 83       	st	Z, r24
    215c:	f7 01       	movw	r30, r14
    215e:	ef 5c       	subi	r30, 0xCF	; 207
    2160:	fd 4f       	sbci	r31, 0xFD	; 253
    2162:	8a ea       	ldi	r24, 0xAA	; 170
    2164:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    2166:	82 e5       	ldi	r24, 0x52	; 82
    2168:	f7 01       	movw	r30, r14
    216a:	82 ab       	sts	0x52, r24
    216c:	83 ab       	sts	0x53, r24
    216e:	81 e6       	ldi	r24, 0x61	; 97
    2170:	84 ab       	sts	0x54, r24
    2172:	91 e4       	ldi	r25, 0x41	; 65
    2174:	95 ab       	sts	0x55, r25
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    2176:	ea 5e       	subi	r30, 0xEA	; 234
    2178:	fd 4f       	sbci	r31, 0xFD	; 253
    217a:	22 e7       	ldi	r18, 0x72	; 114
    217c:	20 83       	st	Z, r18
    217e:	f7 01       	movw	r30, r14
    2180:	e9 5e       	subi	r30, 0xE9	; 233
    2182:	fd 4f       	sbci	r31, 0xFD	; 253
    2184:	20 83       	st	Z, r18
    2186:	f7 01       	movw	r30, r14
    2188:	e8 5e       	subi	r30, 0xE8	; 232
    218a:	fd 4f       	sbci	r31, 0xFD	; 253
    218c:	90 83       	st	Z, r25
    218e:	f7 01       	movw	r30, r14
    2190:	e7 5e       	subi	r30, 0xE7	; 231
    2192:	fd 4f       	sbci	r31, 0xFD	; 253
    2194:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    2196:	f7 01       	movw	r30, r14
    2198:	36 85       	ldd	r19, Z+14	; 0x0e
    219a:	27 85       	ldd	r18, Z+15	; 0x0f
    219c:	90 89       	ldd	r25, Z+16	; 0x10
    219e:	81 89       	ldd	r24, Z+17	; 0x11
    21a0:	e6 5e       	subi	r30, 0xE6	; 230
    21a2:	fd 4f       	sbci	r31, 0xFD	; 253
    21a4:	30 83       	st	Z, r19
    21a6:	f7 01       	movw	r30, r14
    21a8:	e5 5e       	subi	r30, 0xE5	; 229
    21aa:	fd 4f       	sbci	r31, 0xFD	; 253
    21ac:	20 83       	st	Z, r18
    21ae:	f7 01       	movw	r30, r14
    21b0:	e4 5e       	subi	r30, 0xE4	; 228
    21b2:	fd 4f       	sbci	r31, 0xFD	; 253
    21b4:	90 83       	st	Z, r25
    21b6:	f7 01       	movw	r30, r14
    21b8:	e3 5e       	subi	r30, 0xE3	; 227
    21ba:	fd 4f       	sbci	r31, 0xFD	; 253
    21bc:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    21be:	f7 01       	movw	r30, r14
    21c0:	32 85       	ldd	r19, Z+10	; 0x0a
    21c2:	23 85       	ldd	r18, Z+11	; 0x0b
    21c4:	94 85       	ldd	r25, Z+12	; 0x0c
    21c6:	85 85       	ldd	r24, Z+13	; 0x0d
    21c8:	e2 5e       	subi	r30, 0xE2	; 226
    21ca:	fd 4f       	sbci	r31, 0xFD	; 253
    21cc:	30 83       	st	Z, r19
    21ce:	f7 01       	movw	r30, r14
    21d0:	e1 5e       	subi	r30, 0xE1	; 225
    21d2:	fd 4f       	sbci	r31, 0xFD	; 253
    21d4:	20 83       	st	Z, r18
    21d6:	f7 01       	movw	r30, r14
    21d8:	e0 5e       	subi	r30, 0xE0	; 224
    21da:	fd 4f       	sbci	r31, 0xFD	; 253
    21dc:	90 83       	st	Z, r25
    21de:	f7 01       	movw	r30, r14
    21e0:	ef 5d       	subi	r30, 0xDF	; 223
    21e2:	fd 4f       	sbci	r31, 0xFD	; 253
    21e4:	80 83       	st	Z, r24
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    21e6:	f7 01       	movw	r30, r14
    21e8:	22 89       	ldd	r18, Z+18	; 0x12
    21ea:	33 89       	ldd	r19, Z+19	; 0x13
    21ec:	44 89       	ldd	r20, Z+20	; 0x14
    21ee:	55 89       	ldd	r21, Z+21	; 0x15
    21f0:	81 81       	ldd	r24, Z+1	; 0x01
    21f2:	b8 01       	movw	r22, r16
    21f4:	01 e0       	ldi	r16, 0x01	; 1
    21f6:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
			fs->fsi_flag = 0;
    21fa:	f7 01       	movw	r30, r14
    21fc:	15 82       	std	Z+5, r1	; 0x05
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    21fe:	f7 01       	movw	r30, r14
    2200:	81 81       	ldd	r24, Z+1	; 0x01
    2202:	60 e0       	ldi	r22, 0x00	; 0
    2204:	40 e0       	ldi	r20, 0x00	; 0
    2206:	50 e0       	ldi	r21, 0x00	; 0
    2208:	0e 94 66 03 	call	0x6cc	; 0x6cc <disk_ioctl>
    220c:	81 11       	cpse	r24, r1
			res = FR_DISK_ERR;
    220e:	c1 e0       	ldi	r28, 0x01	; 1
	}

	return res;
}
    2210:	8c 2f       	mov	r24, r28
    2212:	cf 91       	pop	r28
    2214:	1f 91       	pop	r17
    2216:	0f 91       	pop	r16
    2218:	ff 90       	pop	r15
    221a:	ef 90       	pop	r14
    221c:	08 95       	ret

0000221e <get_fattime>:
#include "diskio.h"		/* Declarations of low level disk I/O functions */

DWORD get_fattime( void )
{
	return 0;
}
    221e:	60 e0       	ldi	r22, 0x00	; 0
    2220:	70 e0       	ldi	r23, 0x00	; 0
    2222:	cb 01       	movw	r24, r22
    2224:	08 95       	ret

00002226 <clust2sect>:

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
    2226:	0f 93       	push	r16
    2228:	1f 93       	push	r17
    222a:	cf 93       	push	r28
    222c:	df 93       	push	r29
    222e:	ec 01       	movw	r28, r24
    2230:	db 01       	movw	r26, r22
    2232:	ca 01       	movw	r24, r20
	clst -= 2;
    2234:	02 97       	sbiw	r24, 0x02	; 2
    2236:	a1 09       	sbc	r26, r1
    2238:	b1 09       	sbc	r27, r1
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    223a:	4a 8d       	ldd	r20, Y+26	; 0x1a
    223c:	5b 8d       	ldd	r21, Y+27	; 0x1b
    223e:	6c 8d       	ldd	r22, Y+28	; 0x1c
    2240:	7d 8d       	ldd	r23, Y+29	; 0x1d
    2242:	42 50       	subi	r20, 0x02	; 2
    2244:	50 40       	sbci	r21, 0x00	; 0
    2246:	60 40       	sbci	r22, 0x00	; 0
    2248:	70 40       	sbci	r23, 0x00	; 0
    224a:	84 17       	cp	r24, r20
    224c:	95 07       	cpc	r25, r21
    224e:	a6 07       	cpc	r26, r22
    2250:	b7 07       	cpc	r27, r23
    2252:	98 f4       	brcc	.+38     	; 0x227a <clust2sect+0x54>
	return clst * fs->csize + fs->database;
    2254:	2a 81       	ldd	r18, Y+2	; 0x02
    2256:	30 e0       	ldi	r19, 0x00	; 0
    2258:	40 e0       	ldi	r20, 0x00	; 0
    225a:	50 e0       	ldi	r21, 0x00	; 0
    225c:	bc 01       	movw	r22, r24
    225e:	cd 01       	movw	r24, r26
    2260:	0e 94 58 2b 	call	0x56b0	; 0x56b0 <__mulsi3>
    2264:	8b 01       	movw	r16, r22
    2266:	9c 01       	movw	r18, r24
    2268:	8a a5       	lds	r24, 0x6a
    226a:	9b a5       	lds	r25, 0x6b
    226c:	ac a5       	lds	r26, 0x6c
    226e:	bd a5       	lds	r27, 0x6d
    2270:	08 0f       	add	r16, r24
    2272:	19 1f       	adc	r17, r25
    2274:	2a 1f       	adc	r18, r26
    2276:	3b 1f       	adc	r19, r27
    2278:	03 c0       	rjmp	.+6      	; 0x2280 <clust2sect+0x5a>
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    227a:	00 e0       	ldi	r16, 0x00	; 0
    227c:	10 e0       	ldi	r17, 0x00	; 0
    227e:	98 01       	movw	r18, r16
	return clst * fs->csize + fs->database;
}
    2280:	60 2f       	mov	r22, r16
    2282:	71 2f       	mov	r23, r17
    2284:	82 2f       	mov	r24, r18
    2286:	93 2f       	mov	r25, r19
    2288:	df 91       	pop	r29
    228a:	cf 91       	pop	r28
    228c:	1f 91       	pop	r17
    228e:	0f 91       	pop	r16
    2290:	08 95       	ret

00002292 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
    2292:	8f 92       	push	r8
    2294:	9f 92       	push	r9
    2296:	af 92       	push	r10
    2298:	bf 92       	push	r11
    229a:	cf 92       	push	r12
    229c:	df 92       	push	r13
    229e:	ef 92       	push	r14
    22a0:	ff 92       	push	r15
    22a2:	0f 93       	push	r16
    22a4:	1f 93       	push	r17
    22a6:	cf 93       	push	r28
    22a8:	df 93       	push	r29
    22aa:	ec 01       	movw	r28, r24
    22ac:	6a 01       	movw	r12, r20
    22ae:	7b 01       	movw	r14, r22
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
    22b0:	42 30       	cpi	r20, 0x02	; 2
    22b2:	51 05       	cpc	r21, r1
    22b4:	61 05       	cpc	r22, r1
    22b6:	71 05       	cpc	r23, r1
    22b8:	08 f4       	brcc	.+2      	; 0x22bc <get_fat+0x2a>
    22ba:	f4 c0       	rjmp	.+488    	; 0x24a4 <get_fat+0x212>
    22bc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22be:	9b 8d       	ldd	r25, Y+27	; 0x1b
    22c0:	ac 8d       	ldd	r26, Y+28	; 0x1c
    22c2:	bd 8d       	ldd	r27, Y+29	; 0x1d
    22c4:	48 17       	cp	r20, r24
    22c6:	59 07       	cpc	r21, r25
    22c8:	6a 07       	cpc	r22, r26
    22ca:	7b 07       	cpc	r23, r27
    22cc:	08 f0       	brcs	.+2      	; 0x22d0 <get_fat+0x3e>
    22ce:	ef c0       	rjmp	.+478    	; 0x24ae <get_fat+0x21c>
		return 1;

	switch (fs->fs_type) {
    22d0:	88 81       	ld	r24, Y
    22d2:	82 30       	cpi	r24, 0x02	; 2
    22d4:	09 f4       	brne	.+2      	; 0x22d8 <get_fat+0x46>
    22d6:	81 c0       	rjmp	.+258    	; 0x23da <get_fat+0x148>
    22d8:	83 30       	cpi	r24, 0x03	; 3
    22da:	09 f4       	brne	.+2      	; 0x22de <get_fat+0x4c>
    22dc:	a0 c0       	rjmp	.+320    	; 0x241e <get_fat+0x18c>
    22de:	81 30       	cpi	r24, 0x01	; 1
    22e0:	09 f0       	breq	.+2      	; 0x22e4 <get_fat+0x52>
    22e2:	ea c0       	rjmp	.+468    	; 0x24b8 <get_fat+0x226>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
    22e4:	4a 01       	movw	r8, r20
    22e6:	5b 01       	movw	r10, r22
    22e8:	b6 94       	lsr	r11
    22ea:	a7 94       	ror	r10
    22ec:	97 94       	ror	r9
    22ee:	87 94       	ror	r8
    22f0:	84 0e       	add	r8, r20
    22f2:	95 1e       	adc	r9, r21
    22f4:	a6 1e       	adc	r10, r22
    22f6:	b7 1e       	adc	r11, r23
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    22f8:	b5 01       	movw	r22, r10
    22fa:	a4 01       	movw	r20, r8
    22fc:	03 2e       	mov	r0, r19
    22fe:	39 e0       	ldi	r19, 0x09	; 9
    2300:	76 95       	lsr	r23
    2302:	67 95       	ror	r22
    2304:	57 95       	ror	r21
    2306:	47 95       	ror	r20
    2308:	3a 95       	dec	r19
    230a:	d1 f7       	brne	.-12     	; 0x2300 <get_fat+0x6e>
    230c:	30 2d       	mov	r19, r0
    230e:	8a a1       	lds	r24, 0x4a
    2310:	9b a1       	lds	r25, 0x4b
    2312:	ac a1       	lds	r26, 0x4c
    2314:	bd a1       	lds	r27, 0x4d
    2316:	48 0f       	add	r20, r24
    2318:	59 1f       	adc	r21, r25
    231a:	6a 1f       	adc	r22, r26
    231c:	7b 1f       	adc	r23, r27
    231e:	ce 01       	movw	r24, r28
    2320:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
    2324:	88 23       	and	r24, r24
    2326:	09 f0       	breq	.+2      	; 0x232a <get_fat+0x98>
    2328:	cb c0       	rjmp	.+406    	; 0x24c0 <get_fat+0x22e>
		wc = fs->win[bc % SS(fs)]; bc++;
    232a:	d5 01       	movw	r26, r10
    232c:	c4 01       	movw	r24, r8
    232e:	91 70       	andi	r25, 0x01	; 1
    2330:	a0 70       	andi	r26, 0x00	; 0
    2332:	b0 70       	andi	r27, 0x00	; 0
    2334:	fe 01       	movw	r30, r28
    2336:	e8 0f       	add	r30, r24
    2338:	f9 1f       	adc	r31, r25
    233a:	12 a9       	sts	0x42, r17
    233c:	08 94       	sec
    233e:	81 1c       	adc	r8, r1
    2340:	91 1c       	adc	r9, r1
    2342:	a1 1c       	adc	r10, r1
    2344:	b1 1c       	adc	r11, r1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    2346:	b5 01       	movw	r22, r10
    2348:	a4 01       	movw	r20, r8
    234a:	03 2e       	mov	r0, r19
    234c:	39 e0       	ldi	r19, 0x09	; 9
    234e:	76 95       	lsr	r23
    2350:	67 95       	ror	r22
    2352:	57 95       	ror	r21
    2354:	47 95       	ror	r20
    2356:	3a 95       	dec	r19
    2358:	d1 f7       	brne	.-12     	; 0x234e <get_fat+0xbc>
    235a:	30 2d       	mov	r19, r0
    235c:	8a a1       	lds	r24, 0x4a
    235e:	9b a1       	lds	r25, 0x4b
    2360:	ac a1       	lds	r26, 0x4c
    2362:	bd a1       	lds	r27, 0x4d
    2364:	48 0f       	add	r20, r24
    2366:	59 1f       	adc	r21, r25
    2368:	6a 1f       	adc	r22, r26
    236a:	7b 1f       	adc	r23, r27
    236c:	ce 01       	movw	r24, r28
    236e:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
    2372:	88 23       	and	r24, r24
    2374:	09 f0       	breq	.+2      	; 0x2378 <get_fat+0xe6>
    2376:	a8 c0       	rjmp	.+336    	; 0x24c8 <get_fat+0x236>

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
    2378:	41 2f       	mov	r20, r17
    237a:	50 e0       	ldi	r21, 0x00	; 0
    237c:	60 e0       	ldi	r22, 0x00	; 0
    237e:	70 e0       	ldi	r23, 0x00	; 0
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
    2380:	8f ef       	ldi	r24, 0xFF	; 255
    2382:	91 e0       	ldi	r25, 0x01	; 1
    2384:	a0 e0       	ldi	r26, 0x00	; 0
    2386:	b0 e0       	ldi	r27, 0x00	; 0
    2388:	88 22       	and	r8, r24
    238a:	99 22       	and	r9, r25
    238c:	aa 22       	and	r10, r26
    238e:	bb 22       	and	r11, r27
    2390:	fe 01       	movw	r30, r28
    2392:	e8 0d       	add	r30, r8
    2394:	f9 1d       	adc	r31, r9
    2396:	92 a9       	sts	0x42, r25
    2398:	80 e0       	ldi	r24, 0x00	; 0
    239a:	8c 01       	movw	r16, r24
    239c:	22 27       	eor	r18, r18
    239e:	17 fd       	sbrc	r17, 7
    23a0:	20 95       	com	r18
    23a2:	32 2f       	mov	r19, r18
    23a4:	40 2b       	or	r20, r16
    23a6:	51 2b       	or	r21, r17
    23a8:	62 2b       	or	r22, r18
    23aa:	73 2b       	or	r23, r19
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    23ac:	91 e0       	ldi	r25, 0x01	; 1
    23ae:	c9 22       	and	r12, r25
    23b0:	dd 24       	eor	r13, r13
    23b2:	c1 14       	cp	r12, r1
    23b4:	d1 04       	cpc	r13, r1
    23b6:	59 f0       	breq	.+22     	; 0x23ce <get_fat+0x13c>
    23b8:	8a 01       	movw	r16, r20
    23ba:	9b 01       	movw	r18, r22
    23bc:	68 94       	set
    23be:	13 f8       	bld	r1, 3
    23c0:	36 95       	lsr	r19
    23c2:	27 95       	ror	r18
    23c4:	17 95       	ror	r17
    23c6:	07 95       	ror	r16
    23c8:	16 94       	lsr	r1
    23ca:	d1 f7       	brne	.-12     	; 0x23c0 <get_fat+0x12e>
    23cc:	88 c0       	rjmp	.+272    	; 0x24de <get_fat+0x24c>
    23ce:	8a 01       	movw	r16, r20
    23d0:	9b 01       	movw	r18, r22
    23d2:	1f 70       	andi	r17, 0x0F	; 15
    23d4:	20 70       	andi	r18, 0x00	; 0
    23d6:	30 70       	andi	r19, 0x00	; 0
    23d8:	82 c0       	rjmp	.+260    	; 0x24de <get_fat+0x24c>

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    23da:	45 2f       	mov	r20, r21
    23dc:	56 2f       	mov	r21, r22
    23de:	67 2f       	mov	r22, r23
    23e0:	77 27       	eor	r23, r23
    23e2:	8a a1       	lds	r24, 0x4a
    23e4:	9b a1       	lds	r25, 0x4b
    23e6:	ac a1       	lds	r26, 0x4c
    23e8:	bd a1       	lds	r27, 0x4d
    23ea:	48 0f       	add	r20, r24
    23ec:	59 1f       	adc	r21, r25
    23ee:	6a 1f       	adc	r22, r26
    23f0:	7b 1f       	adc	r23, r27
    23f2:	ce 01       	movw	r24, r28
    23f4:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
    23f8:	88 23       	and	r24, r24
    23fa:	09 f0       	breq	.+2      	; 0x23fe <get_fat+0x16c>
    23fc:	69 c0       	rjmp	.+210    	; 0x24d0 <get_fat+0x23e>
		p = &fs->win[clst * 2 % SS(fs)];
    23fe:	f6 01       	movw	r30, r12
    2400:	ee 0f       	add	r30, r30
    2402:	ff 1f       	adc	r31, r31
    2404:	f1 70       	andi	r31, 0x01	; 1
		return LD_WORD(p);
    2406:	ce 0f       	add	r28, r30
    2408:	df 1f       	adc	r29, r31
    240a:	9b a9       	sts	0x4b, r25
    240c:	80 e0       	ldi	r24, 0x00	; 0
    240e:	0a a9       	sts	0x4a, r16
    2410:	10 e0       	ldi	r17, 0x00	; 0
    2412:	80 2b       	or	r24, r16
    2414:	91 2b       	or	r25, r17
    2416:	8c 01       	movw	r16, r24
    2418:	20 e0       	ldi	r18, 0x00	; 0
    241a:	30 e0       	ldi	r19, 0x00	; 0
    241c:	60 c0       	rjmp	.+192    	; 0x24de <get_fat+0x24c>

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    241e:	68 94       	set
    2420:	16 f8       	bld	r1, 6
    2422:	76 95       	lsr	r23
    2424:	67 95       	ror	r22
    2426:	57 95       	ror	r21
    2428:	47 95       	ror	r20
    242a:	16 94       	lsr	r1
    242c:	d1 f7       	brne	.-12     	; 0x2422 <get_fat+0x190>
    242e:	8a a1       	lds	r24, 0x4a
    2430:	9b a1       	lds	r25, 0x4b
    2432:	ac a1       	lds	r26, 0x4c
    2434:	bd a1       	lds	r27, 0x4d
    2436:	48 0f       	add	r20, r24
    2438:	59 1f       	adc	r21, r25
    243a:	6a 1f       	adc	r22, r26
    243c:	7b 1f       	adc	r23, r27
    243e:	ce 01       	movw	r24, r28
    2440:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
    2444:	88 23       	and	r24, r24
    2446:	09 f0       	breq	.+2      	; 0x244a <get_fat+0x1b8>
    2448:	47 c0       	rjmp	.+142    	; 0x24d8 <get_fat+0x246>
		p = &fs->win[clst * 4 % SS(fs)];
    244a:	f6 01       	movw	r30, r12
    244c:	ee 0f       	add	r30, r30
    244e:	ff 1f       	adc	r31, r31
    2450:	ee 0f       	add	r30, r30
    2452:	ff 1f       	adc	r31, r31
    2454:	f1 70       	andi	r31, 0x01	; 1
		return LD_DWORD(p) & 0x0FFFFFFF;
    2456:	ce 0f       	add	r28, r30
    2458:	df 1f       	adc	r29, r31
    245a:	0d a9       	sts	0x4d, r16
    245c:	10 e0       	ldi	r17, 0x00	; 0
    245e:	20 e0       	ldi	r18, 0x00	; 0
    2460:	30 e0       	ldi	r19, 0x00	; 0
    2462:	30 2f       	mov	r19, r16
    2464:	22 27       	eor	r18, r18
    2466:	11 27       	eor	r17, r17
    2468:	00 27       	eor	r16, r16
    246a:	8c a9       	sts	0x4c, r24
    246c:	90 e0       	ldi	r25, 0x00	; 0
    246e:	a0 e0       	ldi	r26, 0x00	; 0
    2470:	b0 e0       	ldi	r27, 0x00	; 0
    2472:	dc 01       	movw	r26, r24
    2474:	99 27       	eor	r25, r25
    2476:	88 27       	eor	r24, r24
    2478:	08 2b       	or	r16, r24
    247a:	19 2b       	or	r17, r25
    247c:	2a 2b       	or	r18, r26
    247e:	3b 2b       	or	r19, r27
    2480:	8a a9       	sts	0x4a, r24
    2482:	90 e0       	ldi	r25, 0x00	; 0
    2484:	a0 e0       	ldi	r26, 0x00	; 0
    2486:	b0 e0       	ldi	r27, 0x00	; 0
    2488:	08 2b       	or	r16, r24
    248a:	19 2b       	or	r17, r25
    248c:	2a 2b       	or	r18, r26
    248e:	3b 2b       	or	r19, r27
    2490:	9b a9       	sts	0x4b, r25
    2492:	80 e0       	ldi	r24, 0x00	; 0
    2494:	a0 e0       	ldi	r26, 0x00	; 0
    2496:	b0 e0       	ldi	r27, 0x00	; 0
    2498:	08 2b       	or	r16, r24
    249a:	19 2b       	or	r17, r25
    249c:	2a 2b       	or	r18, r26
    249e:	3b 2b       	or	r19, r27
    24a0:	3f 70       	andi	r19, 0x0F	; 15
    24a2:	1d c0       	rjmp	.+58     	; 0x24de <get_fat+0x24c>
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;
    24a4:	01 e0       	ldi	r16, 0x01	; 1
    24a6:	10 e0       	ldi	r17, 0x00	; 0
    24a8:	20 e0       	ldi	r18, 0x00	; 0
    24aa:	30 e0       	ldi	r19, 0x00	; 0
    24ac:	18 c0       	rjmp	.+48     	; 0x24de <get_fat+0x24c>
    24ae:	01 e0       	ldi	r16, 0x01	; 1
    24b0:	10 e0       	ldi	r17, 0x00	; 0
    24b2:	20 e0       	ldi	r18, 0x00	; 0
    24b4:	30 e0       	ldi	r19, 0x00	; 0
    24b6:	13 c0       	rjmp	.+38     	; 0x24de <get_fat+0x24c>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    24b8:	0f ef       	ldi	r16, 0xFF	; 255
    24ba:	1f ef       	ldi	r17, 0xFF	; 255
    24bc:	98 01       	movw	r18, r16
    24be:	0f c0       	rjmp	.+30     	; 0x24de <get_fat+0x24c>
    24c0:	0f ef       	ldi	r16, 0xFF	; 255
    24c2:	1f ef       	ldi	r17, 0xFF	; 255
    24c4:	98 01       	movw	r18, r16
    24c6:	0b c0       	rjmp	.+22     	; 0x24de <get_fat+0x24c>
    24c8:	0f ef       	ldi	r16, 0xFF	; 255
    24ca:	1f ef       	ldi	r17, 0xFF	; 255
    24cc:	98 01       	movw	r18, r16
    24ce:	07 c0       	rjmp	.+14     	; 0x24de <get_fat+0x24c>
    24d0:	0f ef       	ldi	r16, 0xFF	; 255
    24d2:	1f ef       	ldi	r17, 0xFF	; 255
    24d4:	98 01       	movw	r18, r16
    24d6:	03 c0       	rjmp	.+6      	; 0x24de <get_fat+0x24c>
    24d8:	0f ef       	ldi	r16, 0xFF	; 255
    24da:	1f ef       	ldi	r17, 0xFF	; 255
    24dc:	98 01       	movw	r18, r16
}
    24de:	60 2f       	mov	r22, r16
    24e0:	71 2f       	mov	r23, r17
    24e2:	82 2f       	mov	r24, r18
    24e4:	93 2f       	mov	r25, r19
    24e6:	df 91       	pop	r29
    24e8:	cf 91       	pop	r28
    24ea:	1f 91       	pop	r17
    24ec:	0f 91       	pop	r16
    24ee:	ff 90       	pop	r15
    24f0:	ef 90       	pop	r14
    24f2:	df 90       	pop	r13
    24f4:	cf 90       	pop	r12
    24f6:	bf 90       	pop	r11
    24f8:	af 90       	pop	r10
    24fa:	9f 90       	pop	r9
    24fc:	8f 90       	pop	r8
    24fe:	08 95       	ret

00002500 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Index of directory table */
)
{
    2500:	ef 92       	push	r14
    2502:	ff 92       	push	r15
    2504:	0f 93       	push	r16
    2506:	1f 93       	push	r17
    2508:	cf 93       	push	r28
    250a:	df 93       	push	r29
    250c:	ec 01       	movw	r28, r24
    250e:	8b 01       	movw	r16, r22
	DWORD clst;
	WORD ic;


	dj->index = idx;
    2510:	7d 83       	std	Y+5, r23	; 0x05
    2512:	6c 83       	std	Y+4, r22	; 0x04
	clst = dj->sclust;
    2514:	4e 81       	ldd	r20, Y+6	; 0x06
    2516:	5f 81       	ldd	r21, Y+7	; 0x07
    2518:	68 85       	ldd	r22, Y+8	; 0x08
    251a:	79 85       	ldd	r23, Y+9	; 0x09
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    251c:	41 30       	cpi	r20, 0x01	; 1
    251e:	51 05       	cpc	r21, r1
    2520:	61 05       	cpc	r22, r1
    2522:	71 05       	cpc	r23, r1
    2524:	09 f4       	brne	.+2      	; 0x2528 <dir_sdi+0x28>
    2526:	9f c0       	rjmp	.+318    	; 0x2666 <dir_sdi+0x166>
    2528:	e8 81       	ld	r30, Y
    252a:	f9 81       	ldd	r31, Y+1	; 0x01
    252c:	82 8d       	ldd	r24, Z+26	; 0x1a
    252e:	93 8d       	ldd	r25, Z+27	; 0x1b
    2530:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2532:	b5 8d       	ldd	r27, Z+29	; 0x1d
    2534:	48 17       	cp	r20, r24
    2536:	59 07       	cpc	r21, r25
    2538:	6a 07       	cpc	r22, r26
    253a:	7b 07       	cpc	r23, r27
    253c:	08 f0       	brcs	.+2      	; 0x2540 <dir_sdi+0x40>
    253e:	95 c0       	rjmp	.+298    	; 0x266a <dir_sdi+0x16a>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    2540:	41 15       	cp	r20, r1
    2542:	51 05       	cpc	r21, r1
    2544:	61 05       	cpc	r22, r1
    2546:	71 05       	cpc	r23, r1
    2548:	69 f5       	brne	.+90     	; 0x25a4 <dir_sdi+0xa4>
    254a:	80 81       	ld	r24, Z
    254c:	83 30       	cpi	r24, 0x03	; 3
    254e:	49 f4       	brne	.+18     	; 0x2562 <dir_sdi+0x62>
		clst = dj->fs->dirbase;
    2550:	46 a1       	lds	r20, 0x46
    2552:	57 a1       	lds	r21, 0x47
    2554:	60 a5       	lds	r22, 0x60
    2556:	71 a5       	lds	r23, 0x61

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    2558:	41 15       	cp	r20, r1
    255a:	51 05       	cpc	r21, r1
    255c:	61 05       	cpc	r22, r1
    255e:	71 05       	cpc	r23, r1
    2560:	09 f5       	brne	.+66     	; 0x25a4 <dir_sdi+0xa4>
		dj->clust = clst;
    2562:	1a 86       	std	Y+10, r1	; 0x0a
    2564:	1b 86       	std	Y+11, r1	; 0x0b
    2566:	1c 86       	std	Y+12, r1	; 0x0c
    2568:	1d 86       	std	Y+13, r1	; 0x0d
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    256a:	80 85       	ldd	r24, Z+8	; 0x08
    256c:	91 85       	ldd	r25, Z+9	; 0x09
    256e:	08 17       	cp	r16, r24
    2570:	19 07       	cpc	r17, r25
    2572:	08 f0       	brcs	.+2      	; 0x2576 <dir_sdi+0x76>
    2574:	7c c0       	rjmp	.+248    	; 0x266e <dir_sdi+0x16e>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    2576:	c8 01       	movw	r24, r16
    2578:	92 95       	swap	r25
    257a:	82 95       	swap	r24
    257c:	8f 70       	andi	r24, 0x0F	; 15
    257e:	89 27       	eor	r24, r25
    2580:	9f 70       	andi	r25, 0x0F	; 15
    2582:	89 27       	eor	r24, r25
    2584:	ac 01       	movw	r20, r24
    2586:	60 e0       	ldi	r22, 0x00	; 0
    2588:	70 e0       	ldi	r23, 0x00	; 0
    258a:	86 a1       	lds	r24, 0x46
    258c:	97 a1       	lds	r25, 0x47
    258e:	a0 a5       	lds	r26, 0x60
    2590:	b1 a5       	lds	r27, 0x61
    2592:	84 0f       	add	r24, r20
    2594:	95 1f       	adc	r25, r21
    2596:	a6 1f       	adc	r26, r22
    2598:	b7 1f       	adc	r27, r23
    259a:	8e 87       	std	Y+14, r24	; 0x0e
    259c:	9f 87       	std	Y+15, r25	; 0x0f
    259e:	a8 8b       	std	Y+16, r26	; 0x10
    25a0:	b9 8b       	std	Y+17, r27	; 0x11
    25a2:	4e c0       	rjmp	.+156    	; 0x2640 <dir_sdi+0x140>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    25a4:	82 81       	ldd	r24, Z+2	; 0x02
    25a6:	90 e0       	ldi	r25, 0x00	; 0
    25a8:	7c 01       	movw	r14, r24
    25aa:	ee 0c       	add	r14, r14
    25ac:	ff 1c       	adc	r15, r15
    25ae:	ee 0c       	add	r14, r14
    25b0:	ff 1c       	adc	r15, r15
    25b2:	ee 0c       	add	r14, r14
    25b4:	ff 1c       	adc	r15, r15
    25b6:	ee 0c       	add	r14, r14
    25b8:	ff 1c       	adc	r15, r15
		while (idx >= ic) {	/* Follow cluster chain */
    25ba:	0e 15       	cp	r16, r14
    25bc:	1f 05       	cpc	r17, r15
    25be:	28 f1       	brcs	.+74     	; 0x260a <dir_sdi+0x10a>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    25c0:	88 81       	ld	r24, Y
    25c2:	99 81       	ldd	r25, Y+1	; 0x01
    25c4:	0e 94 49 11 	call	0x2292	; 0x2292 <get_fat>
    25c8:	ab 01       	movw	r20, r22
    25ca:	bc 01       	movw	r22, r24
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    25cc:	4f 3f       	cpi	r20, 0xFF	; 255
    25ce:	8f ef       	ldi	r24, 0xFF	; 255
    25d0:	58 07       	cpc	r21, r24
    25d2:	8f ef       	ldi	r24, 0xFF	; 255
    25d4:	68 07       	cpc	r22, r24
    25d6:	8f ef       	ldi	r24, 0xFF	; 255
    25d8:	78 07       	cpc	r23, r24
    25da:	09 f4       	brne	.+2      	; 0x25de <dir_sdi+0xde>
    25dc:	4a c0       	rjmp	.+148    	; 0x2672 <dir_sdi+0x172>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    25de:	42 30       	cpi	r20, 0x02	; 2
    25e0:	51 05       	cpc	r21, r1
    25e2:	61 05       	cpc	r22, r1
    25e4:	71 05       	cpc	r23, r1
    25e6:	08 f4       	brcc	.+2      	; 0x25ea <dir_sdi+0xea>
    25e8:	46 c0       	rjmp	.+140    	; 0x2676 <dir_sdi+0x176>
    25ea:	e8 81       	ld	r30, Y
    25ec:	f9 81       	ldd	r31, Y+1	; 0x01
    25ee:	82 8d       	ldd	r24, Z+26	; 0x1a
    25f0:	93 8d       	ldd	r25, Z+27	; 0x1b
    25f2:	a4 8d       	ldd	r26, Z+28	; 0x1c
    25f4:	b5 8d       	ldd	r27, Z+29	; 0x1d
    25f6:	48 17       	cp	r20, r24
    25f8:	59 07       	cpc	r21, r25
    25fa:	6a 07       	cpc	r22, r26
    25fc:	7b 07       	cpc	r23, r27
    25fe:	e8 f5       	brcc	.+122    	; 0x267a <dir_sdi+0x17a>
				return FR_INT_ERR;
			idx -= ic;
    2600:	0e 19       	sub	r16, r14
    2602:	1f 09       	sbc	r17, r15
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
    2604:	0e 15       	cp	r16, r14
    2606:	1f 05       	cpc	r17, r15
    2608:	d8 f6       	brcc	.-74     	; 0x25c0 <dir_sdi+0xc0>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
    260a:	4a 87       	std	Y+10, r20	; 0x0a
    260c:	5b 87       	std	Y+11, r21	; 0x0b
    260e:	6c 87       	std	Y+12, r22	; 0x0c
    2610:	7d 87       	std	Y+13, r23	; 0x0d
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    2612:	88 81       	ld	r24, Y
    2614:	99 81       	ldd	r25, Y+1	; 0x01
    2616:	0e 94 13 11 	call	0x2226	; 0x2226 <clust2sect>
    261a:	ab 01       	movw	r20, r22
    261c:	bc 01       	movw	r22, r24
    261e:	c8 01       	movw	r24, r16
    2620:	92 95       	swap	r25
    2622:	82 95       	swap	r24
    2624:	8f 70       	andi	r24, 0x0F	; 15
    2626:	89 27       	eor	r24, r25
    2628:	9f 70       	andi	r25, 0x0F	; 15
    262a:	89 27       	eor	r24, r25
    262c:	a0 e0       	ldi	r26, 0x00	; 0
    262e:	b0 e0       	ldi	r27, 0x00	; 0
    2630:	84 0f       	add	r24, r20
    2632:	95 1f       	adc	r25, r21
    2634:	a6 1f       	adc	r26, r22
    2636:	b7 1f       	adc	r27, r23
    2638:	8e 87       	std	Y+14, r24	; 0x0e
    263a:	9f 87       	std	Y+15, r25	; 0x0f
    263c:	a8 8b       	std	Y+16, r26	; 0x10
    263e:	b9 8b       	std	Y+17, r27	; 0x11
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    2640:	88 81       	ld	r24, Y
    2642:	99 81       	ldd	r25, Y+1	; 0x01
    2644:	c2 96       	adiw	r24, 0x32	; 50
    2646:	0f 70       	andi	r16, 0x0F	; 15
    2648:	10 70       	andi	r17, 0x00	; 0
    264a:	00 0f       	add	r16, r16
    264c:	11 1f       	adc	r17, r17
    264e:	02 95       	swap	r16
    2650:	12 95       	swap	r17
    2652:	10 7f       	andi	r17, 0xF0	; 240
    2654:	10 27       	eor	r17, r16
    2656:	00 7f       	andi	r16, 0xF0	; 240
    2658:	10 27       	eor	r17, r16
    265a:	80 0f       	add	r24, r16
    265c:	91 1f       	adc	r25, r17
    265e:	9b 8b       	std	Y+19, r25	; 0x13
    2660:	8a 8b       	std	Y+18, r24	; 0x12

	return FR_OK;	/* Seek succeeded */
    2662:	80 e0       	ldi	r24, 0x00	; 0
    2664:	0b c0       	rjmp	.+22     	; 0x267c <dir_sdi+0x17c>


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
    2666:	82 e0       	ldi	r24, 0x02	; 2
    2668:	09 c0       	rjmp	.+18     	; 0x267c <dir_sdi+0x17c>
    266a:	82 e0       	ldi	r24, 0x02	; 2
    266c:	07 c0       	rjmp	.+14     	; 0x267c <dir_sdi+0x17c>
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
    266e:	82 e0       	ldi	r24, 0x02	; 2
    2670:	05 c0       	rjmp	.+10     	; 0x267c <dir_sdi+0x17c>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    2672:	81 e0       	ldi	r24, 0x01	; 1
    2674:	03 c0       	rjmp	.+6      	; 0x267c <dir_sdi+0x17c>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
    2676:	82 e0       	ldi	r24, 0x02	; 2
    2678:	01 c0       	rjmp	.+2      	; 0x267c <dir_sdi+0x17c>
    267a:	82 e0       	ldi	r24, 0x02	; 2
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
    267c:	df 91       	pop	r29
    267e:	cf 91       	pop	r28
    2680:	1f 91       	pop	r17
    2682:	0f 91       	pop	r16
    2684:	ff 90       	pop	r15
    2686:	ef 90       	pop	r14
    2688:	08 95       	ret

0000268a <dir_remove>:
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
	DIR *dj				/* Directory object pointing the entry to be removed */
)
{
    268a:	cf 93       	push	r28
    268c:	df 93       	push	r29
    268e:	ec 01       	movw	r28, r24
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
	}

#else			/* Non LFN configuration */
	res = dir_sdi(dj, dj->index);
    2690:	6c 81       	ldd	r22, Y+4	; 0x04
    2692:	7d 81       	ldd	r23, Y+5	; 0x05
    2694:	0e 94 80 12 	call	0x2500	; 0x2500 <dir_sdi>
	if (res == FR_OK) {
    2698:	88 23       	and	r24, r24
    269a:	91 f4       	brne	.+36     	; 0x26c0 <dir_remove+0x36>
		res = move_window(dj->fs, dj->sect);
    269c:	4e 85       	ldd	r20, Y+14	; 0x0e
    269e:	5f 85       	ldd	r21, Y+15	; 0x0f
    26a0:	68 89       	ldd	r22, Y+16	; 0x10
    26a2:	79 89       	ldd	r23, Y+17	; 0x11
    26a4:	88 81       	ld	r24, Y
    26a6:	99 81       	ldd	r25, Y+1	; 0x01
    26a8:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
		if (res == FR_OK) {
    26ac:	88 23       	and	r24, r24
    26ae:	41 f4       	brne	.+16     	; 0x26c0 <dir_remove+0x36>
			*dj->dir = DDE;			/* Mark the entry "deleted" */
    26b0:	ea 89       	ldd	r30, Y+18	; 0x12
    26b2:	fb 89       	ldd	r31, Y+19	; 0x13
    26b4:	95 ee       	ldi	r25, 0xE5	; 229
    26b6:	90 83       	st	Z, r25
			dj->fs->wflag = 1;
    26b8:	e8 81       	ld	r30, Y
    26ba:	f9 81       	ldd	r31, Y+1	; 0x01
    26bc:	91 e0       	ldi	r25, 0x01	; 1
    26be:	94 83       	std	Z+4, r25	; 0x04
		}
	}
#endif

	return res;
}
    26c0:	df 91       	pop	r29
    26c2:	cf 91       	pop	r28
    26c4:	08 95       	ret

000026c6 <put_fat>:
FRESULT put_fat (
	FATFS *fs,	/* File system object */
	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
	DWORD val	/* New value to mark the cluster */
)
{
    26c6:	4f 92       	push	r4
    26c8:	5f 92       	push	r5
    26ca:	6f 92       	push	r6
    26cc:	7f 92       	push	r7
    26ce:	8f 92       	push	r8
    26d0:	9f 92       	push	r9
    26d2:	af 92       	push	r10
    26d4:	bf 92       	push	r11
    26d6:	cf 92       	push	r12
    26d8:	df 92       	push	r13
    26da:	ef 92       	push	r14
    26dc:	ff 92       	push	r15
    26de:	0f 93       	push	r16
    26e0:	1f 93       	push	r17
    26e2:	cf 93       	push	r28
    26e4:	df 93       	push	r29
    26e6:	ec 01       	movw	r28, r24
    26e8:	6a 01       	movw	r12, r20
    26ea:	7b 01       	movw	r14, r22
    26ec:	48 01       	movw	r8, r16
    26ee:	59 01       	movw	r10, r18
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    26f0:	42 30       	cpi	r20, 0x02	; 2
    26f2:	51 05       	cpc	r21, r1
    26f4:	61 05       	cpc	r22, r1
    26f6:	71 05       	cpc	r23, r1
    26f8:	08 f4       	brcc	.+2      	; 0x26fc <put_fat+0x36>
    26fa:	e0 c0       	rjmp	.+448    	; 0x28bc <put_fat+0x1f6>
    26fc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    26fe:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2700:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2702:	bd 8d       	ldd	r27, Y+29	; 0x1d
    2704:	48 17       	cp	r20, r24
    2706:	59 07       	cpc	r21, r25
    2708:	6a 07       	cpc	r22, r26
    270a:	7b 07       	cpc	r23, r27
    270c:	08 f0       	brcs	.+2      	; 0x2710 <put_fat+0x4a>
    270e:	d8 c0       	rjmp	.+432    	; 0x28c0 <put_fat+0x1fa>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
    2710:	88 81       	ld	r24, Y
    2712:	82 30       	cpi	r24, 0x02	; 2
    2714:	09 f4       	brne	.+2      	; 0x2718 <put_fat+0x52>
    2716:	80 c0       	rjmp	.+256    	; 0x2818 <put_fat+0x152>
    2718:	83 30       	cpi	r24, 0x03	; 3
    271a:	09 f4       	brne	.+2      	; 0x271e <put_fat+0x58>
    271c:	98 c0       	rjmp	.+304    	; 0x284e <put_fat+0x188>
    271e:	81 30       	cpi	r24, 0x01	; 1
    2720:	09 f0       	breq	.+2      	; 0x2724 <put_fat+0x5e>
    2722:	c8 c0       	rjmp	.+400    	; 0x28b4 <put_fat+0x1ee>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
    2724:	db 01       	movw	r26, r22
    2726:	ca 01       	movw	r24, r20
    2728:	b6 95       	lsr	r27
    272a:	a7 95       	ror	r26
    272c:	97 95       	ror	r25
    272e:	87 95       	ror	r24
    2730:	2c 01       	movw	r4, r24
    2732:	3d 01       	movw	r6, r26
    2734:	44 0e       	add	r4, r20
    2736:	55 1e       	adc	r5, r21
    2738:	66 1e       	adc	r6, r22
    273a:	77 1e       	adc	r7, r23
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    273c:	b3 01       	movw	r22, r6
    273e:	a2 01       	movw	r20, r4
    2740:	03 2e       	mov	r0, r19
    2742:	39 e0       	ldi	r19, 0x09	; 9
    2744:	76 95       	lsr	r23
    2746:	67 95       	ror	r22
    2748:	57 95       	ror	r21
    274a:	47 95       	ror	r20
    274c:	3a 95       	dec	r19
    274e:	d1 f7       	brne	.-12     	; 0x2744 <put_fat+0x7e>
    2750:	30 2d       	mov	r19, r0
    2752:	8a a1       	lds	r24, 0x4a
    2754:	9b a1       	lds	r25, 0x4b
    2756:	ac a1       	lds	r26, 0x4c
    2758:	bd a1       	lds	r27, 0x4d
    275a:	48 0f       	add	r20, r24
    275c:	59 1f       	adc	r21, r25
    275e:	6a 1f       	adc	r22, r26
    2760:	7b 1f       	adc	r23, r27
    2762:	ce 01       	movw	r24, r28
    2764:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
			if (res != FR_OK) break;
    2768:	88 23       	and	r24, r24
    276a:	09 f0       	breq	.+2      	; 0x276e <put_fat+0xa8>
    276c:	a4 c0       	rjmp	.+328    	; 0x28b6 <put_fat+0x1f0>
			p = &fs->win[bc % SS(fs)];
    276e:	c2 01       	movw	r24, r4
    2770:	91 70       	andi	r25, 0x01	; 1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    2772:	31 e0       	ldi	r19, 0x01	; 1
    2774:	c3 22       	and	r12, r19
    2776:	dd 24       	eor	r13, r13
    2778:	c1 14       	cp	r12, r1
    277a:	d1 04       	cpc	r13, r1
    277c:	51 f0       	breq	.+20     	; 0x2792 <put_fat+0xcc>
    277e:	fe 01       	movw	r30, r28
    2780:	e8 0f       	add	r30, r24
    2782:	f9 1f       	adc	r31, r25
    2784:	22 a9       	sts	0x42, r18
    2786:	2f 70       	andi	r18, 0x0F	; 15
    2788:	38 2d       	mov	r19, r8
    278a:	32 95       	swap	r19
    278c:	30 7f       	andi	r19, 0xF0	; 240
    278e:	23 2b       	or	r18, r19
    2790:	01 c0       	rjmp	.+2      	; 0x2794 <put_fat+0xce>
    2792:	28 2d       	mov	r18, r8
    2794:	fe 01       	movw	r30, r28
    2796:	e8 0f       	add	r30, r24
    2798:	f9 1f       	adc	r31, r25
    279a:	22 ab       	sts	0x52, r18
			bc++;
    279c:	08 94       	sec
    279e:	41 1c       	adc	r4, r1
    27a0:	51 1c       	adc	r5, r1
    27a2:	61 1c       	adc	r6, r1
    27a4:	71 1c       	adc	r7, r1
			fs->wflag = 1;
    27a6:	81 e0       	ldi	r24, 0x01	; 1
    27a8:	8c 83       	std	Y+4, r24	; 0x04
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    27aa:	b3 01       	movw	r22, r6
    27ac:	a2 01       	movw	r20, r4
    27ae:	03 2e       	mov	r0, r19
    27b0:	39 e0       	ldi	r19, 0x09	; 9
    27b2:	76 95       	lsr	r23
    27b4:	67 95       	ror	r22
    27b6:	57 95       	ror	r21
    27b8:	47 95       	ror	r20
    27ba:	3a 95       	dec	r19
    27bc:	d1 f7       	brne	.-12     	; 0x27b2 <put_fat+0xec>
    27be:	30 2d       	mov	r19, r0
    27c0:	8a a1       	lds	r24, 0x4a
    27c2:	9b a1       	lds	r25, 0x4b
    27c4:	ac a1       	lds	r26, 0x4c
    27c6:	bd a1       	lds	r27, 0x4d
    27c8:	48 0f       	add	r20, r24
    27ca:	59 1f       	adc	r21, r25
    27cc:	6a 1f       	adc	r22, r26
    27ce:	7b 1f       	adc	r23, r27
    27d0:	ce 01       	movw	r24, r28
    27d2:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
			if (res != FR_OK) break;
    27d6:	88 23       	and	r24, r24
    27d8:	09 f0       	breq	.+2      	; 0x27dc <put_fat+0x116>
    27da:	6d c0       	rjmp	.+218    	; 0x28b6 <put_fat+0x1f0>
			p = &fs->win[bc % SS(fs)];
    27dc:	ef ef       	ldi	r30, 0xFF	; 255
    27de:	f1 e0       	ldi	r31, 0x01	; 1
    27e0:	4e 22       	and	r4, r30
    27e2:	5f 22       	and	r5, r31
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    27e4:	c1 14       	cp	r12, r1
    27e6:	d1 04       	cpc	r13, r1
    27e8:	49 f0       	breq	.+18     	; 0x27fc <put_fat+0x136>
    27ea:	68 94       	set
    27ec:	13 f8       	bld	r1, 3
    27ee:	b6 94       	lsr	r11
    27f0:	a7 94       	ror	r10
    27f2:	97 94       	ror	r9
    27f4:	87 94       	ror	r8
    27f6:	16 94       	lsr	r1
    27f8:	d1 f7       	brne	.-12     	; 0x27ee <put_fat+0x128>
    27fa:	09 c0       	rjmp	.+18     	; 0x280e <put_fat+0x148>
    27fc:	fe 01       	movw	r30, r28
    27fe:	e4 0d       	add	r30, r4
    2800:	f5 1d       	adc	r31, r5
    2802:	22 a9       	sts	0x42, r18
    2804:	20 7f       	andi	r18, 0xF0	; 240
    2806:	99 2d       	mov	r25, r9
    2808:	9f 70       	andi	r25, 0x0F	; 15
    280a:	82 2e       	mov	r8, r18
    280c:	89 2a       	or	r8, r25
    280e:	4c 0e       	add	r4, r28
    2810:	5d 1e       	adc	r5, r29
    2812:	f2 01       	movw	r30, r4
    2814:	82 aa       	sts	0x92, r24
			break;
    2816:	4f c0       	rjmp	.+158    	; 0x28b6 <put_fat+0x1f0>

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    2818:	45 2f       	mov	r20, r21
    281a:	56 2f       	mov	r21, r22
    281c:	67 2f       	mov	r22, r23
    281e:	77 27       	eor	r23, r23
    2820:	8a a1       	lds	r24, 0x4a
    2822:	9b a1       	lds	r25, 0x4b
    2824:	ac a1       	lds	r26, 0x4c
    2826:	bd a1       	lds	r27, 0x4d
    2828:	48 0f       	add	r20, r24
    282a:	59 1f       	adc	r21, r25
    282c:	6a 1f       	adc	r22, r26
    282e:	7b 1f       	adc	r23, r27
    2830:	ce 01       	movw	r24, r28
    2832:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
			if (res != FR_OK) break;
    2836:	88 23       	and	r24, r24
    2838:	09 f0       	breq	.+2      	; 0x283c <put_fat+0x176>
    283a:	3d c0       	rjmp	.+122    	; 0x28b6 <put_fat+0x1f0>
			p = &fs->win[clst * 2 % SS(fs)];
    283c:	f6 01       	movw	r30, r12
    283e:	ee 0f       	add	r30, r30
    2840:	ff 1f       	adc	r31, r31
    2842:	f1 70       	andi	r31, 0x01	; 1
			ST_WORD(p, (WORD)val);
    2844:	ec 0f       	add	r30, r28
    2846:	fd 1f       	adc	r31, r29
    2848:	82 aa       	sts	0x92, r24
    284a:	93 aa       	sts	0x93, r25
			break;
    284c:	34 c0       	rjmp	.+104    	; 0x28b6 <put_fat+0x1f0>

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    284e:	68 94       	set
    2850:	16 f8       	bld	r1, 6
    2852:	76 95       	lsr	r23
    2854:	67 95       	ror	r22
    2856:	57 95       	ror	r21
    2858:	47 95       	ror	r20
    285a:	16 94       	lsr	r1
    285c:	d1 f7       	brne	.-12     	; 0x2852 <put_fat+0x18c>
    285e:	8a a1       	lds	r24, 0x4a
    2860:	9b a1       	lds	r25, 0x4b
    2862:	ac a1       	lds	r26, 0x4c
    2864:	bd a1       	lds	r27, 0x4d
    2866:	48 0f       	add	r20, r24
    2868:	59 1f       	adc	r21, r25
    286a:	6a 1f       	adc	r22, r26
    286c:	7b 1f       	adc	r23, r27
    286e:	ce 01       	movw	r24, r28
    2870:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
			if (res != FR_OK) break;
    2874:	88 23       	and	r24, r24
    2876:	f9 f4       	brne	.+62     	; 0x28b6 <put_fat+0x1f0>
			p = &fs->win[clst * 4 % SS(fs)];
    2878:	96 01       	movw	r18, r12
    287a:	22 0f       	add	r18, r18
    287c:	33 1f       	adc	r19, r19
    287e:	22 0f       	add	r18, r18
    2880:	33 1f       	adc	r19, r19
    2882:	31 70       	andi	r19, 0x01	; 1
			val |= LD_DWORD(p) & 0xF0000000;
    2884:	fe 01       	movw	r30, r28
    2886:	e2 0f       	add	r30, r18
    2888:	f3 1f       	adc	r31, r19
    288a:	45 a9       	sts	0x45, r20
    288c:	50 e0       	ldi	r21, 0x00	; 0
    288e:	60 e0       	ldi	r22, 0x00	; 0
    2890:	70 e0       	ldi	r23, 0x00	; 0
    2892:	74 2f       	mov	r23, r20
    2894:	66 27       	eor	r22, r22
    2896:	55 27       	eor	r21, r21
    2898:	44 27       	eor	r20, r20
    289a:	40 70       	andi	r20, 0x00	; 0
    289c:	50 70       	andi	r21, 0x00	; 0
    289e:	60 70       	andi	r22, 0x00	; 0
    28a0:	70 7f       	andi	r23, 0xF0	; 240
    28a2:	48 29       	or	r20, r8
    28a4:	59 29       	or	r21, r9
    28a6:	6a 29       	or	r22, r10
    28a8:	7b 29       	or	r23, r11
			ST_DWORD(p, val);
    28aa:	42 ab       	sts	0x52, r20
    28ac:	53 ab       	sts	0x53, r21
    28ae:	64 ab       	sts	0x54, r22
    28b0:	75 ab       	sts	0x55, r23
			break;
    28b2:	01 c0       	rjmp	.+2      	; 0x28b6 <put_fat+0x1f0>

		default :
			res = FR_INT_ERR;
    28b4:	82 e0       	ldi	r24, 0x02	; 2
		}
		fs->wflag = 1;
    28b6:	91 e0       	ldi	r25, 0x01	; 1
    28b8:	9c 83       	std	Y+4, r25	; 0x04
    28ba:	03 c0       	rjmp	.+6      	; 0x28c2 <put_fat+0x1fc>
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
    28bc:	82 e0       	ldi	r24, 0x02	; 2
    28be:	01 c0       	rjmp	.+2      	; 0x28c2 <put_fat+0x1fc>
    28c0:	82 e0       	ldi	r24, 0x02	; 2
		}
		fs->wflag = 1;
	}

	return res;
}
    28c2:	df 91       	pop	r29
    28c4:	cf 91       	pop	r28
    28c6:	1f 91       	pop	r17
    28c8:	0f 91       	pop	r16
    28ca:	ff 90       	pop	r15
    28cc:	ef 90       	pop	r14
    28ce:	df 90       	pop	r13
    28d0:	cf 90       	pop	r12
    28d2:	bf 90       	pop	r11
    28d4:	af 90       	pop	r10
    28d6:	9f 90       	pop	r9
    28d8:	8f 90       	pop	r8
    28da:	7f 90       	pop	r7
    28dc:	6f 90       	pop	r6
    28de:	5f 90       	pop	r5
    28e0:	4f 90       	pop	r4
    28e2:	08 95       	ret

000028e4 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
    28e4:	2f 92       	push	r2
    28e6:	3f 92       	push	r3
    28e8:	4f 92       	push	r4
    28ea:	5f 92       	push	r5
    28ec:	6f 92       	push	r6
    28ee:	7f 92       	push	r7
    28f0:	8f 92       	push	r8
    28f2:	9f 92       	push	r9
    28f4:	af 92       	push	r10
    28f6:	bf 92       	push	r11
    28f8:	cf 92       	push	r12
    28fa:	df 92       	push	r13
    28fc:	ef 92       	push	r14
    28fe:	ff 92       	push	r15
    2900:	0f 93       	push	r16
    2902:	1f 93       	push	r17
    2904:	cf 93       	push	r28
    2906:	df 93       	push	r29
    2908:	00 d0       	rcall	.+0      	; 0x290a <create_chain+0x26>
    290a:	00 d0       	rcall	.+0      	; 0x290c <create_chain+0x28>
    290c:	cd b7       	in	r28, 0x3d	; 61
    290e:	de b7       	in	r29, 0x3e	; 62
    2910:	1c 01       	movw	r2, r24
    2912:	49 83       	std	Y+1, r20	; 0x01
    2914:	5a 83       	std	Y+2, r21	; 0x02
    2916:	6b 83       	std	Y+3, r22	; 0x03
    2918:	7c 83       	std	Y+4, r23	; 0x04
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
    291a:	41 15       	cp	r20, r1
    291c:	51 05       	cpc	r21, r1
    291e:	61 05       	cpc	r22, r1
    2920:	71 05       	cpc	r23, r1
    2922:	c1 f4       	brne	.+48     	; 0x2954 <create_chain+0x70>
		scl = fs->last_clust;			/* Get suggested start point */
    2924:	dc 01       	movw	r26, r24
    2926:	1a 96       	adiw	r26, 0x0a	; 10
    2928:	8d 90       	ld	r8, X+
    292a:	9d 90       	ld	r9, X+
    292c:	ad 90       	ld	r10, X+
    292e:	bc 90       	ld	r11, X
    2930:	1d 97       	sbiw	r26, 0x0d	; 13
		if (!scl || scl >= fs->n_fatent) scl = 1;
    2932:	81 14       	cp	r8, r1
    2934:	91 04       	cpc	r9, r1
    2936:	a1 04       	cpc	r10, r1
    2938:	b1 04       	cpc	r11, r1
    293a:	51 f1       	breq	.+84     	; 0x2990 <create_chain+0xac>
    293c:	5a 96       	adiw	r26, 0x1a	; 26
    293e:	8d 91       	ld	r24, X+
    2940:	9d 91       	ld	r25, X+
    2942:	0d 90       	ld	r0, X+
    2944:	bc 91       	ld	r27, X
    2946:	a0 2d       	mov	r26, r0
    2948:	88 16       	cp	r8, r24
    294a:	99 06       	cpc	r9, r25
    294c:	aa 06       	cpc	r10, r26
    294e:	bb 06       	cpc	r11, r27
    2950:	20 f5       	brcc	.+72     	; 0x299a <create_chain+0xb6>
    2952:	27 c0       	rjmp	.+78     	; 0x29a2 <create_chain+0xbe>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
    2954:	49 81       	ldd	r20, Y+1	; 0x01
    2956:	5a 81       	ldd	r21, Y+2	; 0x02
    2958:	6b 81       	ldd	r22, Y+3	; 0x03
    295a:	7c 81       	ldd	r23, Y+4	; 0x04
    295c:	0e 94 49 11 	call	0x2292	; 0x2292 <get_fat>
    2960:	8b 01       	movw	r16, r22
    2962:	9c 01       	movw	r18, r24
		if (cs < 2) return 1;			/* It is an invalid cluster */
    2964:	62 30       	cpi	r22, 0x02	; 2
    2966:	71 05       	cpc	r23, r1
    2968:	81 05       	cpc	r24, r1
    296a:	91 05       	cpc	r25, r1
    296c:	08 f4       	brcc	.+2      	; 0x2970 <create_chain+0x8c>
    296e:	ad c0       	rjmp	.+346    	; 0x2aca <create_chain+0x1e6>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    2970:	f1 01       	movw	r30, r2
    2972:	82 8d       	ldd	r24, Z+26	; 0x1a
    2974:	93 8d       	ldd	r25, Z+27	; 0x1b
    2976:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2978:	b5 8d       	ldd	r27, Z+29	; 0x1d
    297a:	08 17       	cp	r16, r24
    297c:	19 07       	cpc	r17, r25
    297e:	2a 07       	cpc	r18, r26
    2980:	3b 07       	cpc	r19, r27
    2982:	08 f4       	brcc	.+2      	; 0x2986 <create_chain+0xa2>
    2984:	b6 c0       	rjmp	.+364    	; 0x2af2 <create_chain+0x20e>
		scl = clst;
    2986:	89 80       	ldd	r8, Y+1	; 0x01
    2988:	9a 80       	ldd	r9, Y+2	; 0x02
    298a:	ab 80       	ldd	r10, Y+3	; 0x03
    298c:	bc 80       	ldd	r11, Y+4	; 0x04
    298e:	09 c0       	rjmp	.+18     	; 0x29a2 <create_chain+0xbe>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
    2990:	88 24       	eor	r8, r8
    2992:	99 24       	eor	r9, r9
    2994:	54 01       	movw	r10, r8
    2996:	83 94       	inc	r8
    2998:	04 c0       	rjmp	.+8      	; 0x29a2 <create_chain+0xbe>
    299a:	88 24       	eor	r8, r8
    299c:	99 24       	eor	r9, r9
    299e:	54 01       	movw	r10, r8
    29a0:	83 94       	inc	r8
		if (cs < 2) return 1;			/* It is an invalid cluster */
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
    29a2:	75 01       	movw	r14, r10
    29a4:	64 01       	movw	r12, r8
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
    29a6:	44 24       	eor	r4, r4
    29a8:	55 24       	eor	r5, r5
    29aa:	32 01       	movw	r6, r4
    29ac:	68 94       	set
    29ae:	41 f8       	bld	r4, 1
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
    29b0:	08 94       	sec
    29b2:	c1 1c       	adc	r12, r1
    29b4:	d1 1c       	adc	r13, r1
    29b6:	e1 1c       	adc	r14, r1
    29b8:	f1 1c       	adc	r15, r1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
    29ba:	f1 01       	movw	r30, r2
    29bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    29be:	93 8d       	ldd	r25, Z+27	; 0x1b
    29c0:	a4 8d       	ldd	r26, Z+28	; 0x1c
    29c2:	b5 8d       	ldd	r27, Z+29	; 0x1d
    29c4:	c8 16       	cp	r12, r24
    29c6:	d9 06       	cpc	r13, r25
    29c8:	ea 06       	cpc	r14, r26
    29ca:	fb 06       	cpc	r15, r27
    29cc:	48 f0       	brcs	.+18     	; 0x29e0 <create_chain+0xfc>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
    29ce:	f2 e0       	ldi	r31, 0x02	; 2
    29d0:	8f 16       	cp	r8, r31
    29d2:	91 04       	cpc	r9, r1
    29d4:	a1 04       	cpc	r10, r1
    29d6:	b1 04       	cpc	r11, r1
    29d8:	08 f4       	brcc	.+2      	; 0x29dc <create_chain+0xf8>
    29da:	7c c0       	rjmp	.+248    	; 0x2ad4 <create_chain+0x1f0>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
    29dc:	73 01       	movw	r14, r6
    29de:	62 01       	movw	r12, r4
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
    29e0:	c1 01       	movw	r24, r2
    29e2:	b7 01       	movw	r22, r14
    29e4:	a6 01       	movw	r20, r12
    29e6:	0e 94 49 11 	call	0x2292	; 0x2292 <get_fat>
    29ea:	8b 01       	movw	r16, r22
    29ec:	9c 01       	movw	r18, r24
		if (cs == 0) break;				/* Found a free cluster */
    29ee:	61 15       	cp	r22, r1
    29f0:	71 05       	cpc	r23, r1
    29f2:	81 05       	cpc	r24, r1
    29f4:	91 05       	cpc	r25, r1
    29f6:	a9 f0       	breq	.+42     	; 0x2a22 <create_chain+0x13e>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    29f8:	0f 3f       	cpi	r16, 0xFF	; 255
    29fa:	8f ef       	ldi	r24, 0xFF	; 255
    29fc:	18 07       	cpc	r17, r24
    29fe:	8f ef       	ldi	r24, 0xFF	; 255
    2a00:	28 07       	cpc	r18, r24
    2a02:	8f ef       	ldi	r24, 0xFF	; 255
    2a04:	38 07       	cpc	r19, r24
    2a06:	09 f4       	brne	.+2      	; 0x2a0a <create_chain+0x126>
    2a08:	74 c0       	rjmp	.+232    	; 0x2af2 <create_chain+0x20e>
    2a0a:	01 30       	cpi	r16, 0x01	; 1
    2a0c:	11 05       	cpc	r17, r1
    2a0e:	21 05       	cpc	r18, r1
    2a10:	31 05       	cpc	r19, r1
    2a12:	09 f4       	brne	.+2      	; 0x2a16 <create_chain+0x132>
    2a14:	6e c0       	rjmp	.+220    	; 0x2af2 <create_chain+0x20e>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
    2a16:	c8 14       	cp	r12, r8
    2a18:	d9 04       	cpc	r13, r9
    2a1a:	ea 04       	cpc	r14, r10
    2a1c:	fb 04       	cpc	r15, r11
    2a1e:	41 f6       	brne	.-112    	; 0x29b0 <create_chain+0xcc>
    2a20:	5d c0       	rjmp	.+186    	; 0x2adc <create_chain+0x1f8>
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
    2a22:	8c 2c       	mov	r8, r12
    2a24:	4d 2c       	mov	r4, r13
    2a26:	be 2c       	mov	r11, r14
    2a28:	af 2c       	mov	r10, r15
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    2a2a:	c1 01       	movw	r24, r2
    2a2c:	4c 2d       	mov	r20, r12
    2a2e:	5d 2d       	mov	r21, r13
    2a30:	6e 2d       	mov	r22, r14
    2a32:	7f 2d       	mov	r23, r15
    2a34:	0f ef       	ldi	r16, 0xFF	; 255
    2a36:	1f ef       	ldi	r17, 0xFF	; 255
    2a38:	2f ef       	ldi	r18, 0xFF	; 255
    2a3a:	3f e0       	ldi	r19, 0x0F	; 15
    2a3c:	0e 94 63 13 	call	0x26c6	; 0x26c6 <put_fat>
	if (res == FR_OK && clst != 0) {
    2a40:	88 23       	and	r24, r24
    2a42:	e9 f5       	brne	.+122    	; 0x2abe <create_chain+0x1da>
    2a44:	89 81       	ldd	r24, Y+1	; 0x01
    2a46:	9a 81       	ldd	r25, Y+2	; 0x02
    2a48:	ab 81       	ldd	r26, Y+3	; 0x03
    2a4a:	bc 81       	ldd	r27, Y+4	; 0x04
    2a4c:	00 97       	sbiw	r24, 0x00	; 0
    2a4e:	a1 05       	cpc	r26, r1
    2a50:	b1 05       	cpc	r27, r1
    2a52:	69 f0       	breq	.+26     	; 0x2a6e <create_chain+0x18a>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    2a54:	c1 01       	movw	r24, r2
    2a56:	49 81       	ldd	r20, Y+1	; 0x01
    2a58:	5a 81       	ldd	r21, Y+2	; 0x02
    2a5a:	6b 81       	ldd	r22, Y+3	; 0x03
    2a5c:	7c 81       	ldd	r23, Y+4	; 0x04
    2a5e:	0c 2d       	mov	r16, r12
    2a60:	1d 2d       	mov	r17, r13
    2a62:	2e 2d       	mov	r18, r14
    2a64:	3f 2d       	mov	r19, r15
    2a66:	0e 94 63 13 	call	0x26c6	; 0x26c6 <put_fat>
	}
	if (res == FR_OK) {
    2a6a:	88 23       	and	r24, r24
    2a6c:	41 f5       	brne	.+80     	; 0x2abe <create_chain+0x1da>
		fs->last_clust = ncl;			/* Update FSINFO */
    2a6e:	d1 01       	movw	r26, r2
    2a70:	1a 96       	adiw	r26, 0x0a	; 10
    2a72:	8c 92       	st	X, r8
    2a74:	1a 97       	sbiw	r26, 0x0a	; 10
    2a76:	1b 96       	adiw	r26, 0x0b	; 11
    2a78:	4c 92       	st	X, r4
    2a7a:	1b 97       	sbiw	r26, 0x0b	; 11
    2a7c:	1c 96       	adiw	r26, 0x0c	; 12
    2a7e:	bc 92       	st	X, r11
    2a80:	1c 97       	sbiw	r26, 0x0c	; 12
    2a82:	1d 96       	adiw	r26, 0x0d	; 13
    2a84:	ac 92       	st	X, r10
    2a86:	1d 97       	sbiw	r26, 0x0d	; 13
		if (fs->free_clust != 0xFFFFFFFF) {
    2a88:	1e 96       	adiw	r26, 0x0e	; 14
    2a8a:	8d 91       	ld	r24, X+
    2a8c:	9d 91       	ld	r25, X+
    2a8e:	0d 90       	ld	r0, X+
    2a90:	bc 91       	ld	r27, X
    2a92:	a0 2d       	mov	r26, r0
    2a94:	8f 3f       	cpi	r24, 0xFF	; 255
    2a96:	ef ef       	ldi	r30, 0xFF	; 255
    2a98:	9e 07       	cpc	r25, r30
    2a9a:	ef ef       	ldi	r30, 0xFF	; 255
    2a9c:	ae 07       	cpc	r26, r30
    2a9e:	ef ef       	ldi	r30, 0xFF	; 255
    2aa0:	be 07       	cpc	r27, r30
    2aa2:	01 f1       	breq	.+64     	; 0x2ae4 <create_chain+0x200>
			fs->free_clust--;
    2aa4:	01 97       	sbiw	r24, 0x01	; 1
    2aa6:	a1 09       	sbc	r26, r1
    2aa8:	b1 09       	sbc	r27, r1
    2aaa:	f1 01       	movw	r30, r2
    2aac:	86 87       	std	Z+14, r24	; 0x0e
    2aae:	97 87       	std	Z+15, r25	; 0x0f
    2ab0:	a0 8b       	std	Z+16, r26	; 0x10
    2ab2:	b1 8b       	std	Z+17, r27	; 0x11
			fs->fsi_flag = 1;
    2ab4:	81 e0       	ldi	r24, 0x01	; 1
    2ab6:	85 83       	std	Z+5, r24	; 0x05
    2ab8:	97 01       	movw	r18, r14
    2aba:	86 01       	movw	r16, r12
    2abc:	1a c0       	rjmp	.+52     	; 0x2af2 <create_chain+0x20e>
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    2abe:	81 30       	cpi	r24, 0x01	; 1
    2ac0:	a1 f4       	brne	.+40     	; 0x2aea <create_chain+0x206>
    2ac2:	0f ef       	ldi	r16, 0xFF	; 255
    2ac4:	1f ef       	ldi	r17, 0xFF	; 255
    2ac6:	98 01       	movw	r18, r16
    2ac8:	14 c0       	rjmp	.+40     	; 0x2af2 <create_chain+0x20e>
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* It is an invalid cluster */
    2aca:	01 e0       	ldi	r16, 0x01	; 1
    2acc:	10 e0       	ldi	r17, 0x00	; 0
    2ace:	20 e0       	ldi	r18, 0x00	; 0
    2ad0:	30 e0       	ldi	r19, 0x00	; 0
    2ad2:	0f c0       	rjmp	.+30     	; 0x2af2 <create_chain+0x20e>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
    2ad4:	00 e0       	ldi	r16, 0x00	; 0
    2ad6:	10 e0       	ldi	r17, 0x00	; 0
    2ad8:	98 01       	movw	r18, r16
    2ada:	0b c0       	rjmp	.+22     	; 0x2af2 <create_chain+0x20e>
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
    2adc:	00 e0       	ldi	r16, 0x00	; 0
    2ade:	10 e0       	ldi	r17, 0x00	; 0
    2ae0:	98 01       	movw	r18, r16
    2ae2:	07 c0       	rjmp	.+14     	; 0x2af2 <create_chain+0x20e>
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
    2ae4:	97 01       	movw	r18, r14
    2ae6:	86 01       	movw	r16, r12
    2ae8:	04 c0       	rjmp	.+8      	; 0x2af2 <create_chain+0x20e>
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    2aea:	01 e0       	ldi	r16, 0x01	; 1
    2aec:	10 e0       	ldi	r17, 0x00	; 0
    2aee:	20 e0       	ldi	r18, 0x00	; 0
    2af0:	30 e0       	ldi	r19, 0x00	; 0
	}

	return ncl;		/* Return new cluster number or error code */
}
    2af2:	60 2f       	mov	r22, r16
    2af4:	71 2f       	mov	r23, r17
    2af6:	82 2f       	mov	r24, r18
    2af8:	93 2f       	mov	r25, r19
    2afa:	0f 90       	pop	r0
    2afc:	0f 90       	pop	r0
    2afe:	0f 90       	pop	r0
    2b00:	0f 90       	pop	r0
    2b02:	df 91       	pop	r29
    2b04:	cf 91       	pop	r28
    2b06:	1f 91       	pop	r17
    2b08:	0f 91       	pop	r16
    2b0a:	ff 90       	pop	r15
    2b0c:	ef 90       	pop	r14
    2b0e:	df 90       	pop	r13
    2b10:	cf 90       	pop	r12
    2b12:	bf 90       	pop	r11
    2b14:	af 90       	pop	r10
    2b16:	9f 90       	pop	r9
    2b18:	8f 90       	pop	r8
    2b1a:	7f 90       	pop	r7
    2b1c:	6f 90       	pop	r6
    2b1e:	5f 90       	pop	r5
    2b20:	4f 90       	pop	r4
    2b22:	3f 90       	pop	r3
    2b24:	2f 90       	pop	r2
    2b26:	08 95       	ret

00002b28 <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
    2b28:	8f 92       	push	r8
    2b2a:	9f 92       	push	r9
    2b2c:	af 92       	push	r10
    2b2e:	bf 92       	push	r11
    2b30:	cf 92       	push	r12
    2b32:	df 92       	push	r13
    2b34:	ef 92       	push	r14
    2b36:	ff 92       	push	r15
    2b38:	0f 93       	push	r16
    2b3a:	1f 93       	push	r17
    2b3c:	cf 93       	push	r28
    2b3e:	df 93       	push	r29
    2b40:	8c 01       	movw	r16, r24
    2b42:	eb 01       	movw	r28, r22
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
    2b44:	dc 01       	movw	r26, r24
    2b46:	14 96       	adiw	r26, 0x04	; 4
    2b48:	ed 90       	ld	r14, X+
    2b4a:	fc 90       	ld	r15, X
    2b4c:	15 97       	sbiw	r26, 0x05	; 5
    2b4e:	08 94       	sec
    2b50:	e1 1c       	adc	r14, r1
    2b52:	f1 1c       	adc	r15, r1
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    2b54:	e1 14       	cp	r14, r1
    2b56:	f1 04       	cpc	r15, r1
    2b58:	09 f4       	brne	.+2      	; 0x2b5c <dir_next+0x34>
    2b5a:	0b c1       	rjmp	.+534    	; 0x2d72 <dir_next+0x24a>
    2b5c:	1e 96       	adiw	r26, 0x0e	; 14
    2b5e:	8d 91       	ld	r24, X+
    2b60:	9d 91       	ld	r25, X+
    2b62:	0d 90       	ld	r0, X+
    2b64:	bc 91       	ld	r27, X
    2b66:	a0 2d       	mov	r26, r0
    2b68:	00 97       	sbiw	r24, 0x00	; 0
    2b6a:	a1 05       	cpc	r26, r1
    2b6c:	b1 05       	cpc	r27, r1
    2b6e:	09 f4       	brne	.+2      	; 0x2b72 <dir_next+0x4a>
    2b70:	02 c1       	rjmp	.+516    	; 0x2d76 <dir_next+0x24e>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    2b72:	0f 2e       	mov	r0, r31
    2b74:	ff e0       	ldi	r31, 0x0F	; 15
    2b76:	cf 2e       	mov	r12, r31
    2b78:	dd 24       	eor	r13, r13
    2b7a:	f0 2d       	mov	r31, r0
    2b7c:	ce 20       	and	r12, r14
    2b7e:	df 20       	and	r13, r15
    2b80:	c1 14       	cp	r12, r1
    2b82:	d1 04       	cpc	r13, r1
    2b84:	09 f0       	breq	.+2      	; 0x2b88 <dir_next+0x60>
    2b86:	da c0       	rjmp	.+436    	; 0x2d3c <dir_next+0x214>
		dj->sect++;					/* Next sector */
    2b88:	01 96       	adiw	r24, 0x01	; 1
    2b8a:	a1 1d       	adc	r26, r1
    2b8c:	b1 1d       	adc	r27, r1
    2b8e:	f8 01       	movw	r30, r16
    2b90:	86 87       	std	Z+14, r24	; 0x0e
    2b92:	97 87       	std	Z+15, r25	; 0x0f
    2b94:	a0 8b       	std	Z+16, r26	; 0x10
    2b96:	b1 8b       	std	Z+17, r27	; 0x11

		if (dj->clust == 0) {	/* Static table */
    2b98:	42 85       	ldd	r20, Z+10	; 0x0a
    2b9a:	53 85       	ldd	r21, Z+11	; 0x0b
    2b9c:	64 85       	ldd	r22, Z+12	; 0x0c
    2b9e:	75 85       	ldd	r23, Z+13	; 0x0d
    2ba0:	41 15       	cp	r20, r1
    2ba2:	51 05       	cpc	r21, r1
    2ba4:	61 05       	cpc	r22, r1
    2ba6:	71 05       	cpc	r23, r1
    2ba8:	51 f4       	brne	.+20     	; 0x2bbe <dir_next+0x96>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    2baa:	01 90       	ld	r0, Z+
    2bac:	f0 81       	ld	r31, Z
    2bae:	e0 2d       	mov	r30, r0
    2bb0:	80 85       	ldd	r24, Z+8	; 0x08
    2bb2:	91 85       	ldd	r25, Z+9	; 0x09
    2bb4:	e8 16       	cp	r14, r24
    2bb6:	f9 06       	cpc	r15, r25
    2bb8:	08 f0       	brcs	.+2      	; 0x2bbc <dir_next+0x94>
    2bba:	df c0       	rjmp	.+446    	; 0x2d7a <dir_next+0x252>
    2bbc:	bf c0       	rjmp	.+382    	; 0x2d3c <dir_next+0x214>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    2bbe:	01 90       	ld	r0, Z+
    2bc0:	f0 81       	ld	r31, Z
    2bc2:	e0 2d       	mov	r30, r0
    2bc4:	82 81       	ldd	r24, Z+2	; 0x02
    2bc6:	90 e0       	ldi	r25, 0x00	; 0
    2bc8:	01 97       	sbiw	r24, 0x01	; 1
    2bca:	97 01       	movw	r18, r14
    2bcc:	32 95       	swap	r19
    2bce:	22 95       	swap	r18
    2bd0:	2f 70       	andi	r18, 0x0F	; 15
    2bd2:	23 27       	eor	r18, r19
    2bd4:	3f 70       	andi	r19, 0x0F	; 15
    2bd6:	23 27       	eor	r18, r19
    2bd8:	82 23       	and	r24, r18
    2bda:	93 23       	and	r25, r19
    2bdc:	00 97       	sbiw	r24, 0x00	; 0
    2bde:	09 f0       	breq	.+2      	; 0x2be2 <dir_next+0xba>
    2be0:	ad c0       	rjmp	.+346    	; 0x2d3c <dir_next+0x214>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    2be2:	cf 01       	movw	r24, r30
    2be4:	0e 94 49 11 	call	0x2292	; 0x2292 <get_fat>
    2be8:	4b 01       	movw	r8, r22
    2bea:	5c 01       	movw	r10, r24
				if (clst <= 1) return FR_INT_ERR;
    2bec:	62 30       	cpi	r22, 0x02	; 2
    2bee:	71 05       	cpc	r23, r1
    2bf0:	81 05       	cpc	r24, r1
    2bf2:	91 05       	cpc	r25, r1
    2bf4:	08 f4       	brcc	.+2      	; 0x2bf8 <dir_next+0xd0>
    2bf6:	c3 c0       	rjmp	.+390    	; 0x2d7e <dir_next+0x256>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2bf8:	6f 3f       	cpi	r22, 0xFF	; 255
    2bfa:	ef ef       	ldi	r30, 0xFF	; 255
    2bfc:	7e 07       	cpc	r23, r30
    2bfe:	ef ef       	ldi	r30, 0xFF	; 255
    2c00:	8e 07       	cpc	r24, r30
    2c02:	ef ef       	ldi	r30, 0xFF	; 255
    2c04:	9e 07       	cpc	r25, r30
    2c06:	09 f4       	brne	.+2      	; 0x2c0a <dir_next+0xe2>
    2c08:	bc c0       	rjmp	.+376    	; 0x2d82 <dir_next+0x25a>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    2c0a:	d8 01       	movw	r26, r16
    2c0c:	ed 91       	ld	r30, X+
    2c0e:	fc 91       	ld	r31, X
    2c10:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c12:	93 8d       	ldd	r25, Z+27	; 0x1b
    2c14:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2c16:	b5 8d       	ldd	r27, Z+29	; 0x1d
    2c18:	88 16       	cp	r8, r24
    2c1a:	99 06       	cpc	r9, r25
    2c1c:	aa 06       	cpc	r10, r26
    2c1e:	bb 06       	cpc	r11, r27
    2c20:	08 f4       	brcc	.+2      	; 0x2c24 <dir_next+0xfc>
    2c22:	7a c0       	rjmp	.+244    	; 0x2d18 <dir_next+0x1f0>
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    2c24:	20 97       	sbiw	r28, 0x00	; 0
    2c26:	09 f4       	brne	.+2      	; 0x2c2a <dir_next+0x102>
    2c28:	ae c0       	rjmp	.+348    	; 0x2d86 <dir_next+0x25e>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
    2c2a:	d8 01       	movw	r26, r16
    2c2c:	1a 96       	adiw	r26, 0x0a	; 10
    2c2e:	4d 91       	ld	r20, X+
    2c30:	5d 91       	ld	r21, X+
    2c32:	6d 91       	ld	r22, X+
    2c34:	7c 91       	ld	r23, X
    2c36:	1d 97       	sbiw	r26, 0x0d	; 13
    2c38:	cf 01       	movw	r24, r30
    2c3a:	0e 94 72 14 	call	0x28e4	; 0x28e4 <create_chain>
    2c3e:	4b 01       	movw	r8, r22
    2c40:	5c 01       	movw	r10, r24
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    2c42:	61 15       	cp	r22, r1
    2c44:	71 05       	cpc	r23, r1
    2c46:	81 05       	cpc	r24, r1
    2c48:	91 05       	cpc	r25, r1
    2c4a:	09 f4       	brne	.+2      	; 0x2c4e <dir_next+0x126>
    2c4c:	9e c0       	rjmp	.+316    	; 0x2d8a <dir_next+0x262>
					if (clst == 1) return FR_INT_ERR;
    2c4e:	61 30       	cpi	r22, 0x01	; 1
    2c50:	71 05       	cpc	r23, r1
    2c52:	81 05       	cpc	r24, r1
    2c54:	91 05       	cpc	r25, r1
    2c56:	09 f4       	brne	.+2      	; 0x2c5a <dir_next+0x132>
    2c58:	9a c0       	rjmp	.+308    	; 0x2d8e <dir_next+0x266>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2c5a:	6f 3f       	cpi	r22, 0xFF	; 255
    2c5c:	ef ef       	ldi	r30, 0xFF	; 255
    2c5e:	7e 07       	cpc	r23, r30
    2c60:	ef ef       	ldi	r30, 0xFF	; 255
    2c62:	8e 07       	cpc	r24, r30
    2c64:	ef ef       	ldi	r30, 0xFF	; 255
    2c66:	9e 07       	cpc	r25, r30
    2c68:	09 f4       	brne	.+2      	; 0x2c6c <dir_next+0x144>
    2c6a:	93 c0       	rjmp	.+294    	; 0x2d92 <dir_next+0x26a>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    2c6c:	d8 01       	movw	r26, r16
    2c6e:	8d 91       	ld	r24, X+
    2c70:	9c 91       	ld	r25, X
    2c72:	40 e0       	ldi	r20, 0x00	; 0
    2c74:	50 e0       	ldi	r21, 0x00	; 0
    2c76:	ba 01       	movw	r22, r20
    2c78:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
    2c7c:	88 23       	and	r24, r24
    2c7e:	09 f0       	breq	.+2      	; 0x2c82 <dir_next+0x15a>
    2c80:	8a c0       	rjmp	.+276    	; 0x2d96 <dir_next+0x26e>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
    2c82:	f8 01       	movw	r30, r16
    2c84:	80 81       	ld	r24, Z
    2c86:	91 81       	ldd	r25, Z+1	; 0x01
    2c88:	c2 96       	adiw	r24, 0x32	; 50
    2c8a:	60 e0       	ldi	r22, 0x00	; 0
    2c8c:	70 e0       	ldi	r23, 0x00	; 0
    2c8e:	20 e0       	ldi	r18, 0x00	; 0
    2c90:	32 e0       	ldi	r19, 0x02	; 2
    2c92:	40 e0       	ldi	r20, 0x00	; 0
    2c94:	50 e0       	ldi	r21, 0x00	; 0
    2c96:	0e 94 1e 0a 	call	0x143c	; 0x143c <mem_set>
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    2c9a:	d8 01       	movw	r26, r16
    2c9c:	cd 91       	ld	r28, X+
    2c9e:	dc 91       	ld	r29, X
    2ca0:	ce 01       	movw	r24, r28
    2ca2:	b5 01       	movw	r22, r10
    2ca4:	a4 01       	movw	r20, r8
    2ca6:	0e 94 13 11 	call	0x2226	; 0x2226 <clust2sect>
    2caa:	dc 01       	movw	r26, r24
    2cac:	cb 01       	movw	r24, r22
    2cae:	8e a7       	lds	r24, 0x7e
    2cb0:	9f a7       	lds	r25, 0x7f
    2cb2:	a8 ab       	sts	0x58, r26
    2cb4:	b9 ab       	sts	0x59, r27
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2cb6:	c0 e0       	ldi	r28, 0x00	; 0
						dj->fs->wflag = 1;
    2cb8:	d1 e0       	ldi	r29, 0x01	; 1
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2cba:	1b c0       	rjmp	.+54     	; 0x2cf2 <dir_next+0x1ca>
						dj->fs->wflag = 1;
    2cbc:	d4 83       	std	Z+4, r29	; 0x04
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    2cbe:	f8 01       	movw	r30, r16
    2cc0:	80 81       	ld	r24, Z
    2cc2:	91 81       	ldd	r25, Z+1	; 0x01
    2cc4:	40 e0       	ldi	r20, 0x00	; 0
    2cc6:	50 e0       	ldi	r21, 0x00	; 0
    2cc8:	ba 01       	movw	r22, r20
    2cca:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
    2cce:	88 23       	and	r24, r24
    2cd0:	09 f0       	breq	.+2      	; 0x2cd4 <dir_next+0x1ac>
    2cd2:	63 c0       	rjmp	.+198    	; 0x2d9a <dir_next+0x272>
						dj->fs->winsect++;
    2cd4:	d8 01       	movw	r26, r16
    2cd6:	ed 91       	ld	r30, X+
    2cd8:	fc 91       	ld	r31, X
    2cda:	86 a5       	lds	r24, 0x66
    2cdc:	97 a5       	lds	r25, 0x67
    2cde:	a0 a9       	sts	0x40, r26
    2ce0:	b1 a9       	sts	0x41, r27
    2ce2:	01 96       	adiw	r24, 0x01	; 1
    2ce4:	a1 1d       	adc	r26, r1
    2ce6:	b1 1d       	adc	r27, r1
    2ce8:	86 a7       	lds	r24, 0x76
    2cea:	97 a7       	lds	r25, 0x77
    2cec:	a0 ab       	sts	0x50, r26
    2cee:	b1 ab       	sts	0x51, r27
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2cf0:	cf 5f       	subi	r28, 0xFF	; 255
    2cf2:	d8 01       	movw	r26, r16
    2cf4:	ed 91       	ld	r30, X+
    2cf6:	fc 91       	ld	r31, X
    2cf8:	11 97       	sbiw	r26, 0x01	; 1
    2cfa:	82 81       	ldd	r24, Z+2	; 0x02
    2cfc:	c8 17       	cp	r28, r24
    2cfe:	f0 f2       	brcs	.-68     	; 0x2cbc <dir_next+0x194>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
    2d00:	86 a5       	lds	r24, 0x66
    2d02:	97 a5       	lds	r25, 0x67
    2d04:	a0 a9       	sts	0x40, r26
    2d06:	b1 a9       	sts	0x41, r27
    2d08:	8c 1b       	sub	r24, r28
    2d0a:	91 09       	sbc	r25, r1
    2d0c:	a1 09       	sbc	r26, r1
    2d0e:	b1 09       	sbc	r27, r1
    2d10:	86 a7       	lds	r24, 0x76
    2d12:	97 a7       	lds	r25, 0x77
    2d14:	a0 ab       	sts	0x50, r26
    2d16:	b1 ab       	sts	0x51, r27
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
    2d18:	f8 01       	movw	r30, r16
    2d1a:	82 86       	std	Z+10, r8	; 0x0a
    2d1c:	93 86       	std	Z+11, r9	; 0x0b
    2d1e:	a4 86       	std	Z+12, r10	; 0x0c
    2d20:	b5 86       	std	Z+13, r11	; 0x0d
				dj->sect = clust2sect(dj->fs, clst);
    2d22:	80 81       	ld	r24, Z
    2d24:	91 81       	ldd	r25, Z+1	; 0x01
    2d26:	b5 01       	movw	r22, r10
    2d28:	a4 01       	movw	r20, r8
    2d2a:	0e 94 13 11 	call	0x2226	; 0x2226 <clust2sect>
    2d2e:	dc 01       	movw	r26, r24
    2d30:	cb 01       	movw	r24, r22
    2d32:	f8 01       	movw	r30, r16
    2d34:	86 87       	std	Z+14, r24	; 0x0e
    2d36:	97 87       	std	Z+15, r25	; 0x0f
    2d38:	a0 8b       	std	Z+16, r26	; 0x10
    2d3a:	b1 8b       	std	Z+17, r27	; 0x11
			}
		}
	}

	dj->index = i;
    2d3c:	d8 01       	movw	r26, r16
    2d3e:	15 96       	adiw	r26, 0x05	; 5
    2d40:	fc 92       	st	X, r15
    2d42:	ee 92       	st	-X, r14
    2d44:	14 97       	sbiw	r26, 0x04	; 4
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    2d46:	8d 91       	ld	r24, X+
    2d48:	9c 91       	ld	r25, X
    2d4a:	11 97       	sbiw	r26, 0x01	; 1
    2d4c:	c2 96       	adiw	r24, 0x32	; 50
    2d4e:	cc 0c       	add	r12, r12
    2d50:	dd 1c       	adc	r13, r13
    2d52:	cc 0c       	add	r12, r12
    2d54:	dd 1c       	adc	r13, r13
    2d56:	cc 0c       	add	r12, r12
    2d58:	dd 1c       	adc	r13, r13
    2d5a:	cc 0c       	add	r12, r12
    2d5c:	dd 1c       	adc	r13, r13
    2d5e:	cc 0c       	add	r12, r12
    2d60:	dd 1c       	adc	r13, r13
    2d62:	8c 0d       	add	r24, r12
    2d64:	9d 1d       	adc	r25, r13
    2d66:	53 96       	adiw	r26, 0x13	; 19
    2d68:	9c 93       	st	X, r25
    2d6a:	8e 93       	st	-X, r24
    2d6c:	52 97       	sbiw	r26, 0x12	; 18

	return FR_OK;
    2d6e:	80 e0       	ldi	r24, 0x00	; 0
    2d70:	15 c0       	rjmp	.+42     	; 0x2d9c <dir_next+0x274>


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
    2d72:	84 e0       	ldi	r24, 0x04	; 4
    2d74:	13 c0       	rjmp	.+38     	; 0x2d9c <dir_next+0x274>
    2d76:	84 e0       	ldi	r24, 0x04	; 4
    2d78:	11 c0       	rjmp	.+34     	; 0x2d9c <dir_next+0x274>
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
    2d7a:	84 e0       	ldi	r24, 0x04	; 4
    2d7c:	0f c0       	rjmp	.+30     	; 0x2d9c <dir_next+0x274>
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
    2d7e:	82 e0       	ldi	r24, 0x02	; 2
    2d80:	0d c0       	rjmp	.+26     	; 0x2d9c <dir_next+0x274>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2d82:	81 e0       	ldi	r24, 0x01	; 1
    2d84:	0b c0       	rjmp	.+22     	; 0x2d9c <dir_next+0x274>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    2d86:	84 e0       	ldi	r24, 0x04	; 4
    2d88:	09 c0       	rjmp	.+18     	; 0x2d9c <dir_next+0x274>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    2d8a:	87 e0       	ldi	r24, 0x07	; 7
    2d8c:	07 c0       	rjmp	.+14     	; 0x2d9c <dir_next+0x274>
					if (clst == 1) return FR_INT_ERR;
    2d8e:	82 e0       	ldi	r24, 0x02	; 2
    2d90:	05 c0       	rjmp	.+10     	; 0x2d9c <dir_next+0x274>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2d92:	81 e0       	ldi	r24, 0x01	; 1
    2d94:	03 c0       	rjmp	.+6      	; 0x2d9c <dir_next+0x274>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    2d96:	81 e0       	ldi	r24, 0x01	; 1
    2d98:	01 c0       	rjmp	.+2      	; 0x2d9c <dir_next+0x274>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    2d9a:	81 e0       	ldi	r24, 0x01	; 1

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
}
    2d9c:	df 91       	pop	r29
    2d9e:	cf 91       	pop	r28
    2da0:	1f 91       	pop	r17
    2da2:	0f 91       	pop	r16
    2da4:	ff 90       	pop	r15
    2da6:	ef 90       	pop	r14
    2da8:	df 90       	pop	r13
    2daa:	cf 90       	pop	r12
    2dac:	bf 90       	pop	r11
    2dae:	af 90       	pop	r10
    2db0:	9f 90       	pop	r9
    2db2:	8f 90       	pop	r8
    2db4:	08 95       	ret

00002db6 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
    2db6:	2f 92       	push	r2
    2db8:	3f 92       	push	r3
    2dba:	4f 92       	push	r4
    2dbc:	5f 92       	push	r5
    2dbe:	6f 92       	push	r6
    2dc0:	7f 92       	push	r7
    2dc2:	8f 92       	push	r8
    2dc4:	9f 92       	push	r9
    2dc6:	af 92       	push	r10
    2dc8:	bf 92       	push	r11
    2dca:	cf 92       	push	r12
    2dcc:	df 92       	push	r13
    2dce:	ef 92       	push	r14
    2dd0:	ff 92       	push	r15
    2dd2:	0f 93       	push	r16
    2dd4:	1f 93       	push	r17
    2dd6:	cf 93       	push	r28
    2dd8:	df 93       	push	r29
    2dda:	cd b7       	in	r28, 0x3d	; 61
    2ddc:	de b7       	in	r29, 0x3e	; 62
    2dde:	2b 97       	sbiw	r28, 0x0b	; 11
    2de0:	0f b6       	in	r0, 0x3f	; 63
    2de2:	f8 94       	cli
    2de4:	de bf       	out	0x3e, r29	; 62
    2de6:	0f be       	out	0x3f, r0	; 63
    2de8:	cd bf       	out	0x3d, r28	; 61
    2dea:	8c 01       	movw	r16, r24
    2dec:	2b 01       	movw	r4, r22
	FRESULT res;
	BYTE *dir, ns;


#if _FS_RPATH
	if (*path == '/' || *path == '\\') { /* There is a heading separator */
    2dee:	db 01       	movw	r26, r22
    2df0:	8c 91       	ld	r24, X
    2df2:	8f 32       	cpi	r24, 0x2F	; 47
    2df4:	11 f0       	breq	.+4      	; 0x2dfa <follow_path+0x44>
    2df6:	8c 35       	cpi	r24, 0x5C	; 92
    2df8:	49 f4       	brne	.+18     	; 0x2e0c <follow_path+0x56>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
    2dfa:	08 94       	sec
    2dfc:	41 1c       	adc	r4, r1
    2dfe:	51 1c       	adc	r5, r1
    2e00:	f8 01       	movw	r30, r16
    2e02:	16 82       	std	Z+6, r1	; 0x06
    2e04:	17 82       	std	Z+7, r1	; 0x07
    2e06:	10 86       	std	Z+8, r1	; 0x08
    2e08:	11 86       	std	Z+9, r1	; 0x09
    2e0a:	0c c0       	rjmp	.+24     	; 0x2e24 <follow_path+0x6e>
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
    2e0c:	d8 01       	movw	r26, r16
    2e0e:	ed 91       	ld	r30, X+
    2e10:	fc 91       	ld	r31, X
    2e12:	86 89       	ldd	r24, Z+22	; 0x16
    2e14:	97 89       	ldd	r25, Z+23	; 0x17
    2e16:	a0 8d       	ldd	r26, Z+24	; 0x18
    2e18:	b1 8d       	ldd	r27, Z+25	; 0x19
    2e1a:	f8 01       	movw	r30, r16
    2e1c:	86 83       	std	Z+6, r24	; 0x06
    2e1e:	97 83       	std	Z+7, r25	; 0x07
    2e20:	a0 87       	std	Z+8, r26	; 0x08
    2e22:	b1 87       	std	Z+9, r27	; 0x09
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    2e24:	d2 01       	movw	r26, r4
    2e26:	8c 91       	ld	r24, X
    2e28:	80 32       	cpi	r24, 0x20	; 32
    2e2a:	48 f4       	brcc	.+18     	; 0x2e3e <follow_path+0x88>
		res = dir_sdi(dj, 0);
    2e2c:	c8 01       	movw	r24, r16
    2e2e:	60 e0       	ldi	r22, 0x00	; 0
    2e30:	70 e0       	ldi	r23, 0x00	; 0
    2e32:	0e 94 80 12 	call	0x2500	; 0x2500 <dir_sdi>
		dj->dir = 0;
    2e36:	f8 01       	movw	r30, r16
    2e38:	13 8a       	std	Z+19, r1	; 0x13
    2e3a:	12 8a       	std	Z+18, r1	; 0x12
    2e3c:	a5 c1       	rjmp	.+842    	; 0x3188 <follow_path+0x3d2>
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    2e3e:	f8 e0       	ldi	r31, 0x08	; 8
    2e40:	fa 83       	std	Y+2, r31	; 0x02
    2e42:	1b 82       	std	Y+3, r1	; 0x03
    2e44:	1c 82       	std	Y+4, r1	; 0x04
    2e46:	1d 82       	std	Y+5, r1	; 0x05
    2e48:	2b e0       	ldi	r18, 0x0B	; 11
    2e4a:	2e 83       	std	Y+6, r18	; 0x06
    2e4c:	1f 82       	std	Y+7, r1	; 0x07
    2e4e:	18 86       	std	Y+8, r1	; 0x08
    2e50:	19 86       	std	Y+9, r1	; 0x09
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
		res = dir_sdi(dj, 0);
		dj->dir = 0;
    2e52:	f2 01       	movw	r30, r4
    2e54:	9f 01       	movw	r18, r30
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    2e56:	81 91       	ld	r24, Z+
    2e58:	8f 32       	cpi	r24, 0x2F	; 47
    2e5a:	e1 f3       	breq	.-8      	; 0x2e54 <follow_path+0x9e>
    2e5c:	8c 35       	cpi	r24, 0x5C	; 92
    2e5e:	d1 f3       	breq	.-12     	; 0x2e54 <follow_path+0x9e>
    2e60:	3b 87       	std	Y+11, r19	; 0x0b
    2e62:	2a 87       	std	Y+10, r18	; 0x0a
	sfn = dj->fn;
    2e64:	d8 01       	movw	r26, r16
    2e66:	54 96       	adiw	r26, 0x14	; 20
    2e68:	2d 90       	ld	r2, X+
    2e6a:	3c 90       	ld	r3, X
    2e6c:	55 97       	sbiw	r26, 0x15	; 21
	mem_set(sfn, ' ', 11);
    2e6e:	c1 01       	movw	r24, r2
    2e70:	60 e2       	ldi	r22, 0x20	; 32
    2e72:	70 e0       	ldi	r23, 0x00	; 0
    2e74:	2b e0       	ldi	r18, 0x0B	; 11
    2e76:	30 e0       	ldi	r19, 0x00	; 0
    2e78:	40 e0       	ldi	r20, 0x00	; 0
    2e7a:	50 e0       	ldi	r21, 0x00	; 0
    2e7c:	0e 94 1e 0a 	call	0x143c	; 0x143c <mem_set>
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
    2e80:	ea 85       	ldd	r30, Y+10	; 0x0a
    2e82:	fb 85       	ldd	r31, Y+11	; 0x0b
    2e84:	80 81       	ld	r24, Z
    2e86:	8e 32       	cpi	r24, 0x2E	; 46
    2e88:	89 f5       	brne	.+98     	; 0x2eec <follow_path+0x136>
		for (;;) {
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
    2e8a:	ee e2       	ldi	r30, 0x2E	; 46
    2e8c:	d1 01       	movw	r26, r2
    2e8e:	ec 93       	st	X, r30
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2e90:	aa 85       	ldd	r26, Y+10	; 0x0a
    2e92:	bb 85       	ldd	r27, Y+11	; 0x0b
    2e94:	11 96       	adiw	r26, 0x01	; 1
    2e96:	2c 91       	ld	r18, X
    2e98:	11 97       	sbiw	r26, 0x01	; 1
			if (c != '.' || si >= 3) break;
    2e9a:	2e 32       	cpi	r18, 0x2E	; 46
    2e9c:	61 f4       	brne	.+24     	; 0x2eb6 <follow_path+0x100>
			sfn[i++] = c;
    2e9e:	f1 01       	movw	r30, r2
    2ea0:	21 83       	std	Z+1, r18	; 0x01
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2ea2:	12 96       	adiw	r26, 0x02	; 2
    2ea4:	2c 91       	ld	r18, X
    2ea6:	12 97       	sbiw	r26, 0x02	; 2
			if (c != '.' || si >= 3) break;
    2ea8:	2e 32       	cpi	r18, 0x2E	; 46
    2eaa:	71 f0       	breq	.+28     	; 0x2ec8 <follow_path+0x112>
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2eac:	83 e0       	ldi	r24, 0x03	; 3
    2eae:	90 e0       	ldi	r25, 0x00	; 0
    2eb0:	a0 e0       	ldi	r26, 0x00	; 0
    2eb2:	b0 e0       	ldi	r27, 0x00	; 0
    2eb4:	04 c0       	rjmp	.+8      	; 0x2ebe <follow_path+0x108>
    2eb6:	82 e0       	ldi	r24, 0x02	; 2
    2eb8:	90 e0       	ldi	r25, 0x00	; 0
    2eba:	a0 e0       	ldi	r26, 0x00	; 0
    2ebc:	b0 e0       	ldi	r27, 0x00	; 0
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    2ebe:	2f 32       	cpi	r18, 0x2F	; 47
    2ec0:	59 f0       	breq	.+22     	; 0x2ed8 <follow_path+0x122>
    2ec2:	2c 35       	cpi	r18, 0x5C	; 92
    2ec4:	49 f0       	breq	.+18     	; 0x2ed8 <follow_path+0x122>
    2ec6:	04 c0       	rjmp	.+8      	; 0x2ed0 <follow_path+0x11a>
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2ec8:	83 e0       	ldi	r24, 0x03	; 3
    2eca:	90 e0       	ldi	r25, 0x00	; 0
    2ecc:	a0 e0       	ldi	r26, 0x00	; 0
    2ece:	b0 e0       	ldi	r27, 0x00	; 0
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    2ed0:	21 32       	cpi	r18, 0x21	; 33
    2ed2:	08 f0       	brcs	.+2      	; 0x2ed6 <follow_path+0x120>
    2ed4:	48 c1       	rjmp	.+656    	; 0x3166 <follow_path+0x3b0>
    2ed6:	71 c1       	rjmp	.+738    	; 0x31ba <follow_path+0x404>
		*path = &p[si];									/* Return pointer to the next segment */
    2ed8:	4a 84       	ldd	r4, Y+10	; 0x0a
    2eda:	5b 84       	ldd	r5, Y+11	; 0x0b
    2edc:	48 0e       	add	r4, r24
    2ede:	59 1e       	adc	r5, r25
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
    2ee0:	80 e2       	ldi	r24, 0x20	; 32
    2ee2:	d1 01       	movw	r26, r2
    2ee4:	1b 96       	adiw	r26, 0x0b	; 11
    2ee6:	8c 93       	st	X, r24
    2ee8:	1b 97       	sbiw	r26, 0x0b	; 11
    2eea:	74 c1       	rjmp	.+744    	; 0x31d4 <follow_path+0x41e>
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
    2eec:	cc 24       	eor	r12, r12
    2eee:	dd 24       	eor	r13, r13
    2ef0:	76 01       	movw	r14, r12
    2ef2:	40 e0       	ldi	r20, 0x00	; 0
    2ef4:	50 e0       	ldi	r21, 0x00	; 0
    2ef6:	ba 01       	movw	r22, r20
    2ef8:	88 24       	eor	r8, r8
    2efa:	99 24       	eor	r9, r9
    2efc:	54 01       	movw	r10, r8
    2efe:	68 94       	set
    2f00:	83 f8       	bld	r8, 3
    2f02:	19 82       	std	Y+1, r1	; 0x01
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    2f04:	ea 85       	ldd	r30, Y+10	; 0x0a
    2f06:	fb 85       	ldd	r31, Y+11	; 0x0b
    2f08:	e4 0f       	add	r30, r20
    2f0a:	f5 1f       	adc	r31, r21
    2f0c:	20 81       	ld	r18, Z
    2f0e:	2a 01       	movw	r4, r20
    2f10:	3b 01       	movw	r6, r22
    2f12:	08 94       	sec
    2f14:	41 1c       	adc	r4, r1
    2f16:	51 1c       	adc	r5, r1
    2f18:	61 1c       	adc	r6, r1
    2f1a:	71 1c       	adc	r7, r1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    2f1c:	21 32       	cpi	r18, 0x21	; 33
    2f1e:	08 f4       	brcc	.+2      	; 0x2f22 <follow_path+0x16c>
    2f20:	95 c0       	rjmp	.+298    	; 0x304c <follow_path+0x296>
    2f22:	2f 32       	cpi	r18, 0x2F	; 47
    2f24:	09 f4       	brne	.+2      	; 0x2f28 <follow_path+0x172>
    2f26:	4f c1       	rjmp	.+670    	; 0x31c6 <follow_path+0x410>
    2f28:	2c 35       	cpi	r18, 0x5C	; 92
    2f2a:	09 f4       	brne	.+2      	; 0x2f2e <follow_path+0x178>
    2f2c:	4c c1       	rjmp	.+664    	; 0x31c6 <follow_path+0x410>
		if (c == '.' || i >= ni) {
    2f2e:	2e 32       	cpi	r18, 0x2E	; 46
    2f30:	29 f0       	breq	.+10     	; 0x2f3c <follow_path+0x186>
    2f32:	c8 14       	cp	r12, r8
    2f34:	d9 04       	cpc	r13, r9
    2f36:	ea 04       	cpc	r14, r10
    2f38:	fb 04       	cpc	r15, r11
    2f3a:	c8 f0       	brcs	.+50     	; 0x2f6e <follow_path+0x1b8>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    2f3c:	f8 e0       	ldi	r31, 0x08	; 8
    2f3e:	8f 16       	cp	r8, r31
    2f40:	91 04       	cpc	r9, r1
    2f42:	a1 04       	cpc	r10, r1
    2f44:	b1 04       	cpc	r11, r1
    2f46:	09 f0       	breq	.+2      	; 0x2f4a <follow_path+0x194>
    2f48:	10 c1       	rjmp	.+544    	; 0x316a <follow_path+0x3b4>
    2f4a:	2e 32       	cpi	r18, 0x2E	; 46
    2f4c:	09 f0       	breq	.+2      	; 0x2f50 <follow_path+0x19a>
    2f4e:	0f c1       	rjmp	.+542    	; 0x316e <follow_path+0x3b8>
			i = 8; ni = 11;
			b <<= 2; continue;
    2f50:	29 81       	ldd	r18, Y+1	; 0x01
    2f52:	22 0f       	add	r18, r18
    2f54:	22 0f       	add	r18, r18
    2f56:	29 83       	std	Y+1, r18	; 0x01
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    2f58:	b3 01       	movw	r22, r6
    2f5a:	a2 01       	movw	r20, r4
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    2f5c:	ca 80       	ldd	r12, Y+2	; 0x02
    2f5e:	db 80       	ldd	r13, Y+3	; 0x03
    2f60:	ec 80       	ldd	r14, Y+4	; 0x04
    2f62:	fd 80       	ldd	r15, Y+5	; 0x05
    2f64:	8e 80       	ldd	r8, Y+6	; 0x06
    2f66:	9f 80       	ldd	r9, Y+7	; 0x07
    2f68:	a8 84       	ldd	r10, Y+8	; 0x08
    2f6a:	b9 84       	ldd	r11, Y+9	; 0x09
    2f6c:	cb cf       	rjmp	.-106    	; 0x2f04 <follow_path+0x14e>
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended char? */
    2f6e:	22 23       	and	r18, r18
    2f70:	1c f4       	brge	.+6      	; 0x2f78 <follow_path+0x1c2>
			b |= 3;						/* Eliminate NT flag */
    2f72:	89 81       	ldd	r24, Y+1	; 0x01
    2f74:	83 60       	ori	r24, 0x03	; 3
    2f76:	89 83       	std	Y+1, r24	; 0x01
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    2f78:	82 2f       	mov	r24, r18
    2f7a:	81 58       	subi	r24, 0x81	; 129
    2f7c:	8f 31       	cpi	r24, 0x1F	; 31
    2f7e:	18 f0       	brcs	.+6      	; 0x2f86 <follow_path+0x1d0>
    2f80:	8f 55       	subi	r24, 0x5F	; 95
    2f82:	8d 31       	cpi	r24, 0x1D	; 29
    2f84:	90 f5       	brcc	.+100    	; 0x2fea <follow_path+0x234>
			d = (BYTE)p[si++];			/* Get 2nd byte */
    2f86:	ea 85       	ldd	r30, Y+10	; 0x0a
    2f88:	fb 85       	ldd	r31, Y+11	; 0x0b
    2f8a:	e4 0d       	add	r30, r4
    2f8c:	f5 1d       	adc	r31, r5
    2f8e:	30 81       	ld	r19, Z
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    2f90:	83 2f       	mov	r24, r19
    2f92:	80 54       	subi	r24, 0x40	; 64
    2f94:	8f 33       	cpi	r24, 0x3F	; 63
    2f96:	20 f0       	brcs	.+8      	; 0x2fa0 <follow_path+0x1ea>
    2f98:	80 54       	subi	r24, 0x40	; 64
    2f9a:	8d 37       	cpi	r24, 0x7D	; 125
    2f9c:	08 f0       	brcs	.+2      	; 0x2fa0 <follow_path+0x1ea>
    2f9e:	e9 c0       	rjmp	.+466    	; 0x3172 <follow_path+0x3bc>
    2fa0:	d5 01       	movw	r26, r10
    2fa2:	c4 01       	movw	r24, r8
    2fa4:	01 97       	sbiw	r24, 0x01	; 1
    2fa6:	a1 09       	sbc	r26, r1
    2fa8:	b1 09       	sbc	r27, r1
    2faa:	c8 16       	cp	r12, r24
    2fac:	d9 06       	cpc	r13, r25
    2fae:	ea 06       	cpc	r14, r26
    2fb0:	fb 06       	cpc	r15, r27
    2fb2:	08 f0       	brcs	.+2      	; 0x2fb6 <follow_path+0x200>
    2fb4:	e0 c0       	rjmp	.+448    	; 0x3176 <follow_path+0x3c0>
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
    2fb6:	4e 5f       	subi	r20, 0xFE	; 254
    2fb8:	5f 4f       	sbci	r21, 0xFF	; 255
    2fba:	6f 4f       	sbci	r22, 0xFF	; 255
    2fbc:	7f 4f       	sbci	r23, 0xFF	; 255
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
    2fbe:	f1 01       	movw	r30, r2
    2fc0:	ec 0d       	add	r30, r12
    2fc2:	fd 1d       	adc	r31, r13
    2fc4:	20 83       	st	Z, r18
    2fc6:	d7 01       	movw	r26, r14
    2fc8:	c6 01       	movw	r24, r12
    2fca:	01 96       	adiw	r24, 0x01	; 1
    2fcc:	a1 1d       	adc	r26, r1
    2fce:	b1 1d       	adc	r27, r1
			sfn[i++] = d;
    2fd0:	82 0d       	add	r24, r2
    2fd2:	93 1d       	adc	r25, r3
    2fd4:	dc 01       	movw	r26, r24
    2fd6:	3c 93       	st	X, r19
    2fd8:	82 e0       	ldi	r24, 0x02	; 2
    2fda:	90 e0       	ldi	r25, 0x00	; 0
    2fdc:	a0 e0       	ldi	r26, 0x00	; 0
    2fde:	b0 e0       	ldi	r27, 0x00	; 0
    2fe0:	c8 0e       	add	r12, r24
    2fe2:	d9 1e       	adc	r13, r25
    2fe4:	ea 1e       	adc	r14, r26
    2fe6:	fb 1e       	adc	r15, r27
    2fe8:	8d cf       	rjmp	.-230    	; 0x2f04 <follow_path+0x14e>
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    2fea:	42 2f       	mov	r20, r18
    2fec:	50 e0       	ldi	r21, 0x00	; 0
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    2fee:	42 32       	cpi	r20, 0x22	; 34
    2ff0:	51 05       	cpc	r21, r1
    2ff2:	09 f4       	brne	.+2      	; 0x2ff6 <follow_path+0x240>
    2ff4:	c2 c0       	rjmp	.+388    	; 0x317a <follow_path+0x3c4>
    2ff6:	e1 ee       	ldi	r30, 0xE1	; 225
    2ff8:	f3 e0       	ldi	r31, 0x03	; 3
    2ffa:	6a 85       	ldd	r22, Y+10	; 0x0a
    2ffc:	7b 85       	ldd	r23, Y+11	; 0x0b
    2ffe:	81 91       	ld	r24, Z+
    3000:	88 23       	and	r24, r24
    3002:	31 f0       	breq	.+12     	; 0x3010 <follow_path+0x25a>
    3004:	90 e0       	ldi	r25, 0x00	; 0
    3006:	48 17       	cp	r20, r24
    3008:	59 07       	cpc	r21, r25
    300a:	c9 f7       	brne	.-14     	; 0x2ffe <follow_path+0x248>
    300c:	86 e0       	ldi	r24, 0x06	; 6
    300e:	bc c0       	rjmp	.+376    	; 0x3188 <follow_path+0x3d2>
    3010:	7b 87       	std	Y+11, r23	; 0x0b
    3012:	6a 87       	std	Y+10, r22	; 0x0a
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
    3014:	82 2f       	mov	r24, r18
    3016:	81 54       	subi	r24, 0x41	; 65
    3018:	8a 31       	cpi	r24, 0x1A	; 26
    301a:	20 f4       	brcc	.+8      	; 0x3024 <follow_path+0x26e>
				b |= 2;
    301c:	99 81       	ldd	r25, Y+1	; 0x01
    301e:	92 60       	ori	r25, 0x02	; 2
    3020:	99 83       	std	Y+1, r25	; 0x01
    3022:	08 c0       	rjmp	.+16     	; 0x3034 <follow_path+0x27e>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
    3024:	82 2f       	mov	r24, r18
    3026:	81 56       	subi	r24, 0x61	; 97
    3028:	8a 31       	cpi	r24, 0x1A	; 26
    302a:	20 f4       	brcc	.+8      	; 0x3034 <follow_path+0x27e>
					b |= 1; c -= 0x20;
    302c:	a9 81       	ldd	r26, Y+1	; 0x01
    302e:	a1 60       	ori	r26, 0x01	; 1
    3030:	a9 83       	std	Y+1, r26	; 0x01
    3032:	20 52       	subi	r18, 0x20	; 32
				}
			}
			sfn[i++] = c;
    3034:	f1 01       	movw	r30, r2
    3036:	ec 0d       	add	r30, r12
    3038:	fd 1d       	adc	r31, r13
    303a:	20 83       	st	Z, r18
    303c:	08 94       	sec
    303e:	c1 1c       	adc	r12, r1
    3040:	d1 1c       	adc	r13, r1
    3042:	e1 1c       	adc	r14, r1
    3044:	f1 1c       	adc	r15, r1
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    3046:	b3 01       	movw	r22, r6
    3048:	a2 01       	movw	r20, r4
    304a:	5c cf       	rjmp	.-328    	; 0x2f04 <follow_path+0x14e>
    304c:	ea 85       	ldd	r30, Y+10	; 0x0a
    304e:	fb 85       	ldd	r31, Y+11	; 0x0b
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    3050:	4e 0e       	add	r4, r30
    3052:	5f 1e       	adc	r5, r31
    3054:	89 81       	ldd	r24, Y+1	; 0x01
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    3056:	44 e0       	ldi	r20, 0x04	; 4

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    3058:	c1 14       	cp	r12, r1
    305a:	d1 04       	cpc	r13, r1
    305c:	e1 04       	cpc	r14, r1
    305e:	f1 04       	cpc	r15, r1
    3060:	09 f4       	brne	.+2      	; 0x3064 <follow_path+0x2ae>
    3062:	8d c0       	rjmp	.+282    	; 0x317e <follow_path+0x3c8>
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    3064:	d1 01       	movw	r26, r2
    3066:	9c 91       	ld	r25, X
    3068:	95 3e       	cpi	r25, 0xE5	; 229
    306a:	11 f4       	brne	.+4      	; 0x3070 <follow_path+0x2ba>
    306c:	e5 e0       	ldi	r30, 0x05	; 5
    306e:	ec 93       	st	X, r30

	if (ni == 8) b <<= 2;
    3070:	f8 e0       	ldi	r31, 0x08	; 8
    3072:	8f 16       	cp	r8, r31
    3074:	91 04       	cpc	r9, r1
    3076:	a1 04       	cpc	r10, r1
    3078:	b1 04       	cpc	r11, r1
    307a:	19 f4       	brne	.+6      	; 0x3082 <follow_path+0x2cc>
    307c:	88 0f       	add	r24, r24
    307e:	88 0f       	add	r24, r24
    3080:	89 83       	std	Y+1, r24	; 0x01
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    3082:	29 81       	ldd	r18, Y+1	; 0x01
    3084:	82 2f       	mov	r24, r18
    3086:	90 e0       	ldi	r25, 0x00	; 0
    3088:	9c 01       	movw	r18, r24
    308a:	23 70       	andi	r18, 0x03	; 3
    308c:	30 70       	andi	r19, 0x00	; 0
    308e:	21 30       	cpi	r18, 0x01	; 1
    3090:	31 05       	cpc	r19, r1
    3092:	09 f4       	brne	.+2      	; 0x3096 <follow_path+0x2e0>
    3094:	40 61       	ori	r20, 0x10	; 16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    3096:	8c 70       	andi	r24, 0x0C	; 12
    3098:	90 70       	andi	r25, 0x00	; 0
    309a:	84 30       	cpi	r24, 0x04	; 4
    309c:	91 05       	cpc	r25, r1
    309e:	09 f4       	brne	.+2      	; 0x30a2 <follow_path+0x2ec>
    30a0:	48 60       	ori	r20, 0x08	; 8

	sfn[NS] = c;		/* Store NT flag, File name is created */
    30a2:	d1 01       	movw	r26, r2
    30a4:	1b 96       	adiw	r26, 0x0b	; 11
    30a6:	4c 93       	st	X, r20
    30a8:	1b 97       	sbiw	r26, 0x0b	; 11
    30aa:	94 c0       	rjmp	.+296    	; 0x31d4 <follow_path+0x41e>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
    30ac:	f8 01       	movw	r30, r16
    30ae:	46 85       	ldd	r20, Z+14	; 0x0e
    30b0:	57 85       	ldd	r21, Z+15	; 0x0f
    30b2:	60 89       	ldd	r22, Z+16	; 0x10
    30b4:	71 89       	ldd	r23, Z+17	; 0x11
    30b6:	80 81       	ld	r24, Z
    30b8:	91 81       	ldd	r25, Z+1	; 0x01
    30ba:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
		if (res != FR_OK) break;
    30be:	88 23       	and	r24, r24
    30c0:	31 f5       	brne	.+76     	; 0x310e <follow_path+0x358>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    30c2:	d8 01       	movw	r26, r16
    30c4:	52 96       	adiw	r26, 0x12	; 18
    30c6:	6d 91       	ld	r22, X+
    30c8:	7c 91       	ld	r23, X
    30ca:	53 97       	sbiw	r26, 0x13	; 19
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    30cc:	fb 01       	movw	r30, r22
    30ce:	90 81       	ld	r25, Z
    30d0:	99 23       	and	r25, r25
    30d2:	09 f4       	brne	.+2      	; 0x30d6 <follow_path+0x320>
    30d4:	90 c0       	rjmp	.+288    	; 0x31f6 <follow_path+0x440>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    30d6:	93 85       	ldd	r25, Z+11	; 0x0b
    30d8:	93 fd       	sbrc	r25, 3
    30da:	12 c0       	rjmp	.+36     	; 0x3100 <follow_path+0x34a>
    30dc:	54 96       	adiw	r26, 0x14	; 20
    30de:	4d 91       	ld	r20, X+
    30e0:	5c 91       	ld	r21, X
    30e2:	55 97       	sbiw	r26, 0x15	; 21
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
    30e4:	9b 01       	movw	r18, r22
    30e6:	25 5f       	subi	r18, 0xF5	; 245
    30e8:	3f 4f       	sbci	r19, 0xFF	; 255
}

/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    30ea:	da 01       	movw	r26, r20
    30ec:	6b 01       	movw	r12, r22
    30ee:	04 c0       	rjmp	.+8      	; 0x30f8 <follow_path+0x342>
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    30f0:	e2 17       	cp	r30, r18
    30f2:	f3 07       	cpc	r31, r19
    30f4:	09 f4       	brne	.+2      	; 0x30f8 <follow_path+0x342>
    30f6:	77 c0       	rjmp	.+238    	; 0x31e6 <follow_path+0x430>
    30f8:	61 91       	ld	r22, Z+
    30fa:	9d 91       	ld	r25, X+
    30fc:	69 17       	cp	r22, r25
    30fe:	c1 f3       	breq	.-16     	; 0x30f0 <follow_path+0x33a>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
    3100:	c8 01       	movw	r24, r16
    3102:	60 e0       	ldi	r22, 0x00	; 0
    3104:	70 e0       	ldi	r23, 0x00	; 0
    3106:	0e 94 94 15 	call	0x2b28	; 0x2b28 <dir_next>
	} while (res == FR_OK);
    310a:	88 23       	and	r24, r24
    310c:	79 f2       	breq	.-98     	; 0x30ac <follow_path+0x2f6>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    310e:	d8 01       	movw	r26, r16
    3110:	54 96       	adiw	r26, 0x14	; 20
    3112:	ed 91       	ld	r30, X+
    3114:	fc 91       	ld	r31, X
    3116:	55 97       	sbiw	r26, 0x15	; 21
    3118:	93 85       	ldd	r25, Z+11	; 0x0b
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
    311a:	84 30       	cpi	r24, 0x04	; 4
    311c:	a9 f5       	brne	.+106    	; 0x3188 <follow_path+0x3d2>
				/* Object not found */
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
    311e:	95 ff       	sbrs	r25, 5
    3120:	0b c0       	rjmp	.+22     	; 0x3138 <follow_path+0x382>
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
    3122:	f8 01       	movw	r30, r16
    3124:	16 82       	std	Z+6, r1	; 0x06
    3126:	17 82       	std	Z+7, r1	; 0x07
    3128:	10 86       	std	Z+8, r1	; 0x08
    312a:	11 86       	std	Z+9, r1	; 0x09
    312c:	13 8a       	std	Z+19, r1	; 0x13
    312e:	12 8a       	std	Z+18, r1	; 0x12
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
    3130:	92 ff       	sbrs	r25, 2
    3132:	8f ce       	rjmp	.-738    	; 0x2e52 <follow_path+0x9c>
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
				/* Object not found */
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
    3134:	80 e0       	ldi	r24, 0x00	; 0
    3136:	28 c0       	rjmp	.+80     	; 0x3188 <follow_path+0x3d2>
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    3138:	92 ff       	sbrs	r25, 2
    313a:	23 c0       	rjmp	.+70     	; 0x3182 <follow_path+0x3cc>
		dj->dir = 0;
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
    313c:	84 e0       	ldi	r24, 0x04	; 4
    313e:	24 c0       	rjmp	.+72     	; 0x3188 <follow_path+0x3d2>
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    3140:	db 01       	movw	r26, r22
    3142:	1b 96       	adiw	r26, 0x0b	; 11
    3144:	8c 91       	ld	r24, X
    3146:	1b 97       	sbiw	r26, 0x0b	; 11
    3148:	84 ff       	sbrs	r24, 4
    314a:	1d c0       	rjmp	.+58     	; 0x3186 <follow_path+0x3d0>
				res = FR_NO_PATH; break;
			}
			dj->sclust = ld_clust(dj->fs, dir);
    314c:	f8 01       	movw	r30, r16
    314e:	80 81       	ld	r24, Z
    3150:	91 81       	ldd	r25, Z+1	; 0x01
    3152:	0e 94 2f 0a 	call	0x145e	; 0x145e <ld_clust>
    3156:	dc 01       	movw	r26, r24
    3158:	cb 01       	movw	r24, r22
    315a:	f8 01       	movw	r30, r16
    315c:	86 83       	std	Z+6, r24	; 0x06
    315e:	97 83       	std	Z+7, r25	; 0x07
    3160:	a0 87       	std	Z+8, r26	; 0x08
    3162:	b1 87       	std	Z+9, r27	; 0x09
    3164:	76 ce       	rjmp	.-788    	; 0x2e52 <follow_path+0x9c>
		for (;;) {
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    3166:	86 e0       	ldi	r24, 0x06	; 6
    3168:	0f c0       	rjmp	.+30     	; 0x3188 <follow_path+0x3d2>
#endif
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    316a:	86 e0       	ldi	r24, 0x06	; 6
    316c:	0d c0       	rjmp	.+26     	; 0x3188 <follow_path+0x3d2>
    316e:	86 e0       	ldi	r24, 0x06	; 6
    3170:	0b c0       	rjmp	.+22     	; 0x3188 <follow_path+0x3d2>
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    3172:	86 e0       	ldi	r24, 0x06	; 6
    3174:	09 c0       	rjmp	.+18     	; 0x3188 <follow_path+0x3d2>
    3176:	86 e0       	ldi	r24, 0x06	; 6
    3178:	07 c0       	rjmp	.+14     	; 0x3188 <follow_path+0x3d2>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    317a:	86 e0       	ldi	r24, 0x06	; 6
    317c:	05 c0       	rjmp	.+10     	; 0x3188 <follow_path+0x3d2>
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    317e:	86 e0       	ldi	r24, 0x06	; 6
    3180:	03 c0       	rjmp	.+6      	; 0x3188 <follow_path+0x3d2>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    3182:	85 e0       	ldi	r24, 0x05	; 5
    3184:	01 c0       	rjmp	.+2      	; 0x3188 <follow_path+0x3d2>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
    3186:	85 e0       	ldi	r24, 0x05	; 5
			dj->sclust = ld_clust(dj->fs, dir);
		}
	}

	return res;
}
    3188:	2b 96       	adiw	r28, 0x0b	; 11
    318a:	0f b6       	in	r0, 0x3f	; 63
    318c:	f8 94       	cli
    318e:	de bf       	out	0x3e, r29	; 62
    3190:	0f be       	out	0x3f, r0	; 63
    3192:	cd bf       	out	0x3d, r28	; 61
    3194:	df 91       	pop	r29
    3196:	cf 91       	pop	r28
    3198:	1f 91       	pop	r17
    319a:	0f 91       	pop	r16
    319c:	ff 90       	pop	r15
    319e:	ef 90       	pop	r14
    31a0:	df 90       	pop	r13
    31a2:	cf 90       	pop	r12
    31a4:	bf 90       	pop	r11
    31a6:	af 90       	pop	r10
    31a8:	9f 90       	pop	r9
    31aa:	8f 90       	pop	r8
    31ac:	7f 90       	pop	r7
    31ae:	6f 90       	pop	r6
    31b0:	5f 90       	pop	r5
    31b2:	4f 90       	pop	r4
    31b4:	3f 90       	pop	r3
    31b6:	2f 90       	pop	r2
    31b8:	08 95       	ret
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
		*path = &p[si];									/* Return pointer to the next segment */
    31ba:	4a 84       	ldd	r4, Y+10	; 0x0a
    31bc:	5b 84       	ldd	r5, Y+11	; 0x0b
    31be:	48 0e       	add	r4, r24
    31c0:	59 1e       	adc	r5, r25
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
    31c2:	84 e2       	ldi	r24, 0x24	; 36
    31c4:	8e ce       	rjmp	.-740    	; 0x2ee2 <follow_path+0x12c>
    31c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    31c8:	9b 85       	ldd	r25, Y+11	; 0x0b
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    31ca:	48 0e       	add	r4, r24
    31cc:	59 1e       	adc	r5, r25
    31ce:	89 81       	ldd	r24, Y+1	; 0x01
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    31d0:	40 e0       	ldi	r20, 0x00	; 0
    31d2:	42 cf       	rjmp	.-380    	; 0x3058 <follow_path+0x2a2>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
    31d4:	c8 01       	movw	r24, r16
    31d6:	60 e0       	ldi	r22, 0x00	; 0
    31d8:	70 e0       	ldi	r23, 0x00	; 0
    31da:	0e 94 80 12 	call	0x2500	; 0x2500 <dir_sdi>
	if (res != FR_OK) return res;
    31de:	88 23       	and	r24, r24
    31e0:	09 f4       	brne	.+2      	; 0x31e4 <follow_path+0x42e>
    31e2:	64 cf       	rjmp	.-312    	; 0x30ac <follow_path+0x2f6>
    31e4:	94 cf       	rjmp	.-216    	; 0x310e <follow_path+0x358>
    31e6:	b6 01       	movw	r22, r12
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    31e8:	da 01       	movw	r26, r20
    31ea:	1b 96       	adiw	r26, 0x0b	; 11
    31ec:	9c 91       	ld	r25, X
    31ee:	1b 97       	sbiw	r26, 0x0b	; 11
    31f0:	92 ff       	sbrs	r25, 2
    31f2:	a6 cf       	rjmp	.-180    	; 0x3140 <follow_path+0x38a>
    31f4:	c9 cf       	rjmp	.-110    	; 0x3188 <follow_path+0x3d2>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    31f6:	d8 01       	movw	r26, r16
    31f8:	54 96       	adiw	r26, 0x14	; 20
    31fa:	ed 91       	ld	r30, X+
    31fc:	fc 91       	ld	r31, X
    31fe:	55 97       	sbiw	r26, 0x15	; 21
    3200:	93 85       	ldd	r25, Z+11	; 0x0b
    3202:	8d cf       	rjmp	.-230    	; 0x311e <follow_path+0x368>

00003204 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
    3204:	ef 92       	push	r14
    3206:	ff 92       	push	r15
    3208:	0f 93       	push	r16
    320a:	1f 93       	push	r17
    320c:	cf 93       	push	r28
    320e:	8c 01       	movw	r16, r24
			} while (res == FR_OK && --ne);
		}
	}

#else	/* Non LFN configuration */
	res = dir_sdi(dj, 0);
    3210:	60 e0       	ldi	r22, 0x00	; 0
    3212:	70 e0       	ldi	r23, 0x00	; 0
    3214:	0e 94 80 12 	call	0x2500	; 0x2500 <dir_sdi>
    3218:	c8 2f       	mov	r28, r24
	if (res == FR_OK) {
    321a:	88 23       	and	r24, r24
    321c:	09 f0       	breq	.+2      	; 0x3220 <dir_register+0x1c>
    321e:	3f c0       	rjmp	.+126    	; 0x329e <dir_register+0x9a>
		do {	/* Find a blank entry for the SFN */
			res = move_window(dj->fs, dj->sect);
    3220:	d8 01       	movw	r26, r16
    3222:	1e 96       	adiw	r26, 0x0e	; 14
    3224:	4d 91       	ld	r20, X+
    3226:	5d 91       	ld	r21, X+
    3228:	6d 91       	ld	r22, X+
    322a:	7c 91       	ld	r23, X
    322c:	51 97       	sbiw	r26, 0x11	; 17
    322e:	8d 91       	ld	r24, X+
    3230:	9c 91       	ld	r25, X
    3232:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
    3236:	c8 2f       	mov	r28, r24
			if (res != FR_OK) break;
    3238:	88 23       	and	r24, r24
    323a:	89 f5       	brne	.+98     	; 0x329e <dir_register+0x9a>
			c = *dj->dir;
    323c:	d8 01       	movw	r26, r16
    323e:	52 96       	adiw	r26, 0x12	; 18
    3240:	ed 91       	ld	r30, X+
    3242:	fc 91       	ld	r31, X
    3244:	53 97       	sbiw	r26, 0x13	; 19
    3246:	80 81       	ld	r24, Z
			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
    3248:	85 3e       	cpi	r24, 0xE5	; 229
    324a:	81 f1       	breq	.+96     	; 0x32ac <dir_register+0xa8>
    324c:	88 23       	and	r24, r24
    324e:	71 f1       	breq	.+92     	; 0x32ac <dir_register+0xa8>
			res = dir_next(dj, 1);			/* Next entry with table stretch */
    3250:	c8 01       	movw	r24, r16
    3252:	61 e0       	ldi	r22, 0x01	; 1
    3254:	70 e0       	ldi	r23, 0x00	; 0
    3256:	0e 94 94 15 	call	0x2b28	; 0x2b28 <dir_next>
    325a:	c8 2f       	mov	r28, r24
		} while (res == FR_OK);
    325c:	88 23       	and	r24, r24
    325e:	01 f3       	breq	.-64     	; 0x3220 <dir_register+0x1c>
    3260:	1e c0       	rjmp	.+60     	; 0x329e <dir_register+0x9a>
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
    3262:	f8 01       	movw	r30, r16
    3264:	e2 88       	ldd	r14, Z+18	; 0x12
    3266:	f3 88       	ldd	r15, Z+19	; 0x13
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
    3268:	c7 01       	movw	r24, r14
    326a:	60 e0       	ldi	r22, 0x00	; 0
    326c:	70 e0       	ldi	r23, 0x00	; 0
    326e:	20 e2       	ldi	r18, 0x20	; 32
    3270:	30 e0       	ldi	r19, 0x00	; 0
    3272:	40 e0       	ldi	r20, 0x00	; 0
    3274:	50 e0       	ldi	r21, 0x00	; 0
    3276:	0e 94 1e 0a 	call	0x143c	; 0x143c <mem_set>
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
    327a:	d8 01       	movw	r26, r16
    327c:	54 96       	adiw	r26, 0x14	; 20
    327e:	6d 91       	ld	r22, X+
    3280:	7c 91       	ld	r23, X
    3282:	55 97       	sbiw	r26, 0x15	; 21
    3284:	c7 01       	movw	r24, r14
    3286:	2b e0       	ldi	r18, 0x0B	; 11
    3288:	30 e0       	ldi	r19, 0x00	; 0
    328a:	40 e0       	ldi	r20, 0x00	; 0
    328c:	50 e0       	ldi	r21, 0x00	; 0
    328e:	0e 94 09 0a 	call	0x1412	; 0x1412 <mem_cpy>
#if _USE_LFN
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dj->fs->wflag = 1;
    3292:	d8 01       	movw	r26, r16
    3294:	ed 91       	ld	r30, X+
    3296:	fc 91       	ld	r31, X
    3298:	11 97       	sbiw	r26, 0x01	; 1
    329a:	81 e0       	ldi	r24, 0x01	; 1
    329c:	84 83       	std	Z+4, r24	; 0x04
		}
	}

	return res;
}
    329e:	8c 2f       	mov	r24, r28
    32a0:	cf 91       	pop	r28
    32a2:	1f 91       	pop	r17
    32a4:	0f 91       	pop	r16
    32a6:	ff 90       	pop	r15
    32a8:	ef 90       	pop	r14
    32aa:	08 95       	ret
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
    32ac:	f8 01       	movw	r30, r16
    32ae:	46 85       	ldd	r20, Z+14	; 0x0e
    32b0:	57 85       	ldd	r21, Z+15	; 0x0f
    32b2:	60 89       	ldd	r22, Z+16	; 0x10
    32b4:	71 89       	ldd	r23, Z+17	; 0x11
    32b6:	80 81       	ld	r24, Z
    32b8:	91 81       	ldd	r25, Z+1	; 0x01
    32ba:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
    32be:	c8 2f       	mov	r28, r24
		if (res == FR_OK) {
    32c0:	88 23       	and	r24, r24
    32c2:	69 f7       	brne	.-38     	; 0x329e <dir_register+0x9a>
    32c4:	ce cf       	rjmp	.-100    	; 0x3262 <dir_register+0x5e>

000032c6 <dir_read>:
#if _FS_MINIMIZE <= 1
static
FRESULT dir_read (
	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
)
{
    32c6:	cf 93       	push	r28
    32c8:	df 93       	push	r29
    32ca:	ec 01       	movw	r28, r24
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
    32cc:	84 e0       	ldi	r24, 0x04	; 4
	while (dj->sect) {
    32ce:	17 c0       	rjmp	.+46     	; 0x32fe <dir_read+0x38>
		res = move_window(dj->fs, dj->sect);
    32d0:	88 81       	ld	r24, Y
    32d2:	99 81       	ldd	r25, Y+1	; 0x01
    32d4:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
		if (res != FR_OK) break;
    32d8:	88 23       	and	r24, r24
    32da:	e1 f4       	brne	.+56     	; 0x3314 <dir_read+0x4e>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    32dc:	ea 89       	ldd	r30, Y+18	; 0x12
    32de:	fb 89       	ldd	r31, Y+19	; 0x13
		c = dir[DIR_Name];
    32e0:	90 81       	ld	r25, Z
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    32e2:	99 23       	and	r25, r25
    32e4:	f1 f0       	breq	.+60     	; 0x3322 <dir_read+0x5c>
					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    32e6:	95 3e       	cpi	r25, 0xE5	; 229
    32e8:	19 f0       	breq	.+6      	; 0x32f0 <dir_read+0x2a>
    32ea:	93 85       	ldd	r25, Z+11	; 0x0b
    32ec:	93 ff       	sbrs	r25, 3
    32ee:	16 c0       	rjmp	.+44     	; 0x331c <dir_read+0x56>
			break;
#endif
		res = dir_next(dj, 0);				/* Next entry */
    32f0:	ce 01       	movw	r24, r28
    32f2:	60 e0       	ldi	r22, 0x00	; 0
    32f4:	70 e0       	ldi	r23, 0x00	; 0
    32f6:	0e 94 94 15 	call	0x2b28	; 0x2b28 <dir_next>
		if (res != FR_OK) break;
    32fa:	88 23       	and	r24, r24
    32fc:	59 f4       	brne	.+22     	; 0x3314 <dir_read+0x4e>
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
    32fe:	4e 85       	ldd	r20, Y+14	; 0x0e
    3300:	5f 85       	ldd	r21, Y+15	; 0x0f
    3302:	68 89       	ldd	r22, Y+16	; 0x10
    3304:	79 89       	ldd	r23, Y+17	; 0x11
    3306:	41 15       	cp	r20, r1
    3308:	51 05       	cpc	r21, r1
    330a:	61 05       	cpc	r22, r1
    330c:	71 05       	cpc	r23, r1
    330e:	01 f7       	brne	.-64     	; 0x32d0 <dir_read+0xa>
#endif
		res = dir_next(dj, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
    3310:	88 23       	and	r24, r24
    3312:	21 f0       	breq	.+8      	; 0x331c <dir_read+0x56>
    3314:	1e 86       	std	Y+14, r1	; 0x0e
    3316:	1f 86       	std	Y+15, r1	; 0x0f
    3318:	18 8a       	std	Y+16, r1	; 0x10
    331a:	19 8a       	std	Y+17, r1	; 0x11

	return res;
}
    331c:	df 91       	pop	r29
    331e:	cf 91       	pop	r28
    3320:	08 95       	ret
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    3322:	84 e0       	ldi	r24, 0x04	; 4
    3324:	f7 cf       	rjmp	.-18     	; 0x3314 <dir_read+0x4e>

00003326 <remove_chain>:
static
FRESULT remove_chain (
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
    3326:	7f 92       	push	r7
    3328:	8f 92       	push	r8
    332a:	9f 92       	push	r9
    332c:	af 92       	push	r10
    332e:	bf 92       	push	r11
    3330:	cf 92       	push	r12
    3332:	df 92       	push	r13
    3334:	ef 92       	push	r14
    3336:	ff 92       	push	r15
    3338:	0f 93       	push	r16
    333a:	1f 93       	push	r17
    333c:	cf 93       	push	r28
    333e:	df 93       	push	r29
    3340:	ec 01       	movw	r28, r24
    3342:	4a 01       	movw	r8, r20
    3344:	5b 01       	movw	r10, r22
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    3346:	42 30       	cpi	r20, 0x02	; 2
    3348:	51 05       	cpc	r21, r1
    334a:	61 05       	cpc	r22, r1
    334c:	71 05       	cpc	r23, r1
    334e:	08 f4       	brcc	.+2      	; 0x3352 <remove_chain+0x2c>
    3350:	55 c0       	rjmp	.+170    	; 0x33fc <remove_chain+0xd6>
    3352:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3354:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3356:	ac 8d       	ldd	r26, Y+28	; 0x1c
    3358:	bd 8d       	ldd	r27, Y+29	; 0x1d
    335a:	48 17       	cp	r20, r24
    335c:	59 07       	cpc	r21, r25
    335e:	6a 07       	cpc	r22, r26
    3360:	7b 07       	cpc	r23, r27
    3362:	08 f0       	brcs	.+2      	; 0x3366 <remove_chain+0x40>
    3364:	4d c0       	rjmp	.+154    	; 0x3400 <remove_chain+0xda>
    3366:	03 c0       	rjmp	.+6      	; 0x336e <remove_chain+0x48>
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
    3368:	46 01       	movw	r8, r12
    336a:	57 01       	movw	r10, r14
    336c:	02 c0       	rjmp	.+4      	; 0x3372 <remove_chain+0x4c>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
				fs->free_clust++;
				fs->fsi_flag = 1;
    336e:	77 24       	eor	r7, r7
    3370:	73 94       	inc	r7
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
    3372:	ce 01       	movw	r24, r28
    3374:	b5 01       	movw	r22, r10
    3376:	a4 01       	movw	r20, r8
    3378:	0e 94 49 11 	call	0x2292	; 0x2292 <get_fat>
    337c:	6b 01       	movw	r12, r22
    337e:	7c 01       	movw	r14, r24
			if (nxt == 0) break;				/* Empty cluster? */
    3380:	61 15       	cp	r22, r1
    3382:	71 05       	cpc	r23, r1
    3384:	81 05       	cpc	r24, r1
    3386:	91 05       	cpc	r25, r1
    3388:	e9 f1       	breq	.+122    	; 0x3404 <remove_chain+0xde>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    338a:	91 e0       	ldi	r25, 0x01	; 1
    338c:	c9 16       	cp	r12, r25
    338e:	d1 04       	cpc	r13, r1
    3390:	e1 04       	cpc	r14, r1
    3392:	f1 04       	cpc	r15, r1
    3394:	c9 f1       	breq	.+114    	; 0x3408 <remove_chain+0xe2>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    3396:	8f ef       	ldi	r24, 0xFF	; 255
    3398:	c8 16       	cp	r12, r24
    339a:	8f ef       	ldi	r24, 0xFF	; 255
    339c:	d8 06       	cpc	r13, r24
    339e:	8f ef       	ldi	r24, 0xFF	; 255
    33a0:	e8 06       	cpc	r14, r24
    33a2:	8f ef       	ldi	r24, 0xFF	; 255
    33a4:	f8 06       	cpc	r15, r24
    33a6:	91 f1       	breq	.+100    	; 0x340c <remove_chain+0xe6>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    33a8:	ce 01       	movw	r24, r28
    33aa:	b5 01       	movw	r22, r10
    33ac:	a4 01       	movw	r20, r8
    33ae:	00 e0       	ldi	r16, 0x00	; 0
    33b0:	10 e0       	ldi	r17, 0x00	; 0
    33b2:	98 01       	movw	r18, r16
    33b4:	0e 94 63 13 	call	0x26c6	; 0x26c6 <put_fat>
			if (res != FR_OK) break;
    33b8:	88 23       	and	r24, r24
    33ba:	49 f5       	brne	.+82     	; 0x340e <remove_chain+0xe8>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    33bc:	4e 85       	ldd	r20, Y+14	; 0x0e
    33be:	5f 85       	ldd	r21, Y+15	; 0x0f
    33c0:	68 89       	ldd	r22, Y+16	; 0x10
    33c2:	79 89       	ldd	r23, Y+17	; 0x11
    33c4:	4f 3f       	cpi	r20, 0xFF	; 255
    33c6:	9f ef       	ldi	r25, 0xFF	; 255
    33c8:	59 07       	cpc	r21, r25
    33ca:	9f ef       	ldi	r25, 0xFF	; 255
    33cc:	69 07       	cpc	r22, r25
    33ce:	9f ef       	ldi	r25, 0xFF	; 255
    33d0:	79 07       	cpc	r23, r25
    33d2:	49 f0       	breq	.+18     	; 0x33e6 <remove_chain+0xc0>
				fs->free_clust++;
    33d4:	4f 5f       	subi	r20, 0xFF	; 255
    33d6:	5f 4f       	sbci	r21, 0xFF	; 255
    33d8:	6f 4f       	sbci	r22, 0xFF	; 255
    33da:	7f 4f       	sbci	r23, 0xFF	; 255
    33dc:	4e 87       	std	Y+14, r20	; 0x0e
    33de:	5f 87       	std	Y+15, r21	; 0x0f
    33e0:	68 8b       	std	Y+16, r22	; 0x10
    33e2:	79 8b       	std	Y+17, r23	; 0x11
				fs->fsi_flag = 1;
    33e4:	7d 82       	std	Y+5, r7	; 0x05
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
    33e6:	4a 8d       	ldd	r20, Y+26	; 0x1a
    33e8:	5b 8d       	ldd	r21, Y+27	; 0x1b
    33ea:	6c 8d       	ldd	r22, Y+28	; 0x1c
    33ec:	7d 8d       	ldd	r23, Y+29	; 0x1d
    33ee:	c4 16       	cp	r12, r20
    33f0:	d5 06       	cpc	r13, r21
    33f2:	e6 06       	cpc	r14, r22
    33f4:	f7 06       	cpc	r15, r23
    33f6:	08 f4       	brcc	.+2      	; 0x33fa <remove_chain+0xd4>
    33f8:	b7 cf       	rjmp	.-146    	; 0x3368 <remove_chain+0x42>
    33fa:	09 c0       	rjmp	.+18     	; 0x340e <remove_chain+0xe8>
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
    33fc:	82 e0       	ldi	r24, 0x02	; 2
    33fe:	07 c0       	rjmp	.+14     	; 0x340e <remove_chain+0xe8>
    3400:	82 e0       	ldi	r24, 0x02	; 2
    3402:	05 c0       	rjmp	.+10     	; 0x340e <remove_chain+0xe8>

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
    3404:	80 e0       	ldi	r24, 0x00	; 0
    3406:	03 c0       	rjmp	.+6      	; 0x340e <remove_chain+0xe8>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    3408:	82 e0       	ldi	r24, 0x02	; 2
    340a:	01 c0       	rjmp	.+2      	; 0x340e <remove_chain+0xe8>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    340c:	81 e0       	ldi	r24, 0x01	; 1
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
    340e:	df 91       	pop	r29
    3410:	cf 91       	pop	r28
    3412:	1f 91       	pop	r17
    3414:	0f 91       	pop	r16
    3416:	ff 90       	pop	r15
    3418:	ef 90       	pop	r14
    341a:	df 90       	pop	r13
    341c:	cf 90       	pop	r12
    341e:	bf 90       	pop	r11
    3420:	af 90       	pop	r10
    3422:	9f 90       	pop	r9
    3424:	8f 90       	pop	r8
    3426:	7f 90       	pop	r7
    3428:	08 95       	ret

0000342a <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
    342a:	88 23       	and	r24, r24
    342c:	91 f4       	brne	.+36     	; 0x3452 <f_mount+0x28>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
    342e:	e0 91 f3 03 	lds	r30, 0x03F3
    3432:	f0 91 f4 03 	lds	r31, 0x03F4

	if (rfs) {
    3436:	30 97       	sbiw	r30, 0x00	; 0
    3438:	09 f0       	breq	.+2      	; 0x343c <f_mount+0x12>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
    343a:	10 82       	st	Z, r1
	}

	if (fs) {
    343c:	61 15       	cp	r22, r1
    343e:	71 05       	cpc	r23, r1
    3440:	11 f0       	breq	.+4      	; 0x3446 <f_mount+0x1c>
		fs->fs_type = 0;		/* Clear new fs object */
    3442:	fb 01       	movw	r30, r22
    3444:	10 82       	st	Z, r1
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
    3446:	70 93 f4 03 	sts	0x03F4, r23
    344a:	60 93 f3 03 	sts	0x03F3, r22

	return FR_OK;
    344e:	80 e0       	ldi	r24, 0x00	; 0
    3450:	08 95       	ret
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
    3452:	8b e0       	ldi	r24, 0x0B	; 11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
    3454:	08 95       	ret

00003456 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    3456:	4f 92       	push	r4
    3458:	5f 92       	push	r5
    345a:	6f 92       	push	r6
    345c:	7f 92       	push	r7
    345e:	8f 92       	push	r8
    3460:	9f 92       	push	r9
    3462:	af 92       	push	r10
    3464:	bf 92       	push	r11
    3466:	cf 92       	push	r12
    3468:	df 92       	push	r13
    346a:	ef 92       	push	r14
    346c:	ff 92       	push	r15
    346e:	0f 93       	push	r16
    3470:	1f 93       	push	r17
    3472:	cf 93       	push	r28
    3474:	df 93       	push	r29
    3476:	cd b7       	in	r28, 0x3d	; 61
    3478:	de b7       	in	r29, 0x3e	; 62
    347a:	a4 97       	sbiw	r28, 0x24	; 36
    347c:	0f b6       	in	r0, 0x3f	; 63
    347e:	f8 94       	cli
    3480:	de bf       	out	0x3e, r29	; 62
    3482:	0f be       	out	0x3f, r0	; 63
    3484:	cd bf       	out	0x3d, r28	; 61
    3486:	7c 01       	movw	r14, r24
    3488:	7c a3       	lds	r23, 0x5c
    348a:	6b a3       	lds	r22, 0x5b
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    348c:	00 97       	sbiw	r24, 0x00	; 0
    348e:	09 f4       	brne	.+2      	; 0x3492 <f_open+0x3c>
    3490:	ea c0       	rjmp	.+468    	; 0x3666 <f_open+0x210>
	fp->fs = 0;			/* Clear file object */
    3492:	fc 01       	movw	r30, r24
    3494:	11 82       	std	Z+1, r1	; 0x01
    3496:	10 82       	st	Z, r1

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    3498:	04 2f       	mov	r16, r20
    349a:	0f 71       	andi	r16, 0x1F	; 31
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
    349c:	4e 71       	andi	r20, 0x1E	; 30
    349e:	ce 01       	movw	r24, r28
    34a0:	83 96       	adiw	r24, 0x23	; 35
    34a2:	be 01       	movw	r22, r28
    34a4:	6f 5f       	subi	r22, 0xFF	; 255
    34a6:	7f 4f       	sbci	r23, 0xFF	; 255
    34a8:	0e 94 ac 0b 	call	0x1758	; 0x1758 <chk_mounted>
    34ac:	18 2f       	mov	r17, r24
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res == FR_OK) {
    34ae:	88 23       	and	r24, r24
    34b0:	09 f0       	breq	.+2      	; 0x34b4 <f_open+0x5e>
    34b2:	da c0       	rjmp	.+436    	; 0x3668 <f_open+0x212>
		INIT_BUF(dj);
    34b4:	ce 01       	movw	r24, r28
    34b6:	47 96       	adiw	r24, 0x17	; 23
    34b8:	9e 8b       	std	Y+22, r25	; 0x16
    34ba:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    34bc:	6b a1       	lds	r22, 0x4b
    34be:	7c a1       	lds	r23, 0x4c
    34c0:	ce 01       	movw	r24, r28
    34c2:	01 96       	adiw	r24, 0x01	; 1
    34c4:	0e 94 db 16 	call	0x2db6	; 0x2db6 <follow_path>
		dir = dj.dir;
    34c8:	cb 88       	ldd	r12, Y+19	; 0x13
    34ca:	dc 88       	ldd	r13, Y+20	; 0x14
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
    34cc:	88 23       	and	r24, r24
    34ce:	21 f4       	brne	.+8      	; 0x34d8 <f_open+0x82>
			if (!dir)	/* Current dir itself */
    34d0:	c1 14       	cp	r12, r1
    34d2:	d1 04       	cpc	r13, r1
    34d4:	09 f4       	brne	.+2      	; 0x34d8 <f_open+0x82>
				res = FR_INVALID_NAME;
    34d6:	86 e0       	ldi	r24, 0x06	; 6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    34d8:	40 2f       	mov	r20, r16
    34da:	50 e0       	ldi	r21, 0x00	; 0
    34dc:	9a 01       	movw	r18, r20
    34de:	2c 71       	andi	r18, 0x1C	; 28
    34e0:	30 70       	andi	r19, 0x00	; 0
    34e2:	21 15       	cp	r18, r1
    34e4:	31 05       	cpc	r19, r1
    34e6:	09 f4       	brne	.+2      	; 0x34ea <f_open+0x94>
    34e8:	5b c0       	rjmp	.+182    	; 0x35a0 <f_open+0x14a>
			DWORD dw, cl;

			if (res != FR_OK) {					/* No file, create new */
    34ea:	88 23       	and	r24, r24
    34ec:	71 f0       	breq	.+28     	; 0x350a <f_open+0xb4>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    34ee:	84 30       	cpi	r24, 0x04	; 4
    34f0:	09 f0       	breq	.+2      	; 0x34f4 <f_open+0x9e>
    34f2:	b7 c0       	rjmp	.+366    	; 0x3662 <f_open+0x20c>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
    34f4:	ce 01       	movw	r24, r28
    34f6:	01 96       	adiw	r24, 0x01	; 1
    34f8:	0e 94 02 19 	call	0x3204	; 0x3204 <dir_register>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
    34fc:	cb 88       	ldd	r12, Y+19	; 0x13
    34fe:	dc 88       	ldd	r13, Y+20	; 0x14
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    3500:	88 23       	and	r24, r24
    3502:	09 f0       	breq	.+2      	; 0x3506 <f_open+0xb0>
    3504:	ae c0       	rjmp	.+348    	; 0x3662 <f_open+0x20c>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
    3506:	08 60       	ori	r16, 0x08	; 8
    3508:	07 c0       	rjmp	.+14     	; 0x3518 <f_open+0xc2>
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    350a:	f6 01       	movw	r30, r12
    350c:	83 85       	ldd	r24, Z+11	; 0x0b
    350e:	81 71       	andi	r24, 0x11	; 17
    3510:	09 f0       	breq	.+2      	; 0x3514 <f_open+0xbe>
    3512:	c2 c0       	rjmp	.+388    	; 0x3698 <f_open+0x242>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    3514:	02 fd       	sbrc	r16, 2
    3516:	c2 c0       	rjmp	.+388    	; 0x369c <f_open+0x246>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    3518:	03 ff       	sbrs	r16, 3
    351a:	c6 c0       	rjmp	.+396    	; 0x36a8 <f_open+0x252>
				dw = get_fattime();					/* Created time */
    351c:	0e 94 0f 11 	call	0x221e	; 0x221e <get_fattime>
				ST_DWORD(dir+DIR_CrtTime, dw);
    3520:	f6 01       	movw	r30, r12
    3522:	66 87       	std	Z+14, r22	; 0x0e
    3524:	77 87       	std	Z+15, r23	; 0x0f
    3526:	80 8b       	std	Z+16, r24	; 0x10
    3528:	91 8b       	std	Z+17, r25	; 0x11
				dir[DIR_Attr] = 0;					/* Reset attribute */
    352a:	13 86       	std	Z+11, r1	; 0x0b
				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
    352c:	14 8e       	std	Z+28, r1	; 0x1c
    352e:	15 8e       	std	Z+29, r1	; 0x1d
    3530:	16 8e       	std	Z+30, r1	; 0x1e
    3532:	17 8e       	std	Z+31, r1	; 0x1f
				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
    3534:	89 81       	ldd	r24, Y+1	; 0x01
    3536:	9a 81       	ldd	r25, Y+2	; 0x02
    3538:	b6 01       	movw	r22, r12
    353a:	0e 94 2f 0a 	call	0x145e	; 0x145e <ld_clust>
    353e:	4b 01       	movw	r8, r22
    3540:	5c 01       	movw	r10, r24
				st_clust(dir, 0);					/* cluster = 0 */
    3542:	c6 01       	movw	r24, r12
    3544:	40 e0       	ldi	r20, 0x00	; 0
    3546:	50 e0       	ldi	r21, 0x00	; 0
    3548:	ba 01       	movw	r22, r20
    354a:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <st_clust>
				dj.fs->wflag = 1;
    354e:	e9 81       	ldd	r30, Y+1	; 0x01
    3550:	fa 81       	ldd	r31, Y+2	; 0x02
    3552:	81 e0       	ldi	r24, 0x01	; 1
    3554:	84 83       	std	Z+4, r24	; 0x04
				if (cl) {							/* Remove the cluster chain if exist */
    3556:	81 14       	cp	r8, r1
    3558:	91 04       	cpc	r9, r1
    355a:	a1 04       	cpc	r10, r1
    355c:	b1 04       	cpc	r11, r1
    355e:	09 f4       	brne	.+2      	; 0x3562 <f_open+0x10c>
    3560:	a3 c0       	rjmp	.+326    	; 0x36a8 <f_open+0x252>
					dw = dj.fs->winsect;
    3562:	46 a4       	lds	r20, 0xa6
    3564:	57 a4       	lds	r21, 0xa7
    3566:	60 a8       	sts	0x00, r22
    3568:	71 a8       	sts	0x81, r23
					res = remove_chain(dj.fs, cl);
    356a:	cf 01       	movw	r24, r30
    356c:	b5 01       	movw	r22, r10
    356e:	a4 01       	movw	r20, r8
    3570:	0e 94 93 19 	call	0x3326	; 0x3326 <remove_chain>
					if (res == FR_OK) {
    3574:	88 23       	and	r24, r24
    3576:	09 f0       	breq	.+2      	; 0x357a <f_open+0x124>
    3578:	74 c0       	rjmp	.+232    	; 0x3662 <f_open+0x20c>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    357a:	e9 81       	ldd	r30, Y+1	; 0x01
    357c:	fa 81       	ldd	r31, Y+2	; 0x02
    357e:	d5 01       	movw	r26, r10
    3580:	c4 01       	movw	r24, r8
    3582:	01 97       	sbiw	r24, 0x01	; 1
    3584:	a1 09       	sbc	r26, r1
    3586:	b1 09       	sbc	r27, r1
    3588:	82 87       	std	Z+10, r24	; 0x0a
    358a:	93 87       	std	Z+11, r25	; 0x0b
    358c:	a4 87       	std	Z+12, r26	; 0x0c
    358e:	b5 87       	std	Z+13, r27	; 0x0d
						res = move_window(dj.fs, dw);
    3590:	cf 01       	movw	r24, r30
    3592:	b3 01       	movw	r22, r6
    3594:	a2 01       	movw	r20, r4
    3596:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
    359a:	88 23       	and	r24, r24
    359c:	69 f0       	breq	.+26     	; 0x35b8 <f_open+0x162>
    359e:	61 c0       	rjmp	.+194    	; 0x3662 <f_open+0x20c>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {						/* Follow succeeded */
    35a0:	88 23       	and	r24, r24
    35a2:	09 f0       	breq	.+2      	; 0x35a6 <f_open+0x150>
    35a4:	5e c0       	rjmp	.+188    	; 0x3662 <f_open+0x20c>
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    35a6:	f6 01       	movw	r30, r12
    35a8:	83 85       	ldd	r24, Z+11	; 0x0b
    35aa:	84 fd       	sbrc	r24, 4
    35ac:	79 c0       	rjmp	.+242    	; 0x36a0 <f_open+0x24a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    35ae:	01 ff       	sbrs	r16, 1
    35b0:	7b c0       	rjmp	.+246    	; 0x36a8 <f_open+0x252>
    35b2:	80 fd       	sbrc	r24, 0
    35b4:	77 c0       	rjmp	.+238    	; 0x36a4 <f_open+0x24e>
    35b6:	78 c0       	rjmp	.+240    	; 0x36a8 <f_open+0x252>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
    35b8:	00 62       	ori	r16, 0x20	; 32
			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
    35ba:	a9 80       	ldd	r10, Y+1	; 0x01
    35bc:	ba 80       	ldd	r11, Y+2	; 0x02
    35be:	f5 01       	movw	r30, r10
    35c0:	86 a5       	lds	r24, 0x66
    35c2:	97 a5       	lds	r25, 0x67
    35c4:	a0 a9       	sts	0x40, r26
    35c6:	b1 a9       	sts	0x41, r27
    35c8:	f7 01       	movw	r30, r14
    35ca:	82 8f       	std	Z+26, r24	; 0x1a
    35cc:	93 8f       	std	Z+27, r25	; 0x1b
    35ce:	a4 8f       	std	Z+28, r26	; 0x1c
    35d0:	b5 8f       	std	Z+29, r27	; 0x1d
			fp->dir_ptr = dir;
    35d2:	d7 8e       	std	Z+31, r13	; 0x1f
    35d4:	c6 8e       	std	Z+30, r12	; 0x1e
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
    35d6:	04 83       	std	Z+4, r16	; 0x04
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
    35d8:	c5 01       	movw	r24, r10
    35da:	b6 01       	movw	r22, r12
    35dc:	0e 94 2f 0a 	call	0x145e	; 0x145e <ld_clust>
    35e0:	dc 01       	movw	r26, r24
    35e2:	cb 01       	movw	r24, r22
    35e4:	f7 01       	movw	r30, r14
    35e6:	86 87       	std	Z+14, r24	; 0x0e
    35e8:	97 87       	std	Z+15, r25	; 0x0f
    35ea:	a0 8b       	std	Z+16, r26	; 0x10
    35ec:	b1 8b       	std	Z+17, r27	; 0x11
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    35ee:	f6 01       	movw	r30, r12
    35f0:	87 8d       	ldd	r24, Z+31	; 0x1f
    35f2:	90 e0       	ldi	r25, 0x00	; 0
    35f4:	a0 e0       	ldi	r26, 0x00	; 0
    35f6:	b0 e0       	ldi	r27, 0x00	; 0
    35f8:	78 2f       	mov	r23, r24
    35fa:	66 27       	eor	r22, r22
    35fc:	55 27       	eor	r21, r21
    35fe:	44 27       	eor	r20, r20
    3600:	86 8d       	ldd	r24, Z+30	; 0x1e
    3602:	90 e0       	ldi	r25, 0x00	; 0
    3604:	a0 e0       	ldi	r26, 0x00	; 0
    3606:	b0 e0       	ldi	r27, 0x00	; 0
    3608:	dc 01       	movw	r26, r24
    360a:	99 27       	eor	r25, r25
    360c:	88 27       	eor	r24, r24
    360e:	48 2b       	or	r20, r24
    3610:	59 2b       	or	r21, r25
    3612:	6a 2b       	or	r22, r26
    3614:	7b 2b       	or	r23, r27
    3616:	84 8d       	ldd	r24, Z+28	; 0x1c
    3618:	90 e0       	ldi	r25, 0x00	; 0
    361a:	a0 e0       	ldi	r26, 0x00	; 0
    361c:	b0 e0       	ldi	r27, 0x00	; 0
    361e:	48 2b       	or	r20, r24
    3620:	59 2b       	or	r21, r25
    3622:	6a 2b       	or	r22, r26
    3624:	7b 2b       	or	r23, r27
    3626:	95 8d       	ldd	r25, Z+29	; 0x1d
    3628:	80 e0       	ldi	r24, 0x00	; 0
    362a:	a0 e0       	ldi	r26, 0x00	; 0
    362c:	b0 e0       	ldi	r27, 0x00	; 0
    362e:	84 2b       	or	r24, r20
    3630:	95 2b       	or	r25, r21
    3632:	a6 2b       	or	r26, r22
    3634:	b7 2b       	or	r27, r23
    3636:	f7 01       	movw	r30, r14
    3638:	82 87       	std	Z+10, r24	; 0x0a
    363a:	93 87       	std	Z+11, r25	; 0x0b
    363c:	a4 87       	std	Z+12, r26	; 0x0c
    363e:	b5 87       	std	Z+13, r27	; 0x0d
			fp->fptr = 0;						/* File pointer */
    3640:	16 82       	std	Z+6, r1	; 0x06
    3642:	17 82       	std	Z+7, r1	; 0x07
    3644:	10 86       	std	Z+8, r1	; 0x08
    3646:	11 86       	std	Z+9, r1	; 0x09
			fp->dsect = 0;
    3648:	16 8a       	std	Z+22, r1	; 0x16
    364a:	17 8a       	std	Z+23, r1	; 0x17
    364c:	10 8e       	std	Z+24, r1	; 0x18
    364e:	11 8e       	std	Z+25, r1	; 0x19
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    3650:	b1 82       	std	Z+1, r11	; 0x01
    3652:	a0 82       	st	Z, r10
    3654:	f5 01       	movw	r30, r10
    3656:	86 81       	ldd	r24, Z+6	; 0x06
    3658:	97 81       	ldd	r25, Z+7	; 0x07
    365a:	f7 01       	movw	r30, r14
    365c:	93 83       	std	Z+3, r25	; 0x03
    365e:	82 83       	std	Z+2, r24	; 0x02
    3660:	03 c0       	rjmp	.+6      	; 0x3668 <f_open+0x212>
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    3662:	18 2f       	mov	r17, r24
    3664:	01 c0       	rjmp	.+2      	; 0x3668 <f_open+0x212>
    3666:	19 e0       	ldi	r17, 0x09	; 9
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
		}
	}

	LEAVE_FF(dj.fs, res);
}
    3668:	81 2f       	mov	r24, r17
    366a:	a4 96       	adiw	r28, 0x24	; 36
    366c:	0f b6       	in	r0, 0x3f	; 63
    366e:	f8 94       	cli
    3670:	de bf       	out	0x3e, r29	; 62
    3672:	0f be       	out	0x3f, r0	; 63
    3674:	cd bf       	out	0x3d, r28	; 61
    3676:	df 91       	pop	r29
    3678:	cf 91       	pop	r28
    367a:	1f 91       	pop	r17
    367c:	0f 91       	pop	r16
    367e:	ff 90       	pop	r15
    3680:	ef 90       	pop	r14
    3682:	df 90       	pop	r13
    3684:	cf 90       	pop	r12
    3686:	bf 90       	pop	r11
    3688:	af 90       	pop	r10
    368a:	9f 90       	pop	r9
    368c:	8f 90       	pop	r8
    368e:	7f 90       	pop	r7
    3690:	6f 90       	pop	r6
    3692:	5f 90       	pop	r5
    3694:	4f 90       	pop	r4
    3696:	08 95       	ret
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
					res = FR_DENIED;
    3698:	87 e0       	ldi	r24, 0x07	; 7
    369a:	e3 cf       	rjmp	.-58     	; 0x3662 <f_open+0x20c>
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
    369c:	88 e0       	ldi	r24, 0x08	; 8
    369e:	e1 cf       	rjmp	.-62     	; 0x3662 <f_open+0x20c>
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {						/* Follow succeeded */
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
					res = FR_NO_FILE;
    36a0:	84 e0       	ldi	r24, 0x04	; 4
    36a2:	df cf       	rjmp	.-66     	; 0x3662 <f_open+0x20c>
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
    36a4:	87 e0       	ldi	r24, 0x07	; 7
    36a6:	dd cf       	rjmp	.-70     	; 0x3662 <f_open+0x20c>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
    36a8:	03 ff       	sbrs	r16, 3
    36aa:	87 cf       	rjmp	.-242    	; 0x35ba <f_open+0x164>
    36ac:	85 cf       	rjmp	.-246    	; 0x35b8 <f_open+0x162>

000036ae <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
    36ae:	2f 92       	push	r2
    36b0:	3f 92       	push	r3
    36b2:	4f 92       	push	r4
    36b4:	5f 92       	push	r5
    36b6:	6f 92       	push	r6
    36b8:	7f 92       	push	r7
    36ba:	8f 92       	push	r8
    36bc:	9f 92       	push	r9
    36be:	af 92       	push	r10
    36c0:	bf 92       	push	r11
    36c2:	cf 92       	push	r12
    36c4:	df 92       	push	r13
    36c6:	ef 92       	push	r14
    36c8:	ff 92       	push	r15
    36ca:	0f 93       	push	r16
    36cc:	1f 93       	push	r17
    36ce:	cf 93       	push	r28
    36d0:	df 93       	push	r29
    36d2:	cd b7       	in	r28, 0x3d	; 61
    36d4:	de b7       	in	r29, 0x3e	; 62
    36d6:	29 97       	sbiw	r28, 0x09	; 9
    36d8:	0f b6       	in	r0, 0x3f	; 63
    36da:	f8 94       	cli
    36dc:	de bf       	out	0x3e, r29	; 62
    36de:	0f be       	out	0x3f, r0	; 63
    36e0:	cd bf       	out	0x3d, r28	; 61
    36e2:	9c 83       	std	Y+4, r25	; 0x04
    36e4:	8b 83       	std	Y+3, r24	; 0x03
    36e6:	a6 2e       	mov	r10, r22
    36e8:	97 2e       	mov	r9, r23
    36ea:	c2 2e       	mov	r12, r18
    36ec:	f3 2e       	mov	r15, r19
    36ee:	e4 2e       	mov	r14, r20
    36f0:	d5 2e       	mov	r13, r21
    36f2:	18 01       	movw	r2, r16
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Clear read byte counter */
    36f4:	d8 01       	movw	r26, r16
    36f6:	1d 92       	st	X+, r1
    36f8:	1d 92       	st	X+, r1
    36fa:	1d 92       	st	X+, r1
    36fc:	1c 92       	st	X, r1
    36fe:	13 97       	sbiw	r26, 0x03	; 3

	res = validate(fp);							/* Check validity */
    3700:	0e 94 ef 0a 	call	0x15de	; 0x15de <validate>
    3704:	b8 2e       	mov	r11, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3706:	88 23       	and	r24, r24
    3708:	09 f0       	breq	.+2      	; 0x370c <f_read+0x5e>
    370a:	e1 c1       	rjmp	.+962    	; 0x3ace <f_read+0x420>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
    370c:	eb 81       	ldd	r30, Y+3	; 0x03
    370e:	fc 81       	ldd	r31, Y+4	; 0x04
    3710:	84 81       	ldd	r24, Z+4	; 0x04
    3712:	88 23       	and	r24, r24
    3714:	0c f4       	brge	.+2      	; 0x3718 <f_read+0x6a>
    3716:	d3 c1       	rjmp	.+934    	; 0x3abe <f_read+0x410>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    3718:	80 ff       	sbrs	r24, 0
    371a:	d5 c1       	rjmp	.+938    	; 0x3ac6 <f_read+0x418>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
    371c:	42 85       	ldd	r20, Z+10	; 0x0a
    371e:	53 85       	ldd	r21, Z+11	; 0x0b
    3720:	64 85       	ldd	r22, Z+12	; 0x0c
    3722:	75 85       	ldd	r23, Z+13	; 0x0d
    3724:	86 81       	ldd	r24, Z+6	; 0x06
    3726:	97 81       	ldd	r25, Z+7	; 0x07
    3728:	a0 85       	ldd	r26, Z+8	; 0x08
    372a:	b1 85       	ldd	r27, Z+9	; 0x09
    372c:	48 1b       	sub	r20, r24
    372e:	59 0b       	sbc	r21, r25
    3730:	6a 0b       	sbc	r22, r26
    3732:	7b 0b       	sbc	r23, r27

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    3734:	4c 2c       	mov	r4, r12
    3736:	5f 2c       	mov	r5, r15
    3738:	6e 2c       	mov	r6, r14
    373a:	7d 2c       	mov	r7, r13
    373c:	44 15       	cp	r20, r4
    373e:	55 05       	cpc	r21, r5
    3740:	66 05       	cpc	r22, r6
    3742:	77 05       	cpc	r23, r7
    3744:	10 f4       	brcc	.+4      	; 0x374a <f_read+0x9c>
    3746:	2a 01       	movw	r4, r20
    3748:	3b 01       	movw	r6, r22
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    374a:	41 14       	cp	r4, r1
    374c:	51 04       	cpc	r5, r1
    374e:	61 04       	cpc	r6, r1
    3750:	71 04       	cpc	r7, r1
    3752:	09 f4       	brne	.+2      	; 0x3756 <f_read+0xa8>
    3754:	bc c1       	rjmp	.+888    	; 0x3ace <f_read+0x420>
    3756:	a9 82       	std	Y+1, r10	; 0x01
    3758:	9a 82       	std	Y+2, r9	; 0x02
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    375a:	0b 81       	ldd	r16, Y+3	; 0x03
    375c:	1c 81       	ldd	r17, Y+4	; 0x04
    375e:	00 5e       	subi	r16, 0xE0	; 224
    3760:	1f 4f       	sbci	r17, 0xFF	; 255
    3762:	1e 83       	std	Y+6, r17	; 0x06
    3764:	0d 83       	std	Y+5, r16	; 0x05
    3766:	bf 82       	std	Y+7, r11	; 0x07
    3768:	2b 81       	ldd	r18, Y+3	; 0x03
    376a:	3c 81       	ldd	r19, Y+4	; 0x04
    376c:	39 87       	std	Y+9, r19	; 0x09
    376e:	28 87       	std	Y+8, r18	; 0x08
    3770:	3c 82       	std	Y+4, r3	; 0x04
    3772:	2b 82       	std	Y+3, r2	; 0x03
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    3774:	a8 85       	ldd	r26, Y+8	; 0x08
    3776:	b9 85       	ldd	r27, Y+9	; 0x09
    3778:	16 96       	adiw	r26, 0x06	; 6
    377a:	4d 91       	ld	r20, X+
    377c:	5d 91       	ld	r21, X+
    377e:	6d 91       	ld	r22, X+
    3780:	7c 91       	ld	r23, X
    3782:	19 97       	sbiw	r26, 0x09	; 9
    3784:	db 01       	movw	r26, r22
    3786:	ca 01       	movw	r24, r20
    3788:	91 70       	andi	r25, 0x01	; 1
    378a:	a0 70       	andi	r26, 0x00	; 0
    378c:	b0 70       	andi	r27, 0x00	; 0
    378e:	00 97       	sbiw	r24, 0x00	; 0
    3790:	a1 05       	cpc	r26, r1
    3792:	b1 05       	cpc	r27, r1
    3794:	09 f0       	breq	.+2      	; 0x3798 <f_read+0xea>
    3796:	3f c1       	rjmp	.+638    	; 0x3a16 <f_read+0x368>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    3798:	a8 85       	ldd	r26, Y+8	; 0x08
    379a:	b9 85       	ldd	r27, Y+9	; 0x09
    379c:	ed 91       	ld	r30, X+
    379e:	fc 91       	ld	r31, X
    37a0:	db 01       	movw	r26, r22
    37a2:	ca 01       	movw	r24, r20
    37a4:	07 2e       	mov	r0, r23
    37a6:	79 e0       	ldi	r23, 0x09	; 9
    37a8:	b6 95       	lsr	r27
    37aa:	a7 95       	ror	r26
    37ac:	97 95       	ror	r25
    37ae:	87 95       	ror	r24
    37b0:	7a 95       	dec	r23
    37b2:	d1 f7       	brne	.-12     	; 0x37a8 <f_read+0xfa>
    37b4:	70 2d       	mov	r23, r0
    37b6:	02 81       	ldd	r16, Z+2	; 0x02
    37b8:	01 50       	subi	r16, 0x01	; 1
    37ba:	08 23       	and	r16, r24
			if (!csect) {						/* On the cluster boundary? */
    37bc:	09 f0       	breq	.+2      	; 0x37c0 <f_read+0x112>
    37be:	44 c0       	rjmp	.+136    	; 0x3848 <f_read+0x19a>
				if (fp->fptr == 0) {			/* On the top of the file? */
    37c0:	41 15       	cp	r20, r1
    37c2:	51 05       	cpc	r21, r1
    37c4:	61 05       	cpc	r22, r1
    37c6:	71 05       	cpc	r23, r1
    37c8:	39 f4       	brne	.+14     	; 0x37d8 <f_read+0x12a>
					clst = fp->sclust;			/* Follow from the origin */
    37ca:	e8 85       	ldd	r30, Y+8	; 0x08
    37cc:	f9 85       	ldd	r31, Y+9	; 0x09
    37ce:	86 85       	ldd	r24, Z+14	; 0x0e
    37d0:	97 85       	ldd	r25, Z+15	; 0x0f
    37d2:	a0 89       	ldd	r26, Z+16	; 0x10
    37d4:	b1 89       	ldd	r27, Z+17	; 0x11
    37d6:	0d c0       	rjmp	.+26     	; 0x37f2 <f_read+0x144>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    37d8:	a8 85       	ldd	r26, Y+8	; 0x08
    37da:	b9 85       	ldd	r27, Y+9	; 0x09
    37dc:	52 96       	adiw	r26, 0x12	; 18
    37de:	4d 91       	ld	r20, X+
    37e0:	5d 91       	ld	r21, X+
    37e2:	6d 91       	ld	r22, X+
    37e4:	7c 91       	ld	r23, X
    37e6:	55 97       	sbiw	r26, 0x15	; 21
    37e8:	cf 01       	movw	r24, r30
    37ea:	0e 94 49 11 	call	0x2292	; 0x2292 <get_fat>
    37ee:	dc 01       	movw	r26, r24
    37f0:	cb 01       	movw	r24, r22
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    37f2:	82 30       	cpi	r24, 0x02	; 2
    37f4:	91 05       	cpc	r25, r1
    37f6:	a1 05       	cpc	r26, r1
    37f8:	b1 05       	cpc	r27, r1
    37fa:	48 f4       	brcc	.+18     	; 0x380e <f_read+0x160>
    37fc:	e8 85       	ldd	r30, Y+8	; 0x08
    37fe:	f9 85       	ldd	r31, Y+9	; 0x09
    3800:	84 81       	ldd	r24, Z+4	; 0x04
    3802:	80 68       	ori	r24, 0x80	; 128
    3804:	84 83       	std	Z+4, r24	; 0x04
    3806:	bb 24       	eor	r11, r11
    3808:	68 94       	set
    380a:	b1 f8       	bld	r11, 1
    380c:	60 c1       	rjmp	.+704    	; 0x3ace <f_read+0x420>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    380e:	8f 3f       	cpi	r24, 0xFF	; 255
    3810:	ff ef       	ldi	r31, 0xFF	; 255
    3812:	9f 07       	cpc	r25, r31
    3814:	ff ef       	ldi	r31, 0xFF	; 255
    3816:	af 07       	cpc	r26, r31
    3818:	ff ef       	ldi	r31, 0xFF	; 255
    381a:	bf 07       	cpc	r27, r31
    381c:	79 f4       	brne	.+30     	; 0x383c <f_read+0x18e>
    381e:	08 85       	ldd	r16, Y+8	; 0x08
    3820:	19 85       	ldd	r17, Y+9	; 0x09
    3822:	1c 83       	std	Y+4, r17	; 0x04
    3824:	0b 83       	std	Y+3, r16	; 0x03
    3826:	d8 01       	movw	r26, r16
    3828:	14 96       	adiw	r26, 0x04	; 4
    382a:	8c 91       	ld	r24, X
    382c:	14 97       	sbiw	r26, 0x04	; 4
    382e:	80 68       	ori	r24, 0x80	; 128
    3830:	14 96       	adiw	r26, 0x04	; 4
    3832:	8c 93       	st	X, r24
    3834:	14 97       	sbiw	r26, 0x04	; 4
    3836:	bb 24       	eor	r11, r11
    3838:	b3 94       	inc	r11
    383a:	49 c1       	rjmp	.+658    	; 0x3ace <f_read+0x420>
				fp->clust = clst;				/* Update current cluster */
    383c:	e8 85       	ldd	r30, Y+8	; 0x08
    383e:	f9 85       	ldd	r31, Y+9	; 0x09
    3840:	82 8b       	std	Z+18, r24	; 0x12
    3842:	93 8b       	std	Z+19, r25	; 0x13
    3844:	a4 8b       	std	Z+20, r26	; 0x14
    3846:	b5 8b       	std	Z+21, r27	; 0x15
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    3848:	a8 85       	ldd	r26, Y+8	; 0x08
    384a:	b9 85       	ldd	r27, Y+9	; 0x09
    384c:	2d 90       	ld	r2, X+
    384e:	3c 90       	ld	r3, X
    3850:	11 97       	sbiw	r26, 0x01	; 1
    3852:	52 96       	adiw	r26, 0x12	; 18
    3854:	4d 91       	ld	r20, X+
    3856:	5d 91       	ld	r21, X+
    3858:	6d 91       	ld	r22, X+
    385a:	7c 91       	ld	r23, X
    385c:	55 97       	sbiw	r26, 0x15	; 21
    385e:	c1 01       	movw	r24, r2
    3860:	0e 94 13 11 	call	0x2226	; 0x2226 <clust2sect>
    3864:	dc 01       	movw	r26, r24
    3866:	cb 01       	movw	r24, r22
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    3868:	00 97       	sbiw	r24, 0x00	; 0
    386a:	a1 05       	cpc	r26, r1
    386c:	b1 05       	cpc	r27, r1
    386e:	49 f4       	brne	.+18     	; 0x3882 <f_read+0x1d4>
    3870:	e8 85       	ldd	r30, Y+8	; 0x08
    3872:	f9 85       	ldd	r31, Y+9	; 0x09
    3874:	84 81       	ldd	r24, Z+4	; 0x04
    3876:	80 68       	ori	r24, 0x80	; 128
    3878:	84 83       	std	Z+4, r24	; 0x04
    387a:	bb 24       	eor	r11, r11
    387c:	68 94       	set
    387e:	b1 f8       	bld	r11, 1
    3880:	26 c1       	rjmp	.+588    	; 0x3ace <f_read+0x420>
			sect += csect;
    3882:	40 2f       	mov	r20, r16
    3884:	50 e0       	ldi	r21, 0x00	; 0
    3886:	60 e0       	ldi	r22, 0x00	; 0
    3888:	70 e0       	ldi	r23, 0x00	; 0
    388a:	4c 01       	movw	r8, r24
    388c:	5d 01       	movw	r10, r26
    388e:	84 0e       	add	r8, r20
    3890:	95 1e       	adc	r9, r21
    3892:	a6 1e       	adc	r10, r22
    3894:	b7 1e       	adc	r11, r23
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    3896:	73 01       	movw	r14, r6
    3898:	62 01       	movw	r12, r4
    389a:	0b 2e       	mov	r0, r27
    389c:	b9 e0       	ldi	r27, 0x09	; 9
    389e:	f6 94       	lsr	r15
    38a0:	e7 94       	ror	r14
    38a2:	d7 94       	ror	r13
    38a4:	c7 94       	ror	r12
    38a6:	ba 95       	dec	r27
    38a8:	d1 f7       	brne	.-12     	; 0x389e <f_read+0x1f0>
    38aa:	b0 2d       	mov	r27, r0
			if (cc) {							/* Read maximum contiguous sectors directly */
    38ac:	c1 14       	cp	r12, r1
    38ae:	d1 04       	cpc	r13, r1
    38b0:	e1 04       	cpc	r14, r1
    38b2:	f1 04       	cpc	r15, r1
    38b4:	09 f4       	brne	.+2      	; 0x38b8 <f_read+0x20a>
    38b6:	60 c0       	rjmp	.+192    	; 0x3978 <f_read+0x2ca>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    38b8:	d1 01       	movw	r26, r2
    38ba:	12 96       	adiw	r26, 0x02	; 2
    38bc:	2c 91       	ld	r18, X
    38be:	d7 01       	movw	r26, r14
    38c0:	c6 01       	movw	r24, r12
    38c2:	84 0f       	add	r24, r20
    38c4:	95 1f       	adc	r25, r21
    38c6:	a6 1f       	adc	r26, r22
    38c8:	b7 1f       	adc	r27, r23
    38ca:	42 2f       	mov	r20, r18
    38cc:	50 e0       	ldi	r21, 0x00	; 0
    38ce:	60 e0       	ldi	r22, 0x00	; 0
    38d0:	70 e0       	ldi	r23, 0x00	; 0
    38d2:	48 17       	cp	r20, r24
    38d4:	59 07       	cpc	r21, r25
    38d6:	6a 07       	cpc	r22, r26
    38d8:	7b 07       	cpc	r23, r27
    38da:	48 f4       	brcc	.+18     	; 0x38ee <f_read+0x240>
					cc = fp->fs->csize - csect;
    38dc:	82 2f       	mov	r24, r18
    38de:	90 e0       	ldi	r25, 0x00	; 0
    38e0:	80 1b       	sub	r24, r16
    38e2:	91 09       	sbc	r25, r1
    38e4:	6c 01       	movw	r12, r24
    38e6:	ee 24       	eor	r14, r14
    38e8:	d7 fc       	sbrc	r13, 7
    38ea:	e0 94       	com	r14
    38ec:	fe 2c       	mov	r15, r14
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    38ee:	f1 01       	movw	r30, r2
    38f0:	81 81       	ldd	r24, Z+1	; 0x01
    38f2:	69 81       	ldd	r22, Y+1	; 0x01
    38f4:	7a 81       	ldd	r23, Y+2	; 0x02
    38f6:	a5 01       	movw	r20, r10
    38f8:	94 01       	movw	r18, r8
    38fa:	0c 2d       	mov	r16, r12
    38fc:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    3900:	88 23       	and	r24, r24
    3902:	79 f0       	breq	.+30     	; 0x3922 <f_read+0x274>
    3904:	08 85       	ldd	r16, Y+8	; 0x08
    3906:	19 85       	ldd	r17, Y+9	; 0x09
    3908:	1c 83       	std	Y+4, r17	; 0x04
    390a:	0b 83       	std	Y+3, r16	; 0x03
					ABORT(fp->fs, FR_DISK_ERR);
    390c:	d8 01       	movw	r26, r16
    390e:	14 96       	adiw	r26, 0x04	; 4
    3910:	8c 91       	ld	r24, X
    3912:	14 97       	sbiw	r26, 0x04	; 4
    3914:	80 68       	ori	r24, 0x80	; 128
    3916:	14 96       	adiw	r26, 0x04	; 4
    3918:	8c 93       	st	X, r24
    391a:	14 97       	sbiw	r26, 0x04	; 4
    391c:	bb 24       	eor	r11, r11
    391e:	b3 94       	inc	r11
    3920:	d6 c0       	rjmp	.+428    	; 0x3ace <f_read+0x420>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
    3922:	e8 85       	ldd	r30, Y+8	; 0x08
    3924:	f9 85       	ldd	r31, Y+9	; 0x09
    3926:	84 81       	ldd	r24, Z+4	; 0x04
    3928:	86 ff       	sbrs	r24, 6
    392a:	1c c0       	rjmp	.+56     	; 0x3964 <f_read+0x2b6>
    392c:	86 89       	ldd	r24, Z+22	; 0x16
    392e:	97 89       	ldd	r25, Z+23	; 0x17
    3930:	a0 8d       	ldd	r26, Z+24	; 0x18
    3932:	b1 8d       	ldd	r27, Z+25	; 0x19
    3934:	88 19       	sub	r24, r8
    3936:	99 09       	sbc	r25, r9
    3938:	aa 09       	sbc	r26, r10
    393a:	bb 09       	sbc	r27, r11
    393c:	8c 15       	cp	r24, r12
    393e:	9d 05       	cpc	r25, r13
    3940:	ae 05       	cpc	r26, r14
    3942:	bf 05       	cpc	r27, r15
    3944:	78 f4       	brcc	.+30     	; 0x3964 <f_read+0x2b6>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
    3946:	98 2f       	mov	r25, r24
    3948:	88 27       	eor	r24, r24
    394a:	99 0f       	add	r25, r25
    394c:	09 81       	ldd	r16, Y+1	; 0x01
    394e:	1a 81       	ldd	r17, Y+2	; 0x02
    3950:	80 0f       	add	r24, r16
    3952:	91 1f       	adc	r25, r17
    3954:	6d 81       	ldd	r22, Y+5	; 0x05
    3956:	7e 81       	ldd	r23, Y+6	; 0x06
    3958:	20 e0       	ldi	r18, 0x00	; 0
    395a:	32 e0       	ldi	r19, 0x02	; 2
    395c:	40 e0       	ldi	r20, 0x00	; 0
    395e:	50 e0       	ldi	r21, 0x00	; 0
    3960:	0e 94 09 0a 	call	0x1412	; 0x1412 <mem_cpy>
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    3964:	0b 2e       	mov	r0, r27
    3966:	b9 e0       	ldi	r27, 0x09	; 9
    3968:	cc 0c       	add	r12, r12
    396a:	dd 1c       	adc	r13, r13
    396c:	ee 1c       	adc	r14, r14
    396e:	ff 1c       	adc	r15, r15
    3970:	ba 95       	dec	r27
    3972:	d1 f7       	brne	.-12     	; 0x3968 <f_read+0x2ba>
    3974:	b0 2d       	mov	r27, r0
				continue;
    3976:	79 c0       	rjmp	.+242    	; 0x3a6a <f_read+0x3bc>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
    3978:	a8 85       	ldd	r26, Y+8	; 0x08
    397a:	b9 85       	ldd	r27, Y+9	; 0x09
    397c:	56 96       	adiw	r26, 0x16	; 22
    397e:	0d 91       	ld	r16, X+
    3980:	1d 91       	ld	r17, X+
    3982:	2d 91       	ld	r18, X+
    3984:	3c 91       	ld	r19, X
    3986:	59 97       	sbiw	r26, 0x19	; 25
    3988:	08 15       	cp	r16, r8
    398a:	19 05       	cpc	r17, r9
    398c:	2a 05       	cpc	r18, r10
    398e:	3b 05       	cpc	r19, r11
    3990:	d1 f1       	breq	.+116    	; 0x3a06 <f_read+0x358>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
    3992:	14 96       	adiw	r26, 0x04	; 4
    3994:	8c 91       	ld	r24, X
    3996:	14 97       	sbiw	r26, 0x04	; 4
    3998:	86 ff       	sbrs	r24, 6
    399a:	1f c0       	rjmp	.+62     	; 0x39da <f_read+0x32c>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    399c:	f1 01       	movw	r30, r2
    399e:	81 81       	ldd	r24, Z+1	; 0x01
    39a0:	6d 81       	ldd	r22, Y+5	; 0x05
    39a2:	7e 81       	ldd	r23, Y+6	; 0x06
    39a4:	a9 01       	movw	r20, r18
    39a6:	98 01       	movw	r18, r16
    39a8:	01 e0       	ldi	r16, 0x01	; 1
    39aa:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    39ae:	88 23       	and	r24, r24
    39b0:	79 f0       	breq	.+30     	; 0x39d0 <f_read+0x322>
    39b2:	08 85       	ldd	r16, Y+8	; 0x08
    39b4:	19 85       	ldd	r17, Y+9	; 0x09
    39b6:	1c 83       	std	Y+4, r17	; 0x04
    39b8:	0b 83       	std	Y+3, r16	; 0x03
						ABORT(fp->fs, FR_DISK_ERR);
    39ba:	d8 01       	movw	r26, r16
    39bc:	14 96       	adiw	r26, 0x04	; 4
    39be:	8c 91       	ld	r24, X
    39c0:	14 97       	sbiw	r26, 0x04	; 4
    39c2:	80 68       	ori	r24, 0x80	; 128
    39c4:	14 96       	adiw	r26, 0x04	; 4
    39c6:	8c 93       	st	X, r24
    39c8:	14 97       	sbiw	r26, 0x04	; 4
    39ca:	bb 24       	eor	r11, r11
    39cc:	b3 94       	inc	r11
    39ce:	7f c0       	rjmp	.+254    	; 0x3ace <f_read+0x420>
					fp->flag &= ~FA__DIRTY;
    39d0:	e8 85       	ldd	r30, Y+8	; 0x08
    39d2:	f9 85       	ldd	r31, Y+9	; 0x09
    39d4:	84 81       	ldd	r24, Z+4	; 0x04
    39d6:	8f 7b       	andi	r24, 0xBF	; 191
    39d8:	84 83       	std	Z+4, r24	; 0x04
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    39da:	a8 85       	ldd	r26, Y+8	; 0x08
    39dc:	b9 85       	ldd	r27, Y+9	; 0x09
    39de:	ed 91       	ld	r30, X+
    39e0:	fc 91       	ld	r31, X
    39e2:	81 81       	ldd	r24, Z+1	; 0x01
    39e4:	6d 81       	ldd	r22, Y+5	; 0x05
    39e6:	7e 81       	ldd	r23, Y+6	; 0x06
    39e8:	a5 01       	movw	r20, r10
    39ea:	94 01       	movw	r18, r8
    39ec:	01 e0       	ldi	r16, 0x01	; 1
    39ee:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    39f2:	88 23       	and	r24, r24
    39f4:	41 f0       	breq	.+16     	; 0x3a06 <f_read+0x358>
    39f6:	e8 85       	ldd	r30, Y+8	; 0x08
    39f8:	f9 85       	ldd	r31, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    39fa:	84 81       	ldd	r24, Z+4	; 0x04
    39fc:	80 68       	ori	r24, 0x80	; 128
    39fe:	84 83       	std	Z+4, r24	; 0x04
    3a00:	bb 24       	eor	r11, r11
    3a02:	b3 94       	inc	r11
    3a04:	64 c0       	rjmp	.+200    	; 0x3ace <f_read+0x420>
			}
#endif
			fp->dsect = sect;
    3a06:	a8 85       	ldd	r26, Y+8	; 0x08
    3a08:	b9 85       	ldd	r27, Y+9	; 0x09
    3a0a:	56 96       	adiw	r26, 0x16	; 22
    3a0c:	8d 92       	st	X+, r8
    3a0e:	9d 92       	st	X+, r9
    3a10:	ad 92       	st	X+, r10
    3a12:	bc 92       	st	X, r11
    3a14:	59 97       	sbiw	r26, 0x19	; 25
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    3a16:	e8 85       	ldd	r30, Y+8	; 0x08
    3a18:	f9 85       	ldd	r31, Y+9	; 0x09
    3a1a:	46 81       	ldd	r20, Z+6	; 0x06
    3a1c:	57 81       	ldd	r21, Z+7	; 0x07
    3a1e:	60 85       	ldd	r22, Z+8	; 0x08
    3a20:	71 85       	ldd	r23, Z+9	; 0x09
    3a22:	db 01       	movw	r26, r22
    3a24:	ca 01       	movw	r24, r20
    3a26:	91 70       	andi	r25, 0x01	; 1
    3a28:	a0 70       	andi	r26, 0x00	; 0
    3a2a:	b0 70       	andi	r27, 0x00	; 0
    3a2c:	00 e0       	ldi	r16, 0x00	; 0
    3a2e:	12 e0       	ldi	r17, 0x02	; 2
    3a30:	20 e0       	ldi	r18, 0x00	; 0
    3a32:	30 e0       	ldi	r19, 0x00	; 0
    3a34:	08 1b       	sub	r16, r24
    3a36:	19 0b       	sbc	r17, r25
    3a38:	2a 0b       	sbc	r18, r26
    3a3a:	3b 0b       	sbc	r19, r27
    3a3c:	73 01       	movw	r14, r6
    3a3e:	62 01       	movw	r12, r4
    3a40:	04 15       	cp	r16, r4
    3a42:	15 05       	cpc	r17, r5
    3a44:	26 05       	cpc	r18, r6
    3a46:	37 05       	cpc	r19, r7
    3a48:	10 f4       	brcc	.+4      	; 0x3a4e <f_read+0x3a0>
    3a4a:	68 01       	movw	r12, r16
    3a4c:	79 01       	movw	r14, r18
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    3a4e:	ba 01       	movw	r22, r20
    3a50:	71 70       	andi	r23, 0x01	; 1
    3a52:	60 5e       	subi	r22, 0xE0	; 224
    3a54:	7f 4f       	sbci	r23, 0xFF	; 255
    3a56:	28 85       	ldd	r18, Y+8	; 0x08
    3a58:	39 85       	ldd	r19, Y+9	; 0x09
    3a5a:	62 0f       	add	r22, r18
    3a5c:	73 1f       	adc	r23, r19
    3a5e:	89 81       	ldd	r24, Y+1	; 0x01
    3a60:	9a 81       	ldd	r25, Y+2	; 0x02
    3a62:	a7 01       	movw	r20, r14
    3a64:	96 01       	movw	r18, r12
    3a66:	0e 94 09 0a 	call	0x1412	; 0x1412 <mem_cpy>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    3a6a:	89 81       	ldd	r24, Y+1	; 0x01
    3a6c:	9a 81       	ldd	r25, Y+2	; 0x02
    3a6e:	8c 0d       	add	r24, r12
    3a70:	9d 1d       	adc	r25, r13
    3a72:	9a 83       	std	Y+2, r25	; 0x02
    3a74:	89 83       	std	Y+1, r24	; 0x01
    3a76:	e8 85       	ldd	r30, Y+8	; 0x08
    3a78:	f9 85       	ldd	r31, Y+9	; 0x09
    3a7a:	86 81       	ldd	r24, Z+6	; 0x06
    3a7c:	97 81       	ldd	r25, Z+7	; 0x07
    3a7e:	a0 85       	ldd	r26, Z+8	; 0x08
    3a80:	b1 85       	ldd	r27, Z+9	; 0x09
    3a82:	8c 0d       	add	r24, r12
    3a84:	9d 1d       	adc	r25, r13
    3a86:	ae 1d       	adc	r26, r14
    3a88:	bf 1d       	adc	r27, r15
    3a8a:	86 83       	std	Z+6, r24	; 0x06
    3a8c:	97 83       	std	Z+7, r25	; 0x07
    3a8e:	a0 87       	std	Z+8, r26	; 0x08
    3a90:	b1 87       	std	Z+9, r27	; 0x09
    3a92:	eb 81       	ldd	r30, Y+3	; 0x03
    3a94:	fc 81       	ldd	r31, Y+4	; 0x04
    3a96:	80 81       	ld	r24, Z
    3a98:	91 81       	ldd	r25, Z+1	; 0x01
    3a9a:	a2 81       	ldd	r26, Z+2	; 0x02
    3a9c:	b3 81       	ldd	r27, Z+3	; 0x03
    3a9e:	8c 0d       	add	r24, r12
    3aa0:	9d 1d       	adc	r25, r13
    3aa2:	ae 1d       	adc	r26, r14
    3aa4:	bf 1d       	adc	r27, r15
    3aa6:	80 83       	st	Z, r24
    3aa8:	91 83       	std	Z+1, r25	; 0x01
    3aaa:	a2 83       	std	Z+2, r26	; 0x02
    3aac:	b3 83       	std	Z+3, r27	; 0x03
    3aae:	4c 18       	sub	r4, r12
    3ab0:	5d 08       	sbc	r5, r13
    3ab2:	6e 08       	sbc	r6, r14
    3ab4:	7f 08       	sbc	r7, r15
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    3ab6:	09 f0       	breq	.+2      	; 0x3aba <f_read+0x40c>
    3ab8:	5d ce       	rjmp	.-838    	; 0x3774 <f_read+0xc6>
    3aba:	bf 80       	ldd	r11, Y+7	; 0x07
    3abc:	08 c0       	rjmp	.+16     	; 0x3ace <f_read+0x420>
	*br = 0;	/* Clear read byte counter */

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    3abe:	bb 24       	eor	r11, r11
    3ac0:	68 94       	set
    3ac2:	b1 f8       	bld	r11, 1
    3ac4:	04 c0       	rjmp	.+8      	; 0x3ace <f_read+0x420>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    3ac6:	0f 2e       	mov	r0, r31
    3ac8:	f7 e0       	ldi	r31, 0x07	; 7
    3aca:	bf 2e       	mov	r11, r31
    3acc:	f0 2d       	mov	r31, r0
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    3ace:	8b 2d       	mov	r24, r11
    3ad0:	29 96       	adiw	r28, 0x09	; 9
    3ad2:	0f b6       	in	r0, 0x3f	; 63
    3ad4:	f8 94       	cli
    3ad6:	de bf       	out	0x3e, r29	; 62
    3ad8:	0f be       	out	0x3f, r0	; 63
    3ada:	cd bf       	out	0x3d, r28	; 61
    3adc:	df 91       	pop	r29
    3ade:	cf 91       	pop	r28
    3ae0:	1f 91       	pop	r17
    3ae2:	0f 91       	pop	r16
    3ae4:	ff 90       	pop	r15
    3ae6:	ef 90       	pop	r14
    3ae8:	df 90       	pop	r13
    3aea:	cf 90       	pop	r12
    3aec:	bf 90       	pop	r11
    3aee:	af 90       	pop	r10
    3af0:	9f 90       	pop	r9
    3af2:	8f 90       	pop	r8
    3af4:	7f 90       	pop	r7
    3af6:	6f 90       	pop	r6
    3af8:	5f 90       	pop	r5
    3afa:	4f 90       	pop	r4
    3afc:	3f 90       	pop	r3
    3afe:	2f 90       	pop	r2
    3b00:	08 95       	ret

00003b02 <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
    3b02:	2f 92       	push	r2
    3b04:	3f 92       	push	r3
    3b06:	4f 92       	push	r4
    3b08:	5f 92       	push	r5
    3b0a:	6f 92       	push	r6
    3b0c:	7f 92       	push	r7
    3b0e:	8f 92       	push	r8
    3b10:	9f 92       	push	r9
    3b12:	af 92       	push	r10
    3b14:	bf 92       	push	r11
    3b16:	cf 92       	push	r12
    3b18:	df 92       	push	r13
    3b1a:	ef 92       	push	r14
    3b1c:	ff 92       	push	r15
    3b1e:	0f 93       	push	r16
    3b20:	1f 93       	push	r17
    3b22:	cf 93       	push	r28
    3b24:	df 93       	push	r29
    3b26:	cd b7       	in	r28, 0x3d	; 61
    3b28:	de b7       	in	r29, 0x3e	; 62
    3b2a:	29 97       	sbiw	r28, 0x09	; 9
    3b2c:	0f b6       	in	r0, 0x3f	; 63
    3b2e:	f8 94       	cli
    3b30:	de bf       	out	0x3e, r29	; 62
    3b32:	0f be       	out	0x3f, r0	; 63
    3b34:	cd bf       	out	0x3d, r28	; 61
    3b36:	2c 01       	movw	r4, r24
    3b38:	c6 2e       	mov	r12, r22
    3b3a:	f7 2e       	mov	r15, r23
    3b3c:	49 01       	movw	r8, r18
    3b3e:	5a 01       	movw	r10, r20
    3b40:	1a 83       	std	Y+2, r17	; 0x02
    3b42:	09 83       	std	Y+1, r16	; 0x01
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
    3b44:	d8 01       	movw	r26, r16
    3b46:	1d 92       	st	X+, r1
    3b48:	1d 92       	st	X+, r1
    3b4a:	1d 92       	st	X+, r1
    3b4c:	1c 92       	st	X, r1
    3b4e:	13 97       	sbiw	r26, 0x03	; 3

	res = validate(fp);						/* Check validity */
    3b50:	0e 94 ef 0a 	call	0x15de	; 0x15de <validate>
    3b54:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3b56:	88 23       	and	r24, r24
    3b58:	09 f0       	breq	.+2      	; 0x3b5c <f_write+0x5a>
    3b5a:	17 c2       	rjmp	.+1070   	; 0x3f8a <f_write+0x488>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
    3b5c:	f2 01       	movw	r30, r4
    3b5e:	84 81       	ldd	r24, Z+4	; 0x04
    3b60:	88 23       	and	r24, r24
    3b62:	0c f4       	brge	.+2      	; 0x3b66 <f_write+0x64>
    3b64:	0f c2       	rjmp	.+1054   	; 0x3f84 <f_write+0x482>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    3b66:	81 ff       	sbrs	r24, 1
    3b68:	0f c2       	rjmp	.+1054   	; 0x3f88 <f_write+0x486>
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
    3b6a:	82 85       	ldd	r24, Z+10	; 0x0a
    3b6c:	93 85       	ldd	r25, Z+11	; 0x0b
    3b6e:	a4 85       	ldd	r26, Z+12	; 0x0c
    3b70:	b5 85       	ldd	r27, Z+13	; 0x0d
    3b72:	b5 01       	movw	r22, r10
    3b74:	a4 01       	movw	r20, r8
    3b76:	48 0f       	add	r20, r24
    3b78:	59 1f       	adc	r21, r25
    3b7a:	6a 1f       	adc	r22, r26
    3b7c:	7b 1f       	adc	r23, r27
    3b7e:	48 17       	cp	r20, r24
    3b80:	59 07       	cpc	r21, r25
    3b82:	6a 07       	cpc	r22, r26
    3b84:	7b 07       	cpc	r23, r27
    3b86:	08 f4       	brcc	.+2      	; 0x3b8a <f_write+0x88>
    3b88:	e2 c1       	rjmp	.+964    	; 0x3f4e <f_write+0x44c>

	for ( ;  btw;							/* Repeat until all data written */
    3b8a:	81 14       	cp	r8, r1
    3b8c:	91 04       	cpc	r9, r1
    3b8e:	a1 04       	cpc	r10, r1
    3b90:	b1 04       	cpc	r11, r1
    3b92:	09 f4       	brne	.+2      	; 0x3b96 <f_write+0x94>
    3b94:	dc c1       	rjmp	.+952    	; 0x3f4e <f_write+0x44c>
    3b96:	cb 82       	std	Y+3, r12	; 0x03
    3b98:	fc 82       	std	Y+4, r15	; 0x04
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    3b9a:	92 01       	movw	r18, r4
    3b9c:	20 5e       	subi	r18, 0xE0	; 224
    3b9e:	3f 4f       	sbci	r19, 0xFF	; 255
    3ba0:	3e 83       	std	Y+6, r19	; 0x06
    3ba2:	2d 83       	std	Y+5, r18	; 0x05
    3ba4:	1f 83       	std	Y+7, r17	; 0x07
    3ba6:	59 86       	std	Y+9, r5	; 0x09
    3ba8:	48 86       	std	Y+8, r4	; 0x08
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    3baa:	a8 85       	ldd	r26, Y+8	; 0x08
    3bac:	b9 85       	ldd	r27, Y+9	; 0x09
    3bae:	16 96       	adiw	r26, 0x06	; 6
    3bb0:	4d 91       	ld	r20, X+
    3bb2:	5d 91       	ld	r21, X+
    3bb4:	6d 91       	ld	r22, X+
    3bb6:	7c 91       	ld	r23, X
    3bb8:	19 97       	sbiw	r26, 0x09	; 9
    3bba:	db 01       	movw	r26, r22
    3bbc:	ca 01       	movw	r24, r20
    3bbe:	91 70       	andi	r25, 0x01	; 1
    3bc0:	a0 70       	andi	r26, 0x00	; 0
    3bc2:	b0 70       	andi	r27, 0x00	; 0
    3bc4:	00 97       	sbiw	r24, 0x00	; 0
    3bc6:	a1 05       	cpc	r26, r1
    3bc8:	b1 05       	cpc	r27, r1
    3bca:	09 f0       	breq	.+2      	; 0x3bce <f_write+0xcc>
    3bcc:	60 c1       	rjmp	.+704    	; 0x3e8e <f_write+0x38c>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    3bce:	e8 85       	ldd	r30, Y+8	; 0x08
    3bd0:	f9 85       	ldd	r31, Y+9	; 0x09
    3bd2:	20 81       	ld	r18, Z
    3bd4:	31 81       	ldd	r19, Z+1	; 0x01
    3bd6:	db 01       	movw	r26, r22
    3bd8:	ca 01       	movw	r24, r20
    3bda:	07 2e       	mov	r0, r23
    3bdc:	79 e0       	ldi	r23, 0x09	; 9
    3bde:	b6 95       	lsr	r27
    3be0:	a7 95       	ror	r26
    3be2:	97 95       	ror	r25
    3be4:	87 95       	ror	r24
    3be6:	7a 95       	dec	r23
    3be8:	d1 f7       	brne	.-12     	; 0x3bde <f_write+0xdc>
    3bea:	70 2d       	mov	r23, r0
    3bec:	f9 01       	movw	r30, r18
    3bee:	12 81       	ldd	r17, Z+2	; 0x02
    3bf0:	11 50       	subi	r17, 0x01	; 1
    3bf2:	18 23       	and	r17, r24
			if (!csect) {					/* On the cluster boundary? */
    3bf4:	09 f0       	breq	.+2      	; 0x3bf8 <f_write+0xf6>
    3bf6:	57 c0       	rjmp	.+174    	; 0x3ca6 <f_write+0x1a4>
				if (fp->fptr == 0) {		/* On the top of the file? */
    3bf8:	41 15       	cp	r20, r1
    3bfa:	51 05       	cpc	r21, r1
    3bfc:	61 05       	cpc	r22, r1
    3bfe:	71 05       	cpc	r23, r1
    3c00:	c9 f4       	brne	.+50     	; 0x3c34 <f_write+0x132>
					clst = fp->sclust;		/* Follow from the origin */
    3c02:	e8 85       	ldd	r30, Y+8	; 0x08
    3c04:	f9 85       	ldd	r31, Y+9	; 0x09
    3c06:	86 85       	ldd	r24, Z+14	; 0x0e
    3c08:	97 85       	ldd	r25, Z+15	; 0x0f
    3c0a:	a0 89       	ldd	r26, Z+16	; 0x10
    3c0c:	b1 89       	ldd	r27, Z+17	; 0x11
					if (clst == 0)			/* When no cluster is allocated, */
    3c0e:	00 97       	sbiw	r24, 0x00	; 0
    3c10:	a1 05       	cpc	r26, r1
    3c12:	b1 05       	cpc	r27, r1
    3c14:	09 f5       	brne	.+66     	; 0x3c58 <f_write+0x156>
						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    3c16:	c9 01       	movw	r24, r18
    3c18:	40 e0       	ldi	r20, 0x00	; 0
    3c1a:	50 e0       	ldi	r21, 0x00	; 0
    3c1c:	ba 01       	movw	r22, r20
    3c1e:	0e 94 72 14 	call	0x28e4	; 0x28e4 <create_chain>
    3c22:	dc 01       	movw	r26, r24
    3c24:	cb 01       	movw	r24, r22
    3c26:	e8 85       	ldd	r30, Y+8	; 0x08
    3c28:	f9 85       	ldd	r31, Y+9	; 0x09
    3c2a:	86 87       	std	Z+14, r24	; 0x0e
    3c2c:	97 87       	std	Z+15, r25	; 0x0f
    3c2e:	a0 8b       	std	Z+16, r26	; 0x10
    3c30:	b1 8b       	std	Z+17, r27	; 0x11
    3c32:	0d c0       	rjmp	.+26     	; 0x3c4e <f_write+0x14c>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    3c34:	a8 85       	ldd	r26, Y+8	; 0x08
    3c36:	b9 85       	ldd	r27, Y+9	; 0x09
    3c38:	52 96       	adiw	r26, 0x12	; 18
    3c3a:	4d 91       	ld	r20, X+
    3c3c:	5d 91       	ld	r21, X+
    3c3e:	6d 91       	ld	r22, X+
    3c40:	7c 91       	ld	r23, X
    3c42:	55 97       	sbiw	r26, 0x15	; 21
    3c44:	c9 01       	movw	r24, r18
    3c46:	0e 94 72 14 	call	0x28e4	; 0x28e4 <create_chain>
    3c4a:	dc 01       	movw	r26, r24
    3c4c:	cb 01       	movw	r24, r22
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    3c4e:	00 97       	sbiw	r24, 0x00	; 0
    3c50:	a1 05       	cpc	r26, r1
    3c52:	b1 05       	cpc	r27, r1
    3c54:	09 f4       	brne	.+2      	; 0x3c58 <f_write+0x156>
    3c56:	78 c1       	rjmp	.+752    	; 0x3f48 <f_write+0x446>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    3c58:	81 30       	cpi	r24, 0x01	; 1
    3c5a:	91 05       	cpc	r25, r1
    3c5c:	a1 05       	cpc	r26, r1
    3c5e:	b1 05       	cpc	r27, r1
    3c60:	41 f4       	brne	.+16     	; 0x3c72 <f_write+0x170>
    3c62:	48 84       	ldd	r4, Y+8	; 0x08
    3c64:	59 84       	ldd	r5, Y+9	; 0x09
    3c66:	f2 01       	movw	r30, r4
    3c68:	84 81       	ldd	r24, Z+4	; 0x04
    3c6a:	80 68       	ori	r24, 0x80	; 128
    3c6c:	84 83       	std	Z+4, r24	; 0x04
    3c6e:	12 e0       	ldi	r17, 0x02	; 2
    3c70:	8c c1       	rjmp	.+792    	; 0x3f8a <f_write+0x488>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3c72:	8f 3f       	cpi	r24, 0xFF	; 255
    3c74:	ff ef       	ldi	r31, 0xFF	; 255
    3c76:	9f 07       	cpc	r25, r31
    3c78:	ff ef       	ldi	r31, 0xFF	; 255
    3c7a:	af 07       	cpc	r26, r31
    3c7c:	ff ef       	ldi	r31, 0xFF	; 255
    3c7e:	bf 07       	cpc	r27, r31
    3c80:	61 f4       	brne	.+24     	; 0x3c9a <f_write+0x198>
    3c82:	48 84       	ldd	r4, Y+8	; 0x08
    3c84:	59 84       	ldd	r5, Y+9	; 0x09
    3c86:	d2 01       	movw	r26, r4
    3c88:	14 96       	adiw	r26, 0x04	; 4
    3c8a:	8c 91       	ld	r24, X
    3c8c:	14 97       	sbiw	r26, 0x04	; 4
    3c8e:	80 68       	ori	r24, 0x80	; 128
    3c90:	14 96       	adiw	r26, 0x04	; 4
    3c92:	8c 93       	st	X, r24
    3c94:	14 97       	sbiw	r26, 0x04	; 4
    3c96:	11 e0       	ldi	r17, 0x01	; 1
    3c98:	78 c1       	rjmp	.+752    	; 0x3f8a <f_write+0x488>
				fp->clust = clst;			/* Update current cluster */
    3c9a:	e8 85       	ldd	r30, Y+8	; 0x08
    3c9c:	f9 85       	ldd	r31, Y+9	; 0x09
    3c9e:	82 8b       	std	Z+18, r24	; 0x12
    3ca0:	93 8b       	std	Z+19, r25	; 0x13
    3ca2:	a4 8b       	std	Z+20, r26	; 0x14
    3ca4:	b5 8b       	std	Z+21, r27	; 0x15
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
    3ca6:	a8 85       	ldd	r26, Y+8	; 0x08
    3ca8:	b9 85       	ldd	r27, Y+9	; 0x09
    3caa:	14 96       	adiw	r26, 0x04	; 4
    3cac:	8c 91       	ld	r24, X
    3cae:	14 97       	sbiw	r26, 0x04	; 4
    3cb0:	86 ff       	sbrs	r24, 6
    3cb2:	21 c0       	rjmp	.+66     	; 0x3cf6 <f_write+0x1f4>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3cb4:	ed 91       	ld	r30, X+
    3cb6:	fc 91       	ld	r31, X
    3cb8:	11 97       	sbiw	r26, 0x01	; 1
    3cba:	56 96       	adiw	r26, 0x16	; 22
    3cbc:	2d 91       	ld	r18, X+
    3cbe:	3d 91       	ld	r19, X+
    3cc0:	4d 91       	ld	r20, X+
    3cc2:	5c 91       	ld	r21, X
    3cc4:	59 97       	sbiw	r26, 0x19	; 25
    3cc6:	81 81       	ldd	r24, Z+1	; 0x01
    3cc8:	6d 81       	ldd	r22, Y+5	; 0x05
    3cca:	7e 81       	ldd	r23, Y+6	; 0x06
    3ccc:	01 e0       	ldi	r16, 0x01	; 1
    3cce:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    3cd2:	88 23       	and	r24, r24
    3cd4:	41 f0       	breq	.+16     	; 0x3ce6 <f_write+0x1e4>
    3cd6:	48 84       	ldd	r4, Y+8	; 0x08
    3cd8:	59 84       	ldd	r5, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3cda:	f2 01       	movw	r30, r4
    3cdc:	84 81       	ldd	r24, Z+4	; 0x04
    3cde:	80 68       	ori	r24, 0x80	; 128
    3ce0:	84 83       	std	Z+4, r24	; 0x04
    3ce2:	11 e0       	ldi	r17, 0x01	; 1
    3ce4:	52 c1       	rjmp	.+676    	; 0x3f8a <f_write+0x488>
				fp->flag &= ~FA__DIRTY;
    3ce6:	a8 85       	ldd	r26, Y+8	; 0x08
    3ce8:	b9 85       	ldd	r27, Y+9	; 0x09
    3cea:	14 96       	adiw	r26, 0x04	; 4
    3cec:	8c 91       	ld	r24, X
    3cee:	14 97       	sbiw	r26, 0x04	; 4
    3cf0:	8f 7b       	andi	r24, 0xBF	; 191
    3cf2:	14 96       	adiw	r26, 0x04	; 4
    3cf4:	8c 93       	st	X, r24
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    3cf6:	e8 85       	ldd	r30, Y+8	; 0x08
    3cf8:	f9 85       	ldd	r31, Y+9	; 0x09
    3cfa:	20 80       	ld	r2, Z
    3cfc:	31 80       	ldd	r3, Z+1	; 0x01
    3cfe:	42 89       	ldd	r20, Z+18	; 0x12
    3d00:	53 89       	ldd	r21, Z+19	; 0x13
    3d02:	64 89       	ldd	r22, Z+20	; 0x14
    3d04:	75 89       	ldd	r23, Z+21	; 0x15
    3d06:	c1 01       	movw	r24, r2
    3d08:	0e 94 13 11 	call	0x2226	; 0x2226 <clust2sect>
    3d0c:	dc 01       	movw	r26, r24
    3d0e:	cb 01       	movw	r24, r22
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    3d10:	00 97       	sbiw	r24, 0x00	; 0
    3d12:	a1 05       	cpc	r26, r1
    3d14:	b1 05       	cpc	r27, r1
    3d16:	61 f4       	brne	.+24     	; 0x3d30 <f_write+0x22e>
    3d18:	48 84       	ldd	r4, Y+8	; 0x08
    3d1a:	59 84       	ldd	r5, Y+9	; 0x09
    3d1c:	d2 01       	movw	r26, r4
    3d1e:	14 96       	adiw	r26, 0x04	; 4
    3d20:	8c 91       	ld	r24, X
    3d22:	14 97       	sbiw	r26, 0x04	; 4
    3d24:	80 68       	ori	r24, 0x80	; 128
    3d26:	14 96       	adiw	r26, 0x04	; 4
    3d28:	8c 93       	st	X, r24
    3d2a:	14 97       	sbiw	r26, 0x04	; 4
    3d2c:	12 e0       	ldi	r17, 0x02	; 2
    3d2e:	2d c1       	rjmp	.+602    	; 0x3f8a <f_write+0x488>
			sect += csect;
    3d30:	41 2f       	mov	r20, r17
    3d32:	50 e0       	ldi	r21, 0x00	; 0
    3d34:	60 e0       	ldi	r22, 0x00	; 0
    3d36:	70 e0       	ldi	r23, 0x00	; 0
    3d38:	2c 01       	movw	r4, r24
    3d3a:	3d 01       	movw	r6, r26
    3d3c:	44 0e       	add	r4, r20
    3d3e:	55 1e       	adc	r5, r21
    3d40:	66 1e       	adc	r6, r22
    3d42:	77 1e       	adc	r7, r23
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    3d44:	75 01       	movw	r14, r10
    3d46:	64 01       	movw	r12, r8
    3d48:	0b 2e       	mov	r0, r27
    3d4a:	b9 e0       	ldi	r27, 0x09	; 9
    3d4c:	f6 94       	lsr	r15
    3d4e:	e7 94       	ror	r14
    3d50:	d7 94       	ror	r13
    3d52:	c7 94       	ror	r12
    3d54:	ba 95       	dec	r27
    3d56:	d1 f7       	brne	.-12     	; 0x3d4c <f_write+0x24a>
    3d58:	b0 2d       	mov	r27, r0
			if (cc) {						/* Write maximum contiguous sectors directly */
    3d5a:	c1 14       	cp	r12, r1
    3d5c:	d1 04       	cpc	r13, r1
    3d5e:	e1 04       	cpc	r14, r1
    3d60:	f1 04       	cpc	r15, r1
    3d62:	09 f4       	brne	.+2      	; 0x3d66 <f_write+0x264>
    3d64:	60 c0       	rjmp	.+192    	; 0x3e26 <f_write+0x324>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    3d66:	f1 01       	movw	r30, r2
    3d68:	22 81       	ldd	r18, Z+2	; 0x02
    3d6a:	d7 01       	movw	r26, r14
    3d6c:	c6 01       	movw	r24, r12
    3d6e:	84 0f       	add	r24, r20
    3d70:	95 1f       	adc	r25, r21
    3d72:	a6 1f       	adc	r26, r22
    3d74:	b7 1f       	adc	r27, r23
    3d76:	42 2f       	mov	r20, r18
    3d78:	50 e0       	ldi	r21, 0x00	; 0
    3d7a:	60 e0       	ldi	r22, 0x00	; 0
    3d7c:	70 e0       	ldi	r23, 0x00	; 0
    3d7e:	48 17       	cp	r20, r24
    3d80:	59 07       	cpc	r21, r25
    3d82:	6a 07       	cpc	r22, r26
    3d84:	7b 07       	cpc	r23, r27
    3d86:	48 f4       	brcc	.+18     	; 0x3d9a <f_write+0x298>
					cc = fp->fs->csize - csect;
    3d88:	82 2f       	mov	r24, r18
    3d8a:	90 e0       	ldi	r25, 0x00	; 0
    3d8c:	81 1b       	sub	r24, r17
    3d8e:	91 09       	sbc	r25, r1
    3d90:	6c 01       	movw	r12, r24
    3d92:	ee 24       	eor	r14, r14
    3d94:	d7 fc       	sbrc	r13, 7
    3d96:	e0 94       	com	r14
    3d98:	fe 2c       	mov	r15, r14
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
    3d9a:	d1 01       	movw	r26, r2
    3d9c:	11 96       	adiw	r26, 0x01	; 1
    3d9e:	8c 91       	ld	r24, X
    3da0:	6b 81       	ldd	r22, Y+3	; 0x03
    3da2:	7c 81       	ldd	r23, Y+4	; 0x04
    3da4:	a3 01       	movw	r20, r6
    3da6:	92 01       	movw	r18, r4
    3da8:	0c 2d       	mov	r16, r12
    3daa:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    3dae:	88 23       	and	r24, r24
    3db0:	41 f0       	breq	.+16     	; 0x3dc2 <f_write+0x2c0>
    3db2:	48 84       	ldd	r4, Y+8	; 0x08
    3db4:	59 84       	ldd	r5, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3db6:	f2 01       	movw	r30, r4
    3db8:	84 81       	ldd	r24, Z+4	; 0x04
    3dba:	80 68       	ori	r24, 0x80	; 128
    3dbc:	84 83       	std	Z+4, r24	; 0x04
    3dbe:	11 e0       	ldi	r17, 0x01	; 1
    3dc0:	e4 c0       	rjmp	.+456    	; 0x3f8a <f_write+0x488>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
    3dc2:	e8 85       	ldd	r30, Y+8	; 0x08
    3dc4:	f9 85       	ldd	r31, Y+9	; 0x09
    3dc6:	86 89       	ldd	r24, Z+22	; 0x16
    3dc8:	97 89       	ldd	r25, Z+23	; 0x17
    3dca:	a0 8d       	ldd	r26, Z+24	; 0x18
    3dcc:	b1 8d       	ldd	r27, Z+25	; 0x19
    3dce:	84 19       	sub	r24, r4
    3dd0:	95 09       	sbc	r25, r5
    3dd2:	a6 09       	sbc	r26, r6
    3dd4:	b7 09       	sbc	r27, r7
    3dd6:	8c 15       	cp	r24, r12
    3dd8:	9d 05       	cpc	r25, r13
    3dda:	ae 05       	cpc	r26, r14
    3ddc:	bf 05       	cpc	r27, r15
    3dde:	c8 f4       	brcc	.+50     	; 0x3e12 <f_write+0x310>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
    3de0:	bc 01       	movw	r22, r24
    3de2:	76 2f       	mov	r23, r22
    3de4:	66 27       	eor	r22, r22
    3de6:	77 0f       	add	r23, r23
    3de8:	0b 81       	ldd	r16, Y+3	; 0x03
    3dea:	1c 81       	ldd	r17, Y+4	; 0x04
    3dec:	60 0f       	add	r22, r16
    3dee:	71 1f       	adc	r23, r17
    3df0:	8d 81       	ldd	r24, Y+5	; 0x05
    3df2:	9e 81       	ldd	r25, Y+6	; 0x06
    3df4:	20 e0       	ldi	r18, 0x00	; 0
    3df6:	32 e0       	ldi	r19, 0x02	; 2
    3df8:	40 e0       	ldi	r20, 0x00	; 0
    3dfa:	50 e0       	ldi	r21, 0x00	; 0
    3dfc:	0e 94 09 0a 	call	0x1412	; 0x1412 <mem_cpy>
					fp->flag &= ~FA__DIRTY;
    3e00:	a8 85       	ldd	r26, Y+8	; 0x08
    3e02:	b9 85       	ldd	r27, Y+9	; 0x09
    3e04:	14 96       	adiw	r26, 0x04	; 4
    3e06:	8c 91       	ld	r24, X
    3e08:	14 97       	sbiw	r26, 0x04	; 4
    3e0a:	8f 7b       	andi	r24, 0xBF	; 191
    3e0c:	14 96       	adiw	r26, 0x04	; 4
    3e0e:	8c 93       	st	X, r24
    3e10:	14 97       	sbiw	r26, 0x04	; 4
				}
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    3e12:	0b 2e       	mov	r0, r27
    3e14:	b9 e0       	ldi	r27, 0x09	; 9
    3e16:	cc 0c       	add	r12, r12
    3e18:	dd 1c       	adc	r13, r13
    3e1a:	ee 1c       	adc	r14, r14
    3e1c:	ff 1c       	adc	r15, r15
    3e1e:	ba 95       	dec	r27
    3e20:	d1 f7       	brne	.-12     	; 0x3e16 <f_write+0x314>
    3e22:	b0 2d       	mov	r27, r0
				continue;
    3e24:	65 c0       	rjmp	.+202    	; 0x3ef0 <f_write+0x3ee>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
    3e26:	e8 85       	ldd	r30, Y+8	; 0x08
    3e28:	f9 85       	ldd	r31, Y+9	; 0x09
    3e2a:	86 89       	ldd	r24, Z+22	; 0x16
    3e2c:	97 89       	ldd	r25, Z+23	; 0x17
    3e2e:	a0 8d       	ldd	r26, Z+24	; 0x18
    3e30:	b1 8d       	ldd	r27, Z+25	; 0x19
    3e32:	84 15       	cp	r24, r4
    3e34:	95 05       	cpc	r25, r5
    3e36:	a6 05       	cpc	r26, r6
    3e38:	b7 05       	cpc	r27, r7
    3e3a:	09 f1       	breq	.+66     	; 0x3e7e <f_write+0x37c>
				if (fp->fptr < fp->fsize &&
    3e3c:	86 81       	ldd	r24, Z+6	; 0x06
    3e3e:	97 81       	ldd	r25, Z+7	; 0x07
    3e40:	a0 85       	ldd	r26, Z+8	; 0x08
    3e42:	b1 85       	ldd	r27, Z+9	; 0x09
    3e44:	42 85       	ldd	r20, Z+10	; 0x0a
    3e46:	53 85       	ldd	r21, Z+11	; 0x0b
    3e48:	64 85       	ldd	r22, Z+12	; 0x0c
    3e4a:	75 85       	ldd	r23, Z+13	; 0x0d
    3e4c:	84 17       	cp	r24, r20
    3e4e:	95 07       	cpc	r25, r21
    3e50:	a6 07       	cpc	r26, r22
    3e52:	b7 07       	cpc	r27, r23
    3e54:	a0 f4       	brcc	.+40     	; 0x3e7e <f_write+0x37c>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    3e56:	d1 01       	movw	r26, r2
    3e58:	11 96       	adiw	r26, 0x01	; 1
    3e5a:	8c 91       	ld	r24, X
    3e5c:	6d 81       	ldd	r22, Y+5	; 0x05
    3e5e:	7e 81       	ldd	r23, Y+6	; 0x06
    3e60:	a3 01       	movw	r20, r6
    3e62:	92 01       	movw	r18, r4
    3e64:	01 e0       	ldi	r16, 0x01	; 1
    3e66:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
    3e6a:	88 23       	and	r24, r24
    3e6c:	41 f0       	breq	.+16     	; 0x3e7e <f_write+0x37c>
    3e6e:	48 84       	ldd	r4, Y+8	; 0x08
    3e70:	59 84       	ldd	r5, Y+9	; 0x09
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
    3e72:	f2 01       	movw	r30, r4
    3e74:	84 81       	ldd	r24, Z+4	; 0x04
    3e76:	80 68       	ori	r24, 0x80	; 128
    3e78:	84 83       	std	Z+4, r24	; 0x04
    3e7a:	11 e0       	ldi	r17, 0x01	; 1
    3e7c:	86 c0       	rjmp	.+268    	; 0x3f8a <f_write+0x488>
			}
#endif
			fp->dsect = sect;
    3e7e:	a8 85       	ldd	r26, Y+8	; 0x08
    3e80:	b9 85       	ldd	r27, Y+9	; 0x09
    3e82:	56 96       	adiw	r26, 0x16	; 22
    3e84:	4d 92       	st	X+, r4
    3e86:	5d 92       	st	X+, r5
    3e88:	6d 92       	st	X+, r6
    3e8a:	7c 92       	st	X, r7
    3e8c:	59 97       	sbiw	r26, 0x19	; 25
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    3e8e:	e8 85       	ldd	r30, Y+8	; 0x08
    3e90:	f9 85       	ldd	r31, Y+9	; 0x09
    3e92:	46 81       	ldd	r20, Z+6	; 0x06
    3e94:	57 81       	ldd	r21, Z+7	; 0x07
    3e96:	60 85       	ldd	r22, Z+8	; 0x08
    3e98:	71 85       	ldd	r23, Z+9	; 0x09
    3e9a:	db 01       	movw	r26, r22
    3e9c:	ca 01       	movw	r24, r20
    3e9e:	91 70       	andi	r25, 0x01	; 1
    3ea0:	a0 70       	andi	r26, 0x00	; 0
    3ea2:	b0 70       	andi	r27, 0x00	; 0
    3ea4:	00 e0       	ldi	r16, 0x00	; 0
    3ea6:	12 e0       	ldi	r17, 0x02	; 2
    3ea8:	20 e0       	ldi	r18, 0x00	; 0
    3eaa:	30 e0       	ldi	r19, 0x00	; 0
    3eac:	08 1b       	sub	r16, r24
    3eae:	19 0b       	sbc	r17, r25
    3eb0:	2a 0b       	sbc	r18, r26
    3eb2:	3b 0b       	sbc	r19, r27
    3eb4:	75 01       	movw	r14, r10
    3eb6:	64 01       	movw	r12, r8
    3eb8:	08 15       	cp	r16, r8
    3eba:	19 05       	cpc	r17, r9
    3ebc:	2a 05       	cpc	r18, r10
    3ebe:	3b 05       	cpc	r19, r11
    3ec0:	10 f4       	brcc	.+4      	; 0x3ec6 <f_write+0x3c4>
    3ec2:	68 01       	movw	r12, r16
    3ec4:	79 01       	movw	r14, r18
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    3ec6:	ca 01       	movw	r24, r20
    3ec8:	91 70       	andi	r25, 0x01	; 1
    3eca:	80 96       	adiw	r24, 0x20	; 32
    3ecc:	28 85       	ldd	r18, Y+8	; 0x08
    3ece:	39 85       	ldd	r19, Y+9	; 0x09
    3ed0:	82 0f       	add	r24, r18
    3ed2:	93 1f       	adc	r25, r19
    3ed4:	6b 81       	ldd	r22, Y+3	; 0x03
    3ed6:	7c 81       	ldd	r23, Y+4	; 0x04
    3ed8:	a7 01       	movw	r20, r14
    3eda:	96 01       	movw	r18, r12
    3edc:	0e 94 09 0a 	call	0x1412	; 0x1412 <mem_cpy>
		fp->flag |= FA__DIRTY;
    3ee0:	a8 85       	ldd	r26, Y+8	; 0x08
    3ee2:	b9 85       	ldd	r27, Y+9	; 0x09
    3ee4:	14 96       	adiw	r26, 0x04	; 4
    3ee6:	8c 91       	ld	r24, X
    3ee8:	14 97       	sbiw	r26, 0x04	; 4
    3eea:	80 64       	ori	r24, 0x40	; 64
    3eec:	14 96       	adiw	r26, 0x04	; 4
    3eee:	8c 93       	st	X, r24
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    3ef0:	eb 81       	ldd	r30, Y+3	; 0x03
    3ef2:	fc 81       	ldd	r31, Y+4	; 0x04
    3ef4:	ec 0d       	add	r30, r12
    3ef6:	fd 1d       	adc	r31, r13
    3ef8:	fc 83       	std	Y+4, r31	; 0x04
    3efa:	eb 83       	std	Y+3, r30	; 0x03
    3efc:	e8 85       	ldd	r30, Y+8	; 0x08
    3efe:	f9 85       	ldd	r31, Y+9	; 0x09
    3f00:	86 81       	ldd	r24, Z+6	; 0x06
    3f02:	97 81       	ldd	r25, Z+7	; 0x07
    3f04:	a0 85       	ldd	r26, Z+8	; 0x08
    3f06:	b1 85       	ldd	r27, Z+9	; 0x09
    3f08:	8c 0d       	add	r24, r12
    3f0a:	9d 1d       	adc	r25, r13
    3f0c:	ae 1d       	adc	r26, r14
    3f0e:	bf 1d       	adc	r27, r15
    3f10:	86 83       	std	Z+6, r24	; 0x06
    3f12:	97 83       	std	Z+7, r25	; 0x07
    3f14:	a0 87       	std	Z+8, r26	; 0x08
    3f16:	b1 87       	std	Z+9, r27	; 0x09
    3f18:	e9 81       	ldd	r30, Y+1	; 0x01
    3f1a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f1c:	80 81       	ld	r24, Z
    3f1e:	91 81       	ldd	r25, Z+1	; 0x01
    3f20:	a2 81       	ldd	r26, Z+2	; 0x02
    3f22:	b3 81       	ldd	r27, Z+3	; 0x03
    3f24:	8c 0d       	add	r24, r12
    3f26:	9d 1d       	adc	r25, r13
    3f28:	ae 1d       	adc	r26, r14
    3f2a:	bf 1d       	adc	r27, r15
    3f2c:	80 83       	st	Z, r24
    3f2e:	91 83       	std	Z+1, r25	; 0x01
    3f30:	a2 83       	std	Z+2, r26	; 0x02
    3f32:	b3 83       	std	Z+3, r27	; 0x03
    3f34:	8c 18       	sub	r8, r12
    3f36:	9d 08       	sbc	r9, r13
    3f38:	ae 08       	sbc	r10, r14
    3f3a:	bf 08       	sbc	r11, r15
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
    3f3c:	09 f0       	breq	.+2      	; 0x3f40 <f_write+0x43e>
    3f3e:	35 ce       	rjmp	.-918    	; 0x3baa <f_write+0xa8>
    3f40:	1f 81       	ldd	r17, Y+7	; 0x07
    3f42:	48 84       	ldd	r4, Y+8	; 0x08
    3f44:	59 84       	ldd	r5, Y+9	; 0x09
    3f46:	03 c0       	rjmp	.+6      	; 0x3f4e <f_write+0x44c>
    3f48:	1f 81       	ldd	r17, Y+7	; 0x07
    3f4a:	48 84       	ldd	r4, Y+8	; 0x08
    3f4c:	59 84       	ldd	r5, Y+9	; 0x09
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    3f4e:	f2 01       	movw	r30, r4
    3f50:	86 81       	ldd	r24, Z+6	; 0x06
    3f52:	97 81       	ldd	r25, Z+7	; 0x07
    3f54:	a0 85       	ldd	r26, Z+8	; 0x08
    3f56:	b1 85       	ldd	r27, Z+9	; 0x09
    3f58:	42 85       	ldd	r20, Z+10	; 0x0a
    3f5a:	53 85       	ldd	r21, Z+11	; 0x0b
    3f5c:	64 85       	ldd	r22, Z+12	; 0x0c
    3f5e:	75 85       	ldd	r23, Z+13	; 0x0d
    3f60:	48 17       	cp	r20, r24
    3f62:	59 07       	cpc	r21, r25
    3f64:	6a 07       	cpc	r22, r26
    3f66:	7b 07       	cpc	r23, r27
    3f68:	20 f4       	brcc	.+8      	; 0x3f72 <f_write+0x470>
    3f6a:	82 87       	std	Z+10, r24	; 0x0a
    3f6c:	93 87       	std	Z+11, r25	; 0x0b
    3f6e:	a4 87       	std	Z+12, r26	; 0x0c
    3f70:	b5 87       	std	Z+13, r27	; 0x0d
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    3f72:	d2 01       	movw	r26, r4
    3f74:	14 96       	adiw	r26, 0x04	; 4
    3f76:	8c 91       	ld	r24, X
    3f78:	14 97       	sbiw	r26, 0x04	; 4
    3f7a:	80 62       	ori	r24, 0x20	; 32
    3f7c:	14 96       	adiw	r26, 0x04	; 4
    3f7e:	8c 93       	st	X, r24
    3f80:	14 97       	sbiw	r26, 0x04	; 4

	LEAVE_FF(fp->fs, FR_OK);
    3f82:	03 c0       	rjmp	.+6      	; 0x3f8a <f_write+0x488>
	*bw = 0;	/* Clear write byte counter */

	res = validate(fp);						/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)				/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    3f84:	12 e0       	ldi	r17, 0x02	; 2
    3f86:	01 c0       	rjmp	.+2      	; 0x3f8a <f_write+0x488>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    3f88:	17 e0       	ldi	r17, 0x07	; 7

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
    3f8a:	81 2f       	mov	r24, r17
    3f8c:	29 96       	adiw	r28, 0x09	; 9
    3f8e:	0f b6       	in	r0, 0x3f	; 63
    3f90:	f8 94       	cli
    3f92:	de bf       	out	0x3e, r29	; 62
    3f94:	0f be       	out	0x3f, r0	; 63
    3f96:	cd bf       	out	0x3d, r28	; 61
    3f98:	df 91       	pop	r29
    3f9a:	cf 91       	pop	r28
    3f9c:	1f 91       	pop	r17
    3f9e:	0f 91       	pop	r16
    3fa0:	ff 90       	pop	r15
    3fa2:	ef 90       	pop	r14
    3fa4:	df 90       	pop	r13
    3fa6:	cf 90       	pop	r12
    3fa8:	bf 90       	pop	r11
    3faa:	af 90       	pop	r10
    3fac:	9f 90       	pop	r9
    3fae:	8f 90       	pop	r8
    3fb0:	7f 90       	pop	r7
    3fb2:	6f 90       	pop	r6
    3fb4:	5f 90       	pop	r5
    3fb6:	4f 90       	pop	r4
    3fb8:	3f 90       	pop	r3
    3fba:	2f 90       	pop	r2
    3fbc:	08 95       	ret

00003fbe <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
    3fbe:	0f 93       	push	r16
    3fc0:	1f 93       	push	r17
    3fc2:	cf 93       	push	r28
    3fc4:	df 93       	push	r29
    3fc6:	ec 01       	movw	r28, r24
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
    3fc8:	0e 94 ef 0a 	call	0x15de	; 0x15de <validate>
	if (res == FR_OK) {
    3fcc:	88 23       	and	r24, r24
    3fce:	09 f0       	breq	.+2      	; 0x3fd2 <f_sync+0x14>
    3fd0:	4c c0       	rjmp	.+152    	; 0x406a <f_sync+0xac>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    3fd2:	9c 81       	ldd	r25, Y+4	; 0x04
    3fd4:	95 ff       	sbrs	r25, 5
    3fd6:	49 c0       	rjmp	.+146    	; 0x406a <f_sync+0xac>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
    3fd8:	96 ff       	sbrs	r25, 6
    3fda:	12 c0       	rjmp	.+36     	; 0x4000 <f_sync+0x42>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3fdc:	e8 81       	ld	r30, Y
    3fde:	f9 81       	ldd	r31, Y+1	; 0x01
    3fe0:	be 01       	movw	r22, r28
    3fe2:	60 5e       	subi	r22, 0xE0	; 224
    3fe4:	7f 4f       	sbci	r23, 0xFF	; 255
    3fe6:	2e 89       	ldd	r18, Y+22	; 0x16
    3fe8:	3f 89       	ldd	r19, Y+23	; 0x17
    3fea:	48 8d       	ldd	r20, Y+24	; 0x18
    3fec:	59 8d       	ldd	r21, Y+25	; 0x19
    3fee:	81 81       	ldd	r24, Z+1	; 0x01
    3ff0:	01 e0       	ldi	r16, 0x01	; 1
    3ff2:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    3ff6:	88 23       	and	r24, r24
    3ff8:	b9 f5       	brne	.+110    	; 0x4068 <f_sync+0xaa>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
    3ffa:	8c 81       	ldd	r24, Y+4	; 0x04
    3ffc:	8f 7b       	andi	r24, 0xBF	; 191
    3ffe:	8c 83       	std	Y+4, r24	; 0x04
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
    4000:	4a 8d       	ldd	r20, Y+26	; 0x1a
    4002:	5b 8d       	ldd	r21, Y+27	; 0x1b
    4004:	6c 8d       	ldd	r22, Y+28	; 0x1c
    4006:	7d 8d       	ldd	r23, Y+29	; 0x1d
    4008:	88 81       	ld	r24, Y
    400a:	99 81       	ldd	r25, Y+1	; 0x01
    400c:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
			if (res == FR_OK) {
    4010:	88 23       	and	r24, r24
    4012:	59 f5       	brne	.+86     	; 0x406a <f_sync+0xac>
				dir = fp->dir_ptr;
    4014:	0e 8d       	ldd	r16, Y+30	; 0x1e
    4016:	1f 8d       	ldd	r17, Y+31	; 0x1f
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    4018:	f8 01       	movw	r30, r16
    401a:	83 85       	ldd	r24, Z+11	; 0x0b
    401c:	80 62       	ori	r24, 0x20	; 32
    401e:	83 87       	std	Z+11, r24	; 0x0b
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    4020:	8a 85       	ldd	r24, Y+10	; 0x0a
    4022:	84 8f       	std	Z+28, r24	; 0x1c
    4024:	8b 85       	ldd	r24, Y+11	; 0x0b
    4026:	85 8f       	std	Z+29, r24	; 0x1d
    4028:	8c 85       	ldd	r24, Y+12	; 0x0c
    402a:	86 8f       	std	Z+30, r24	; 0x1e
    402c:	8d 85       	ldd	r24, Y+13	; 0x0d
    402e:	87 8f       	std	Z+31, r24	; 0x1f
				st_clust(dir, fp->sclust);					/* Update start cluster */
    4030:	4e 85       	ldd	r20, Y+14	; 0x0e
    4032:	5f 85       	ldd	r21, Y+15	; 0x0f
    4034:	68 89       	ldd	r22, Y+16	; 0x10
    4036:	79 89       	ldd	r23, Y+17	; 0x11
    4038:	c8 01       	movw	r24, r16
    403a:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <st_clust>
				tim = get_fattime();						/* Update updated time */
    403e:	0e 94 0f 11 	call	0x221e	; 0x221e <get_fattime>
				ST_DWORD(dir+DIR_WrtTime, tim);
    4042:	f8 01       	movw	r30, r16
    4044:	66 8b       	std	Z+22, r22	; 0x16
    4046:	77 8b       	std	Z+23, r23	; 0x17
    4048:	80 8f       	std	Z+24, r24	; 0x18
    404a:	91 8f       	std	Z+25, r25	; 0x19
				ST_WORD(dir+DIR_LstAccDate, 0);
    404c:	12 8a       	std	Z+18, r1	; 0x12
    404e:	13 8a       	std	Z+19, r1	; 0x13
				fp->flag &= ~FA__WRITTEN;
    4050:	8c 81       	ldd	r24, Y+4	; 0x04
    4052:	8f 7d       	andi	r24, 0xDF	; 223
    4054:	8c 83       	std	Y+4, r24	; 0x04
				fp->fs->wflag = 1;
    4056:	e8 81       	ld	r30, Y
    4058:	f9 81       	ldd	r31, Y+1	; 0x01
    405a:	81 e0       	ldi	r24, 0x01	; 1
    405c:	84 83       	std	Z+4, r24	; 0x04
				res = sync(fp->fs);
    405e:	88 81       	ld	r24, Y
    4060:	99 81       	ldd	r25, Y+1	; 0x01
    4062:	0e 94 81 10 	call	0x2102	; 0x2102 <sync>
    4066:	01 c0       	rjmp	.+2      	; 0x406a <f_sync+0xac>
	if (res == FR_OK) {
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
    4068:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
    406a:	df 91       	pop	r29
    406c:	cf 91       	pop	r28
    406e:	1f 91       	pop	r17
    4070:	0f 91       	pop	r16
    4072:	08 95       	ret

00004074 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    4074:	cf 93       	push	r28
    4076:	df 93       	push	r29
    4078:	ec 01       	movw	r28, r24
#endif
		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
		LEAVE_FF(fs, res);
	}
#else
	res = f_sync(fp);		/* Flush cached data */
    407a:	0e 94 df 1f 	call	0x3fbe	; 0x3fbe <f_sync>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    407e:	88 23       	and	r24, r24
    4080:	11 f4       	brne	.+4      	; 0x4086 <f_close+0x12>
    4082:	19 82       	std	Y+1, r1	; 0x01
    4084:	18 82       	st	Y, r1
	return res;
#endif
}
    4086:	df 91       	pop	r29
    4088:	cf 91       	pop	r28
    408a:	08 95       	ret

0000408c <f_chdrive>:

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
    408c:	88 23       	and	r24, r24
    408e:	19 f4       	brne	.+6      	; 0x4096 <f_chdrive+0xa>

	CurrVol = drv;
    4090:	10 92 f5 03 	sts	0x03F5, r1

	return FR_OK;
    4094:	08 95       	ret

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
    4096:	8b e0       	ldi	r24, 0x0B	; 11

	CurrVol = drv;

	return FR_OK;
}
    4098:	08 95       	ret

0000409a <f_chdir>:


FRESULT f_chdir (
	const TCHAR *path	/* Pointer to the directory path */
)
{
    409a:	ef 92       	push	r14
    409c:	ff 92       	push	r15
    409e:	1f 93       	push	r17
    40a0:	cf 93       	push	r28
    40a2:	df 93       	push	r29
    40a4:	cd b7       	in	r28, 0x3d	; 61
    40a6:	de b7       	in	r29, 0x3e	; 62
    40a8:	a4 97       	sbiw	r28, 0x24	; 36
    40aa:	0f b6       	in	r0, 0x3f	; 63
    40ac:	f8 94       	cli
    40ae:	de bf       	out	0x3e, r29	; 62
    40b0:	0f be       	out	0x3f, r0	; 63
    40b2:	cd bf       	out	0x3d, r28	; 61
    40b4:	9c a3       	lds	r25, 0x5c
    40b6:	8b a3       	lds	r24, 0x5b
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
    40b8:	ce 01       	movw	r24, r28
    40ba:	83 96       	adiw	r24, 0x23	; 35
    40bc:	be 01       	movw	r22, r28
    40be:	6f 5f       	subi	r22, 0xFF	; 255
    40c0:	7f 4f       	sbci	r23, 0xFF	; 255
    40c2:	40 e0       	ldi	r20, 0x00	; 0
    40c4:	0e 94 ac 0b 	call	0x1758	; 0x1758 <chk_mounted>
    40c8:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    40ca:	88 23       	and	r24, r24
    40cc:	81 f5       	brne	.+96     	; 0x412e <f_chdir+0x94>
		INIT_BUF(dj);
    40ce:	ce 01       	movw	r24, r28
    40d0:	47 96       	adiw	r24, 0x17	; 23
    40d2:	9e 8b       	std	Y+22, r25	; 0x16
    40d4:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the path */
    40d6:	6b a1       	lds	r22, 0x4b
    40d8:	7c a1       	lds	r23, 0x4c
    40da:	ce 01       	movw	r24, r28
    40dc:	01 96       	adiw	r24, 0x01	; 1
    40de:	0e 94 db 16 	call	0x2db6	; 0x2db6 <follow_path>
    40e2:	18 2f       	mov	r17, r24
		FREE_BUF();
		if (res == FR_OK) {					/* Follow completed */
    40e4:	88 23       	and	r24, r24
    40e6:	01 f5       	brne	.+64     	; 0x4128 <f_chdir+0x8e>
			if (!dj.dir) {
    40e8:	eb 89       	ldd	r30, Y+19	; 0x13
    40ea:	fc 89       	ldd	r31, Y+20	; 0x14
    40ec:	30 97       	sbiw	r30, 0x00	; 0
    40ee:	59 f4       	brne	.+22     	; 0x4106 <f_chdir+0x6c>
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
    40f0:	e9 81       	ldd	r30, Y+1	; 0x01
    40f2:	fa 81       	ldd	r31, Y+2	; 0x02
    40f4:	8f 81       	ldd	r24, Y+7	; 0x07
    40f6:	98 85       	ldd	r25, Y+8	; 0x08
    40f8:	a9 85       	ldd	r26, Y+9	; 0x09
    40fa:	ba 85       	ldd	r27, Y+10	; 0x0a
    40fc:	86 8b       	std	Z+22, r24	; 0x16
    40fe:	97 8b       	std	Z+23, r25	; 0x17
    4100:	a0 8f       	std	Z+24, r26	; 0x18
    4102:	b1 8f       	std	Z+25, r27	; 0x19
    4104:	14 c0       	rjmp	.+40     	; 0x412e <f_chdir+0x94>
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
    4106:	83 85       	ldd	r24, Z+11	; 0x0b
    4108:	84 ff       	sbrs	r24, 4
    410a:	1e c0       	rjmp	.+60     	; 0x4148 <f_chdir+0xae>
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
    410c:	e9 80       	ldd	r14, Y+1	; 0x01
    410e:	fa 80       	ldd	r15, Y+2	; 0x02
    4110:	c7 01       	movw	r24, r14
    4112:	bf 01       	movw	r22, r30
    4114:	0e 94 2f 0a 	call	0x145e	; 0x145e <ld_clust>
    4118:	dc 01       	movw	r26, r24
    411a:	cb 01       	movw	r24, r22
    411c:	f7 01       	movw	r30, r14
    411e:	86 8b       	std	Z+22, r24	; 0x16
    4120:	97 8b       	std	Z+23, r25	; 0x17
    4122:	a0 8f       	std	Z+24, r26	; 0x18
    4124:	b1 8f       	std	Z+25, r27	; 0x19
    4126:	03 c0       	rjmp	.+6      	; 0x412e <f_chdir+0x94>
				else
					res = FR_NO_PATH;		/* Reached but a file */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    4128:	84 30       	cpi	r24, 0x04	; 4
    412a:	09 f4       	brne	.+2      	; 0x412e <f_chdir+0x94>
    412c:	15 e0       	ldi	r17, 0x05	; 5
	}

	LEAVE_FF(dj.fs, res);
}
    412e:	81 2f       	mov	r24, r17
    4130:	a4 96       	adiw	r28, 0x24	; 36
    4132:	0f b6       	in	r0, 0x3f	; 63
    4134:	f8 94       	cli
    4136:	de bf       	out	0x3e, r29	; 62
    4138:	0f be       	out	0x3f, r0	; 63
    413a:	cd bf       	out	0x3d, r28	; 61
    413c:	df 91       	pop	r29
    413e:	cf 91       	pop	r28
    4140:	1f 91       	pop	r17
    4142:	ff 90       	pop	r15
    4144:	ef 90       	pop	r14
    4146:	08 95       	ret
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
				else
					res = FR_NO_PATH;		/* Reached but a file */
    4148:	15 e0       	ldi	r17, 0x05	; 5
    414a:	f1 cf       	rjmp	.-30     	; 0x412e <f_chdir+0x94>

0000414c <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
    414c:	2f 92       	push	r2
    414e:	3f 92       	push	r3
    4150:	4f 92       	push	r4
    4152:	5f 92       	push	r5
    4154:	6f 92       	push	r6
    4156:	7f 92       	push	r7
    4158:	8f 92       	push	r8
    415a:	9f 92       	push	r9
    415c:	af 92       	push	r10
    415e:	bf 92       	push	r11
    4160:	cf 92       	push	r12
    4162:	df 92       	push	r13
    4164:	ef 92       	push	r14
    4166:	ff 92       	push	r15
    4168:	0f 93       	push	r16
    416a:	1f 93       	push	r17
    416c:	cf 93       	push	r28
    416e:	df 93       	push	r29
    4170:	00 d0       	rcall	.+0      	; 0x4172 <f_lseek+0x26>
    4172:	00 d0       	rcall	.+0      	; 0x4174 <f_lseek+0x28>
    4174:	00 d0       	rcall	.+0      	; 0x4176 <f_lseek+0x2a>
    4176:	cd b7       	in	r28, 0x3d	; 61
    4178:	de b7       	in	r29, 0x3e	; 62
    417a:	9e 83       	std	Y+6, r25	; 0x06
    417c:	8d 83       	std	Y+5, r24	; 0x05
    417e:	6a 01       	movw	r12, r20
    4180:	7b 01       	movw	r14, r22
	FRESULT res;


	res = validate(fp);					/* Check validity of the object */
    4182:	0e 94 ef 0a 	call	0x15de	; 0x15de <validate>
    4186:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    4188:	88 23       	and	r24, r24
    418a:	09 f0       	breq	.+2      	; 0x418e <f_lseek+0x42>
    418c:	e6 c1       	rjmp	.+972    	; 0x455a <f_lseek+0x40e>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
    418e:	ad 81       	ldd	r26, Y+5	; 0x05
    4190:	be 81       	ldd	r27, Y+6	; 0x06
    4192:	14 96       	adiw	r26, 0x04	; 4
    4194:	2c 91       	ld	r18, X
    4196:	14 97       	sbiw	r26, 0x04	; 4
    4198:	22 23       	and	r18, r18
    419a:	0c f4       	brge	.+2      	; 0x419e <f_lseek+0x52>
    419c:	dd c1       	rjmp	.+954    	; 0x4558 <f_lseek+0x40c>

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    419e:	1a 96       	adiw	r26, 0x0a	; 10
    41a0:	8d 91       	ld	r24, X+
    41a2:	9d 91       	ld	r25, X+
    41a4:	0d 90       	ld	r0, X+
    41a6:	bc 91       	ld	r27, X
    41a8:	a0 2d       	mov	r26, r0
    41aa:	8c 15       	cp	r24, r12
    41ac:	9d 05       	cpc	r25, r13
    41ae:	ae 05       	cpc	r26, r14
    41b0:	bf 05       	cpc	r27, r15
    41b2:	20 f4       	brcc	.+8      	; 0x41bc <f_lseek+0x70>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
    41b4:	21 fd       	sbrc	r18, 1
    41b6:	02 c0       	rjmp	.+4      	; 0x41bc <f_lseek+0x70>
#endif
			) ofs = fp->fsize;
    41b8:	6c 01       	movw	r12, r24
    41ba:	7d 01       	movw	r14, r26

		ifptr = fp->fptr;
    41bc:	ed 81       	ldd	r30, Y+5	; 0x05
    41be:	fe 81       	ldd	r31, Y+6	; 0x06
    41c0:	46 81       	ldd	r20, Z+6	; 0x06
    41c2:	57 81       	ldd	r21, Z+7	; 0x07
    41c4:	60 85       	ldd	r22, Z+8	; 0x08
    41c6:	71 85       	ldd	r23, Z+9	; 0x09
		fp->fptr = nsect = 0;
    41c8:	16 82       	std	Z+6, r1	; 0x06
    41ca:	17 82       	std	Z+7, r1	; 0x07
    41cc:	10 86       	std	Z+8, r1	; 0x08
    41ce:	11 86       	std	Z+9, r1	; 0x09
		if (ofs) {
    41d0:	c1 14       	cp	r12, r1
    41d2:	d1 04       	cpc	r13, r1
    41d4:	e1 04       	cpc	r14, r1
    41d6:	f1 04       	cpc	r15, r1
    41d8:	09 f4       	brne	.+2      	; 0x41dc <f_lseek+0x90>
    41da:	bf c1       	rjmp	.+894    	; 0x455a <f_lseek+0x40e>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    41dc:	20 80       	ld	r2, Z
    41de:	31 80       	ldd	r3, Z+1	; 0x01
    41e0:	f1 01       	movw	r30, r2
    41e2:	82 81       	ldd	r24, Z+2	; 0x02
    41e4:	90 e0       	ldi	r25, 0x00	; 0
    41e6:	a0 e0       	ldi	r26, 0x00	; 0
    41e8:	b0 e0       	ldi	r27, 0x00	; 0
    41ea:	4c 01       	movw	r8, r24
    41ec:	5d 01       	movw	r10, r26
    41ee:	07 2e       	mov	r0, r23
    41f0:	79 e0       	ldi	r23, 0x09	; 9
    41f2:	88 0c       	add	r8, r8
    41f4:	99 1c       	adc	r9, r9
    41f6:	aa 1c       	adc	r10, r10
    41f8:	bb 1c       	adc	r11, r11
    41fa:	7a 95       	dec	r23
    41fc:	d1 f7       	brne	.-12     	; 0x41f2 <f_lseek+0xa6>
    41fe:	70 2d       	mov	r23, r0
			if (ifptr > 0 &&
    4200:	41 15       	cp	r20, r1
    4202:	51 05       	cpc	r21, r1
    4204:	61 05       	cpc	r22, r1
    4206:	71 05       	cpc	r23, r1
    4208:	f1 f1       	breq	.+124    	; 0x4286 <f_lseek+0x13a>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
    420a:	2a 01       	movw	r4, r20
    420c:	3b 01       	movw	r6, r22
    420e:	08 94       	sec
    4210:	41 08       	sbc	r4, r1
    4212:	51 08       	sbc	r5, r1
    4214:	61 08       	sbc	r6, r1
    4216:	71 08       	sbc	r7, r1
    4218:	c7 01       	movw	r24, r14
    421a:	b6 01       	movw	r22, r12
    421c:	61 50       	subi	r22, 0x01	; 1
    421e:	70 40       	sbci	r23, 0x00	; 0
    4220:	80 40       	sbci	r24, 0x00	; 0
    4222:	90 40       	sbci	r25, 0x00	; 0
    4224:	a5 01       	movw	r20, r10
    4226:	94 01       	movw	r18, r8
    4228:	0e 94 77 2b 	call	0x56ee	; 0x56ee <__udivmodsi4>
    422c:	29 83       	std	Y+1, r18	; 0x01
    422e:	3a 83       	std	Y+2, r19	; 0x02
    4230:	4b 83       	std	Y+3, r20	; 0x03
    4232:	5c 83       	std	Y+4, r21	; 0x04
    4234:	c3 01       	movw	r24, r6
    4236:	b2 01       	movw	r22, r4
    4238:	a5 01       	movw	r20, r10
    423a:	94 01       	movw	r18, r8
    423c:	0e 94 77 2b 	call	0x56ee	; 0x56ee <__udivmodsi4>

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
    4240:	89 81       	ldd	r24, Y+1	; 0x01
    4242:	9a 81       	ldd	r25, Y+2	; 0x02
    4244:	ab 81       	ldd	r26, Y+3	; 0x03
    4246:	bc 81       	ldd	r27, Y+4	; 0x04
    4248:	82 17       	cp	r24, r18
    424a:	93 07       	cpc	r25, r19
    424c:	a4 07       	cpc	r26, r20
    424e:	b5 07       	cpc	r27, r21
    4250:	d0 f0       	brcs	.+52     	; 0x4286 <f_lseek+0x13a>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    4252:	88 27       	eor	r24, r24
    4254:	99 27       	eor	r25, r25
    4256:	dc 01       	movw	r26, r24
    4258:	88 19       	sub	r24, r8
    425a:	99 09       	sbc	r25, r9
    425c:	aa 09       	sbc	r26, r10
    425e:	bb 09       	sbc	r27, r11
    4260:	84 21       	and	r24, r4
    4262:	95 21       	and	r25, r5
    4264:	a6 21       	and	r26, r6
    4266:	b7 21       	and	r27, r7
    4268:	ed 81       	ldd	r30, Y+5	; 0x05
    426a:	fe 81       	ldd	r31, Y+6	; 0x06
    426c:	86 83       	std	Z+6, r24	; 0x06
    426e:	97 83       	std	Z+7, r25	; 0x07
    4270:	a0 87       	std	Z+8, r26	; 0x08
    4272:	b1 87       	std	Z+9, r27	; 0x09
				ofs -= fp->fptr;
    4274:	c8 1a       	sub	r12, r24
    4276:	d9 0a       	sbc	r13, r25
    4278:	ea 0a       	sbc	r14, r26
    427a:	fb 0a       	sbc	r15, r27
				clst = fp->clust;
    427c:	42 89       	ldd	r20, Z+18	; 0x12
    427e:	53 89       	ldd	r21, Z+19	; 0x13
    4280:	64 89       	ldd	r22, Z+20	; 0x14
    4282:	75 89       	ldd	r23, Z+21	; 0x15
    4284:	42 c0       	rjmp	.+132    	; 0x430a <f_lseek+0x1be>
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
    4286:	ad 81       	ldd	r26, Y+5	; 0x05
    4288:	be 81       	ldd	r27, Y+6	; 0x06
    428a:	1e 96       	adiw	r26, 0x0e	; 14
    428c:	4d 91       	ld	r20, X+
    428e:	5d 91       	ld	r21, X+
    4290:	6d 91       	ld	r22, X+
    4292:	7c 91       	ld	r23, X
    4294:	51 97       	sbiw	r26, 0x11	; 17
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
    4296:	41 15       	cp	r20, r1
    4298:	51 05       	cpc	r21, r1
    429a:	61 05       	cpc	r22, r1
    429c:	71 05       	cpc	r23, r1
    429e:	69 f5       	brne	.+90     	; 0x42fa <f_lseek+0x1ae>
					clst = create_chain(fp->fs, 0);
    42a0:	c1 01       	movw	r24, r2
    42a2:	40 e0       	ldi	r20, 0x00	; 0
    42a4:	50 e0       	ldi	r21, 0x00	; 0
    42a6:	ba 01       	movw	r22, r20
    42a8:	0e 94 72 14 	call	0x28e4	; 0x28e4 <create_chain>
    42ac:	ab 01       	movw	r20, r22
    42ae:	bc 01       	movw	r22, r24
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    42b0:	41 30       	cpi	r20, 0x01	; 1
    42b2:	51 05       	cpc	r21, r1
    42b4:	61 05       	cpc	r22, r1
    42b6:	71 05       	cpc	r23, r1
    42b8:	39 f4       	brne	.+14     	; 0x42c8 <f_lseek+0x17c>
    42ba:	ed 81       	ldd	r30, Y+5	; 0x05
    42bc:	fe 81       	ldd	r31, Y+6	; 0x06
    42be:	84 81       	ldd	r24, Z+4	; 0x04
    42c0:	80 68       	ori	r24, 0x80	; 128
    42c2:	84 83       	std	Z+4, r24	; 0x04
    42c4:	12 e0       	ldi	r17, 0x02	; 2
    42c6:	49 c1       	rjmp	.+658    	; 0x455a <f_lseek+0x40e>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    42c8:	4f 3f       	cpi	r20, 0xFF	; 255
    42ca:	ff ef       	ldi	r31, 0xFF	; 255
    42cc:	5f 07       	cpc	r21, r31
    42ce:	ff ef       	ldi	r31, 0xFF	; 255
    42d0:	6f 07       	cpc	r22, r31
    42d2:	ff ef       	ldi	r31, 0xFF	; 255
    42d4:	7f 07       	cpc	r23, r31
    42d6:	59 f4       	brne	.+22     	; 0x42ee <f_lseek+0x1a2>
    42d8:	ad 81       	ldd	r26, Y+5	; 0x05
    42da:	be 81       	ldd	r27, Y+6	; 0x06
    42dc:	14 96       	adiw	r26, 0x04	; 4
    42de:	8c 91       	ld	r24, X
    42e0:	14 97       	sbiw	r26, 0x04	; 4
    42e2:	80 68       	ori	r24, 0x80	; 128
    42e4:	14 96       	adiw	r26, 0x04	; 4
    42e6:	8c 93       	st	X, r24
    42e8:	14 97       	sbiw	r26, 0x04	; 4
    42ea:	11 e0       	ldi	r17, 0x01	; 1
    42ec:	36 c1       	rjmp	.+620    	; 0x455a <f_lseek+0x40e>
					fp->sclust = clst;
    42ee:	ed 81       	ldd	r30, Y+5	; 0x05
    42f0:	fe 81       	ldd	r31, Y+6	; 0x06
    42f2:	46 87       	std	Z+14, r20	; 0x0e
    42f4:	57 87       	std	Z+15, r21	; 0x0f
    42f6:	60 8b       	std	Z+16, r22	; 0x10
    42f8:	71 8b       	std	Z+17, r23	; 0x11
				}
#endif
				fp->clust = clst;
    42fa:	ad 81       	ldd	r26, Y+5	; 0x05
    42fc:	be 81       	ldd	r27, Y+6	; 0x06
    42fe:	52 96       	adiw	r26, 0x12	; 18
    4300:	4d 93       	st	X+, r20
    4302:	5d 93       	st	X+, r21
    4304:	6d 93       	st	X+, r22
    4306:	7c 93       	st	X, r23
    4308:	55 97       	sbiw	r26, 0x15	; 21
			}
			if (clst != 0) {
    430a:	41 15       	cp	r20, r1
    430c:	51 05       	cpc	r21, r1
    430e:	61 05       	cpc	r22, r1
    4310:	71 05       	cpc	r23, r1
    4312:	09 f4       	brne	.+2      	; 0x4316 <f_lseek+0x1ca>
    4314:	aa c0       	rjmp	.+340    	; 0x446a <f_lseek+0x31e>
				while (ofs > bcs) {						/* Cluster following loop */
    4316:	8c 14       	cp	r8, r12
    4318:	9d 04       	cpc	r9, r13
    431a:	ae 04       	cpc	r10, r14
    431c:	bf 04       	cpc	r11, r15
    431e:	08 f0       	brcs	.+2      	; 0x4322 <f_lseek+0x1d6>
    4320:	68 c0       	rjmp	.+208    	; 0x43f2 <f_lseek+0x2a6>
    4322:	4d 80       	ldd	r4, Y+5	; 0x05
    4324:	5e 80       	ldd	r5, Y+6	; 0x06
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    4326:	f2 01       	movw	r30, r4
    4328:	84 81       	ldd	r24, Z+4	; 0x04
    432a:	81 ff       	sbrs	r24, 1
    432c:	0c c0       	rjmp	.+24     	; 0x4346 <f_lseek+0x1fa>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
    432e:	80 81       	ld	r24, Z
    4330:	91 81       	ldd	r25, Z+1	; 0x01
    4332:	0e 94 72 14 	call	0x28e4	; 0x28e4 <create_chain>
    4336:	ab 01       	movw	r20, r22
    4338:	bc 01       	movw	r22, r24
						if (clst == 0) {				/* When disk gets full, clip file size */
    433a:	41 15       	cp	r20, r1
    433c:	51 05       	cpc	r21, r1
    433e:	61 05       	cpc	r22, r1
    4340:	71 05       	cpc	r23, r1
    4342:	39 f4       	brne	.+14     	; 0x4352 <f_lseek+0x206>
    4344:	52 c0       	rjmp	.+164    	; 0x43ea <f_lseek+0x29e>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    4346:	80 81       	ld	r24, Z
    4348:	91 81       	ldd	r25, Z+1	; 0x01
    434a:	0e 94 49 11 	call	0x2292	; 0x2292 <get_fat>
    434e:	ab 01       	movw	r20, r22
    4350:	bc 01       	movw	r22, r24
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    4352:	4f 3f       	cpi	r20, 0xFF	; 255
    4354:	bf ef       	ldi	r27, 0xFF	; 255
    4356:	5b 07       	cpc	r21, r27
    4358:	bf ef       	ldi	r27, 0xFF	; 255
    435a:	6b 07       	cpc	r22, r27
    435c:	bf ef       	ldi	r27, 0xFF	; 255
    435e:	7b 07       	cpc	r23, r27
    4360:	41 f4       	brne	.+16     	; 0x4372 <f_lseek+0x226>
    4362:	5e 82       	std	Y+6, r5	; 0x06
    4364:	4d 82       	std	Y+5, r4	; 0x05
    4366:	f2 01       	movw	r30, r4
    4368:	84 81       	ldd	r24, Z+4	; 0x04
    436a:	80 68       	ori	r24, 0x80	; 128
    436c:	84 83       	std	Z+4, r24	; 0x04
    436e:	11 e0       	ldi	r17, 0x01	; 1
    4370:	f4 c0       	rjmp	.+488    	; 0x455a <f_lseek+0x40e>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    4372:	42 30       	cpi	r20, 0x02	; 2
    4374:	51 05       	cpc	r21, r1
    4376:	61 05       	cpc	r22, r1
    4378:	71 05       	cpc	r23, r1
    437a:	60 f0       	brcs	.+24     	; 0x4394 <f_lseek+0x248>
    437c:	d2 01       	movw	r26, r4
    437e:	ed 91       	ld	r30, X+
    4380:	fc 91       	ld	r31, X
    4382:	82 8d       	ldd	r24, Z+26	; 0x1a
    4384:	93 8d       	ldd	r25, Z+27	; 0x1b
    4386:	a4 8d       	ldd	r26, Z+28	; 0x1c
    4388:	b5 8d       	ldd	r27, Z+29	; 0x1d
    438a:	48 17       	cp	r20, r24
    438c:	59 07       	cpc	r21, r25
    438e:	6a 07       	cpc	r22, r26
    4390:	7b 07       	cpc	r23, r27
    4392:	40 f0       	brcs	.+16     	; 0x43a4 <f_lseek+0x258>
    4394:	5e 82       	std	Y+6, r5	; 0x06
    4396:	4d 82       	std	Y+5, r4	; 0x05
    4398:	f2 01       	movw	r30, r4
    439a:	84 81       	ldd	r24, Z+4	; 0x04
    439c:	80 68       	ori	r24, 0x80	; 128
    439e:	84 83       	std	Z+4, r24	; 0x04
    43a0:	12 e0       	ldi	r17, 0x02	; 2
    43a2:	db c0       	rjmp	.+438    	; 0x455a <f_lseek+0x40e>
					fp->clust = clst;
    43a4:	d2 01       	movw	r26, r4
    43a6:	52 96       	adiw	r26, 0x12	; 18
    43a8:	4d 93       	st	X+, r20
    43aa:	5d 93       	st	X+, r21
    43ac:	6d 93       	st	X+, r22
    43ae:	7c 93       	st	X, r23
    43b0:	55 97       	sbiw	r26, 0x15	; 21
					fp->fptr += bcs;
    43b2:	16 96       	adiw	r26, 0x06	; 6
    43b4:	8d 91       	ld	r24, X+
    43b6:	9d 91       	ld	r25, X+
    43b8:	0d 90       	ld	r0, X+
    43ba:	bc 91       	ld	r27, X
    43bc:	a0 2d       	mov	r26, r0
    43be:	88 0d       	add	r24, r8
    43c0:	99 1d       	adc	r25, r9
    43c2:	aa 1d       	adc	r26, r10
    43c4:	bb 1d       	adc	r27, r11
    43c6:	f2 01       	movw	r30, r4
    43c8:	86 83       	std	Z+6, r24	; 0x06
    43ca:	97 83       	std	Z+7, r25	; 0x07
    43cc:	a0 87       	std	Z+8, r26	; 0x08
    43ce:	b1 87       	std	Z+9, r27	; 0x09
					ofs -= bcs;
    43d0:	c8 18       	sub	r12, r8
    43d2:	d9 08       	sbc	r13, r9
    43d4:	ea 08       	sbc	r14, r10
    43d6:	fb 08       	sbc	r15, r11
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
    43d8:	8c 14       	cp	r8, r12
    43da:	9d 04       	cpc	r9, r13
    43dc:	ae 04       	cpc	r10, r14
    43de:	bf 04       	cpc	r11, r15
    43e0:	08 f4       	brcc	.+2      	; 0x43e4 <f_lseek+0x298>
    43e2:	a1 cf       	rjmp	.-190    	; 0x4326 <f_lseek+0x1da>
    43e4:	5e 82       	std	Y+6, r5	; 0x06
    43e6:	4d 82       	std	Y+5, r4	; 0x05
    43e8:	04 c0       	rjmp	.+8      	; 0x43f2 <f_lseek+0x2a6>
    43ea:	5e 82       	std	Y+6, r5	; 0x06
    43ec:	4d 82       	std	Y+5, r4	; 0x05
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
						if (clst == 0) {				/* When disk gets full, clip file size */
							ofs = bcs; break;
    43ee:	75 01       	movw	r14, r10
    43f0:	64 01       	movw	r12, r8
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
    43f2:	ed 81       	ldd	r30, Y+5	; 0x05
    43f4:	fe 81       	ldd	r31, Y+6	; 0x06
    43f6:	86 81       	ldd	r24, Z+6	; 0x06
    43f8:	97 81       	ldd	r25, Z+7	; 0x07
    43fa:	a0 85       	ldd	r26, Z+8	; 0x08
    43fc:	b1 85       	ldd	r27, Z+9	; 0x09
    43fe:	8c 0d       	add	r24, r12
    4400:	9d 1d       	adc	r25, r13
    4402:	ae 1d       	adc	r26, r14
    4404:	bf 1d       	adc	r27, r15
    4406:	86 83       	std	Z+6, r24	; 0x06
    4408:	97 83       	std	Z+7, r25	; 0x07
    440a:	a0 87       	std	Z+8, r26	; 0x08
    440c:	b1 87       	std	Z+9, r27	; 0x09
				if (ofs % SS(fp->fs)) {
    440e:	d7 01       	movw	r26, r14
    4410:	c6 01       	movw	r24, r12
    4412:	91 70       	andi	r25, 0x01	; 1
    4414:	a0 70       	andi	r26, 0x00	; 0
    4416:	b0 70       	andi	r27, 0x00	; 0
    4418:	00 97       	sbiw	r24, 0x00	; 0
    441a:	a1 05       	cpc	r26, r1
    441c:	b1 05       	cpc	r27, r1
    441e:	49 f1       	breq	.+82     	; 0x4472 <f_lseek+0x326>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    4420:	80 81       	ld	r24, Z
    4422:	91 81       	ldd	r25, Z+1	; 0x01
    4424:	0e 94 13 11 	call	0x2226	; 0x2226 <clust2sect>
    4428:	dc 01       	movw	r26, r24
    442a:	cb 01       	movw	r24, r22
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    442c:	00 97       	sbiw	r24, 0x00	; 0
    442e:	a1 05       	cpc	r26, r1
    4430:	b1 05       	cpc	r27, r1
    4432:	59 f4       	brne	.+22     	; 0x444a <f_lseek+0x2fe>
    4434:	ad 81       	ldd	r26, Y+5	; 0x05
    4436:	be 81       	ldd	r27, Y+6	; 0x06
    4438:	14 96       	adiw	r26, 0x04	; 4
    443a:	8c 91       	ld	r24, X
    443c:	14 97       	sbiw	r26, 0x04	; 4
    443e:	80 68       	ori	r24, 0x80	; 128
    4440:	14 96       	adiw	r26, 0x04	; 4
    4442:	8c 93       	st	X, r24
    4444:	14 97       	sbiw	r26, 0x04	; 4
    4446:	12 e0       	ldi	r17, 0x02	; 2
    4448:	88 c0       	rjmp	.+272    	; 0x455a <f_lseek+0x40e>
					nsect += ofs / SS(fp->fs);
    444a:	46 01       	movw	r8, r12
    444c:	57 01       	movw	r10, r14
    444e:	07 2e       	mov	r0, r23
    4450:	79 e0       	ldi	r23, 0x09	; 9
    4452:	b6 94       	lsr	r11
    4454:	a7 94       	ror	r10
    4456:	97 94       	ror	r9
    4458:	87 94       	ror	r8
    445a:	7a 95       	dec	r23
    445c:	d1 f7       	brne	.-12     	; 0x4452 <f_lseek+0x306>
    445e:	70 2d       	mov	r23, r0
    4460:	88 0e       	add	r8, r24
    4462:	99 1e       	adc	r9, r25
    4464:	aa 1e       	adc	r10, r26
    4466:	bb 1e       	adc	r11, r27
    4468:	07 c0       	rjmp	.+14     	; 0x4478 <f_lseek+0x32c>
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
    446a:	88 24       	eor	r8, r8
    446c:	99 24       	eor	r9, r9
    446e:	54 01       	movw	r10, r8
    4470:	03 c0       	rjmp	.+6      	; 0x4478 <f_lseek+0x32c>
    4472:	88 24       	eor	r8, r8
    4474:	99 24       	eor	r9, r9
    4476:	54 01       	movw	r10, r8
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
					nsect += ofs / SS(fp->fs);
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    4478:	ed 81       	ldd	r30, Y+5	; 0x05
    447a:	fe 81       	ldd	r31, Y+6	; 0x06
    447c:	86 81       	ldd	r24, Z+6	; 0x06
    447e:	97 81       	ldd	r25, Z+7	; 0x07
    4480:	a0 85       	ldd	r26, Z+8	; 0x08
    4482:	b1 85       	ldd	r27, Z+9	; 0x09
    4484:	91 70       	andi	r25, 0x01	; 1
    4486:	a0 70       	andi	r26, 0x00	; 0
    4488:	b0 70       	andi	r27, 0x00	; 0
    448a:	00 97       	sbiw	r24, 0x00	; 0
    448c:	a1 05       	cpc	r26, r1
    448e:	b1 05       	cpc	r27, r1
    4490:	09 f4       	brne	.+2      	; 0x4494 <f_lseek+0x348>
    4492:	4b c0       	rjmp	.+150    	; 0x452a <f_lseek+0x3de>
    4494:	c6 88       	ldd	r12, Z+22	; 0x16
    4496:	d7 88       	ldd	r13, Z+23	; 0x17
    4498:	e0 8c       	ldd	r14, Z+24	; 0x18
    449a:	f1 8c       	ldd	r15, Z+25	; 0x19
    449c:	c8 14       	cp	r12, r8
    449e:	d9 04       	cpc	r13, r9
    44a0:	ea 04       	cpc	r14, r10
    44a2:	fb 04       	cpc	r15, r11
    44a4:	09 f4       	brne	.+2      	; 0x44a8 <f_lseek+0x35c>
    44a6:	41 c0       	rjmp	.+130    	; 0x452a <f_lseek+0x3de>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
    44a8:	84 81       	ldd	r24, Z+4	; 0x04
    44aa:	86 ff       	sbrs	r24, 6
    44ac:	1f c0       	rjmp	.+62     	; 0x44ec <f_lseek+0x3a0>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    44ae:	01 90       	ld	r0, Z+
    44b0:	f0 81       	ld	r31, Z
    44b2:	e0 2d       	mov	r30, r0
    44b4:	6d 81       	ldd	r22, Y+5	; 0x05
    44b6:	7e 81       	ldd	r23, Y+6	; 0x06
    44b8:	60 5e       	subi	r22, 0xE0	; 224
    44ba:	7f 4f       	sbci	r23, 0xFF	; 255
    44bc:	81 81       	ldd	r24, Z+1	; 0x01
    44be:	a7 01       	movw	r20, r14
    44c0:	96 01       	movw	r18, r12
    44c2:	01 e0       	ldi	r16, 0x01	; 1
    44c4:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    44c8:	88 23       	and	r24, r24
    44ca:	59 f0       	breq	.+22     	; 0x44e2 <f_lseek+0x396>
					ABORT(fp->fs, FR_DISK_ERR);
    44cc:	ad 81       	ldd	r26, Y+5	; 0x05
    44ce:	be 81       	ldd	r27, Y+6	; 0x06
    44d0:	14 96       	adiw	r26, 0x04	; 4
    44d2:	8c 91       	ld	r24, X
    44d4:	14 97       	sbiw	r26, 0x04	; 4
    44d6:	80 68       	ori	r24, 0x80	; 128
    44d8:	14 96       	adiw	r26, 0x04	; 4
    44da:	8c 93       	st	X, r24
    44dc:	14 97       	sbiw	r26, 0x04	; 4
    44de:	11 e0       	ldi	r17, 0x01	; 1
    44e0:	3c c0       	rjmp	.+120    	; 0x455a <f_lseek+0x40e>
				fp->flag &= ~FA__DIRTY;
    44e2:	ed 81       	ldd	r30, Y+5	; 0x05
    44e4:	fe 81       	ldd	r31, Y+6	; 0x06
    44e6:	84 81       	ldd	r24, Z+4	; 0x04
    44e8:	8f 7b       	andi	r24, 0xBF	; 191
    44ea:	84 83       	std	Z+4, r24	; 0x04
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
    44ec:	ad 81       	ldd	r26, Y+5	; 0x05
    44ee:	be 81       	ldd	r27, Y+6	; 0x06
    44f0:	ed 91       	ld	r30, X+
    44f2:	fc 91       	ld	r31, X
    44f4:	11 97       	sbiw	r26, 0x01	; 1
    44f6:	bd 01       	movw	r22, r26
    44f8:	60 5e       	subi	r22, 0xE0	; 224
    44fa:	7f 4f       	sbci	r23, 0xFF	; 255
    44fc:	81 81       	ldd	r24, Z+1	; 0x01
    44fe:	a5 01       	movw	r20, r10
    4500:	94 01       	movw	r18, r8
    4502:	01 e0       	ldi	r16, 0x01	; 1
    4504:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    4508:	88 23       	and	r24, r24
    450a:	39 f0       	breq	.+14     	; 0x451a <f_lseek+0x3ce>
				ABORT(fp->fs, FR_DISK_ERR);
    450c:	ed 81       	ldd	r30, Y+5	; 0x05
    450e:	fe 81       	ldd	r31, Y+6	; 0x06
    4510:	84 81       	ldd	r24, Z+4	; 0x04
    4512:	80 68       	ori	r24, 0x80	; 128
    4514:	84 83       	std	Z+4, r24	; 0x04
    4516:	11 e0       	ldi	r17, 0x01	; 1
    4518:	20 c0       	rjmp	.+64     	; 0x455a <f_lseek+0x40e>
#endif
			fp->dsect = nsect;
    451a:	ad 81       	ldd	r26, Y+5	; 0x05
    451c:	be 81       	ldd	r27, Y+6	; 0x06
    451e:	56 96       	adiw	r26, 0x16	; 22
    4520:	8d 92       	st	X+, r8
    4522:	9d 92       	st	X+, r9
    4524:	ad 92       	st	X+, r10
    4526:	bc 92       	st	X, r11
    4528:	59 97       	sbiw	r26, 0x19	; 25
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
    452a:	ed 81       	ldd	r30, Y+5	; 0x05
    452c:	fe 81       	ldd	r31, Y+6	; 0x06
    452e:	86 81       	ldd	r24, Z+6	; 0x06
    4530:	97 81       	ldd	r25, Z+7	; 0x07
    4532:	a0 85       	ldd	r26, Z+8	; 0x08
    4534:	b1 85       	ldd	r27, Z+9	; 0x09
    4536:	42 85       	ldd	r20, Z+10	; 0x0a
    4538:	53 85       	ldd	r21, Z+11	; 0x0b
    453a:	64 85       	ldd	r22, Z+12	; 0x0c
    453c:	75 85       	ldd	r23, Z+13	; 0x0d
    453e:	48 17       	cp	r20, r24
    4540:	59 07       	cpc	r21, r25
    4542:	6a 07       	cpc	r22, r26
    4544:	7b 07       	cpc	r23, r27
    4546:	48 f4       	brcc	.+18     	; 0x455a <f_lseek+0x40e>
			fp->fsize = fp->fptr;
    4548:	82 87       	std	Z+10, r24	; 0x0a
    454a:	93 87       	std	Z+11, r25	; 0x0b
    454c:	a4 87       	std	Z+12, r26	; 0x0c
    454e:	b5 87       	std	Z+13, r27	; 0x0d
			fp->flag |= FA__WRITTEN;
    4550:	84 81       	ldd	r24, Z+4	; 0x04
    4552:	80 62       	ori	r24, 0x20	; 32
    4554:	84 83       	std	Z+4, r24	; 0x04
    4556:	01 c0       	rjmp	.+2      	; 0x455a <f_lseek+0x40e>


	res = validate(fp);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)			/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    4558:	12 e0       	ldi	r17, 0x02	; 2
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
    455a:	81 2f       	mov	r24, r17
    455c:	26 96       	adiw	r28, 0x06	; 6
    455e:	0f b6       	in	r0, 0x3f	; 63
    4560:	f8 94       	cli
    4562:	de bf       	out	0x3e, r29	; 62
    4564:	0f be       	out	0x3f, r0	; 63
    4566:	cd bf       	out	0x3d, r28	; 61
    4568:	df 91       	pop	r29
    456a:	cf 91       	pop	r28
    456c:	1f 91       	pop	r17
    456e:	0f 91       	pop	r16
    4570:	ff 90       	pop	r15
    4572:	ef 90       	pop	r14
    4574:	df 90       	pop	r13
    4576:	cf 90       	pop	r12
    4578:	bf 90       	pop	r11
    457a:	af 90       	pop	r10
    457c:	9f 90       	pop	r9
    457e:	8f 90       	pop	r8
    4580:	7f 90       	pop	r7
    4582:	6f 90       	pop	r6
    4584:	5f 90       	pop	r5
    4586:	4f 90       	pop	r4
    4588:	3f 90       	pop	r3
    458a:	2f 90       	pop	r2
    458c:	08 95       	ret

0000458e <f_opendir>:

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const TCHAR *path	/* Pointer to the directory path */
)
{
    458e:	ef 92       	push	r14
    4590:	ff 92       	push	r15
    4592:	0f 93       	push	r16
    4594:	1f 93       	push	r17
    4596:	cf 93       	push	r28
    4598:	df 93       	push	r29
    459a:	cd b7       	in	r28, 0x3d	; 61
    459c:	de b7       	in	r29, 0x3e	; 62
    459e:	2e 97       	sbiw	r28, 0x0e	; 14
    45a0:	0f b6       	in	r0, 0x3f	; 63
    45a2:	f8 94       	cli
    45a4:	de bf       	out	0x3e, r29	; 62
    45a6:	0f be       	out	0x3f, r0	; 63
    45a8:	cd bf       	out	0x3d, r28	; 61
    45aa:	8c 01       	movw	r16, r24
    45ac:	7e 87       	std	Y+14, r23	; 0x0e
    45ae:	6d 87       	std	Y+13, r22	; 0x0d
	FRESULT res;
	FATFS *fs;
	DEF_NAMEBUF;


	if (!dj) return FR_INVALID_OBJECT;
    45b0:	00 97       	sbiw	r24, 0x00	; 0
    45b2:	09 f4       	brne	.+2      	; 0x45b6 <f_opendir+0x28>
    45b4:	4c c0       	rjmp	.+152    	; 0x464e <f_opendir+0xc0>

	res = chk_mounted(&path, &dj->fs, 0);
    45b6:	ce 01       	movw	r24, r28
    45b8:	0d 96       	adiw	r24, 0x0d	; 13
    45ba:	b8 01       	movw	r22, r16
    45bc:	40 e0       	ldi	r20, 0x00	; 0
    45be:	0e 94 ac 0b 	call	0x1758	; 0x1758 <chk_mounted>
	fs = dj->fs;
    45c2:	d8 01       	movw	r26, r16
    45c4:	ed 90       	ld	r14, X+
    45c6:	fc 90       	ld	r15, X
    45c8:	11 97       	sbiw	r26, 0x01	; 1
	if (res == FR_OK) {
    45ca:	88 23       	and	r24, r24
    45cc:	e1 f5       	brne	.+120    	; 0x4646 <f_opendir+0xb8>
		INIT_BUF(*dj);
    45ce:	ce 01       	movw	r24, r28
    45d0:	01 96       	adiw	r24, 0x01	; 1
    45d2:	55 96       	adiw	r26, 0x15	; 21
    45d4:	9c 93       	st	X, r25
    45d6:	8e 93       	st	-X, r24
    45d8:	54 97       	sbiw	r26, 0x14	; 20
		res = follow_path(dj, path);			/* Follow the path to the directory */
    45da:	6d 85       	ldd	r22, Y+13	; 0x0d
    45dc:	7e 85       	ldd	r23, Y+14	; 0x0e
    45de:	c8 01       	movw	r24, r16
    45e0:	0e 94 db 16 	call	0x2db6	; 0x2db6 <follow_path>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
    45e4:	88 23       	and	r24, r24
    45e6:	11 f5       	brne	.+68     	; 0x462c <f_opendir+0x9e>
			if (dj->dir) {						/* It is not the root dir */
    45e8:	d8 01       	movw	r26, r16
    45ea:	52 96       	adiw	r26, 0x12	; 18
    45ec:	ed 91       	ld	r30, X+
    45ee:	fc 91       	ld	r31, X
    45f0:	53 97       	sbiw	r26, 0x13	; 19
    45f2:	30 97       	sbiw	r30, 0x00	; 0
    45f4:	71 f0       	breq	.+28     	; 0x4612 <f_opendir+0x84>
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
    45f6:	83 85       	ldd	r24, Z+11	; 0x0b
    45f8:	84 ff       	sbrs	r24, 4
    45fa:	1b c0       	rjmp	.+54     	; 0x4632 <f_opendir+0xa4>
					dj->sclust = ld_clust(fs, dj->dir);
    45fc:	c7 01       	movw	r24, r14
    45fe:	bf 01       	movw	r22, r30
    4600:	0e 94 2f 0a 	call	0x145e	; 0x145e <ld_clust>
    4604:	dc 01       	movw	r26, r24
    4606:	cb 01       	movw	r24, r22
    4608:	f8 01       	movw	r30, r16
    460a:	86 83       	std	Z+6, r24	; 0x06
    460c:	97 83       	std	Z+7, r25	; 0x07
    460e:	a0 87       	std	Z+8, r26	; 0x08
    4610:	b1 87       	std	Z+9, r27	; 0x09
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dj->id = fs->id;
    4612:	d7 01       	movw	r26, r14
    4614:	16 96       	adiw	r26, 0x06	; 6
    4616:	8d 91       	ld	r24, X+
    4618:	9c 91       	ld	r25, X
    461a:	17 97       	sbiw	r26, 0x07	; 7
    461c:	f8 01       	movw	r30, r16
    461e:	93 83       	std	Z+3, r25	; 0x03
    4620:	82 83       	std	Z+2, r24	; 0x02
				res = dir_sdi(dj, 0);			/* Rewind dir */
    4622:	c8 01       	movw	r24, r16
    4624:	60 e0       	ldi	r22, 0x00	; 0
    4626:	70 e0       	ldi	r23, 0x00	; 0
    4628:	0e 94 80 12 	call	0x2500	; 0x2500 <dir_sdi>
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    462c:	84 30       	cpi	r24, 0x04	; 4
    462e:	11 f4       	brne	.+4      	; 0x4634 <f_opendir+0xa6>
    4630:	04 c0       	rjmp	.+8      	; 0x463a <f_opendir+0xac>
		if (res == FR_OK) {						/* Follow completed */
			if (dj->dir) {						/* It is not the root dir */
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
					dj->sclust = ld_clust(fs, dj->dir);
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
    4632:	85 e0       	ldi	r24, 0x05	; 5
				dj->id = fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
    4634:	88 23       	and	r24, r24
    4636:	61 f0       	breq	.+24     	; 0x4650 <f_opendir+0xc2>
    4638:	01 c0       	rjmp	.+2      	; 0x463c <f_opendir+0xae>
			if (res == FR_OK) {
				dj->id = fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    463a:	85 e0       	ldi	r24, 0x05	; 5
		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
    463c:	d8 01       	movw	r26, r16
    463e:	11 96       	adiw	r26, 0x01	; 1
    4640:	1c 92       	st	X, r1
    4642:	1e 92       	st	-X, r1
    4644:	05 c0       	rjmp	.+10     	; 0x4650 <f_opendir+0xc2>
	} else {
		dj->fs = 0;
    4646:	f8 01       	movw	r30, r16
    4648:	11 82       	std	Z+1, r1	; 0x01
    464a:	10 82       	st	Z, r1
    464c:	01 c0       	rjmp	.+2      	; 0x4650 <f_opendir+0xc2>
	FRESULT res;
	FATFS *fs;
	DEF_NAMEBUF;


	if (!dj) return FR_INVALID_OBJECT;
    464e:	89 e0       	ldi	r24, 0x09	; 9
	} else {
		dj->fs = 0;
	}

	LEAVE_FF(fs, res);
}
    4650:	2e 96       	adiw	r28, 0x0e	; 14
    4652:	0f b6       	in	r0, 0x3f	; 63
    4654:	f8 94       	cli
    4656:	de bf       	out	0x3e, r29	; 62
    4658:	0f be       	out	0x3f, r0	; 63
    465a:	cd bf       	out	0x3d, r28	; 61
    465c:	df 91       	pop	r29
    465e:	cf 91       	pop	r28
    4660:	1f 91       	pop	r17
    4662:	0f 91       	pop	r16
    4664:	ff 90       	pop	r15
    4666:	ef 90       	pop	r14
    4668:	08 95       	ret

0000466a <f_readdir>:

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
    466a:	cf 92       	push	r12
    466c:	df 92       	push	r13
    466e:	ef 92       	push	r14
    4670:	ff 92       	push	r15
    4672:	1f 93       	push	r17
    4674:	cf 93       	push	r28
    4676:	df 93       	push	r29
    4678:	cd b7       	in	r28, 0x3d	; 61
    467a:	de b7       	in	r29, 0x3e	; 62
    467c:	2c 97       	sbiw	r28, 0x0c	; 12
    467e:	0f b6       	in	r0, 0x3f	; 63
    4680:	f8 94       	cli
    4682:	de bf       	out	0x3e, r29	; 62
    4684:	0f be       	out	0x3f, r0	; 63
    4686:	cd bf       	out	0x3d, r28	; 61
    4688:	7c 01       	movw	r14, r24
    468a:	6b 01       	movw	r12, r22
	FRESULT res;
	DEF_NAMEBUF;


	res = validate(dj);						/* Check validity of the object */
    468c:	0e 94 ef 0a 	call	0x15de	; 0x15de <validate>
    4690:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    4692:	88 23       	and	r24, r24
    4694:	81 f5       	brne	.+96     	; 0x46f6 <f_readdir+0x8c>
		if (!fno) {
    4696:	c1 14       	cp	r12, r1
    4698:	d1 04       	cpc	r13, r1
    469a:	39 f4       	brne	.+14     	; 0x46aa <f_readdir+0x40>
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
    469c:	c7 01       	movw	r24, r14
    469e:	60 e0       	ldi	r22, 0x00	; 0
    46a0:	70 e0       	ldi	r23, 0x00	; 0
    46a2:	0e 94 80 12 	call	0x2500	; 0x2500 <dir_sdi>
    46a6:	18 2f       	mov	r17, r24
    46a8:	26 c0       	rjmp	.+76     	; 0x46f6 <f_readdir+0x8c>
		} else {
			INIT_BUF(*dj);
    46aa:	ce 01       	movw	r24, r28
    46ac:	01 96       	adiw	r24, 0x01	; 1
    46ae:	f7 01       	movw	r30, r14
    46b0:	95 8b       	std	Z+21, r25	; 0x15
    46b2:	84 8b       	std	Z+20, r24	; 0x14
			res = dir_read(dj);				/* Read an directory item */
    46b4:	c7 01       	movw	r24, r14
    46b6:	0e 94 63 19 	call	0x32c6	; 0x32c6 <dir_read>
			if (res == FR_NO_FILE) {		/* Reached end of dir */
    46ba:	84 30       	cpi	r24, 0x04	; 4
    46bc:	31 f4       	brne	.+12     	; 0x46ca <f_readdir+0x60>
				dj->sect = 0;
    46be:	f7 01       	movw	r30, r14
    46c0:	16 86       	std	Z+14, r1	; 0x0e
    46c2:	17 86       	std	Z+15, r1	; 0x0f
    46c4:	10 8a       	std	Z+16, r1	; 0x10
    46c6:	11 8a       	std	Z+17, r1	; 0x11
    46c8:	02 c0       	rjmp	.+4      	; 0x46ce <f_readdir+0x64>
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
    46ca:	88 23       	and	r24, r24
    46cc:	89 f4       	brne	.+34     	; 0x46f0 <f_readdir+0x86>
				get_fileinfo(dj, fno);		/* Get the object information */
    46ce:	c7 01       	movw	r24, r14
    46d0:	b6 01       	movw	r22, r12
    46d2:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <get_fileinfo>
				res = dir_next(dj, 0);		/* Increment index for next */
    46d6:	c7 01       	movw	r24, r14
    46d8:	60 e0       	ldi	r22, 0x00	; 0
    46da:	70 e0       	ldi	r23, 0x00	; 0
    46dc:	0e 94 94 15 	call	0x2b28	; 0x2b28 <dir_next>
				if (res == FR_NO_FILE) {
    46e0:	84 30       	cpi	r24, 0x04	; 4
    46e2:	41 f4       	brne	.+16     	; 0x46f4 <f_readdir+0x8a>
					dj->sect = 0;
    46e4:	f7 01       	movw	r30, r14
    46e6:	16 86       	std	Z+14, r1	; 0x0e
    46e8:	17 86       	std	Z+15, r1	; 0x0f
    46ea:	10 8a       	std	Z+16, r1	; 0x10
    46ec:	11 8a       	std	Z+17, r1	; 0x11
    46ee:	03 c0       	rjmp	.+6      	; 0x46f6 <f_readdir+0x8c>
	if (res == FR_OK) {
		if (!fno) {
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
		} else {
			INIT_BUF(*dj);
			res = dir_read(dj);				/* Read an directory item */
    46f0:	18 2f       	mov	r17, r24
    46f2:	01 c0       	rjmp	.+2      	; 0x46f6 <f_readdir+0x8c>
				dj->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj, 0);		/* Increment index for next */
    46f4:	18 2f       	mov	r17, r24
			FREE_BUF();
		}
	}

	LEAVE_FF(dj->fs, res);
}
    46f6:	81 2f       	mov	r24, r17
    46f8:	2c 96       	adiw	r28, 0x0c	; 12
    46fa:	0f b6       	in	r0, 0x3f	; 63
    46fc:	f8 94       	cli
    46fe:	de bf       	out	0x3e, r29	; 62
    4700:	0f be       	out	0x3f, r0	; 63
    4702:	cd bf       	out	0x3d, r28	; 61
    4704:	df 91       	pop	r29
    4706:	cf 91       	pop	r28
    4708:	1f 91       	pop	r17
    470a:	ff 90       	pop	r15
    470c:	ef 90       	pop	r14
    470e:	df 90       	pop	r13
    4710:	cf 90       	pop	r12
    4712:	08 95       	ret

00004714 <f_stat>:

FRESULT f_stat (
	const TCHAR *path,	/* Pointer to the file path */
	FILINFO *fno		/* Pointer to file information to return */
)
{
    4714:	ef 92       	push	r14
    4716:	ff 92       	push	r15
    4718:	1f 93       	push	r17
    471a:	cf 93       	push	r28
    471c:	df 93       	push	r29
    471e:	cd b7       	in	r28, 0x3d	; 61
    4720:	de b7       	in	r29, 0x3e	; 62
    4722:	a4 97       	sbiw	r28, 0x24	; 36
    4724:	0f b6       	in	r0, 0x3f	; 63
    4726:	f8 94       	cli
    4728:	de bf       	out	0x3e, r29	; 62
    472a:	0f be       	out	0x3f, r0	; 63
    472c:	cd bf       	out	0x3d, r28	; 61
    472e:	9c a3       	lds	r25, 0x5c
    4730:	8b a3       	lds	r24, 0x5b
    4732:	7b 01       	movw	r14, r22
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
    4734:	ce 01       	movw	r24, r28
    4736:	83 96       	adiw	r24, 0x23	; 35
    4738:	be 01       	movw	r22, r28
    473a:	6f 5f       	subi	r22, 0xFF	; 255
    473c:	7f 4f       	sbci	r23, 0xFF	; 255
    473e:	40 e0       	ldi	r20, 0x00	; 0
    4740:	0e 94 ac 0b 	call	0x1758	; 0x1758 <chk_mounted>
    4744:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    4746:	88 23       	and	r24, r24
    4748:	c1 f4       	brne	.+48     	; 0x477a <f_stat+0x66>
		INIT_BUF(dj);
    474a:	ce 01       	movw	r24, r28
    474c:	47 96       	adiw	r24, 0x17	; 23
    474e:	9e 8b       	std	Y+22, r25	; 0x16
    4750:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    4752:	6b a1       	lds	r22, 0x4b
    4754:	7c a1       	lds	r23, 0x4c
    4756:	ce 01       	movw	r24, r28
    4758:	01 96       	adiw	r24, 0x01	; 1
    475a:	0e 94 db 16 	call	0x2db6	; 0x2db6 <follow_path>
    475e:	18 2f       	mov	r17, r24
		if (res == FR_OK) {				/* Follow completed */
    4760:	88 23       	and	r24, r24
    4762:	59 f4       	brne	.+22     	; 0x477a <f_stat+0x66>
			if (dj.dir)		/* Found an object */
    4764:	8b 89       	ldd	r24, Y+19	; 0x13
    4766:	9c 89       	ldd	r25, Y+20	; 0x14
    4768:	00 97       	sbiw	r24, 0x00	; 0
    476a:	31 f0       	breq	.+12     	; 0x4778 <f_stat+0x64>
				get_fileinfo(&dj, fno);
    476c:	ce 01       	movw	r24, r28
    476e:	01 96       	adiw	r24, 0x01	; 1
    4770:	b7 01       	movw	r22, r14
    4772:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <get_fileinfo>
    4776:	01 c0       	rjmp	.+2      	; 0x477a <f_stat+0x66>
			else			/* It is root dir */
				res = FR_INVALID_NAME;
    4778:	16 e0       	ldi	r17, 0x06	; 6
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    477a:	81 2f       	mov	r24, r17
    477c:	a4 96       	adiw	r28, 0x24	; 36
    477e:	0f b6       	in	r0, 0x3f	; 63
    4780:	f8 94       	cli
    4782:	de bf       	out	0x3e, r29	; 62
    4784:	0f be       	out	0x3f, r0	; 63
    4786:	cd bf       	out	0x3d, r28	; 61
    4788:	df 91       	pop	r29
    478a:	cf 91       	pop	r28
    478c:	1f 91       	pop	r17
    478e:	ff 90       	pop	r15
    4790:	ef 90       	pop	r14
    4792:	08 95       	ret

00004794 <f_getfree>:
FRESULT f_getfree (
	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
)
{
    4794:	2f 92       	push	r2
    4796:	3f 92       	push	r3
    4798:	4f 92       	push	r4
    479a:	5f 92       	push	r5
    479c:	6f 92       	push	r6
    479e:	7f 92       	push	r7
    47a0:	8f 92       	push	r8
    47a2:	9f 92       	push	r9
    47a4:	af 92       	push	r10
    47a6:	bf 92       	push	r11
    47a8:	cf 92       	push	r12
    47aa:	df 92       	push	r13
    47ac:	ef 92       	push	r14
    47ae:	ff 92       	push	r15
    47b0:	0f 93       	push	r16
    47b2:	1f 93       	push	r17
    47b4:	cf 93       	push	r28
    47b6:	df 93       	push	r29
    47b8:	cd b7       	in	r28, 0x3d	; 61
    47ba:	de b7       	in	r29, 0x3e	; 62
    47bc:	2c 97       	sbiw	r28, 0x0c	; 12
    47be:	0f b6       	in	r0, 0x3f	; 63
    47c0:	f8 94       	cli
    47c2:	de bf       	out	0x3e, r29	; 62
    47c4:	0f be       	out	0x3f, r0	; 63
    47c6:	cd bf       	out	0x3d, r28	; 61
    47c8:	9a 83       	std	Y+2, r25	; 0x02
    47ca:	89 83       	std	Y+1, r24	; 0x01
    47cc:	78 87       	std	Y+8, r23	; 0x08
    47ce:	6f 83       	std	Y+7, r22	; 0x07
    47d0:	8a 01       	movw	r16, r20
	UINT i;
	BYTE fat, *p;


	/* Get drive number */
	res = chk_mounted(&path, fatfs, 0);
    47d2:	ce 01       	movw	r24, r28
    47d4:	01 96       	adiw	r24, 0x01	; 1
    47d6:	ba 01       	movw	r22, r20
    47d8:	40 e0       	ldi	r20, 0x00	; 0
    47da:	0e 94 ac 0b 	call	0x1758	; 0x1758 <chk_mounted>
    47de:	b8 2e       	mov	r11, r24
	fs = *fatfs;
    47e0:	d8 01       	movw	r26, r16
    47e2:	8d 90       	ld	r8, X+
    47e4:	9c 90       	ld	r9, X
    47e6:	11 97       	sbiw	r26, 0x01	; 1
	if (res == FR_OK) {
    47e8:	88 23       	and	r24, r24
    47ea:	09 f0       	breq	.+2      	; 0x47ee <f_getfree+0x5a>
    47ec:	03 c1       	rjmp	.+518    	; 0x49f4 <f_getfree+0x260>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
    47ee:	f4 01       	movw	r30, r8
    47f0:	86 85       	ldd	r24, Z+14	; 0x0e
    47f2:	97 85       	ldd	r25, Z+15	; 0x0f
    47f4:	a0 89       	ldd	r26, Z+16	; 0x10
    47f6:	b1 89       	ldd	r27, Z+17	; 0x11
    47f8:	c2 8c       	ldd	r12, Z+26	; 0x1a
    47fa:	d3 8c       	ldd	r13, Z+27	; 0x1b
    47fc:	e4 8c       	ldd	r14, Z+28	; 0x1c
    47fe:	f5 8c       	ldd	r15, Z+29	; 0x1d
    4800:	b7 01       	movw	r22, r14
    4802:	a6 01       	movw	r20, r12
    4804:	42 50       	subi	r20, 0x02	; 2
    4806:	50 40       	sbci	r21, 0x00	; 0
    4808:	60 40       	sbci	r22, 0x00	; 0
    480a:	70 40       	sbci	r23, 0x00	; 0
    480c:	48 17       	cp	r20, r24
    480e:	59 07       	cpc	r21, r25
    4810:	6a 07       	cpc	r22, r26
    4812:	7b 07       	cpc	r23, r27
    4814:	38 f0       	brcs	.+14     	; 0x4824 <f_getfree+0x90>
			*nclst = fs->free_clust;
    4816:	ef 81       	ldd	r30, Y+7	; 0x07
    4818:	f8 85       	ldd	r31, Y+8	; 0x08
    481a:	80 83       	st	Z, r24
    481c:	91 83       	std	Z+1, r25	; 0x01
    481e:	a2 83       	std	Z+2, r26	; 0x02
    4820:	b3 83       	std	Z+3, r27	; 0x03
    4822:	e8 c0       	rjmp	.+464    	; 0x49f4 <f_getfree+0x260>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
    4824:	a0 80       	ld	r10, Z
			n = 0;
			if (fat == FS_FAT12) {
    4826:	b1 e0       	ldi	r27, 0x01	; 1
    4828:	ab 16       	cp	r10, r27
    482a:	d9 f5       	brne	.+118    	; 0x48a2 <f_getfree+0x10e>
    482c:	cc 24       	eor	r12, r12
    482e:	dd 24       	eor	r13, r13
    4830:	76 01       	movw	r14, r12
    4832:	68 94       	set
    4834:	c1 f8       	bld	r12, 1
    4836:	44 24       	eor	r4, r4
    4838:	55 24       	eor	r5, r5
    483a:	32 01       	movw	r6, r4
				clst = 2;
				do {
					stat = get_fat(fs, clst);
    483c:	c4 01       	movw	r24, r8
    483e:	b7 01       	movw	r22, r14
    4840:	a6 01       	movw	r20, r12
    4842:	0e 94 49 11 	call	0x2292	; 0x2292 <get_fat>
    4846:	dc 01       	movw	r26, r24
    4848:	cb 01       	movw	r24, r22
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
    484a:	8f 3f       	cpi	r24, 0xFF	; 255
    484c:	ef ef       	ldi	r30, 0xFF	; 255
    484e:	9e 07       	cpc	r25, r30
    4850:	ef ef       	ldi	r30, 0xFF	; 255
    4852:	ae 07       	cpc	r26, r30
    4854:	ef ef       	ldi	r30, 0xFF	; 255
    4856:	be 07       	cpc	r27, r30
    4858:	09 f4       	brne	.+2      	; 0x485c <f_getfree+0xc8>
    485a:	b0 c0       	rjmp	.+352    	; 0x49bc <f_getfree+0x228>
					if (stat == 1) { res = FR_INT_ERR; break; }
    485c:	81 30       	cpi	r24, 0x01	; 1
    485e:	91 05       	cpc	r25, r1
    4860:	a1 05       	cpc	r26, r1
    4862:	b1 05       	cpc	r27, r1
    4864:	09 f4       	brne	.+2      	; 0x4868 <f_getfree+0xd4>
    4866:	ad c0       	rjmp	.+346    	; 0x49c2 <f_getfree+0x22e>
					if (stat == 0) n++;
    4868:	00 97       	sbiw	r24, 0x00	; 0
    486a:	a1 05       	cpc	r26, r1
    486c:	b1 05       	cpc	r27, r1
    486e:	29 f4       	brne	.+10     	; 0x487a <f_getfree+0xe6>
    4870:	08 94       	sec
    4872:	41 1c       	adc	r4, r1
    4874:	51 1c       	adc	r5, r1
    4876:	61 1c       	adc	r6, r1
    4878:	71 1c       	adc	r7, r1
				} while (++clst < fs->n_fatent);
    487a:	08 94       	sec
    487c:	c1 1c       	adc	r12, r1
    487e:	d1 1c       	adc	r13, r1
    4880:	e1 1c       	adc	r14, r1
    4882:	f1 1c       	adc	r15, r1
    4884:	f4 01       	movw	r30, r8
    4886:	82 8d       	ldd	r24, Z+26	; 0x1a
    4888:	93 8d       	ldd	r25, Z+27	; 0x1b
    488a:	a4 8d       	ldd	r26, Z+28	; 0x1c
    488c:	b5 8d       	ldd	r27, Z+29	; 0x1d
    488e:	c8 16       	cp	r12, r24
    4890:	d9 06       	cpc	r13, r25
    4892:	ea 06       	cpc	r14, r26
    4894:	fb 06       	cpc	r15, r27
    4896:	90 f2       	brcs	.-92     	; 0x483c <f_getfree+0xa8>
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
    4898:	46 86       	std	Z+14, r4	; 0x0e
    489a:	57 86       	std	Z+15, r5	; 0x0f
    489c:	60 8a       	std	Z+16, r6	; 0x10
    489e:	71 8a       	std	Z+17, r7	; 0x11
    48a0:	a2 c0       	rjmp	.+324    	; 0x49e6 <f_getfree+0x252>
					if (stat == 1) { res = FR_INT_ERR; break; }
					if (stat == 0) n++;
				} while (++clst < fs->n_fatent);
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
    48a2:	82 a1       	lds	r24, 0x42
    48a4:	93 a1       	lds	r25, 0x43
    48a6:	a4 a1       	lds	r26, 0x44
    48a8:	b5 a1       	lds	r27, 0x45
    48aa:	8b 83       	std	Y+3, r24	; 0x03
    48ac:	9c 83       	std	Y+4, r25	; 0x04
    48ae:	ad 83       	std	Y+5, r26	; 0x05
    48b0:	be 83       	std	Y+6, r27	; 0x06
				i = 0; p = 0;
    48b2:	e0 e0       	ldi	r30, 0x00	; 0
    48b4:	f0 e0       	ldi	r31, 0x00	; 0
    48b6:	00 e0       	ldi	r16, 0x00	; 0
    48b8:	10 e0       	ldi	r17, 0x00	; 0
    48ba:	98 01       	movw	r18, r16
		if (fs->free_clust <= fs->n_fatent - 2) {
			*nclst = fs->free_clust;
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
			n = 0;
    48bc:	44 24       	eor	r4, r4
    48be:	55 24       	eor	r5, r5
    48c0:	32 01       	movw	r6, r4
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
    48c2:	a4 01       	movw	r20, r8
    48c4:	4e 5c       	subi	r20, 0xCE	; 206
    48c6:	5f 4f       	sbci	r21, 0xFF	; 255
    48c8:	5c 87       	std	Y+12, r21	; 0x0c
    48ca:	4b 87       	std	Y+11, r20	; 0x0b
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
    48cc:	01 15       	cp	r16, r1
    48ce:	11 05       	cpc	r17, r1
    48d0:	21 05       	cpc	r18, r1
    48d2:	31 05       	cpc	r19, r1
    48d4:	d9 f4       	brne	.+54     	; 0x490c <f_getfree+0x178>
						res = move_window(fs, sect++);
    48d6:	c4 01       	movw	r24, r8
    48d8:	4b 81       	ldd	r20, Y+3	; 0x03
    48da:	5c 81       	ldd	r21, Y+4	; 0x04
    48dc:	6d 81       	ldd	r22, Y+5	; 0x05
    48de:	7e 81       	ldd	r23, Y+6	; 0x06
    48e0:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
						if (res != FR_OK) break;
    48e4:	88 23       	and	r24, r24
    48e6:	09 f0       	breq	.+2      	; 0x48ea <f_getfree+0x156>
    48e8:	70 c0       	rjmp	.+224    	; 0x49ca <f_getfree+0x236>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
    48ea:	8b 81       	ldd	r24, Y+3	; 0x03
    48ec:	9c 81       	ldd	r25, Y+4	; 0x04
    48ee:	ad 81       	ldd	r26, Y+5	; 0x05
    48f0:	be 81       	ldd	r27, Y+6	; 0x06
    48f2:	01 96       	adiw	r24, 0x01	; 1
    48f4:	a1 1d       	adc	r26, r1
    48f6:	b1 1d       	adc	r27, r1
    48f8:	8b 83       	std	Y+3, r24	; 0x03
    48fa:	9c 83       	std	Y+4, r25	; 0x04
    48fc:	ad 83       	std	Y+5, r26	; 0x05
    48fe:	be 83       	std	Y+6, r27	; 0x06
						if (res != FR_OK) break;
						p = fs->win;
    4900:	eb 85       	ldd	r30, Y+11	; 0x0b
    4902:	fc 85       	ldd	r31, Y+12	; 0x0c
						i = SS(fs);
    4904:	00 e0       	ldi	r16, 0x00	; 0
    4906:	12 e0       	ldi	r17, 0x02	; 2
    4908:	20 e0       	ldi	r18, 0x00	; 0
    490a:	30 e0       	ldi	r19, 0x00	; 0
					}
					if (fat == FS_FAT16) {
    490c:	92 e0       	ldi	r25, 0x02	; 2
    490e:	a9 16       	cp	r10, r25
    4910:	b1 f4       	brne	.+44     	; 0x493e <f_getfree+0x1aa>
						if (LD_WORD(p) == 0) n++;
    4912:	a1 81       	ldd	r26, Z+1	; 0x01
    4914:	aa 87       	std	Y+10, r26	; 0x0a
    4916:	19 86       	std	Y+9, r1	; 0x09
    4918:	80 81       	ld	r24, Z
    491a:	90 e0       	ldi	r25, 0x00	; 0
    491c:	49 85       	ldd	r20, Y+9	; 0x09
    491e:	5a 85       	ldd	r21, Y+10	; 0x0a
    4920:	84 2b       	or	r24, r20
    4922:	95 2b       	or	r25, r21
    4924:	00 97       	sbiw	r24, 0x00	; 0
    4926:	29 f4       	brne	.+10     	; 0x4932 <f_getfree+0x19e>
    4928:	08 94       	sec
    492a:	41 1c       	adc	r4, r1
    492c:	51 1c       	adc	r5, r1
    492e:	61 1c       	adc	r6, r1
    4930:	71 1c       	adc	r7, r1
						p += 2; i -= 2;
    4932:	32 96       	adiw	r30, 0x02	; 2
    4934:	02 50       	subi	r16, 0x02	; 2
    4936:	10 40       	sbci	r17, 0x00	; 0
    4938:	20 40       	sbci	r18, 0x00	; 0
    493a:	30 40       	sbci	r19, 0x00	; 0
    493c:	33 c0       	rjmp	.+102    	; 0x49a4 <f_getfree+0x210>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
    493e:	83 81       	ldd	r24, Z+3	; 0x03
    4940:	90 e0       	ldi	r25, 0x00	; 0
    4942:	a0 e0       	ldi	r26, 0x00	; 0
    4944:	b0 e0       	ldi	r27, 0x00	; 0
    4946:	78 2f       	mov	r23, r24
    4948:	66 27       	eor	r22, r22
    494a:	55 27       	eor	r21, r21
    494c:	44 27       	eor	r20, r20
    494e:	82 81       	ldd	r24, Z+2	; 0x02
    4950:	90 e0       	ldi	r25, 0x00	; 0
    4952:	a0 e0       	ldi	r26, 0x00	; 0
    4954:	b0 e0       	ldi	r27, 0x00	; 0
    4956:	dc 01       	movw	r26, r24
    4958:	99 27       	eor	r25, r25
    495a:	88 27       	eor	r24, r24
    495c:	48 2b       	or	r20, r24
    495e:	59 2b       	or	r21, r25
    4960:	6a 2b       	or	r22, r26
    4962:	7b 2b       	or	r23, r27
    4964:	80 81       	ld	r24, Z
    4966:	90 e0       	ldi	r25, 0x00	; 0
    4968:	a0 e0       	ldi	r26, 0x00	; 0
    496a:	b0 e0       	ldi	r27, 0x00	; 0
    496c:	84 2b       	or	r24, r20
    496e:	95 2b       	or	r25, r21
    4970:	a6 2b       	or	r26, r22
    4972:	b7 2b       	or	r27, r23
    4974:	31 80       	ldd	r3, Z+1	; 0x01
    4976:	22 24       	eor	r2, r2
    4978:	a1 01       	movw	r20, r2
    497a:	60 e0       	ldi	r22, 0x00	; 0
    497c:	70 e0       	ldi	r23, 0x00	; 0
    497e:	84 2b       	or	r24, r20
    4980:	95 2b       	or	r25, r21
    4982:	a6 2b       	or	r26, r22
    4984:	b7 2b       	or	r27, r23
    4986:	bf 70       	andi	r27, 0x0F	; 15
    4988:	00 97       	sbiw	r24, 0x00	; 0
    498a:	a1 05       	cpc	r26, r1
    498c:	b1 05       	cpc	r27, r1
    498e:	29 f4       	brne	.+10     	; 0x499a <f_getfree+0x206>
    4990:	08 94       	sec
    4992:	41 1c       	adc	r4, r1
    4994:	51 1c       	adc	r5, r1
    4996:	61 1c       	adc	r6, r1
    4998:	71 1c       	adc	r7, r1
						p += 4; i -= 4;
    499a:	34 96       	adiw	r30, 0x04	; 4
    499c:	04 50       	subi	r16, 0x04	; 4
    499e:	10 40       	sbci	r17, 0x00	; 0
    49a0:	20 40       	sbci	r18, 0x00	; 0
    49a2:	30 40       	sbci	r19, 0x00	; 0
					}
				} while (--clst);
    49a4:	08 94       	sec
    49a6:	c1 08       	sbc	r12, r1
    49a8:	d1 08       	sbc	r13, r1
    49aa:	e1 08       	sbc	r14, r1
    49ac:	f1 08       	sbc	r15, r1
    49ae:	c1 14       	cp	r12, r1
    49b0:	d1 04       	cpc	r13, r1
    49b2:	e1 04       	cpc	r14, r1
    49b4:	f1 04       	cpc	r15, r1
    49b6:	09 f0       	breq	.+2      	; 0x49ba <f_getfree+0x226>
    49b8:	89 cf       	rjmp	.-238    	; 0x48cc <f_getfree+0x138>
    49ba:	08 c0       	rjmp	.+16     	; 0x49cc <f_getfree+0x238>
			n = 0;
			if (fat == FS_FAT12) {
				clst = 2;
				do {
					stat = get_fat(fs, clst);
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
    49bc:	bb 24       	eor	r11, r11
    49be:	b3 94       	inc	r11
    49c0:	05 c0       	rjmp	.+10     	; 0x49cc <f_getfree+0x238>
					if (stat == 1) { res = FR_INT_ERR; break; }
    49c2:	bb 24       	eor	r11, r11
    49c4:	68 94       	set
    49c6:	b1 f8       	bld	r11, 1
    49c8:	01 c0       	rjmp	.+2      	; 0x49cc <f_getfree+0x238>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
    49ca:	b8 2e       	mov	r11, r24
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
    49cc:	d4 01       	movw	r26, r8
    49ce:	1e 96       	adiw	r26, 0x0e	; 14
    49d0:	4d 92       	st	X+, r4
    49d2:	5d 92       	st	X+, r5
    49d4:	6d 92       	st	X+, r6
    49d6:	7c 92       	st	X, r7
    49d8:	51 97       	sbiw	r26, 0x11	; 17
			if (fat == FS_FAT32) fs->fsi_flag = 1;
    49da:	b3 e0       	ldi	r27, 0x03	; 3
    49dc:	ab 16       	cp	r10, r27
    49de:	19 f4       	brne	.+6      	; 0x49e6 <f_getfree+0x252>
    49e0:	81 e0       	ldi	r24, 0x01	; 1
    49e2:	f4 01       	movw	r30, r8
    49e4:	85 83       	std	Z+5, r24	; 0x05
			*nclst = n;
    49e6:	af 81       	ldd	r26, Y+7	; 0x07
    49e8:	b8 85       	ldd	r27, Y+8	; 0x08
    49ea:	4d 92       	st	X+, r4
    49ec:	5d 92       	st	X+, r5
    49ee:	6d 92       	st	X+, r6
    49f0:	7c 92       	st	X, r7
    49f2:	13 97       	sbiw	r26, 0x03	; 3
		}
	}
	LEAVE_FF(fs, res);
}
    49f4:	8b 2d       	mov	r24, r11
    49f6:	2c 96       	adiw	r28, 0x0c	; 12
    49f8:	0f b6       	in	r0, 0x3f	; 63
    49fa:	f8 94       	cli
    49fc:	de bf       	out	0x3e, r29	; 62
    49fe:	0f be       	out	0x3f, r0	; 63
    4a00:	cd bf       	out	0x3d, r28	; 61
    4a02:	df 91       	pop	r29
    4a04:	cf 91       	pop	r28
    4a06:	1f 91       	pop	r17
    4a08:	0f 91       	pop	r16
    4a0a:	ff 90       	pop	r15
    4a0c:	ef 90       	pop	r14
    4a0e:	df 90       	pop	r13
    4a10:	cf 90       	pop	r12
    4a12:	bf 90       	pop	r11
    4a14:	af 90       	pop	r10
    4a16:	9f 90       	pop	r9
    4a18:	8f 90       	pop	r8
    4a1a:	7f 90       	pop	r7
    4a1c:	6f 90       	pop	r6
    4a1e:	5f 90       	pop	r5
    4a20:	4f 90       	pop	r4
    4a22:	3f 90       	pop	r3
    4a24:	2f 90       	pop	r2
    4a26:	08 95       	ret

00004a28 <f_truncate>:
/*-----------------------------------------------------------------------*/

FRESULT f_truncate (
	FIL *fp		/* Pointer to the file object */
)
{
    4a28:	cf 92       	push	r12
    4a2a:	df 92       	push	r13
    4a2c:	ef 92       	push	r14
    4a2e:	ff 92       	push	r15
    4a30:	0f 93       	push	r16
    4a32:	1f 93       	push	r17
    4a34:	cf 93       	push	r28
    4a36:	df 93       	push	r29
    4a38:	ec 01       	movw	r28, r24
	FRESULT res;
	DWORD ncl;


	if (!fp) return FR_INVALID_OBJECT;
    4a3a:	00 97       	sbiw	r24, 0x00	; 0
    4a3c:	09 f4       	brne	.+2      	; 0x4a40 <f_truncate+0x18>
    4a3e:	69 c0       	rjmp	.+210    	; 0x4b12 <f_truncate+0xea>

	res = validate(fp);						/* Check validity of the object */
    4a40:	0e 94 ef 0a 	call	0x15de	; 0x15de <validate>
	if (res == FR_OK) {
    4a44:	88 23       	and	r24, r24
    4a46:	09 f0       	breq	.+2      	; 0x4a4a <f_truncate+0x22>
    4a48:	65 c0       	rjmp	.+202    	; 0x4b14 <f_truncate+0xec>
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
    4a4a:	9c 81       	ldd	r25, Y+4	; 0x04
    4a4c:	99 23       	and	r25, r25
    4a4e:	24 f0       	brlt	.+8      	; 0x4a58 <f_truncate+0x30>
			res = FR_INT_ERR;
		} else {
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
    4a50:	91 fd       	sbrc	r25, 1
    4a52:	69 c0       	rjmp	.+210    	; 0x4b26 <f_truncate+0xfe>
				res = FR_DENIED;
    4a54:	87 e0       	ldi	r24, 0x07	; 7
    4a56:	5e c0       	rjmp	.+188    	; 0x4b14 <f_truncate+0xec>
	if (!fp) return FR_INVALID_OBJECT;

	res = validate(fp);						/* Check validity of the object */
	if (res == FR_OK) {
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
			res = FR_INT_ERR;
    4a58:	82 e0       	ldi	r24, 0x02	; 2
    4a5a:	5c c0       	rjmp	.+184    	; 0x4b14 <f_truncate+0xec>
				res = FR_DENIED;
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
    4a5c:	4a 87       	std	Y+10, r20	; 0x0a
    4a5e:	5b 87       	std	Y+11, r21	; 0x0b
    4a60:	6c 87       	std	Y+12, r22	; 0x0c
    4a62:	7d 87       	std	Y+13, r23	; 0x0d
			fp->flag |= FA__WRITTEN;
    4a64:	8c 81       	ldd	r24, Y+4	; 0x04
    4a66:	80 62       	ori	r24, 0x20	; 32
    4a68:	8c 83       	std	Y+4, r24	; 0x04
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
    4a6a:	41 15       	cp	r20, r1
    4a6c:	51 05       	cpc	r21, r1
    4a6e:	61 05       	cpc	r22, r1
    4a70:	71 05       	cpc	r23, r1
    4a72:	69 f4       	brne	.+26     	; 0x4a8e <f_truncate+0x66>
				res = remove_chain(fp->fs, fp->sclust);
    4a74:	4e 85       	ldd	r20, Y+14	; 0x0e
    4a76:	5f 85       	ldd	r21, Y+15	; 0x0f
    4a78:	68 89       	ldd	r22, Y+16	; 0x10
    4a7a:	79 89       	ldd	r23, Y+17	; 0x11
    4a7c:	88 81       	ld	r24, Y
    4a7e:	99 81       	ldd	r25, Y+1	; 0x01
    4a80:	0e 94 93 19 	call	0x3326	; 0x3326 <remove_chain>
				fp->sclust = 0;
    4a84:	1e 86       	std	Y+14, r1	; 0x0e
    4a86:	1f 86       	std	Y+15, r1	; 0x0f
    4a88:	18 8a       	std	Y+16, r1	; 0x10
    4a8a:	19 8a       	std	Y+17, r1	; 0x11
    4a8c:	3c c0       	rjmp	.+120    	; 0x4b06 <f_truncate+0xde>
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
    4a8e:	4a 89       	ldd	r20, Y+18	; 0x12
    4a90:	5b 89       	ldd	r21, Y+19	; 0x13
    4a92:	6c 89       	ldd	r22, Y+20	; 0x14
    4a94:	7d 89       	ldd	r23, Y+21	; 0x15
    4a96:	88 81       	ld	r24, Y
    4a98:	99 81       	ldd	r25, Y+1	; 0x01
    4a9a:	0e 94 49 11 	call	0x2292	; 0x2292 <get_fat>
    4a9e:	6b 01       	movw	r12, r22
    4aa0:	7c 01       	movw	r14, r24
				res = FR_OK;
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
    4aa2:	81 e0       	ldi	r24, 0x01	; 1
    4aa4:	c8 16       	cp	r12, r24
    4aa6:	d1 04       	cpc	r13, r1
    4aa8:	e1 04       	cpc	r14, r1
    4aaa:	f1 04       	cpc	r15, r1
    4aac:	09 f4       	brne	.+2      	; 0x4ab0 <f_truncate+0x88>
    4aae:	4a c0       	rjmp	.+148    	; 0x4b44 <f_truncate+0x11c>
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
				res = remove_chain(fp->fs, fp->sclust);
				fp->sclust = 0;
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
				res = FR_OK;
    4ab0:	81 e0       	ldi	r24, 0x01	; 1
    4ab2:	9f ef       	ldi	r25, 0xFF	; 255
    4ab4:	c9 16       	cp	r12, r25
    4ab6:	9f ef       	ldi	r25, 0xFF	; 255
    4ab8:	d9 06       	cpc	r13, r25
    4aba:	9f ef       	ldi	r25, 0xFF	; 255
    4abc:	e9 06       	cpc	r14, r25
    4abe:	9f ef       	ldi	r25, 0xFF	; 255
    4ac0:	f9 06       	cpc	r15, r25
    4ac2:	09 f0       	breq	.+2      	; 0x4ac6 <f_truncate+0x9e>
    4ac4:	80 e0       	ldi	r24, 0x00	; 0
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
				if (res == FR_OK && ncl < fp->fs->n_fatent) {
    4ac6:	88 23       	and	r24, r24
    4ac8:	01 f5       	brne	.+64     	; 0x4b0a <f_truncate+0xe2>
    4aca:	e8 81       	ld	r30, Y
    4acc:	f9 81       	ldd	r31, Y+1	; 0x01
    4ace:	42 8d       	ldd	r20, Z+26	; 0x1a
    4ad0:	53 8d       	ldd	r21, Z+27	; 0x1b
    4ad2:	64 8d       	ldd	r22, Z+28	; 0x1c
    4ad4:	75 8d       	ldd	r23, Z+29	; 0x1d
    4ad6:	c4 16       	cp	r12, r20
    4ad8:	d5 06       	cpc	r13, r21
    4ada:	e6 06       	cpc	r14, r22
    4adc:	f7 06       	cpc	r15, r23
    4ade:	d0 f4       	brcc	.+52     	; 0x4b14 <f_truncate+0xec>
					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
    4ae0:	4a 89       	ldd	r20, Y+18	; 0x12
    4ae2:	5b 89       	ldd	r21, Y+19	; 0x13
    4ae4:	6c 89       	ldd	r22, Y+20	; 0x14
    4ae6:	7d 89       	ldd	r23, Y+21	; 0x15
    4ae8:	cf 01       	movw	r24, r30
    4aea:	0f ef       	ldi	r16, 0xFF	; 255
    4aec:	1f ef       	ldi	r17, 0xFF	; 255
    4aee:	2f ef       	ldi	r18, 0xFF	; 255
    4af0:	3f e0       	ldi	r19, 0x0F	; 15
    4af2:	0e 94 63 13 	call	0x26c6	; 0x26c6 <put_fat>
					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
    4af6:	88 23       	and	r24, r24
    4af8:	41 f4       	brne	.+16     	; 0x4b0a <f_truncate+0xe2>
    4afa:	88 81       	ld	r24, Y
    4afc:	99 81       	ldd	r25, Y+1	; 0x01
    4afe:	b7 01       	movw	r22, r14
    4b00:	a6 01       	movw	r20, r12
    4b02:	0e 94 93 19 	call	0x3326	; 0x3326 <remove_chain>
				}
			}
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
    4b06:	88 23       	and	r24, r24
    4b08:	29 f0       	breq	.+10     	; 0x4b14 <f_truncate+0xec>
    4b0a:	9c 81       	ldd	r25, Y+4	; 0x04
    4b0c:	90 68       	ori	r25, 0x80	; 128
    4b0e:	9c 83       	std	Y+4, r25	; 0x04
    4b10:	01 c0       	rjmp	.+2      	; 0x4b14 <f_truncate+0xec>
{
	FRESULT res;
	DWORD ncl;


	if (!fp) return FR_INVALID_OBJECT;
    4b12:	89 e0       	ldi	r24, 0x09	; 9
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
	}

	LEAVE_FF(fp->fs, res);
}
    4b14:	df 91       	pop	r29
    4b16:	cf 91       	pop	r28
    4b18:	1f 91       	pop	r17
    4b1a:	0f 91       	pop	r16
    4b1c:	ff 90       	pop	r15
    4b1e:	ef 90       	pop	r14
    4b20:	df 90       	pop	r13
    4b22:	cf 90       	pop	r12
    4b24:	08 95       	ret
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
				res = FR_DENIED;
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
    4b26:	4e 81       	ldd	r20, Y+6	; 0x06
    4b28:	5f 81       	ldd	r21, Y+7	; 0x07
    4b2a:	68 85       	ldd	r22, Y+8	; 0x08
    4b2c:	79 85       	ldd	r23, Y+9	; 0x09
    4b2e:	0a 85       	ldd	r16, Y+10	; 0x0a
    4b30:	1b 85       	ldd	r17, Y+11	; 0x0b
    4b32:	2c 85       	ldd	r18, Y+12	; 0x0c
    4b34:	3d 85       	ldd	r19, Y+13	; 0x0d
    4b36:	40 17       	cp	r20, r16
    4b38:	51 07       	cpc	r21, r17
    4b3a:	62 07       	cpc	r22, r18
    4b3c:	73 07       	cpc	r23, r19
    4b3e:	08 f4       	brcc	.+2      	; 0x4b42 <f_truncate+0x11a>
    4b40:	8d cf       	rjmp	.-230    	; 0x4a5c <f_truncate+0x34>
    4b42:	e8 cf       	rjmp	.-48     	; 0x4b14 <f_truncate+0xec>
				fp->sclust = 0;
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
				res = FR_OK;
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
    4b44:	82 e0       	ldi	r24, 0x02	; 2
    4b46:	e1 cf       	rjmp	.-62     	; 0x4b0a <f_truncate+0xe2>

00004b48 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR *path		/* Pointer to the file or directory path */
)
{
    4b48:	cf 92       	push	r12
    4b4a:	df 92       	push	r13
    4b4c:	ef 92       	push	r14
    4b4e:	ff 92       	push	r15
    4b50:	1f 93       	push	r17
    4b52:	cf 93       	push	r28
    4b54:	df 93       	push	r29
    4b56:	cd b7       	in	r28, 0x3d	; 61
    4b58:	de b7       	in	r29, 0x3e	; 62
    4b5a:	ea 97       	sbiw	r28, 0x3a	; 58
    4b5c:	0f b6       	in	r0, 0x3f	; 63
    4b5e:	f8 94       	cli
    4b60:	de bf       	out	0x3e, r29	; 62
    4b62:	0f be       	out	0x3f, r0	; 63
    4b64:	cd bf       	out	0x3d, r28	; 61
    4b66:	9a af       	sts	0x7a, r25
    4b68:	89 af       	sts	0x79, r24
	BYTE *dir;
	DWORD dclst;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4b6a:	ce 01       	movw	r24, r28
    4b6c:	c9 96       	adiw	r24, 0x39	; 57
    4b6e:	be 01       	movw	r22, r28
    4b70:	6f 5f       	subi	r22, 0xFF	; 255
    4b72:	7f 4f       	sbci	r23, 0xFF	; 255
    4b74:	41 e0       	ldi	r20, 0x01	; 1
    4b76:	0e 94 ac 0b 	call	0x1758	; 0x1758 <chk_mounted>
	if (res == FR_OK) {
    4b7a:	88 23       	and	r24, r24
    4b7c:	09 f0       	breq	.+2      	; 0x4b80 <f_unlink+0x38>
    4b7e:	63 c0       	rjmp	.+198    	; 0x4c46 <f_unlink+0xfe>
		INIT_BUF(dj);
    4b80:	ce 01       	movw	r24, r28
    4b82:	8d 96       	adiw	r24, 0x2d	; 45
    4b84:	9e 8b       	std	Y+22, r25	; 0x16
    4b86:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the file path */
    4b88:	69 ad       	sts	0x69, r22
    4b8a:	7a ad       	sts	0x6a, r23
    4b8c:	ce 01       	movw	r24, r28
    4b8e:	01 96       	adiw	r24, 0x01	; 1
    4b90:	0e 94 db 16 	call	0x2db6	; 0x2db6 <follow_path>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    4b94:	88 23       	and	r24, r24
    4b96:	09 f0       	breq	.+2      	; 0x4b9a <f_unlink+0x52>
    4b98:	56 c0       	rjmp	.+172    	; 0x4c46 <f_unlink+0xfe>
    4b9a:	ed 89       	ldd	r30, Y+21	; 0x15
    4b9c:	fe 89       	ldd	r31, Y+22	; 0x16
    4b9e:	83 85       	ldd	r24, Z+11	; 0x0b
    4ba0:	85 ff       	sbrs	r24, 5
    4ba2:	5f c0       	rjmp	.+190    	; 0x4c62 <f_unlink+0x11a>
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
    4ba4:	86 e0       	ldi	r24, 0x06	; 6
    4ba6:	4f c0       	rjmp	.+158    	; 0x4c46 <f_unlink+0xfe>
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
    4ba8:	fb 01       	movw	r30, r22
    4baa:	13 85       	ldd	r17, Z+11	; 0x0b
    4bac:	10 ff       	sbrs	r17, 0
    4bae:	60 c0       	rjmp	.+192    	; 0x4c70 <f_unlink+0x128>
					res = FR_DENIED;		/* Cannot remove R/O object */
    4bb0:	87 e0       	ldi	r24, 0x07	; 7
    4bb2:	49 c0       	rjmp	.+146    	; 0x4c46 <f_unlink+0xfe>
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
    4bb4:	86 e0       	ldi	r24, 0x06	; 6
    4bb6:	47 c0       	rjmp	.+142    	; 0x4c46 <f_unlink+0xfe>
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = ld_clust(dj.fs, dir);
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
				if (dclst < 2) {
    4bb8:	f2 e0       	ldi	r31, 0x02	; 2
    4bba:	cf 16       	cp	r12, r31
    4bbc:	d1 04       	cpc	r13, r1
    4bbe:	e1 04       	cpc	r14, r1
    4bc0:	f1 04       	cpc	r15, r1
    4bc2:	08 f4       	brcc	.+2      	; 0x4bc6 <f_unlink+0x7e>
    4bc4:	5e c0       	rjmp	.+188    	; 0x4c82 <f_unlink+0x13a>
					res = FR_INT_ERR;
				} else {
					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
    4bc6:	ce 01       	movw	r24, r28
    4bc8:	47 96       	adiw	r24, 0x17	; 23
    4bca:	be 01       	movw	r22, r28
    4bcc:	6f 5f       	subi	r22, 0xFF	; 255
    4bce:	7f 4f       	sbci	r23, 0xFF	; 255
    4bd0:	26 e1       	ldi	r18, 0x16	; 22
    4bd2:	30 e0       	ldi	r19, 0x00	; 0
    4bd4:	40 e0       	ldi	r20, 0x00	; 0
    4bd6:	50 e0       	ldi	r21, 0x00	; 0
    4bd8:	0e 94 09 0a 	call	0x1412	; 0x1412 <mem_cpy>
					sdj.sclust = dclst;
    4bdc:	cd 8e       	std	Y+29, r12	; 0x1d
    4bde:	de 8e       	std	Y+30, r13	; 0x1e
    4be0:	ef 8e       	std	Y+31, r14	; 0x1f
    4be2:	f8 a2       	lds	r31, 0x98
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
    4be4:	ce 01       	movw	r24, r28
    4be6:	47 96       	adiw	r24, 0x17	; 23
    4be8:	62 e0       	ldi	r22, 0x02	; 2
    4bea:	70 e0       	ldi	r23, 0x00	; 0
    4bec:	0e 94 80 12 	call	0x2500	; 0x2500 <dir_sdi>
					if (res == FR_OK) {
    4bf0:	88 23       	and	r24, r24
    4bf2:	49 f5       	brne	.+82     	; 0x4c46 <f_unlink+0xfe>
						res = dir_read(&sdj);
    4bf4:	ce 01       	movw	r24, r28
    4bf6:	47 96       	adiw	r24, 0x17	; 23
    4bf8:	0e 94 63 19 	call	0x32c6	; 0x32c6 <dir_read>
						if (res == FR_OK		/* Not empty dir */
    4bfc:	88 23       	and	r24, r24
    4bfe:	71 f0       	breq	.+28     	; 0x4c1c <f_unlink+0xd4>
#if _FS_RPATH
						|| dclst == dj.fs->cdir	/* Current dir */
    4c00:	e9 81       	ldd	r30, Y+1	; 0x01
    4c02:	fa 81       	ldd	r31, Y+2	; 0x02
    4c04:	46 89       	ldd	r20, Z+22	; 0x16
    4c06:	57 89       	ldd	r21, Z+23	; 0x17
    4c08:	60 8d       	ldd	r22, Z+24	; 0x18
    4c0a:	71 8d       	ldd	r23, Z+25	; 0x19
    4c0c:	4c 15       	cp	r20, r12
    4c0e:	5d 05       	cpc	r21, r13
    4c10:	6e 05       	cpc	r22, r14
    4c12:	7f 05       	cpc	r23, r15
    4c14:	29 f0       	breq	.+10     	; 0x4c20 <f_unlink+0xd8>
#endif
						) res = FR_DENIED;
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
    4c16:	84 30       	cpi	r24, 0x04	; 4
    4c18:	b1 f1       	breq	.+108    	; 0x4c86 <f_unlink+0x13e>
    4c1a:	15 c0       	rjmp	.+42     	; 0x4c46 <f_unlink+0xfe>
					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
					sdj.sclust = dclst;
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
					if (res == FR_OK) {
						res = dir_read(&sdj);
						if (res == FR_OK		/* Not empty dir */
    4c1c:	87 e0       	ldi	r24, 0x07	; 7
    4c1e:	13 c0       	rjmp	.+38     	; 0x4c46 <f_unlink+0xfe>
#if _FS_RPATH
						|| dclst == dj.fs->cdir	/* Current dir */
    4c20:	87 e0       	ldi	r24, 0x07	; 7
    4c22:	11 c0       	rjmp	.+34     	; 0x4c46 <f_unlink+0xfe>
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
				if (res == FR_OK) {
					if (dclst)				/* Remove the cluster chain if exist */
    4c24:	c1 14       	cp	r12, r1
    4c26:	d1 04       	cpc	r13, r1
    4c28:	e1 04       	cpc	r14, r1
    4c2a:	f1 04       	cpc	r15, r1
    4c2c:	41 f0       	breq	.+16     	; 0x4c3e <f_unlink+0xf6>
						res = remove_chain(dj.fs, dclst);
    4c2e:	89 81       	ldd	r24, Y+1	; 0x01
    4c30:	9a 81       	ldd	r25, Y+2	; 0x02
    4c32:	b7 01       	movw	r22, r14
    4c34:	a6 01       	movw	r20, r12
    4c36:	0e 94 93 19 	call	0x3326	; 0x3326 <remove_chain>
					if (res == FR_OK) res = sync(dj.fs);
    4c3a:	88 23       	and	r24, r24
    4c3c:	21 f4       	brne	.+8      	; 0x4c46 <f_unlink+0xfe>
    4c3e:	89 81       	ldd	r24, Y+1	; 0x01
    4c40:	9a 81       	ldd	r25, Y+2	; 0x02
    4c42:	0e 94 81 10 	call	0x2102	; 0x2102 <sync>
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(dj.fs, res);
}
    4c46:	ea 96       	adiw	r28, 0x3a	; 58
    4c48:	0f b6       	in	r0, 0x3f	; 63
    4c4a:	f8 94       	cli
    4c4c:	de bf       	out	0x3e, r29	; 62
    4c4e:	0f be       	out	0x3f, r0	; 63
    4c50:	cd bf       	out	0x3d, r28	; 61
    4c52:	df 91       	pop	r29
    4c54:	cf 91       	pop	r28
    4c56:	1f 91       	pop	r17
    4c58:	ff 90       	pop	r15
    4c5a:	ef 90       	pop	r14
    4c5c:	df 90       	pop	r13
    4c5e:	cf 90       	pop	r12
    4c60:	08 95       	ret
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
    4c62:	6b 89       	ldd	r22, Y+19	; 0x13
    4c64:	7c 89       	ldd	r23, Y+20	; 0x14
			if (!dir) {
    4c66:	61 15       	cp	r22, r1
    4c68:	71 05       	cpc	r23, r1
    4c6a:	09 f0       	breq	.+2      	; 0x4c6e <f_unlink+0x126>
    4c6c:	9d cf       	rjmp	.-198    	; 0x4ba8 <f_unlink+0x60>
    4c6e:	a2 cf       	rjmp	.-188    	; 0x4bb4 <f_unlink+0x6c>
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = ld_clust(dj.fs, dir);
    4c70:	89 81       	ldd	r24, Y+1	; 0x01
    4c72:	9a 81       	ldd	r25, Y+2	; 0x02
    4c74:	0e 94 2f 0a 	call	0x145e	; 0x145e <ld_clust>
    4c78:	6b 01       	movw	r12, r22
    4c7a:	7c 01       	movw	r14, r24
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
    4c7c:	14 fd       	sbrc	r17, 4
    4c7e:	9c cf       	rjmp	.-200    	; 0x4bb8 <f_unlink+0x70>
    4c80:	02 c0       	rjmp	.+4      	; 0x4c86 <f_unlink+0x13e>
				if (dclst < 2) {
					res = FR_INT_ERR;
    4c82:	82 e0       	ldi	r24, 0x02	; 2
    4c84:	e0 cf       	rjmp	.-64     	; 0x4c46 <f_unlink+0xfe>
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
    4c86:	ce 01       	movw	r24, r28
    4c88:	01 96       	adiw	r24, 0x01	; 1
    4c8a:	0e 94 45 13 	call	0x268a	; 0x268a <dir_remove>
				if (res == FR_OK) {
    4c8e:	88 23       	and	r24, r24
    4c90:	49 f2       	breq	.-110    	; 0x4c24 <f_unlink+0xdc>
    4c92:	d9 cf       	rjmp	.-78     	; 0x4c46 <f_unlink+0xfe>

00004c94 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR *path		/* Pointer to the directory path */
)
{
    4c94:	2f 92       	push	r2
    4c96:	3f 92       	push	r3
    4c98:	4f 92       	push	r4
    4c9a:	5f 92       	push	r5
    4c9c:	6f 92       	push	r6
    4c9e:	7f 92       	push	r7
    4ca0:	8f 92       	push	r8
    4ca2:	9f 92       	push	r9
    4ca4:	af 92       	push	r10
    4ca6:	bf 92       	push	r11
    4ca8:	cf 92       	push	r12
    4caa:	df 92       	push	r13
    4cac:	ef 92       	push	r14
    4cae:	ff 92       	push	r15
    4cb0:	0f 93       	push	r16
    4cb2:	1f 93       	push	r17
    4cb4:	cf 93       	push	r28
    4cb6:	df 93       	push	r29
    4cb8:	cd b7       	in	r28, 0x3d	; 61
    4cba:	de b7       	in	r29, 0x3e	; 62
    4cbc:	a8 97       	sbiw	r28, 0x28	; 40
    4cbe:	0f b6       	in	r0, 0x3f	; 63
    4cc0:	f8 94       	cli
    4cc2:	de bf       	out	0x3e, r29	; 62
    4cc4:	0f be       	out	0x3f, r0	; 63
    4cc6:	cd bf       	out	0x3d, r28	; 61
    4cc8:	9c a3       	lds	r25, 0x5c
    4cca:	8b a3       	lds	r24, 0x5b
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tim = get_fattime();
    4ccc:	0e 94 0f 11 	call	0x221e	; 0x221e <get_fattime>
    4cd0:	6b 01       	movw	r12, r22
    4cd2:	7c 01       	movw	r14, r24
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4cd4:	ce 01       	movw	r24, r28
    4cd6:	83 96       	adiw	r24, 0x23	; 35
    4cd8:	be 01       	movw	r22, r28
    4cda:	6f 5f       	subi	r22, 0xFF	; 255
    4cdc:	7f 4f       	sbci	r23, 0xFF	; 255
    4cde:	41 e0       	ldi	r20, 0x01	; 1
    4ce0:	0e 94 ac 0b 	call	0x1758	; 0x1758 <chk_mounted>
    4ce4:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    4ce6:	88 23       	and	r24, r24
    4ce8:	09 f0       	breq	.+2      	; 0x4cec <f_mkdir+0x58>
    4cea:	f6 c0       	rjmp	.+492    	; 0x4ed8 <f_mkdir+0x244>
		INIT_BUF(dj);
    4cec:	ce 01       	movw	r24, r28
    4cee:	47 96       	adiw	r24, 0x17	; 23
    4cf0:	9e 8b       	std	Y+22, r25	; 0x16
    4cf2:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);			/* Follow the file path */
    4cf4:	6b a1       	lds	r22, 0x4b
    4cf6:	7c a1       	lds	r23, 0x4c
    4cf8:	ce 01       	movw	r24, r28
    4cfa:	01 96       	adiw	r24, 0x01	; 1
    4cfc:	0e 94 db 16 	call	0x2db6	; 0x2db6 <follow_path>
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
    4d00:	88 23       	and	r24, r24
    4d02:	49 f0       	breq	.+18     	; 0x4d16 <f_mkdir+0x82>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
    4d04:	84 30       	cpi	r24, 0x04	; 4
    4d06:	41 f4       	brne	.+16     	; 0x4d18 <f_mkdir+0x84>
    4d08:	ed 89       	ldd	r30, Y+21	; 0x15
    4d0a:	fe 89       	ldd	r31, Y+22	; 0x16
    4d0c:	83 85       	ldd	r24, Z+11	; 0x0b
    4d0e:	85 ff       	sbrs	r24, 5
    4d10:	fd c0       	rjmp	.+506    	; 0x4f0c <f_mkdir+0x278>
			res = FR_INVALID_NAME;
    4d12:	86 e0       	ldi	r24, 0x06	; 6
    4d14:	01 c0       	rjmp	.+2      	; 0x4d18 <f_mkdir+0x84>

	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
    4d16:	88 e0       	ldi	r24, 0x08	; 8
				ST_DWORD(dir+DIR_WrtTime, tim);
				st_clust(dir, dcl);
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
    4d18:	18 2f       	mov	r17, r24
    4d1a:	de c0       	rjmp	.+444    	; 0x4ed8 <f_mkdir+0x244>
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
			if (dcl == 1) res = FR_INT_ERR;
    4d1c:	81 e0       	ldi	r24, 0x01	; 1
    4d1e:	48 16       	cp	r4, r24
    4d20:	51 04       	cpc	r5, r1
    4d22:	61 04       	cpc	r6, r1
    4d24:	71 04       	cpc	r7, r1
    4d26:	09 f4       	brne	.+2      	; 0x4d2a <f_mkdir+0x96>
    4d28:	01 c1       	rjmp	.+514    	; 0x4f2c <f_mkdir+0x298>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
    4d2a:	ef ef       	ldi	r30, 0xFF	; 255
    4d2c:	4e 16       	cp	r4, r30
    4d2e:	ef ef       	ldi	r30, 0xFF	; 255
    4d30:	5e 06       	cpc	r5, r30
    4d32:	ef ef       	ldi	r30, 0xFF	; 255
    4d34:	6e 06       	cpc	r6, r30
    4d36:	ef ef       	ldi	r30, 0xFF	; 255
    4d38:	7e 06       	cpc	r7, r30
    4d3a:	09 f4       	brne	.+2      	; 0x4d3e <f_mkdir+0xaa>
    4d3c:	f9 c0       	rjmp	.+498    	; 0x4f30 <f_mkdir+0x29c>
    4d3e:	01 c0       	rjmp	.+2      	; 0x4d42 <f_mkdir+0xae>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
    4d40:	17 e0       	ldi	r17, 0x07	; 7
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
			if (res == FR_OK)					/* Flush FAT */
    4d42:	11 23       	and	r17, r17
    4d44:	09 f0       	breq	.+2      	; 0x4d48 <f_mkdir+0xb4>
    4d46:	a8 c0       	rjmp	.+336    	; 0x4e98 <f_mkdir+0x204>
				res = move_window(dj.fs, 0);
    4d48:	89 81       	ldd	r24, Y+1	; 0x01
    4d4a:	9a 81       	ldd	r25, Y+2	; 0x02
    4d4c:	40 e0       	ldi	r20, 0x00	; 0
    4d4e:	50 e0       	ldi	r21, 0x00	; 0
    4d50:	ba 01       	movw	r22, r20
    4d52:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
    4d56:	18 2f       	mov	r17, r24
			if (res == FR_OK) {					/* Initialize the new directory table */
    4d58:	88 23       	and	r24, r24
    4d5a:	09 f0       	breq	.+2      	; 0x4d5e <f_mkdir+0xca>
    4d5c:	9d c0       	rjmp	.+314    	; 0x4e98 <f_mkdir+0x204>
				dsc = clust2sect(dj.fs, dcl);
    4d5e:	09 81       	ldd	r16, Y+1	; 0x01
    4d60:	1a 81       	ldd	r17, Y+2	; 0x02
    4d62:	c8 01       	movw	r24, r16
    4d64:	b3 01       	movw	r22, r6
    4d66:	a2 01       	movw	r20, r4
    4d68:	0e 94 13 11 	call	0x2226	; 0x2226 <clust2sect>
    4d6c:	4b 01       	movw	r8, r22
    4d6e:	5c 01       	movw	r10, r24
				dir = dj.fs->win;
    4d70:	0f 2e       	mov	r0, r31
    4d72:	f2 e3       	ldi	r31, 0x32	; 50
    4d74:	2f 2e       	mov	r2, r31
    4d76:	33 24       	eor	r3, r3
    4d78:	f0 2d       	mov	r31, r0
    4d7a:	20 0e       	add	r2, r16
    4d7c:	31 1e       	adc	r3, r17
				mem_set(dir, 0, SS(dj.fs));
    4d7e:	c1 01       	movw	r24, r2
    4d80:	60 e0       	ldi	r22, 0x00	; 0
    4d82:	70 e0       	ldi	r23, 0x00	; 0
    4d84:	20 e0       	ldi	r18, 0x00	; 0
    4d86:	32 e0       	ldi	r19, 0x02	; 2
    4d88:	40 e0       	ldi	r20, 0x00	; 0
    4d8a:	50 e0       	ldi	r21, 0x00	; 0
    4d8c:	0e 94 1e 0a 	call	0x143c	; 0x143c <mem_set>
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
    4d90:	c1 01       	movw	r24, r2
    4d92:	60 e2       	ldi	r22, 0x20	; 32
    4d94:	70 e0       	ldi	r23, 0x00	; 0
    4d96:	2b e0       	ldi	r18, 0x0B	; 11
    4d98:	30 e0       	ldi	r19, 0x00	; 0
    4d9a:	40 e0       	ldi	r20, 0x00	; 0
    4d9c:	50 e0       	ldi	r21, 0x00	; 0
    4d9e:	0e 94 1e 0a 	call	0x143c	; 0x143c <mem_set>
				dir[DIR_Name] = '.';
    4da2:	8e e2       	ldi	r24, 0x2E	; 46
    4da4:	f8 01       	movw	r30, r16
    4da6:	82 ab       	sts	0x52, r24
				dir[DIR_Attr] = AM_DIR;
    4da8:	80 e1       	ldi	r24, 0x10	; 16
    4daa:	85 af       	sts	0x75, r24
				ST_DWORD(dir+DIR_WrtTime, tim);
    4dac:	cd a2       	lds	r28, 0x9d
    4dae:	e8 5b       	subi	r30, 0xB8	; 184
    4db0:	ff 4f       	sbci	r31, 0xFF	; 255
    4db2:	c0 82       	st	Z, r12
    4db4:	8d 2d       	mov	r24, r13
    4db6:	99 27       	eor	r25, r25
    4db8:	8e a3       	lds	r24, 0x5e
    4dba:	f8 01       	movw	r30, r16
    4dbc:	e7 5b       	subi	r30, 0xB7	; 183
    4dbe:	ff 4f       	sbci	r31, 0xFF	; 255
    4dc0:	80 83       	st	Z, r24
    4dc2:	c7 01       	movw	r24, r14
    4dc4:	aa 27       	eor	r26, r26
    4dc6:	bb 27       	eor	r27, r27
    4dc8:	8f a3       	lds	r24, 0x5f
    4dca:	f8 01       	movw	r30, r16
    4dcc:	e6 5b       	subi	r30, 0xB6	; 182
    4dce:	ff 4f       	sbci	r31, 0xFF	; 255
    4dd0:	80 83       	st	Z, r24
    4dd2:	cf 2c       	mov	r12, r15
    4dd4:	dd 24       	eor	r13, r13
    4dd6:	ee 24       	eor	r14, r14
    4dd8:	ff 24       	eor	r15, r15
    4dda:	c8 a6       	lds	r28, 0xb8
    4ddc:	f8 01       	movw	r30, r16
    4dde:	e5 5b       	subi	r30, 0xB5	; 181
    4de0:	ff 4f       	sbci	r31, 0xFF	; 255
    4de2:	c0 82       	st	Z, r12
				st_clust(dir, dcl);
    4de4:	c1 01       	movw	r24, r2
    4de6:	b3 01       	movw	r22, r6
    4de8:	a2 01       	movw	r20, r4
    4dea:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <st_clust>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
    4dee:	0f 2e       	mov	r0, r31
    4df0:	f2 e5       	ldi	r31, 0x52	; 82
    4df2:	cf 2e       	mov	r12, r31
    4df4:	dd 24       	eor	r13, r13
    4df6:	f0 2d       	mov	r31, r0
    4df8:	c0 0e       	add	r12, r16
    4dfa:	d1 1e       	adc	r13, r17
    4dfc:	c6 01       	movw	r24, r12
    4dfe:	b1 01       	movw	r22, r2
    4e00:	20 e2       	ldi	r18, 0x20	; 32
    4e02:	30 e0       	ldi	r19, 0x00	; 0
    4e04:	40 e0       	ldi	r20, 0x00	; 0
    4e06:	50 e0       	ldi	r21, 0x00	; 0
    4e08:	0e 94 09 0a 	call	0x1412	; 0x1412 <mem_cpy>
				dir[33] = '.'; pcl = dj.sclust;
    4e0c:	f8 01       	movw	r30, r16
    4e0e:	ed 5a       	subi	r30, 0xAD	; 173
    4e10:	ff 4f       	sbci	r31, 0xFF	; 255
    4e12:	8e e2       	ldi	r24, 0x2E	; 46
    4e14:	80 83       	st	Z, r24
    4e16:	4f 81       	ldd	r20, Y+7	; 0x07
    4e18:	58 85       	ldd	r21, Y+8	; 0x08
    4e1a:	69 85       	ldd	r22, Y+9	; 0x09
    4e1c:	7a 85       	ldd	r23, Y+10	; 0x0a
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
    4e1e:	e9 81       	ldd	r30, Y+1	; 0x01
    4e20:	fa 81       	ldd	r31, Y+2	; 0x02
    4e22:	80 81       	ld	r24, Z
    4e24:	83 30       	cpi	r24, 0x03	; 3
    4e26:	61 f4       	brne	.+24     	; 0x4e40 <f_mkdir+0x1ac>
    4e28:	86 a1       	lds	r24, 0x46
    4e2a:	97 a1       	lds	r25, 0x47
    4e2c:	a0 a5       	lds	r26, 0x60
    4e2e:	b1 a5       	lds	r27, 0x61
    4e30:	84 17       	cp	r24, r20
    4e32:	95 07       	cpc	r25, r21
    4e34:	a6 07       	cpc	r26, r22
    4e36:	b7 07       	cpc	r27, r23
    4e38:	19 f4       	brne	.+6      	; 0x4e40 <f_mkdir+0x1ac>
					pcl = 0;
    4e3a:	40 e0       	ldi	r20, 0x00	; 0
    4e3c:	50 e0       	ldi	r21, 0x00	; 0
    4e3e:	ba 01       	movw	r22, r20
				st_clust(dir+SZ_DIR, pcl);
    4e40:	c6 01       	movw	r24, r12
    4e42:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <st_clust>
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
    4e46:	e9 81       	ldd	r30, Y+1	; 0x01
    4e48:	fa 81       	ldd	r31, Y+2	; 0x02
    4e4a:	02 81       	ldd	r16, Z+2	; 0x02
    4e4c:	00 23       	and	r16, r16
    4e4e:	09 f4       	brne	.+2      	; 0x4e52 <f_mkdir+0x1be>
    4e50:	71 c0       	rjmp	.+226    	; 0x4f34 <f_mkdir+0x2a0>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
    4e52:	cc 24       	eor	r12, r12
    4e54:	c3 94       	inc	r12
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
    4e56:	89 81       	ldd	r24, Y+1	; 0x01
    4e58:	9a 81       	ldd	r25, Y+2	; 0x02
    4e5a:	fc 01       	movw	r30, r24
    4e5c:	86 a6       	lds	r24, 0xb6
    4e5e:	97 a6       	lds	r25, 0xb7
    4e60:	a0 aa       	sts	0x90, r26
    4e62:	b1 aa       	sts	0x91, r27
    4e64:	08 94       	sec
    4e66:	81 1c       	adc	r8, r1
    4e68:	91 1c       	adc	r9, r1
    4e6a:	a1 1c       	adc	r10, r1
    4e6c:	b1 1c       	adc	r11, r1
					dj.fs->wflag = 1;
    4e6e:	c4 82       	std	Z+4, r12	; 0x04
					res = move_window(dj.fs, 0);
    4e70:	40 e0       	ldi	r20, 0x00	; 0
    4e72:	50 e0       	ldi	r21, 0x00	; 0
    4e74:	ba 01       	movw	r22, r20
    4e76:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
    4e7a:	18 2f       	mov	r17, r24
					if (res != FR_OK) break;
    4e7c:	88 23       	and	r24, r24
    4e7e:	61 f4       	brne	.+24     	; 0x4e98 <f_mkdir+0x204>
					mem_set(dir, 0, SS(dj.fs));
    4e80:	c1 01       	movw	r24, r2
    4e82:	60 e0       	ldi	r22, 0x00	; 0
    4e84:	70 e0       	ldi	r23, 0x00	; 0
    4e86:	20 e0       	ldi	r18, 0x00	; 0
    4e88:	32 e0       	ldi	r19, 0x02	; 2
    4e8a:	40 e0       	ldi	r20, 0x00	; 0
    4e8c:	50 e0       	ldi	r21, 0x00	; 0
    4e8e:	0e 94 1e 0a 	call	0x143c	; 0x143c <mem_set>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
    4e92:	01 50       	subi	r16, 0x01	; 1
    4e94:	01 f7       	brne	.-64     	; 0x4e56 <f_mkdir+0x1c2>
    4e96:	4e c0       	rjmp	.+156    	; 0x4f34 <f_mkdir+0x2a0>
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
    4e98:	89 81       	ldd	r24, Y+1	; 0x01
    4e9a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e9c:	b3 01       	movw	r22, r6
    4e9e:	a2 01       	movw	r20, r4
    4ea0:	0e 94 93 19 	call	0x3326	; 0x3326 <remove_chain>
    4ea4:	19 c0       	rjmp	.+50     	; 0x4ed8 <f_mkdir+0x244>
			} else {
				dir = dj.dir;
    4ea6:	eb 89       	ldd	r30, Y+19	; 0x13
    4ea8:	fc 89       	ldd	r31, Y+20	; 0x14
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
    4eaa:	80 e1       	ldi	r24, 0x10	; 16
    4eac:	83 87       	std	Z+11, r24	; 0x0b
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
    4eae:	8d a1       	lds	r24, 0x4d
    4eb0:	86 8b       	std	Z+22, r24	; 0x16
    4eb2:	8e a1       	lds	r24, 0x4e
    4eb4:	87 8b       	std	Z+23, r24	; 0x17
    4eb6:	8f a1       	lds	r24, 0x4f
    4eb8:	80 8f       	std	Z+24, r24	; 0x18
    4eba:	88 a5       	lds	r24, 0x68
    4ebc:	81 8f       	std	Z+25, r24	; 0x19
				st_clust(dir, dcl);					/* Table start cluster */
    4ebe:	cf 01       	movw	r24, r30
    4ec0:	b3 01       	movw	r22, r6
    4ec2:	a2 01       	movw	r20, r4
    4ec4:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <st_clust>
				dj.fs->wflag = 1;
    4ec8:	89 81       	ldd	r24, Y+1	; 0x01
    4eca:	9a 81       	ldd	r25, Y+2	; 0x02
    4ecc:	21 e0       	ldi	r18, 0x01	; 1
    4ece:	fc 01       	movw	r30, r24
    4ed0:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    4ed2:	0e 94 81 10 	call	0x2102	; 0x2102 <sync>
    4ed6:	18 2f       	mov	r17, r24
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    4ed8:	81 2f       	mov	r24, r17
    4eda:	a8 96       	adiw	r28, 0x28	; 40
    4edc:	0f b6       	in	r0, 0x3f	; 63
    4ede:	f8 94       	cli
    4ee0:	de bf       	out	0x3e, r29	; 62
    4ee2:	0f be       	out	0x3f, r0	; 63
    4ee4:	cd bf       	out	0x3d, r28	; 61
    4ee6:	df 91       	pop	r29
    4ee8:	cf 91       	pop	r28
    4eea:	1f 91       	pop	r17
    4eec:	0f 91       	pop	r16
    4eee:	ff 90       	pop	r15
    4ef0:	ef 90       	pop	r14
    4ef2:	df 90       	pop	r13
    4ef4:	cf 90       	pop	r12
    4ef6:	bf 90       	pop	r11
    4ef8:	af 90       	pop	r10
    4efa:	9f 90       	pop	r9
    4efc:	8f 90       	pop	r8
    4efe:	7f 90       	pop	r7
    4f00:	6f 90       	pop	r6
    4f02:	5f 90       	pop	r5
    4f04:	4f 90       	pop	r4
    4f06:	3f 90       	pop	r3
    4f08:	2f 90       	pop	r2
    4f0a:	08 95       	ret
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
    4f0c:	89 81       	ldd	r24, Y+1	; 0x01
    4f0e:	9a 81       	ldd	r25, Y+2	; 0x02
    4f10:	40 e0       	ldi	r20, 0x00	; 0
    4f12:	50 e0       	ldi	r21, 0x00	; 0
    4f14:	ba 01       	movw	r22, r20
    4f16:	0e 94 72 14 	call	0x28e4	; 0x28e4 <create_chain>
    4f1a:	2b 01       	movw	r4, r22
    4f1c:	3c 01       	movw	r6, r24
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
    4f1e:	61 15       	cp	r22, r1
    4f20:	71 05       	cpc	r23, r1
    4f22:	81 05       	cpc	r24, r1
    4f24:	91 05       	cpc	r25, r1
    4f26:	09 f4       	brne	.+2      	; 0x4f2a <f_mkdir+0x296>
    4f28:	0b cf       	rjmp	.-490    	; 0x4d40 <f_mkdir+0xac>
    4f2a:	f8 ce       	rjmp	.-528    	; 0x4d1c <f_mkdir+0x88>
			if (dcl == 1) res = FR_INT_ERR;
    4f2c:	12 e0       	ldi	r17, 0x02	; 2
    4f2e:	b4 cf       	rjmp	.-152    	; 0x4e98 <f_mkdir+0x204>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
    4f30:	11 e0       	ldi	r17, 0x01	; 1
    4f32:	b2 cf       	rjmp	.-156    	; 0x4e98 <f_mkdir+0x204>
					res = move_window(dj.fs, 0);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
    4f34:	ce 01       	movw	r24, r28
    4f36:	01 96       	adiw	r24, 0x01	; 1
    4f38:	0e 94 02 19 	call	0x3204	; 0x3204 <dir_register>
    4f3c:	18 2f       	mov	r17, r24
			if (res != FR_OK) {
    4f3e:	88 23       	and	r24, r24
    4f40:	09 f4       	brne	.+2      	; 0x4f44 <f_mkdir+0x2b0>
    4f42:	b1 cf       	rjmp	.-158    	; 0x4ea6 <f_mkdir+0x212>
    4f44:	a9 cf       	rjmp	.-174    	; 0x4e98 <f_mkdir+0x204>

00004f46 <f_chmod>:
FRESULT f_chmod (
	const TCHAR *path,	/* Pointer to the file path */
	BYTE value,			/* Attribute bits */
	BYTE mask			/* Attribute mask to change */
)
{
    4f46:	0f 93       	push	r16
    4f48:	1f 93       	push	r17
    4f4a:	cf 93       	push	r28
    4f4c:	df 93       	push	r29
    4f4e:	cd b7       	in	r28, 0x3d	; 61
    4f50:	de b7       	in	r29, 0x3e	; 62
    4f52:	a4 97       	sbiw	r28, 0x24	; 36
    4f54:	0f b6       	in	r0, 0x3f	; 63
    4f56:	f8 94       	cli
    4f58:	de bf       	out	0x3e, r29	; 62
    4f5a:	0f be       	out	0x3f, r0	; 63
    4f5c:	cd bf       	out	0x3d, r28	; 61
    4f5e:	9c a3       	lds	r25, 0x5c
    4f60:	8b a3       	lds	r24, 0x5b
    4f62:	06 2f       	mov	r16, r22
    4f64:	14 2f       	mov	r17, r20
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4f66:	ce 01       	movw	r24, r28
    4f68:	83 96       	adiw	r24, 0x23	; 35
    4f6a:	be 01       	movw	r22, r28
    4f6c:	6f 5f       	subi	r22, 0xFF	; 255
    4f6e:	7f 4f       	sbci	r23, 0xFF	; 255
    4f70:	41 e0       	ldi	r20, 0x01	; 1
    4f72:	0e 94 ac 0b 	call	0x1758	; 0x1758 <chk_mounted>
	if (res == FR_OK) {
    4f76:	88 23       	and	r24, r24
    4f78:	29 f5       	brne	.+74     	; 0x4fc4 <f_chmod+0x7e>
		INIT_BUF(dj);
    4f7a:	ce 01       	movw	r24, r28
    4f7c:	47 96       	adiw	r24, 0x17	; 23
    4f7e:	9e 8b       	std	Y+22, r25	; 0x16
    4f80:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the file path */
    4f82:	6b a1       	lds	r22, 0x4b
    4f84:	7c a1       	lds	r23, 0x4c
    4f86:	ce 01       	movw	r24, r28
    4f88:	01 96       	adiw	r24, 0x01	; 1
    4f8a:	0e 94 db 16 	call	0x2db6	; 0x2db6 <follow_path>
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    4f8e:	88 23       	and	r24, r24
    4f90:	c9 f4       	brne	.+50     	; 0x4fc4 <f_chmod+0x7e>
    4f92:	ed 89       	ldd	r30, Y+21	; 0x15
    4f94:	fe 89       	ldd	r31, Y+22	; 0x16
    4f96:	83 85       	ldd	r24, Z+11	; 0x0b
    4f98:	85 ff       	sbrs	r24, 5
    4f9a:	1f c0       	rjmp	.+62     	; 0x4fda <f_chmod+0x94>
			res = FR_INVALID_NAME;
    4f9c:	86 e0       	ldi	r24, 0x06	; 6
    4f9e:	12 c0       	rjmp	.+36     	; 0x4fc4 <f_chmod+0x7e>
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
			} else {						/* File or sub directory */
				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
    4fa0:	17 72       	andi	r17, 0x27	; 39
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
    4fa2:	91 2f       	mov	r25, r17
    4fa4:	90 95       	com	r25
    4fa6:	83 85       	ldd	r24, Z+11	; 0x0b
    4fa8:	89 23       	and	r24, r25
    4faa:	01 23       	and	r16, r17
    4fac:	18 2f       	mov	r17, r24
    4fae:	10 2b       	or	r17, r16
    4fb0:	13 87       	std	Z+11, r17	; 0x0b
				dj.fs->wflag = 1;
    4fb2:	89 81       	ldd	r24, Y+1	; 0x01
    4fb4:	9a 81       	ldd	r25, Y+2	; 0x02
    4fb6:	21 e0       	ldi	r18, 0x01	; 1
    4fb8:	fc 01       	movw	r30, r24
    4fba:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    4fbc:	0e 94 81 10 	call	0x2102	; 0x2102 <sync>
    4fc0:	01 c0       	rjmp	.+2      	; 0x4fc4 <f_chmod+0x7e>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
    4fc2:	86 e0       	ldi	r24, 0x06	; 6
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
    4fc4:	a4 96       	adiw	r28, 0x24	; 36
    4fc6:	0f b6       	in	r0, 0x3f	; 63
    4fc8:	f8 94       	cli
    4fca:	de bf       	out	0x3e, r29	; 62
    4fcc:	0f be       	out	0x3f, r0	; 63
    4fce:	cd bf       	out	0x3d, r28	; 61
    4fd0:	df 91       	pop	r29
    4fd2:	cf 91       	pop	r28
    4fd4:	1f 91       	pop	r17
    4fd6:	0f 91       	pop	r16
    4fd8:	08 95       	ret
		res = follow_path(&dj, path);		/* Follow the file path */
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
    4fda:	eb 89       	ldd	r30, Y+19	; 0x13
    4fdc:	fc 89       	ldd	r31, Y+20	; 0x14
			if (!dir) {						/* Is it a root directory? */
    4fde:	30 97       	sbiw	r30, 0x00	; 0
    4fe0:	f9 f6       	brne	.-66     	; 0x4fa0 <f_chmod+0x5a>
    4fe2:	ef cf       	rjmp	.-34     	; 0x4fc2 <f_chmod+0x7c>

00004fe4 <f_utime>:

FRESULT f_utime (
	const TCHAR *path,	/* Pointer to the file/directory name */
	const FILINFO *fno	/* Pointer to the time stamp to be set */
)
{
    4fe4:	0f 93       	push	r16
    4fe6:	1f 93       	push	r17
    4fe8:	cf 93       	push	r28
    4fea:	df 93       	push	r29
    4fec:	cd b7       	in	r28, 0x3d	; 61
    4fee:	de b7       	in	r29, 0x3e	; 62
    4ff0:	a4 97       	sbiw	r28, 0x24	; 36
    4ff2:	0f b6       	in	r0, 0x3f	; 63
    4ff4:	f8 94       	cli
    4ff6:	de bf       	out	0x3e, r29	; 62
    4ff8:	0f be       	out	0x3f, r0	; 63
    4ffa:	cd bf       	out	0x3d, r28	; 61
    4ffc:	9c a3       	lds	r25, 0x5c
    4ffe:	8b a3       	lds	r24, 0x5b
    5000:	8b 01       	movw	r16, r22
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    5002:	ce 01       	movw	r24, r28
    5004:	83 96       	adiw	r24, 0x23	; 35
    5006:	be 01       	movw	r22, r28
    5008:	6f 5f       	subi	r22, 0xFF	; 255
    500a:	7f 4f       	sbci	r23, 0xFF	; 255
    500c:	41 e0       	ldi	r20, 0x01	; 1
    500e:	0e 94 ac 0b 	call	0x1758	; 0x1758 <chk_mounted>
	if (res == FR_OK) {
    5012:	88 23       	and	r24, r24
    5014:	61 f5       	brne	.+88     	; 0x506e <f_utime+0x8a>
		INIT_BUF(dj);
    5016:	ce 01       	movw	r24, r28
    5018:	47 96       	adiw	r24, 0x17	; 23
    501a:	9e 8b       	std	Y+22, r25	; 0x16
    501c:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    501e:	6b a1       	lds	r22, 0x4b
    5020:	7c a1       	lds	r23, 0x4c
    5022:	ce 01       	movw	r24, r28
    5024:	01 96       	adiw	r24, 0x01	; 1
    5026:	0e 94 db 16 	call	0x2db6	; 0x2db6 <follow_path>
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    502a:	88 23       	and	r24, r24
    502c:	01 f5       	brne	.+64     	; 0x506e <f_utime+0x8a>
    502e:	ed 89       	ldd	r30, Y+21	; 0x15
    5030:	fe 89       	ldd	r31, Y+22	; 0x16
    5032:	83 85       	ldd	r24, Z+11	; 0x0b
    5034:	85 ff       	sbrs	r24, 5
    5036:	26 c0       	rjmp	.+76     	; 0x5084 <f_utime+0xa0>
			res = FR_INVALID_NAME;
    5038:	86 e0       	ldi	r24, 0x06	; 6
    503a:	19 c0       	rjmp	.+50     	; 0x506e <f_utime+0x8a>
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {					/* Root directory */
				res = FR_INVALID_NAME;
			} else {					/* File or sub-directory */
				ST_WORD(dir+DIR_WrtTime, fno->ftime);
    503c:	d8 01       	movw	r26, r16
    503e:	16 96       	adiw	r26, 0x06	; 6
    5040:	8c 91       	ld	r24, X
    5042:	16 97       	sbiw	r26, 0x06	; 6
    5044:	86 8b       	std	Z+22, r24	; 0x16
    5046:	17 96       	adiw	r26, 0x07	; 7
    5048:	8c 91       	ld	r24, X
    504a:	17 97       	sbiw	r26, 0x07	; 7
    504c:	87 8b       	std	Z+23, r24	; 0x17
				ST_WORD(dir+DIR_WrtDate, fno->fdate);
    504e:	14 96       	adiw	r26, 0x04	; 4
    5050:	8c 91       	ld	r24, X
    5052:	14 97       	sbiw	r26, 0x04	; 4
    5054:	80 8f       	std	Z+24, r24	; 0x18
    5056:	15 96       	adiw	r26, 0x05	; 5
    5058:	8c 91       	ld	r24, X
    505a:	81 8f       	std	Z+25, r24	; 0x19
				dj.fs->wflag = 1;
    505c:	89 81       	ldd	r24, Y+1	; 0x01
    505e:	9a 81       	ldd	r25, Y+2	; 0x02
    5060:	21 e0       	ldi	r18, 0x01	; 1
    5062:	fc 01       	movw	r30, r24
    5064:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    5066:	0e 94 81 10 	call	0x2102	; 0x2102 <sync>
    506a:	01 c0       	rjmp	.+2      	; 0x506e <f_utime+0x8a>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {					/* Root directory */
				res = FR_INVALID_NAME;
    506c:	86 e0       	ldi	r24, 0x06	; 6
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
    506e:	a4 96       	adiw	r28, 0x24	; 36
    5070:	0f b6       	in	r0, 0x3f	; 63
    5072:	f8 94       	cli
    5074:	de bf       	out	0x3e, r29	; 62
    5076:	0f be       	out	0x3f, r0	; 63
    5078:	cd bf       	out	0x3d, r28	; 61
    507a:	df 91       	pop	r29
    507c:	cf 91       	pop	r28
    507e:	1f 91       	pop	r17
    5080:	0f 91       	pop	r16
    5082:	08 95       	ret
		res = follow_path(&dj, path);	/* Follow the file path */
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
    5084:	eb 89       	ldd	r30, Y+19	; 0x13
    5086:	fc 89       	ldd	r31, Y+20	; 0x14
			if (!dir) {					/* Root directory */
    5088:	30 97       	sbiw	r30, 0x00	; 0
    508a:	c1 f6       	brne	.-80     	; 0x503c <f_utime+0x58>
    508c:	ef cf       	rjmp	.-34     	; 0x506c <f_utime+0x88>

0000508e <f_rename>:

FRESULT f_rename (
	const TCHAR *path_old,	/* Pointer to the old name */
	const TCHAR *path_new	/* Pointer to the new name */
)
{
    508e:	ef 92       	push	r14
    5090:	ff 92       	push	r15
    5092:	0f 93       	push	r16
    5094:	1f 93       	push	r17
    5096:	cf 93       	push	r28
    5098:	df 93       	push	r29
    509a:	cd b7       	in	r28, 0x3d	; 61
    509c:	de b7       	in	r29, 0x3e	; 62
    509e:	cf 54       	subi	r28, 0x4F	; 79
    50a0:	d0 40       	sbci	r29, 0x00	; 0
    50a2:	0f b6       	in	r0, 0x3f	; 63
    50a4:	f8 94       	cli
    50a6:	de bf       	out	0x3e, r29	; 62
    50a8:	0f be       	out	0x3f, r0	; 63
    50aa:	cd bf       	out	0x3d, r28	; 61
    50ac:	60 96       	adiw	r28, 0x10	; 16
    50ae:	9f af       	sts	0x7f, r25
    50b0:	8e af       	sts	0x7e, r24
    50b2:	60 97       	sbiw	r28, 0x10	; 16
    50b4:	8b 01       	movw	r16, r22
	BYTE buf[21], *dir;
	DWORD dw;
	DEF_NAMEBUF;


	res = chk_mounted(&path_old, &djo.fs, 1);
    50b6:	ce 01       	movw	r24, r28
    50b8:	82 5b       	subi	r24, 0xB2	; 178
    50ba:	9f 4f       	sbci	r25, 0xFF	; 255
    50bc:	be 01       	movw	r22, r28
    50be:	6f 5f       	subi	r22, 0xFF	; 255
    50c0:	7f 4f       	sbci	r23, 0xFF	; 255
    50c2:	41 e0       	ldi	r20, 0x01	; 1
    50c4:	0e 94 ac 0b 	call	0x1758	; 0x1758 <chk_mounted>
	if (res == FR_OK) {
    50c8:	88 23       	and	r24, r24
    50ca:	09 f0       	breq	.+2      	; 0x50ce <f_rename+0x40>
    50cc:	b7 c0       	rjmp	.+366    	; 0x523c <f_rename+0x1ae>
		djn.fs = djo.fs;
    50ce:	89 81       	ldd	r24, Y+1	; 0x01
    50d0:	9a 81       	ldd	r25, Y+2	; 0x02
    50d2:	98 8f       	std	Y+24, r25	; 0x18
    50d4:	8f 8b       	std	Y+23, r24	; 0x17
		INIT_BUF(djo);
    50d6:	ce 01       	movw	r24, r28
    50d8:	8e 5b       	subi	r24, 0xBE	; 190
    50da:	9f 4f       	sbci	r25, 0xFF	; 255
    50dc:	9e 8b       	std	Y+22, r25	; 0x16
    50de:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&djo, path_old);		/* Check old object */
    50e0:	60 96       	adiw	r28, 0x10	; 16
    50e2:	6e ad       	sts	0x6e, r22
    50e4:	7f ad       	sts	0x6f, r23
    50e6:	60 97       	sbiw	r28, 0x10	; 16
    50e8:	ce 01       	movw	r24, r28
    50ea:	01 96       	adiw	r24, 0x01	; 1
    50ec:	0e 94 db 16 	call	0x2db6	; 0x2db6 <follow_path>
		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
    50f0:	88 23       	and	r24, r24
    50f2:	09 f0       	breq	.+2      	; 0x50f6 <f_rename+0x68>
    50f4:	a3 c0       	rjmp	.+326    	; 0x523c <f_rename+0x1ae>
    50f6:	ed 89       	ldd	r30, Y+21	; 0x15
    50f8:	fe 89       	ldd	r31, Y+22	; 0x16
    50fa:	83 85       	ldd	r24, Z+11	; 0x0b
    50fc:	85 ff       	sbrs	r24, 5
    50fe:	ac c0       	rjmp	.+344    	; 0x5258 <f_rename+0x1ca>
			res = FR_INVALID_NAME;
    5100:	86 e0       	ldi	r24, 0x06	; 6
    5102:	9c c0       	rjmp	.+312    	; 0x523c <f_rename+0x1ae>
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
    5104:	65 5f       	subi	r22, 0xF5	; 245
    5106:	7f 4f       	sbci	r23, 0xFF	; 255
    5108:	ce 01       	movw	r24, r28
    510a:	8d 96       	adiw	r24, 0x2d	; 45
    510c:	25 e1       	ldi	r18, 0x15	; 21
    510e:	30 e0       	ldi	r19, 0x00	; 0
    5110:	40 e0       	ldi	r20, 0x00	; 0
    5112:	50 e0       	ldi	r21, 0x00	; 0
    5114:	0e 94 09 0a 	call	0x1412	; 0x1412 <mem_cpy>
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
    5118:	ce 01       	movw	r24, r28
    511a:	47 96       	adiw	r24, 0x17	; 23
    511c:	be 01       	movw	r22, r28
    511e:	6f 5f       	subi	r22, 0xFF	; 255
    5120:	7f 4f       	sbci	r23, 0xFF	; 255
    5122:	26 e1       	ldi	r18, 0x16	; 22
    5124:	30 e0       	ldi	r19, 0x00	; 0
    5126:	40 e0       	ldi	r20, 0x00	; 0
    5128:	50 e0       	ldi	r21, 0x00	; 0
    512a:	0e 94 09 0a 	call	0x1412	; 0x1412 <mem_cpy>
				res = follow_path(&djn, path_new);
    512e:	ce 01       	movw	r24, r28
    5130:	47 96       	adiw	r24, 0x17	; 23
    5132:	b8 01       	movw	r22, r16
    5134:	0e 94 db 16 	call	0x2db6	; 0x2db6 <follow_path>
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
    5138:	88 23       	and	r24, r24
    513a:	09 f4       	brne	.+2      	; 0x513e <f_rename+0xb0>
    513c:	7c c0       	rjmp	.+248    	; 0x5236 <f_rename+0x1a8>
				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
    513e:	84 30       	cpi	r24, 0x04	; 4
    5140:	09 f0       	breq	.+2      	; 0x5144 <f_rename+0xb6>
    5142:	7c c0       	rjmp	.+248    	; 0x523c <f_rename+0x1ae>
/* Start critical section that an interruption or error can cause cross-link */
					res = dir_register(&djn);			/* Register the new entry */
    5144:	ce 01       	movw	r24, r28
    5146:	47 96       	adiw	r24, 0x17	; 23
    5148:	0e 94 02 19 	call	0x3204	; 0x3204 <dir_register>
					if (res == FR_OK) {
    514c:	88 23       	and	r24, r24
    514e:	09 f0       	breq	.+2      	; 0x5152 <f_rename+0xc4>
    5150:	75 c0       	rjmp	.+234    	; 0x523c <f_rename+0x1ae>
						dir = djn.dir;					/* Copy object information except for name */
    5152:	09 a5       	lds	r16, 0x69
    5154:	1a a5       	lds	r17, 0x6a
						mem_cpy(dir+13, buf+2, 19);
    5156:	c8 01       	movw	r24, r16
    5158:	0d 96       	adiw	r24, 0x0d	; 13
    515a:	be 01       	movw	r22, r28
    515c:	61 5d       	subi	r22, 0xD1	; 209
    515e:	7f 4f       	sbci	r23, 0xFF	; 255
    5160:	23 e1       	ldi	r18, 0x13	; 19
    5162:	30 e0       	ldi	r19, 0x00	; 0
    5164:	40 e0       	ldi	r20, 0x00	; 0
    5166:	50 e0       	ldi	r21, 0x00	; 0
    5168:	0e 94 09 0a 	call	0x1412	; 0x1412 <mem_cpy>
						dir[DIR_Attr] = buf[0] | AM_ARC;
    516c:	8d a5       	lds	r24, 0x6d
    516e:	80 62       	ori	r24, 0x20	; 32
    5170:	f8 01       	movw	r30, r16
    5172:	83 87       	std	Z+11, r24	; 0x0b
						djo.fs->wflag = 1;
    5174:	e9 80       	ldd	r14, Y+1	; 0x01
    5176:	fa 80       	ldd	r15, Y+2	; 0x02
    5178:	81 e0       	ldi	r24, 0x01	; 1
    517a:	f7 01       	movw	r30, r14
    517c:	84 83       	std	Z+4, r24	; 0x04
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
    517e:	4f 81       	ldd	r20, Y+7	; 0x07
    5180:	58 85       	ldd	r21, Y+8	; 0x08
    5182:	69 85       	ldd	r22, Y+9	; 0x09
    5184:	7a 85       	ldd	r23, Y+10	; 0x0a
    5186:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5188:	9e 8d       	ldd	r25, Y+30	; 0x1e
    518a:	af 8d       	ldd	r26, Y+31	; 0x1f
    518c:	b8 a1       	lds	r27, 0x48
    518e:	48 17       	cp	r20, r24
    5190:	59 07       	cpc	r21, r25
    5192:	6a 07       	cpc	r22, r26
    5194:	7b 07       	cpc	r23, r27
    5196:	09 f4       	brne	.+2      	; 0x519a <f_rename+0x10c>
    5198:	43 c0       	rjmp	.+134    	; 0x5220 <f_rename+0x192>
    519a:	f8 01       	movw	r30, r16
    519c:	83 85       	ldd	r24, Z+11	; 0x0b
    519e:	84 ff       	sbrs	r24, 4
    51a0:	3f c0       	rjmp	.+126    	; 0x5220 <f_rename+0x192>
							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
    51a2:	c7 01       	movw	r24, r14
    51a4:	b8 01       	movw	r22, r16
    51a6:	0e 94 2f 0a 	call	0x145e	; 0x145e <ld_clust>
    51aa:	ab 01       	movw	r20, r22
    51ac:	bc 01       	movw	r22, r24
    51ae:	c7 01       	movw	r24, r14
    51b0:	0e 94 13 11 	call	0x2226	; 0x2226 <clust2sect>
    51b4:	ab 01       	movw	r20, r22
    51b6:	bc 01       	movw	r22, r24
							if (!dw) {
    51b8:	41 15       	cp	r20, r1
    51ba:	51 05       	cpc	r21, r1
    51bc:	61 05       	cpc	r22, r1
    51be:	71 05       	cpc	r23, r1
    51c0:	09 f4       	brne	.+2      	; 0x51c4 <f_rename+0x136>
    51c2:	51 c0       	rjmp	.+162    	; 0x5266 <f_rename+0x1d8>
								res = FR_INT_ERR;
							} else {
								res = move_window(djo.fs, dw);
    51c4:	c7 01       	movw	r24, r14
    51c6:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <move_window>
								dir = djo.fs->win+SZ_DIR;	/* .. entry */
    51ca:	e9 81       	ldd	r30, Y+1	; 0x01
    51cc:	fa 81       	ldd	r31, Y+2	; 0x02
								if (res == FR_OK && dir[1] == '.') {
    51ce:	88 23       	and	r24, r24
    51d0:	a9 f5       	brne	.+106    	; 0x523c <f_rename+0x1ae>
    51d2:	df 01       	movw	r26, r30
    51d4:	ad 5a       	subi	r26, 0xAD	; 173
    51d6:	bf 4f       	sbci	r27, 0xFF	; 255
    51d8:	8c 91       	ld	r24, X
    51da:	8e 32       	cpi	r24, 0x2E	; 46
    51dc:	09 f5       	brne	.+66     	; 0x5220 <f_rename+0x192>
									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
    51de:	80 81       	ld	r24, Z
    51e0:	83 30       	cpi	r24, 0x03	; 3
    51e2:	69 f4       	brne	.+26     	; 0x51fe <f_rename+0x170>
    51e4:	4d 8d       	ldd	r20, Y+29	; 0x1d
    51e6:	5e 8d       	ldd	r21, Y+30	; 0x1e
    51e8:	6f 8d       	ldd	r22, Y+31	; 0x1f
    51ea:	78 a1       	lds	r23, 0x48
    51ec:	86 a1       	lds	r24, 0x46
    51ee:	97 a1       	lds	r25, 0x47
    51f0:	a0 a5       	lds	r26, 0x60
    51f2:	b1 a5       	lds	r27, 0x61
    51f4:	48 17       	cp	r20, r24
    51f6:	59 07       	cpc	r21, r25
    51f8:	6a 07       	cpc	r22, r26
    51fa:	7b 07       	cpc	r23, r27
    51fc:	29 f0       	breq	.+10     	; 0x5208 <f_rename+0x17a>
    51fe:	4d 8d       	ldd	r20, Y+29	; 0x1d
    5200:	5e 8d       	ldd	r21, Y+30	; 0x1e
    5202:	6f 8d       	ldd	r22, Y+31	; 0x1f
    5204:	78 a1       	lds	r23, 0x48
    5206:	03 c0       	rjmp	.+6      	; 0x520e <f_rename+0x180>
    5208:	40 e0       	ldi	r20, 0x00	; 0
    520a:	50 e0       	ldi	r21, 0x00	; 0
    520c:	ba 01       	movw	r22, r20
									st_clust(dir, dw);
    520e:	cf 01       	movw	r24, r30
    5210:	8e 5a       	subi	r24, 0xAE	; 174
    5212:	9f 4f       	sbci	r25, 0xFF	; 255
    5214:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <st_clust>
									djo.fs->wflag = 1;
    5218:	e9 81       	ldd	r30, Y+1	; 0x01
    521a:	fa 81       	ldd	r31, Y+2	; 0x02
    521c:	81 e0       	ldi	r24, 0x01	; 1
    521e:	84 83       	std	Z+4, r24	; 0x04
								}
							}
						}
						if (res == FR_OK) {
							res = dir_remove(&djo);		/* Remove old entry */
    5220:	ce 01       	movw	r24, r28
    5222:	01 96       	adiw	r24, 0x01	; 1
    5224:	0e 94 45 13 	call	0x268a	; 0x268a <dir_remove>
							if (res == FR_OK)
    5228:	88 23       	and	r24, r24
    522a:	41 f4       	brne	.+16     	; 0x523c <f_rename+0x1ae>
								res = sync(djo.fs);
    522c:	89 81       	ldd	r24, Y+1	; 0x01
    522e:	9a 81       	ldd	r25, Y+2	; 0x02
    5230:	0e 94 81 10 	call	0x2102	; 0x2102 <sync>
    5234:	03 c0       	rjmp	.+6      	; 0x523c <f_rename+0x1ae>
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
				res = follow_path(&djn, path_new);
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
    5236:	88 e0       	ldi	r24, 0x08	; 8
    5238:	01 c0       	rjmp	.+2      	; 0x523c <f_rename+0x1ae>
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
    523a:	84 e0       	ldi	r24, 0x04	; 4
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(djo.fs, res);
}
    523c:	c1 5b       	subi	r28, 0xB1	; 177
    523e:	df 4f       	sbci	r29, 0xFF	; 255
    5240:	0f b6       	in	r0, 0x3f	; 63
    5242:	f8 94       	cli
    5244:	de bf       	out	0x3e, r29	; 62
    5246:	0f be       	out	0x3f, r0	; 63
    5248:	cd bf       	out	0x3d, r28	; 61
    524a:	df 91       	pop	r29
    524c:	cf 91       	pop	r28
    524e:	1f 91       	pop	r17
    5250:	0f 91       	pop	r16
    5252:	ff 90       	pop	r15
    5254:	ef 90       	pop	r14
    5256:	08 95       	ret
			res = FR_INVALID_NAME;
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
    5258:	6b 89       	ldd	r22, Y+19	; 0x13
    525a:	7c 89       	ldd	r23, Y+20	; 0x14
    525c:	61 15       	cp	r22, r1
    525e:	71 05       	cpc	r23, r1
    5260:	09 f0       	breq	.+2      	; 0x5264 <f_rename+0x1d6>
    5262:	50 cf       	rjmp	.-352    	; 0x5104 <f_rename+0x76>
    5264:	ea cf       	rjmp	.-44     	; 0x523a <f_rename+0x1ac>
						dir[DIR_Attr] = buf[0] | AM_ARC;
						djo.fs->wflag = 1;
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
							if (!dw) {
								res = FR_INT_ERR;
    5266:	82 e0       	ldi	r24, 0x02	; 2
    5268:	e9 cf       	rjmp	.-46     	; 0x523c <f_rename+0x1ae>

0000526a <InitSCCB>:
Function: Initial the SCCB port in AVR
-----------------------------------------------
*/
void InitSCCB(void)
{
	SCCB_DDR|=(1<<SCCB_SIO_C)|(1<<SCCB_SIO_D);  //|(1<<FIFO_WEN)|(1<<FIFO_nRRST)|(1<<FIFO_RCLK);
    526a:	8a b1       	in	r24, 0x0a	; 10
    526c:	83 60       	ori	r24, 0x03	; 3
    526e:	8a b9       	out	0x0a, r24	; 10
	SCCB_PORT|=(1<<SCCB_SIO_C)|(1<<SCCB_SIO_D);
    5270:	8b b1       	in	r24, 0x0b	; 11
    5272:	83 60       	ori	r24, 0x03	; 3
    5274:	8b b9       	out	0x0b, r24	; 11
}
    5276:	08 95       	ret

00005278 <startSCCB>:
Function: Generate the start phase for SCCB following the datasheet
-----------------------------------------------
*/
void startSCCB(void)
{
	SIO_D_SET;     
    5278:	59 9a       	sbi	0x0b, 1	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    527a:	8b e2       	ldi	r24, 0x2B	; 43
    527c:	91 e0       	ldi	r25, 0x01	; 1
    527e:	01 97       	sbiw	r24, 0x01	; 1
    5280:	f1 f7       	brne	.-4      	; 0x527e <startSCCB+0x6>
    5282:	00 c0       	rjmp	.+0      	; 0x5284 <startSCCB+0xc>
    5284:	00 00       	nop
    _delay_us(100);

    SIO_C_SET;
    5286:	58 9a       	sbi	0x0b, 0	; 11
    5288:	8b e2       	ldi	r24, 0x2B	; 43
    528a:	91 e0       	ldi	r25, 0x01	; 1
    528c:	01 97       	sbiw	r24, 0x01	; 1
    528e:	f1 f7       	brne	.-4      	; 0x528c <startSCCB+0x14>
    5290:	00 c0       	rjmp	.+0      	; 0x5292 <startSCCB+0x1a>
    5292:	00 00       	nop
    _delay_us(100);
 
    SIO_D_CLR;
    5294:	59 98       	cbi	0x0b, 1	; 11
    5296:	8b e2       	ldi	r24, 0x2B	; 43
    5298:	91 e0       	ldi	r25, 0x01	; 1
    529a:	01 97       	sbiw	r24, 0x01	; 1
    529c:	f1 f7       	brne	.-4      	; 0x529a <startSCCB+0x22>
    529e:	00 c0       	rjmp	.+0      	; 0x52a0 <startSCCB+0x28>
    52a0:	00 00       	nop
    _delay_us(100);

    SIO_C_CLR;
    52a2:	58 98       	cbi	0x0b, 0	; 11
    52a4:	8b e2       	ldi	r24, 0x2B	; 43
    52a6:	91 e0       	ldi	r25, 0x01	; 1
    52a8:	01 97       	sbiw	r24, 0x01	; 1
    52aa:	f1 f7       	brne	.-4      	; 0x52a8 <startSCCB+0x30>
    52ac:	00 c0       	rjmp	.+0      	; 0x52ae <startSCCB+0x36>
    52ae:	00 00       	nop
    _delay_us(100);


}
    52b0:	08 95       	ret

000052b2 <stopSCCB>:
Function: Generate the stop phase of SCCB following the datasheet
-----------------------------------------------
*/
void stopSCCB(void)
{
	SIO_D_CLR;
    52b2:	59 98       	cbi	0x0b, 1	; 11
    52b4:	8b e2       	ldi	r24, 0x2B	; 43
    52b6:	91 e0       	ldi	r25, 0x01	; 1
    52b8:	01 97       	sbiw	r24, 0x01	; 1
    52ba:	f1 f7       	brne	.-4      	; 0x52b8 <stopSCCB+0x6>
    52bc:	00 c0       	rjmp	.+0      	; 0x52be <stopSCCB+0xc>
    52be:	00 00       	nop
    _delay_us(100);
 
    SIO_C_SET;
    52c0:	58 9a       	sbi	0x0b, 0	; 11
    52c2:	8b e2       	ldi	r24, 0x2B	; 43
    52c4:	91 e0       	ldi	r25, 0x01	; 1
    52c6:	01 97       	sbiw	r24, 0x01	; 1
    52c8:	f1 f7       	brne	.-4      	; 0x52c6 <stopSCCB+0x14>
    52ca:	00 c0       	rjmp	.+0      	; 0x52cc <stopSCCB+0x1a>
    52cc:	00 00       	nop
    _delay_us(100);
  

    SIO_D_SET;
    52ce:	59 9a       	sbi	0x0b, 1	; 11
    52d0:	8b e2       	ldi	r24, 0x2B	; 43
    52d2:	91 e0       	ldi	r25, 0x01	; 1
    52d4:	01 97       	sbiw	r24, 0x01	; 1
    52d6:	f1 f7       	brne	.-4      	; 0x52d4 <stopSCCB+0x22>
    52d8:	00 c0       	rjmp	.+0      	; 0x52da <stopSCCB+0x28>
    52da:	00 00       	nop
    _delay_us(100);
 //   SCCB_DDR&= ~(SCCB_SIO_D);

}
    52dc:	08 95       	ret

000052de <noAck>:
-----------------------------------------------
*/
void noAck(void)
{
	
	SIO_D_SET;
    52de:	59 9a       	sbi	0x0b, 1	; 11
    52e0:	8b e2       	ldi	r24, 0x2B	; 43
    52e2:	91 e0       	ldi	r25, 0x01	; 1
    52e4:	01 97       	sbiw	r24, 0x01	; 1
    52e6:	f1 f7       	brne	.-4      	; 0x52e4 <noAck+0x6>
    52e8:	00 c0       	rjmp	.+0      	; 0x52ea <noAck+0xc>
    52ea:	00 00       	nop
	_delay_us(100);
	
	SIO_C_SET;
    52ec:	58 9a       	sbi	0x0b, 0	; 11
    52ee:	8b e2       	ldi	r24, 0x2B	; 43
    52f0:	91 e0       	ldi	r25, 0x01	; 1
    52f2:	01 97       	sbiw	r24, 0x01	; 1
    52f4:	f1 f7       	brne	.-4      	; 0x52f2 <noAck+0x14>
    52f6:	00 c0       	rjmp	.+0      	; 0x52f8 <noAck+0x1a>
    52f8:	00 00       	nop
	_delay_us(100);
	
	SIO_C_CLR;
    52fa:	58 98       	cbi	0x0b, 0	; 11
    52fc:	8b e2       	ldi	r24, 0x2B	; 43
    52fe:	91 e0       	ldi	r25, 0x01	; 1
    5300:	01 97       	sbiw	r24, 0x01	; 1
    5302:	f1 f7       	brne	.-4      	; 0x5300 <noAck+0x22>
    5304:	00 c0       	rjmp	.+0      	; 0x5306 <noAck+0x28>
    5306:	00 00       	nop
	_delay_us(100);
	
	SIO_D_CLR;
    5308:	59 98       	cbi	0x0b, 1	; 11
    530a:	8b e2       	ldi	r24, 0x2B	; 43
    530c:	91 e0       	ldi	r25, 0x01	; 1
    530e:	01 97       	sbiw	r24, 0x01	; 1
    5310:	f1 f7       	brne	.-4      	; 0x530e <noAck+0x30>
    5312:	00 c0       	rjmp	.+0      	; 0x5314 <noAck+0x36>
    5314:	00 00       	nop
	_delay_us(100);

}
    5316:	08 95       	ret

00005318 <SCCBwriteByte>:
-----------------------------------------------
Function: Write one Byte data through SCCB
-----------------------------------------------
*/
unsigned char SCCBwriteByte(unsigned char m_data)
{
    5318:	20 e0       	ldi	r18, 0x00	; 0
    531a:	30 e0       	ldi	r19, 0x00	; 0
	unsigned char j,tem;

	for(j=0;j<8;j++)
	{
		if((m_data<<j)&0x80)
    531c:	90 e0       	ldi	r25, 0x00	; 0
    531e:	ac 01       	movw	r20, r24
    5320:	02 2e       	mov	r0, r18
    5322:	02 c0       	rjmp	.+4      	; 0x5328 <SCCBwriteByte+0x10>
    5324:	44 0f       	add	r20, r20
    5326:	55 1f       	adc	r21, r21
    5328:	0a 94       	dec	r0
    532a:	e2 f7       	brpl	.-8      	; 0x5324 <SCCBwriteByte+0xc>
    532c:	47 ff       	sbrs	r20, 7
    532e:	02 c0       	rjmp	.+4      	; 0x5334 <SCCBwriteByte+0x1c>
		{
			SIO_D_SET;
    5330:	59 9a       	sbi	0x0b, 1	; 11
    5332:	01 c0       	rjmp	.+2      	; 0x5336 <SCCBwriteByte+0x1e>
		}
		else
		{
			SIO_D_CLR;
    5334:	59 98       	cbi	0x0b, 1	; 11
    5336:	eb e2       	ldi	r30, 0x2B	; 43
    5338:	f1 e0       	ldi	r31, 0x01	; 1
    533a:	31 97       	sbiw	r30, 0x01	; 1
    533c:	f1 f7       	brne	.-4      	; 0x533a <SCCBwriteByte+0x22>
    533e:	00 c0       	rjmp	.+0      	; 0x5340 <SCCBwriteByte+0x28>
    5340:	00 00       	nop
		}
		_delay_us(100);
		SIO_C_SET;
    5342:	58 9a       	sbi	0x0b, 0	; 11
    5344:	eb e2       	ldi	r30, 0x2B	; 43
    5346:	f1 e0       	ldi	r31, 0x01	; 1
    5348:	31 97       	sbiw	r30, 0x01	; 1
    534a:	f1 f7       	brne	.-4      	; 0x5348 <SCCBwriteByte+0x30>
    534c:	00 c0       	rjmp	.+0      	; 0x534e <SCCBwriteByte+0x36>
    534e:	00 00       	nop
		_delay_us(100);
		SIO_C_CLR;
    5350:	58 98       	cbi	0x0b, 0	; 11
    5352:	eb e2       	ldi	r30, 0x2B	; 43
    5354:	f1 e0       	ldi	r31, 0x01	; 1
    5356:	31 97       	sbiw	r30, 0x01	; 1
    5358:	f1 f7       	brne	.-4      	; 0x5356 <SCCBwriteByte+0x3e>
    535a:	00 c0       	rjmp	.+0      	; 0x535c <SCCBwriteByte+0x44>
    535c:	00 00       	nop
    535e:	2f 5f       	subi	r18, 0xFF	; 255
    5360:	3f 4f       	sbci	r19, 0xFF	; 255
*/
unsigned char SCCBwriteByte(unsigned char m_data)
{
	unsigned char j,tem;

	for(j=0;j<8;j++)
    5362:	28 30       	cpi	r18, 0x08	; 8
    5364:	31 05       	cpc	r19, r1
    5366:	d9 f6       	brne	.-74     	; 0x531e <SCCBwriteByte+0x6>
    5368:	8b e2       	ldi	r24, 0x2B	; 43
    536a:	91 e0       	ldi	r25, 0x01	; 1
    536c:	01 97       	sbiw	r24, 0x01	; 1
    536e:	f1 f7       	brne	.-4      	; 0x536c <SCCBwriteByte+0x54>
    5370:	00 c0       	rjmp	.+0      	; 0x5372 <SCCBwriteByte+0x5a>
    5372:	00 00       	nop
		_delay_us(100);

	}
	_delay_us(100);
	
	SIO_D_IN;	//Set SDA as input
    5374:	51 98       	cbi	0x0a, 1	; 10
    5376:	eb e2       	ldi	r30, 0x2B	; 43
    5378:	f1 e0       	ldi	r31, 0x01	; 1
    537a:	31 97       	sbiw	r30, 0x01	; 1
    537c:	f1 f7       	brne	.-4      	; 0x537a <SCCBwriteByte+0x62>
    537e:	00 c0       	rjmp	.+0      	; 0x5380 <SCCBwriteByte+0x68>
    5380:	00 00       	nop
	_delay_us(100);
	SIO_C_SET;
    5382:	58 9a       	sbi	0x0b, 0	; 11
    5384:	87 eb       	ldi	r24, 0xB7	; 183
    5386:	9b e0       	ldi	r25, 0x0B	; 11
    5388:	01 97       	sbiw	r24, 0x01	; 1
    538a:	f1 f7       	brne	.-4      	; 0x5388 <SCCBwriteByte+0x70>
    538c:	00 c0       	rjmp	.+0      	; 0x538e <SCCBwriteByte+0x76>
    538e:	00 00       	nop
	_delay_us(1000);
	if(SIO_D_STATE)
    5390:	99 b1       	in	r25, 0x09	; 9
	}
	else
	{
		tem=1;   //SDA=0 send succeed, reture 1
	}
	SIO_C_CLR;
    5392:	58 98       	cbi	0x0b, 0	; 11
    5394:	eb e2       	ldi	r30, 0x2B	; 43
    5396:	f1 e0       	ldi	r31, 0x01	; 1
    5398:	31 97       	sbiw	r30, 0x01	; 1
    539a:	f1 f7       	brne	.-4      	; 0x5398 <SCCBwriteByte+0x80>
    539c:	00 c0       	rjmp	.+0      	; 0x539e <SCCBwriteByte+0x86>
    539e:	00 00       	nop
	_delay_us(100);	
    SIO_D_OUT;	//Set SDA as output
    53a0:	51 9a       	sbi	0x0a, 1	; 10
	_delay_us(100);
	SIO_C_SET;
	_delay_us(1000);
	if(SIO_D_STATE)
	{
		tem=0;   //SDA=1 send fail, return 0
    53a2:	81 e0       	ldi	r24, 0x01	; 1
    53a4:	91 fd       	sbrc	r25, 1
    53a6:	80 e0       	ldi	r24, 0x00	; 0
	SIO_C_CLR;
	_delay_us(100);	
    SIO_D_OUT;	//Set SDA as output

	return(tem);  
}
    53a8:	08 95       	ret

000053aa <SCCBreadByte>:
unsigned char SCCBreadByte(void)
{
	unsigned char read,j;
	read=0x00;
	
	SIO_D_IN;/*SDA*/
    53aa:	51 98       	cbi	0x0a, 1	; 10
    53ac:	8b e2       	ldi	r24, 0x2B	; 43
    53ae:	91 e0       	ldi	r25, 0x01	; 1
    53b0:	01 97       	sbiw	r24, 0x01	; 1
    53b2:	f1 f7       	brne	.-4      	; 0x53b0 <SCCBreadByte+0x6>
    53b4:	00 c0       	rjmp	.+0      	; 0x53b6 <SCCBreadByte+0xc>
    53b6:	00 00       	nop
    53b8:	98 e0       	ldi	r25, 0x08	; 8
-----------------------------------------------
*/
unsigned char SCCBreadByte(void)
{
	unsigned char read,j;
	read=0x00;
    53ba:	80 e0       	ldi	r24, 0x00	; 0
    53bc:	eb e2       	ldi	r30, 0x2B	; 43
    53be:	f1 e0       	ldi	r31, 0x01	; 1
    53c0:	31 97       	sbiw	r30, 0x01	; 1
    53c2:	f1 f7       	brne	.-4      	; 0x53c0 <SCCBreadByte+0x16>
    53c4:	00 c0       	rjmp	.+0      	; 0x53c6 <SCCBreadByte+0x1c>
    53c6:	00 00       	nop
	SIO_D_IN;/*SDA*/
	_delay_us(100);
	for(j=8;j>0;j--) //8
	{		     
		_delay_us(100);
		SIO_C_SET;
    53c8:	58 9a       	sbi	0x0b, 0	; 11
    53ca:	eb e2       	ldi	r30, 0x2B	; 43
    53cc:	f1 e0       	ldi	r31, 0x01	; 1
    53ce:	31 97       	sbiw	r30, 0x01	; 1
    53d0:	f1 f7       	brne	.-4      	; 0x53ce <SCCBreadByte+0x24>
    53d2:	00 c0       	rjmp	.+0      	; 0x53d4 <SCCBreadByte+0x2a>
    53d4:	00 00       	nop
		_delay_us(100);
		read=read<<1;
    53d6:	88 0f       	add	r24, r24
		if(SIO_D_STATE) 
    53d8:	49 99       	sbic	0x09, 1	; 9
		{
			read=read+1;
    53da:	8f 5f       	subi	r24, 0xFF	; 255
		}
		SIO_C_CLR;
    53dc:	58 98       	cbi	0x0b, 0	; 11
    53de:	eb e2       	ldi	r30, 0x2B	; 43
    53e0:	f1 e0       	ldi	r31, 0x01	; 1
    53e2:	31 97       	sbiw	r30, 0x01	; 1
    53e4:	f1 f7       	brne	.-4      	; 0x53e2 <SCCBreadByte+0x38>
    53e6:	00 c0       	rjmp	.+0      	; 0x53e8 <SCCBreadByte+0x3e>
    53e8:	00 00       	nop
    53ea:	91 50       	subi	r25, 0x01	; 1
	unsigned char read,j;
	read=0x00;
	
	SIO_D_IN;/*SDA*/
	_delay_us(100);
	for(j=8;j>0;j--) //8
    53ec:	39 f7       	brne	.-50     	; 0x53bc <SCCBreadByte+0x12>
		}
		SIO_C_CLR;
		_delay_us(100);
	}	
	return(read);
}
    53ee:	08 95       	ret

000053f0 <TWI_Master_Initialise>:
		DDRC = 0x00;
		PORTC = (1 << PC0) | (1 << PC1);
	#else
		#pragma message("External I2C Pull Ups Required.")
	#endif
	TWBR = TWI_TWBR;                                  // Set bit rate register (Baudrate). Defined in header file.
    53f0:	84 e3       	ldi	r24, 0x34	; 52
    53f2:	80 93 b8 00 	sts	0x00B8, r24
	// TWSR = TWI_TWPS;                                  // Not used. Driver presumes prescaler to be 00.
	TWDR = 0xFF;                                      // Default content = SDA released.
    53f6:	8f ef       	ldi	r24, 0xFF	; 255
    53f8:	80 93 bb 00 	sts	0x00BB, r24
	TWCR =	(1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
    53fc:	84 e0       	ldi	r24, 0x04	; 4
    53fe:	80 93 bc 00 	sts	0x00BC, r24
			(0<<TWIE)|(0<<TWINT)|                      // Disable Interupt.
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests.
			(0<<TWWC);                                 //
}    
    5402:	08 95       	ret

00005404 <TWI_Transceiver_Busy>:
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
    5404:	80 91 bc 00 	lds	r24, 0x00BC
}
    5408:	81 70       	andi	r24, 0x01	; 1
    540a:	08 95       	ret

0000540c <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
    540c:	0e 94 02 2a 	call	0x5404	; 0x5404 <TWI_Transceiver_Busy>
    5410:	88 23       	and	r24, r24
    5412:	e1 f7       	brne	.-8      	; 0x540c <TWI_Get_State_Info>
  return ( TWI_state );                         // Return error state.
}
    5414:	80 91 ef 03 	lds	r24, 0x03EF
    5418:	08 95       	ret

0000541a <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
    541a:	0f 93       	push	r16
    541c:	1f 93       	push	r17
    541e:	cf 93       	push	r28
    5420:	8c 01       	movw	r16, r24
    5422:	c6 2f       	mov	r28, r22
  unsigned char temp;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    5424:	0e 94 02 2a 	call	0x5404	; 0x5404 <TWI_Transceiver_Busy>
    5428:	88 23       	and	r24, r24
    542a:	e1 f7       	brne	.-8      	; 0x5424 <TWI_Start_Transceiver_With_Data+0xa>

  TWI_msgSize = msgSize;                        // Number of data to transmit.
    542c:	c0 93 f9 03 	sts	0x03F9, r28
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
    5430:	f8 01       	movw	r30, r16
    5432:	80 81       	ld	r24, Z
    5434:	80 93 fa 03 	sts	0x03FA, r24
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
    5438:	80 fd       	sbrc	r24, 0
    543a:	0c c0       	rjmp	.+24     	; 0x5454 <TWI_Start_Transceiver_With_Data+0x3a>
  {
    for ( temp = 1; temp < msgSize; temp++ )
    543c:	c2 30       	cpi	r28, 0x02	; 2
    543e:	50 f0       	brcs	.+20     	; 0x5454 <TWI_Start_Transceiver_With_Data+0x3a>
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    5440:	d8 01       	movw	r26, r16
    5442:	11 96       	adiw	r26, 0x01	; 1

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    5444:	eb ef       	ldi	r30, 0xFB	; 251
    5446:	f3 e0       	ldi	r31, 0x03	; 3
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    5448:	81 e0       	ldi	r24, 0x01	; 1
  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
      TWI_buf[ temp ] = msg[ temp ];
    544a:	9d 91       	ld	r25, X+
    544c:	91 93       	st	Z+, r25

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    544e:	8f 5f       	subi	r24, 0xFF	; 255
    5450:	8c 17       	cp	r24, r28
    5452:	d9 f7       	brne	.-10     	; 0x544a <TWI_Start_Transceiver_With_Data+0x30>
      TWI_buf[ temp ] = msg[ temp ];
  }
  TWI_statusReg.all = 0;      
    5454:	10 92 f8 03 	sts	0x03F8, r1
  TWI_state         = TWI_NO_STATE ;
    5458:	88 ef       	ldi	r24, 0xF8	; 248
    545a:	80 93 ef 03 	sts	0x03EF, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    545e:	85 ea       	ldi	r24, 0xA5	; 165
    5460:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    5464:	cf 91       	pop	r28
    5466:	1f 91       	pop	r17
    5468:	0f 91       	pop	r16
    546a:	08 95       	ret

0000546c <TWI_Start_Transceiver>:
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    546c:	0e 94 02 2a 	call	0x5404	; 0x5404 <TWI_Transceiver_Busy>
    5470:	88 23       	and	r24, r24
    5472:	e1 f7       	brne	.-8      	; 0x546c <TWI_Start_Transceiver>
  TWI_statusReg.all = 0;      
    5474:	10 92 f8 03 	sts	0x03F8, r1
  TWI_state         = TWI_NO_STATE ;
    5478:	88 ef       	ldi	r24, 0xF8	; 248
    547a:	80 93 ef 03 	sts	0x03EF, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    547e:	85 ea       	ldi	r24, 0xA5	; 165
    5480:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    5484:	08 95       	ret

00005486 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    5486:	1f 93       	push	r17
    5488:	cf 93       	push	r28
    548a:	df 93       	push	r29
    548c:	d8 2f       	mov	r29, r24
    548e:	19 2f       	mov	r17, r25
    5490:	c6 2f       	mov	r28, r22
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    5492:	0e 94 02 2a 	call	0x5404	; 0x5404 <TWI_Transceiver_Busy>
    5496:	88 23       	and	r24, r24
    5498:	e1 f7       	brne	.-8      	; 0x5492 <TWI_Get_Data_From_Transceiver+0xc>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    549a:	80 91 f8 03 	lds	r24, 0x03F8
    549e:	80 ff       	sbrs	r24, 0
    54a0:	0d c0       	rjmp	.+26     	; 0x54bc <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    54a2:	cc 23       	and	r28, r28
    54a4:	59 f0       	breq	.+22     	; 0x54bc <TWI_Get_Data_From_Transceiver+0x36>
    54a6:	aa ef       	ldi	r26, 0xFA	; 250
    54a8:	b3 e0       	ldi	r27, 0x03	; 3
    54aa:	9d 2f       	mov	r25, r29
    54ac:	ed 2f       	mov	r30, r29
    54ae:	f1 2f       	mov	r31, r17
    {
      msg[ i ] = TWI_buf[ i ];
    54b0:	8d 91       	ld	r24, X+
    54b2:	81 93       	st	Z+, r24

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    54b4:	8e 2f       	mov	r24, r30
    54b6:	89 1b       	sub	r24, r25
    54b8:	8c 17       	cp	r24, r28
    54ba:	d0 f3       	brcs	.-12     	; 0x54b0 <TWI_Get_Data_From_Transceiver+0x2a>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    54bc:	80 91 f8 03 	lds	r24, 0x03F8
}
    54c0:	81 70       	andi	r24, 0x01	; 1
    54c2:	df 91       	pop	r29
    54c4:	cf 91       	pop	r28
    54c6:	1f 91       	pop	r17
    54c8:	08 95       	ret

000054ca <__vector_26>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/

ISR(TWI_vect)
{
    54ca:	1f 92       	push	r1
    54cc:	0f 92       	push	r0
    54ce:	0f b6       	in	r0, 0x3f	; 63
    54d0:	0f 92       	push	r0
    54d2:	11 24       	eor	r1, r1
    54d4:	2f 93       	push	r18
    54d6:	3f 93       	push	r19
    54d8:	8f 93       	push	r24
    54da:	9f 93       	push	r25
    54dc:	ef 93       	push	r30
    54de:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    54e0:	80 91 b9 00 	lds	r24, 0x00B9
    54e4:	88 32       	cpi	r24, 0x28	; 40
    54e6:	d1 f0       	breq	.+52     	; 0x551c <__vector_26+0x52>
    54e8:	89 32       	cpi	r24, 0x29	; 41
    54ea:	40 f4       	brcc	.+16     	; 0x54fc <__vector_26+0x32>
    54ec:	80 31       	cpi	r24, 0x10	; 16
    54ee:	a1 f0       	breq	.+40     	; 0x5518 <__vector_26+0x4e>
    54f0:	88 31       	cpi	r24, 0x18	; 24
    54f2:	a1 f0       	breq	.+40     	; 0x551c <__vector_26+0x52>
    54f4:	88 30       	cpi	r24, 0x08	; 8
    54f6:	09 f0       	breq	.+2      	; 0x54fa <__vector_26+0x30>
    54f8:	61 c0       	rjmp	.+194    	; 0x55bc <__vector_26+0xf2>
    54fa:	0e c0       	rjmp	.+28     	; 0x5518 <__vector_26+0x4e>
    54fc:	80 34       	cpi	r24, 0x40	; 64
    54fe:	b9 f1       	breq	.+110    	; 0x556e <__vector_26+0xa4>
    5500:	81 34       	cpi	r24, 0x41	; 65
    5502:	20 f4       	brcc	.+8      	; 0x550c <__vector_26+0x42>
    5504:	88 33       	cpi	r24, 0x38	; 56
    5506:	09 f0       	breq	.+2      	; 0x550a <__vector_26+0x40>
    5508:	59 c0       	rjmp	.+178    	; 0x55bc <__vector_26+0xf2>
    550a:	54 c0       	rjmp	.+168    	; 0x55b4 <__vector_26+0xea>
    550c:	80 35       	cpi	r24, 0x50	; 80
    550e:	19 f1       	breq	.+70     	; 0x5556 <__vector_26+0x8c>
    5510:	88 35       	cpi	r24, 0x58	; 88
    5512:	09 f0       	breq	.+2      	; 0x5516 <__vector_26+0x4c>
    5514:	53 c0       	rjmp	.+166    	; 0x55bc <__vector_26+0xf2>
    5516:	3d c0       	rjmp	.+122    	; 0x5592 <__vector_26+0xc8>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    5518:	10 92 fe 03 	sts	0x03FE, r1
    case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    551c:	80 91 fe 03 	lds	r24, 0x03FE
    5520:	90 91 f9 03 	lds	r25, 0x03F9
    5524:	89 17       	cp	r24, r25
    5526:	70 f4       	brcc	.+28     	; 0x5544 <__vector_26+0x7a>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    5528:	e8 2f       	mov	r30, r24
    552a:	f0 e0       	ldi	r31, 0x00	; 0
    552c:	e6 50       	subi	r30, 0x06	; 6
    552e:	fc 4f       	sbci	r31, 0xFC	; 252
    5530:	90 81       	ld	r25, Z
    5532:	90 93 bb 00 	sts	0x00BB, r25
    5536:	8f 5f       	subi	r24, 0xFF	; 255
    5538:	80 93 fe 03 	sts	0x03FE, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    553c:	85 e8       	ldi	r24, 0x85	; 133
    553e:	80 93 bc 00 	sts	0x00BC, r24
    5542:	43 c0       	rjmp	.+134    	; 0x55ca <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    5544:	80 91 f8 03 	lds	r24, 0x03F8
    5548:	81 60       	ori	r24, 0x01	; 1
    554a:	80 93 f8 03 	sts	0x03F8, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    554e:	84 e9       	ldi	r24, 0x94	; 148
    5550:	80 93 bc 00 	sts	0x00BC, r24
    5554:	3a c0       	rjmp	.+116    	; 0x55ca <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    5556:	80 91 fe 03 	lds	r24, 0x03FE
    555a:	90 91 bb 00 	lds	r25, 0x00BB
    555e:	e8 2f       	mov	r30, r24
    5560:	f0 e0       	ldi	r31, 0x00	; 0
    5562:	e6 50       	subi	r30, 0x06	; 6
    5564:	fc 4f       	sbci	r31, 0xFC	; 252
    5566:	90 83       	st	Z, r25
    5568:	8f 5f       	subi	r24, 0xFF	; 255
    556a:	80 93 fe 03 	sts	0x03FE, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    556e:	20 91 fe 03 	lds	r18, 0x03FE
    5572:	30 e0       	ldi	r19, 0x00	; 0
    5574:	80 91 f9 03 	lds	r24, 0x03F9
    5578:	90 e0       	ldi	r25, 0x00	; 0
    557a:	01 97       	sbiw	r24, 0x01	; 1
    557c:	28 17       	cp	r18, r24
    557e:	39 07       	cpc	r19, r25
    5580:	24 f4       	brge	.+8      	; 0x558a <__vector_26+0xc0>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    5582:	85 ec       	ldi	r24, 0xC5	; 197
    5584:	80 93 bc 00 	sts	0x00BC, r24
    5588:	20 c0       	rjmp	.+64     	; 0x55ca <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    558a:	85 e8       	ldi	r24, 0x85	; 133
    558c:	80 93 bc 00 	sts	0x00BC, r24
    5590:	1c c0       	rjmp	.+56     	; 0x55ca <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    5592:	80 91 bb 00 	lds	r24, 0x00BB
    5596:	e0 91 fe 03 	lds	r30, 0x03FE
    559a:	f0 e0       	ldi	r31, 0x00	; 0
    559c:	e6 50       	subi	r30, 0x06	; 6
    559e:	fc 4f       	sbci	r31, 0xFC	; 252
    55a0:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    55a2:	80 91 f8 03 	lds	r24, 0x03F8
    55a6:	81 60       	ori	r24, 0x01	; 1
    55a8:	80 93 f8 03 	sts	0x03F8, r24
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    55ac:	84 e9       	ldi	r24, 0x94	; 148
    55ae:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    55b2:	0b c0       	rjmp	.+22     	; 0x55ca <__vector_26+0x100>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    55b4:	85 ea       	ldi	r24, 0xA5	; 165
    55b6:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    55ba:	07 c0       	rjmp	.+14     	; 0x55ca <__vector_26+0x100>
    case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
//    case TWI_NO_STATE              // No relevant state information available; TWINT = 0
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    55bc:	80 91 b9 00 	lds	r24, 0x00B9
    55c0:	80 93 ef 03 	sts	0x03EF, r24
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    55c4:	84 e0       	ldi	r24, 0x04	; 4
    55c6:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    55ca:	ff 91       	pop	r31
    55cc:	ef 91       	pop	r30
    55ce:	9f 91       	pop	r25
    55d0:	8f 91       	pop	r24
    55d2:	3f 91       	pop	r19
    55d4:	2f 91       	pop	r18
    55d6:	0f 90       	pop	r0
    55d8:	0f be       	out	0x3f, r0	; 63
    55da:	0f 90       	pop	r0
    55dc:	1f 90       	pop	r1
    55de:	18 95       	reti

000055e0 <USART0_Init>:

void USART0_Init()
{
	uint16_t ubrr = UBBR;
	//Set baud rate
	UBRR0H = (unsigned char)(ubrr >>8);
    55e0:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (unsigned char)ubrr ;
    55e4:	8c e0       	ldi	r24, 0x0C	; 12
    55e6:	80 93 c4 00 	sts	0x00C4, r24
	//Enable receiver and transmitter
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    55ea:	88 e1       	ldi	r24, 0x18	; 24
    55ec:	80 93 c1 00 	sts	0x00C1, r24
	
	UCSR0C = 0x06; //set asynchronous, no parity, one stop bit, 8 bit transfer.
    55f0:	86 e0       	ldi	r24, 0x06	; 6
    55f2:	80 93 c2 00 	sts	0x00C2, r24
	
	//UCSR0B |= (1 << RXCIE0) | (1 << TXCIE0); //set RX and TX interrupt on
}
    55f6:	08 95       	ret

000055f8 <Usart_SendChar>:
void Usart_SendChar(char data) 
{
    // Wait for empty transmit buffer
    while ( !(UCSR0A & (1 << UDRE0)) );
    55f8:	e0 ec       	ldi	r30, 0xC0	; 192
    55fa:	f0 e0       	ldi	r31, 0x00	; 0
    55fc:	90 81       	ld	r25, Z
    55fe:	95 ff       	sbrs	r25, 5
    5600:	fd cf       	rjmp	.-6      	; 0x55fc <Usart_SendChar+0x4>
    // Start transmission
    UDR0 = data; 
    5602:	80 93 c6 00 	sts	0x00C6, r24
}
    5606:	08 95       	ret

00005608 <Usart_Receive>:
unsigned char Usart_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
    5608:	e0 ec       	ldi	r30, 0xC0	; 192
    560a:	f0 e0       	ldi	r31, 0x00	; 0
    560c:	80 81       	ld	r24, Z
    560e:	88 23       	and	r24, r24
    5610:	ec f7       	brge	.-6      	; 0x560c <Usart_Receive+0x4>
	;
	/* Get and return received data from buffer */
	//Usart_SendChar(UDR0);
	return UDR0;
    5612:	80 91 c6 00 	lds	r24, 0x00C6
}
    5616:	08 95       	ret

00005618 <Usart_printf>:
//to use this copy the following as a global- 
//		static FILE mystdout = FDEV_SETUP_STREAM(Usart_printf, NULL, _FDEV_SETUP_WRITE);
// and add this line at the beginning of main:
//		stdout = &mystdout;
//	stdio.h must be used.
int Usart_printf(char var, FILE *stream) {
    5618:	cf 93       	push	r28
    561a:	c8 2f       	mov	r28, r24
    // translate \n to \r for br@y++ terminal
    if (var == '\n') Usart_SendChar('\r');
    561c:	8a 30       	cpi	r24, 0x0A	; 10
    561e:	19 f4       	brne	.+6      	; 0x5626 <Usart_printf+0xe>
    5620:	8d e0       	ldi	r24, 0x0D	; 13
    5622:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <Usart_SendChar>
    Usart_SendChar(var);
    5626:	8c 2f       	mov	r24, r28
    5628:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <Usart_SendChar>
    return 0;
}
    562c:	80 e0       	ldi	r24, 0x00	; 0
    562e:	90 e0       	ldi	r25, 0x00	; 0
    5630:	cf 91       	pop	r28
    5632:	08 95       	ret

00005634 <Usart_get_line>:

void Usart_get_line (char *buff, int len)
{
    5634:	ef 92       	push	r14
    5636:	ff 92       	push	r15
    5638:	0f 93       	push	r16
    563a:	1f 93       	push	r17
    563c:	cf 93       	push	r28
    563e:	df 93       	push	r29
    5640:	7c 01       	movw	r14, r24
	cli();
    5642:	f8 94       	cli
	char c;
	int i = 0;
    5644:	c0 e0       	ldi	r28, 0x00	; 0
    5646:	d0 e0       	ldi	r29, 0x00	; 0
		if ((c == '\b') && i) {
			i--;
			Usart_SendChar(c);
			continue;
		}
		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    5648:	8b 01       	movw	r16, r22
    564a:	01 50       	subi	r16, 0x01	; 1
    564c:	10 40       	sbci	r17, 0x00	; 0
	char c;
	int i = 0;


	for (;;) {
		c = Usart_Receive();
    564e:	0e 94 04 2b 	call	0x5608	; 0x5608 <Usart_Receive>
		if (c == '\r') break;
    5652:	8d 30       	cpi	r24, 0x0D	; 13
    5654:	a9 f0       	breq	.+42     	; 0x5680 <Usart_get_line+0x4c>
		if ((c == '\b') && i) {
    5656:	88 30       	cpi	r24, 0x08	; 8
    5658:	31 f4       	brne	.+12     	; 0x5666 <Usart_get_line+0x32>
    565a:	20 97       	sbiw	r28, 0x00	; 0
    565c:	c1 f3       	breq	.-16     	; 0x564e <Usart_get_line+0x1a>
			i--;
    565e:	21 97       	sbiw	r28, 0x01	; 1
			Usart_SendChar(c);
    5660:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <Usart_SendChar>
			continue;
    5664:	f4 cf       	rjmp	.-24     	; 0x564e <Usart_get_line+0x1a>
		}
		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    5666:	80 32       	cpi	r24, 0x20	; 32
    5668:	90 f3       	brcs	.-28     	; 0x564e <Usart_get_line+0x1a>
    566a:	c0 17       	cp	r28, r16
    566c:	d1 07       	cpc	r29, r17
    566e:	7c f7       	brge	.-34     	; 0x564e <Usart_get_line+0x1a>
			buff[i++] = c;
    5670:	f7 01       	movw	r30, r14
    5672:	ec 0f       	add	r30, r28
    5674:	fd 1f       	adc	r31, r29
    5676:	80 83       	st	Z, r24
    5678:	21 96       	adiw	r28, 0x01	; 1
			Usart_SendChar(c);
    567a:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <Usart_SendChar>
    567e:	e7 cf       	rjmp	.-50     	; 0x564e <Usart_get_line+0x1a>
		}
	}
	buff[i] = 0;
    5680:	ce 0d       	add	r28, r14
    5682:	df 1d       	adc	r29, r15
    5684:	18 82       	st	Y, r1
	Usart_SendChar('\n');
    5686:	8a e0       	ldi	r24, 0x0A	; 10
    5688:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <Usart_SendChar>
	sei();
    568c:	78 94       	sei
}
    568e:	df 91       	pop	r29
    5690:	cf 91       	pop	r28
    5692:	1f 91       	pop	r17
    5694:	0f 91       	pop	r16
    5696:	ff 90       	pop	r15
    5698:	ef 90       	pop	r14
    569a:	08 95       	ret

0000569c <USART0_Senduint16>:
void USART0_Senduint16 (uint16_t Data)
{
    569c:	cf 93       	push	r28
    569e:	c8 2f       	mov	r28, r24
	Usart_SendChar(Data >> 8);
    56a0:	89 2f       	mov	r24, r25
    56a2:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <Usart_SendChar>
	Usart_SendChar(Data & 0xFF);
    56a6:	8c 2f       	mov	r24, r28
    56a8:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <Usart_SendChar>
    56ac:	cf 91       	pop	r28
    56ae:	08 95       	ret

000056b0 <__mulsi3>:
    56b0:	62 9f       	mul	r22, r18
    56b2:	d0 01       	movw	r26, r0
    56b4:	73 9f       	mul	r23, r19
    56b6:	f0 01       	movw	r30, r0
    56b8:	82 9f       	mul	r24, r18
    56ba:	e0 0d       	add	r30, r0
    56bc:	f1 1d       	adc	r31, r1
    56be:	64 9f       	mul	r22, r20
    56c0:	e0 0d       	add	r30, r0
    56c2:	f1 1d       	adc	r31, r1
    56c4:	92 9f       	mul	r25, r18
    56c6:	f0 0d       	add	r31, r0
    56c8:	83 9f       	mul	r24, r19
    56ca:	f0 0d       	add	r31, r0
    56cc:	74 9f       	mul	r23, r20
    56ce:	f0 0d       	add	r31, r0
    56d0:	65 9f       	mul	r22, r21
    56d2:	f0 0d       	add	r31, r0
    56d4:	99 27       	eor	r25, r25
    56d6:	72 9f       	mul	r23, r18
    56d8:	b0 0d       	add	r27, r0
    56da:	e1 1d       	adc	r30, r1
    56dc:	f9 1f       	adc	r31, r25
    56de:	63 9f       	mul	r22, r19
    56e0:	b0 0d       	add	r27, r0
    56e2:	e1 1d       	adc	r30, r1
    56e4:	f9 1f       	adc	r31, r25
    56e6:	bd 01       	movw	r22, r26
    56e8:	cf 01       	movw	r24, r30
    56ea:	11 24       	eor	r1, r1
    56ec:	08 95       	ret

000056ee <__udivmodsi4>:
    56ee:	a1 e2       	ldi	r26, 0x21	; 33
    56f0:	1a 2e       	mov	r1, r26
    56f2:	aa 1b       	sub	r26, r26
    56f4:	bb 1b       	sub	r27, r27
    56f6:	fd 01       	movw	r30, r26
    56f8:	0d c0       	rjmp	.+26     	; 0x5714 <__udivmodsi4_ep>

000056fa <__udivmodsi4_loop>:
    56fa:	aa 1f       	adc	r26, r26
    56fc:	bb 1f       	adc	r27, r27
    56fe:	ee 1f       	adc	r30, r30
    5700:	ff 1f       	adc	r31, r31
    5702:	a2 17       	cp	r26, r18
    5704:	b3 07       	cpc	r27, r19
    5706:	e4 07       	cpc	r30, r20
    5708:	f5 07       	cpc	r31, r21
    570a:	20 f0       	brcs	.+8      	; 0x5714 <__udivmodsi4_ep>
    570c:	a2 1b       	sub	r26, r18
    570e:	b3 0b       	sbc	r27, r19
    5710:	e4 0b       	sbc	r30, r20
    5712:	f5 0b       	sbc	r31, r21

00005714 <__udivmodsi4_ep>:
    5714:	66 1f       	adc	r22, r22
    5716:	77 1f       	adc	r23, r23
    5718:	88 1f       	adc	r24, r24
    571a:	99 1f       	adc	r25, r25
    571c:	1a 94       	dec	r1
    571e:	69 f7       	brne	.-38     	; 0x56fa <__udivmodsi4_loop>
    5720:	60 95       	com	r22
    5722:	70 95       	com	r23
    5724:	80 95       	com	r24
    5726:	90 95       	com	r25
    5728:	9b 01       	movw	r18, r22
    572a:	ac 01       	movw	r20, r24
    572c:	bd 01       	movw	r22, r26
    572e:	cf 01       	movw	r24, r30
    5730:	08 95       	ret

00005732 <printf>:
    5732:	a0 e0       	ldi	r26, 0x00	; 0
    5734:	b0 e0       	ldi	r27, 0x00	; 0
    5736:	ef e9       	ldi	r30, 0x9F	; 159
    5738:	fb e2       	ldi	r31, 0x2B	; 43
    573a:	0c 94 8c 2e 	jmp	0x5d18	; 0x5d18 <__prologue_saves__+0x20>
    573e:	fe 01       	movw	r30, r28
    5740:	35 96       	adiw	r30, 0x05	; 5
    5742:	61 91       	ld	r22, Z+
    5744:	71 91       	ld	r23, Z+
    5746:	80 91 8b 0e 	lds	r24, 0x0E8B
    574a:	90 91 8c 0e 	lds	r25, 0x0E8C
    574e:	af 01       	movw	r20, r30
    5750:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <vfprintf>
    5754:	20 96       	adiw	r28, 0x00	; 0
    5756:	e2 e0       	ldi	r30, 0x02	; 2
    5758:	0c 94 a8 2e 	jmp	0x5d50	; 0x5d50 <__epilogue_restores__+0x20>

0000575c <puts>:
    575c:	0f 93       	push	r16
    575e:	1f 93       	push	r17
    5760:	cf 93       	push	r28
    5762:	df 93       	push	r29
    5764:	8c 01       	movw	r16, r24
    5766:	e0 91 8b 0e 	lds	r30, 0x0E8B
    576a:	f0 91 8c 0e 	lds	r31, 0x0E8C
    576e:	83 81       	ldd	r24, Z+3	; 0x03
    5770:	81 ff       	sbrs	r24, 1
    5772:	1a c0       	rjmp	.+52     	; 0x57a8 <puts+0x4c>
    5774:	c0 e0       	ldi	r28, 0x00	; 0
    5776:	d0 e0       	ldi	r29, 0x00	; 0
    5778:	05 c0       	rjmp	.+10     	; 0x5784 <puts+0x28>
    577a:	09 95       	icall
    577c:	00 97       	sbiw	r24, 0x00	; 0
    577e:	11 f0       	breq	.+4      	; 0x5784 <puts+0x28>
    5780:	cf ef       	ldi	r28, 0xFF	; 255
    5782:	df ef       	ldi	r29, 0xFF	; 255
    5784:	f8 01       	movw	r30, r16
    5786:	81 91       	ld	r24, Z+
    5788:	8f 01       	movw	r16, r30
    578a:	60 91 8b 0e 	lds	r22, 0x0E8B
    578e:	70 91 8c 0e 	lds	r23, 0x0E8C
    5792:	db 01       	movw	r26, r22
    5794:	18 96       	adiw	r26, 0x08	; 8
    5796:	ed 91       	ld	r30, X+
    5798:	fc 91       	ld	r31, X
    579a:	19 97       	sbiw	r26, 0x09	; 9
    579c:	88 23       	and	r24, r24
    579e:	69 f7       	brne	.-38     	; 0x577a <puts+0x1e>
    57a0:	8a e0       	ldi	r24, 0x0A	; 10
    57a2:	09 95       	icall
    57a4:	00 97       	sbiw	r24, 0x00	; 0
    57a6:	11 f0       	breq	.+4      	; 0x57ac <puts+0x50>
    57a8:	cf ef       	ldi	r28, 0xFF	; 255
    57aa:	df ef       	ldi	r29, 0xFF	; 255
    57ac:	ce 01       	movw	r24, r28
    57ae:	df 91       	pop	r29
    57b0:	cf 91       	pop	r28
    57b2:	1f 91       	pop	r17
    57b4:	0f 91       	pop	r16
    57b6:	08 95       	ret

000057b8 <sprintf>:
    57b8:	ae e0       	ldi	r26, 0x0E	; 14
    57ba:	b0 e0       	ldi	r27, 0x00	; 0
    57bc:	e2 ee       	ldi	r30, 0xE2	; 226
    57be:	fb e2       	ldi	r31, 0x2B	; 43
    57c0:	0c 94 8a 2e 	jmp	0x5d14	; 0x5d14 <__prologue_saves__+0x1c>
    57c4:	0d 89       	ldd	r16, Y+21	; 0x15
    57c6:	1e 89       	ldd	r17, Y+22	; 0x16
    57c8:	86 e0       	ldi	r24, 0x06	; 6
    57ca:	8c 83       	std	Y+4, r24	; 0x04
    57cc:	1a 83       	std	Y+2, r17	; 0x02
    57ce:	09 83       	std	Y+1, r16	; 0x01
    57d0:	8f ef       	ldi	r24, 0xFF	; 255
    57d2:	9f e7       	ldi	r25, 0x7F	; 127
    57d4:	9e 83       	std	Y+6, r25	; 0x06
    57d6:	8d 83       	std	Y+5, r24	; 0x05
    57d8:	ae 01       	movw	r20, r28
    57da:	47 5e       	subi	r20, 0xE7	; 231
    57dc:	5f 4f       	sbci	r21, 0xFF	; 255
    57de:	ce 01       	movw	r24, r28
    57e0:	01 96       	adiw	r24, 0x01	; 1
    57e2:	6f 89       	ldd	r22, Y+23	; 0x17
    57e4:	78 8d       	ldd	r23, Y+24	; 0x18
    57e6:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <vfprintf>
    57ea:	ef 81       	ldd	r30, Y+7	; 0x07
    57ec:	f8 85       	ldd	r31, Y+8	; 0x08
    57ee:	e0 0f       	add	r30, r16
    57f0:	f1 1f       	adc	r31, r17
    57f2:	10 82       	st	Z, r1
    57f4:	2e 96       	adiw	r28, 0x0e	; 14
    57f6:	e4 e0       	ldi	r30, 0x04	; 4
    57f8:	0c 94 a6 2e 	jmp	0x5d4c	; 0x5d4c <__epilogue_restores__+0x1c>

000057fc <vfprintf>:
    57fc:	ad e0       	ldi	r26, 0x0D	; 13
    57fe:	b0 e0       	ldi	r27, 0x00	; 0
    5800:	e4 e0       	ldi	r30, 0x04	; 4
    5802:	fc e2       	ldi	r31, 0x2C	; 44
    5804:	0c 94 7c 2e 	jmp	0x5cf8	; 0x5cf8 <__prologue_saves__>
    5808:	3c 01       	movw	r6, r24
    580a:	7d 87       	std	Y+13, r23	; 0x0d
    580c:	6c 87       	std	Y+12, r22	; 0x0c
    580e:	5a 01       	movw	r10, r20
    5810:	fc 01       	movw	r30, r24
    5812:	17 82       	std	Z+7, r1	; 0x07
    5814:	16 82       	std	Z+6, r1	; 0x06
    5816:	83 81       	ldd	r24, Z+3	; 0x03
    5818:	81 ff       	sbrs	r24, 1
    581a:	c8 c1       	rjmp	.+912    	; 0x5bac <vfprintf+0x3b0>
    581c:	2e 01       	movw	r4, r28
    581e:	08 94       	sec
    5820:	41 1c       	adc	r4, r1
    5822:	51 1c       	adc	r5, r1
    5824:	f3 01       	movw	r30, r6
    5826:	93 81       	ldd	r25, Z+3	; 0x03
    5828:	ec 85       	ldd	r30, Y+12	; 0x0c
    582a:	fd 85       	ldd	r31, Y+13	; 0x0d
    582c:	93 fd       	sbrc	r25, 3
    582e:	85 91       	lpm	r24, Z+
    5830:	93 ff       	sbrs	r25, 3
    5832:	81 91       	ld	r24, Z+
    5834:	fd 87       	std	Y+13, r31	; 0x0d
    5836:	ec 87       	std	Y+12, r30	; 0x0c
    5838:	88 23       	and	r24, r24
    583a:	09 f4       	brne	.+2      	; 0x583e <vfprintf+0x42>
    583c:	b3 c1       	rjmp	.+870    	; 0x5ba4 <vfprintf+0x3a8>
    583e:	85 32       	cpi	r24, 0x25	; 37
    5840:	41 f4       	brne	.+16     	; 0x5852 <vfprintf+0x56>
    5842:	93 fd       	sbrc	r25, 3
    5844:	85 91       	lpm	r24, Z+
    5846:	93 ff       	sbrs	r25, 3
    5848:	81 91       	ld	r24, Z+
    584a:	fd 87       	std	Y+13, r31	; 0x0d
    584c:	ec 87       	std	Y+12, r30	; 0x0c
    584e:	85 32       	cpi	r24, 0x25	; 37
    5850:	29 f4       	brne	.+10     	; 0x585c <vfprintf+0x60>
    5852:	90 e0       	ldi	r25, 0x00	; 0
    5854:	b3 01       	movw	r22, r6
    5856:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <fputc>
    585a:	e4 cf       	rjmp	.-56     	; 0x5824 <vfprintf+0x28>
    585c:	ff 24       	eor	r15, r15
    585e:	ee 24       	eor	r14, r14
    5860:	10 e0       	ldi	r17, 0x00	; 0
    5862:	10 32       	cpi	r17, 0x20	; 32
    5864:	b0 f4       	brcc	.+44     	; 0x5892 <vfprintf+0x96>
    5866:	8b 32       	cpi	r24, 0x2B	; 43
    5868:	69 f0       	breq	.+26     	; 0x5884 <vfprintf+0x88>
    586a:	8c 32       	cpi	r24, 0x2C	; 44
    586c:	28 f4       	brcc	.+10     	; 0x5878 <vfprintf+0x7c>
    586e:	80 32       	cpi	r24, 0x20	; 32
    5870:	51 f0       	breq	.+20     	; 0x5886 <vfprintf+0x8a>
    5872:	83 32       	cpi	r24, 0x23	; 35
    5874:	71 f4       	brne	.+28     	; 0x5892 <vfprintf+0x96>
    5876:	0b c0       	rjmp	.+22     	; 0x588e <vfprintf+0x92>
    5878:	8d 32       	cpi	r24, 0x2D	; 45
    587a:	39 f0       	breq	.+14     	; 0x588a <vfprintf+0x8e>
    587c:	80 33       	cpi	r24, 0x30	; 48
    587e:	49 f4       	brne	.+18     	; 0x5892 <vfprintf+0x96>
    5880:	11 60       	ori	r17, 0x01	; 1
    5882:	2c c0       	rjmp	.+88     	; 0x58dc <vfprintf+0xe0>
    5884:	12 60       	ori	r17, 0x02	; 2
    5886:	14 60       	ori	r17, 0x04	; 4
    5888:	29 c0       	rjmp	.+82     	; 0x58dc <vfprintf+0xe0>
    588a:	18 60       	ori	r17, 0x08	; 8
    588c:	27 c0       	rjmp	.+78     	; 0x58dc <vfprintf+0xe0>
    588e:	10 61       	ori	r17, 0x10	; 16
    5890:	25 c0       	rjmp	.+74     	; 0x58dc <vfprintf+0xe0>
    5892:	17 fd       	sbrc	r17, 7
    5894:	2e c0       	rjmp	.+92     	; 0x58f2 <vfprintf+0xf6>
    5896:	28 2f       	mov	r18, r24
    5898:	20 53       	subi	r18, 0x30	; 48
    589a:	2a 30       	cpi	r18, 0x0A	; 10
    589c:	98 f4       	brcc	.+38     	; 0x58c4 <vfprintf+0xc8>
    589e:	16 ff       	sbrs	r17, 6
    58a0:	08 c0       	rjmp	.+16     	; 0x58b2 <vfprintf+0xb6>
    58a2:	8f 2d       	mov	r24, r15
    58a4:	88 0f       	add	r24, r24
    58a6:	f8 2e       	mov	r15, r24
    58a8:	ff 0c       	add	r15, r15
    58aa:	ff 0c       	add	r15, r15
    58ac:	f8 0e       	add	r15, r24
    58ae:	f2 0e       	add	r15, r18
    58b0:	15 c0       	rjmp	.+42     	; 0x58dc <vfprintf+0xe0>
    58b2:	8e 2d       	mov	r24, r14
    58b4:	88 0f       	add	r24, r24
    58b6:	e8 2e       	mov	r14, r24
    58b8:	ee 0c       	add	r14, r14
    58ba:	ee 0c       	add	r14, r14
    58bc:	e8 0e       	add	r14, r24
    58be:	e2 0e       	add	r14, r18
    58c0:	10 62       	ori	r17, 0x20	; 32
    58c2:	0c c0       	rjmp	.+24     	; 0x58dc <vfprintf+0xe0>
    58c4:	8e 32       	cpi	r24, 0x2E	; 46
    58c6:	21 f4       	brne	.+8      	; 0x58d0 <vfprintf+0xd4>
    58c8:	16 fd       	sbrc	r17, 6
    58ca:	6c c1       	rjmp	.+728    	; 0x5ba4 <vfprintf+0x3a8>
    58cc:	10 64       	ori	r17, 0x40	; 64
    58ce:	06 c0       	rjmp	.+12     	; 0x58dc <vfprintf+0xe0>
    58d0:	8c 36       	cpi	r24, 0x6C	; 108
    58d2:	11 f4       	brne	.+4      	; 0x58d8 <vfprintf+0xdc>
    58d4:	10 68       	ori	r17, 0x80	; 128
    58d6:	02 c0       	rjmp	.+4      	; 0x58dc <vfprintf+0xe0>
    58d8:	88 36       	cpi	r24, 0x68	; 104
    58da:	59 f4       	brne	.+22     	; 0x58f2 <vfprintf+0xf6>
    58dc:	ec 85       	ldd	r30, Y+12	; 0x0c
    58de:	fd 85       	ldd	r31, Y+13	; 0x0d
    58e0:	93 fd       	sbrc	r25, 3
    58e2:	85 91       	lpm	r24, Z+
    58e4:	93 ff       	sbrs	r25, 3
    58e6:	81 91       	ld	r24, Z+
    58e8:	fd 87       	std	Y+13, r31	; 0x0d
    58ea:	ec 87       	std	Y+12, r30	; 0x0c
    58ec:	88 23       	and	r24, r24
    58ee:	09 f0       	breq	.+2      	; 0x58f2 <vfprintf+0xf6>
    58f0:	b8 cf       	rjmp	.-144    	; 0x5862 <vfprintf+0x66>
    58f2:	98 2f       	mov	r25, r24
    58f4:	95 54       	subi	r25, 0x45	; 69
    58f6:	93 30       	cpi	r25, 0x03	; 3
    58f8:	18 f0       	brcs	.+6      	; 0x5900 <vfprintf+0x104>
    58fa:	90 52       	subi	r25, 0x20	; 32
    58fc:	93 30       	cpi	r25, 0x03	; 3
    58fe:	38 f4       	brcc	.+14     	; 0x590e <vfprintf+0x112>
    5900:	24 e0       	ldi	r18, 0x04	; 4
    5902:	30 e0       	ldi	r19, 0x00	; 0
    5904:	a2 0e       	add	r10, r18
    5906:	b3 1e       	adc	r11, r19
    5908:	3f e3       	ldi	r19, 0x3F	; 63
    590a:	39 83       	std	Y+1, r19	; 0x01
    590c:	0f c0       	rjmp	.+30     	; 0x592c <vfprintf+0x130>
    590e:	83 36       	cpi	r24, 0x63	; 99
    5910:	31 f0       	breq	.+12     	; 0x591e <vfprintf+0x122>
    5912:	83 37       	cpi	r24, 0x73	; 115
    5914:	81 f0       	breq	.+32     	; 0x5936 <vfprintf+0x13a>
    5916:	83 35       	cpi	r24, 0x53	; 83
    5918:	09 f0       	breq	.+2      	; 0x591c <vfprintf+0x120>
    591a:	5a c0       	rjmp	.+180    	; 0x59d0 <vfprintf+0x1d4>
    591c:	22 c0       	rjmp	.+68     	; 0x5962 <vfprintf+0x166>
    591e:	f5 01       	movw	r30, r10
    5920:	80 81       	ld	r24, Z
    5922:	89 83       	std	Y+1, r24	; 0x01
    5924:	22 e0       	ldi	r18, 0x02	; 2
    5926:	30 e0       	ldi	r19, 0x00	; 0
    5928:	a2 0e       	add	r10, r18
    592a:	b3 1e       	adc	r11, r19
    592c:	21 e0       	ldi	r18, 0x01	; 1
    592e:	c2 2e       	mov	r12, r18
    5930:	d1 2c       	mov	r13, r1
    5932:	42 01       	movw	r8, r4
    5934:	14 c0       	rjmp	.+40     	; 0x595e <vfprintf+0x162>
    5936:	92 e0       	ldi	r25, 0x02	; 2
    5938:	29 2e       	mov	r2, r25
    593a:	31 2c       	mov	r3, r1
    593c:	2a 0c       	add	r2, r10
    593e:	3b 1c       	adc	r3, r11
    5940:	f5 01       	movw	r30, r10
    5942:	80 80       	ld	r8, Z
    5944:	91 80       	ldd	r9, Z+1	; 0x01
    5946:	16 ff       	sbrs	r17, 6
    5948:	03 c0       	rjmp	.+6      	; 0x5950 <vfprintf+0x154>
    594a:	6f 2d       	mov	r22, r15
    594c:	70 e0       	ldi	r23, 0x00	; 0
    594e:	02 c0       	rjmp	.+4      	; 0x5954 <vfprintf+0x158>
    5950:	6f ef       	ldi	r22, 0xFF	; 255
    5952:	7f ef       	ldi	r23, 0xFF	; 255
    5954:	c4 01       	movw	r24, r8
    5956:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <strnlen>
    595a:	6c 01       	movw	r12, r24
    595c:	51 01       	movw	r10, r2
    595e:	1f 77       	andi	r17, 0x7F	; 127
    5960:	15 c0       	rjmp	.+42     	; 0x598c <vfprintf+0x190>
    5962:	82 e0       	ldi	r24, 0x02	; 2
    5964:	28 2e       	mov	r2, r24
    5966:	31 2c       	mov	r3, r1
    5968:	2a 0c       	add	r2, r10
    596a:	3b 1c       	adc	r3, r11
    596c:	f5 01       	movw	r30, r10
    596e:	80 80       	ld	r8, Z
    5970:	91 80       	ldd	r9, Z+1	; 0x01
    5972:	16 ff       	sbrs	r17, 6
    5974:	03 c0       	rjmp	.+6      	; 0x597c <vfprintf+0x180>
    5976:	6f 2d       	mov	r22, r15
    5978:	70 e0       	ldi	r23, 0x00	; 0
    597a:	02 c0       	rjmp	.+4      	; 0x5980 <vfprintf+0x184>
    597c:	6f ef       	ldi	r22, 0xFF	; 255
    597e:	7f ef       	ldi	r23, 0xFF	; 255
    5980:	c4 01       	movw	r24, r8
    5982:	0e 94 dc 2d 	call	0x5bb8	; 0x5bb8 <strnlen_P>
    5986:	6c 01       	movw	r12, r24
    5988:	10 68       	ori	r17, 0x80	; 128
    598a:	51 01       	movw	r10, r2
    598c:	13 fd       	sbrc	r17, 3
    598e:	1c c0       	rjmp	.+56     	; 0x59c8 <vfprintf+0x1cc>
    5990:	06 c0       	rjmp	.+12     	; 0x599e <vfprintf+0x1a2>
    5992:	80 e2       	ldi	r24, 0x20	; 32
    5994:	90 e0       	ldi	r25, 0x00	; 0
    5996:	b3 01       	movw	r22, r6
    5998:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <fputc>
    599c:	ea 94       	dec	r14
    599e:	8e 2d       	mov	r24, r14
    59a0:	90 e0       	ldi	r25, 0x00	; 0
    59a2:	c8 16       	cp	r12, r24
    59a4:	d9 06       	cpc	r13, r25
    59a6:	a8 f3       	brcs	.-22     	; 0x5992 <vfprintf+0x196>
    59a8:	0f c0       	rjmp	.+30     	; 0x59c8 <vfprintf+0x1cc>
    59aa:	f4 01       	movw	r30, r8
    59ac:	17 fd       	sbrc	r17, 7
    59ae:	85 91       	lpm	r24, Z+
    59b0:	17 ff       	sbrs	r17, 7
    59b2:	81 91       	ld	r24, Z+
    59b4:	4f 01       	movw	r8, r30
    59b6:	90 e0       	ldi	r25, 0x00	; 0
    59b8:	b3 01       	movw	r22, r6
    59ba:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <fputc>
    59be:	e1 10       	cpse	r14, r1
    59c0:	ea 94       	dec	r14
    59c2:	08 94       	sec
    59c4:	c1 08       	sbc	r12, r1
    59c6:	d1 08       	sbc	r13, r1
    59c8:	c1 14       	cp	r12, r1
    59ca:	d1 04       	cpc	r13, r1
    59cc:	71 f7       	brne	.-36     	; 0x59aa <vfprintf+0x1ae>
    59ce:	e7 c0       	rjmp	.+462    	; 0x5b9e <vfprintf+0x3a2>
    59d0:	84 36       	cpi	r24, 0x64	; 100
    59d2:	11 f0       	breq	.+4      	; 0x59d8 <vfprintf+0x1dc>
    59d4:	89 36       	cpi	r24, 0x69	; 105
    59d6:	51 f5       	brne	.+84     	; 0x5a2c <vfprintf+0x230>
    59d8:	f5 01       	movw	r30, r10
    59da:	17 ff       	sbrs	r17, 7
    59dc:	07 c0       	rjmp	.+14     	; 0x59ec <vfprintf+0x1f0>
    59de:	80 81       	ld	r24, Z
    59e0:	91 81       	ldd	r25, Z+1	; 0x01
    59e2:	a2 81       	ldd	r26, Z+2	; 0x02
    59e4:	b3 81       	ldd	r27, Z+3	; 0x03
    59e6:	24 e0       	ldi	r18, 0x04	; 4
    59e8:	30 e0       	ldi	r19, 0x00	; 0
    59ea:	08 c0       	rjmp	.+16     	; 0x59fc <vfprintf+0x200>
    59ec:	80 81       	ld	r24, Z
    59ee:	91 81       	ldd	r25, Z+1	; 0x01
    59f0:	aa 27       	eor	r26, r26
    59f2:	97 fd       	sbrc	r25, 7
    59f4:	a0 95       	com	r26
    59f6:	ba 2f       	mov	r27, r26
    59f8:	22 e0       	ldi	r18, 0x02	; 2
    59fa:	30 e0       	ldi	r19, 0x00	; 0
    59fc:	a2 0e       	add	r10, r18
    59fe:	b3 1e       	adc	r11, r19
    5a00:	01 2f       	mov	r16, r17
    5a02:	0f 76       	andi	r16, 0x6F	; 111
    5a04:	b7 ff       	sbrs	r27, 7
    5a06:	08 c0       	rjmp	.+16     	; 0x5a18 <vfprintf+0x21c>
    5a08:	b0 95       	com	r27
    5a0a:	a0 95       	com	r26
    5a0c:	90 95       	com	r25
    5a0e:	81 95       	neg	r24
    5a10:	9f 4f       	sbci	r25, 0xFF	; 255
    5a12:	af 4f       	sbci	r26, 0xFF	; 255
    5a14:	bf 4f       	sbci	r27, 0xFF	; 255
    5a16:	00 68       	ori	r16, 0x80	; 128
    5a18:	bc 01       	movw	r22, r24
    5a1a:	cd 01       	movw	r24, r26
    5a1c:	a2 01       	movw	r20, r4
    5a1e:	2a e0       	ldi	r18, 0x0A	; 10
    5a20:	30 e0       	ldi	r19, 0x00	; 0
    5a22:	0e 94 1e 2e 	call	0x5c3c	; 0x5c3c <__ultoa_invert>
    5a26:	d8 2e       	mov	r13, r24
    5a28:	d4 18       	sub	r13, r4
    5a2a:	3f c0       	rjmp	.+126    	; 0x5aaa <vfprintf+0x2ae>
    5a2c:	85 37       	cpi	r24, 0x75	; 117
    5a2e:	21 f4       	brne	.+8      	; 0x5a38 <vfprintf+0x23c>
    5a30:	1f 7e       	andi	r17, 0xEF	; 239
    5a32:	2a e0       	ldi	r18, 0x0A	; 10
    5a34:	30 e0       	ldi	r19, 0x00	; 0
    5a36:	20 c0       	rjmp	.+64     	; 0x5a78 <vfprintf+0x27c>
    5a38:	19 7f       	andi	r17, 0xF9	; 249
    5a3a:	8f 36       	cpi	r24, 0x6F	; 111
    5a3c:	a9 f0       	breq	.+42     	; 0x5a68 <vfprintf+0x26c>
    5a3e:	80 37       	cpi	r24, 0x70	; 112
    5a40:	20 f4       	brcc	.+8      	; 0x5a4a <vfprintf+0x24e>
    5a42:	88 35       	cpi	r24, 0x58	; 88
    5a44:	09 f0       	breq	.+2      	; 0x5a48 <vfprintf+0x24c>
    5a46:	ae c0       	rjmp	.+348    	; 0x5ba4 <vfprintf+0x3a8>
    5a48:	0b c0       	rjmp	.+22     	; 0x5a60 <vfprintf+0x264>
    5a4a:	80 37       	cpi	r24, 0x70	; 112
    5a4c:	21 f0       	breq	.+8      	; 0x5a56 <vfprintf+0x25a>
    5a4e:	88 37       	cpi	r24, 0x78	; 120
    5a50:	09 f0       	breq	.+2      	; 0x5a54 <vfprintf+0x258>
    5a52:	a8 c0       	rjmp	.+336    	; 0x5ba4 <vfprintf+0x3a8>
    5a54:	01 c0       	rjmp	.+2      	; 0x5a58 <vfprintf+0x25c>
    5a56:	10 61       	ori	r17, 0x10	; 16
    5a58:	14 ff       	sbrs	r17, 4
    5a5a:	09 c0       	rjmp	.+18     	; 0x5a6e <vfprintf+0x272>
    5a5c:	14 60       	ori	r17, 0x04	; 4
    5a5e:	07 c0       	rjmp	.+14     	; 0x5a6e <vfprintf+0x272>
    5a60:	14 ff       	sbrs	r17, 4
    5a62:	08 c0       	rjmp	.+16     	; 0x5a74 <vfprintf+0x278>
    5a64:	16 60       	ori	r17, 0x06	; 6
    5a66:	06 c0       	rjmp	.+12     	; 0x5a74 <vfprintf+0x278>
    5a68:	28 e0       	ldi	r18, 0x08	; 8
    5a6a:	30 e0       	ldi	r19, 0x00	; 0
    5a6c:	05 c0       	rjmp	.+10     	; 0x5a78 <vfprintf+0x27c>
    5a6e:	20 e1       	ldi	r18, 0x10	; 16
    5a70:	30 e0       	ldi	r19, 0x00	; 0
    5a72:	02 c0       	rjmp	.+4      	; 0x5a78 <vfprintf+0x27c>
    5a74:	20 e1       	ldi	r18, 0x10	; 16
    5a76:	32 e0       	ldi	r19, 0x02	; 2
    5a78:	f5 01       	movw	r30, r10
    5a7a:	17 ff       	sbrs	r17, 7
    5a7c:	07 c0       	rjmp	.+14     	; 0x5a8c <vfprintf+0x290>
    5a7e:	60 81       	ld	r22, Z
    5a80:	71 81       	ldd	r23, Z+1	; 0x01
    5a82:	82 81       	ldd	r24, Z+2	; 0x02
    5a84:	93 81       	ldd	r25, Z+3	; 0x03
    5a86:	44 e0       	ldi	r20, 0x04	; 4
    5a88:	50 e0       	ldi	r21, 0x00	; 0
    5a8a:	06 c0       	rjmp	.+12     	; 0x5a98 <vfprintf+0x29c>
    5a8c:	60 81       	ld	r22, Z
    5a8e:	71 81       	ldd	r23, Z+1	; 0x01
    5a90:	80 e0       	ldi	r24, 0x00	; 0
    5a92:	90 e0       	ldi	r25, 0x00	; 0
    5a94:	42 e0       	ldi	r20, 0x02	; 2
    5a96:	50 e0       	ldi	r21, 0x00	; 0
    5a98:	a4 0e       	add	r10, r20
    5a9a:	b5 1e       	adc	r11, r21
    5a9c:	a2 01       	movw	r20, r4
    5a9e:	0e 94 1e 2e 	call	0x5c3c	; 0x5c3c <__ultoa_invert>
    5aa2:	d8 2e       	mov	r13, r24
    5aa4:	d4 18       	sub	r13, r4
    5aa6:	01 2f       	mov	r16, r17
    5aa8:	0f 77       	andi	r16, 0x7F	; 127
    5aaa:	06 ff       	sbrs	r16, 6
    5aac:	09 c0       	rjmp	.+18     	; 0x5ac0 <vfprintf+0x2c4>
    5aae:	0e 7f       	andi	r16, 0xFE	; 254
    5ab0:	df 14       	cp	r13, r15
    5ab2:	30 f4       	brcc	.+12     	; 0x5ac0 <vfprintf+0x2c4>
    5ab4:	04 ff       	sbrs	r16, 4
    5ab6:	06 c0       	rjmp	.+12     	; 0x5ac4 <vfprintf+0x2c8>
    5ab8:	02 fd       	sbrc	r16, 2
    5aba:	04 c0       	rjmp	.+8      	; 0x5ac4 <vfprintf+0x2c8>
    5abc:	0f 7e       	andi	r16, 0xEF	; 239
    5abe:	02 c0       	rjmp	.+4      	; 0x5ac4 <vfprintf+0x2c8>
    5ac0:	1d 2d       	mov	r17, r13
    5ac2:	01 c0       	rjmp	.+2      	; 0x5ac6 <vfprintf+0x2ca>
    5ac4:	1f 2d       	mov	r17, r15
    5ac6:	80 2f       	mov	r24, r16
    5ac8:	90 e0       	ldi	r25, 0x00	; 0
    5aca:	04 ff       	sbrs	r16, 4
    5acc:	0c c0       	rjmp	.+24     	; 0x5ae6 <vfprintf+0x2ea>
    5ace:	fe 01       	movw	r30, r28
    5ad0:	ed 0d       	add	r30, r13
    5ad2:	f1 1d       	adc	r31, r1
    5ad4:	20 81       	ld	r18, Z
    5ad6:	20 33       	cpi	r18, 0x30	; 48
    5ad8:	11 f4       	brne	.+4      	; 0x5ade <vfprintf+0x2e2>
    5ada:	09 7e       	andi	r16, 0xE9	; 233
    5adc:	09 c0       	rjmp	.+18     	; 0x5af0 <vfprintf+0x2f4>
    5ade:	02 ff       	sbrs	r16, 2
    5ae0:	06 c0       	rjmp	.+12     	; 0x5aee <vfprintf+0x2f2>
    5ae2:	1e 5f       	subi	r17, 0xFE	; 254
    5ae4:	05 c0       	rjmp	.+10     	; 0x5af0 <vfprintf+0x2f4>
    5ae6:	86 78       	andi	r24, 0x86	; 134
    5ae8:	90 70       	andi	r25, 0x00	; 0
    5aea:	00 97       	sbiw	r24, 0x00	; 0
    5aec:	09 f0       	breq	.+2      	; 0x5af0 <vfprintf+0x2f4>
    5aee:	1f 5f       	subi	r17, 0xFF	; 255
    5af0:	80 2e       	mov	r8, r16
    5af2:	99 24       	eor	r9, r9
    5af4:	03 fd       	sbrc	r16, 3
    5af6:	12 c0       	rjmp	.+36     	; 0x5b1c <vfprintf+0x320>
    5af8:	00 ff       	sbrs	r16, 0
    5afa:	0d c0       	rjmp	.+26     	; 0x5b16 <vfprintf+0x31a>
    5afc:	fd 2c       	mov	r15, r13
    5afe:	1e 15       	cp	r17, r14
    5b00:	50 f4       	brcc	.+20     	; 0x5b16 <vfprintf+0x31a>
    5b02:	fe 0c       	add	r15, r14
    5b04:	f1 1a       	sub	r15, r17
    5b06:	1e 2d       	mov	r17, r14
    5b08:	06 c0       	rjmp	.+12     	; 0x5b16 <vfprintf+0x31a>
    5b0a:	80 e2       	ldi	r24, 0x20	; 32
    5b0c:	90 e0       	ldi	r25, 0x00	; 0
    5b0e:	b3 01       	movw	r22, r6
    5b10:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <fputc>
    5b14:	1f 5f       	subi	r17, 0xFF	; 255
    5b16:	1e 15       	cp	r17, r14
    5b18:	c0 f3       	brcs	.-16     	; 0x5b0a <vfprintf+0x30e>
    5b1a:	04 c0       	rjmp	.+8      	; 0x5b24 <vfprintf+0x328>
    5b1c:	1e 15       	cp	r17, r14
    5b1e:	10 f4       	brcc	.+4      	; 0x5b24 <vfprintf+0x328>
    5b20:	e1 1a       	sub	r14, r17
    5b22:	01 c0       	rjmp	.+2      	; 0x5b26 <vfprintf+0x32a>
    5b24:	ee 24       	eor	r14, r14
    5b26:	84 fe       	sbrs	r8, 4
    5b28:	0f c0       	rjmp	.+30     	; 0x5b48 <vfprintf+0x34c>
    5b2a:	80 e3       	ldi	r24, 0x30	; 48
    5b2c:	90 e0       	ldi	r25, 0x00	; 0
    5b2e:	b3 01       	movw	r22, r6
    5b30:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <fputc>
    5b34:	82 fe       	sbrs	r8, 2
    5b36:	1f c0       	rjmp	.+62     	; 0x5b76 <vfprintf+0x37a>
    5b38:	81 fe       	sbrs	r8, 1
    5b3a:	03 c0       	rjmp	.+6      	; 0x5b42 <vfprintf+0x346>
    5b3c:	88 e5       	ldi	r24, 0x58	; 88
    5b3e:	90 e0       	ldi	r25, 0x00	; 0
    5b40:	10 c0       	rjmp	.+32     	; 0x5b62 <vfprintf+0x366>
    5b42:	88 e7       	ldi	r24, 0x78	; 120
    5b44:	90 e0       	ldi	r25, 0x00	; 0
    5b46:	0d c0       	rjmp	.+26     	; 0x5b62 <vfprintf+0x366>
    5b48:	c4 01       	movw	r24, r8
    5b4a:	86 78       	andi	r24, 0x86	; 134
    5b4c:	90 70       	andi	r25, 0x00	; 0
    5b4e:	00 97       	sbiw	r24, 0x00	; 0
    5b50:	91 f0       	breq	.+36     	; 0x5b76 <vfprintf+0x37a>
    5b52:	81 fc       	sbrc	r8, 1
    5b54:	02 c0       	rjmp	.+4      	; 0x5b5a <vfprintf+0x35e>
    5b56:	80 e2       	ldi	r24, 0x20	; 32
    5b58:	01 c0       	rjmp	.+2      	; 0x5b5c <vfprintf+0x360>
    5b5a:	8b e2       	ldi	r24, 0x2B	; 43
    5b5c:	07 fd       	sbrc	r16, 7
    5b5e:	8d e2       	ldi	r24, 0x2D	; 45
    5b60:	90 e0       	ldi	r25, 0x00	; 0
    5b62:	b3 01       	movw	r22, r6
    5b64:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <fputc>
    5b68:	06 c0       	rjmp	.+12     	; 0x5b76 <vfprintf+0x37a>
    5b6a:	80 e3       	ldi	r24, 0x30	; 48
    5b6c:	90 e0       	ldi	r25, 0x00	; 0
    5b6e:	b3 01       	movw	r22, r6
    5b70:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <fputc>
    5b74:	fa 94       	dec	r15
    5b76:	df 14       	cp	r13, r15
    5b78:	c0 f3       	brcs	.-16     	; 0x5b6a <vfprintf+0x36e>
    5b7a:	da 94       	dec	r13
    5b7c:	f2 01       	movw	r30, r4
    5b7e:	ed 0d       	add	r30, r13
    5b80:	f1 1d       	adc	r31, r1
    5b82:	80 81       	ld	r24, Z
    5b84:	90 e0       	ldi	r25, 0x00	; 0
    5b86:	b3 01       	movw	r22, r6
    5b88:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <fputc>
    5b8c:	dd 20       	and	r13, r13
    5b8e:	a9 f7       	brne	.-22     	; 0x5b7a <vfprintf+0x37e>
    5b90:	06 c0       	rjmp	.+12     	; 0x5b9e <vfprintf+0x3a2>
    5b92:	80 e2       	ldi	r24, 0x20	; 32
    5b94:	90 e0       	ldi	r25, 0x00	; 0
    5b96:	b3 01       	movw	r22, r6
    5b98:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <fputc>
    5b9c:	ea 94       	dec	r14
    5b9e:	ee 20       	and	r14, r14
    5ba0:	c1 f7       	brne	.-16     	; 0x5b92 <vfprintf+0x396>
    5ba2:	40 ce       	rjmp	.-896    	; 0x5824 <vfprintf+0x28>
    5ba4:	f3 01       	movw	r30, r6
    5ba6:	86 81       	ldd	r24, Z+6	; 0x06
    5ba8:	97 81       	ldd	r25, Z+7	; 0x07
    5baa:	02 c0       	rjmp	.+4      	; 0x5bb0 <vfprintf+0x3b4>
    5bac:	8f ef       	ldi	r24, 0xFF	; 255
    5bae:	9f ef       	ldi	r25, 0xFF	; 255
    5bb0:	2d 96       	adiw	r28, 0x0d	; 13
    5bb2:	e2 e1       	ldi	r30, 0x12	; 18
    5bb4:	0c 94 98 2e 	jmp	0x5d30	; 0x5d30 <__epilogue_restores__>

00005bb8 <strnlen_P>:
    5bb8:	fc 01       	movw	r30, r24
    5bba:	05 90       	lpm	r0, Z+
    5bbc:	61 50       	subi	r22, 0x01	; 1
    5bbe:	70 40       	sbci	r23, 0x00	; 0
    5bc0:	01 10       	cpse	r0, r1
    5bc2:	d8 f7       	brcc	.-10     	; 0x5bba <strnlen_P+0x2>
    5bc4:	80 95       	com	r24
    5bc6:	90 95       	com	r25
    5bc8:	8e 0f       	add	r24, r30
    5bca:	9f 1f       	adc	r25, r31
    5bcc:	08 95       	ret

00005bce <strnlen>:
    5bce:	fc 01       	movw	r30, r24
    5bd0:	61 50       	subi	r22, 0x01	; 1
    5bd2:	70 40       	sbci	r23, 0x00	; 0
    5bd4:	01 90       	ld	r0, Z+
    5bd6:	01 10       	cpse	r0, r1
    5bd8:	d8 f7       	brcc	.-10     	; 0x5bd0 <strnlen+0x2>
    5bda:	80 95       	com	r24
    5bdc:	90 95       	com	r25
    5bde:	8e 0f       	add	r24, r30
    5be0:	9f 1f       	adc	r25, r31
    5be2:	08 95       	ret

00005be4 <fputc>:
    5be4:	0f 93       	push	r16
    5be6:	1f 93       	push	r17
    5be8:	cf 93       	push	r28
    5bea:	df 93       	push	r29
    5bec:	8c 01       	movw	r16, r24
    5bee:	eb 01       	movw	r28, r22
    5bf0:	8b 81       	ldd	r24, Y+3	; 0x03
    5bf2:	81 ff       	sbrs	r24, 1
    5bf4:	1b c0       	rjmp	.+54     	; 0x5c2c <fputc+0x48>
    5bf6:	82 ff       	sbrs	r24, 2
    5bf8:	0d c0       	rjmp	.+26     	; 0x5c14 <fputc+0x30>
    5bfa:	2e 81       	ldd	r18, Y+6	; 0x06
    5bfc:	3f 81       	ldd	r19, Y+7	; 0x07
    5bfe:	8c 81       	ldd	r24, Y+4	; 0x04
    5c00:	9d 81       	ldd	r25, Y+5	; 0x05
    5c02:	28 17       	cp	r18, r24
    5c04:	39 07       	cpc	r19, r25
    5c06:	64 f4       	brge	.+24     	; 0x5c20 <fputc+0x3c>
    5c08:	e8 81       	ld	r30, Y
    5c0a:	f9 81       	ldd	r31, Y+1	; 0x01
    5c0c:	01 93       	st	Z+, r16
    5c0e:	f9 83       	std	Y+1, r31	; 0x01
    5c10:	e8 83       	st	Y, r30
    5c12:	06 c0       	rjmp	.+12     	; 0x5c20 <fputc+0x3c>
    5c14:	e8 85       	ldd	r30, Y+8	; 0x08
    5c16:	f9 85       	ldd	r31, Y+9	; 0x09
    5c18:	80 2f       	mov	r24, r16
    5c1a:	09 95       	icall
    5c1c:	00 97       	sbiw	r24, 0x00	; 0
    5c1e:	31 f4       	brne	.+12     	; 0x5c2c <fputc+0x48>
    5c20:	8e 81       	ldd	r24, Y+6	; 0x06
    5c22:	9f 81       	ldd	r25, Y+7	; 0x07
    5c24:	01 96       	adiw	r24, 0x01	; 1
    5c26:	9f 83       	std	Y+7, r25	; 0x07
    5c28:	8e 83       	std	Y+6, r24	; 0x06
    5c2a:	02 c0       	rjmp	.+4      	; 0x5c30 <fputc+0x4c>
    5c2c:	0f ef       	ldi	r16, 0xFF	; 255
    5c2e:	1f ef       	ldi	r17, 0xFF	; 255
    5c30:	c8 01       	movw	r24, r16
    5c32:	df 91       	pop	r29
    5c34:	cf 91       	pop	r28
    5c36:	1f 91       	pop	r17
    5c38:	0f 91       	pop	r16
    5c3a:	08 95       	ret

00005c3c <__ultoa_invert>:
    5c3c:	fa 01       	movw	r30, r20
    5c3e:	aa 27       	eor	r26, r26
    5c40:	28 30       	cpi	r18, 0x08	; 8
    5c42:	51 f1       	breq	.+84     	; 0x5c98 <__ultoa_invert+0x5c>
    5c44:	20 31       	cpi	r18, 0x10	; 16
    5c46:	81 f1       	breq	.+96     	; 0x5ca8 <__ultoa_invert+0x6c>
    5c48:	e8 94       	clt
    5c4a:	6f 93       	push	r22
    5c4c:	6e 7f       	andi	r22, 0xFE	; 254
    5c4e:	6e 5f       	subi	r22, 0xFE	; 254
    5c50:	7f 4f       	sbci	r23, 0xFF	; 255
    5c52:	8f 4f       	sbci	r24, 0xFF	; 255
    5c54:	9f 4f       	sbci	r25, 0xFF	; 255
    5c56:	af 4f       	sbci	r26, 0xFF	; 255
    5c58:	b1 e0       	ldi	r27, 0x01	; 1
    5c5a:	3e d0       	rcall	.+124    	; 0x5cd8 <__ultoa_invert+0x9c>
    5c5c:	b4 e0       	ldi	r27, 0x04	; 4
    5c5e:	3c d0       	rcall	.+120    	; 0x5cd8 <__ultoa_invert+0x9c>
    5c60:	67 0f       	add	r22, r23
    5c62:	78 1f       	adc	r23, r24
    5c64:	89 1f       	adc	r24, r25
    5c66:	9a 1f       	adc	r25, r26
    5c68:	a1 1d       	adc	r26, r1
    5c6a:	68 0f       	add	r22, r24
    5c6c:	79 1f       	adc	r23, r25
    5c6e:	8a 1f       	adc	r24, r26
    5c70:	91 1d       	adc	r25, r1
    5c72:	a1 1d       	adc	r26, r1
    5c74:	6a 0f       	add	r22, r26
    5c76:	71 1d       	adc	r23, r1
    5c78:	81 1d       	adc	r24, r1
    5c7a:	91 1d       	adc	r25, r1
    5c7c:	a1 1d       	adc	r26, r1
    5c7e:	20 d0       	rcall	.+64     	; 0x5cc0 <__ultoa_invert+0x84>
    5c80:	09 f4       	brne	.+2      	; 0x5c84 <__ultoa_invert+0x48>
    5c82:	68 94       	set
    5c84:	3f 91       	pop	r19
    5c86:	2a e0       	ldi	r18, 0x0A	; 10
    5c88:	26 9f       	mul	r18, r22
    5c8a:	11 24       	eor	r1, r1
    5c8c:	30 19       	sub	r19, r0
    5c8e:	30 5d       	subi	r19, 0xD0	; 208
    5c90:	31 93       	st	Z+, r19
    5c92:	de f6       	brtc	.-74     	; 0x5c4a <__ultoa_invert+0xe>
    5c94:	cf 01       	movw	r24, r30
    5c96:	08 95       	ret
    5c98:	46 2f       	mov	r20, r22
    5c9a:	47 70       	andi	r20, 0x07	; 7
    5c9c:	40 5d       	subi	r20, 0xD0	; 208
    5c9e:	41 93       	st	Z+, r20
    5ca0:	b3 e0       	ldi	r27, 0x03	; 3
    5ca2:	0f d0       	rcall	.+30     	; 0x5cc2 <__ultoa_invert+0x86>
    5ca4:	c9 f7       	brne	.-14     	; 0x5c98 <__ultoa_invert+0x5c>
    5ca6:	f6 cf       	rjmp	.-20     	; 0x5c94 <__ultoa_invert+0x58>
    5ca8:	46 2f       	mov	r20, r22
    5caa:	4f 70       	andi	r20, 0x0F	; 15
    5cac:	40 5d       	subi	r20, 0xD0	; 208
    5cae:	4a 33       	cpi	r20, 0x3A	; 58
    5cb0:	18 f0       	brcs	.+6      	; 0x5cb8 <__ultoa_invert+0x7c>
    5cb2:	49 5d       	subi	r20, 0xD9	; 217
    5cb4:	31 fd       	sbrc	r19, 1
    5cb6:	40 52       	subi	r20, 0x20	; 32
    5cb8:	41 93       	st	Z+, r20
    5cba:	02 d0       	rcall	.+4      	; 0x5cc0 <__ultoa_invert+0x84>
    5cbc:	a9 f7       	brne	.-22     	; 0x5ca8 <__ultoa_invert+0x6c>
    5cbe:	ea cf       	rjmp	.-44     	; 0x5c94 <__ultoa_invert+0x58>
    5cc0:	b4 e0       	ldi	r27, 0x04	; 4
    5cc2:	a6 95       	lsr	r26
    5cc4:	97 95       	ror	r25
    5cc6:	87 95       	ror	r24
    5cc8:	77 95       	ror	r23
    5cca:	67 95       	ror	r22
    5ccc:	ba 95       	dec	r27
    5cce:	c9 f7       	brne	.-14     	; 0x5cc2 <__ultoa_invert+0x86>
    5cd0:	00 97       	sbiw	r24, 0x00	; 0
    5cd2:	61 05       	cpc	r22, r1
    5cd4:	71 05       	cpc	r23, r1
    5cd6:	08 95       	ret
    5cd8:	9b 01       	movw	r18, r22
    5cda:	ac 01       	movw	r20, r24
    5cdc:	0a 2e       	mov	r0, r26
    5cde:	06 94       	lsr	r0
    5ce0:	57 95       	ror	r21
    5ce2:	47 95       	ror	r20
    5ce4:	37 95       	ror	r19
    5ce6:	27 95       	ror	r18
    5ce8:	ba 95       	dec	r27
    5cea:	c9 f7       	brne	.-14     	; 0x5cde <__ultoa_invert+0xa2>
    5cec:	62 0f       	add	r22, r18
    5cee:	73 1f       	adc	r23, r19
    5cf0:	84 1f       	adc	r24, r20
    5cf2:	95 1f       	adc	r25, r21
    5cf4:	a0 1d       	adc	r26, r0
    5cf6:	08 95       	ret

00005cf8 <__prologue_saves__>:
    5cf8:	2f 92       	push	r2
    5cfa:	3f 92       	push	r3
    5cfc:	4f 92       	push	r4
    5cfe:	5f 92       	push	r5
    5d00:	6f 92       	push	r6
    5d02:	7f 92       	push	r7
    5d04:	8f 92       	push	r8
    5d06:	9f 92       	push	r9
    5d08:	af 92       	push	r10
    5d0a:	bf 92       	push	r11
    5d0c:	cf 92       	push	r12
    5d0e:	df 92       	push	r13
    5d10:	ef 92       	push	r14
    5d12:	ff 92       	push	r15
    5d14:	0f 93       	push	r16
    5d16:	1f 93       	push	r17
    5d18:	cf 93       	push	r28
    5d1a:	df 93       	push	r29
    5d1c:	cd b7       	in	r28, 0x3d	; 61
    5d1e:	de b7       	in	r29, 0x3e	; 62
    5d20:	ca 1b       	sub	r28, r26
    5d22:	db 0b       	sbc	r29, r27
    5d24:	0f b6       	in	r0, 0x3f	; 63
    5d26:	f8 94       	cli
    5d28:	de bf       	out	0x3e, r29	; 62
    5d2a:	0f be       	out	0x3f, r0	; 63
    5d2c:	cd bf       	out	0x3d, r28	; 61
    5d2e:	09 94       	ijmp

00005d30 <__epilogue_restores__>:
    5d30:	2a 88       	ldd	r2, Y+18	; 0x12
    5d32:	39 88       	ldd	r3, Y+17	; 0x11
    5d34:	48 88       	ldd	r4, Y+16	; 0x10
    5d36:	5f 84       	ldd	r5, Y+15	; 0x0f
    5d38:	6e 84       	ldd	r6, Y+14	; 0x0e
    5d3a:	7d 84       	ldd	r7, Y+13	; 0x0d
    5d3c:	8c 84       	ldd	r8, Y+12	; 0x0c
    5d3e:	9b 84       	ldd	r9, Y+11	; 0x0b
    5d40:	aa 84       	ldd	r10, Y+10	; 0x0a
    5d42:	b9 84       	ldd	r11, Y+9	; 0x09
    5d44:	c8 84       	ldd	r12, Y+8	; 0x08
    5d46:	df 80       	ldd	r13, Y+7	; 0x07
    5d48:	ee 80       	ldd	r14, Y+6	; 0x06
    5d4a:	fd 80       	ldd	r15, Y+5	; 0x05
    5d4c:	0c 81       	ldd	r16, Y+4	; 0x04
    5d4e:	1b 81       	ldd	r17, Y+3	; 0x03
    5d50:	aa 81       	ldd	r26, Y+2	; 0x02
    5d52:	b9 81       	ldd	r27, Y+1	; 0x01
    5d54:	ce 0f       	add	r28, r30
    5d56:	d1 1d       	adc	r29, r1
    5d58:	0f b6       	in	r0, 0x3f	; 63
    5d5a:	f8 94       	cli
    5d5c:	de bf       	out	0x3e, r29	; 62
    5d5e:	0f be       	out	0x3f, r0	; 63
    5d60:	cd bf       	out	0x3d, r28	; 61
    5d62:	ed 01       	movw	r28, r26
    5d64:	08 95       	ret

00005d66 <_exit>:
    5d66:	f8 94       	cli

00005d68 <__stop_program>:
    5d68:	ff cf       	rjmp	.-2      	; 0x5d68 <__stop_program>
