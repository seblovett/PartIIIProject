
DualOV7670.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000320  00800100  00005c90  00005d24  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005c90  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000a9a  00800420  00800420  00006044  2**0
                  ALLOC
  3 .stab         00000c84  00000000  00000000  00006044  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001b6  00000000  00000000  00006cc8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000260  00000000  00000000  00006e80  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000053ed  00000000  00000000  000070e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001429  00000000  00000000  0000c4cd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000020b9  00000000  00000000  0000d8f6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000010e8  00000000  00000000  0000f9b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000b8a  00000000  00000000  00010a98  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006b0d  00000000  00000000  00011622  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000138  00000000  00000000  0001812f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 82 05 	jmp	0xb04	; 0xb04 <__vector_1>
       8:	0c 94 ad 05 	jmp	0xb5a	; 0xb5a <__vector_2>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 c5 07 	jmp	0xf8a	; 0xf8a <__vector_16>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 3b 2a 	jmp	0x5476	; 0x5476 <__vector_26>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d0 e1       	ldi	r29, 0x10	; 16
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	14 e0       	ldi	r17, 0x04	; 4
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	e0 e9       	ldi	r30, 0x90	; 144
      90:	fc e5       	ldi	r31, 0x5C	; 92
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	a0 32       	cpi	r26, 0x20	; 32
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	1e e0       	ldi	r17, 0x0E	; 14
      a0:	a0 e2       	ldi	r26, 0x20	; 32
      a2:	b4 e0       	ldi	r27, 0x04	; 4
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	aa 3b       	cpi	r26, 0xBA	; 186
      aa:	b1 07       	cpc	r27, r17
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <main>
      b2:	0c 94 46 2e 	jmp	0x5c8c	; 0x5c8c <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <WriteBMPHeader>:
										};



FRESULT WriteBMPHeader(FIL *File)
{
      ba:	0f 93       	push	r16
      bc:	1f 93       	push	r17
      be:	cf 93       	push	r28
      c0:	df 93       	push	r29
      c2:	00 d0       	rcall	.+0      	; 0xc4 <WriteBMPHeader+0xa>
      c4:	00 d0       	rcall	.+0      	; 0xc6 <WriteBMPHeader+0xc>
      c6:	cd b7       	in	r28, 0x3d	; 61
      c8:	de b7       	in	r29, 0x3e	; 62
      ca:	8c 01       	movw	r16, r24
	uint32_t p;
	FRESULT f; 
	
	f_lseek(File, 0);
      cc:	40 e0       	ldi	r20, 0x00	; 0
      ce:	50 e0       	ldi	r21, 0x00	; 0
      d0:	ba 01       	movw	r22, r20
      d2:	0e 94 e7 20 	call	0x41ce	; 0x41ce <f_lseek>
	f = f_write(File, BMPHeader, BMPHEADERSIZE, &p);
      d6:	c8 01       	movw	r24, r16
      d8:	60 e0       	ldi	r22, 0x00	; 0
      da:	71 e0       	ldi	r23, 0x01	; 1
      dc:	2e e0       	ldi	r18, 0x0E	; 14
      de:	30 e0       	ldi	r19, 0x00	; 0
      e0:	40 e0       	ldi	r20, 0x00	; 0
      e2:	50 e0       	ldi	r21, 0x00	; 0
      e4:	8e 01       	movw	r16, r28
      e6:	0f 5f       	subi	r16, 0xFF	; 255
      e8:	1f 4f       	sbci	r17, 0xFF	; 255
      ea:	0e 94 c2 1d 	call	0x3b84	; 0x3b84 <f_write>
	
	return f;
}
      ee:	0f 90       	pop	r0
      f0:	0f 90       	pop	r0
      f2:	0f 90       	pop	r0
      f4:	0f 90       	pop	r0
      f6:	df 91       	pop	r29
      f8:	cf 91       	pop	r28
      fa:	1f 91       	pop	r17
      fc:	0f 91       	pop	r16
      fe:	08 95       	ret

00000100 <WriteDIBHeader>:

FRESULT WriteDIBHeader(FIL *File)
{
     100:	0f 93       	push	r16
     102:	1f 93       	push	r17
     104:	cf 93       	push	r28
     106:	df 93       	push	r29
     108:	00 d0       	rcall	.+0      	; 0x10a <WriteDIBHeader+0xa>
     10a:	00 d0       	rcall	.+0      	; 0x10c <WriteDIBHeader+0xc>
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
     110:	8c 01       	movw	r16, r24
	uint32_t p;
	FRESULT f;
	
	f_lseek(File, BMPHEADERSIZE);//place just after the bitmap header
     112:	4e e0       	ldi	r20, 0x0E	; 14
     114:	50 e0       	ldi	r21, 0x00	; 0
     116:	60 e0       	ldi	r22, 0x00	; 0
     118:	70 e0       	ldi	r23, 0x00	; 0
     11a:	0e 94 e7 20 	call	0x41ce	; 0x41ce <f_lseek>
	f = f_write(File, DIBHead, DIBHEADERSIZE, &p);
     11e:	c8 01       	movw	r24, r16
     120:	6e e0       	ldi	r22, 0x0E	; 14
     122:	71 e0       	ldi	r23, 0x01	; 1
     124:	2c e7       	ldi	r18, 0x7C	; 124
     126:	30 e0       	ldi	r19, 0x00	; 0
     128:	40 e0       	ldi	r20, 0x00	; 0
     12a:	50 e0       	ldi	r21, 0x00	; 0
     12c:	8e 01       	movw	r16, r28
     12e:	0f 5f       	subi	r16, 0xFF	; 255
     130:	1f 4f       	sbci	r17, 0xFF	; 255
     132:	0e 94 c2 1d 	call	0x3b84	; 0x3b84 <f_write>
	return f;
}
     136:	0f 90       	pop	r0
     138:	0f 90       	pop	r0
     13a:	0f 90       	pop	r0
     13c:	0f 90       	pop	r0
     13e:	df 91       	pop	r29
     140:	cf 91       	pop	r28
     142:	1f 91       	pop	r17
     144:	0f 91       	pop	r16
     146:	08 95       	ret

00000148 <IO_Init>:
#include "Config.h"
#include <avr/io.h>
void IO_Init(void)
{
	//initialise timer 0 to interrupt every 10 ms
	TIMSK0 |= (1 << OCIE0A);
     148:	ee e6       	ldi	r30, 0x6E	; 110
     14a:	f0 e0       	ldi	r31, 0x00	; 0
     14c:	80 81       	ld	r24, Z
     14e:	82 60       	ori	r24, 0x02	; 2
     150:	80 83       	st	Z, r24
	TCCR0A |= (1 << WGM01);
     152:	84 b5       	in	r24, 0x24	; 36
     154:	82 60       	ori	r24, 0x02	; 2
     156:	84 bd       	out	0x24, r24	; 36
	OCR0A = 117; //10ms interrupt at 12MHz
     158:	85 e7       	ldi	r24, 0x75	; 117
     15a:	87 bd       	out	0x27, r24	; 39
	TCCR0B |= (1 << CS02) | (1 << CS00);
     15c:	85 b5       	in	r24, 0x25	; 37
     15e:	85 60       	ori	r24, 0x05	; 5
     160:	85 bd       	out	0x25, r24	; 37
	
	
	DDRA = 0x00;
     162:	11 b8       	out	0x01, r1	; 1
	//PORTB = 0xBF;
	DDRC = 0xFC;
     164:	8c ef       	ldi	r24, 0xFC	; 252
     166:	87 b9       	out	0x07, r24	; 7
	DDRD = 0xF2;
     168:	82 ef       	ldi	r24, 0xF2	; 242
     16a:	8a b9       	out	0x0a, r24	; 10
	
	
	
	//set int0 and int1 to trigger on falling edge
	EIMSK = (1 << INT0) | (1 << INT1);				//Enable INT0 and INT1
     16c:	83 e0       	ldi	r24, 0x03	; 3
     16e:	8d bb       	out	0x1d, r24	; 29
	EICRA = (1 << ISC01) | (1 << ISC11);			//Trigger INT0 and INT1 on the falling edge
     170:	8a e0       	ldi	r24, 0x0A	; 10
     172:	80 93 69 00 	sts	0x0069, r24
     176:	08 95       	ret

00000178 <power_off>:
}

static
void power_off (void)
{
	SPCR = 0;				/* Disable SPI function */
     178:	1c bc       	out	0x2c, r1	; 44
// 	DDRB  &= ~0b00110111;	/* Set SCK/MOSI/CS as hi-z, INS#/WP as pull-up */
// 	PORTB &= ~0b00000111;
// 	PORTB |=  0b00110000;


	PORTB = ~0b00010000;      // SS high
     17a:	8f ee       	ldi	r24, 0xEF	; 239
     17c:	85 b9       	out	0x05, r24	; 5
	DDRB =  ~(uint8_t)0b10110000;      // !SS,SCK and MOSI outputs
     17e:	8f e4       	ldi	r24, 0x4F	; 79
     180:	84 b9       	out	0x04, r24	; 4
// 	{	/* Remove this block if no socket power control */
// 		PORTE |= _BV(7);		/* Socket power off (PE7=high) */
// 		for (Timer1 = 20; Timer1; );	/* Wait for 20ms */
// 	}
}
     182:	08 95       	ret

00000184 <xchg_spi>:
static
BYTE xchg_spi (		/* Returns received data */
	BYTE dat		/* Data to be sent */
)
{
	SPDR = dat;
     184:	8e bd       	out	0x2e, r24	; 46
	loop_until_bit_is_set(SPSR, SPIF);
     186:	0d b4       	in	r0, 0x2d	; 45
     188:	07 fe       	sbrs	r0, 7
     18a:	fd cf       	rjmp	.-6      	; 0x186 <xchg_spi+0x2>
	return SPDR;
     18c:	8e b5       	in	r24, 0x2e	; 46
}
     18e:	08 95       	ret

00000190 <wait_ready>:
int wait_ready (void)	/* 1:OK, 0:Timeout */
{
	BYTE d;


	Timer2 = 50;	/* Wait for ready in timeout of 500ms */
     190:	82 e3       	ldi	r24, 0x32	; 50
     192:	80 93 20 04 	sts	0x0420, r24
	do
		d = xchg_spi(0xFF);
     196:	8f ef       	ldi	r24, 0xFF	; 255
     198:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	while (d != 0xFF && Timer2);
     19c:	8f 3f       	cpi	r24, 0xFF	; 255
     19e:	21 f0       	breq	.+8      	; 0x1a8 <wait_ready+0x18>
     1a0:	90 91 20 04 	lds	r25, 0x0420
     1a4:	99 23       	and	r25, r25
     1a6:	b9 f7       	brne	.-18     	; 0x196 <wait_ready+0x6>

	return (d == 0xFF) ? 1 : 0;
     1a8:	21 e0       	ldi	r18, 0x01	; 1
     1aa:	30 e0       	ldi	r19, 0x00	; 0
     1ac:	8f 3f       	cpi	r24, 0xFF	; 255
     1ae:	11 f0       	breq	.+4      	; 0x1b4 <wait_ready+0x24>
     1b0:	20 e0       	ldi	r18, 0x00	; 0
     1b2:	30 e0       	ldi	r19, 0x00	; 0
}
     1b4:	82 2f       	mov	r24, r18
     1b6:	93 2f       	mov	r25, r19
     1b8:	08 95       	ret

000001ba <deselect>:
/*-----------------------------------------------------------------------*/

static
void deselect (void)
{
	CS_HIGH();
     1ba:	2c 9a       	sbi	0x05, 4	; 5
	xchg_spi(0xFF);	/* Dummy clock (force DO hi-z for multiple slave SPI) */
     1bc:	8f ef       	ldi	r24, 0xFF	; 255
     1be:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
}
     1c2:	08 95       	ret

000001c4 <select>:
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:Successful, 0:Timeout */
{
	CS_LOW();
     1c4:	2c 98       	cbi	0x05, 4	; 5
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */
     1c6:	8f ef       	ldi	r24, 0xFF	; 255
     1c8:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>

	if (wait_ready()) return 1;	/* OK */
     1cc:	0e 94 c8 00 	call	0x190	; 0x190 <wait_ready>
     1d0:	00 97       	sbiw	r24, 0x00	; 0
     1d2:	29 f4       	brne	.+10     	; 0x1de <select+0x1a>
	deselect();
     1d4:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
	return 0;	/* Timeout */
     1d8:	80 e0       	ldi	r24, 0x00	; 0
     1da:	90 e0       	ldi	r25, 0x00	; 0
     1dc:	08 95       	ret
int select (void)	/* 1:Successful, 0:Timeout */
{
	CS_LOW();
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */

	if (wait_ready()) return 1;	/* OK */
     1de:	81 e0       	ldi	r24, 0x01	; 1
     1e0:	90 e0       	ldi	r25, 0x00	; 0
	deselect();
	return 0;	/* Timeout */
}
     1e2:	08 95       	ret

000001e4 <rcvr_datablock>:
static
int rcvr_datablock (
	BYTE *buff,			/* Data buffer to store received data */
	UINT btr			/* Byte count (must be multiple of 4) */
)
{
     1e4:	cf 92       	push	r12
     1e6:	df 92       	push	r13
     1e8:	ef 92       	push	r14
     1ea:	ff 92       	push	r15
     1ec:	cf 93       	push	r28
     1ee:	df 93       	push	r29
     1f0:	ec 01       	movw	r28, r24
     1f2:	6a 01       	movw	r12, r20
     1f4:	7b 01       	movw	r14, r22
	BYTE token;


	Timer1 = 20;
     1f6:	84 e1       	ldi	r24, 0x14	; 20
     1f8:	80 93 21 04 	sts	0x0421, r24
	do {							/* Wait for data packet in timeout of 200ms */
		token = xchg_spi(0xFF);
     1fc:	8f ef       	ldi	r24, 0xFF	; 255
     1fe:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	} while ((token == 0xFF) && Timer1);
     202:	8f 3f       	cpi	r24, 0xFF	; 255
     204:	39 f4       	brne	.+14     	; 0x214 <rcvr_datablock+0x30>
     206:	80 91 21 04 	lds	r24, 0x0421
     20a:	88 23       	and	r24, r24
     20c:	b9 f7       	brne	.-18     	; 0x1fc <rcvr_datablock+0x18>
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */
     20e:	80 e0       	ldi	r24, 0x00	; 0
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	28 c0       	rjmp	.+80     	; 0x264 <rcvr_datablock+0x80>
     214:	8e 3f       	cpi	r24, 0xFE	; 254
     216:	21 f5       	brne	.+72     	; 0x260 <rcvr_datablock+0x7c>
	BYTE *p,	/* Data buffer */
	UINT cnt	/* Size of data block */
)
{
	do {
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
     218:	8f ef       	ldi	r24, 0xFF	; 255
     21a:	8e bd       	out	0x2e, r24	; 46
     21c:	0d b4       	in	r0, 0x2d	; 45
     21e:	07 fe       	sbrs	r0, 7
     220:	fd cf       	rjmp	.-6      	; 0x21c <rcvr_datablock+0x38>
     222:	9e b5       	in	r25, 0x2e	; 46
     224:	98 83       	st	Y, r25
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
     226:	8e bd       	out	0x2e, r24	; 46
     228:	0d b4       	in	r0, 0x2d	; 45
     22a:	07 fe       	sbrs	r0, 7
     22c:	fd cf       	rjmp	.-6      	; 0x228 <rcvr_datablock+0x44>
     22e:	9e b5       	in	r25, 0x2e	; 46
     230:	99 83       	std	Y+1, r25	; 0x01
/*-----------------------------------------------------------------------*/
/* Receive a data packet from MMC                                        */
/*-----------------------------------------------------------------------*/

static
int rcvr_datablock (
     232:	22 96       	adiw	r28, 0x02	; 2
)
{
	do {
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
	} while (cnt -= 2);
     234:	2e ef       	ldi	r18, 0xFE	; 254
     236:	3f ef       	ldi	r19, 0xFF	; 255
     238:	4f ef       	ldi	r20, 0xFF	; 255
     23a:	5f ef       	ldi	r21, 0xFF	; 255
     23c:	c2 0e       	add	r12, r18
     23e:	d3 1e       	adc	r13, r19
     240:	e4 1e       	adc	r14, r20
     242:	f5 1e       	adc	r15, r21
     244:	c1 14       	cp	r12, r1
     246:	d1 04       	cpc	r13, r1
     248:	e1 04       	cpc	r14, r1
     24a:	f1 04       	cpc	r15, r1
     24c:	31 f7       	brne	.-52     	; 0x21a <rcvr_datablock+0x36>
		token = xchg_spi(0xFF);
	} while ((token == 0xFF) && Timer1);
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */

	rcvr_spi_multi(buff, btr);		/* Receive the data block into buffer */
	xchg_spi(0xFF);					/* Discard CRC */
     24e:	8f ef       	ldi	r24, 0xFF	; 255
     250:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi(0xFF);
     254:	8f ef       	ldi	r24, 0xFF	; 255
     256:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>

	return 1;						/* Return with success */
     25a:	81 e0       	ldi	r24, 0x01	; 1
     25c:	90 e0       	ldi	r25, 0x00	; 0
     25e:	02 c0       	rjmp	.+4      	; 0x264 <rcvr_datablock+0x80>

	Timer1 = 20;
	do {							/* Wait for data packet in timeout of 200ms */
		token = xchg_spi(0xFF);
	} while ((token == 0xFF) && Timer1);
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */
     260:	80 e0       	ldi	r24, 0x00	; 0
     262:	90 e0       	ldi	r25, 0x00	; 0
	rcvr_spi_multi(buff, btr);		/* Receive the data block into buffer */
	xchg_spi(0xFF);					/* Discard CRC */
	xchg_spi(0xFF);

	return 1;						/* Return with success */
}
     264:	df 91       	pop	r29
     266:	cf 91       	pop	r28
     268:	ff 90       	pop	r15
     26a:	ef 90       	pop	r14
     26c:	df 90       	pop	r13
     26e:	cf 90       	pop	r12
     270:	08 95       	ret

00000272 <xmit_datablock>:
static
int xmit_datablock (
	const BYTE *buff,	/* 512 byte data block to be transmitted */
	BYTE token			/* Data/Stop token */
)
{
     272:	1f 93       	push	r17
     274:	cf 93       	push	r28
     276:	df 93       	push	r29
     278:	ec 01       	movw	r28, r24
     27a:	16 2f       	mov	r17, r22
	BYTE resp;


	if (!wait_ready()) return 0;
     27c:	0e 94 c8 00 	call	0x190	; 0x190 <wait_ready>
     280:	00 97       	sbiw	r24, 0x00	; 0
     282:	41 f1       	breq	.+80     	; 0x2d4 <xmit_datablock+0x62>

	xchg_spi(token);					/* Xmit data token */
     284:	81 2f       	mov	r24, r17
     286:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	if (token != 0xFD) {	/* Is data token */
     28a:	1d 3f       	cpi	r17, 0xFD	; 253
     28c:	31 f1       	breq	.+76     	; 0x2da <xmit_datablock+0x68>
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     28e:	ce 01       	movw	r24, r28
     290:	80 50       	subi	r24, 0x00	; 0
     292:	9e 4f       	sbci	r25, 0xFE	; 254
	const BYTE *p,	/* Data block to be sent */
	UINT cnt		/* Size of data block */
)
{
	do {
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     294:	28 81       	ld	r18, Y
     296:	2e bd       	out	0x2e, r18	; 46
     298:	0d b4       	in	r0, 0x2d	; 45
     29a:	07 fe       	sbrs	r0, 7
     29c:	fd cf       	rjmp	.-6      	; 0x298 <xmit_datablock+0x26>
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     29e:	29 81       	ldd	r18, Y+1	; 0x01
     2a0:	2e bd       	out	0x2e, r18	; 46
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     2a2:	22 96       	adiw	r28, 0x02	; 2
	UINT cnt		/* Size of data block */
)
{
	do {
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     2a4:	0d b4       	in	r0, 0x2d	; 45
     2a6:	07 fe       	sbrs	r0, 7
     2a8:	fd cf       	rjmp	.-6      	; 0x2a4 <xmit_datablock+0x32>
	} while (cnt -= 2);
     2aa:	8c 17       	cp	r24, r28
     2ac:	9d 07       	cpc	r25, r29
     2ae:	91 f7       	brne	.-28     	; 0x294 <xmit_datablock+0x22>
	if (!wait_ready()) return 0;

	xchg_spi(token);					/* Xmit data token */
	if (token != 0xFD) {	/* Is data token */
		xmit_spi_multi(buff, 512);		/* Xmit the data block to the MMC */
		xchg_spi(0xFF);					/* CRC (Dummy) */
     2b0:	8f ef       	ldi	r24, 0xFF	; 255
     2b2:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
		xchg_spi(0xFF);
     2b6:	8f ef       	ldi	r24, 0xFF	; 255
     2b8:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
		resp = xchg_spi(0xFF);			/* Reveive data response */
     2bc:	8f ef       	ldi	r24, 0xFF	; 255
     2be:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
     2c2:	8f 71       	andi	r24, 0x1F	; 31
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     2c4:	21 e0       	ldi	r18, 0x01	; 1
     2c6:	30 e0       	ldi	r19, 0x00	; 0
     2c8:	85 30       	cpi	r24, 0x05	; 5
     2ca:	11 f0       	breq	.+4      	; 0x2d0 <xmit_datablock+0x5e>
     2cc:	20 e0       	ldi	r18, 0x00	; 0
     2ce:	30 e0       	ldi	r19, 0x00	; 0
)
{
	BYTE resp;


	if (!wait_ready()) return 0;
     2d0:	c9 01       	movw	r24, r18
     2d2:	05 c0       	rjmp	.+10     	; 0x2de <xmit_datablock+0x6c>
     2d4:	80 e0       	ldi	r24, 0x00	; 0
     2d6:	90 e0       	ldi	r25, 0x00	; 0
     2d8:	02 c0       	rjmp	.+4      	; 0x2de <xmit_datablock+0x6c>
		resp = xchg_spi(0xFF);			/* Reveive data response */
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
			return 0;
	}

	return 1;
     2da:	81 e0       	ldi	r24, 0x01	; 1
     2dc:	90 e0       	ldi	r25, 0x00	; 0
}
     2de:	df 91       	pop	r29
     2e0:	cf 91       	pop	r28
     2e2:	1f 91       	pop	r17
     2e4:	08 95       	ret

000002e6 <send_cmd>:
static
BYTE send_cmd (		/* Returns R1 resp (bit7==1:Send failed) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
     2e6:	ff 92       	push	r15
     2e8:	0f 93       	push	r16
     2ea:	1f 93       	push	r17
     2ec:	cf 93       	push	r28
     2ee:	df 93       	push	r29
     2f0:	c8 2f       	mov	r28, r24
     2f2:	d4 2f       	mov	r29, r20
     2f4:	15 2f       	mov	r17, r21
     2f6:	06 2f       	mov	r16, r22
     2f8:	f7 2e       	mov	r15, r23
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
     2fa:	88 23       	and	r24, r24
     2fc:	4c f4       	brge	.+18     	; 0x310 <send_cmd+0x2a>
		cmd &= 0x7F;
		res = send_cmd(CMD55, 0);
     2fe:	87 e3       	ldi	r24, 0x37	; 55
     300:	40 e0       	ldi	r20, 0x00	; 0
     302:	50 e0       	ldi	r21, 0x00	; 0
     304:	ba 01       	movw	r22, r20
     306:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
		if (res > 1) return res;
     30a:	82 30       	cpi	r24, 0x02	; 2
     30c:	68 f5       	brcc	.+90     	; 0x368 <send_cmd+0x82>
{
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
     30e:	cf 77       	andi	r28, 0x7F	; 127
		res = send_cmd(CMD55, 0);
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	deselect();
     310:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
	if (!select()) return 0xFF;
     314:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <select>
     318:	00 97       	sbiw	r24, 0x00	; 0
     31a:	29 f1       	breq	.+74     	; 0x366 <send_cmd+0x80>

	/* Send command packet */
	xchg_spi(0x40 | cmd);				/* Start + Command index */
     31c:	8c 2f       	mov	r24, r28
     31e:	80 64       	ori	r24, 0x40	; 64
     320:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
     324:	8f 2d       	mov	r24, r15
     326:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
     32a:	80 2f       	mov	r24, r16
     32c:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
     330:	81 2f       	mov	r24, r17
     332:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
     336:	8d 2f       	mov	r24, r29
     338:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) + Stop */
     33c:	cc 23       	and	r28, r28
     33e:	f1 f0       	breq	.+60     	; 0x37c <send_cmd+0x96>
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) Stop */
     340:	c8 30       	cpi	r28, 0x08	; 8
     342:	c1 f0       	breq	.+48     	; 0x374 <send_cmd+0x8e>
	xchg_spi(n);
     344:	81 e0       	ldi	r24, 0x01	; 1
     346:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>

	/* Receive command response */
	if (cmd == CMD12) xchg_spi(0xFF);		/* Skip a stuff byte when stop reading */
     34a:	cc 30       	cpi	r28, 0x0C	; 12
     34c:	19 f4       	brne	.+6      	; 0x354 <send_cmd+0x6e>
     34e:	8f ef       	ldi	r24, 0xFF	; 255
     350:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
static
BYTE send_cmd (		/* Returns R1 resp (bit7==1:Send failed) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
     354:	ca e0       	ldi	r28, 0x0A	; 10

	/* Receive command response */
	if (cmd == CMD12) xchg_spi(0xFF);		/* Skip a stuff byte when stop reading */
	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do
		res = xchg_spi(0xFF);
     356:	8f ef       	ldi	r24, 0xFF	; 255
     358:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
	while ((res & 0x80) && --n);
     35c:	88 23       	and	r24, r24
     35e:	24 f4       	brge	.+8      	; 0x368 <send_cmd+0x82>
     360:	c1 50       	subi	r28, 0x01	; 1
     362:	c9 f7       	brne	.-14     	; 0x356 <send_cmd+0x70>
     364:	01 c0       	rjmp	.+2      	; 0x368 <send_cmd+0x82>
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	deselect();
	if (!select()) return 0xFF;
     366:	8f ef       	ldi	r24, 0xFF	; 255
	do
		res = xchg_spi(0xFF);
	while ((res & 0x80) && --n);

	return res;			/* Return with the response value */
}
     368:	df 91       	pop	r29
     36a:	cf 91       	pop	r28
     36c:	1f 91       	pop	r17
     36e:	0f 91       	pop	r16
     370:	ff 90       	pop	r15
     372:	08 95       	ret
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) + Stop */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) Stop */
	xchg_spi(n);
     374:	87 e8       	ldi	r24, 0x87	; 135
     376:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     37a:	ec cf       	rjmp	.-40     	; 0x354 <send_cmd+0x6e>
     37c:	85 e9       	ldi	r24, 0x95	; 149
     37e:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     382:	e8 cf       	rjmp	.-48     	; 0x354 <send_cmd+0x6e>

00000384 <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
     384:	cf 92       	push	r12
     386:	df 92       	push	r13
     388:	ef 92       	push	r14
     38a:	ff 92       	push	r15
     38c:	0f 93       	push	r16
     38e:	1f 93       	push	r17
     390:	cf 93       	push	r28
     392:	df 93       	push	r29
     394:	00 d0       	rcall	.+0      	; 0x396 <disk_initialize+0x12>
     396:	00 d0       	rcall	.+0      	; 0x398 <disk_initialize+0x14>
     398:	cd b7       	in	r28, 0x3d	; 61
     39a:	de b7       	in	r29, 0x3e	; 62
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only single drive */
     39c:	88 23       	and	r24, r24
     39e:	09 f0       	breq	.+2      	; 0x3a2 <disk_initialize+0x1e>
     3a0:	a8 c0       	rjmp	.+336    	; 0x4f2 <disk_initialize+0x16e>
	power_off();						/* Turn off the socket power to reset the card */
     3a2:	0e 94 bc 00 	call	0x178	; 0x178 <power_off>
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
     3a6:	80 91 8a 01 	lds	r24, 0x018A
     3aa:	81 ff       	sbrs	r24, 1
     3ac:	03 c0       	rjmp	.+6      	; 0x3b4 <disk_initialize+0x30>
     3ae:	80 91 8a 01 	lds	r24, 0x018A
     3b2:	a0 c0       	rjmp	.+320    	; 0x4f4 <disk_initialize+0x170>
	// Configure for: PB4 - /SS
	//                PB5 - MOSI
	//                PB6 - MISO
	//                PB7 - SCK

	PORTB = 0b00010000;      // SS high
     3b4:	80 e1       	ldi	r24, 0x10	; 16
     3b6:	85 b9       	out	0x05, r24	; 5
	DDRB =  0b10110000;      // !SS,SCK and MOSI outputs
     3b8:	80 eb       	ldi	r24, 0xB0	; 176
     3ba:	84 b9       	out	0x04, r24	; 4

	/* Set MOSI and SCK output, all others input */
	//DDR_SPI = (1<<DD_MOSI)|(1<<DD_SCK);
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
     3bc:	81 e5       	ldi	r24, 0x51	; 81
     3be:	8c bd       	out	0x2c, r24	; 44

	if (drv) return STA_NOINIT;			/* Supports only single drive */
	power_off();						/* Turn off the socket power to reset the card */
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
	power_on();							/* Turn on the socket power */
	FCLK_SLOW();
     3c0:	82 e5       	ldi	r24, 0x52	; 82
     3c2:	8c bd       	out	0x2c, r24	; 44
     3c4:	0a e0       	ldi	r16, 0x0A	; 10
	for (n = 10; n; n--) xchg_spi(0xFF);	/* 80 dummy clocks */
     3c6:	8f ef       	ldi	r24, 0xFF	; 255
     3c8:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     3cc:	01 50       	subi	r16, 0x01	; 1
     3ce:	d9 f7       	brne	.-10     	; 0x3c6 <disk_initialize+0x42>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
     3d0:	80 e0       	ldi	r24, 0x00	; 0
     3d2:	40 e0       	ldi	r20, 0x00	; 0
     3d4:	50 e0       	ldi	r21, 0x00	; 0
     3d6:	ba 01       	movw	r22, r20
     3d8:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     3dc:	81 30       	cpi	r24, 0x01	; 1
     3de:	09 f0       	breq	.+2      	; 0x3e2 <disk_initialize+0x5e>
     3e0:	9c c0       	rjmp	.+312    	; 0x51a <disk_initialize+0x196>
		Timer1 = 100;						/* Initialization timeout of 1000 msec */
     3e2:	84 e6       	ldi	r24, 0x64	; 100
     3e4:	80 93 21 04 	sts	0x0421, r24
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
     3e8:	88 e0       	ldi	r24, 0x08	; 8
     3ea:	4a ea       	ldi	r20, 0xAA	; 170
     3ec:	51 e0       	ldi	r21, 0x01	; 1
     3ee:	60 e0       	ldi	r22, 0x00	; 0
     3f0:	70 e0       	ldi	r23, 0x00	; 0
     3f2:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     3f6:	81 30       	cpi	r24, 0x01	; 1
     3f8:	09 f0       	breq	.+2      	; 0x3fc <disk_initialize+0x78>
     3fa:	42 c0       	rjmp	.+132    	; 0x480 <disk_initialize+0xfc>
     3fc:	6e 01       	movw	r12, r28
     3fe:	08 94       	sec
     400:	c1 1c       	adc	r12, r1
     402:	d1 1c       	adc	r13, r1

/*-----------------------------------------------------------------------*/
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
     404:	8e 01       	movw	r16, r28
     406:	0b 5f       	subi	r16, 0xFB	; 251
     408:	1f 4f       	sbci	r17, 0xFF	; 255
     40a:	76 01       	movw	r14, r12

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		Timer1 = 100;						/* Initialization timeout of 1000 msec */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);		/* Get trailing return value of R7 resp */
     40c:	8f ef       	ldi	r24, 0xFF	; 255
     40e:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     412:	f7 01       	movw	r30, r14
     414:	81 93       	st	Z+, r24
     416:	7f 01       	movw	r14, r30
     418:	e0 17       	cp	r30, r16
     41a:	f1 07       	cpc	r31, r17
     41c:	b9 f7       	brne	.-18     	; 0x40c <disk_initialize+0x88>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	81 30       	cpi	r24, 0x01	; 1
     422:	09 f0       	breq	.+2      	; 0x426 <disk_initialize+0xa2>
     424:	7a c0       	rjmp	.+244    	; 0x51a <disk_initialize+0x196>
     426:	8c 81       	ldd	r24, Y+4	; 0x04
     428:	8a 3a       	cpi	r24, 0xAA	; 170
     42a:	09 f0       	breq	.+2      	; 0x42e <disk_initialize+0xaa>
     42c:	76 c0       	rjmp	.+236    	; 0x51a <disk_initialize+0x196>
				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
     42e:	80 91 21 04 	lds	r24, 0x0421
     432:	88 23       	and	r24, r24
     434:	49 f0       	breq	.+18     	; 0x448 <disk_initialize+0xc4>
     436:	89 ea       	ldi	r24, 0xA9	; 169
     438:	40 e0       	ldi	r20, 0x00	; 0
     43a:	50 e0       	ldi	r21, 0x00	; 0
     43c:	60 e0       	ldi	r22, 0x00	; 0
     43e:	70 e4       	ldi	r23, 0x40	; 64
     440:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     444:	88 23       	and	r24, r24
     446:	99 f7       	brne	.-26     	; 0x42e <disk_initialize+0xaa>
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
     448:	80 91 21 04 	lds	r24, 0x0421
     44c:	88 23       	and	r24, r24
     44e:	09 f4       	brne	.+2      	; 0x452 <disk_initialize+0xce>
     450:	64 c0       	rjmp	.+200    	; 0x51a <disk_initialize+0x196>
     452:	8a e3       	ldi	r24, 0x3A	; 58
     454:	40 e0       	ldi	r20, 0x00	; 0
     456:	50 e0       	ldi	r21, 0x00	; 0
     458:	ba 01       	movw	r22, r20
     45a:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     45e:	88 23       	and	r24, r24
     460:	09 f0       	breq	.+2      	; 0x464 <disk_initialize+0xe0>
     462:	5b c0       	rjmp	.+182    	; 0x51a <disk_initialize+0x196>
     464:	04 e0       	ldi	r16, 0x04	; 4
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
     466:	8f ef       	ldi	r24, 0xFF	; 255
     468:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     46c:	f6 01       	movw	r30, r12
     46e:	81 93       	st	Z+, r24
     470:	6f 01       	movw	r12, r30
     472:	01 50       	subi	r16, 0x01	; 1
     474:	c1 f7       	brne	.-16     	; 0x466 <disk_initialize+0xe2>
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
     476:	89 81       	ldd	r24, Y+1	; 0x01
     478:	86 fd       	sbrc	r24, 6
     47a:	49 c0       	rjmp	.+146    	; 0x50e <disk_initialize+0x18a>
     47c:	84 e0       	ldi	r24, 0x04	; 4
     47e:	48 c0       	rjmp	.+144    	; 0x510 <disk_initialize+0x18c>
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
     480:	89 ea       	ldi	r24, 0xA9	; 169
     482:	40 e0       	ldi	r20, 0x00	; 0
     484:	50 e0       	ldi	r21, 0x00	; 0
     486:	ba 01       	movw	r22, r20
     488:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     48c:	82 30       	cpi	r24, 0x02	; 2
     48e:	18 f4       	brcc	.+6      	; 0x496 <disk_initialize+0x112>
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
     490:	12 e0       	ldi	r17, 0x02	; 2
     492:	09 ea       	ldi	r16, 0xA9	; 169
     494:	02 c0       	rjmp	.+4      	; 0x49a <disk_initialize+0x116>
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
     496:	11 e0       	ldi	r17, 0x01	; 1
     498:	01 e0       	ldi	r16, 0x01	; 1
			}
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
     49a:	80 91 21 04 	lds	r24, 0x0421
     49e:	88 23       	and	r24, r24
     4a0:	41 f0       	breq	.+16     	; 0x4b2 <disk_initialize+0x12e>
     4a2:	80 2f       	mov	r24, r16
     4a4:	40 e0       	ldi	r20, 0x00	; 0
     4a6:	50 e0       	ldi	r21, 0x00	; 0
     4a8:	ba 01       	movw	r22, r20
     4aa:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     4ae:	88 23       	and	r24, r24
     4b0:	a1 f7       	brne	.-24     	; 0x49a <disk_initialize+0x116>
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
     4b2:	80 91 21 04 	lds	r24, 0x0421
     4b6:	88 23       	and	r24, r24
     4b8:	81 f1       	breq	.+96     	; 0x51a <disk_initialize+0x196>
     4ba:	80 e1       	ldi	r24, 0x10	; 16
     4bc:	40 e0       	ldi	r20, 0x00	; 0
     4be:	52 e0       	ldi	r21, 0x02	; 2
     4c0:	60 e0       	ldi	r22, 0x00	; 0
     4c2:	70 e0       	ldi	r23, 0x00	; 0
     4c4:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     4c8:	88 23       	and	r24, r24
     4ca:	39 f5       	brne	.+78     	; 0x51a <disk_initialize+0x196>
				ty = 0;
		}
	}
	CardType = ty;
     4cc:	10 93 22 04 	sts	0x0422, r17
	deselect();
     4d0:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>

	if (ty) {			/* Initialization succeded */
     4d4:	11 23       	and	r17, r17
     4d6:	41 f0       	breq	.+16     	; 0x4e8 <disk_initialize+0x164>
		Stat &= ~STA_NOINIT;		/* Clear STA_NOINIT */
     4d8:	80 91 8a 01 	lds	r24, 0x018A
     4dc:	8e 7f       	andi	r24, 0xFE	; 254
     4de:	80 93 8a 01 	sts	0x018A, r24
		FCLK_FAST();
     4e2:	80 e5       	ldi	r24, 0x50	; 80
     4e4:	8c bd       	out	0x2c, r24	; 44
     4e6:	02 c0       	rjmp	.+4      	; 0x4ec <disk_initialize+0x168>
	} else {			/* Initialization failed */
		power_off();
     4e8:	0e 94 bc 00 	call	0x178	; 0x178 <power_off>
	}

	return Stat;
     4ec:	80 91 8a 01 	lds	r24, 0x018A
     4f0:	01 c0       	rjmp	.+2      	; 0x4f4 <disk_initialize+0x170>
)
{
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only single drive */
     4f2:	81 e0       	ldi	r24, 0x01	; 1
	} else {			/* Initialization failed */
		power_off();
	}

	return Stat;
}
     4f4:	0f 90       	pop	r0
     4f6:	0f 90       	pop	r0
     4f8:	0f 90       	pop	r0
     4fa:	0f 90       	pop	r0
     4fc:	df 91       	pop	r29
     4fe:	cf 91       	pop	r28
     500:	1f 91       	pop	r17
     502:	0f 91       	pop	r16
     504:	ff 90       	pop	r15
     506:	ef 90       	pop	r14
     508:	df 90       	pop	r13
     50a:	cf 90       	pop	r12
     50c:	08 95       	ret
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);		/* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
     50e:	8c e0       	ldi	r24, 0x0C	; 12
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
     510:	80 93 22 04 	sts	0x0422, r24
	deselect();
     514:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
     518:	df cf       	rjmp	.-66     	; 0x4d8 <disk_initialize+0x154>
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
     51a:	10 92 22 04 	sts	0x0422, r1
	deselect();
     51e:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
     522:	e2 cf       	rjmp	.-60     	; 0x4e8 <disk_initialize+0x164>

00000524 <disk_status>:

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
     524:	88 23       	and	r24, r24
     526:	19 f4       	brne	.+6      	; 0x52e <disk_status+0xa>
	return Stat;
     528:	80 91 8a 01 	lds	r24, 0x018A
     52c:	08 95       	ret

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
     52e:	81 e0       	ldi	r24, 0x01	; 1
	return Stat;
}
     530:	08 95       	ret

00000532 <disk_read>:
	BYTE drv,			/* Physical drive nmuber (0) */
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
     532:	0f 93       	push	r16
     534:	cf 93       	push	r28
     536:	df 93       	push	r29
     538:	eb 01       	movw	r28, r22
	if (drv || !count) return RES_PARERR;
     53a:	88 23       	and	r24, r24
     53c:	09 f0       	breq	.+2      	; 0x540 <disk_read+0xe>
     53e:	4a c0       	rjmp	.+148    	; 0x5d4 <disk_read+0xa2>
     540:	00 23       	and	r16, r16
     542:	09 f4       	brne	.+2      	; 0x546 <disk_read+0x14>
     544:	49 c0       	rjmp	.+146    	; 0x5d8 <disk_read+0xa6>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     546:	80 91 8a 01 	lds	r24, 0x018A
     54a:	80 fd       	sbrc	r24, 0
     54c:	47 c0       	rjmp	.+142    	; 0x5dc <disk_read+0xaa>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
     54e:	80 91 22 04 	lds	r24, 0x0422
     552:	83 fd       	sbrc	r24, 3
     554:	09 c0       	rjmp	.+18     	; 0x568 <disk_read+0x36>
     556:	01 2e       	mov	r0, r17
     558:	19 e0       	ldi	r17, 0x09	; 9
     55a:	22 0f       	add	r18, r18
     55c:	33 1f       	adc	r19, r19
     55e:	44 1f       	adc	r20, r20
     560:	55 1f       	adc	r21, r21
     562:	1a 95       	dec	r17
     564:	d1 f7       	brne	.-12     	; 0x55a <disk_read+0x28>
     566:	10 2d       	mov	r17, r0

	if (count == 1) {	/* Single block read */
     568:	01 30       	cpi	r16, 0x01	; 1
     56a:	89 f4       	brne	.+34     	; 0x58e <disk_read+0x5c>
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
     56c:	81 e1       	ldi	r24, 0x11	; 17
     56e:	ba 01       	movw	r22, r20
     570:	a9 01       	movw	r20, r18
     572:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     576:	88 23       	and	r24, r24
     578:	31 f5       	brne	.+76     	; 0x5c6 <disk_read+0x94>
			&& rcvr_datablock(buff, 512))
     57a:	ce 01       	movw	r24, r28
     57c:	40 e0       	ldi	r20, 0x00	; 0
     57e:	52 e0       	ldi	r21, 0x02	; 2
     580:	60 e0       	ldi	r22, 0x00	; 0
     582:	70 e0       	ldi	r23, 0x00	; 0
     584:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     588:	00 97       	sbiw	r24, 0x00	; 0
     58a:	e1 f4       	brne	.+56     	; 0x5c4 <disk_read+0x92>
     58c:	1c c0       	rjmp	.+56     	; 0x5c6 <disk_read+0x94>
			count = 0;
	}
	else {				/* Multiple block read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
     58e:	82 e1       	ldi	r24, 0x12	; 18
     590:	ba 01       	movw	r22, r20
     592:	a9 01       	movw	r20, r18
     594:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     598:	88 23       	and	r24, r24
     59a:	a9 f4       	brne	.+42     	; 0x5c6 <disk_read+0x94>
			do {
				if (!rcvr_datablock(buff, 512)) break;
     59c:	ce 01       	movw	r24, r28
     59e:	40 e0       	ldi	r20, 0x00	; 0
     5a0:	52 e0       	ldi	r21, 0x02	; 2
     5a2:	60 e0       	ldi	r22, 0x00	; 0
     5a4:	70 e0       	ldi	r23, 0x00	; 0
     5a6:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     5aa:	00 97       	sbiw	r24, 0x00	; 0
     5ac:	21 f0       	breq	.+8      	; 0x5b6 <disk_read+0x84>
				buff += 512;
     5ae:	c0 50       	subi	r28, 0x00	; 0
     5b0:	de 4f       	sbci	r29, 0xFE	; 254
			} while (--count);
     5b2:	01 50       	subi	r16, 0x01	; 1
     5b4:	99 f7       	brne	.-26     	; 0x59c <disk_read+0x6a>
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
     5b6:	8c e0       	ldi	r24, 0x0C	; 12
     5b8:	40 e0       	ldi	r20, 0x00	; 0
     5ba:	50 e0       	ldi	r21, 0x00	; 0
     5bc:	ba 01       	movw	r22, r20
     5be:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     5c2:	01 c0       	rjmp	.+2      	; 0x5c6 <disk_read+0x94>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */

	if (count == 1) {	/* Single block read */
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
			&& rcvr_datablock(buff, 512))
			count = 0;
     5c4:	00 e0       	ldi	r16, 0x00	; 0
				buff += 512;
			} while (--count);
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
		}
	}
	deselect();
     5c6:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>

	return count ? RES_ERROR : RES_OK;
     5ca:	81 e0       	ldi	r24, 0x01	; 1
     5cc:	00 23       	and	r16, r16
     5ce:	39 f4       	brne	.+14     	; 0x5de <disk_read+0xac>
     5d0:	80 e0       	ldi	r24, 0x00	; 0
     5d2:	05 c0       	rjmp	.+10     	; 0x5de <disk_read+0xac>
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
	if (drv || !count) return RES_PARERR;
     5d4:	84 e0       	ldi	r24, 0x04	; 4
     5d6:	03 c0       	rjmp	.+6      	; 0x5de <disk_read+0xac>
     5d8:	84 e0       	ldi	r24, 0x04	; 4
     5da:	01 c0       	rjmp	.+2      	; 0x5de <disk_read+0xac>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     5dc:	83 e0       	ldi	r24, 0x03	; 3
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
     5de:	df 91       	pop	r29
     5e0:	cf 91       	pop	r28
     5e2:	0f 91       	pop	r16
     5e4:	08 95       	ret

000005e6 <disk_write>:
	BYTE drv,			/* Physical drive nmuber (0) */
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
     5e6:	cf 92       	push	r12
     5e8:	df 92       	push	r13
     5ea:	ef 92       	push	r14
     5ec:	ff 92       	push	r15
     5ee:	0f 93       	push	r16
     5f0:	cf 93       	push	r28
     5f2:	df 93       	push	r29
     5f4:	eb 01       	movw	r28, r22
     5f6:	69 01       	movw	r12, r18
     5f8:	7a 01       	movw	r14, r20
	if (drv || !count) return RES_PARERR;
     5fa:	88 23       	and	r24, r24
     5fc:	09 f0       	breq	.+2      	; 0x600 <disk_write+0x1a>
     5fe:	57 c0       	rjmp	.+174    	; 0x6ae <disk_write+0xc8>
     600:	00 23       	and	r16, r16
     602:	09 f4       	brne	.+2      	; 0x606 <disk_write+0x20>
     604:	56 c0       	rjmp	.+172    	; 0x6b2 <disk_write+0xcc>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     606:	80 91 8a 01 	lds	r24, 0x018A
     60a:	80 fd       	sbrc	r24, 0
     60c:	54 c0       	rjmp	.+168    	; 0x6b6 <disk_write+0xd0>
	if (Stat & STA_PROTECT) return RES_WRPRT;
     60e:	80 91 8a 01 	lds	r24, 0x018A
     612:	82 fd       	sbrc	r24, 2
     614:	52 c0       	rjmp	.+164    	; 0x6ba <disk_write+0xd4>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
     616:	80 91 22 04 	lds	r24, 0x0422
     61a:	90 e0       	ldi	r25, 0x00	; 0
     61c:	83 fd       	sbrc	r24, 3
     61e:	09 c0       	rjmp	.+18     	; 0x632 <disk_write+0x4c>
     620:	0b 2e       	mov	r0, r27
     622:	b9 e0       	ldi	r27, 0x09	; 9
     624:	cc 0c       	add	r12, r12
     626:	dd 1c       	adc	r13, r13
     628:	ee 1c       	adc	r14, r14
     62a:	ff 1c       	adc	r15, r15
     62c:	ba 95       	dec	r27
     62e:	d1 f7       	brne	.-12     	; 0x624 <disk_write+0x3e>
     630:	b0 2d       	mov	r27, r0

	if (count == 1) {	/* Single block write */
     632:	01 30       	cpi	r16, 0x01	; 1
     634:	71 f4       	brne	.+28     	; 0x652 <disk_write+0x6c>
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
     636:	88 e1       	ldi	r24, 0x18	; 24
     638:	b7 01       	movw	r22, r14
     63a:	a6 01       	movw	r20, r12
     63c:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     640:	88 23       	and	r24, r24
     642:	71 f5       	brne	.+92     	; 0x6a0 <disk_write+0xba>
			&& xmit_datablock(buff, 0xFE))
     644:	ce 01       	movw	r24, r28
     646:	6e ef       	ldi	r22, 0xFE	; 254
     648:	0e 94 39 01 	call	0x272	; 0x272 <xmit_datablock>
     64c:	00 97       	sbiw	r24, 0x00	; 0
     64e:	29 f5       	brne	.+74     	; 0x69a <disk_write+0xb4>
     650:	27 c0       	rjmp	.+78     	; 0x6a0 <disk_write+0xba>
			count = 0;
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
     652:	86 70       	andi	r24, 0x06	; 6
     654:	90 70       	andi	r25, 0x00	; 0
     656:	00 97       	sbiw	r24, 0x00	; 0
     658:	39 f0       	breq	.+14     	; 0x668 <disk_write+0x82>
     65a:	40 2f       	mov	r20, r16
     65c:	50 e0       	ldi	r21, 0x00	; 0
     65e:	60 e0       	ldi	r22, 0x00	; 0
     660:	70 e0       	ldi	r23, 0x00	; 0
     662:	87 e9       	ldi	r24, 0x97	; 151
     664:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
     668:	89 e1       	ldi	r24, 0x19	; 25
     66a:	b7 01       	movw	r22, r14
     66c:	a6 01       	movw	r20, r12
     66e:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     672:	88 23       	and	r24, r24
     674:	a9 f4       	brne	.+42     	; 0x6a0 <disk_write+0xba>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
     676:	ce 01       	movw	r24, r28
     678:	6c ef       	ldi	r22, 0xFC	; 252
     67a:	0e 94 39 01 	call	0x272	; 0x272 <xmit_datablock>
     67e:	00 97       	sbiw	r24, 0x00	; 0
     680:	21 f0       	breq	.+8      	; 0x68a <disk_write+0xa4>
				buff += 512;
     682:	c0 50       	subi	r28, 0x00	; 0
     684:	de 4f       	sbci	r29, 0xFE	; 254
			} while (--count);
     686:	01 50       	subi	r16, 0x01	; 1
     688:	b1 f7       	brne	.-20     	; 0x676 <disk_write+0x90>
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
     68a:	80 e0       	ldi	r24, 0x00	; 0
     68c:	90 e0       	ldi	r25, 0x00	; 0
     68e:	6d ef       	ldi	r22, 0xFD	; 253
     690:	0e 94 39 01 	call	0x272	; 0x272 <xmit_datablock>
     694:	00 97       	sbiw	r24, 0x00	; 0
     696:	19 f0       	breq	.+6      	; 0x69e <disk_write+0xb8>
     698:	03 c0       	rjmp	.+6      	; 0x6a0 <disk_write+0xba>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */

	if (count == 1) {	/* Single block write */
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
			&& xmit_datablock(buff, 0xFE))
			count = 0;
     69a:	00 e0       	ldi	r16, 0x00	; 0
     69c:	01 c0       	rjmp	.+2      	; 0x6a0 <disk_write+0xba>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
				buff += 512;
			} while (--count);
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
				count = 1;
     69e:	01 e0       	ldi	r16, 0x01	; 1
		}
	}
	deselect();
     6a0:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>

	return count ? RES_ERROR : RES_OK;
     6a4:	81 e0       	ldi	r24, 0x01	; 1
     6a6:	00 23       	and	r16, r16
     6a8:	49 f4       	brne	.+18     	; 0x6bc <disk_write+0xd6>
     6aa:	80 e0       	ldi	r24, 0x00	; 0
     6ac:	07 c0       	rjmp	.+14     	; 0x6bc <disk_write+0xd6>
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
	if (drv || !count) return RES_PARERR;
     6ae:	84 e0       	ldi	r24, 0x04	; 4
     6b0:	05 c0       	rjmp	.+10     	; 0x6bc <disk_write+0xd6>
     6b2:	84 e0       	ldi	r24, 0x04	; 4
     6b4:	03 c0       	rjmp	.+6      	; 0x6bc <disk_write+0xd6>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     6b6:	83 e0       	ldi	r24, 0x03	; 3
     6b8:	01 c0       	rjmp	.+2      	; 0x6bc <disk_write+0xd6>
	if (Stat & STA_PROTECT) return RES_WRPRT;
     6ba:	82 e0       	ldi	r24, 0x02	; 2
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
     6bc:	df 91       	pop	r29
     6be:	cf 91       	pop	r28
     6c0:	0f 91       	pop	r16
     6c2:	ff 90       	pop	r15
     6c4:	ef 90       	pop	r14
     6c6:	df 90       	pop	r13
     6c8:	cf 90       	pop	r12
     6ca:	08 95       	ret

000006cc <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
     6cc:	ef 92       	push	r14
     6ce:	ff 92       	push	r15
     6d0:	0f 93       	push	r16
     6d2:	1f 93       	push	r17
     6d4:	cf 93       	push	r28
     6d6:	df 93       	push	r29
     6d8:	cd b7       	in	r28, 0x3d	; 61
     6da:	de b7       	in	r29, 0x3e	; 62
     6dc:	60 97       	sbiw	r28, 0x10	; 16
     6de:	0f b6       	in	r0, 0x3f	; 63
     6e0:	f8 94       	cli
     6e2:	de bf       	out	0x3e, r29	; 62
     6e4:	0f be       	out	0x3f, r0	; 63
     6e6:	cd bf       	out	0x3d, r28	; 61
     6e8:	7a 01       	movw	r14, r20
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	DWORD csize;


	if (drv) return RES_PARERR;
     6ea:	88 23       	and	r24, r24
     6ec:	09 f0       	breq	.+2      	; 0x6f0 <disk_ioctl+0x24>
     6ee:	da c1       	rjmp	.+948    	; 0xaa4 <disk_ioctl+0x3d8>

	res = RES_ERROR;

	if (ctrl == CTRL_POWER) {
     6f0:	65 30       	cpi	r22, 0x05	; 5
     6f2:	89 f4       	brne	.+34     	; 0x716 <disk_ioctl+0x4a>
		switch (ptr[0]) {
     6f4:	fa 01       	movw	r30, r20
     6f6:	80 81       	ld	r24, Z
     6f8:	88 23       	and	r24, r24
     6fa:	21 f0       	breq	.+8      	; 0x704 <disk_ioctl+0x38>
     6fc:	81 30       	cpi	r24, 0x01	; 1
     6fe:	09 f0       	breq	.+2      	; 0x702 <disk_ioctl+0x36>
     700:	d3 c1       	rjmp	.+934    	; 0xaa8 <disk_ioctl+0x3dc>
     702:	04 c0       	rjmp	.+8      	; 0x70c <disk_ioctl+0x40>
		case 0:		/* Sub control code (POWER_OFF) */
			power_off();		/* Power off */
     704:	0e 94 bc 00 	call	0x178	; 0x178 <power_off>
			res = RES_OK;
     708:	00 e0       	ldi	r16, 0x00	; 0
			break;
     70a:	d1 c1       	rjmp	.+930    	; 0xaae <disk_ioctl+0x3e2>
		case 1:		/* Sub control code (POWER_GET) */
			ptr[1] = (BYTE)power_status();
     70c:	81 e0       	ldi	r24, 0x01	; 1
     70e:	fa 01       	movw	r30, r20
     710:	81 83       	std	Z+1, r24	; 0x01
			res = RES_OK;
     712:	00 e0       	ldi	r16, 0x00	; 0
			break;
     714:	cc c1       	rjmp	.+920    	; 0xaae <disk_ioctl+0x3e2>
		default :
			res = RES_PARERR;
		}
	}
	else {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
     716:	80 91 8a 01 	lds	r24, 0x018A
     71a:	80 fd       	sbrc	r24, 0
     71c:	c7 c1       	rjmp	.+910    	; 0xaac <disk_ioctl+0x3e0>

		switch (ctrl) {
     71e:	6a 30       	cpi	r22, 0x0A	; 10
     720:	09 f4       	brne	.+2      	; 0x724 <disk_ioctl+0x58>
     722:	44 c1       	rjmp	.+648    	; 0x9ac <disk_ioctl+0x2e0>
     724:	6b 30       	cpi	r22, 0x0B	; 11
     726:	58 f4       	brcc	.+22     	; 0x73e <disk_ioctl+0x72>
     728:	61 30       	cpi	r22, 0x01	; 1
     72a:	f9 f0       	breq	.+62     	; 0x76a <disk_ioctl+0x9e>
     72c:	61 30       	cpi	r22, 0x01	; 1
     72e:	a0 f0       	brcs	.+40     	; 0x758 <disk_ioctl+0x8c>
     730:	62 30       	cpi	r22, 0x02	; 2
     732:	09 f4       	brne	.+2      	; 0x736 <disk_ioctl+0x6a>
     734:	98 c0       	rjmp	.+304    	; 0x866 <disk_ioctl+0x19a>
     736:	63 30       	cpi	r22, 0x03	; 3
     738:	09 f0       	breq	.+2      	; 0x73c <disk_ioctl+0x70>
     73a:	94 c1       	rjmp	.+808    	; 0xa64 <disk_ioctl+0x398>
     73c:	9b c0       	rjmp	.+310    	; 0x874 <disk_ioctl+0x1a8>
     73e:	6c 30       	cpi	r22, 0x0C	; 12
     740:	09 f4       	brne	.+2      	; 0x744 <disk_ioctl+0x78>
     742:	4f c1       	rjmp	.+670    	; 0x9e2 <disk_ioctl+0x316>
     744:	6c 30       	cpi	r22, 0x0C	; 12
     746:	08 f4       	brcc	.+2      	; 0x74a <disk_ioctl+0x7e>
     748:	37 c1       	rjmp	.+622    	; 0x9b8 <disk_ioctl+0x2ec>
     74a:	6d 30       	cpi	r22, 0x0D	; 13
     74c:	09 f4       	brne	.+2      	; 0x750 <disk_ioctl+0x84>
     74e:	5e c1       	rjmp	.+700    	; 0xa0c <disk_ioctl+0x340>
     750:	6e 30       	cpi	r22, 0x0E	; 14
     752:	09 f0       	breq	.+2      	; 0x756 <disk_ioctl+0x8a>
     754:	87 c1       	rjmp	.+782    	; 0xa64 <disk_ioctl+0x398>
     756:	70 c1       	rjmp	.+736    	; 0xa38 <disk_ioctl+0x36c>
		case CTRL_SYNC :		/* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
			if (select()) {
     758:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <select>
     75c:	00 97       	sbiw	r24, 0x00	; 0
     75e:	09 f4       	brne	.+2      	; 0x762 <disk_ioctl+0x96>
     760:	83 c1       	rjmp	.+774    	; 0xa68 <disk_ioctl+0x39c>
				deselect();
     762:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
				res = RES_OK;
     766:	00 e0       	ldi	r16, 0x00	; 0
     768:	9a c1       	rjmp	.+820    	; 0xa9e <disk_ioctl+0x3d2>
			}
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
     76a:	89 e0       	ldi	r24, 0x09	; 9
     76c:	40 e0       	ldi	r20, 0x00	; 0
     76e:	50 e0       	ldi	r21, 0x00	; 0
     770:	ba 01       	movw	r22, r20
     772:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     776:	88 23       	and	r24, r24
     778:	09 f0       	breq	.+2      	; 0x77c <disk_ioctl+0xb0>
     77a:	78 c1       	rjmp	.+752    	; 0xa6c <disk_ioctl+0x3a0>
     77c:	ce 01       	movw	r24, r28
     77e:	01 96       	adiw	r24, 0x01	; 1
     780:	40 e1       	ldi	r20, 0x10	; 16
     782:	50 e0       	ldi	r21, 0x00	; 0
     784:	60 e0       	ldi	r22, 0x00	; 0
     786:	70 e0       	ldi	r23, 0x00	; 0
     788:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     78c:	00 97       	sbiw	r24, 0x00	; 0
     78e:	09 f4       	brne	.+2      	; 0x792 <disk_ioctl+0xc6>
     790:	6f c1       	rjmp	.+734    	; 0xa70 <disk_ioctl+0x3a4>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
     792:	89 81       	ldd	r24, Y+1	; 0x01
     794:	82 95       	swap	r24
     796:	86 95       	lsr	r24
     798:	86 95       	lsr	r24
     79a:	83 70       	andi	r24, 0x03	; 3
     79c:	81 30       	cpi	r24, 0x01	; 1
     79e:	51 f5       	brne	.+84     	; 0x7f4 <disk_ioctl+0x128>
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
     7a0:	48 85       	ldd	r20, Y+8	; 0x08
     7a2:	50 e0       	ldi	r21, 0x00	; 0
     7a4:	60 e0       	ldi	r22, 0x00	; 0
     7a6:	70 e0       	ldi	r23, 0x00	; 0
     7a8:	4f 73       	andi	r20, 0x3F	; 63
     7aa:	50 70       	andi	r21, 0x00	; 0
     7ac:	60 70       	andi	r22, 0x00	; 0
     7ae:	70 70       	andi	r23, 0x00	; 0
     7b0:	ba 01       	movw	r22, r20
     7b2:	55 27       	eor	r21, r21
     7b4:	44 27       	eor	r20, r20
     7b6:	4f 5f       	subi	r20, 0xFF	; 255
     7b8:	5f 4f       	sbci	r21, 0xFF	; 255
     7ba:	6f 4f       	sbci	r22, 0xFF	; 255
     7bc:	7f 4f       	sbci	r23, 0xFF	; 255
     7be:	99 85       	ldd	r25, Y+9	; 0x09
     7c0:	80 e0       	ldi	r24, 0x00	; 0
     7c2:	2a 85       	ldd	r18, Y+10	; 0x0a
     7c4:	82 0f       	add	r24, r18
     7c6:	91 1d       	adc	r25, r1
     7c8:	a0 e0       	ldi	r26, 0x00	; 0
     7ca:	b0 e0       	ldi	r27, 0x00	; 0
     7cc:	84 0f       	add	r24, r20
     7ce:	95 1f       	adc	r25, r21
     7d0:	a6 1f       	adc	r26, r22
     7d2:	b7 1f       	adc	r27, r23
					*(DWORD*)buff = csize << 10;
     7d4:	07 2e       	mov	r0, r23
     7d6:	7a e0       	ldi	r23, 0x0A	; 10
     7d8:	88 0f       	add	r24, r24
     7da:	99 1f       	adc	r25, r25
     7dc:	aa 1f       	adc	r26, r26
     7de:	bb 1f       	adc	r27, r27
     7e0:	7a 95       	dec	r23
     7e2:	d1 f7       	brne	.-12     	; 0x7d8 <disk_ioctl+0x10c>
     7e4:	70 2d       	mov	r23, r0
     7e6:	f7 01       	movw	r30, r14
     7e8:	80 83       	st	Z, r24
     7ea:	91 83       	std	Z+1, r25	; 0x01
     7ec:	a2 83       	std	Z+2, r26	; 0x02
     7ee:	b3 83       	std	Z+3, r27	; 0x03
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = csize << (n - 9);
				}
				res = RES_OK;
     7f0:	00 e0       	ldi	r16, 0x00	; 0
     7f2:	55 c1       	rjmp	.+682    	; 0xa9e <disk_ioctl+0x3d2>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = csize << 10;
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
     7f4:	29 85       	ldd	r18, Y+9	; 0x09
     7f6:	22 95       	swap	r18
     7f8:	26 95       	lsr	r18
     7fa:	26 95       	lsr	r18
     7fc:	23 70       	andi	r18, 0x03	; 3
     7fe:	88 85       	ldd	r24, Y+8	; 0x08
     800:	90 e0       	ldi	r25, 0x00	; 0
     802:	88 0f       	add	r24, r24
     804:	99 1f       	adc	r25, r25
     806:	88 0f       	add	r24, r24
     808:	99 1f       	adc	r25, r25
     80a:	82 0f       	add	r24, r18
     80c:	91 1d       	adc	r25, r1
     80e:	01 96       	adiw	r24, 0x01	; 1
     810:	2f 81       	ldd	r18, Y+7	; 0x07
     812:	30 e0       	ldi	r19, 0x00	; 0
     814:	23 70       	andi	r18, 0x03	; 3
     816:	30 70       	andi	r19, 0x00	; 0
     818:	32 2f       	mov	r19, r18
     81a:	22 27       	eor	r18, r18
     81c:	33 0f       	add	r19, r19
     81e:	33 0f       	add	r19, r19
     820:	82 0f       	add	r24, r18
     822:	93 1f       	adc	r25, r19
     824:	ac 01       	movw	r20, r24
     826:	60 e0       	ldi	r22, 0x00	; 0
     828:	70 e0       	ldi	r23, 0x00	; 0
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = csize << 10;
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
     82a:	9e 81       	ldd	r25, Y+6	; 0x06
     82c:	9f 70       	andi	r25, 0x0F	; 15
     82e:	8b 85       	ldd	r24, Y+11	; 0x0b
     830:	88 1f       	adc	r24, r24
     832:	88 27       	eor	r24, r24
     834:	88 1f       	adc	r24, r24
     836:	98 0f       	add	r25, r24
     838:	9e 5f       	subi	r25, 0xFE	; 254
     83a:	8a 85       	ldd	r24, Y+10	; 0x0a
     83c:	83 70       	andi	r24, 0x03	; 3
     83e:	88 0f       	add	r24, r24
     840:	89 0f       	add	r24, r25
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = csize << (n - 9);
     842:	90 e0       	ldi	r25, 0x00	; 0
     844:	09 97       	sbiw	r24, 0x09	; 9
     846:	8a 01       	movw	r16, r20
     848:	9b 01       	movw	r18, r22
     84a:	04 c0       	rjmp	.+8      	; 0x854 <disk_ioctl+0x188>
     84c:	00 0f       	add	r16, r16
     84e:	11 1f       	adc	r17, r17
     850:	22 1f       	adc	r18, r18
     852:	33 1f       	adc	r19, r19
     854:	8a 95       	dec	r24
     856:	d2 f7       	brpl	.-12     	; 0x84c <disk_ioctl+0x180>
     858:	f7 01       	movw	r30, r14
     85a:	00 83       	st	Z, r16
     85c:	11 83       	std	Z+1, r17	; 0x01
     85e:	22 83       	std	Z+2, r18	; 0x02
     860:	33 83       	std	Z+3, r19	; 0x03
				}
				res = RES_OK;
     862:	00 e0       	ldi	r16, 0x00	; 0
     864:	1c c1       	rjmp	.+568    	; 0xa9e <disk_ioctl+0x3d2>
			}
			break;

		case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
			*(WORD*)buff = 512;
     866:	80 e0       	ldi	r24, 0x00	; 0
     868:	92 e0       	ldi	r25, 0x02	; 2
     86a:	fa 01       	movw	r30, r20
     86c:	91 83       	std	Z+1, r25	; 0x01
     86e:	80 83       	st	Z, r24
			res = RES_OK;
     870:	00 e0       	ldi	r16, 0x00	; 0
			break;
     872:	15 c1       	rjmp	.+554    	; 0xa9e <disk_ioctl+0x3d2>

		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
			if (CardType & CT_SD2) {	/* SDv2? */
     874:	00 91 22 04 	lds	r16, 0x0422
     878:	02 ff       	sbrs	r16, 2
     87a:	31 c0       	rjmp	.+98     	; 0x8de <disk_ioctl+0x212>
				if (send_cmd(ACMD13, 0) == 0) {	/* Read SD status */
     87c:	8d e8       	ldi	r24, 0x8D	; 141
     87e:	40 e0       	ldi	r20, 0x00	; 0
     880:	50 e0       	ldi	r21, 0x00	; 0
     882:	ba 01       	movw	r22, r20
     884:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     888:	88 23       	and	r24, r24
     88a:	09 f0       	breq	.+2      	; 0x88e <disk_ioctl+0x1c2>
     88c:	f3 c0       	rjmp	.+486    	; 0xa74 <disk_ioctl+0x3a8>
					xchg_spi(0xFF);
     88e:	8f ef       	ldi	r24, 0xFF	; 255
     890:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
					if (rcvr_datablock(csd, 16)) {				/* Read partial block */
     894:	ce 01       	movw	r24, r28
     896:	01 96       	adiw	r24, 0x01	; 1
     898:	40 e1       	ldi	r20, 0x10	; 16
     89a:	50 e0       	ldi	r21, 0x00	; 0
     89c:	60 e0       	ldi	r22, 0x00	; 0
     89e:	70 e0       	ldi	r23, 0x00	; 0
     8a0:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     8a4:	00 97       	sbiw	r24, 0x00	; 0
     8a6:	09 f4       	brne	.+2      	; 0x8aa <disk_ioctl+0x1de>
     8a8:	e7 c0       	rjmp	.+462    	; 0xa78 <disk_ioctl+0x3ac>
     8aa:	00 e3       	ldi	r16, 0x30	; 48
						for (n = 64 - 16; n; n--) xchg_spi(0xFF);	/* Purge trailing data */
     8ac:	8f ef       	ldi	r24, 0xFF	; 255
     8ae:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     8b2:	01 50       	subi	r16, 0x01	; 1
     8b4:	d9 f7       	brne	.-10     	; 0x8ac <disk_ioctl+0x1e0>
						*(DWORD*)buff = 16UL << (csd[10] >> 4);
     8b6:	2b 85       	ldd	r18, Y+11	; 0x0b
     8b8:	22 95       	swap	r18
     8ba:	2f 70       	andi	r18, 0x0F	; 15
     8bc:	80 e1       	ldi	r24, 0x10	; 16
     8be:	90 e0       	ldi	r25, 0x00	; 0
     8c0:	a0 e0       	ldi	r26, 0x00	; 0
     8c2:	b0 e0       	ldi	r27, 0x00	; 0
     8c4:	04 c0       	rjmp	.+8      	; 0x8ce <disk_ioctl+0x202>
     8c6:	88 0f       	add	r24, r24
     8c8:	99 1f       	adc	r25, r25
     8ca:	aa 1f       	adc	r26, r26
     8cc:	bb 1f       	adc	r27, r27
     8ce:	2a 95       	dec	r18
     8d0:	d2 f7       	brpl	.-12     	; 0x8c6 <disk_ioctl+0x1fa>
     8d2:	f7 01       	movw	r30, r14
     8d4:	80 83       	st	Z, r24
     8d6:	91 83       	std	Z+1, r25	; 0x01
     8d8:	a2 83       	std	Z+2, r26	; 0x02
     8da:	b3 83       	std	Z+3, r27	; 0x03
     8dc:	e0 c0       	rjmp	.+448    	; 0xa9e <disk_ioctl+0x3d2>
						res = RES_OK;
					}
				}
			} else {					/* SDv1 or MMCv3 */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
     8de:	89 e0       	ldi	r24, 0x09	; 9
     8e0:	40 e0       	ldi	r20, 0x00	; 0
     8e2:	50 e0       	ldi	r21, 0x00	; 0
     8e4:	ba 01       	movw	r22, r20
     8e6:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     8ea:	88 23       	and	r24, r24
     8ec:	09 f0       	breq	.+2      	; 0x8f0 <disk_ioctl+0x224>
     8ee:	c6 c0       	rjmp	.+396    	; 0xa7c <disk_ioctl+0x3b0>
     8f0:	ce 01       	movw	r24, r28
     8f2:	01 96       	adiw	r24, 0x01	; 1
     8f4:	40 e1       	ldi	r20, 0x10	; 16
     8f6:	50 e0       	ldi	r21, 0x00	; 0
     8f8:	60 e0       	ldi	r22, 0x00	; 0
     8fa:	70 e0       	ldi	r23, 0x00	; 0
     8fc:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     900:	00 97       	sbiw	r24, 0x00	; 0
     902:	09 f4       	brne	.+2      	; 0x906 <disk_ioctl+0x23a>
     904:	bd c0       	rjmp	.+378    	; 0xa80 <disk_ioctl+0x3b4>
					if (CardType & CT_SD1) {	/* SDv1 */
     906:	01 ff       	sbrs	r16, 1
     908:	25 c0       	rjmp	.+74     	; 0x954 <disk_ioctl+0x288>
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
     90a:	8c 85       	ldd	r24, Y+12	; 0x0c
     90c:	88 1f       	adc	r24, r24
     90e:	88 27       	eor	r24, r24
     910:	88 1f       	adc	r24, r24
     912:	90 e0       	ldi	r25, 0x00	; 0
     914:	01 96       	adiw	r24, 0x01	; 1
     916:	2b 85       	ldd	r18, Y+11	; 0x0b
     918:	30 e0       	ldi	r19, 0x00	; 0
     91a:	2f 73       	andi	r18, 0x3F	; 63
     91c:	30 70       	andi	r19, 0x00	; 0
     91e:	22 0f       	add	r18, r18
     920:	33 1f       	adc	r19, r19
     922:	28 0f       	add	r18, r24
     924:	39 1f       	adc	r19, r25
     926:	8e 85       	ldd	r24, Y+14	; 0x0e
     928:	82 95       	swap	r24
     92a:	86 95       	lsr	r24
     92c:	86 95       	lsr	r24
     92e:	83 70       	andi	r24, 0x03	; 3
     930:	90 e0       	ldi	r25, 0x00	; 0
     932:	01 97       	sbiw	r24, 0x01	; 1
     934:	89 01       	movw	r16, r18
     936:	02 c0       	rjmp	.+4      	; 0x93c <disk_ioctl+0x270>
     938:	00 0f       	add	r16, r16
     93a:	11 1f       	adc	r17, r17
     93c:	8a 95       	dec	r24
     93e:	e2 f7       	brpl	.-8      	; 0x938 <disk_ioctl+0x26c>
     940:	c8 01       	movw	r24, r16
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	f7 01       	movw	r30, r14
     948:	80 83       	st	Z, r24
     94a:	91 83       	std	Z+1, r25	; 0x01
     94c:	a2 83       	std	Z+2, r26	; 0x02
     94e:	b3 83       	std	Z+3, r27	; 0x03
					} else {					/* MMCv3 */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
					}
					res = RES_OK;
     950:	00 e0       	ldi	r16, 0x00	; 0
     952:	a5 c0       	rjmp	.+330    	; 0xa9e <disk_ioctl+0x3d2>
			} else {					/* SDv1 or MMCv3 */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
					if (CardType & CT_SD1) {	/* SDv1 */
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
					} else {					/* MMCv3 */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
     954:	8c 85       	ldd	r24, Y+12	; 0x0c
     956:	48 2f       	mov	r20, r24
     958:	50 e0       	ldi	r21, 0x00	; 0
     95a:	43 70       	andi	r20, 0x03	; 3
     95c:	50 70       	andi	r21, 0x00	; 0
     95e:	44 0f       	add	r20, r20
     960:	55 1f       	adc	r21, r21
     962:	44 0f       	add	r20, r20
     964:	55 1f       	adc	r21, r21
     966:	44 0f       	add	r20, r20
     968:	55 1f       	adc	r21, r21
     96a:	82 95       	swap	r24
     96c:	86 95       	lsr	r24
     96e:	87 70       	andi	r24, 0x07	; 7
     970:	48 0f       	add	r20, r24
     972:	51 1d       	adc	r21, r1
     974:	4f 5f       	subi	r20, 0xFF	; 255
     976:	5f 4f       	sbci	r21, 0xFF	; 255
     978:	2b 85       	ldd	r18, Y+11	; 0x0b
     97a:	30 e0       	ldi	r19, 0x00	; 0
     97c:	2c 77       	andi	r18, 0x7C	; 124
     97e:	30 70       	andi	r19, 0x00	; 0
     980:	35 95       	asr	r19
     982:	27 95       	ror	r18
     984:	35 95       	asr	r19
     986:	27 95       	ror	r18
     988:	2f 5f       	subi	r18, 0xFF	; 255
     98a:	3f 4f       	sbci	r19, 0xFF	; 255
     98c:	42 9f       	mul	r20, r18
     98e:	c0 01       	movw	r24, r0
     990:	43 9f       	mul	r20, r19
     992:	90 0d       	add	r25, r0
     994:	52 9f       	mul	r21, r18
     996:	90 0d       	add	r25, r0
     998:	11 24       	eor	r1, r1
     99a:	a0 e0       	ldi	r26, 0x00	; 0
     99c:	b0 e0       	ldi	r27, 0x00	; 0
     99e:	f7 01       	movw	r30, r14
     9a0:	80 83       	st	Z, r24
     9a2:	91 83       	std	Z+1, r25	; 0x01
     9a4:	a2 83       	std	Z+2, r26	; 0x02
     9a6:	b3 83       	std	Z+3, r27	; 0x03
					}
					res = RES_OK;
     9a8:	00 e0       	ldi	r16, 0x00	; 0
     9aa:	79 c0       	rjmp	.+242    	; 0xa9e <disk_ioctl+0x3d2>
				}
			}
			break;

		case MMC_GET_TYPE :		/* Get card type flags (1 byte) */
			*ptr = CardType;
     9ac:	80 91 22 04 	lds	r24, 0x0422
     9b0:	fa 01       	movw	r30, r20
     9b2:	80 83       	st	Z, r24
			res = RES_OK;
     9b4:	00 e0       	ldi	r16, 0x00	; 0
			break;
     9b6:	73 c0       	rjmp	.+230    	; 0xa9e <disk_ioctl+0x3d2>

		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
     9b8:	89 e0       	ldi	r24, 0x09	; 9
     9ba:	40 e0       	ldi	r20, 0x00	; 0
     9bc:	50 e0       	ldi	r21, 0x00	; 0
     9be:	ba 01       	movw	r22, r20
     9c0:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     9c4:	88 23       	and	r24, r24
     9c6:	09 f0       	breq	.+2      	; 0x9ca <disk_ioctl+0x2fe>
     9c8:	5d c0       	rjmp	.+186    	; 0xa84 <disk_ioctl+0x3b8>
				&& rcvr_datablock(ptr, 16))
     9ca:	c7 01       	movw	r24, r14
     9cc:	40 e1       	ldi	r20, 0x10	; 16
     9ce:	50 e0       	ldi	r21, 0x00	; 0
     9d0:	60 e0       	ldi	r22, 0x00	; 0
     9d2:	70 e0       	ldi	r23, 0x00	; 0
     9d4:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     9d8:	00 97       	sbiw	r24, 0x00	; 0
     9da:	09 f0       	breq	.+2      	; 0x9de <disk_ioctl+0x312>
     9dc:	55 c0       	rjmp	.+170    	; 0xa88 <disk_ioctl+0x3bc>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     9de:	01 e0       	ldi	r16, 0x01	; 1
     9e0:	5e c0       	rjmp	.+188    	; 0xa9e <disk_ioctl+0x3d2>
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
			break;

		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
     9e2:	8a e0       	ldi	r24, 0x0A	; 10
     9e4:	40 e0       	ldi	r20, 0x00	; 0
     9e6:	50 e0       	ldi	r21, 0x00	; 0
     9e8:	ba 01       	movw	r22, r20
     9ea:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     9ee:	88 23       	and	r24, r24
     9f0:	09 f0       	breq	.+2      	; 0x9f4 <disk_ioctl+0x328>
     9f2:	4c c0       	rjmp	.+152    	; 0xa8c <disk_ioctl+0x3c0>
				&& rcvr_datablock(ptr, 16))
     9f4:	c7 01       	movw	r24, r14
     9f6:	40 e1       	ldi	r20, 0x10	; 16
     9f8:	50 e0       	ldi	r21, 0x00	; 0
     9fa:	60 e0       	ldi	r22, 0x00	; 0
     9fc:	70 e0       	ldi	r23, 0x00	; 0
     9fe:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     a02:	00 97       	sbiw	r24, 0x00	; 0
     a04:	09 f0       	breq	.+2      	; 0xa08 <disk_ioctl+0x33c>
     a06:	44 c0       	rjmp	.+136    	; 0xa90 <disk_ioctl+0x3c4>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a08:	01 e0       	ldi	r16, 0x01	; 1
     a0a:	49 c0       	rjmp	.+146    	; 0xa9e <disk_ioctl+0x3d2>
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
			break;

		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
			if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
     a0c:	8a e3       	ldi	r24, 0x3A	; 58
     a0e:	40 e0       	ldi	r20, 0x00	; 0
     a10:	50 e0       	ldi	r21, 0x00	; 0
     a12:	ba 01       	movw	r22, r20
     a14:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     a18:	88 23       	and	r24, r24
     a1a:	e1 f5       	brne	.+120    	; 0xa94 <disk_ioctl+0x3c8>
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
/*-----------------------------------------------------------------------*/

#if _USE_IOCTL
DRESULT disk_ioctl (
     a1c:	87 01       	movw	r16, r14
     a1e:	0c 5f       	subi	r16, 0xFC	; 252
     a20:	1f 4f       	sbci	r17, 0xFF	; 255
				res = RES_OK;
			break;

		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
			if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
				for (n = 4; n; n--) *ptr++ = xchg_spi(0xFF);
     a22:	8f ef       	ldi	r24, 0xFF	; 255
     a24:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
     a28:	f7 01       	movw	r30, r14
     a2a:	81 93       	st	Z+, r24
     a2c:	7f 01       	movw	r14, r30
     a2e:	e0 17       	cp	r30, r16
     a30:	f1 07       	cpc	r31, r17
     a32:	b9 f7       	brne	.-18     	; 0xa22 <disk_ioctl+0x356>
				res = RES_OK;
     a34:	00 e0       	ldi	r16, 0x00	; 0
     a36:	33 c0       	rjmp	.+102    	; 0xa9e <disk_ioctl+0x3d2>
			}
			break;

		case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
			if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
     a38:	8d e8       	ldi	r24, 0x8D	; 141
     a3a:	40 e0       	ldi	r20, 0x00	; 0
     a3c:	50 e0       	ldi	r21, 0x00	; 0
     a3e:	ba 01       	movw	r22, r20
     a40:	0e 94 73 01 	call	0x2e6	; 0x2e6 <send_cmd>
     a44:	88 23       	and	r24, r24
     a46:	41 f5       	brne	.+80     	; 0xa98 <disk_ioctl+0x3cc>
				xchg_spi(0xFF);
     a48:	8f ef       	ldi	r24, 0xFF	; 255
     a4a:	0e 94 c2 00 	call	0x184	; 0x184 <xchg_spi>
				if (rcvr_datablock(ptr, 64))
     a4e:	c7 01       	movw	r24, r14
     a50:	40 e4       	ldi	r20, 0x40	; 64
     a52:	50 e0       	ldi	r21, 0x00	; 0
     a54:	60 e0       	ldi	r22, 0x00	; 0
     a56:	70 e0       	ldi	r23, 0x00	; 0
     a58:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <rcvr_datablock>
     a5c:	00 97       	sbiw	r24, 0x00	; 0
     a5e:	f1 f4       	brne	.+60     	; 0xa9c <disk_ioctl+0x3d0>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a60:	01 e0       	ldi	r16, 0x01	; 1
     a62:	1d c0       	rjmp	.+58     	; 0xa9e <disk_ioctl+0x3d2>
					res = RES_OK;
			}
			break;

		default:
			res = RES_PARERR;
     a64:	04 e0       	ldi	r16, 0x04	; 4
     a66:	1b c0       	rjmp	.+54     	; 0xa9e <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a68:	01 e0       	ldi	r16, 0x01	; 1
     a6a:	19 c0       	rjmp	.+50     	; 0xa9e <disk_ioctl+0x3d2>
     a6c:	01 e0       	ldi	r16, 0x01	; 1
     a6e:	17 c0       	rjmp	.+46     	; 0xa9e <disk_ioctl+0x3d2>
     a70:	01 e0       	ldi	r16, 0x01	; 1
     a72:	15 c0       	rjmp	.+42     	; 0xa9e <disk_ioctl+0x3d2>
     a74:	01 e0       	ldi	r16, 0x01	; 1
     a76:	13 c0       	rjmp	.+38     	; 0xa9e <disk_ioctl+0x3d2>
     a78:	01 e0       	ldi	r16, 0x01	; 1
     a7a:	11 c0       	rjmp	.+34     	; 0xa9e <disk_ioctl+0x3d2>
     a7c:	01 e0       	ldi	r16, 0x01	; 1
     a7e:	0f c0       	rjmp	.+30     	; 0xa9e <disk_ioctl+0x3d2>
     a80:	01 e0       	ldi	r16, 0x01	; 1
     a82:	0d c0       	rjmp	.+26     	; 0xa9e <disk_ioctl+0x3d2>
     a84:	01 e0       	ldi	r16, 0x01	; 1
     a86:	0b c0       	rjmp	.+22     	; 0xa9e <disk_ioctl+0x3d2>
			break;

		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
     a88:	00 e0       	ldi	r16, 0x00	; 0
     a8a:	09 c0       	rjmp	.+18     	; 0xa9e <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a8c:	01 e0       	ldi	r16, 0x01	; 1
     a8e:	07 c0       	rjmp	.+14     	; 0xa9e <disk_ioctl+0x3d2>
			break;

		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
     a90:	00 e0       	ldi	r16, 0x00	; 0
     a92:	05 c0       	rjmp	.+10     	; 0xa9e <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a94:	01 e0       	ldi	r16, 0x01	; 1
     a96:	03 c0       	rjmp	.+6      	; 0xa9e <disk_ioctl+0x3d2>
     a98:	01 e0       	ldi	r16, 0x01	; 1
     a9a:	01 c0       	rjmp	.+2      	; 0xa9e <disk_ioctl+0x3d2>

		case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
			if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
				xchg_spi(0xFF);
				if (rcvr_datablock(ptr, 64))
					res = RES_OK;
     a9c:	00 e0       	ldi	r16, 0x00	; 0

		default:
			res = RES_PARERR;
		}

		deselect();
     a9e:	0e 94 dd 00 	call	0x1ba	; 0x1ba <deselect>
     aa2:	05 c0       	rjmp	.+10     	; 0xaae <disk_ioctl+0x3e2>
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	DWORD csize;


	if (drv) return RES_PARERR;
     aa4:	04 e0       	ldi	r16, 0x04	; 4
     aa6:	03 c0       	rjmp	.+6      	; 0xaae <disk_ioctl+0x3e2>
		case 1:		/* Sub control code (POWER_GET) */
			ptr[1] = (BYTE)power_status();
			res = RES_OK;
			break;
		default :
			res = RES_PARERR;
     aa8:	04 e0       	ldi	r16, 0x04	; 4
     aaa:	01 c0       	rjmp	.+2      	; 0xaae <disk_ioctl+0x3e2>
		}
	}
	else {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
     aac:	03 e0       	ldi	r16, 0x03	; 3

		deselect();
	}

	return res;
}
     aae:	80 2f       	mov	r24, r16
     ab0:	60 96       	adiw	r28, 0x10	; 16
     ab2:	0f b6       	in	r0, 0x3f	; 63
     ab4:	f8 94       	cli
     ab6:	de bf       	out	0x3e, r29	; 62
     ab8:	0f be       	out	0x3f, r0	; 63
     aba:	cd bf       	out	0x3d, r28	; 61
     abc:	df 91       	pop	r29
     abe:	cf 91       	pop	r28
     ac0:	1f 91       	pop	r17
     ac2:	0f 91       	pop	r16
     ac4:	ff 90       	pop	r15
     ac6:	ef 90       	pop	r14
     ac8:	08 95       	ret

00000aca <disk_timerproc>:
void disk_timerproc (void)
{
	BYTE n, s;


	n = Timer1;				/* 100Hz decrement timer */
     aca:	80 91 21 04 	lds	r24, 0x0421
	if (n) Timer1 = --n;
     ace:	88 23       	and	r24, r24
     ad0:	19 f0       	breq	.+6      	; 0xad8 <disk_timerproc+0xe>
     ad2:	81 50       	subi	r24, 0x01	; 1
     ad4:	80 93 21 04 	sts	0x0421, r24
	n = Timer2;
     ad8:	80 91 20 04 	lds	r24, 0x0420
	if (n) Timer2 = --n;
     adc:	88 23       	and	r24, r24
     ade:	19 f0       	breq	.+6      	; 0xae6 <disk_timerproc+0x1c>
     ae0:	81 50       	subi	r24, 0x01	; 1
     ae2:	80 93 20 04 	sts	0x0420, r24

	s = Stat;
     ae6:	80 91 8a 01 	lds	r24, 0x018A

	if (SOCKWP)				/* Write protected */
     aea:	18 9b       	sbis	0x03, 0	; 3
     aec:	02 c0       	rjmp	.+4      	; 0xaf2 <disk_timerproc+0x28>
		s |= STA_PROTECT;
     aee:	84 60       	ori	r24, 0x04	; 4
     af0:	01 c0       	rjmp	.+2      	; 0xaf4 <disk_timerproc+0x2a>
	else					/* Write enabled */
		s &= ~STA_PROTECT;
     af2:	8b 7f       	andi	r24, 0xFB	; 251

	if (SOCKINS)			/* Card inserted */
     af4:	19 99       	sbic	0x03, 1	; 3
     af6:	02 c0       	rjmp	.+4      	; 0xafc <disk_timerproc+0x32>
		s &= ~STA_NODISK;
     af8:	8d 7f       	andi	r24, 0xFD	; 253
     afa:	01 c0       	rjmp	.+2      	; 0xafe <disk_timerproc+0x34>
	else					/* Socket empty */
		s |= (STA_NODISK | STA_NOINIT);
     afc:	83 60       	ori	r24, 0x03	; 3

	Stat = s;				/* Update MMC status */
     afe:	80 93 8a 01 	sts	0x018A, r24
}
     b02:	08 95       	ret

00000b04 <__vector_1>:



//ISR for controlling WEN.
ISR(INT0_vect)
{
     b04:	1f 92       	push	r1
     b06:	0f 92       	push	r0
     b08:	0f b6       	in	r0, 0x3f	; 63
     b0a:	0f 92       	push	r0
     b0c:	11 24       	eor	r1, r1
     b0e:	8f 93       	push	r24
	//printf("ISR INT0 Entered\n");
	if (VSYNC_0_Count==1)//start a frame read
     b10:	80 91 2f 04 	lds	r24, 0x042F
     b14:	81 30       	cpi	r24, 0x01	; 1
     b16:	39 f4       	brne	.+14     	; 0xb26 <__vector_1+0x22>
	{
		FIFO_WEN_0_SET;
     b18:	5e 9a       	sbi	0x0b, 6	; 11
		VSYNC_0_Count++;
     b1a:	80 91 2f 04 	lds	r24, 0x042F
     b1e:	8f 5f       	subi	r24, 0xFF	; 255
     b20:	80 93 2f 04 	sts	0x042F, r24
     b24:	14 c0       	rjmp	.+40     	; 0xb4e <__vector_1+0x4a>
	}
	else if (VSYNC_0_Count==2)//end a frame read
     b26:	80 91 2f 04 	lds	r24, 0x042F
     b2a:	82 30       	cpi	r24, 0x02	; 2
     b2c:	39 f4       	brne	.+14     	; 0xb3c <__vector_1+0x38>
	{
		FIFO_WEN_0_CLR;
     b2e:	5e 98       	cbi	0x0b, 6	; 11
		VSYNC_0_Count++;
     b30:	80 91 2f 04 	lds	r24, 0x042F
     b34:	8f 5f       	subi	r24, 0xFF	; 255
     b36:	80 93 2f 04 	sts	0x042F, r24
     b3a:	09 c0       	rjmp	.+18     	; 0xb4e <__vector_1+0x4a>
	}
	else if(VSYNC_0_Count == 3)
     b3c:	80 91 2f 04 	lds	r24, 0x042F
     b40:	83 30       	cpi	r24, 0x03	; 3
     b42:	11 f4       	brne	.+4      	; 0xb48 <__vector_1+0x44>
	{
		FIFO_WEN_0_CLR;
     b44:	5e 98       	cbi	0x0b, 6	; 11
     b46:	03 c0       	rjmp	.+6      	; 0xb4e <__vector_1+0x4a>
	}
	else
	{
		FIFO_WEN_0_CLR
     b48:	5e 98       	cbi	0x0b, 6	; 11
		VSYNC_0_Count = 0;//wait for a read to be started
     b4a:	10 92 2f 04 	sts	0x042F, r1
	}
}
     b4e:	8f 91       	pop	r24
     b50:	0f 90       	pop	r0
     b52:	0f be       	out	0x3f, r0	; 63
     b54:	0f 90       	pop	r0
     b56:	1f 90       	pop	r1
     b58:	18 95       	reti

00000b5a <__vector_2>:
//ISR for controlling WEN.
ISR(INT1_vect)
{
     b5a:	1f 92       	push	r1
     b5c:	0f 92       	push	r0
     b5e:	0f b6       	in	r0, 0x3f	; 63
     b60:	0f 92       	push	r0
     b62:	11 24       	eor	r1, r1
     b64:	8f 93       	push	r24
	//printf("ISR INT1 Entered\n");
	if (VSYNC_1_Count==1)//start a frame read
     b66:	80 91 70 0c 	lds	r24, 0x0C70
     b6a:	81 30       	cpi	r24, 0x01	; 1
     b6c:	39 f4       	brne	.+14     	; 0xb7c <__vector_2+0x22>
	{
		FIFO_WEN_1_SET;
     b6e:	44 9a       	sbi	0x08, 4	; 8
		VSYNC_1_Count++;
     b70:	80 91 70 0c 	lds	r24, 0x0C70
     b74:	8f 5f       	subi	r24, 0xFF	; 255
     b76:	80 93 70 0c 	sts	0x0C70, r24
     b7a:	14 c0       	rjmp	.+40     	; 0xba4 <__vector_2+0x4a>
	}
	else if (VSYNC_1_Count==2)//end a frame read
     b7c:	80 91 70 0c 	lds	r24, 0x0C70
     b80:	82 30       	cpi	r24, 0x02	; 2
     b82:	39 f4       	brne	.+14     	; 0xb92 <__vector_2+0x38>
	{
		FIFO_WEN_1_CLR;
     b84:	44 98       	cbi	0x08, 4	; 8
		VSYNC_1_Count++;
     b86:	80 91 70 0c 	lds	r24, 0x0C70
     b8a:	8f 5f       	subi	r24, 0xFF	; 255
     b8c:	80 93 70 0c 	sts	0x0C70, r24
     b90:	09 c0       	rjmp	.+18     	; 0xba4 <__vector_2+0x4a>
	}
	else if(VSYNC_1_Count == 3)
     b92:	80 91 70 0c 	lds	r24, 0x0C70
     b96:	83 30       	cpi	r24, 0x03	; 3
     b98:	11 f4       	brne	.+4      	; 0xb9e <__vector_2+0x44>
	{
		FIFO_WEN_1_CLR;
     b9a:	44 98       	cbi	0x08, 4	; 8
     b9c:	03 c0       	rjmp	.+6      	; 0xba4 <__vector_2+0x4a>
	}
	else
	{
		FIFO_WEN_1_CLR
     b9e:	44 98       	cbi	0x08, 4	; 8
		VSYNC_1_Count = 0;//wait for a read to be started
     ba0:	10 92 70 0c 	sts	0x0C70, r1
	}
}
     ba4:	8f 91       	pop	r24
     ba6:	0f 90       	pop	r0
     ba8:	0f be       	out	0x3f, r0	; 63
     baa:	0f 90       	pop	r0
     bac:	1f 90       	pop	r1
     bae:	18 95       	reti

00000bb0 <wrOV7670Reg>:

//Write Register Method
unsigned char wrOV7670Reg(unsigned char regID, unsigned char regDat)
{
     bb0:	cf 93       	push	r28
     bb2:	df 93       	push	r29
     bb4:	00 d0       	rcall	.+0      	; 0xbb6 <wrOV7670Reg+0x6>
     bb6:	00 d0       	rcall	.+0      	; 0xbb8 <wrOV7670Reg+0x8>
     bb8:	cd b7       	in	r28, 0x3d	; 61
     bba:	de b7       	in	r29, 0x3e	; 62
	/*	I2C Traffic Generated:
	 *	S | OV_7670 + W | A | RegID | A | Data | A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE];
	messageBuf[0] = (OV7670_ADDR  <<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consit of General Call code or the TWI slave address.
     bbc:	92 e4       	ldi	r25, 0x42	; 66
     bbe:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for commands.
     bc0:	8a 83       	std	Y+2, r24	; 0x02
	messageBuf[2] = regDat;                        // The second byte is used for the data.
     bc2:	6b 83       	std	Y+3, r22	; 0x03
	TWI_Start_Transceiver_With_Data( messageBuf, 3 );
     bc4:	ce 01       	movw	r24, r28
     bc6:	01 96       	adiw	r24, 0x01	; 1
     bc8:	63 e0       	ldi	r22, 0x03	; 3
     bca:	0e 94 e3 29 	call	0x53c6	; 0x53c6 <TWI_Start_Transceiver_With_Data>
	
	while(TWI_Transceiver_Busy()) ; //Wait for transceiver to clear
     bce:	0e 94 d8 29 	call	0x53b0	; 0x53b0 <TWI_Transceiver_Busy>
     bd2:	88 23       	and	r24, r24
     bd4:	e1 f7       	brne	.-8      	; 0xbce <wrOV7670Reg+0x1e>
	
	return TWI_statusReg.lastTransOK;
     bd6:	80 91 28 04 	lds	r24, 0x0428
}
     bda:	81 70       	andi	r24, 0x01	; 1
     bdc:	0f 90       	pop	r0
     bde:	0f 90       	pop	r0
     be0:	0f 90       	pop	r0
     be2:	0f 90       	pop	r0
     be4:	df 91       	pop	r29
     be6:	cf 91       	pop	r28
     be8:	08 95       	ret

00000bea <rdOV7670Reg>:

//Read Register Method
unsigned char rdOV7670Reg(unsigned char regID, unsigned char *regDat)
{
     bea:	0f 93       	push	r16
     bec:	1f 93       	push	r17
     bee:	cf 93       	push	r28
     bf0:	df 93       	push	r29
     bf2:	00 d0       	rcall	.+0      	; 0xbf4 <rdOV7670Reg+0xa>
     bf4:	00 d0       	rcall	.+0      	; 0xbf6 <rdOV7670Reg+0xc>
     bf6:	cd b7       	in	r28, 0x3d	; 61
     bf8:	de b7       	in	r29, 0x3e	; 62
     bfa:	8b 01       	movw	r16, r22
	 *	S	|	OV_ADDR + W	| A | RegID | A | P |
	 *	S	|	OV_ADDR + R | A | Data	|~A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE]; //Initialise a buffer
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
     bfc:	92 e4       	ldi	r25, 0x42	; 66
     bfe:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for Address Pointer.
     c00:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
     c02:	ce 01       	movw	r24, r28
     c04:	01 96       	adiw	r24, 0x01	; 1
     c06:	62 e0       	ldi	r22, 0x02	; 2
     c08:	0e 94 e3 29 	call	0x53c6	; 0x53c6 <TWI_Start_Transceiver_With_Data>
	
	// Request/collect the data from the Slave
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
     c0c:	83 e4       	ldi	r24, 0x43	; 67
     c0e:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );              
     c10:	ce 01       	movw	r24, r28
     c12:	01 96       	adiw	r24, 0x01	; 1
     c14:	62 e0       	ldi	r22, 0x02	; 2
     c16:	0e 94 e3 29 	call	0x53c6	; 0x53c6 <TWI_Start_Transceiver_With_Data>
    
	// Get the received data from the transceiver buffer
	TWI_Get_Data_From_Transceiver( messageBuf, 2 );
     c1a:	ce 01       	movw	r24, r28
     c1c:	01 96       	adiw	r24, 0x01	; 1
     c1e:	62 e0       	ldi	r22, 0x02	; 2
     c20:	0e 94 19 2a 	call	0x5432	; 0x5432 <TWI_Get_Data_From_Transceiver>
	*regDat = messageBuf[1];       
     c24:	8a 81       	ldd	r24, Y+2	; 0x02
     c26:	f8 01       	movw	r30, r16
     c28:	80 83       	st	Z, r24
	return TWI_statusReg.lastTransOK;
     c2a:	80 91 28 04 	lds	r24, 0x0428
}
     c2e:	81 70       	andi	r24, 0x01	; 1
     c30:	0f 90       	pop	r0
     c32:	0f 90       	pop	r0
     c34:	0f 90       	pop	r0
     c36:	0f 90       	pop	r0
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	1f 91       	pop	r17
     c3e:	0f 91       	pop	r16
     c40:	08 95       	ret

00000c42 <OV7670_init>:


unsigned char OV7670_init()
{
     c42:	0f 93       	push	r16
     c44:	1f 93       	push	r17
     c46:	cf 93       	push	r28
     c48:	df 93       	push	r29
	uint8_t i = 0;
	if(0==wrOV7670Reg(OV_COM7, 0x80)) //Reset Camera
     c4a:	82 e1       	ldi	r24, 0x12	; 18
     c4c:	60 e8       	ldi	r22, 0x80	; 128
     c4e:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <wrOV7670Reg>
     c52:	88 23       	and	r24, r24
     c54:	f1 f0       	breq	.+60     	; 0xc92 <OV7670_init+0x50>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     c56:	8f e2       	ldi	r24, 0x2F	; 47
     c58:	95 e7       	ldi	r25, 0x75	; 117
     c5a:	01 97       	sbiw	r24, 0x01	; 1
     c5c:	f1 f7       	brne	.-4      	; 0xc5a <OV7670_init+0x18>
     c5e:	00 c0       	rjmp	.+0      	; 0xc60 <OV7670_init+0x1e>
     c60:	00 00       	nop
     c62:	cc e8       	ldi	r28, 0x8C	; 140
     c64:	d1 e0       	ldi	r29, 0x01	; 1
	*regDat = messageBuf[1];       
	return TWI_statusReg.lastTransOK;
}


unsigned char OV7670_init()
     c66:	0a ed       	ldi	r16, 0xDA	; 218
     c68:	12 e0       	ldi	r17, 0x02	; 2
     c6a:	fe 01       	movw	r30, r28
     c6c:	31 97       	sbiw	r30, 0x01	; 1
		return 1;
	}
	_delay_ms(10);
	for(i=0; i<SETTINGS_LENGTH; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
     c6e:	80 81       	ld	r24, Z
     c70:	68 81       	ld	r22, Y
     c72:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <wrOV7670Reg>
     c76:	88 23       	and	r24, r24
     c78:	71 f0       	breq	.+28     	; 0xc96 <OV7670_init+0x54>
     c7a:	87 eb       	ldi	r24, 0xB7	; 183
     c7c:	9b e0       	ldi	r25, 0x0B	; 11
     c7e:	01 97       	sbiw	r24, 0x01	; 1
     c80:	f1 f7       	brne	.-4      	; 0xc7e <OV7670_init+0x3c>
     c82:	00 c0       	rjmp	.+0      	; 0xc84 <OV7670_init+0x42>
     c84:	00 00       	nop
     c86:	22 96       	adiw	r28, 0x02	; 2
	if(0==wrOV7670Reg(OV_COM7, 0x80)) //Reset Camera
	{
		return 1;
	}
	_delay_ms(10);
	for(i=0; i<SETTINGS_LENGTH; i++)
     c88:	c0 17       	cp	r28, r16
     c8a:	d1 07       	cpc	r29, r17
     c8c:	71 f7       	brne	.-36     	; 0xc6a <OV7670_init+0x28>
			return 1;
		}
		_delay_ms(1);
	}
	
	return 0;
     c8e:	80 e0       	ldi	r24, 0x00	; 0
     c90:	03 c0       	rjmp	.+6      	; 0xc98 <OV7670_init+0x56>
unsigned char OV7670_init()
{
	uint8_t i = 0;
	if(0==wrOV7670Reg(OV_COM7, 0x80)) //Reset Camera
	{
		return 1;
     c92:	81 e0       	ldi	r24, 0x01	; 1
     c94:	01 c0       	rjmp	.+2      	; 0xc98 <OV7670_init+0x56>
	_delay_ms(10);
	for(i=0; i<SETTINGS_LENGTH; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
		{
			return 1;
     c96:	81 e0       	ldi	r24, 0x01	; 1
		}
		_delay_ms(1);
	}
	
	return 0;
}
     c98:	df 91       	pop	r29
     c9a:	cf 91       	pop	r28
     c9c:	1f 91       	pop	r17
     c9e:	0f 91       	pop	r16
     ca0:	08 95       	ret

00000ca2 <FIFO_init>:

void FIFO_init( void )
{
	//disable both outputs
	FIFO_nOE_0_SET;
     ca2:	46 9a       	sbi	0x08, 6	; 8
	FIFO_nOE_1_SET;
     ca4:	47 9a       	sbi	0x08, 7	; 8
	//Reset Buffer 0
	FIFO_WRST_0_CLR;
     ca6:	5f 98       	cbi	0x0b, 7	; 11
	FIFO_RCLK_0_CLR;
     ca8:	5c 98       	cbi	0x0b, 4	; 11
	//FIFO_nOE_0_CLR;
	FIFO_nRRST_0_SET;
     caa:	5d 9a       	sbi	0x0b, 5	; 11
	FIFO_WEN_0_CLR;
     cac:	5e 98       	cbi	0x0b, 6	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     cae:	88 e2       	ldi	r24, 0x28	; 40
     cb0:	8a 95       	dec	r24
     cb2:	f1 f7       	brne	.-4      	; 0xcb0 <FIFO_init+0xe>
	_delay_us(10);
	FIFO_RCLK_0_SET;
     cb4:	5c 9a       	sbi	0x0b, 4	; 11
     cb6:	88 e2       	ldi	r24, 0x28	; 40
     cb8:	8a 95       	dec	r24
     cba:	f1 f7       	brne	.-4      	; 0xcb8 <FIFO_init+0x16>
	_delay_us(10);
	FIFO_RCLK_0_CLR;
     cbc:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_0_CLR;
     cbe:	5d 98       	cbi	0x0b, 5	; 11
     cc0:	88 e2       	ldi	r24, 0x28	; 40
     cc2:	8a 95       	dec	r24
     cc4:	f1 f7       	brne	.-4      	; 0xcc2 <FIFO_init+0x20>
	_delay_us(10);
	FIFO_RCLK_0_SET;
     cc6:	5c 9a       	sbi	0x0b, 4	; 11
     cc8:	88 e2       	ldi	r24, 0x28	; 40
     cca:	8a 95       	dec	r24
     ccc:	f1 f7       	brne	.-4      	; 0xcca <FIFO_init+0x28>
	_delay_us(10);
	FIFO_RCLK_0_CLR;
     cce:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_0_SET;
     cd0:	5d 9a       	sbi	0x0b, 5	; 11
     cd2:	88 e2       	ldi	r24, 0x28	; 40
     cd4:	8a 95       	dec	r24
     cd6:	f1 f7       	brne	.-4      	; 0xcd4 <FIFO_init+0x32>
	_delay_us(10);
	FIFO_WRST_0_SET;
     cd8:	5f 9a       	sbi	0x0b, 7	; 11
	
	//Reset Buffer 1
	FIFO_WRST_1_CLR;
     cda:	45 98       	cbi	0x08, 5	; 8
	FIFO_RCLK_1_CLR;
     cdc:	42 98       	cbi	0x08, 2	; 8
	//FIFO_nOE_1_CLR;
	FIFO_nRRST_1_SET;
     cde:	43 9a       	sbi	0x08, 3	; 8
	FIFO_WEN_1_CLR;
     ce0:	44 98       	cbi	0x08, 4	; 8
     ce2:	88 e2       	ldi	r24, 0x28	; 40
     ce4:	8a 95       	dec	r24
     ce6:	f1 f7       	brne	.-4      	; 0xce4 <FIFO_init+0x42>
	_delay_us(10);
	FIFO_RCLK_1_SET;
     ce8:	42 9a       	sbi	0x08, 2	; 8
     cea:	88 e2       	ldi	r24, 0x28	; 40
     cec:	8a 95       	dec	r24
     cee:	f1 f7       	brne	.-4      	; 0xcec <FIFO_init+0x4a>
	_delay_us(10);
	FIFO_RCLK_1_CLR;
     cf0:	42 98       	cbi	0x08, 2	; 8
	FIFO_nRRST_1_CLR;
     cf2:	43 98       	cbi	0x08, 3	; 8
     cf4:	88 e2       	ldi	r24, 0x28	; 40
     cf6:	8a 95       	dec	r24
     cf8:	f1 f7       	brne	.-4      	; 0xcf6 <FIFO_init+0x54>
	_delay_us(10);
	FIFO_RCLK_1_SET;
     cfa:	42 9a       	sbi	0x08, 2	; 8
     cfc:	88 e2       	ldi	r24, 0x28	; 40
     cfe:	8a 95       	dec	r24
     d00:	f1 f7       	brne	.-4      	; 0xcfe <FIFO_init+0x5c>
	_delay_us(10);
	FIFO_RCLK_1_CLR;
     d02:	42 98       	cbi	0x08, 2	; 8
	FIFO_nRRST_1_SET;
     d04:	43 9a       	sbi	0x08, 3	; 8
     d06:	88 e2       	ldi	r24, 0x28	; 40
     d08:	8a 95       	dec	r24
     d0a:	f1 f7       	brne	.-4      	; 0xd08 <FIFO_init+0x66>
	_delay_us(10);
	FIFO_WRST_1_SET;
     d0c:	45 9a       	sbi	0x08, 5	; 8

}
     d0e:	08 95       	ret

00000d10 <FIFO_TO_AVR>:
//Write one pixel in AVR
uint16_t FIFO_TO_AVR(uint8_t ID)
{
	uint16_t data = 0;
	
	DDRA = 0;
     d10:	11 b8       	out	0x01, r1	; 1
	if(ID == 1)
     d12:	81 30       	cpi	r24, 0x01	; 1
     d14:	61 f4       	brne	.+24     	; 0xd2e <FIFO_TO_AVR+0x1e>
	{
		FIFO_RCLK_1_SET;
     d16:	42 9a       	sbi	0x08, 2	; 8
		data = PINA;
     d18:	80 b1       	in	r24, 0x00	; 0
		FIFO_RCLK_1_CLR;
     d1a:	42 98       	cbi	0x08, 2	; 8
		data <<= 8;
     d1c:	38 2f       	mov	r19, r24
     d1e:	20 e0       	ldi	r18, 0x00	; 0
		FIFO_RCLK_1_SET;
     d20:	42 9a       	sbi	0x08, 2	; 8
		data |= PINA;
     d22:	80 b1       	in	r24, 0x00	; 0
     d24:	90 e0       	ldi	r25, 0x00	; 0
     d26:	82 2b       	or	r24, r18
     d28:	93 2b       	or	r25, r19
		FIFO_RCLK_1_CLR;
     d2a:	42 98       	cbi	0x08, 2	; 8
     d2c:	08 95       	ret
	}		
	else
	{	
		FIFO_RCLK_0_SET;
     d2e:	5c 9a       	sbi	0x0b, 4	; 11
		data = PINA;
     d30:	80 b1       	in	r24, 0x00	; 0
		FIFO_RCLK_0_CLR;
     d32:	5c 98       	cbi	0x0b, 4	; 11
		data <<= 8;
     d34:	38 2f       	mov	r19, r24
     d36:	20 e0       	ldi	r18, 0x00	; 0
		FIFO_RCLK_0_SET;
     d38:	5c 9a       	sbi	0x0b, 4	; 11
		data |= PINA;
     d3a:	80 b1       	in	r24, 0x00	; 0
     d3c:	90 e0       	ldi	r25, 0x00	; 0
     d3e:	82 2b       	or	r24, r18
     d40:	93 2b       	or	r25, r19
		FIFO_RCLK_0_CLR;
     d42:	5c 98       	cbi	0x0b, 4	; 11
	}		
	return(data);
}
     d44:	08 95       	ret

00000d46 <FIFO_Reset>:


//Resets both pointers
void FIFO_Reset(uint8_t CameraID)
{
	FIFO_nOE_0_SET;	
     d46:	46 9a       	sbi	0x08, 6	; 8
	FIFO_nOE_1_SET;
     d48:	47 9a       	sbi	0x08, 7	; 8
	if(CameraID == 0)
     d4a:	88 23       	and	r24, r24
     d4c:	39 f4       	brne	.+14     	; 0xd5c <FIFO_Reset+0x16>
	{
		FIFO_WRST_0_CLR;
     d4e:	5f 98       	cbi	0x0b, 7	; 11
		FIFO_nRRST_0_CLR;
     d50:	5d 98       	cbi	0x0b, 5	; 11
		FIFO_RCLK_0_SET;
     d52:	5c 9a       	sbi	0x0b, 4	; 11
		FIFO_RCLK_0_CLR;
     d54:	5c 98       	cbi	0x0b, 4	; 11
		FIFO_nRRST_0_SET;
     d56:	5d 9a       	sbi	0x0b, 5	; 11
		FIFO_WRST_0_SET;
     d58:	5f 9a       	sbi	0x0b, 7	; 11
     d5a:	08 95       	ret
	}
	else
	{
		FIFO_WRST_1_CLR;
     d5c:	45 98       	cbi	0x08, 5	; 8
		FIFO_nRRST_1_CLR;
     d5e:	43 98       	cbi	0x08, 3	; 8
		FIFO_RCLK_1_SET;
     d60:	42 9a       	sbi	0x08, 2	; 8
		FIFO_RCLK_1_CLR;
     d62:	42 98       	cbi	0x08, 2	; 8
		FIFO_nRRST_1_SET;
     d64:	43 9a       	sbi	0x08, 3	; 8
		FIFO_WRST_1_SET;
     d66:	45 9a       	sbi	0x08, 5	; 8
     d68:	08 95       	ret

00000d6a <LoadImagesToBuffer>:
	}
	
}
void LoadImagesToBuffer()
{
	VSYNC_0_Count = 0;
     d6a:	10 92 2f 04 	sts	0x042F, r1
	VSYNC_1_Count = 0;
     d6e:	10 92 70 0c 	sts	0x0C70, r1
	FIFO_Reset(0);
     d72:	80 e0       	ldi	r24, 0x00	; 0
     d74:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
	FIFO_Reset(1);
     d78:	81 e0       	ldi	r24, 0x01	; 1
     d7a:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
	VSYNC_0_Count = 1;
     d7e:	81 e0       	ldi	r24, 0x01	; 1
     d80:	80 93 2f 04 	sts	0x042F, r24
	VSYNC_1_Count = 1;
     d84:	80 93 70 0c 	sts	0x0C70, r24
	
}
     d88:	08 95       	ret

00000d8a <GetImageIfAvailiable>:
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
{
     d8a:	2f 92       	push	r2
     d8c:	3f 92       	push	r3
     d8e:	4f 92       	push	r4
     d90:	5f 92       	push	r5
     d92:	6f 92       	push	r6
     d94:	7f 92       	push	r7
     d96:	8f 92       	push	r8
     d98:	9f 92       	push	r9
     d9a:	af 92       	push	r10
     d9c:	bf 92       	push	r11
     d9e:	cf 92       	push	r12
     da0:	df 92       	push	r13
     da2:	ff 92       	push	r15
     da4:	0f 93       	push	r16
     da6:	1f 93       	push	r17
     da8:	cf 93       	push	r28
     daa:	df 93       	push	r29
     dac:	00 d0       	rcall	.+0      	; 0xdae <GetImageIfAvailiable+0x24>
     dae:	00 d0       	rcall	.+0      	; 0xdb0 <GetImageIfAvailiable+0x26>
     db0:	cd b7       	in	r28, 0x3d	; 61
     db2:	de b7       	in	r29, 0x3e	; 62
     db4:	3c 01       	movw	r6, r24
     db6:	f6 2e       	mov	r15, r22

	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
     db8:	66 23       	and	r22, r22
     dba:	31 f4       	brne	.+12     	; 0xdc8 <GetImageIfAvailiable+0x3e>
     dbc:	80 91 2f 04 	lds	r24, 0x042F
     dc0:	83 30       	cpi	r24, 0x03	; 3
     dc2:	69 f0       	breq	.+26     	; 0xdde <GetImageIfAvailiable+0x54>
		FIFO_nOE_1_SET;
		return 0;
	}
	else
	{
		return 2;
     dc4:	82 e0       	ldi	r24, 0x02	; 2
     dc6:	78 c0       	rjmp	.+240    	; 0xeb8 <GetImageIfAvailiable+0x12e>
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
{

	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
     dc8:	81 e0       	ldi	r24, 0x01	; 1
     dca:	68 17       	cp	r22, r24
     dcc:	09 f0       	breq	.+2      	; 0xdd0 <GetImageIfAvailiable+0x46>
     dce:	73 c0       	rjmp	.+230    	; 0xeb6 <GetImageIfAvailiable+0x12c>
		((CameraID == 1) && (VSYNC_1_Count == 3)) )
     dd0:	80 91 70 0c 	lds	r24, 0x0C70
     dd4:	83 30       	cpi	r24, 0x03	; 3
     dd6:	09 f4       	brne	.+2      	; 0xdda <GetImageIfAvailiable+0x50>
     dd8:	85 c0       	rjmp	.+266    	; 0xee4 <GetImageIfAvailiable+0x15a>
		FIFO_nOE_1_SET;
		return 0;
	}
	else
	{
		return 2;
     dda:	82 e0       	ldi	r24, 0x02	; 2
     ddc:	6d c0       	rjmp	.+218    	; 0xeb8 <GetImageIfAvailiable+0x12e>
	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
		((CameraID == 1) && (VSYNC_1_Count == 3)) )
	{
		
		//Write Bitmap Headers
		WriteBMPHeader(File);
     dde:	c3 01       	movw	r24, r6
     de0:	0e 94 5d 00 	call	0xba	; 0xba <WriteBMPHeader>
		WriteDIBHeader(File);
     de4:	c3 01       	movw	r24, r6
     de6:	0e 94 80 00 	call	0x100	; 0x100 <WriteDIBHeader>
		if (CameraID == 0)
		{
			//Enable output of Camera 0
			FIFO_nOE_0_CLR;
     dea:	46 98       	cbi	0x08, 6	; 8
			//Reset Read Pointer
			FIFO_nRRST_0_CLR;
     dec:	5d 98       	cbi	0x0b, 5	; 11
			FIFO_RCLK_0_SET;
     dee:	5c 9a       	sbi	0x0b, 4	; 11
			FIFO_RCLK_0_CLR;
     df0:	5c 98       	cbi	0x0b, 4	; 11
			FIFO_nRRST_0_SET;
     df2:	5d 9a       	sbi	0x0b, 5	; 11
	VSYNC_0_Count = 1;
	VSYNC_1_Count = 1;
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
{
     df4:	0f 2e       	mov	r0, r31
     df6:	fa e8       	ldi	r31, 0x8A	; 138
     df8:	8f 2e       	mov	r8, r31
     dfa:	f0 e0       	ldi	r31, 0x00	; 0
     dfc:	9f 2e       	mov	r9, r31
     dfe:	f0 e0       	ldi	r31, 0x00	; 0
     e00:	af 2e       	mov	r10, r31
     e02:	f0 e0       	ldi	r31, 0x00	; 0
     e04:	bf 2e       	mov	r11, r31
     e06:	f0 2d       	mov	r31, r0
		uint32_t pointer;
		uint16_t Temp;
		uint32_t p;
		FRESULT fr;
		//for(j = HEIGHT; j>0; j--)
		for(j = 0; j < HEIGHT; j++)
     e08:	0f 2e       	mov	r0, r31
     e0a:	f1 e7       	ldi	r31, 0x71	; 113
     e0c:	4f 2e       	mov	r4, r31
     e0e:	f8 e0       	ldi	r31, 0x08	; 8
     e10:	5f 2e       	mov	r5, r31
     e12:	f0 2d       	mov	r31, r0
	FIFO_Reset(1);
	VSYNC_0_Count = 1;
	VSYNC_1_Count = 1;
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
     e14:	0f 2e       	mov	r0, r31
     e16:	f1 ef       	ldi	r31, 0xF1	; 241
     e18:	cf 2e       	mov	r12, r31
     e1a:	fa e0       	ldi	r31, 0x0A	; 10
     e1c:	df 2e       	mov	r13, r31
     e1e:	f0 2d       	mov	r31, r0
				Buff[pointer++] = (uint8_t)(Temp >> 8);
				Buff[pointer++] = (uint8_t)Temp;
			}
			pointer = (uint32_t)j * (uint32_t)WIDTH * 2 + BMPHEADERSIZE + DIBHEADERSIZE;
			f_lseek(File, pointer);
			fr = f_write(File, Buff, WIDTH * 2, &p);
     e20:	0f 2e       	mov	r0, r31
     e22:	f0 e7       	ldi	r31, 0x70	; 112
     e24:	2f 2e       	mov	r2, r31
     e26:	f8 e0       	ldi	r31, 0x08	; 8
     e28:	3f 2e       	mov	r3, r31
     e2a:	f0 2d       	mov	r31, r0
     e2c:	3b c0       	rjmp	.+118    	; 0xea4 <GetImageIfAvailiable+0x11a>
		for(j = 0; j < HEIGHT; j++)
		{
			pointer = 0;
			for(i = 0; i < WIDTH; i++)
			{
				Temp = FIFO_TO_AVR(CameraID);
     e2e:	8f 2d       	mov	r24, r15
     e30:	0e 94 88 06 	call	0xd10	; 0xd10 <FIFO_TO_AVR>
	FIFO_Reset(1);
	VSYNC_0_Count = 1;
	VSYNC_1_Count = 1;
	
}
uint8_t GetImageIfAvailiable(FIL *File, uint8_t CameraID)
     e34:	f8 01       	movw	r30, r16
     e36:	31 97       	sbiw	r30, 0x01	; 1
			for(i = 0; i < WIDTH; i++)
			{
				Temp = FIFO_TO_AVR(CameraID);
				//USART0_Senduint16(Temp);
				
				Buff[pointer++] = (uint8_t)(Temp >> 8);
     e38:	90 83       	st	Z, r25
				Buff[pointer++] = (uint8_t)Temp;
     e3a:	d8 01       	movw	r26, r16
     e3c:	8c 93       	st	X, r24
     e3e:	0e 5f       	subi	r16, 0xFE	; 254
     e40:	1f 4f       	sbci	r17, 0xFF	; 255
		FRESULT fr;
		//for(j = HEIGHT; j>0; j--)
		for(j = 0; j < HEIGHT; j++)
		{
			pointer = 0;
			for(i = 0; i < WIDTH; i++)
     e42:	0c 15       	cp	r16, r12
     e44:	1d 05       	cpc	r17, r13
     e46:	99 f7       	brne	.-26     	; 0xe2e <GetImageIfAvailiable+0xa4>
				
				Buff[pointer++] = (uint8_t)(Temp >> 8);
				Buff[pointer++] = (uint8_t)Temp;
			}
			pointer = (uint32_t)j * (uint32_t)WIDTH * 2 + BMPHEADERSIZE + DIBHEADERSIZE;
			f_lseek(File, pointer);
     e48:	c3 01       	movw	r24, r6
     e4a:	b5 01       	movw	r22, r10
     e4c:	a4 01       	movw	r20, r8
     e4e:	0e 94 e7 20 	call	0x41ce	; 0x41ce <f_lseek>
			fr = f_write(File, Buff, WIDTH * 2, &p);
     e52:	c3 01       	movw	r24, r6
     e54:	b1 01       	movw	r22, r2
     e56:	20 e8       	ldi	r18, 0x80	; 128
     e58:	32 e0       	ldi	r19, 0x02	; 2
     e5a:	40 e0       	ldi	r20, 0x00	; 0
     e5c:	50 e0       	ldi	r21, 0x00	; 0
     e5e:	8e 01       	movw	r16, r28
     e60:	0f 5f       	subi	r16, 0xFF	; 255
     e62:	1f 4f       	sbci	r17, 0xFF	; 255
     e64:	0e 94 c2 1d 	call	0x3b84	; 0x3b84 <f_write>
			if(fr != FR_OK)
     e68:	88 23       	and	r24, r24
     e6a:	59 f0       	breq	.+22     	; 0xe82 <GetImageIfAvailiable+0xf8>
			{
				//printf("Write Fail.\n");
				VSYNC_0_Count = 0;
     e6c:	10 92 2f 04 	sts	0x042F, r1
				VSYNC_1_Count = 0;
     e70:	10 92 70 0c 	sts	0x0C70, r1
				FIFO_Reset(CameraID);
     e74:	8f 2d       	mov	r24, r15
     e76:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
				FIFO_nOE_0_SET;
     e7a:	46 9a       	sbi	0x08, 6	; 8
				FIFO_nOE_1_SET;
     e7c:	47 9a       	sbi	0x08, 7	; 8
				return 1;
     e7e:	81 e0       	ldi	r24, 0x01	; 1
     e80:	1b c0       	rjmp	.+54     	; 0xeb8 <GetImageIfAvailiable+0x12e>
     e82:	80 e8       	ldi	r24, 0x80	; 128
     e84:	92 e0       	ldi	r25, 0x02	; 2
     e86:	a0 e0       	ldi	r26, 0x00	; 0
     e88:	b0 e0       	ldi	r27, 0x00	; 0
     e8a:	88 0e       	add	r8, r24
     e8c:	99 1e       	adc	r9, r25
     e8e:	aa 1e       	adc	r10, r26
     e90:	bb 1e       	adc	r11, r27
		uint32_t pointer;
		uint16_t Temp;
		uint32_t p;
		FRESULT fr;
		//for(j = HEIGHT; j>0; j--)
		for(j = 0; j < HEIGHT; j++)
     e92:	9a e8       	ldi	r25, 0x8A	; 138
     e94:	89 16       	cp	r8, r25
     e96:	98 e5       	ldi	r25, 0x58	; 88
     e98:	99 06       	cpc	r9, r25
     e9a:	92 e0       	ldi	r25, 0x02	; 2
     e9c:	a9 06       	cpc	r10, r25
     e9e:	90 e0       	ldi	r25, 0x00	; 0
     ea0:	b9 06       	cpc	r11, r25
     ea2:	11 f0       	breq	.+4      	; 0xea8 <GetImageIfAvailiable+0x11e>
     ea4:	82 01       	movw	r16, r4
     ea6:	c3 cf       	rjmp	.-122    	; 0xe2e <GetImageIfAvailiable+0xa4>
				FIFO_nOE_0_SET;
				FIFO_nOE_1_SET;
				return 1;
			}
		}
		FIFO_Reset(CameraID);
     ea8:	8f 2d       	mov	r24, r15
     eaa:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
		//fr = f_close(File);
		FIFO_nOE_0_SET;
     eae:	46 9a       	sbi	0x08, 6	; 8
		FIFO_nOE_1_SET;
     eb0:	47 9a       	sbi	0x08, 7	; 8
		return 0;
     eb2:	80 e0       	ldi	r24, 0x00	; 0
     eb4:	01 c0       	rjmp	.+2      	; 0xeb8 <GetImageIfAvailiable+0x12e>
	}
	else
	{
		return 2;
     eb6:	82 e0       	ldi	r24, 0x02	; 2
	}
}
     eb8:	0f 90       	pop	r0
     eba:	0f 90       	pop	r0
     ebc:	0f 90       	pop	r0
     ebe:	0f 90       	pop	r0
     ec0:	df 91       	pop	r29
     ec2:	cf 91       	pop	r28
     ec4:	1f 91       	pop	r17
     ec6:	0f 91       	pop	r16
     ec8:	ff 90       	pop	r15
     eca:	df 90       	pop	r13
     ecc:	cf 90       	pop	r12
     ece:	bf 90       	pop	r11
     ed0:	af 90       	pop	r10
     ed2:	9f 90       	pop	r9
     ed4:	8f 90       	pop	r8
     ed6:	7f 90       	pop	r7
     ed8:	6f 90       	pop	r6
     eda:	5f 90       	pop	r5
     edc:	4f 90       	pop	r4
     ede:	3f 90       	pop	r3
     ee0:	2f 90       	pop	r2
     ee2:	08 95       	ret
	if(	((CameraID == 0) && (VSYNC_0_Count == 3)) || 
		((CameraID == 1) && (VSYNC_1_Count == 3)) )
	{
		
		//Write Bitmap Headers
		WriteBMPHeader(File);
     ee4:	c3 01       	movw	r24, r6
     ee6:	0e 94 5d 00 	call	0xba	; 0xba <WriteBMPHeader>
		WriteDIBHeader(File);
     eea:	c3 01       	movw	r24, r6
     eec:	0e 94 80 00 	call	0x100	; 0x100 <WriteDIBHeader>
			FIFO_nRRST_0_SET;
		}		
		else 
		{
			//Enable output of Camera 0
			FIFO_nOE_1_CLR;
     ef0:	47 98       	cbi	0x08, 7	; 8
			//Reset Read Pointer
			FIFO_nRRST_1_CLR;
     ef2:	43 98       	cbi	0x08, 3	; 8
			FIFO_RCLK_1_SET;
     ef4:	42 9a       	sbi	0x08, 2	; 8
			FIFO_RCLK_1_CLR;
     ef6:	42 98       	cbi	0x08, 2	; 8
			FIFO_nRRST_1_SET;
     ef8:	43 9a       	sbi	0x08, 3	; 8
     efa:	7c cf       	rjmp	.-264    	; 0xdf4 <GetImageIfAvailiable+0x6a>

00000efc <UI_LEDs>:
#define STATUS_Exit_Bad		0x80

#define Button_Capture		0
#define Button_Exit			3
unsigned char UI_LEDs(uint8_t LED)
{
     efc:	cf 93       	push	r28
     efe:	df 93       	push	r29
     f00:	00 d0       	rcall	.+0      	; 0xf02 <UI_LEDs+0x6>
     f02:	00 d0       	rcall	.+0      	; 0xf04 <UI_LEDs+0x8>
     f04:	cd b7       	in	r28, 0x3d	; 61
     f06:	de b7       	in	r29, 0x3e	; 62
	unsigned char mesbuf[TWI_BUFFER_SIZE];
	mesbuf[0] = (0x15 << TWI_ADR_BITS) | (FALSE << TWI_READ_BIT);
     f08:	9a e2       	ldi	r25, 0x2A	; 42
     f0a:	99 83       	std	Y+1, r25	; 0x01
	mesbuf[1] = 0x10;
     f0c:	90 e1       	ldi	r25, 0x10	; 16
     f0e:	9a 83       	std	Y+2, r25	; 0x02
	mesbuf[2] = LED;
     f10:	8b 83       	std	Y+3, r24	; 0x03
	TWI_Start_Transceiver_With_Data(mesbuf, 3);
     f12:	ce 01       	movw	r24, r28
     f14:	01 96       	adiw	r24, 0x01	; 1
     f16:	63 e0       	ldi	r22, 0x03	; 3
     f18:	0e 94 e3 29 	call	0x53c6	; 0x53c6 <TWI_Start_Transceiver_With_Data>
	while(TWI_Transceiver_Busy())	;
     f1c:	0e 94 d8 29 	call	0x53b0	; 0x53b0 <TWI_Transceiver_Busy>
     f20:	88 23       	and	r24, r24
     f22:	e1 f7       	brne	.-8      	; 0xf1c <UI_LEDs+0x20>
	return TWI_statusReg.lastTransOK;
     f24:	80 91 28 04 	lds	r24, 0x0428
}
     f28:	81 70       	andi	r24, 0x01	; 1
     f2a:	0f 90       	pop	r0
     f2c:	0f 90       	pop	r0
     f2e:	0f 90       	pop	r0
     f30:	0f 90       	pop	r0
     f32:	df 91       	pop	r29
     f34:	cf 91       	pop	r28
     f36:	08 95       	ret

00000f38 <UI_Buttons>:
unsigned char UI_Buttons()
{
     f38:	cf 93       	push	r28
     f3a:	df 93       	push	r29
     f3c:	00 d0       	rcall	.+0      	; 0xf3e <UI_Buttons+0x6>
     f3e:	00 d0       	rcall	.+0      	; 0xf40 <UI_Buttons+0x8>
     f40:	cd b7       	in	r28, 0x3d	; 61
     f42:	de b7       	in	r29, 0x3e	; 62
	unsigned char messageBuf[TWI_BUFFER_SIZE]; //Initialise a buffer
	messageBuf[0] = (0x15<<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
     f44:	8a e2       	ldi	r24, 0x2A	; 42
     f46:	89 83       	std	Y+1, r24	; 0x01
	messageBuf[1] = 0x20;             // The first byte is used for the command
     f48:	80 e2       	ldi	r24, 0x20	; 32
     f4a:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
     f4c:	ce 01       	movw	r24, r28
     f4e:	01 96       	adiw	r24, 0x01	; 1
     f50:	62 e0       	ldi	r22, 0x02	; 2
     f52:	0e 94 e3 29 	call	0x53c6	; 0x53c6 <TWI_Start_Transceiver_With_Data>
     f56:	8d ee       	ldi	r24, 0xED	; 237
     f58:	92 e0       	ldi	r25, 0x02	; 2
     f5a:	01 97       	sbiw	r24, 0x01	; 1
     f5c:	f1 f7       	brne	.-4      	; 0xf5a <UI_Buttons+0x22>
     f5e:	00 c0       	rjmp	.+0      	; 0xf60 <UI_Buttons+0x28>
     f60:	00 00       	nop
	_delay_us(250);
	// Request/collect the data from the Slave
	messageBuf[0] = (0x15<<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
     f62:	8b e2       	ldi	r24, 0x2B	; 43
     f64:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
     f66:	ce 01       	movw	r24, r28
     f68:	01 96       	adiw	r24, 0x01	; 1
     f6a:	62 e0       	ldi	r22, 0x02	; 2
     f6c:	0e 94 e3 29 	call	0x53c6	; 0x53c6 <TWI_Start_Transceiver_With_Data>
	
	// Get the received data from the transceiver buffer
	TWI_Get_Data_From_Transceiver( messageBuf, 2 );
     f70:	ce 01       	movw	r24, r28
     f72:	01 96       	adiw	r24, 0x01	; 1
     f74:	62 e0       	ldi	r22, 0x02	; 2
     f76:	0e 94 19 2a 	call	0x5432	; 0x5432 <TWI_Get_Data_From_Transceiver>
	return messageBuf[1];
}
     f7a:	8a 81       	ldd	r24, Y+2	; 0x02
     f7c:	0f 90       	pop	r0
     f7e:	0f 90       	pop	r0
     f80:	0f 90       	pop	r0
     f82:	0f 90       	pop	r0
     f84:	df 91       	pop	r29
     f86:	cf 91       	pop	r28
     f88:	08 95       	ret

00000f8a <__vector_16>:
ISR(TIMER0_COMPA_vect)
{
     f8a:	1f 92       	push	r1
     f8c:	0f 92       	push	r0
     f8e:	0f b6       	in	r0, 0x3f	; 63
     f90:	0f 92       	push	r0
     f92:	11 24       	eor	r1, r1
     f94:	2f 93       	push	r18
     f96:	3f 93       	push	r19
     f98:	4f 93       	push	r20
     f9a:	5f 93       	push	r21
     f9c:	6f 93       	push	r22
     f9e:	7f 93       	push	r23
     fa0:	8f 93       	push	r24
     fa2:	9f 93       	push	r25
     fa4:	af 93       	push	r26
     fa6:	bf 93       	push	r27
     fa8:	ef 93       	push	r30
     faa:	ff 93       	push	r31
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
     fac:	0e 94 65 05 	call	0xaca	; 0xaca <disk_timerproc>
// 	if(!TWI_statusReg.lastTransOK) //if the last TWI transmission failed, reset the protocol
// 		TWI_Start_Transceiver();
// 	if(!TWI_Transceiver_Busy())
// 		UI_LEDs(StatusReg);
}
     fb0:	ff 91       	pop	r31
     fb2:	ef 91       	pop	r30
     fb4:	bf 91       	pop	r27
     fb6:	af 91       	pop	r26
     fb8:	9f 91       	pop	r25
     fba:	8f 91       	pop	r24
     fbc:	7f 91       	pop	r23
     fbe:	6f 91       	pop	r22
     fc0:	5f 91       	pop	r21
     fc2:	4f 91       	pop	r20
     fc4:	3f 91       	pop	r19
     fc6:	2f 91       	pop	r18
     fc8:	0f 90       	pop	r0
     fca:	0f be       	out	0x3f, r0	; 63
     fcc:	0f 90       	pop	r0
     fce:	1f 90       	pop	r1
     fd0:	18 95       	reti

00000fd2 <main>:
int main(void)
{
     fd2:	2f 92       	push	r2
     fd4:	3f 92       	push	r3
     fd6:	4f 92       	push	r4
     fd8:	5f 92       	push	r5
     fda:	6f 92       	push	r6
     fdc:	7f 92       	push	r7
     fde:	8f 92       	push	r8
     fe0:	9f 92       	push	r9
     fe2:	af 92       	push	r10
     fe4:	bf 92       	push	r11
     fe6:	df 92       	push	r13
     fe8:	ef 92       	push	r14
     fea:	ff 92       	push	r15
     fec:	0f 93       	push	r16
     fee:	1f 93       	push	r17
     ff0:	cf 93       	push	r28
     ff2:	df 93       	push	r29
     ff4:	00 d0       	rcall	.+0      	; 0xff6 <main+0x24>
     ff6:	00 d0       	rcall	.+0      	; 0xff8 <main+0x26>
     ff8:	cd b7       	in	r28, 0x3d	; 61
     ffa:	de b7       	in	r29, 0x3e	; 62
	unsigned long int a = 0;
     ffc:	19 82       	std	Y+1, r1	; 0x01
     ffe:	1a 82       	std	Y+2, r1	; 0x02
    1000:	1b 82       	std	Y+3, r1	; 0x03
    1002:	1c 82       	std	Y+4, r1	; 0x04
	uint8_t b = 0;
	FRESULT fr;
	
	TWI_Master_Initialise();
    1004:	0e 94 ce 29 	call	0x539c	; 0x539c <TWI_Master_Initialise>
	IO_Init();
    1008:	0e 94 a4 00 	call	0x148	; 0x148 <IO_Init>
	sei();
    100c:	78 94       	sei
	PCA9542A_Init();
    100e:	0e 94 76 29 	call	0x52ec	; 0x52ec <PCA9542A_Init>

	StatusReg = STATUS_OKAY;
    1012:	81 e0       	ldi	r24, 0x01	; 1
    1014:	80 93 b9 0e 	sts	0x0EB9, r24
	UI_LEDs(StatusReg);
    1018:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    101c:	8f e2       	ldi	r24, 0x2F	; 47
    101e:	95 e7       	ldi	r25, 0x75	; 117
    1020:	01 97       	sbiw	r24, 0x01	; 1
    1022:	f1 f7       	brne	.-4      	; 0x1020 <main+0x4e>
    1024:	00 c0       	rjmp	.+0      	; 0x1026 <main+0x54>
    1026:	00 00       	nop
	_delay_ms(10);
	UI_Buttons();
    1028:	0e 94 9c 07 	call	0xf38	; 0xf38 <UI_Buttons>

	fr = f_mount(0, &Fatfs[0]);
    102c:	80 e0       	ldi	r24, 0x00	; 0
    102e:	61 e7       	ldi	r22, 0x71	; 113
    1030:	7c e0       	ldi	r23, 0x0C	; 12
    1032:	0e 94 56 1a 	call	0x34ac	; 0x34ac <f_mount>
	if(fr != FR_OK)
    1036:	88 23       	and	r24, r24
    1038:	49 f0       	breq	.+18     	; 0x104c <main+0x7a>
	{
		StatusReg |= (STATUS_Exit_Bad);
    103a:	80 91 b9 0e 	lds	r24, 0x0EB9
    103e:	80 68       	ori	r24, 0x80	; 128
		StatusReg &= ~(STATUS_OKAY);
    1040:	8e 7f       	andi	r24, 0xFE	; 254
    1042:	80 93 b9 0e 	sts	0x0EB9, r24
		UI_LEDs(StatusReg);
    1046:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
		return 0;
    104a:	0c c2       	rjmp	.+1048   	; 0x1464 <__stack+0x365>
	}
	else
		StatusReg |= STATUS_SDOkay;
    104c:	80 91 b9 0e 	lds	r24, 0x0EB9
    1050:	82 60       	ori	r24, 0x02	; 2
    1052:	80 93 b9 0e 	sts	0x0EB9, r24
	UI_LEDs(StatusReg);
    1056:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
	
	fr = f_open(&Files[0], "/log.txt", FA_WRITE|FA_CREATE_ALWAYS);
    105a:	80 e3       	ldi	r24, 0x30	; 48
    105c:	94 e0       	ldi	r25, 0x04	; 4
    105e:	69 ed       	ldi	r22, 0xD9	; 217
    1060:	72 e0       	ldi	r23, 0x02	; 2
    1062:	4a e0       	ldi	r20, 0x0A	; 10
    1064:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <f_open>
	if(fr != FR_OK)
    1068:	88 23       	and	r24, r24
    106a:	49 f0       	breq	.+18     	; 0x107e <main+0xac>
	{
		StatusReg |= (STATUS_Exit_Bad);
    106c:	80 91 b9 0e 	lds	r24, 0x0EB9
    1070:	80 68       	ori	r24, 0x80	; 128
		StatusReg &= ~(1<<STATUS_SDOkay) | (1<<STATUS_OKAY);
    1072:	8b 7f       	andi	r24, 0xFB	; 251
    1074:	80 93 b9 0e 	sts	0x0EB9, r24
		UI_LEDs(StatusReg);
    1078:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
		return 0;
    107c:	f3 c1       	rjmp	.+998    	; 0x1464 <__stack+0x365>
	}		
	UI_LEDs(StatusReg);
    107e:	80 91 b9 0e 	lds	r24, 0x0EB9
    1082:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
	
	f_close(&Files[0]);
    1086:	00 e3       	ldi	r16, 0x30	; 48
    1088:	14 e0       	ldi	r17, 0x04	; 4
    108a:	c8 01       	movw	r24, r16
    108c:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <f_close>
	f_open(&Files[0], "/log.txt", FA_WRITE);
    1090:	c8 01       	movw	r24, r16
    1092:	69 ed       	ldi	r22, 0xD9	; 217
    1094:	72 e0       	ldi	r23, 0x02	; 2
    1096:	42 e0       	ldi	r20, 0x02	; 2
    1098:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <f_open>
	//stdout = &mystdout;
	b = MCUSR;
    109c:	84 b7       	in	r24, 0x34	; 52
	MCUSR = 0;
    109e:	14 be       	out	0x34, r1	; 52
	f_write(&Files[0],"Il Matto Dual Camera\n", sizeof("Il Matto Dual Camera\n"), &a);
    10a0:	c8 01       	movw	r24, r16
    10a2:	62 ee       	ldi	r22, 0xE2	; 226
    10a4:	72 e0       	ldi	r23, 0x02	; 2
    10a6:	26 e1       	ldi	r18, 0x16	; 22
    10a8:	30 e0       	ldi	r19, 0x00	; 0
    10aa:	40 e0       	ldi	r20, 0x00	; 0
    10ac:	50 e0       	ldi	r21, 0x00	; 0
    10ae:	8e 01       	movw	r16, r28
    10b0:	0f 5f       	subi	r16, 0xFF	; 255
    10b2:	1f 4f       	sbci	r17, 0xFF	; 255
    10b4:	0e 94 c2 1d 	call	0x3b84	; 0x3b84 <f_write>

	/*f_write(&Files[0], "System Startup Complete.\n", 26, &a);*/
	
	PCA9542A_SetChannel(CH1);
    10b8:	85 e0       	ldi	r24, 0x05	; 5
    10ba:	0e 94 92 29 	call	0x5324	; 0x5324 <PCA9542A_SetChannel>
	b = OV7670_init();
    10be:	0e 94 21 06 	call	0xc42	; 0xc42 <OV7670_init>
    10c2:	08 2f       	mov	r16, r24
	if(b == 0)
    10c4:	88 23       	and	r24, r24
    10c6:	29 f4       	brne	.+10     	; 0x10d2 <main+0x100>
		StatusReg |= STATUS_CAM1Okay;
    10c8:	80 91 b9 0e 	lds	r24, 0x0EB9
    10cc:	88 60       	ori	r24, 0x08	; 8
    10ce:	80 93 b9 0e 	sts	0x0EB9, r24
	PCA9542A_SetChannel(NO_SELECT);
    10d2:	80 e0       	ldi	r24, 0x00	; 0
    10d4:	0e 94 92 29 	call	0x5324	; 0x5324 <PCA9542A_SetChannel>
	UI_LEDs(StatusReg);
    10d8:	80 91 b9 0e 	lds	r24, 0x0EB9
    10dc:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
	sprintf(Buff, "OV7670_1 Initialise result : %d\n", b);
    10e0:	00 d0       	rcall	.+0      	; 0x10e2 <main+0x110>
    10e2:	00 d0       	rcall	.+0      	; 0x10e4 <main+0x112>
    10e4:	00 d0       	rcall	.+0      	; 0x10e6 <main+0x114>
    10e6:	ed b7       	in	r30, 0x3d	; 61
    10e8:	fe b7       	in	r31, 0x3e	; 62
    10ea:	31 96       	adiw	r30, 0x01	; 1
    10ec:	0f 2e       	mov	r0, r31
    10ee:	f0 e7       	ldi	r31, 0x70	; 112
    10f0:	ef 2e       	mov	r14, r31
    10f2:	f8 e0       	ldi	r31, 0x08	; 8
    10f4:	ff 2e       	mov	r15, r31
    10f6:	f0 2d       	mov	r31, r0
    10f8:	ad b7       	in	r26, 0x3d	; 61
    10fa:	be b7       	in	r27, 0x3e	; 62
    10fc:	12 96       	adiw	r26, 0x02	; 2
    10fe:	fc 92       	st	X, r15
    1100:	ee 92       	st	-X, r14
    1102:	11 97       	sbiw	r26, 0x01	; 1
    1104:	88 ef       	ldi	r24, 0xF8	; 248
    1106:	92 e0       	ldi	r25, 0x02	; 2
    1108:	93 83       	std	Z+3, r25	; 0x03
    110a:	82 83       	std	Z+2, r24	; 0x02
    110c:	04 83       	std	Z+4, r16	; 0x04
    110e:	15 82       	std	Z+5, r1	; 0x05
    1110:	0e 94 6f 2b 	call	0x56de	; 0x56de <sprintf>
	f_write(&Files[0], &Buff, 33, &a);
    1114:	8d b7       	in	r24, 0x3d	; 61
    1116:	9e b7       	in	r25, 0x3e	; 62
    1118:	06 96       	adiw	r24, 0x06	; 6
    111a:	0f b6       	in	r0, 0x3f	; 63
    111c:	f8 94       	cli
    111e:	9e bf       	out	0x3e, r25	; 62
    1120:	0f be       	out	0x3f, r0	; 63
    1122:	8d bf       	out	0x3d, r24	; 61
    1124:	80 e3       	ldi	r24, 0x30	; 48
    1126:	94 e0       	ldi	r25, 0x04	; 4
    1128:	b7 01       	movw	r22, r14
    112a:	21 e2       	ldi	r18, 0x21	; 33
    112c:	30 e0       	ldi	r19, 0x00	; 0
    112e:	40 e0       	ldi	r20, 0x00	; 0
    1130:	50 e0       	ldi	r21, 0x00	; 0
    1132:	8e 01       	movw	r16, r28
    1134:	0f 5f       	subi	r16, 0xFF	; 255
    1136:	1f 4f       	sbci	r17, 0xFF	; 255
    1138:	0e 94 c2 1d 	call	0x3b84	; 0x3b84 <f_write>
	
	PCA9542A_SetChannel(CH0);
    113c:	84 e0       	ldi	r24, 0x04	; 4
    113e:	0e 94 92 29 	call	0x5324	; 0x5324 <PCA9542A_SetChannel>
	b = OV7670_init();
    1142:	0e 94 21 06 	call	0xc42	; 0xc42 <OV7670_init>
    1146:	08 2f       	mov	r16, r24
	if(b == 0)
    1148:	88 23       	and	r24, r24
    114a:	29 f4       	brne	.+10     	; 0x1156 <__stack+0x57>
		StatusReg |= STATUS_CAM0Okay;
    114c:	80 91 b9 0e 	lds	r24, 0x0EB9
    1150:	84 60       	ori	r24, 0x04	; 4
    1152:	80 93 b9 0e 	sts	0x0EB9, r24
	UI_LEDs(StatusReg);
    1156:	80 91 b9 0e 	lds	r24, 0x0EB9
    115a:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
	PCA9542A_SetChannel(NO_SELECT);
    115e:	80 e0       	ldi	r24, 0x00	; 0
    1160:	0e 94 92 29 	call	0x5324	; 0x5324 <PCA9542A_SetChannel>
	sprintf(Buff, "OV7670_0 Initialise result : %d\n", b);
    1164:	00 d0       	rcall	.+0      	; 0x1166 <__stack+0x67>
    1166:	00 d0       	rcall	.+0      	; 0x1168 <__stack+0x69>
    1168:	00 d0       	rcall	.+0      	; 0x116a <__stack+0x6b>
    116a:	ed b7       	in	r30, 0x3d	; 61
    116c:	fe b7       	in	r31, 0x3e	; 62
    116e:	31 96       	adiw	r30, 0x01	; 1
    1170:	0f 2e       	mov	r0, r31
    1172:	f0 e7       	ldi	r31, 0x70	; 112
    1174:	ef 2e       	mov	r14, r31
    1176:	f8 e0       	ldi	r31, 0x08	; 8
    1178:	ff 2e       	mov	r15, r31
    117a:	f0 2d       	mov	r31, r0
    117c:	ad b7       	in	r26, 0x3d	; 61
    117e:	be b7       	in	r27, 0x3e	; 62
    1180:	12 96       	adiw	r26, 0x02	; 2
    1182:	fc 92       	st	X, r15
    1184:	ee 92       	st	-X, r14
    1186:	11 97       	sbiw	r26, 0x01	; 1
    1188:	89 e1       	ldi	r24, 0x19	; 25
    118a:	93 e0       	ldi	r25, 0x03	; 3
    118c:	93 83       	std	Z+3, r25	; 0x03
    118e:	82 83       	std	Z+2, r24	; 0x02
    1190:	04 83       	std	Z+4, r16	; 0x04
    1192:	15 82       	std	Z+5, r1	; 0x05
    1194:	0e 94 6f 2b 	call	0x56de	; 0x56de <sprintf>
	f_write(&Files[0], &Buff, 33, &a);
    1198:	8d b7       	in	r24, 0x3d	; 61
    119a:	9e b7       	in	r25, 0x3e	; 62
    119c:	06 96       	adiw	r24, 0x06	; 6
    119e:	0f b6       	in	r0, 0x3f	; 63
    11a0:	f8 94       	cli
    11a2:	9e bf       	out	0x3e, r25	; 62
    11a4:	0f be       	out	0x3f, r0	; 63
    11a6:	8d bf       	out	0x3d, r24	; 61
    11a8:	80 e3       	ldi	r24, 0x30	; 48
    11aa:	94 e0       	ldi	r25, 0x04	; 4
    11ac:	b7 01       	movw	r22, r14
    11ae:	21 e2       	ldi	r18, 0x21	; 33
    11b0:	30 e0       	ldi	r19, 0x00	; 0
    11b2:	40 e0       	ldi	r20, 0x00	; 0
    11b4:	50 e0       	ldi	r21, 0x00	; 0
    11b6:	8e 01       	movw	r16, r28
    11b8:	0f 5f       	subi	r16, 0xFF	; 255
    11ba:	1f 4f       	sbci	r17, 0xFF	; 255
    11bc:	0e 94 c2 1d 	call	0x3b84	; 0x3b84 <f_write>
	FIFO_init();
    11c0:	0e 94 51 06 	call	0xca2	; 0xca2 <FIFO_init>

	//f_close(&Files[0]);
	StatusReg |= STATUS_READY;
    11c4:	80 91 b9 0e 	lds	r24, 0x0EB9
    11c8:	80 61       	ori	r24, 0x10	; 16
    11ca:	80 93 b9 0e 	sts	0x0EB9, r24
	UI_LEDs(StatusReg);
    11ce:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
    11d2:	8f eb       	ldi	r24, 0xBF	; 191
    11d4:	97 e2       	ldi	r25, 0x27	; 39
    11d6:	a9 e0       	ldi	r26, 0x09	; 9
    11d8:	81 50       	subi	r24, 0x01	; 1
    11da:	90 40       	sbci	r25, 0x00	; 0
    11dc:	a0 40       	sbci	r26, 0x00	; 0
    11de:	e1 f7       	brne	.-8      	; 0x11d8 <__stack+0xd9>
    11e0:	00 c0       	rjmp	.+0      	; 0x11e2 <__stack+0xe3>
    11e2:	00 00       	nop
    {
		Input = (~UI_Buttons() & 0x0F);//Data is received negative
		if(Input)//if a button has been pressed
		{
			_delay_ms(250);
			sprintf(Buff, "Button Received : %d\n", Input);
    11e4:	47 01       	movw	r8, r14
    11e6:	0f 2e       	mov	r0, r31
    11e8:	fa e3       	ldi	r31, 0x3A	; 58
    11ea:	6f 2e       	mov	r6, r31
    11ec:	f3 e0       	ldi	r31, 0x03	; 3
    11ee:	7f 2e       	mov	r7, r31
    11f0:	f0 2d       	mov	r31, r0
			f_write(&Files[0], Buff, 21, &a);
    11f2:	0f 2e       	mov	r0, r31
    11f4:	f0 e3       	ldi	r31, 0x30	; 48
    11f6:	af 2e       	mov	r10, r31
    11f8:	f4 e0       	ldi	r31, 0x04	; 4
    11fa:	bf 2e       	mov	r11, r31
    11fc:	f0 2d       	mov	r31, r0
					FIFO_Reset(1);
					f_write(&Files[0], "Capturing Images...\n", 20, &a);
					LoadImagesToBuffer();//Load both images
					
					//Create Bitmap for image 0
					f_open(&Files[1], "/image0.bmp", FA_CREATE_ALWAYS | FA_WRITE);
    11fe:	0f 2e       	mov	r0, r31
    1200:	f0 e5       	ldi	r31, 0x50	; 80
    1202:	ef 2e       	mov	r14, r31
    1204:	f6 e0       	ldi	r31, 0x06	; 6
    1206:	ff 2e       	mov	r15, r31
    1208:	f0 2d       	mov	r31, r0
    120a:	0f 2e       	mov	r0, r31
    120c:	f5 e6       	ldi	r31, 0x65	; 101
    120e:	4f 2e       	mov	r4, r31
    1210:	f3 e0       	ldi	r31, 0x03	; 3
    1212:	5f 2e       	mov	r5, r31
    1214:	f0 2d       	mov	r31, r0
					f_lseek(&Files[1], 0);
					f_close(&Files[1]);
					f_write(&Files[0], "Extended image0 file.\n", 22, &a);
					
					//Create Bitmap for image 1
					f_open(&Files[1], "/image1.bmp", FA_CREATE_ALWAYS | FA_WRITE);
    1216:	0f 2e       	mov	r0, r31
    1218:	fe e9       	ldi	r31, 0x9E	; 158
    121a:	2f 2e       	mov	r2, r31
    121c:	f3 e0       	ldi	r31, 0x03	; 3
    121e:	3f 2e       	mov	r3, r31
    1220:	f0 2d       	mov	r31, r0
	_delay_ms(250);
	uint8_t Input;
	
    while(1)
    {
		Input = (~UI_Buttons() & 0x0F);//Data is received negative
    1222:	0e 94 9c 07 	call	0xf38	; 0xf38 <UI_Buttons>
    1226:	80 95       	com	r24
    1228:	0f 2e       	mov	r0, r31
    122a:	ff e0       	ldi	r31, 0x0F	; 15
    122c:	df 2e       	mov	r13, r31
    122e:	f0 2d       	mov	r31, r0
    1230:	d8 22       	and	r13, r24
		if(Input)//if a button has been pressed
    1232:	09 f4       	brne	.+2      	; 0x1236 <__stack+0x137>
    1234:	06 c1       	rjmp	.+524    	; 0x1442 <__stack+0x343>
    1236:	8f eb       	ldi	r24, 0xBF	; 191
    1238:	97 e2       	ldi	r25, 0x27	; 39
    123a:	a9 e0       	ldi	r26, 0x09	; 9
    123c:	81 50       	subi	r24, 0x01	; 1
    123e:	90 40       	sbci	r25, 0x00	; 0
    1240:	a0 40       	sbci	r26, 0x00	; 0
    1242:	e1 f7       	brne	.-8      	; 0x123c <__stack+0x13d>
    1244:	00 c0       	rjmp	.+0      	; 0x1246 <__stack+0x147>
    1246:	00 00       	nop
		{
			_delay_ms(250);
			sprintf(Buff, "Button Received : %d\n", Input);
    1248:	00 d0       	rcall	.+0      	; 0x124a <__stack+0x14b>
    124a:	00 d0       	rcall	.+0      	; 0x124c <__stack+0x14d>
    124c:	00 d0       	rcall	.+0      	; 0x124e <__stack+0x14f>
    124e:	ed b7       	in	r30, 0x3d	; 61
    1250:	fe b7       	in	r31, 0x3e	; 62
    1252:	31 96       	adiw	r30, 0x01	; 1
    1254:	ad b7       	in	r26, 0x3d	; 61
    1256:	be b7       	in	r27, 0x3e	; 62
    1258:	12 96       	adiw	r26, 0x02	; 2
    125a:	9c 92       	st	X, r9
    125c:	8e 92       	st	-X, r8
    125e:	11 97       	sbiw	r26, 0x01	; 1
    1260:	73 82       	std	Z+3, r7	; 0x03
    1262:	62 82       	std	Z+2, r6	; 0x02
    1264:	d4 82       	std	Z+4, r13	; 0x04
    1266:	15 82       	std	Z+5, r1	; 0x05
    1268:	0e 94 6f 2b 	call	0x56de	; 0x56de <sprintf>
			f_write(&Files[0], Buff, 21, &a);
    126c:	8d b7       	in	r24, 0x3d	; 61
    126e:	9e b7       	in	r25, 0x3e	; 62
    1270:	06 96       	adiw	r24, 0x06	; 6
    1272:	0f b6       	in	r0, 0x3f	; 63
    1274:	f8 94       	cli
    1276:	9e bf       	out	0x3e, r25	; 62
    1278:	0f be       	out	0x3f, r0	; 63
    127a:	8d bf       	out	0x3d, r24	; 61
    127c:	c5 01       	movw	r24, r10
    127e:	b4 01       	movw	r22, r8
    1280:	25 e1       	ldi	r18, 0x15	; 21
    1282:	30 e0       	ldi	r19, 0x00	; 0
    1284:	40 e0       	ldi	r20, 0x00	; 0
    1286:	50 e0       	ldi	r21, 0x00	; 0
    1288:	8e 01       	movw	r16, r28
    128a:	0f 5f       	subi	r16, 0xFF	; 255
    128c:	1f 4f       	sbci	r17, 0xFF	; 255
    128e:	0e 94 c2 1d 	call	0x3b84	; 0x3b84 <f_write>
			
			StatusReg&= ~(STATUS_READY);//no longer ready
    1292:	80 91 b9 0e 	lds	r24, 0x0EB9
    1296:	8f 7e       	andi	r24, 0xEF	; 239
    1298:	80 93 b9 0e 	sts	0x0EB9, r24
			
			switch(Input)
    129c:	91 e0       	ldi	r25, 0x01	; 1
    129e:	d9 16       	cp	r13, r25
    12a0:	29 f0       	breq	.+10     	; 0x12ac <__stack+0x1ad>
    12a2:	a8 e0       	ldi	r26, 0x08	; 8
    12a4:	da 16       	cp	r13, r26
    12a6:	09 f0       	breq	.+2      	; 0x12aa <__stack+0x1ab>
    12a8:	bc cf       	rjmp	.-136    	; 0x1222 <__stack+0x123>
    12aa:	b0 c0       	rjmp	.+352    	; 0x140c <__stack+0x30d>
			{
				case (1<<Button_Capture):
					StatusReg |= STATUS_CAPTURING;
    12ac:	80 62       	ori	r24, 0x20	; 32
    12ae:	80 93 b9 0e 	sts	0x0EB9, r24
					UI_LEDs(StatusReg);
    12b2:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
					//Reset both buffers
					FIFO_Reset(0);
    12b6:	80 e0       	ldi	r24, 0x00	; 0
    12b8:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
					FIFO_Reset(1);
    12bc:	81 e0       	ldi	r24, 0x01	; 1
    12be:	0e 94 a3 06 	call	0xd46	; 0xd46 <FIFO_Reset>
					f_write(&Files[0], "Capturing Images...\n", 20, &a);
    12c2:	c5 01       	movw	r24, r10
    12c4:	60 e5       	ldi	r22, 0x50	; 80
    12c6:	73 e0       	ldi	r23, 0x03	; 3
    12c8:	24 e1       	ldi	r18, 0x14	; 20
    12ca:	30 e0       	ldi	r19, 0x00	; 0
    12cc:	40 e0       	ldi	r20, 0x00	; 0
    12ce:	50 e0       	ldi	r21, 0x00	; 0
    12d0:	8e 01       	movw	r16, r28
    12d2:	0f 5f       	subi	r16, 0xFF	; 255
    12d4:	1f 4f       	sbci	r17, 0xFF	; 255
    12d6:	0e 94 c2 1d 	call	0x3b84	; 0x3b84 <f_write>
					LoadImagesToBuffer();//Load both images
    12da:	0e 94 b5 06 	call	0xd6a	; 0xd6a <LoadImagesToBuffer>
					
					//Create Bitmap for image 0
					f_open(&Files[1], "/image0.bmp", FA_CREATE_ALWAYS | FA_WRITE);
    12de:	c7 01       	movw	r24, r14
    12e0:	b2 01       	movw	r22, r4
    12e2:	4a e0       	ldi	r20, 0x0A	; 10
    12e4:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <f_open>
					f_write(&Files[0], "Created image0 file.\n", 22, &a);
    12e8:	c5 01       	movw	r24, r10
    12ea:	61 e7       	ldi	r22, 0x71	; 113
    12ec:	73 e0       	ldi	r23, 0x03	; 3
    12ee:	26 e1       	ldi	r18, 0x16	; 22
    12f0:	30 e0       	ldi	r19, 0x00	; 0
    12f2:	40 e0       	ldi	r20, 0x00	; 0
    12f4:	50 e0       	ldi	r21, 0x00	; 0
    12f6:	8e 01       	movw	r16, r28
    12f8:	0f 5f       	subi	r16, 0xFF	; 255
    12fa:	1f 4f       	sbci	r17, 0xFF	; 255
    12fc:	0e 94 c2 1d 	call	0x3b84	; 0x3b84 <f_write>
					f_lseek(&Files[1], BMPFileSize);
    1300:	c7 01       	movw	r24, r14
    1302:	4a e8       	ldi	r20, 0x8A	; 138
    1304:	58 e5       	ldi	r21, 0x58	; 88
    1306:	62 e0       	ldi	r22, 0x02	; 2
    1308:	70 e0       	ldi	r23, 0x00	; 0
    130a:	0e 94 e7 20 	call	0x41ce	; 0x41ce <f_lseek>
					f_lseek(&Files[1], 0);
    130e:	c7 01       	movw	r24, r14
    1310:	40 e0       	ldi	r20, 0x00	; 0
    1312:	50 e0       	ldi	r21, 0x00	; 0
    1314:	ba 01       	movw	r22, r20
    1316:	0e 94 e7 20 	call	0x41ce	; 0x41ce <f_lseek>
					f_close(&Files[1]);
    131a:	c7 01       	movw	r24, r14
    131c:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <f_close>
					f_write(&Files[0], "Extended image0 file.\n", 22, &a);
    1320:	c5 01       	movw	r24, r10
    1322:	67 e8       	ldi	r22, 0x87	; 135
    1324:	73 e0       	ldi	r23, 0x03	; 3
    1326:	26 e1       	ldi	r18, 0x16	; 22
    1328:	30 e0       	ldi	r19, 0x00	; 0
    132a:	40 e0       	ldi	r20, 0x00	; 0
    132c:	50 e0       	ldi	r21, 0x00	; 0
    132e:	8e 01       	movw	r16, r28
    1330:	0f 5f       	subi	r16, 0xFF	; 255
    1332:	1f 4f       	sbci	r17, 0xFF	; 255
    1334:	0e 94 c2 1d 	call	0x3b84	; 0x3b84 <f_write>
					
					//Create Bitmap for image 1
					f_open(&Files[1], "/image1.bmp", FA_CREATE_ALWAYS | FA_WRITE);
    1338:	c7 01       	movw	r24, r14
    133a:	b1 01       	movw	r22, r2
    133c:	4a e0       	ldi	r20, 0x0A	; 10
    133e:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <f_open>
					f_write(&Files[0], "Created image1 file.\n", 22, &a);
    1342:	c5 01       	movw	r24, r10
    1344:	6a ea       	ldi	r22, 0xAA	; 170
    1346:	73 e0       	ldi	r23, 0x03	; 3
    1348:	26 e1       	ldi	r18, 0x16	; 22
    134a:	30 e0       	ldi	r19, 0x00	; 0
    134c:	40 e0       	ldi	r20, 0x00	; 0
    134e:	50 e0       	ldi	r21, 0x00	; 0
    1350:	8e 01       	movw	r16, r28
    1352:	0f 5f       	subi	r16, 0xFF	; 255
    1354:	1f 4f       	sbci	r17, 0xFF	; 255
    1356:	0e 94 c2 1d 	call	0x3b84	; 0x3b84 <f_write>
					f_lseek(&Files[1], BMPFileSize);
    135a:	c7 01       	movw	r24, r14
    135c:	4a e8       	ldi	r20, 0x8A	; 138
    135e:	58 e5       	ldi	r21, 0x58	; 88
    1360:	62 e0       	ldi	r22, 0x02	; 2
    1362:	70 e0       	ldi	r23, 0x00	; 0
    1364:	0e 94 e7 20 	call	0x41ce	; 0x41ce <f_lseek>
					f_lseek(&Files[1], 0);
    1368:	c7 01       	movw	r24, r14
    136a:	40 e0       	ldi	r20, 0x00	; 0
    136c:	50 e0       	ldi	r21, 0x00	; 0
    136e:	ba 01       	movw	r22, r20
    1370:	0e 94 e7 20 	call	0x41ce	; 0x41ce <f_lseek>
					f_close(&Files[1]);
    1374:	c7 01       	movw	r24, r14
    1376:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <f_close>
					f_write(&Files[0], "Extended image1 file.\n", 22, &a);
    137a:	c5 01       	movw	r24, r10
    137c:	60 ec       	ldi	r22, 0xC0	; 192
    137e:	73 e0       	ldi	r23, 0x03	; 3
    1380:	26 e1       	ldi	r18, 0x16	; 22
    1382:	30 e0       	ldi	r19, 0x00	; 0
    1384:	40 e0       	ldi	r20, 0x00	; 0
    1386:	50 e0       	ldi	r21, 0x00	; 0
    1388:	8e 01       	movw	r16, r28
    138a:	0f 5f       	subi	r16, 0xFF	; 255
    138c:	1f 4f       	sbci	r17, 0xFF	; 255
    138e:	0e 94 c2 1d 	call	0x3b84	; 0x3b84 <f_write>
					//Get image 0
					f_open(&Files[1], "/image0.bmp", FA_WRITE);
    1392:	c7 01       	movw	r24, r14
    1394:	b2 01       	movw	r22, r4
    1396:	42 e0       	ldi	r20, 0x02	; 2
    1398:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <f_open>
					while (2 == GetImageIfAvailiable(&Files[1], 0))	;
    139c:	c7 01       	movw	r24, r14
    139e:	60 e0       	ldi	r22, 0x00	; 0
    13a0:	0e 94 c5 06 	call	0xd8a	; 0xd8a <GetImageIfAvailiable>
    13a4:	82 30       	cpi	r24, 0x02	; 2
    13a6:	d1 f3       	breq	.-12     	; 0x139c <__stack+0x29d>
					f_close(&Files[1]);
    13a8:	c7 01       	movw	r24, r14
    13aa:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <f_close>
					f_write(&Files[0], "Captured image0.\n", 17, &a);
    13ae:	c5 01       	movw	r24, r10
    13b0:	67 ed       	ldi	r22, 0xD7	; 215
    13b2:	73 e0       	ldi	r23, 0x03	; 3
    13b4:	21 e1       	ldi	r18, 0x11	; 17
    13b6:	30 e0       	ldi	r19, 0x00	; 0
    13b8:	40 e0       	ldi	r20, 0x00	; 0
    13ba:	50 e0       	ldi	r21, 0x00	; 0
    13bc:	8e 01       	movw	r16, r28
    13be:	0f 5f       	subi	r16, 0xFF	; 255
    13c0:	1f 4f       	sbci	r17, 0xFF	; 255
    13c2:	0e 94 c2 1d 	call	0x3b84	; 0x3b84 <f_write>
					//get image 1
					f_open(&Files[1], "/image1.bmp", FA_WRITE);
    13c6:	c7 01       	movw	r24, r14
    13c8:	b1 01       	movw	r22, r2
    13ca:	42 e0       	ldi	r20, 0x02	; 2
    13cc:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <f_open>
					while (2 == GetImageIfAvailiable(&Files[1], 1))	;
    13d0:	c7 01       	movw	r24, r14
    13d2:	61 e0       	ldi	r22, 0x01	; 1
    13d4:	0e 94 c5 06 	call	0xd8a	; 0xd8a <GetImageIfAvailiable>
    13d8:	82 30       	cpi	r24, 0x02	; 2
    13da:	d1 f3       	breq	.-12     	; 0x13d0 <__stack+0x2d1>
					f_close(&Files[1]);
    13dc:	c7 01       	movw	r24, r14
    13de:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <f_close>
					f_write(&Files[0], "Captured image1.\n", 17, &a);
    13e2:	c5 01       	movw	r24, r10
    13e4:	69 ee       	ldi	r22, 0xE9	; 233
    13e6:	73 e0       	ldi	r23, 0x03	; 3
    13e8:	21 e1       	ldi	r18, 0x11	; 17
    13ea:	30 e0       	ldi	r19, 0x00	; 0
    13ec:	40 e0       	ldi	r20, 0x00	; 0
    13ee:	50 e0       	ldi	r21, 0x00	; 0
    13f0:	8e 01       	movw	r16, r28
    13f2:	0f 5f       	subi	r16, 0xFF	; 255
    13f4:	1f 4f       	sbci	r17, 0xFF	; 255
    13f6:	0e 94 c2 1d 	call	0x3b84	; 0x3b84 <f_write>
					StatusReg |= STATUS_READY;
    13fa:	80 91 b9 0e 	lds	r24, 0x0EB9
    13fe:	80 61       	ori	r24, 0x10	; 16
					StatusReg &= ~STATUS_CAPTURING;
    1400:	8f 7d       	andi	r24, 0xDF	; 223
    1402:	80 93 b9 0e 	sts	0x0EB9, r24
					UI_LEDs(StatusReg);
    1406:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
					break;//break case(1<<ButtonCapture)
    140a:	0b cf       	rjmp	.-490    	; 0x1222 <__stack+0x123>
					
				case (1<<Button_Exit):
					f_write(&Files[0], "\nSystem Exiting...\n",19 ,&a);
    140c:	0f 2e       	mov	r0, r31
    140e:	f0 e3       	ldi	r31, 0x30	; 48
    1410:	ef 2e       	mov	r14, r31
    1412:	f4 e0       	ldi	r31, 0x04	; 4
    1414:	ff 2e       	mov	r15, r31
    1416:	f0 2d       	mov	r31, r0
    1418:	c7 01       	movw	r24, r14
    141a:	6b ef       	ldi	r22, 0xFB	; 251
    141c:	73 e0       	ldi	r23, 0x03	; 3
    141e:	23 e1       	ldi	r18, 0x13	; 19
    1420:	30 e0       	ldi	r19, 0x00	; 0
    1422:	40 e0       	ldi	r20, 0x00	; 0
    1424:	50 e0       	ldi	r21, 0x00	; 0
    1426:	8e 01       	movw	r16, r28
    1428:	0f 5f       	subi	r16, 0xFF	; 255
    142a:	1f 4f       	sbci	r17, 0xFF	; 255
    142c:	0e 94 c2 1d 	call	0x3b84	; 0x3b84 <f_write>
					f_close(&Files[0]);//close log file
    1430:	c7 01       	movw	r24, r14
    1432:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <f_close>
					
					StatusReg = 0x41;
    1436:	81 e4       	ldi	r24, 0x41	; 65
    1438:	80 93 b9 0e 	sts	0x0EB9, r24
					UI_LEDs(StatusReg);
    143c:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
					return 0;//Q
    1440:	11 c0       	rjmp	.+34     	; 0x1464 <__stack+0x365>
			}//End switch
		}//End if(Input)
		else
		{
			StatusReg |= STATUS_READY;
    1442:	80 91 b9 0e 	lds	r24, 0x0EB9
    1446:	80 61       	ori	r24, 0x10	; 16
    1448:	80 93 b9 0e 	sts	0x0EB9, r24
			UI_LEDs(StatusReg);
    144c:	0e 94 7e 07 	call	0xefc	; 0xefc <UI_LEDs>
    1450:	8f eb       	ldi	r24, 0xBF	; 191
    1452:	97 e2       	ldi	r25, 0x27	; 39
    1454:	a9 e0       	ldi	r26, 0x09	; 9
    1456:	81 50       	subi	r24, 0x01	; 1
    1458:	90 40       	sbci	r25, 0x00	; 0
    145a:	a0 40       	sbci	r26, 0x00	; 0
    145c:	e1 f7       	brne	.-8      	; 0x1456 <__stack+0x357>
    145e:	00 c0       	rjmp	.+0      	; 0x1460 <__stack+0x361>
    1460:	00 00       	nop
    1462:	df ce       	rjmp	.-578    	; 0x1222 <__stack+0x123>
			_delay_ms(250);//wait
		}//end else(Input)					
    }//End while(1)
    1464:	80 e0       	ldi	r24, 0x00	; 0
    1466:	90 e0       	ldi	r25, 0x00	; 0
    1468:	0f 90       	pop	r0
    146a:	0f 90       	pop	r0
    146c:	0f 90       	pop	r0
    146e:	0f 90       	pop	r0
    1470:	df 91       	pop	r29
    1472:	cf 91       	pop	r28
    1474:	1f 91       	pop	r17
    1476:	0f 91       	pop	r16
    1478:	ff 90       	pop	r15
    147a:	ef 90       	pop	r14
    147c:	df 90       	pop	r13
    147e:	bf 90       	pop	r11
    1480:	af 90       	pop	r10
    1482:	9f 90       	pop	r9
    1484:	8f 90       	pop	r8
    1486:	7f 90       	pop	r7
    1488:	6f 90       	pop	r6
    148a:	5f 90       	pop	r5
    148c:	4f 90       	pop	r4
    148e:	3f 90       	pop	r3
    1490:	2f 90       	pop	r2
    1492:	08 95       	ret

00001494 <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
    1494:	e6 2f       	mov	r30, r22
    1496:	f7 2f       	mov	r31, r23
    1498:	ba 01       	movw	r22, r20
    149a:	a9 01       	movw	r20, r18
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
    149c:	41 15       	cp	r20, r1
    149e:	51 05       	cpc	r21, r1
    14a0:	61 05       	cpc	r22, r1
    14a2:	71 05       	cpc	r23, r1
    14a4:	59 f0       	breq	.+22     	; 0x14bc <mem_cpy+0x28>
    14a6:	ae 2f       	mov	r26, r30
    14a8:	bf 2f       	mov	r27, r31
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    14aa:	e8 2f       	mov	r30, r24
    14ac:	f9 2f       	mov	r31, r25
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
    14ae:	8d 91       	ld	r24, X+
    14b0:	81 93       	st	Z+, r24
    14b2:	41 50       	subi	r20, 0x01	; 1
    14b4:	50 40       	sbci	r21, 0x00	; 0
    14b6:	60 40       	sbci	r22, 0x00	; 0
    14b8:	70 40       	sbci	r23, 0x00	; 0
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
    14ba:	c9 f7       	brne	.-14     	; 0x14ae <mem_cpy+0x1a>
    14bc:	08 95       	ret

000014be <mem_set>:
		*d++ = *s++;
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
    14be:	a6 2f       	mov	r26, r22
    14c0:	ba 01       	movw	r22, r20
    14c2:	a9 01       	movw	r20, r18
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    14c4:	41 15       	cp	r20, r1
    14c6:	51 05       	cpc	r21, r1
    14c8:	61 05       	cpc	r22, r1
    14ca:	71 05       	cpc	r23, r1
    14cc:	41 f0       	breq	.+16     	; 0x14de <mem_set+0x20>
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    14ce:	e8 2f       	mov	r30, r24
    14d0:	f9 2f       	mov	r31, r25

	while (cnt--)
		*d++ = (BYTE)val;
    14d2:	a1 93       	st	Z+, r26
    14d4:	41 50       	subi	r20, 0x01	; 1
    14d6:	50 40       	sbci	r21, 0x00	; 0
    14d8:	60 40       	sbci	r22, 0x00	; 0
    14da:	70 40       	sbci	r23, 0x00	; 0
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    14dc:	d1 f7       	brne	.-12     	; 0x14d2 <mem_set+0x14>
    14de:	08 95       	ret

000014e0 <ld_clust>:
static
DWORD ld_clust (
	FATFS *fs,	/* Pointer to the fs object */
	BYTE *dir	/* Pointer to the directory entry */
)
{
    14e0:	0f 93       	push	r16
    14e2:	1f 93       	push	r17
    14e4:	dc 01       	movw	r26, r24
    14e6:	fb 01       	movw	r30, r22
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
    14e8:	93 8d       	ldd	r25, Z+27	; 0x1b
    14ea:	80 e0       	ldi	r24, 0x00	; 0
    14ec:	02 8d       	ldd	r16, Z+26	; 0x1a
    14ee:	10 e0       	ldi	r17, 0x00	; 0
    14f0:	08 2b       	or	r16, r24
    14f2:	19 2b       	or	r17, r25
    14f4:	20 e0       	ldi	r18, 0x00	; 0
    14f6:	30 e0       	ldi	r19, 0x00	; 0
	if (fs->fs_type == FS_FAT32)
    14f8:	8c 91       	ld	r24, X
    14fa:	83 30       	cpi	r24, 0x03	; 3
    14fc:	79 f4       	brne	.+30     	; 0x151c <ld_clust+0x3c>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
    14fe:	55 89       	ldd	r21, Z+21	; 0x15
    1500:	40 e0       	ldi	r20, 0x00	; 0
    1502:	84 89       	ldd	r24, Z+20	; 0x14
    1504:	90 e0       	ldi	r25, 0x00	; 0
    1506:	84 2b       	or	r24, r20
    1508:	95 2b       	or	r25, r21
    150a:	a0 e0       	ldi	r26, 0x00	; 0
    150c:	b0 e0       	ldi	r27, 0x00	; 0
    150e:	dc 01       	movw	r26, r24
    1510:	99 27       	eor	r25, r25
    1512:	88 27       	eor	r24, r24
    1514:	08 2b       	or	r16, r24
    1516:	19 2b       	or	r17, r25
    1518:	2a 2b       	or	r18, r26
    151a:	3b 2b       	or	r19, r27

	return cl;
}
    151c:	60 2f       	mov	r22, r16
    151e:	71 2f       	mov	r23, r17
    1520:	82 2f       	mov	r24, r18
    1522:	93 2f       	mov	r25, r19
    1524:	1f 91       	pop	r17
    1526:	0f 91       	pop	r16
    1528:	08 95       	ret

0000152a <st_clust>:
static
void st_clust (
	BYTE *dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
    152a:	fc 01       	movw	r30, r24
	ST_WORD(dir+DIR_FstClusLO, cl);
    152c:	42 8f       	std	Z+26, r20	; 0x1a
    152e:	53 8f       	std	Z+27, r21	; 0x1b
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
    1530:	ab 01       	movw	r20, r22
    1532:	66 27       	eor	r22, r22
    1534:	77 27       	eor	r23, r23
    1536:	44 8b       	std	Z+20, r20	; 0x14
    1538:	55 8b       	std	Z+21, r21	; 0x15
}
    153a:	08 95       	ret

0000153c <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to the file information to be filled */
)
{
    153c:	ef 92       	push	r14
    153e:	ff 92       	push	r15
    1540:	0f 93       	push	r16
    1542:	1f 93       	push	r17
    1544:	cf 93       	push	r28
    1546:	df 93       	push	r29
    1548:	fc 01       	movw	r30, r24
    154a:	7b 01       	movw	r14, r22
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
    154c:	8b 01       	movw	r16, r22
    154e:	07 5f       	subi	r16, 0xF7	; 247
    1550:	1f 4f       	sbci	r17, 0xFF	; 255
	if (dj->sect) {
    1552:	86 85       	ldd	r24, Z+14	; 0x0e
    1554:	97 85       	ldd	r25, Z+15	; 0x0f
    1556:	a0 89       	ldd	r26, Z+16	; 0x10
    1558:	b1 89       	ldd	r27, Z+17	; 0x11
    155a:	00 97       	sbiw	r24, 0x00	; 0
    155c:	a1 05       	cpc	r26, r1
    155e:	b1 05       	cpc	r27, r1
    1560:	09 f4       	brne	.+2      	; 0x1564 <get_fileinfo+0x28>
    1562:	65 c0       	rjmp	.+202    	; 0x162e <get_fileinfo+0xf2>
		dir = dj->dir;
    1564:	c2 89       	ldd	r28, Z+18	; 0x12
    1566:	d3 89       	ldd	r29, Z+19	; 0x13
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
    1568:	28 81       	ld	r18, Y
			if (c == ' ') break;
    156a:	20 32       	cpi	r18, 0x20	; 32
    156c:	99 f0       	breq	.+38     	; 0x1594 <get_fileinfo+0x58>
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
    156e:	de 01       	movw	r26, r28
    1570:	11 96       	adiw	r26, 0x01	; 1
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
    1572:	f8 01       	movw	r30, r16
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
    1574:	80 e0       	ldi	r24, 0x00	; 0
    1576:	90 e0       	ldi	r25, 0x00	; 0
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
    1578:	35 ee       	ldi	r19, 0xE5	; 229
    157a:	04 c0       	rjmp	.+8      	; 0x1584 <get_fileinfo+0x48>
	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
    157c:	2d 91       	ld	r18, X+
    157e:	01 96       	adiw	r24, 0x01	; 1
			if (c == ' ') break;
    1580:	20 32       	cpi	r18, 0x20	; 32
    1582:	41 f0       	breq	.+16     	; 0x1594 <get_fileinfo+0x58>
			if (c == NDDE) c = (TCHAR)DDE;
    1584:	25 30       	cpi	r18, 0x05	; 5
    1586:	09 f4       	brne	.+2      	; 0x158a <get_fileinfo+0x4e>
    1588:	23 2f       	mov	r18, r19
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
    158a:	21 93       	st	Z+, r18
    158c:	8f 01       	movw	r16, r30

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
    158e:	87 30       	cpi	r24, 0x07	; 7
    1590:	91 05       	cpc	r25, r1
    1592:	a1 f7       	brne	.-24     	; 0x157c <get_fileinfo+0x40>
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
    1594:	88 85       	ldd	r24, Y+8	; 0x08
    1596:	80 32       	cpi	r24, 0x20	; 32
    1598:	81 f0       	breq	.+32     	; 0x15ba <get_fileinfo+0x7e>
			*p++ = '.';
    159a:	8e e2       	ldi	r24, 0x2E	; 46
    159c:	f8 01       	movw	r30, r16
    159e:	80 83       	st	Z, r24
			for (i = 8; i < 11; i++) {
				c = dir[i];
    15a0:	88 85       	ldd	r24, Y+8	; 0x08
				if (c == ' ') break;
    15a2:	80 32       	cpi	r24, 0x20	; 32
    15a4:	09 f0       	breq	.+2      	; 0x15a8 <get_fileinfo+0x6c>
    15a6:	4c c0       	rjmp	.+152    	; 0x1640 <get_fileinfo+0x104>
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
    15a8:	0f 5f       	subi	r16, 0xFF	; 255
    15aa:	1f 4f       	sbci	r17, 0xFF	; 255
    15ac:	06 c0       	rjmp	.+12     	; 0x15ba <get_fileinfo+0x7e>
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
    15ae:	8c 01       	movw	r16, r24
    15b0:	04 c0       	rjmp	.+8      	; 0x15ba <get_fileinfo+0x7e>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    15b2:	f8 01       	movw	r30, r16
    15b4:	23 83       	std	Z+3, r18	; 0x03
    15b6:	0c 5f       	subi	r16, 0xFC	; 252
    15b8:	1f 4f       	sbci	r17, 0xFF	; 255
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
    15ba:	8b 85       	ldd	r24, Y+11	; 0x0b
    15bc:	f7 01       	movw	r30, r14
    15be:	80 87       	std	Z+8, r24	; 0x08
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
    15c0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    15c2:	90 e0       	ldi	r25, 0x00	; 0
    15c4:	a0 e0       	ldi	r26, 0x00	; 0
    15c6:	b0 e0       	ldi	r27, 0x00	; 0
    15c8:	b8 2f       	mov	r27, r24
    15ca:	aa 27       	eor	r26, r26
    15cc:	99 27       	eor	r25, r25
    15ce:	88 27       	eor	r24, r24
    15d0:	4e 8d       	ldd	r20, Y+30	; 0x1e
    15d2:	50 e0       	ldi	r21, 0x00	; 0
    15d4:	60 e0       	ldi	r22, 0x00	; 0
    15d6:	70 e0       	ldi	r23, 0x00	; 0
    15d8:	ba 01       	movw	r22, r20
    15da:	55 27       	eor	r21, r21
    15dc:	44 27       	eor	r20, r20
    15de:	48 2b       	or	r20, r24
    15e0:	59 2b       	or	r21, r25
    15e2:	6a 2b       	or	r22, r26
    15e4:	7b 2b       	or	r23, r27
    15e6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    15e8:	90 e0       	ldi	r25, 0x00	; 0
    15ea:	a0 e0       	ldi	r26, 0x00	; 0
    15ec:	b0 e0       	ldi	r27, 0x00	; 0
    15ee:	48 2b       	or	r20, r24
    15f0:	59 2b       	or	r21, r25
    15f2:	6a 2b       	or	r22, r26
    15f4:	7b 2b       	or	r23, r27
    15f6:	9d 8d       	ldd	r25, Y+29	; 0x1d
    15f8:	80 e0       	ldi	r24, 0x00	; 0
    15fa:	a0 e0       	ldi	r26, 0x00	; 0
    15fc:	b0 e0       	ldi	r27, 0x00	; 0
    15fe:	84 2b       	or	r24, r20
    1600:	95 2b       	or	r25, r21
    1602:	a6 2b       	or	r26, r22
    1604:	b7 2b       	or	r27, r23
    1606:	80 83       	st	Z, r24
    1608:	91 83       	std	Z+1, r25	; 0x01
    160a:	a2 83       	std	Z+2, r26	; 0x02
    160c:	b3 83       	std	Z+3, r27	; 0x03
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
    160e:	39 8d       	ldd	r19, Y+25	; 0x19
    1610:	20 e0       	ldi	r18, 0x00	; 0
    1612:	88 8d       	ldd	r24, Y+24	; 0x18
    1614:	90 e0       	ldi	r25, 0x00	; 0
    1616:	82 2b       	or	r24, r18
    1618:	93 2b       	or	r25, r19
    161a:	95 83       	std	Z+5, r25	; 0x05
    161c:	84 83       	std	Z+4, r24	; 0x04
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
    161e:	9f 89       	ldd	r25, Y+23	; 0x17
    1620:	80 e0       	ldi	r24, 0x00	; 0
    1622:	2e 89       	ldd	r18, Y+22	; 0x16
    1624:	30 e0       	ldi	r19, 0x00	; 0
    1626:	82 2b       	or	r24, r18
    1628:	93 2b       	or	r25, r19
    162a:	97 83       	std	Z+7, r25	; 0x07
    162c:	86 83       	std	Z+6, r24	; 0x06
	}
	*p = 0;		/* Terminate SFN str by a \0 */
    162e:	f8 01       	movw	r30, r16
    1630:	10 82       	st	Z, r1
			}
		}
		tp[i] = 0;	/* Terminate the LFN str by a \0 */
	}
#endif
}
    1632:	df 91       	pop	r29
    1634:	cf 91       	pop	r28
    1636:	1f 91       	pop	r17
    1638:	0f 91       	pop	r16
    163a:	ff 90       	pop	r15
    163c:	ef 90       	pop	r14
    163e:	08 95       	ret
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    1640:	f8 01       	movw	r30, r16
    1642:	81 83       	std	Z+1, r24	; 0x01
    1644:	c8 01       	movw	r24, r16
    1646:	02 96       	adiw	r24, 0x02	; 2
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
    1648:	29 85       	ldd	r18, Y+9	; 0x09
				if (c == ' ') break;
    164a:	20 32       	cpi	r18, 0x20	; 32
    164c:	09 f4       	brne	.+2      	; 0x1650 <get_fileinfo+0x114>
    164e:	af cf       	rjmp	.-162    	; 0x15ae <get_fileinfo+0x72>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
    1650:	22 83       	std	Z+2, r18	; 0x02
    1652:	c8 01       	movw	r24, r16
    1654:	03 96       	adiw	r24, 0x03	; 3
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
    1656:	2a 85       	ldd	r18, Y+10	; 0x0a
				if (c == ' ') break;
    1658:	20 32       	cpi	r18, 0x20	; 32
    165a:	09 f0       	breq	.+2      	; 0x165e <get_fileinfo+0x122>
    165c:	aa cf       	rjmp	.-172    	; 0x15b2 <get_fileinfo+0x76>
    165e:	a7 cf       	rjmp	.-178    	; 0x15ae <get_fileinfo+0x72>

00001660 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
    1660:	dc 01       	movw	r26, r24
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
    1662:	ed 91       	ld	r30, X+
    1664:	fc 91       	ld	r31, X
    1666:	11 97       	sbiw	r26, 0x01	; 1
    1668:	30 97       	sbiw	r30, 0x00	; 0
    166a:	99 f0       	breq	.+38     	; 0x1692 <validate+0x32>
    166c:	80 81       	ld	r24, Z
    166e:	88 23       	and	r24, r24
    1670:	91 f0       	breq	.+36     	; 0x1696 <validate+0x36>
    1672:	26 81       	ldd	r18, Z+6	; 0x06
    1674:	37 81       	ldd	r19, Z+7	; 0x07
    1676:	12 96       	adiw	r26, 0x02	; 2
    1678:	8d 91       	ld	r24, X+
    167a:	9c 91       	ld	r25, X
    167c:	13 97       	sbiw	r26, 0x03	; 3
    167e:	28 17       	cp	r18, r24
    1680:	39 07       	cpc	r19, r25
    1682:	59 f4       	brne	.+22     	; 0x169a <validate+0x3a>
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
    1684:	81 81       	ldd	r24, Z+1	; 0x01
    1686:	0e 94 92 02 	call	0x524	; 0x524 <disk_status>
    168a:	80 ff       	sbrs	r24, 0
    168c:	08 c0       	rjmp	.+16     	; 0x169e <validate+0x3e>
		return FR_NOT_READY;
    168e:	83 e0       	ldi	r24, 0x03	; 3
    1690:	08 95       	ret
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
		return FR_INVALID_OBJECT;
    1692:	89 e0       	ldi	r24, 0x09	; 9
    1694:	08 95       	ret
    1696:	89 e0       	ldi	r24, 0x09	; 9
    1698:	08 95       	ret
    169a:	89 e0       	ldi	r24, 0x09	; 9
    169c:	08 95       	ret
	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
    169e:	80 e0       	ldi	r24, 0x00	; 0
}
    16a0:	08 95       	ret

000016a2 <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    16a2:	0f 93       	push	r16
    16a4:	cf 93       	push	r28
    16a6:	df 93       	push	r29
    16a8:	ec 01       	movw	r28, r24
    16aa:	9a 01       	movw	r18, r20
    16ac:	ab 01       	movw	r20, r22
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    16ae:	bc 01       	movw	r22, r24
    16b0:	6e 5c       	subi	r22, 0xCE	; 206
    16b2:	7f 4f       	sbci	r23, 0xFF	; 255
    16b4:	89 81       	ldd	r24, Y+1	; 0x01
    16b6:	01 e0       	ldi	r16, 0x01	; 1
    16b8:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    16bc:	88 23       	and	r24, r24
    16be:	09 f0       	breq	.+2      	; 0x16c2 <check_fs+0x20>
    16c0:	83 c0       	rjmp	.+262    	; 0x17c8 <check_fs+0x126>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    16c2:	fe 01       	movw	r30, r28
    16c4:	ef 5c       	subi	r30, 0xCF	; 207
    16c6:	fd 4f       	sbci	r31, 0xFD	; 253
    16c8:	90 81       	ld	r25, Z
    16ca:	80 e0       	ldi	r24, 0x00	; 0
    16cc:	fe 01       	movw	r30, r28
    16ce:	e0 5d       	subi	r30, 0xD0	; 208
    16d0:	fd 4f       	sbci	r31, 0xFD	; 253
    16d2:	20 81       	ld	r18, Z
    16d4:	30 e0       	ldi	r19, 0x00	; 0
    16d6:	82 2b       	or	r24, r18
    16d8:	93 2b       	or	r25, r19
    16da:	2a ea       	ldi	r18, 0xAA	; 170
    16dc:	85 35       	cpi	r24, 0x55	; 85
    16de:	92 07       	cpc	r25, r18
    16e0:	09 f0       	breq	.+2      	; 0x16e4 <check_fs+0x42>
    16e2:	74 c0       	rjmp	.+232    	; 0x17cc <check_fs+0x12a>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    16e4:	fe 01       	movw	r30, r28
    16e6:	e5 59       	subi	r30, 0x95	; 149
    16e8:	ff 4f       	sbci	r31, 0xFF	; 255
    16ea:	80 81       	ld	r24, Z
    16ec:	90 e0       	ldi	r25, 0x00	; 0
    16ee:	a0 e0       	ldi	r26, 0x00	; 0
    16f0:	b0 e0       	ldi	r27, 0x00	; 0
    16f2:	b8 2f       	mov	r27, r24
    16f4:	aa 27       	eor	r26, r26
    16f6:	99 27       	eor	r25, r25
    16f8:	88 27       	eor	r24, r24
    16fa:	fe 01       	movw	r30, r28
    16fc:	e6 59       	subi	r30, 0x96	; 150
    16fe:	ff 4f       	sbci	r31, 0xFF	; 255
    1700:	40 81       	ld	r20, Z
    1702:	50 e0       	ldi	r21, 0x00	; 0
    1704:	60 e0       	ldi	r22, 0x00	; 0
    1706:	70 e0       	ldi	r23, 0x00	; 0
    1708:	ba 01       	movw	r22, r20
    170a:	55 27       	eor	r21, r21
    170c:	44 27       	eor	r20, r20
    170e:	48 2b       	or	r20, r24
    1710:	59 2b       	or	r21, r25
    1712:	6a 2b       	or	r22, r26
    1714:	7b 2b       	or	r23, r27
    1716:	fe 01       	movw	r30, r28
    1718:	e8 59       	subi	r30, 0x98	; 152
    171a:	ff 4f       	sbci	r31, 0xFF	; 255
    171c:	80 81       	ld	r24, Z
    171e:	90 e0       	ldi	r25, 0x00	; 0
    1720:	a0 e0       	ldi	r26, 0x00	; 0
    1722:	b0 e0       	ldi	r27, 0x00	; 0
    1724:	48 2b       	or	r20, r24
    1726:	59 2b       	or	r21, r25
    1728:	6a 2b       	or	r22, r26
    172a:	7b 2b       	or	r23, r27
    172c:	fe 01       	movw	r30, r28
    172e:	e7 59       	subi	r30, 0x97	; 151
    1730:	ff 4f       	sbci	r31, 0xFF	; 255
    1732:	90 81       	ld	r25, Z
    1734:	80 e0       	ldi	r24, 0x00	; 0
    1736:	a0 e0       	ldi	r26, 0x00	; 0
    1738:	b0 e0       	ldi	r27, 0x00	; 0
    173a:	48 2b       	or	r20, r24
    173c:	59 2b       	or	r21, r25
    173e:	6a 2b       	or	r22, r26
    1740:	7b 2b       	or	r23, r27
    1742:	70 70       	andi	r23, 0x00	; 0
    1744:	46 34       	cpi	r20, 0x46	; 70
    1746:	81 e4       	ldi	r24, 0x41	; 65
    1748:	58 07       	cpc	r21, r24
    174a:	84 e5       	ldi	r24, 0x54	; 84
    174c:	68 07       	cpc	r22, r24
    174e:	80 e0       	ldi	r24, 0x00	; 0
    1750:	78 07       	cpc	r23, r24
    1752:	f1 f1       	breq	.+124    	; 0x17d0 <check_fs+0x12e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    1754:	fe 01       	movw	r30, r28
    1756:	e9 57       	subi	r30, 0x79	; 121
    1758:	ff 4f       	sbci	r31, 0xFF	; 255
    175a:	80 81       	ld	r24, Z
    175c:	90 e0       	ldi	r25, 0x00	; 0
    175e:	a0 e0       	ldi	r26, 0x00	; 0
    1760:	b0 e0       	ldi	r27, 0x00	; 0
    1762:	b8 2f       	mov	r27, r24
    1764:	aa 27       	eor	r26, r26
    1766:	99 27       	eor	r25, r25
    1768:	88 27       	eor	r24, r24
    176a:	fe 01       	movw	r30, r28
    176c:	ea 57       	subi	r30, 0x7A	; 122
    176e:	ff 4f       	sbci	r31, 0xFF	; 255
    1770:	40 81       	ld	r20, Z
    1772:	50 e0       	ldi	r21, 0x00	; 0
    1774:	60 e0       	ldi	r22, 0x00	; 0
    1776:	70 e0       	ldi	r23, 0x00	; 0
    1778:	ba 01       	movw	r22, r20
    177a:	55 27       	eor	r21, r21
    177c:	44 27       	eor	r20, r20
    177e:	48 2b       	or	r20, r24
    1780:	59 2b       	or	r21, r25
    1782:	6a 2b       	or	r22, r26
    1784:	7b 2b       	or	r23, r27
    1786:	fe 01       	movw	r30, r28
    1788:	ec 57       	subi	r30, 0x7C	; 124
    178a:	ff 4f       	sbci	r31, 0xFF	; 255
    178c:	80 81       	ld	r24, Z
    178e:	90 e0       	ldi	r25, 0x00	; 0
    1790:	a0 e0       	ldi	r26, 0x00	; 0
    1792:	b0 e0       	ldi	r27, 0x00	; 0
    1794:	48 2b       	or	r20, r24
    1796:	59 2b       	or	r21, r25
    1798:	6a 2b       	or	r22, r26
    179a:	7b 2b       	or	r23, r27
    179c:	cb 57       	subi	r28, 0x7B	; 123
    179e:	df 4f       	sbci	r29, 0xFF	; 255
    17a0:	98 81       	ld	r25, Y
    17a2:	80 e0       	ldi	r24, 0x00	; 0
    17a4:	a0 e0       	ldi	r26, 0x00	; 0
    17a6:	b0 e0       	ldi	r27, 0x00	; 0
    17a8:	48 2b       	or	r20, r24
    17aa:	59 2b       	or	r21, r25
    17ac:	6a 2b       	or	r22, r26
    17ae:	7b 2b       	or	r23, r27
    17b0:	70 70       	andi	r23, 0x00	; 0
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
    17b2:	81 e0       	ldi	r24, 0x01	; 1
    17b4:	46 34       	cpi	r20, 0x46	; 70
    17b6:	91 e4       	ldi	r25, 0x41	; 65
    17b8:	59 07       	cpc	r21, r25
    17ba:	94 e5       	ldi	r25, 0x54	; 84
    17bc:	69 07       	cpc	r22, r25
    17be:	90 e0       	ldi	r25, 0x00	; 0
    17c0:	79 07       	cpc	r23, r25
    17c2:	39 f4       	brne	.+14     	; 0x17d2 <check_fs+0x130>
    17c4:	80 e0       	ldi	r24, 0x00	; 0
    17c6:	05 c0       	rjmp	.+10     	; 0x17d2 <check_fs+0x130>
    17c8:	83 e0       	ldi	r24, 0x03	; 3
    17ca:	03 c0       	rjmp	.+6      	; 0x17d2 <check_fs+0x130>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
    17cc:	82 e0       	ldi	r24, 0x02	; 2
    17ce:	01 c0       	rjmp	.+2      	; 0x17d2 <check_fs+0x130>

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;
    17d0:	80 e0       	ldi	r24, 0x00	; 0
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
    17d2:	df 91       	pop	r29
    17d4:	cf 91       	pop	r28
    17d6:	0f 91       	pop	r16
    17d8:	08 95       	ret

000017da <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
    17da:	2f 92       	push	r2
    17dc:	3f 92       	push	r3
    17de:	4f 92       	push	r4
    17e0:	5f 92       	push	r5
    17e2:	6f 92       	push	r6
    17e4:	7f 92       	push	r7
    17e6:	8f 92       	push	r8
    17e8:	9f 92       	push	r9
    17ea:	af 92       	push	r10
    17ec:	bf 92       	push	r11
    17ee:	cf 92       	push	r12
    17f0:	df 92       	push	r13
    17f2:	ef 92       	push	r14
    17f4:	ff 92       	push	r15
    17f6:	0f 93       	push	r16
    17f8:	1f 93       	push	r17
    17fa:	cf 93       	push	r28
    17fc:	df 93       	push	r29
    17fe:	cd b7       	in	r28, 0x3d	; 61
    1800:	de b7       	in	r29, 0x3e	; 62
    1802:	60 97       	sbiw	r28, 0x10	; 16
    1804:	0f b6       	in	r0, 0x3f	; 63
    1806:	f8 94       	cli
    1808:	de bf       	out	0x3e, r29	; 62
    180a:	0f be       	out	0x3f, r0	; 63
    180c:	cd bf       	out	0x3d, r28	; 61
    180e:	8b 01       	movw	r16, r22
    1810:	d4 2e       	mov	r13, r20
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
    1812:	dc 01       	movw	r26, r24
    1814:	ed 91       	ld	r30, X+
    1816:	fc 91       	ld	r31, X
    1818:	11 97       	sbiw	r26, 0x01	; 1
	FATFS *fs;


	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
    181a:	40 81       	ld	r20, Z
    181c:	50 e0       	ldi	r21, 0x00	; 0
    181e:	40 53       	subi	r20, 0x30	; 48
    1820:	50 40       	sbci	r21, 0x00	; 0
    1822:	66 27       	eor	r22, r22
    1824:	57 fd       	sbrc	r21, 7
    1826:	60 95       	com	r22
    1828:	76 2f       	mov	r23, r22
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    182a:	4a 30       	cpi	r20, 0x0A	; 10
    182c:	51 05       	cpc	r21, r1
    182e:	61 05       	cpc	r22, r1
    1830:	71 05       	cpc	r23, r1
    1832:	48 f4       	brcc	.+18     	; 0x1846 <chk_mounted+0x6c>
    1834:	81 81       	ldd	r24, Z+1	; 0x01
    1836:	8a 33       	cpi	r24, 0x3A	; 58
    1838:	31 f4       	brne	.+12     	; 0x1846 <chk_mounted+0x6c>
		p += 2; *path = p;				/* Return pointer to the path name */
    183a:	cf 01       	movw	r24, r30
    183c:	02 96       	adiw	r24, 0x02	; 2
    183e:	11 96       	adiw	r26, 0x01	; 1
    1840:	9c 93       	st	X, r25
    1842:	8e 93       	st	-X, r24
    1844:	05 c0       	rjmp	.+10     	; 0x1850 <chk_mounted+0x76>
	} else {							/* No drive number is given */
#if _FS_RPATH
		vol = CurrVol;					/* Use current drive */
    1846:	40 91 25 04 	lds	r20, 0x0425
    184a:	50 e0       	ldi	r21, 0x00	; 0
    184c:	60 e0       	ldi	r22, 0x00	; 0
    184e:	70 e0       	ldi	r23, 0x00	; 0
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
    1850:	f8 01       	movw	r30, r16
    1852:	11 82       	std	Z+1, r1	; 0x01
    1854:	10 82       	st	Z, r1
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    1856:	41 15       	cp	r20, r1
    1858:	51 05       	cpc	r21, r1
    185a:	61 05       	cpc	r22, r1
    185c:	71 05       	cpc	r23, r1
    185e:	09 f0       	breq	.+2      	; 0x1862 <chk_mounted+0x88>
    1860:	a3 c3       	rjmp	.+1862   	; 0x1fa8 <chk_mounted+0x7ce>
		return FR_INVALID_DRIVE;
	fs = FatFs[vol];					/* Get corresponding file system object */
    1862:	e0 90 23 04 	lds	r14, 0x0423
    1866:	f0 90 24 04 	lds	r15, 0x0424
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    186a:	e1 14       	cp	r14, r1
    186c:	f1 04       	cpc	r15, r1
    186e:	09 f4       	brne	.+2      	; 0x1872 <chk_mounted+0x98>
    1870:	9d c3       	rjmp	.+1850   	; 0x1fac <chk_mounted+0x7d2>

	ENTER_FF(fs);						/* Lock file system */

	*rfs = fs;							/* Return pointer to the corresponding file system object */
    1872:	f1 82       	std	Z+1, r15	; 0x01
    1874:	e0 82       	st	Z, r14
	if (fs->fs_type) {					/* If the volume has been mounted */
    1876:	d7 01       	movw	r26, r14
    1878:	8c 91       	ld	r24, X
    187a:	88 23       	and	r24, r24
    187c:	69 f0       	breq	.+26     	; 0x1898 <chk_mounted+0xbe>
		stat = disk_status(fs->drv);
    187e:	11 96       	adiw	r26, 0x01	; 1
    1880:	8c 91       	ld	r24, X
    1882:	0e 94 92 02 	call	0x524	; 0x524 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    1886:	80 fd       	sbrc	r24, 0
    1888:	07 c0       	rjmp	.+14     	; 0x1898 <chk_mounted+0xbe>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
    188a:	dd 20       	and	r13, r13
    188c:	09 f4       	brne	.+2      	; 0x1890 <chk_mounted+0xb6>
    188e:	90 c3       	rjmp	.+1824   	; 0x1fb0 <chk_mounted+0x7d6>
    1890:	82 fd       	sbrc	r24, 2
    1892:	90 c3       	rjmp	.+1824   	; 0x1fb4 <chk_mounted+0x7da>
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
    1894:	80 e0       	ldi	r24, 0x00	; 0
    1896:	af c3       	rjmp	.+1886   	; 0x1ff6 <chk_mounted+0x81c>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
    1898:	f7 01       	movw	r30, r14
    189a:	10 82       	st	Z, r1
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    189c:	11 82       	std	Z+1, r1	; 0x01
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
    189e:	80 e0       	ldi	r24, 0x00	; 0
    18a0:	0e 94 c2 01 	call	0x384	; 0x384 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    18a4:	80 fd       	sbrc	r24, 0
    18a6:	88 c3       	rjmp	.+1808   	; 0x1fb8 <chk_mounted+0x7de>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    18a8:	dd 20       	and	r13, r13
    18aa:	11 f0       	breq	.+4      	; 0x18b0 <chk_mounted+0xd6>
    18ac:	82 fd       	sbrc	r24, 2
    18ae:	86 c3       	rjmp	.+1804   	; 0x1fbc <chk_mounted+0x7e2>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    18b0:	c7 01       	movw	r24, r14
    18b2:	40 e0       	ldi	r20, 0x00	; 0
    18b4:	50 e0       	ldi	r21, 0x00	; 0
    18b6:	ba 01       	movw	r22, r20
    18b8:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <check_fs>
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    18bc:	81 30       	cpi	r24, 0x01	; 1
    18be:	e9 f5       	brne	.+122    	; 0x193a <chk_mounted+0x160>
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
    18c0:	f7 01       	movw	r30, r14
    18c2:	ec 50       	subi	r30, 0x0C	; 12
    18c4:	fe 4f       	sbci	r31, 0xFE	; 254
    18c6:	80 81       	ld	r24, Z
    18c8:	88 23       	and	r24, r24
    18ca:	09 f4       	brne	.+2      	; 0x18ce <chk_mounted+0xf4>
    18cc:	79 c3       	rjmp	.+1778   	; 0x1fc0 <chk_mounted+0x7e6>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    18ce:	f7 01       	movw	r30, r14
    18d0:	e5 50       	subi	r30, 0x05	; 5
    18d2:	fe 4f       	sbci	r31, 0xFE	; 254
    18d4:	80 81       	ld	r24, Z
    18d6:	90 e0       	ldi	r25, 0x00	; 0
    18d8:	a0 e0       	ldi	r26, 0x00	; 0
    18da:	b0 e0       	ldi	r27, 0x00	; 0
    18dc:	b8 2f       	mov	r27, r24
    18de:	aa 27       	eor	r26, r26
    18e0:	99 27       	eor	r25, r25
    18e2:	88 27       	eor	r24, r24
    18e4:	f7 01       	movw	r30, r14
    18e6:	e6 50       	subi	r30, 0x06	; 6
    18e8:	fe 4f       	sbci	r31, 0xFE	; 254
    18ea:	40 81       	ld	r20, Z
    18ec:	50 e0       	ldi	r21, 0x00	; 0
    18ee:	60 e0       	ldi	r22, 0x00	; 0
    18f0:	70 e0       	ldi	r23, 0x00	; 0
    18f2:	ba 01       	movw	r22, r20
    18f4:	55 27       	eor	r21, r21
    18f6:	44 27       	eor	r20, r20
    18f8:	84 2b       	or	r24, r20
    18fa:	95 2b       	or	r25, r21
    18fc:	a6 2b       	or	r26, r22
    18fe:	b7 2b       	or	r27, r23
    1900:	f7 01       	movw	r30, r14
    1902:	e8 50       	subi	r30, 0x08	; 8
    1904:	fe 4f       	sbci	r31, 0xFE	; 254
    1906:	40 81       	ld	r20, Z
    1908:	50 e0       	ldi	r21, 0x00	; 0
    190a:	60 e0       	ldi	r22, 0x00	; 0
    190c:	70 e0       	ldi	r23, 0x00	; 0
    190e:	48 2b       	or	r20, r24
    1910:	59 2b       	or	r21, r25
    1912:	6a 2b       	or	r22, r26
    1914:	7b 2b       	or	r23, r27
    1916:	f7 01       	movw	r30, r14
    1918:	e7 50       	subi	r30, 0x07	; 7
    191a:	fe 4f       	sbci	r31, 0xFE	; 254
    191c:	90 81       	ld	r25, Z
    191e:	80 e0       	ldi	r24, 0x00	; 0
    1920:	4c 01       	movw	r8, r24
    1922:	aa 24       	eor	r10, r10
    1924:	bb 24       	eor	r11, r11
    1926:	84 2a       	or	r8, r20
    1928:	95 2a       	or	r9, r21
    192a:	a6 2a       	or	r10, r22
    192c:	b7 2a       	or	r11, r23
			fmt = check_fs(fs, bsect);		/* Check the partition */
    192e:	c7 01       	movw	r24, r14
    1930:	b5 01       	movw	r22, r10
    1932:	a4 01       	movw	r20, r8
    1934:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <check_fs>
    1938:	03 c0       	rjmp	.+6      	; 0x1940 <chk_mounted+0x166>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    193a:	88 24       	eor	r8, r8
    193c:	99 24       	eor	r9, r9
    193e:	54 01       	movw	r10, r8
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    1940:	83 30       	cpi	r24, 0x03	; 3
    1942:	09 f4       	brne	.+2      	; 0x1946 <chk_mounted+0x16c>
    1944:	3f c3       	rjmp	.+1662   	; 0x1fc4 <chk_mounted+0x7ea>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    1946:	88 23       	and	r24, r24
    1948:	09 f0       	breq	.+2      	; 0x194c <chk_mounted+0x172>
    194a:	3e c3       	rjmp	.+1660   	; 0x1fc8 <chk_mounted+0x7ee>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    194c:	d7 01       	movw	r26, r14
    194e:	de 96       	adiw	r26, 0x3e	; 62
    1950:	9c 91       	ld	r25, X
    1952:	de 97       	sbiw	r26, 0x3e	; 62
    1954:	80 e0       	ldi	r24, 0x00	; 0
    1956:	dd 96       	adiw	r26, 0x3d	; 61
    1958:	2c 91       	ld	r18, X
    195a:	dd 97       	sbiw	r26, 0x3d	; 61
    195c:	30 e0       	ldi	r19, 0x00	; 0
    195e:	82 2b       	or	r24, r18
    1960:	93 2b       	or	r25, r19
    1962:	b2 e0       	ldi	r27, 0x02	; 2
    1964:	80 30       	cpi	r24, 0x00	; 0
    1966:	9b 07       	cpc	r25, r27
    1968:	09 f0       	breq	.+2      	; 0x196c <chk_mounted+0x192>
    196a:	30 c3       	rjmp	.+1632   	; 0x1fcc <chk_mounted+0x7f2>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    196c:	f7 01       	movw	r30, r14
    196e:	e7 5b       	subi	r30, 0xB7	; 183
    1970:	ff 4f       	sbci	r31, 0xFF	; 255
    1972:	30 81       	ld	r19, Z
    1974:	20 e0       	ldi	r18, 0x00	; 0
    1976:	f7 01       	movw	r30, r14
    1978:	e8 5b       	subi	r30, 0xB8	; 184
    197a:	ff 4f       	sbci	r31, 0xFF	; 255
    197c:	80 81       	ld	r24, Z
    197e:	90 e0       	ldi	r25, 0x00	; 0
    1980:	82 2b       	or	r24, r18
    1982:	93 2b       	or	r25, r19
    1984:	2c 01       	movw	r4, r24
    1986:	66 24       	eor	r6, r6
    1988:	77 24       	eor	r7, r7
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    198a:	41 14       	cp	r4, r1
    198c:	51 04       	cpc	r5, r1
    198e:	61 04       	cpc	r6, r1
    1990:	71 04       	cpc	r7, r1
    1992:	89 f5       	brne	.+98     	; 0x19f6 <chk_mounted+0x21c>
    1994:	f7 01       	movw	r30, r14
    1996:	e7 5a       	subi	r30, 0xA7	; 167
    1998:	ff 4f       	sbci	r31, 0xFF	; 255
    199a:	40 81       	ld	r20, Z
    199c:	50 e0       	ldi	r21, 0x00	; 0
    199e:	60 e0       	ldi	r22, 0x00	; 0
    19a0:	70 e0       	ldi	r23, 0x00	; 0
    19a2:	74 2f       	mov	r23, r20
    19a4:	66 27       	eor	r22, r22
    19a6:	55 27       	eor	r21, r21
    19a8:	44 27       	eor	r20, r20
    19aa:	f7 01       	movw	r30, r14
    19ac:	e8 5a       	subi	r30, 0xA8	; 168
    19ae:	ff 4f       	sbci	r31, 0xFF	; 255
    19b0:	80 81       	ld	r24, Z
    19b2:	90 e0       	ldi	r25, 0x00	; 0
    19b4:	a0 e0       	ldi	r26, 0x00	; 0
    19b6:	b0 e0       	ldi	r27, 0x00	; 0
    19b8:	dc 01       	movw	r26, r24
    19ba:	99 27       	eor	r25, r25
    19bc:	88 27       	eor	r24, r24
    19be:	48 2b       	or	r20, r24
    19c0:	59 2b       	or	r21, r25
    19c2:	6a 2b       	or	r22, r26
    19c4:	7b 2b       	or	r23, r27
    19c6:	f7 01       	movw	r30, r14
    19c8:	ea 5a       	subi	r30, 0xAA	; 170
    19ca:	ff 4f       	sbci	r31, 0xFF	; 255
    19cc:	80 81       	ld	r24, Z
    19ce:	90 e0       	ldi	r25, 0x00	; 0
    19d0:	a0 e0       	ldi	r26, 0x00	; 0
    19d2:	b0 e0       	ldi	r27, 0x00	; 0
    19d4:	48 2b       	or	r20, r24
    19d6:	59 2b       	or	r21, r25
    19d8:	6a 2b       	or	r22, r26
    19da:	7b 2b       	or	r23, r27
    19dc:	f7 01       	movw	r30, r14
    19de:	e9 5a       	subi	r30, 0xA9	; 169
    19e0:	ff 4f       	sbci	r31, 0xFF	; 255
    19e2:	90 81       	ld	r25, Z
    19e4:	80 e0       	ldi	r24, 0x00	; 0
    19e6:	a0 e0       	ldi	r26, 0x00	; 0
    19e8:	b0 e0       	ldi	r27, 0x00	; 0
    19ea:	2a 01       	movw	r4, r20
    19ec:	3b 01       	movw	r6, r22
    19ee:	48 2a       	or	r4, r24
    19f0:	59 2a       	or	r5, r25
    19f2:	6a 2a       	or	r6, r26
    19f4:	7b 2a       	or	r7, r27
	fs->fsize = fasize;
    19f6:	f7 01       	movw	r30, r14
    19f8:	46 8e       	std	Z+30, r4	; 0x1e
    19fa:	57 8e       	std	Z+31, r5	; 0x1f
    19fc:	60 a2       	lds	r22, 0x90
    19fe:	71 a2       	lds	r23, 0x91

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    1a00:	ee 5b       	subi	r30, 0xBE	; 190
    1a02:	ff 4f       	sbci	r31, 0xFF	; 255
    1a04:	c0 80       	ld	r12, Z
    1a06:	d7 01       	movw	r26, r14
    1a08:	13 96       	adiw	r26, 0x03	; 3
    1a0a:	cc 92       	st	X, r12
    1a0c:	13 97       	sbiw	r26, 0x03	; 3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    1a0e:	8c 2d       	mov	r24, r12
    1a10:	81 50       	subi	r24, 0x01	; 1
    1a12:	82 30       	cpi	r24, 0x02	; 2
    1a14:	08 f0       	brcs	.+2      	; 0x1a18 <chk_mounted+0x23e>
    1a16:	dc c2       	rjmp	.+1464   	; 0x1fd0 <chk_mounted+0x7f6>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    1a18:	df 96       	adiw	r26, 0x3f	; 63
    1a1a:	dc 90       	ld	r13, X
    1a1c:	df 97       	sbiw	r26, 0x3f	; 63
    1a1e:	12 96       	adiw	r26, 0x02	; 2
    1a20:	dc 92       	st	X, r13
    1a22:	12 97       	sbiw	r26, 0x02	; 2
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    1a24:	dd 20       	and	r13, r13
    1a26:	09 f4       	brne	.+2      	; 0x1a2a <chk_mounted+0x250>
    1a28:	d5 c2       	rjmp	.+1450   	; 0x1fd4 <chk_mounted+0x7fa>
    1a2a:	8d 2d       	mov	r24, r13
    1a2c:	90 e0       	ldi	r25, 0x00	; 0
    1a2e:	9c 01       	movw	r18, r24
    1a30:	21 50       	subi	r18, 0x01	; 1
    1a32:	30 40       	sbci	r19, 0x00	; 0
    1a34:	82 23       	and	r24, r18
    1a36:	93 23       	and	r25, r19
    1a38:	00 97       	sbiw	r24, 0x00	; 0
    1a3a:	09 f0       	breq	.+2      	; 0x1a3e <chk_mounted+0x264>
    1a3c:	cd c2       	rjmp	.+1434   	; 0x1fd8 <chk_mounted+0x7fe>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    1a3e:	f7 01       	movw	r30, r14
    1a40:	ec 5b       	subi	r30, 0xBC	; 188
    1a42:	ff 4f       	sbci	r31, 0xFF	; 255
    1a44:	30 81       	ld	r19, Z
    1a46:	20 e0       	ldi	r18, 0x00	; 0
    1a48:	f7 01       	movw	r30, r14
    1a4a:	ed 5b       	subi	r30, 0xBD	; 189
    1a4c:	ff 4f       	sbci	r31, 0xFF	; 255
    1a4e:	80 81       	ld	r24, Z
    1a50:	90 e0       	ldi	r25, 0x00	; 0
    1a52:	19 01       	movw	r2, r18
    1a54:	28 2a       	or	r2, r24
    1a56:	39 2a       	or	r3, r25
    1a58:	f7 01       	movw	r30, r14
    1a5a:	31 86       	std	Z+9, r3	; 0x09
    1a5c:	20 86       	std	Z+8, r2	; 0x08
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    1a5e:	c1 01       	movw	r24, r2
    1a60:	8f 70       	andi	r24, 0x0F	; 15
    1a62:	90 70       	andi	r25, 0x00	; 0
    1a64:	00 97       	sbiw	r24, 0x00	; 0
    1a66:	09 f0       	breq	.+2      	; 0x1a6a <chk_mounted+0x290>
    1a68:	b9 c2       	rjmp	.+1394   	; 0x1fdc <chk_mounted+0x802>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    1a6a:	ea 5b       	subi	r30, 0xBA	; 186
    1a6c:	ff 4f       	sbci	r31, 0xFF	; 255
    1a6e:	30 81       	ld	r19, Z
    1a70:	20 e0       	ldi	r18, 0x00	; 0
    1a72:	f7 01       	movw	r30, r14
    1a74:	eb 5b       	subi	r30, 0xBB	; 187
    1a76:	ff 4f       	sbci	r31, 0xFF	; 255
    1a78:	80 81       	ld	r24, Z
    1a7a:	90 e0       	ldi	r25, 0x00	; 0
    1a7c:	82 2b       	or	r24, r18
    1a7e:	93 2b       	or	r25, r19
    1a80:	8c 01       	movw	r16, r24
    1a82:	20 e0       	ldi	r18, 0x00	; 0
    1a84:	30 e0       	ldi	r19, 0x00	; 0
    1a86:	09 83       	std	Y+1, r16	; 0x01
    1a88:	1a 83       	std	Y+2, r17	; 0x02
    1a8a:	2b 83       	std	Y+3, r18	; 0x03
    1a8c:	3c 83       	std	Y+4, r19	; 0x04
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    1a8e:	01 15       	cp	r16, r1
    1a90:	11 05       	cpc	r17, r1
    1a92:	21 05       	cpc	r18, r1
    1a94:	31 05       	cpc	r19, r1
    1a96:	a9 f5       	brne	.+106    	; 0x1b02 <chk_mounted+0x328>
    1a98:	f7 01       	movw	r30, r14
    1a9a:	eb 5a       	subi	r30, 0xAB	; 171
    1a9c:	ff 4f       	sbci	r31, 0xFF	; 255
    1a9e:	80 81       	ld	r24, Z
    1aa0:	90 e0       	ldi	r25, 0x00	; 0
    1aa2:	a0 e0       	ldi	r26, 0x00	; 0
    1aa4:	b0 e0       	ldi	r27, 0x00	; 0
    1aa6:	78 2f       	mov	r23, r24
    1aa8:	66 27       	eor	r22, r22
    1aaa:	55 27       	eor	r21, r21
    1aac:	44 27       	eor	r20, r20
    1aae:	f7 01       	movw	r30, r14
    1ab0:	ec 5a       	subi	r30, 0xAC	; 172
    1ab2:	ff 4f       	sbci	r31, 0xFF	; 255
    1ab4:	80 81       	ld	r24, Z
    1ab6:	90 e0       	ldi	r25, 0x00	; 0
    1ab8:	a0 e0       	ldi	r26, 0x00	; 0
    1aba:	b0 e0       	ldi	r27, 0x00	; 0
    1abc:	dc 01       	movw	r26, r24
    1abe:	99 27       	eor	r25, r25
    1ac0:	88 27       	eor	r24, r24
    1ac2:	48 2b       	or	r20, r24
    1ac4:	59 2b       	or	r21, r25
    1ac6:	6a 2b       	or	r22, r26
    1ac8:	7b 2b       	or	r23, r27
    1aca:	f7 01       	movw	r30, r14
    1acc:	ee 5a       	subi	r30, 0xAE	; 174
    1ace:	ff 4f       	sbci	r31, 0xFF	; 255
    1ad0:	80 81       	ld	r24, Z
    1ad2:	90 e0       	ldi	r25, 0x00	; 0
    1ad4:	a0 e0       	ldi	r26, 0x00	; 0
    1ad6:	b0 e0       	ldi	r27, 0x00	; 0
    1ad8:	48 2b       	or	r20, r24
    1ada:	59 2b       	or	r21, r25
    1adc:	6a 2b       	or	r22, r26
    1ade:	7b 2b       	or	r23, r27
    1ae0:	f7 01       	movw	r30, r14
    1ae2:	ed 5a       	subi	r30, 0xAD	; 173
    1ae4:	ff 4f       	sbci	r31, 0xFF	; 255
    1ae6:	90 81       	ld	r25, Z
    1ae8:	80 e0       	ldi	r24, 0x00	; 0
    1aea:	a0 e0       	ldi	r26, 0x00	; 0
    1aec:	b0 e0       	ldi	r27, 0x00	; 0
    1aee:	8a 01       	movw	r16, r20
    1af0:	9b 01       	movw	r18, r22
    1af2:	08 2b       	or	r16, r24
    1af4:	19 2b       	or	r17, r25
    1af6:	2a 2b       	or	r18, r26
    1af8:	3b 2b       	or	r19, r27
    1afa:	09 83       	std	Y+1, r16	; 0x01
    1afc:	1a 83       	std	Y+2, r17	; 0x02
    1afe:	2b 83       	std	Y+3, r18	; 0x03
    1b00:	3c 83       	std	Y+4, r19	; 0x04

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    1b02:	f7 01       	movw	r30, r14
    1b04:	ef 5b       	subi	r30, 0xBF	; 191
    1b06:	ff 4f       	sbci	r31, 0xFF	; 255
    1b08:	30 81       	ld	r19, Z
    1b0a:	20 e0       	ldi	r18, 0x00	; 0
    1b0c:	f7 01       	movw	r30, r14
    1b0e:	e0 5c       	subi	r30, 0xC0	; 192
    1b10:	ff 4f       	sbci	r31, 0xFF	; 255
    1b12:	80 81       	ld	r24, Z
    1b14:	90 e0       	ldi	r25, 0x00	; 0
    1b16:	89 01       	movw	r16, r18
    1b18:	08 2b       	or	r16, r24
    1b1a:	19 2b       	or	r17, r25
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    1b1c:	01 15       	cp	r16, r1
    1b1e:	11 05       	cpc	r17, r1
    1b20:	09 f4       	brne	.+2      	; 0x1b24 <chk_mounted+0x34a>
    1b22:	5e c2       	rjmp	.+1212   	; 0x1fe0 <chk_mounted+0x806>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
    1b24:	2c 2d       	mov	r18, r12
    1b26:	30 e0       	ldi	r19, 0x00	; 0
    1b28:	40 e0       	ldi	r20, 0x00	; 0
    1b2a:	50 e0       	ldi	r21, 0x00	; 0
    1b2c:	c3 01       	movw	r24, r6
    1b2e:	b2 01       	movw	r22, r4
    1b30:	0e 94 2e 2b 	call	0x565c	; 0x565c <__mulsi3>
    1b34:	6d 87       	std	Y+13, r22	; 0x0d
    1b36:	7e 87       	std	Y+14, r23	; 0x0e
    1b38:	8f 87       	std	Y+15, r24	; 0x0f
    1b3a:	98 8b       	std	Y+16, r25	; 0x10

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    1b3c:	98 01       	movw	r18, r16
    1b3e:	40 e0       	ldi	r20, 0x00	; 0
    1b40:	50 e0       	ldi	r21, 0x00	; 0
    1b42:	29 87       	std	Y+9, r18	; 0x09
    1b44:	3a 87       	std	Y+10, r19	; 0x0a
    1b46:	4b 87       	std	Y+11, r20	; 0x0b
    1b48:	5c 87       	std	Y+12, r21	; 0x0c
    1b4a:	c1 01       	movw	r24, r2
    1b4c:	92 95       	swap	r25
    1b4e:	82 95       	swap	r24
    1b50:	8f 70       	andi	r24, 0x0F	; 15
    1b52:	89 27       	eor	r24, r25
    1b54:	9f 70       	andi	r25, 0x0F	; 15
    1b56:	89 27       	eor	r24, r25
    1b58:	a0 e0       	ldi	r26, 0x00	; 0
    1b5a:	b0 e0       	ldi	r27, 0x00	; 0
    1b5c:	82 0f       	add	r24, r18
    1b5e:	93 1f       	adc	r25, r19
    1b60:	a4 1f       	adc	r26, r20
    1b62:	b5 1f       	adc	r27, r21
    1b64:	0d 85       	ldd	r16, Y+13	; 0x0d
    1b66:	1e 85       	ldd	r17, Y+14	; 0x0e
    1b68:	2f 85       	ldd	r18, Y+15	; 0x0f
    1b6a:	38 89       	ldd	r19, Y+16	; 0x10
    1b6c:	08 0f       	add	r16, r24
    1b6e:	19 1f       	adc	r17, r25
    1b70:	2a 1f       	adc	r18, r26
    1b72:	3b 1f       	adc	r19, r27
    1b74:	0d 83       	std	Y+5, r16	; 0x05
    1b76:	1e 83       	std	Y+6, r17	; 0x06
    1b78:	2f 83       	std	Y+7, r18	; 0x07
    1b7a:	38 87       	std	Y+8, r19	; 0x08
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    1b7c:	89 81       	ldd	r24, Y+1	; 0x01
    1b7e:	9a 81       	ldd	r25, Y+2	; 0x02
    1b80:	ab 81       	ldd	r26, Y+3	; 0x03
    1b82:	bc 81       	ldd	r27, Y+4	; 0x04
    1b84:	80 17       	cp	r24, r16
    1b86:	91 07       	cpc	r25, r17
    1b88:	a2 07       	cpc	r26, r18
    1b8a:	b3 07       	cpc	r27, r19
    1b8c:	08 f4       	brcc	.+2      	; 0x1b90 <chk_mounted+0x3b6>
    1b8e:	2a c2       	rjmp	.+1108   	; 0x1fe4 <chk_mounted+0x80a>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    1b90:	bc 01       	movw	r22, r24
    1b92:	cd 01       	movw	r24, r26
    1b94:	60 1b       	sub	r22, r16
    1b96:	71 0b       	sbc	r23, r17
    1b98:	82 0b       	sbc	r24, r18
    1b9a:	93 0b       	sbc	r25, r19
    1b9c:	2d 2d       	mov	r18, r13
    1b9e:	30 e0       	ldi	r19, 0x00	; 0
    1ba0:	40 e0       	ldi	r20, 0x00	; 0
    1ba2:	50 e0       	ldi	r21, 0x00	; 0
    1ba4:	0e 94 4d 2b 	call	0x569a	; 0x569a <__udivmodsi4>
    1ba8:	89 01       	movw	r16, r18
    1baa:	9a 01       	movw	r18, r20
    1bac:	d9 01       	movw	r26, r18
    1bae:	c8 01       	movw	r24, r16
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    1bb0:	01 15       	cp	r16, r1
    1bb2:	11 05       	cpc	r17, r1
    1bb4:	21 05       	cpc	r18, r1
    1bb6:	31 05       	cpc	r19, r1
    1bb8:	09 f4       	brne	.+2      	; 0x1bbc <chk_mounted+0x3e2>
    1bba:	16 c2       	rjmp	.+1068   	; 0x1fe8 <chk_mounted+0x80e>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    1bbc:	06 3f       	cpi	r16, 0xF6	; 246
    1bbe:	ef e0       	ldi	r30, 0x0F	; 15
    1bc0:	1e 07       	cpc	r17, r30
    1bc2:	e0 e0       	ldi	r30, 0x00	; 0
    1bc4:	2e 07       	cpc	r18, r30
    1bc6:	e0 e0       	ldi	r30, 0x00	; 0
    1bc8:	3e 07       	cpc	r19, r30
    1bca:	18 f4       	brcc	.+6      	; 0x1bd2 <chk_mounted+0x3f8>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
    1bcc:	dd 24       	eor	r13, r13
    1bce:	d3 94       	inc	r13
    1bd0:	03 c0       	rjmp	.+6      	; 0x1bd8 <chk_mounted+0x3fe>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    1bd2:	dd 24       	eor	r13, r13
    1bd4:	68 94       	set
    1bd6:	d1 f8       	bld	r13, 1
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    1bd8:	86 3f       	cpi	r24, 0xF6	; 246
    1bda:	ff ef       	ldi	r31, 0xFF	; 255
    1bdc:	9f 07       	cpc	r25, r31
    1bde:	f0 e0       	ldi	r31, 0x00	; 0
    1be0:	af 07       	cpc	r26, r31
    1be2:	f0 e0       	ldi	r31, 0x00	; 0
    1be4:	bf 07       	cpc	r27, r31
    1be6:	08 f0       	brcs	.+2      	; 0x1bea <chk_mounted+0x410>
    1be8:	1f c2       	rjmp	.+1086   	; 0x2028 <chk_mounted+0x84e>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    1bea:	b9 01       	movw	r22, r18
    1bec:	a8 01       	movw	r20, r16
    1bee:	4e 5f       	subi	r20, 0xFE	; 254
    1bf0:	5f 4f       	sbci	r21, 0xFF	; 255
    1bf2:	6f 4f       	sbci	r22, 0xFF	; 255
    1bf4:	7f 4f       	sbci	r23, 0xFF	; 255
    1bf6:	d7 01       	movw	r26, r14
    1bf8:	5a 96       	adiw	r26, 0x1a	; 26
    1bfa:	4d 93       	st	X+, r20
    1bfc:	5d 93       	st	X+, r21
    1bfe:	6d 93       	st	X+, r22
    1c00:	7c 93       	st	X, r23
    1c02:	5d 97       	sbiw	r26, 0x1d	; 29
	fs->database = bsect + sysect;						/* Data start sector */
    1c04:	8d 81       	ldd	r24, Y+5	; 0x05
    1c06:	9e 81       	ldd	r25, Y+6	; 0x06
    1c08:	af 81       	ldd	r26, Y+7	; 0x07
    1c0a:	b8 85       	ldd	r27, Y+8	; 0x08
    1c0c:	88 0d       	add	r24, r8
    1c0e:	99 1d       	adc	r25, r9
    1c10:	aa 1d       	adc	r26, r10
    1c12:	bb 1d       	adc	r27, r11
    1c14:	f7 01       	movw	r30, r14
    1c16:	82 a7       	lds	r24, 0x72
    1c18:	93 a7       	lds	r25, 0x73
    1c1a:	a4 a7       	lds	r26, 0x74
    1c1c:	b5 a7       	lds	r27, 0x75
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    1c1e:	89 85       	ldd	r24, Y+9	; 0x09
    1c20:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c22:	ab 85       	ldd	r26, Y+11	; 0x0b
    1c24:	bc 85       	ldd	r27, Y+12	; 0x0c
    1c26:	88 0d       	add	r24, r8
    1c28:	99 1d       	adc	r25, r9
    1c2a:	aa 1d       	adc	r26, r10
    1c2c:	bb 1d       	adc	r27, r11
    1c2e:	82 a3       	lds	r24, 0x52
    1c30:	93 a3       	lds	r25, 0x53
    1c32:	a4 a3       	lds	r26, 0x54
    1c34:	b5 a3       	lds	r27, 0x55
	if (fmt == FS_FAT32) {
    1c36:	f3 e0       	ldi	r31, 0x03	; 3
    1c38:	df 16       	cp	r13, r31
    1c3a:	09 f0       	breq	.+2      	; 0x1c3e <chk_mounted+0x464>
    1c3c:	41 c0       	rjmp	.+130    	; 0x1cc0 <chk_mounted+0x4e6>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    1c3e:	21 14       	cp	r2, r1
    1c40:	31 04       	cpc	r3, r1
    1c42:	09 f0       	breq	.+2      	; 0x1c46 <chk_mounted+0x46c>
    1c44:	d3 c1       	rjmp	.+934    	; 0x1fec <chk_mounted+0x812>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    1c46:	f7 01       	movw	r30, r14
    1c48:	ef 59       	subi	r30, 0x9F	; 159
    1c4a:	ff 4f       	sbci	r31, 0xFF	; 255
    1c4c:	80 81       	ld	r24, Z
    1c4e:	90 e0       	ldi	r25, 0x00	; 0
    1c50:	a0 e0       	ldi	r26, 0x00	; 0
    1c52:	b0 e0       	ldi	r27, 0x00	; 0
    1c54:	38 2f       	mov	r19, r24
    1c56:	22 27       	eor	r18, r18
    1c58:	11 27       	eor	r17, r17
    1c5a:	00 27       	eor	r16, r16
    1c5c:	f7 01       	movw	r30, r14
    1c5e:	e0 5a       	subi	r30, 0xA0	; 160
    1c60:	ff 4f       	sbci	r31, 0xFF	; 255
    1c62:	80 81       	ld	r24, Z
    1c64:	90 e0       	ldi	r25, 0x00	; 0
    1c66:	a0 e0       	ldi	r26, 0x00	; 0
    1c68:	b0 e0       	ldi	r27, 0x00	; 0
    1c6a:	dc 01       	movw	r26, r24
    1c6c:	99 27       	eor	r25, r25
    1c6e:	88 27       	eor	r24, r24
    1c70:	08 2b       	or	r16, r24
    1c72:	19 2b       	or	r17, r25
    1c74:	2a 2b       	or	r18, r26
    1c76:	3b 2b       	or	r19, r27
    1c78:	f7 01       	movw	r30, r14
    1c7a:	e2 5a       	subi	r30, 0xA2	; 162
    1c7c:	ff 4f       	sbci	r31, 0xFF	; 255
    1c7e:	80 81       	ld	r24, Z
    1c80:	90 e0       	ldi	r25, 0x00	; 0
    1c82:	a0 e0       	ldi	r26, 0x00	; 0
    1c84:	b0 e0       	ldi	r27, 0x00	; 0
    1c86:	08 2b       	or	r16, r24
    1c88:	19 2b       	or	r17, r25
    1c8a:	2a 2b       	or	r18, r26
    1c8c:	3b 2b       	or	r19, r27
    1c8e:	f7 01       	movw	r30, r14
    1c90:	e1 5a       	subi	r30, 0xA1	; 161
    1c92:	ff 4f       	sbci	r31, 0xFF	; 255
    1c94:	90 81       	ld	r25, Z
    1c96:	80 e0       	ldi	r24, 0x00	; 0
    1c98:	a0 e0       	ldi	r26, 0x00	; 0
    1c9a:	b0 e0       	ldi	r27, 0x00	; 0
    1c9c:	80 2b       	or	r24, r16
    1c9e:	91 2b       	or	r25, r17
    1ca0:	a2 2b       	or	r26, r18
    1ca2:	b3 2b       	or	r27, r19
    1ca4:	f7 01       	movw	r30, r14
    1ca6:	86 a3       	lds	r24, 0x56
    1ca8:	97 a3       	lds	r25, 0x57
    1caa:	a0 a7       	lds	r26, 0x70
    1cac:	b1 a7       	lds	r27, 0x71
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    1cae:	44 0f       	add	r20, r20
    1cb0:	55 1f       	adc	r21, r21
    1cb2:	66 1f       	adc	r22, r22
    1cb4:	77 1f       	adc	r23, r23
    1cb6:	44 0f       	add	r20, r20
    1cb8:	55 1f       	adc	r21, r21
    1cba:	66 1f       	adc	r22, r22
    1cbc:	77 1f       	adc	r23, r23
    1cbe:	2f c0       	rjmp	.+94     	; 0x1d1e <chk_mounted+0x544>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    1cc0:	21 14       	cp	r2, r1
    1cc2:	31 04       	cpc	r3, r1
    1cc4:	09 f4       	brne	.+2      	; 0x1cc8 <chk_mounted+0x4ee>
    1cc6:	94 c1       	rjmp	.+808    	; 0x1ff0 <chk_mounted+0x816>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    1cc8:	0d 85       	ldd	r16, Y+13	; 0x0d
    1cca:	1e 85       	ldd	r17, Y+14	; 0x0e
    1ccc:	2f 85       	ldd	r18, Y+15	; 0x0f
    1cce:	38 89       	ldd	r19, Y+16	; 0x10
    1cd0:	80 0f       	add	r24, r16
    1cd2:	91 1f       	adc	r25, r17
    1cd4:	a2 1f       	adc	r26, r18
    1cd6:	b3 1f       	adc	r27, r19
    1cd8:	f7 01       	movw	r30, r14
    1cda:	86 a3       	lds	r24, 0x56
    1cdc:	97 a3       	lds	r25, 0x57
    1cde:	a0 a7       	lds	r26, 0x70
    1ce0:	b1 a7       	lds	r27, 0x71
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    1ce2:	f2 e0       	ldi	r31, 0x02	; 2
    1ce4:	df 16       	cp	r13, r31
    1ce6:	29 f4       	brne	.+10     	; 0x1cf2 <chk_mounted+0x518>
    1ce8:	44 0f       	add	r20, r20
    1cea:	55 1f       	adc	r21, r21
    1cec:	66 1f       	adc	r22, r22
    1cee:	77 1f       	adc	r23, r23
    1cf0:	16 c0       	rjmp	.+44     	; 0x1d1e <chk_mounted+0x544>
    1cf2:	db 01       	movw	r26, r22
    1cf4:	ca 01       	movw	r24, r20
    1cf6:	88 0f       	add	r24, r24
    1cf8:	99 1f       	adc	r25, r25
    1cfa:	aa 1f       	adc	r26, r26
    1cfc:	bb 1f       	adc	r27, r27
    1cfe:	84 0f       	add	r24, r20
    1d00:	95 1f       	adc	r25, r21
    1d02:	a6 1f       	adc	r26, r22
    1d04:	b7 1f       	adc	r27, r23
    1d06:	b6 95       	lsr	r27
    1d08:	a7 95       	ror	r26
    1d0a:	97 95       	ror	r25
    1d0c:	87 95       	ror	r24
    1d0e:	41 70       	andi	r20, 0x01	; 1
    1d10:	50 70       	andi	r21, 0x00	; 0
    1d12:	60 70       	andi	r22, 0x00	; 0
    1d14:	70 70       	andi	r23, 0x00	; 0
    1d16:	48 0f       	add	r20, r24
    1d18:	59 1f       	adc	r21, r25
    1d1a:	6a 1f       	adc	r22, r26
    1d1c:	7b 1f       	adc	r23, r27
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    1d1e:	db 01       	movw	r26, r22
    1d20:	ca 01       	movw	r24, r20
    1d22:	81 50       	subi	r24, 0x01	; 1
    1d24:	9e 4f       	sbci	r25, 0xFE	; 254
    1d26:	af 4f       	sbci	r26, 0xFF	; 255
    1d28:	bf 4f       	sbci	r27, 0xFF	; 255
    1d2a:	07 2e       	mov	r0, r23
    1d2c:	79 e0       	ldi	r23, 0x09	; 9
    1d2e:	b6 95       	lsr	r27
    1d30:	a7 95       	ror	r26
    1d32:	97 95       	ror	r25
    1d34:	87 95       	ror	r24
    1d36:	7a 95       	dec	r23
    1d38:	d1 f7       	brne	.-12     	; 0x1d2e <chk_mounted+0x554>
    1d3a:	70 2d       	mov	r23, r0
    1d3c:	48 16       	cp	r4, r24
    1d3e:	59 06       	cpc	r5, r25
    1d40:	6a 06       	cpc	r6, r26
    1d42:	7b 06       	cpc	r7, r27
    1d44:	08 f4       	brcc	.+2      	; 0x1d48 <chk_mounted+0x56e>
    1d46:	56 c1       	rjmp	.+684    	; 0x1ff4 <chk_mounted+0x81a>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
    1d48:	8f ef       	ldi	r24, 0xFF	; 255
    1d4a:	9f ef       	ldi	r25, 0xFF	; 255
    1d4c:	dc 01       	movw	r26, r24
    1d4e:	f7 01       	movw	r30, r14
    1d50:	86 87       	std	Z+14, r24	; 0x0e
    1d52:	97 87       	std	Z+15, r25	; 0x0f
    1d54:	a0 8b       	std	Z+16, r26	; 0x10
    1d56:	b1 8b       	std	Z+17, r27	; 0x11
	fs->last_clust = 0;
    1d58:	12 86       	std	Z+10, r1	; 0x0a
    1d5a:	13 86       	std	Z+11, r1	; 0x0b
    1d5c:	14 86       	std	Z+12, r1	; 0x0c
    1d5e:	15 86       	std	Z+13, r1	; 0x0d

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
    1d60:	b3 e0       	ldi	r27, 0x03	; 3
    1d62:	db 16       	cp	r13, r27
    1d64:	09 f0       	breq	.+2      	; 0x1d68 <chk_mounted+0x58e>
    1d66:	03 c1       	rjmp	.+518    	; 0x1f6e <chk_mounted+0x794>
	 	fs->fsi_flag = 0;
    1d68:	15 82       	std	Z+5, r1	; 0x05
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
    1d6a:	ed 59       	subi	r30, 0x9D	; 157
    1d6c:	ff 4f       	sbci	r31, 0xFF	; 255
    1d6e:	30 81       	ld	r19, Z
    1d70:	20 e0       	ldi	r18, 0x00	; 0
    1d72:	f7 01       	movw	r30, r14
    1d74:	ee 59       	subi	r30, 0x9E	; 158
    1d76:	ff 4f       	sbci	r31, 0xFF	; 255
    1d78:	80 81       	ld	r24, Z
    1d7a:	90 e0       	ldi	r25, 0x00	; 0
    1d7c:	82 2b       	or	r24, r18
    1d7e:	93 2b       	or	r25, r19
    1d80:	a0 e0       	ldi	r26, 0x00	; 0
    1d82:	b0 e0       	ldi	r27, 0x00	; 0
    1d84:	a5 01       	movw	r20, r10
    1d86:	94 01       	movw	r18, r8
    1d88:	28 0f       	add	r18, r24
    1d8a:	39 1f       	adc	r19, r25
    1d8c:	4a 1f       	adc	r20, r26
    1d8e:	5b 1f       	adc	r21, r27
    1d90:	d7 01       	movw	r26, r14
    1d92:	52 96       	adiw	r26, 0x12	; 18
    1d94:	2d 93       	st	X+, r18
    1d96:	3d 93       	st	X+, r19
    1d98:	4d 93       	st	X+, r20
    1d9a:	5c 93       	st	X, r21
    1d9c:	55 97       	sbiw	r26, 0x15	; 21
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    1d9e:	b7 01       	movw	r22, r14
    1da0:	6e 5c       	subi	r22, 0xCE	; 206
    1da2:	7f 4f       	sbci	r23, 0xFF	; 255
    1da4:	11 96       	adiw	r26, 0x01	; 1
    1da6:	8c 91       	ld	r24, X
    1da8:	01 e0       	ldi	r16, 0x01	; 1
    1daa:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    1dae:	88 23       	and	r24, r24
    1db0:	09 f0       	breq	.+2      	; 0x1db4 <chk_mounted+0x5da>
    1db2:	dd c0       	rjmp	.+442    	; 0x1f6e <chk_mounted+0x794>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
    1db4:	f7 01       	movw	r30, r14
    1db6:	ef 5c       	subi	r30, 0xCF	; 207
    1db8:	fd 4f       	sbci	r31, 0xFD	; 253
    1dba:	30 81       	ld	r19, Z
    1dbc:	20 e0       	ldi	r18, 0x00	; 0
    1dbe:	f7 01       	movw	r30, r14
    1dc0:	e0 5d       	subi	r30, 0xD0	; 208
    1dc2:	fd 4f       	sbci	r31, 0xFD	; 253
    1dc4:	80 81       	ld	r24, Z
    1dc6:	90 e0       	ldi	r25, 0x00	; 0
    1dc8:	82 2b       	or	r24, r18
    1dca:	93 2b       	or	r25, r19

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    1dcc:	ba ea       	ldi	r27, 0xAA	; 170
    1dce:	85 35       	cpi	r24, 0x55	; 85
    1dd0:	9b 07       	cpc	r25, r27
    1dd2:	09 f0       	breq	.+2      	; 0x1dd6 <chk_mounted+0x5fc>
    1dd4:	cc c0       	rjmp	.+408    	; 0x1f6e <chk_mounted+0x794>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
    1dd6:	f7 01       	movw	r30, r14
    1dd8:	45 a9       	sts	0x45, r20
    1dda:	50 e0       	ldi	r21, 0x00	; 0
    1ddc:	60 e0       	ldi	r22, 0x00	; 0
    1dde:	70 e0       	ldi	r23, 0x00	; 0
    1de0:	74 2f       	mov	r23, r20
    1de2:	66 27       	eor	r22, r22
    1de4:	55 27       	eor	r21, r21
    1de6:	44 27       	eor	r20, r20
    1de8:	84 a9       	sts	0x44, r24
    1dea:	90 e0       	ldi	r25, 0x00	; 0
    1dec:	a0 e0       	ldi	r26, 0x00	; 0
    1dee:	b0 e0       	ldi	r27, 0x00	; 0
    1df0:	dc 01       	movw	r26, r24
    1df2:	99 27       	eor	r25, r25
    1df4:	88 27       	eor	r24, r24
    1df6:	48 2b       	or	r20, r24
    1df8:	59 2b       	or	r21, r25
    1dfa:	6a 2b       	or	r22, r26
    1dfc:	7b 2b       	or	r23, r27
    1dfe:	82 a9       	sts	0x42, r24
    1e00:	90 e0       	ldi	r25, 0x00	; 0
    1e02:	a0 e0       	ldi	r26, 0x00	; 0
    1e04:	b0 e0       	ldi	r27, 0x00	; 0
    1e06:	48 2b       	or	r20, r24
    1e08:	59 2b       	or	r21, r25
    1e0a:	6a 2b       	or	r22, r26
    1e0c:	7b 2b       	or	r23, r27
    1e0e:	93 a9       	sts	0x43, r25
    1e10:	80 e0       	ldi	r24, 0x00	; 0
    1e12:	a0 e0       	ldi	r26, 0x00	; 0
    1e14:	b0 e0       	ldi	r27, 0x00	; 0
    1e16:	84 2b       	or	r24, r20
    1e18:	95 2b       	or	r25, r21
    1e1a:	a6 2b       	or	r26, r22
    1e1c:	b7 2b       	or	r27, r23
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
    1e1e:	82 35       	cpi	r24, 0x52	; 82
    1e20:	f2 e5       	ldi	r31, 0x52	; 82
    1e22:	9f 07       	cpc	r25, r31
    1e24:	f1 e6       	ldi	r31, 0x61	; 97
    1e26:	af 07       	cpc	r26, r31
    1e28:	f1 e4       	ldi	r31, 0x41	; 65
    1e2a:	bf 07       	cpc	r27, r31
    1e2c:	09 f0       	breq	.+2      	; 0x1e30 <chk_mounted+0x656>
    1e2e:	9f c0       	rjmp	.+318    	; 0x1f6e <chk_mounted+0x794>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
    1e30:	f7 01       	movw	r30, r14
    1e32:	e7 5e       	subi	r30, 0xE7	; 231
    1e34:	fd 4f       	sbci	r31, 0xFD	; 253
    1e36:	80 81       	ld	r24, Z
    1e38:	90 e0       	ldi	r25, 0x00	; 0
    1e3a:	a0 e0       	ldi	r26, 0x00	; 0
    1e3c:	b0 e0       	ldi	r27, 0x00	; 0
    1e3e:	b8 2f       	mov	r27, r24
    1e40:	aa 27       	eor	r26, r26
    1e42:	99 27       	eor	r25, r25
    1e44:	88 27       	eor	r24, r24
    1e46:	f7 01       	movw	r30, r14
    1e48:	e8 5e       	subi	r30, 0xE8	; 232
    1e4a:	fd 4f       	sbci	r31, 0xFD	; 253
    1e4c:	40 81       	ld	r20, Z
    1e4e:	50 e0       	ldi	r21, 0x00	; 0
    1e50:	60 e0       	ldi	r22, 0x00	; 0
    1e52:	70 e0       	ldi	r23, 0x00	; 0
    1e54:	ba 01       	movw	r22, r20
    1e56:	55 27       	eor	r21, r21
    1e58:	44 27       	eor	r20, r20
    1e5a:	84 2b       	or	r24, r20
    1e5c:	95 2b       	or	r25, r21
    1e5e:	a6 2b       	or	r26, r22
    1e60:	b7 2b       	or	r27, r23
    1e62:	f7 01       	movw	r30, r14
    1e64:	ea 5e       	subi	r30, 0xEA	; 234
    1e66:	fd 4f       	sbci	r31, 0xFD	; 253
    1e68:	40 81       	ld	r20, Z
    1e6a:	50 e0       	ldi	r21, 0x00	; 0
    1e6c:	60 e0       	ldi	r22, 0x00	; 0
    1e6e:	70 e0       	ldi	r23, 0x00	; 0
    1e70:	48 2b       	or	r20, r24
    1e72:	59 2b       	or	r21, r25
    1e74:	6a 2b       	or	r22, r26
    1e76:	7b 2b       	or	r23, r27
    1e78:	f7 01       	movw	r30, r14
    1e7a:	e9 5e       	subi	r30, 0xE9	; 233
    1e7c:	fd 4f       	sbci	r31, 0xFD	; 253
    1e7e:	90 81       	ld	r25, Z
    1e80:	80 e0       	ldi	r24, 0x00	; 0
    1e82:	a0 e0       	ldi	r26, 0x00	; 0
    1e84:	b0 e0       	ldi	r27, 0x00	; 0
    1e86:	84 2b       	or	r24, r20
    1e88:	95 2b       	or	r25, r21
    1e8a:	a6 2b       	or	r26, r22
    1e8c:	b7 2b       	or	r27, r23
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
    1e8e:	82 37       	cpi	r24, 0x72	; 114
    1e90:	02 e7       	ldi	r16, 0x72	; 114
    1e92:	90 07       	cpc	r25, r16
    1e94:	01 e4       	ldi	r16, 0x41	; 65
    1e96:	a0 07       	cpc	r26, r16
    1e98:	01 e6       	ldi	r16, 0x61	; 97
    1e9a:	b0 07       	cpc	r27, r16
    1e9c:	09 f0       	breq	.+2      	; 0x1ea0 <chk_mounted+0x6c6>
    1e9e:	67 c0       	rjmp	.+206    	; 0x1f6e <chk_mounted+0x794>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
    1ea0:	f7 01       	movw	r30, r14
    1ea2:	ef 5d       	subi	r30, 0xDF	; 223
    1ea4:	fd 4f       	sbci	r31, 0xFD	; 253
    1ea6:	80 81       	ld	r24, Z
    1ea8:	90 e0       	ldi	r25, 0x00	; 0
    1eaa:	a0 e0       	ldi	r26, 0x00	; 0
    1eac:	b0 e0       	ldi	r27, 0x00	; 0
    1eae:	b8 2f       	mov	r27, r24
    1eb0:	aa 27       	eor	r26, r26
    1eb2:	99 27       	eor	r25, r25
    1eb4:	88 27       	eor	r24, r24
    1eb6:	f7 01       	movw	r30, r14
    1eb8:	e0 5e       	subi	r30, 0xE0	; 224
    1eba:	fd 4f       	sbci	r31, 0xFD	; 253
    1ebc:	40 81       	ld	r20, Z
    1ebe:	50 e0       	ldi	r21, 0x00	; 0
    1ec0:	60 e0       	ldi	r22, 0x00	; 0
    1ec2:	70 e0       	ldi	r23, 0x00	; 0
    1ec4:	ba 01       	movw	r22, r20
    1ec6:	55 27       	eor	r21, r21
    1ec8:	44 27       	eor	r20, r20
    1eca:	84 2b       	or	r24, r20
    1ecc:	95 2b       	or	r25, r21
    1ece:	a6 2b       	or	r26, r22
    1ed0:	b7 2b       	or	r27, r23
    1ed2:	f7 01       	movw	r30, r14
    1ed4:	e2 5e       	subi	r30, 0xE2	; 226
    1ed6:	fd 4f       	sbci	r31, 0xFD	; 253
    1ed8:	40 81       	ld	r20, Z
    1eda:	50 e0       	ldi	r21, 0x00	; 0
    1edc:	60 e0       	ldi	r22, 0x00	; 0
    1ede:	70 e0       	ldi	r23, 0x00	; 0
    1ee0:	48 2b       	or	r20, r24
    1ee2:	59 2b       	or	r21, r25
    1ee4:	6a 2b       	or	r22, r26
    1ee6:	7b 2b       	or	r23, r27
    1ee8:	f7 01       	movw	r30, r14
    1eea:	e1 5e       	subi	r30, 0xE1	; 225
    1eec:	fd 4f       	sbci	r31, 0xFD	; 253
    1eee:	90 81       	ld	r25, Z
    1ef0:	80 e0       	ldi	r24, 0x00	; 0
    1ef2:	a0 e0       	ldi	r26, 0x00	; 0
    1ef4:	b0 e0       	ldi	r27, 0x00	; 0
    1ef6:	84 2b       	or	r24, r20
    1ef8:	95 2b       	or	r25, r21
    1efa:	a6 2b       	or	r26, r22
    1efc:	b7 2b       	or	r27, r23
    1efe:	f7 01       	movw	r30, r14
    1f00:	82 87       	std	Z+10, r24	; 0x0a
    1f02:	93 87       	std	Z+11, r25	; 0x0b
    1f04:	a4 87       	std	Z+12, r26	; 0x0c
    1f06:	b5 87       	std	Z+13, r27	; 0x0d
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
    1f08:	e3 5e       	subi	r30, 0xE3	; 227
    1f0a:	fd 4f       	sbci	r31, 0xFD	; 253
    1f0c:	80 81       	ld	r24, Z
    1f0e:	90 e0       	ldi	r25, 0x00	; 0
    1f10:	a0 e0       	ldi	r26, 0x00	; 0
    1f12:	b0 e0       	ldi	r27, 0x00	; 0
    1f14:	b8 2f       	mov	r27, r24
    1f16:	aa 27       	eor	r26, r26
    1f18:	99 27       	eor	r25, r25
    1f1a:	88 27       	eor	r24, r24
    1f1c:	f7 01       	movw	r30, r14
    1f1e:	e4 5e       	subi	r30, 0xE4	; 228
    1f20:	fd 4f       	sbci	r31, 0xFD	; 253
    1f22:	40 81       	ld	r20, Z
    1f24:	50 e0       	ldi	r21, 0x00	; 0
    1f26:	60 e0       	ldi	r22, 0x00	; 0
    1f28:	70 e0       	ldi	r23, 0x00	; 0
    1f2a:	ba 01       	movw	r22, r20
    1f2c:	55 27       	eor	r21, r21
    1f2e:	44 27       	eor	r20, r20
    1f30:	84 2b       	or	r24, r20
    1f32:	95 2b       	or	r25, r21
    1f34:	a6 2b       	or	r26, r22
    1f36:	b7 2b       	or	r27, r23
    1f38:	f7 01       	movw	r30, r14
    1f3a:	e6 5e       	subi	r30, 0xE6	; 230
    1f3c:	fd 4f       	sbci	r31, 0xFD	; 253
    1f3e:	40 81       	ld	r20, Z
    1f40:	50 e0       	ldi	r21, 0x00	; 0
    1f42:	60 e0       	ldi	r22, 0x00	; 0
    1f44:	70 e0       	ldi	r23, 0x00	; 0
    1f46:	48 2b       	or	r20, r24
    1f48:	59 2b       	or	r21, r25
    1f4a:	6a 2b       	or	r22, r26
    1f4c:	7b 2b       	or	r23, r27
    1f4e:	f7 01       	movw	r30, r14
    1f50:	e5 5e       	subi	r30, 0xE5	; 229
    1f52:	fd 4f       	sbci	r31, 0xFD	; 253
    1f54:	90 81       	ld	r25, Z
    1f56:	80 e0       	ldi	r24, 0x00	; 0
    1f58:	a0 e0       	ldi	r26, 0x00	; 0
    1f5a:	b0 e0       	ldi	r27, 0x00	; 0
    1f5c:	84 2b       	or	r24, r20
    1f5e:	95 2b       	or	r25, r21
    1f60:	a6 2b       	or	r26, r22
    1f62:	b7 2b       	or	r27, r23
    1f64:	f7 01       	movw	r30, r14
    1f66:	86 87       	std	Z+14, r24	; 0x0e
    1f68:	97 87       	std	Z+15, r25	; 0x0f
    1f6a:	a0 8b       	std	Z+16, r26	; 0x10
    1f6c:	b1 8b       	std	Z+17, r27	; 0x11
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
    1f6e:	d7 01       	movw	r26, r14
    1f70:	dc 92       	st	X, r13
	fs->id = ++Fsid;		/* File system mount ID */
    1f72:	80 91 26 04 	lds	r24, 0x0426
    1f76:	90 91 27 04 	lds	r25, 0x0427
    1f7a:	01 96       	adiw	r24, 0x01	; 1
    1f7c:	90 93 27 04 	sts	0x0427, r25
    1f80:	80 93 26 04 	sts	0x0426, r24
    1f84:	17 96       	adiw	r26, 0x07	; 7
    1f86:	9c 93       	st	X, r25
    1f88:	8e 93       	st	-X, r24
    1f8a:	16 97       	sbiw	r26, 0x06	; 6
	fs->winsect = 0;		/* Invalidate sector cache */
    1f8c:	f7 01       	movw	r30, r14
    1f8e:	16 a6       	lds	r17, 0xb6
    1f90:	17 a6       	lds	r17, 0xb7
    1f92:	10 aa       	sts	0x90, r17
    1f94:	11 aa       	sts	0x91, r17
	fs->wflag = 0;
    1f96:	14 82       	std	Z+4, r1	; 0x04
#if _FS_RPATH
	fs->cdir = 0;			/* Current directory (root dir) */
    1f98:	56 96       	adiw	r26, 0x16	; 22
    1f9a:	1d 92       	st	X+, r1
    1f9c:	1d 92       	st	X+, r1
    1f9e:	1d 92       	st	X+, r1
    1fa0:	1c 92       	st	X, r1
    1fa2:	59 97       	sbiw	r26, 0x19	; 25
#endif
#if _FS_LOCK				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
    1fa4:	80 e0       	ldi	r24, 0x00	; 0
    1fa6:	27 c0       	rjmp	.+78     	; 0x1ff6 <chk_mounted+0x81c>
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
    1fa8:	8b e0       	ldi	r24, 0x0B	; 11
    1faa:	25 c0       	rjmp	.+74     	; 0x1ff6 <chk_mounted+0x81c>
	fs = FatFs[vol];					/* Get corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    1fac:	8c e0       	ldi	r24, 0x0C	; 12
    1fae:	23 c0       	rjmp	.+70     	; 0x1ff6 <chk_mounted+0x81c>
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
    1fb0:	80 e0       	ldi	r24, 0x00	; 0
    1fb2:	21 c0       	rjmp	.+66     	; 0x1ff6 <chk_mounted+0x81c>
	*rfs = fs;							/* Return pointer to the corresponding file system object */
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
    1fb4:	8a e0       	ldi	r24, 0x0A	; 10
    1fb6:	1f c0       	rjmp	.+62     	; 0x1ff6 <chk_mounted+0x81c>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
    1fb8:	83 e0       	ldi	r24, 0x03	; 3
    1fba:	1d c0       	rjmp	.+58     	; 0x1ff6 <chk_mounted+0x81c>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
    1fbc:	8a e0       	ldi	r24, 0x0A	; 10
    1fbe:	1b c0       	rjmp	.+54     	; 0x1ff6 <chk_mounted+0x81c>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    1fc0:	8d e0       	ldi	r24, 0x0D	; 13
    1fc2:	19 c0       	rjmp	.+50     	; 0x1ff6 <chk_mounted+0x81c>
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    1fc4:	81 e0       	ldi	r24, 0x01	; 1
    1fc6:	17 c0       	rjmp	.+46     	; 0x1ff6 <chk_mounted+0x81c>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    1fc8:	8d e0       	ldi	r24, 0x0D	; 13
    1fca:	15 c0       	rjmp	.+42     	; 0x1ff6 <chk_mounted+0x81c>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;
    1fcc:	8d e0       	ldi	r24, 0x0D	; 13
    1fce:	13 c0       	rjmp	.+38     	; 0x1ff6 <chk_mounted+0x81c>
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    1fd0:	8d e0       	ldi	r24, 0x0D	; 13
    1fd2:	11 c0       	rjmp	.+34     	; 0x1ff6 <chk_mounted+0x81c>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    1fd4:	8d e0       	ldi	r24, 0x0D	; 13
    1fd6:	0f c0       	rjmp	.+30     	; 0x1ff6 <chk_mounted+0x81c>
    1fd8:	8d e0       	ldi	r24, 0x0D	; 13
    1fda:	0d c0       	rjmp	.+26     	; 0x1ff6 <chk_mounted+0x81c>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    1fdc:	8d e0       	ldi	r24, 0x0D	; 13
    1fde:	0b c0       	rjmp	.+22     	; 0x1ff6 <chk_mounted+0x81c>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    1fe0:	8d e0       	ldi	r24, 0x0D	; 13
    1fe2:	09 c0       	rjmp	.+18     	; 0x1ff6 <chk_mounted+0x81c>

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    1fe4:	8d e0       	ldi	r24, 0x0D	; 13
    1fe6:	07 c0       	rjmp	.+14     	; 0x1ff6 <chk_mounted+0x81c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    1fe8:	8d e0       	ldi	r24, 0x0D	; 13
    1fea:	05 c0       	rjmp	.+10     	; 0x1ff6 <chk_mounted+0x81c>
	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    1fec:	8d e0       	ldi	r24, 0x0D	; 13
    1fee:	03 c0       	rjmp	.+6      	; 0x1ff6 <chk_mounted+0x81c>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    1ff0:	8d e0       	ldi	r24, 0x0D	; 13
    1ff2:	01 c0       	rjmp	.+2      	; 0x1ff6 <chk_mounted+0x81c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;
    1ff4:	8d e0       	ldi	r24, 0x0D	; 13
#if _FS_LOCK				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
}
    1ff6:	60 96       	adiw	r28, 0x10	; 16
    1ff8:	0f b6       	in	r0, 0x3f	; 63
    1ffa:	f8 94       	cli
    1ffc:	de bf       	out	0x3e, r29	; 62
    1ffe:	0f be       	out	0x3f, r0	; 63
    2000:	cd bf       	out	0x3d, r28	; 61
    2002:	df 91       	pop	r29
    2004:	cf 91       	pop	r28
    2006:	1f 91       	pop	r17
    2008:	0f 91       	pop	r16
    200a:	ff 90       	pop	r15
    200c:	ef 90       	pop	r14
    200e:	df 90       	pop	r13
    2010:	cf 90       	pop	r12
    2012:	bf 90       	pop	r11
    2014:	af 90       	pop	r10
    2016:	9f 90       	pop	r9
    2018:	8f 90       	pop	r8
    201a:	7f 90       	pop	r7
    201c:	6f 90       	pop	r6
    201e:	5f 90       	pop	r5
    2020:	4f 90       	pop	r4
    2022:	3f 90       	pop	r3
    2024:	2f 90       	pop	r2
    2026:	08 95       	ret
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    2028:	b9 01       	movw	r22, r18
    202a:	a8 01       	movw	r20, r16
    202c:	4e 5f       	subi	r20, 0xFE	; 254
    202e:	5f 4f       	sbci	r21, 0xFF	; 255
    2030:	6f 4f       	sbci	r22, 0xFF	; 255
    2032:	7f 4f       	sbci	r23, 0xFF	; 255
    2034:	f7 01       	movw	r30, r14
    2036:	42 8f       	std	Z+26, r20	; 0x1a
    2038:	53 8f       	std	Z+27, r21	; 0x1b
    203a:	64 8f       	std	Z+28, r22	; 0x1c
    203c:	75 8f       	std	Z+29, r23	; 0x1d
	fs->database = bsect + sysect;						/* Data start sector */
    203e:	8d 81       	ldd	r24, Y+5	; 0x05
    2040:	9e 81       	ldd	r25, Y+6	; 0x06
    2042:	af 81       	ldd	r26, Y+7	; 0x07
    2044:	b8 85       	ldd	r27, Y+8	; 0x08
    2046:	88 0d       	add	r24, r8
    2048:	99 1d       	adc	r25, r9
    204a:	aa 1d       	adc	r26, r10
    204c:	bb 1d       	adc	r27, r11
    204e:	82 a7       	lds	r24, 0x72
    2050:	93 a7       	lds	r25, 0x73
    2052:	a4 a7       	lds	r26, 0x74
    2054:	b5 a7       	lds	r27, 0x75
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    2056:	89 85       	ldd	r24, Y+9	; 0x09
    2058:	9a 85       	ldd	r25, Y+10	; 0x0a
    205a:	ab 85       	ldd	r26, Y+11	; 0x0b
    205c:	bc 85       	ldd	r27, Y+12	; 0x0c
    205e:	88 0d       	add	r24, r8
    2060:	99 1d       	adc	r25, r9
    2062:	aa 1d       	adc	r26, r10
    2064:	bb 1d       	adc	r27, r11
    2066:	82 a3       	lds	r24, 0x52
    2068:	93 a3       	lds	r25, 0x53
    206a:	a4 a3       	lds	r26, 0x54
    206c:	b5 a3       	lds	r27, 0x55
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    206e:	0f 2e       	mov	r0, r31
    2070:	f3 e0       	ldi	r31, 0x03	; 3
    2072:	df 2e       	mov	r13, r31
    2074:	f0 2d       	mov	r31, r0
    2076:	e3 cd       	rjmp	.-1082   	; 0x1c3e <chk_mounted+0x464>

00002078 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
    2078:	4f 92       	push	r4
    207a:	5f 92       	push	r5
    207c:	6f 92       	push	r6
    207e:	7f 92       	push	r7
    2080:	8f 92       	push	r8
    2082:	9f 92       	push	r9
    2084:	af 92       	push	r10
    2086:	bf 92       	push	r11
    2088:	cf 92       	push	r12
    208a:	df 92       	push	r13
    208c:	ef 92       	push	r14
    208e:	ff 92       	push	r15
    2090:	0f 93       	push	r16
    2092:	cf 93       	push	r28
    2094:	5c 01       	movw	r10, r24
    2096:	2a 01       	movw	r4, r20
    2098:	3b 01       	movw	r6, r22
	DWORD wsect;


	wsect = fs->winsect;
    209a:	fc 01       	movw	r30, r24
    209c:	c6 a4       	lds	r28, 0xa6
    209e:	d7 a4       	lds	r29, 0xa7
    20a0:	e0 a8       	sts	0x00, r30
    20a2:	f1 a8       	sts	0x81, r31
	if (wsect != sector) {	/* Changed current window */
    20a4:	c4 16       	cp	r12, r20
    20a6:	d5 06       	cpc	r13, r21
    20a8:	e6 06       	cpc	r14, r22
    20aa:	f7 06       	cpc	r15, r23
    20ac:	09 f4       	brne	.+2      	; 0x20b0 <move_window+0x38>
    20ae:	54 c0       	rjmp	.+168    	; 0x2158 <move_window+0xe0>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
    20b0:	84 81       	ldd	r24, Z+4	; 0x04
    20b2:	88 23       	and	r24, r24
    20b4:	d1 f1       	breq	.+116    	; 0x212a <move_window+0xb2>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    20b6:	0f 2e       	mov	r0, r31
    20b8:	f2 e3       	ldi	r31, 0x32	; 50
    20ba:	8f 2e       	mov	r8, r31
    20bc:	99 24       	eor	r9, r9
    20be:	f0 2d       	mov	r31, r0
    20c0:	8a 0c       	add	r8, r10
    20c2:	9b 1c       	adc	r9, r11
    20c4:	81 81       	ldd	r24, Z+1	; 0x01
    20c6:	b4 01       	movw	r22, r8
    20c8:	a7 01       	movw	r20, r14
    20ca:	96 01       	movw	r18, r12
    20cc:	01 e0       	ldi	r16, 0x01	; 1
    20ce:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    20d2:	88 23       	and	r24, r24
    20d4:	09 f0       	breq	.+2      	; 0x20d8 <move_window+0x60>
    20d6:	42 c0       	rjmp	.+132    	; 0x215c <move_window+0xe4>
				return FR_DISK_ERR;
			fs->wflag = 0;
    20d8:	f5 01       	movw	r30, r10
    20da:	14 82       	std	Z+4, r1	; 0x04
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    20dc:	46 8d       	ldd	r20, Z+30	; 0x1e
    20de:	57 8d       	ldd	r21, Z+31	; 0x1f
    20e0:	60 a1       	lds	r22, 0x40
    20e2:	71 a1       	lds	r23, 0x41
    20e4:	82 a1       	lds	r24, 0x42
    20e6:	93 a1       	lds	r25, 0x43
    20e8:	a4 a1       	lds	r26, 0x44
    20ea:	b5 a1       	lds	r27, 0x45
    20ec:	84 0f       	add	r24, r20
    20ee:	95 1f       	adc	r25, r21
    20f0:	a6 1f       	adc	r26, r22
    20f2:	b7 1f       	adc	r27, r23
    20f4:	c8 16       	cp	r12, r24
    20f6:	d9 06       	cpc	r13, r25
    20f8:	ea 06       	cpc	r14, r26
    20fa:	fb 06       	cpc	r15, r27
    20fc:	b0 f4       	brcc	.+44     	; 0x212a <move_window+0xb2>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    20fe:	c3 81       	ldd	r28, Z+3	; 0x03
    2100:	c2 30       	cpi	r28, 0x02	; 2
    2102:	98 f0       	brcs	.+38     	; 0x212a <move_window+0xb2>
					wsect += fs->fsize;
    2104:	f5 01       	movw	r30, r10
    2106:	86 8d       	ldd	r24, Z+30	; 0x1e
    2108:	97 8d       	ldd	r25, Z+31	; 0x1f
    210a:	a0 a1       	lds	r26, 0x40
    210c:	b1 a1       	lds	r27, 0x41
    210e:	c8 0e       	add	r12, r24
    2110:	d9 1e       	adc	r13, r25
    2112:	ea 1e       	adc	r14, r26
    2114:	fb 1e       	adc	r15, r27
					disk_write(fs->drv, fs->win, wsect, 1);
    2116:	81 81       	ldd	r24, Z+1	; 0x01
    2118:	b4 01       	movw	r22, r8
    211a:	a7 01       	movw	r20, r14
    211c:	96 01       	movw	r18, r12
    211e:	01 e0       	ldi	r16, 0x01	; 1
    2120:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    2124:	c1 50       	subi	r28, 0x01	; 1
    2126:	c1 30       	cpi	r28, 0x01	; 1
    2128:	69 f7       	brne	.-38     	; 0x2104 <move_window+0x8c>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
    212a:	41 14       	cp	r4, r1
    212c:	51 04       	cpc	r5, r1
    212e:	61 04       	cpc	r6, r1
    2130:	71 04       	cpc	r7, r1
    2132:	b1 f0       	breq	.+44     	; 0x2160 <move_window+0xe8>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    2134:	b5 01       	movw	r22, r10
    2136:	6e 5c       	subi	r22, 0xCE	; 206
    2138:	7f 4f       	sbci	r23, 0xFF	; 255
    213a:	f5 01       	movw	r30, r10
    213c:	81 81       	ldd	r24, Z+1	; 0x01
    213e:	a3 01       	movw	r20, r6
    2140:	92 01       	movw	r18, r4
    2142:	01 e0       	ldi	r16, 0x01	; 1
    2144:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    2148:	88 23       	and	r24, r24
    214a:	61 f4       	brne	.+24     	; 0x2164 <move_window+0xec>
				return FR_DISK_ERR;
			fs->winsect = sector;
    214c:	f5 01       	movw	r30, r10
    214e:	46 a6       	lds	r20, 0xb6
    2150:	57 a6       	lds	r21, 0xb7
    2152:	60 aa       	sts	0x90, r22
    2154:	71 aa       	sts	0x91, r23
    2156:	07 c0       	rjmp	.+14     	; 0x2166 <move_window+0xee>
		}
	}

	return FR_OK;
    2158:	80 e0       	ldi	r24, 0x00	; 0
    215a:	05 c0       	rjmp	.+10     	; 0x2166 <move_window+0xee>
	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
    215c:	81 e0       	ldi	r24, 0x01	; 1
    215e:	03 c0       	rjmp	.+6      	; 0x2166 <move_window+0xee>
				return FR_DISK_ERR;
			fs->winsect = sector;
		}
	}

	return FR_OK;
    2160:	80 e0       	ldi	r24, 0x00	; 0
    2162:	01 c0       	rjmp	.+2      	; 0x2166 <move_window+0xee>
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
    2164:	81 e0       	ldi	r24, 0x01	; 1
			fs->winsect = sector;
		}
	}

	return FR_OK;
}
    2166:	cf 91       	pop	r28
    2168:	0f 91       	pop	r16
    216a:	ff 90       	pop	r15
    216c:	ef 90       	pop	r14
    216e:	df 90       	pop	r13
    2170:	cf 90       	pop	r12
    2172:	bf 90       	pop	r11
    2174:	af 90       	pop	r10
    2176:	9f 90       	pop	r9
    2178:	8f 90       	pop	r8
    217a:	7f 90       	pop	r7
    217c:	6f 90       	pop	r6
    217e:	5f 90       	pop	r5
    2180:	4f 90       	pop	r4
    2182:	08 95       	ret

00002184 <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
    2184:	ef 92       	push	r14
    2186:	ff 92       	push	r15
    2188:	0f 93       	push	r16
    218a:	1f 93       	push	r17
    218c:	cf 93       	push	r28
    218e:	7c 01       	movw	r14, r24
	FRESULT res;


	res = move_window(fs, 0);
    2190:	40 e0       	ldi	r20, 0x00	; 0
    2192:	50 e0       	ldi	r21, 0x00	; 0
    2194:	ba 01       	movw	r22, r20
    2196:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
    219a:	c8 2f       	mov	r28, r24
	if (res == FR_OK) {
    219c:	88 23       	and	r24, r24
    219e:	09 f0       	breq	.+2      	; 0x21a2 <sync+0x1e>
    21a0:	78 c0       	rjmp	.+240    	; 0x2292 <sync+0x10e>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    21a2:	f7 01       	movw	r30, r14
    21a4:	80 81       	ld	r24, Z
    21a6:	83 30       	cpi	r24, 0x03	; 3
    21a8:	09 f0       	breq	.+2      	; 0x21ac <sync+0x28>
    21aa:	6a c0       	rjmp	.+212    	; 0x2280 <sync+0xfc>
    21ac:	85 81       	ldd	r24, Z+5	; 0x05
    21ae:	88 23       	and	r24, r24
    21b0:	09 f4       	brne	.+2      	; 0x21b4 <sync+0x30>
    21b2:	66 c0       	rjmp	.+204    	; 0x2280 <sync+0xfc>
			fs->winsect = 0;
    21b4:	16 a6       	lds	r17, 0xb6
    21b6:	17 a6       	lds	r17, 0xb7
    21b8:	10 aa       	sts	0x90, r17
    21ba:	11 aa       	sts	0x91, r17
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
    21bc:	87 01       	movw	r16, r14
    21be:	0e 5c       	subi	r16, 0xCE	; 206
    21c0:	1f 4f       	sbci	r17, 0xFF	; 255
    21c2:	c8 01       	movw	r24, r16
    21c4:	60 e0       	ldi	r22, 0x00	; 0
    21c6:	70 e0       	ldi	r23, 0x00	; 0
    21c8:	20 e0       	ldi	r18, 0x00	; 0
    21ca:	32 e0       	ldi	r19, 0x02	; 2
    21cc:	40 e0       	ldi	r20, 0x00	; 0
    21ce:	50 e0       	ldi	r21, 0x00	; 0
    21d0:	0e 94 5f 0a 	call	0x14be	; 0x14be <mem_set>
			ST_WORD(fs->win+BS_55AA, 0xAA55);
    21d4:	f7 01       	movw	r30, r14
    21d6:	e0 5d       	subi	r30, 0xD0	; 208
    21d8:	fd 4f       	sbci	r31, 0xFD	; 253
    21da:	85 e5       	ldi	r24, 0x55	; 85
    21dc:	80 83       	st	Z, r24
    21de:	f7 01       	movw	r30, r14
    21e0:	ef 5c       	subi	r30, 0xCF	; 207
    21e2:	fd 4f       	sbci	r31, 0xFD	; 253
    21e4:	8a ea       	ldi	r24, 0xAA	; 170
    21e6:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    21e8:	82 e5       	ldi	r24, 0x52	; 82
    21ea:	f7 01       	movw	r30, r14
    21ec:	82 ab       	sts	0x52, r24
    21ee:	83 ab       	sts	0x53, r24
    21f0:	81 e6       	ldi	r24, 0x61	; 97
    21f2:	84 ab       	sts	0x54, r24
    21f4:	91 e4       	ldi	r25, 0x41	; 65
    21f6:	95 ab       	sts	0x55, r25
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    21f8:	ea 5e       	subi	r30, 0xEA	; 234
    21fa:	fd 4f       	sbci	r31, 0xFD	; 253
    21fc:	22 e7       	ldi	r18, 0x72	; 114
    21fe:	20 83       	st	Z, r18
    2200:	f7 01       	movw	r30, r14
    2202:	e9 5e       	subi	r30, 0xE9	; 233
    2204:	fd 4f       	sbci	r31, 0xFD	; 253
    2206:	20 83       	st	Z, r18
    2208:	f7 01       	movw	r30, r14
    220a:	e8 5e       	subi	r30, 0xE8	; 232
    220c:	fd 4f       	sbci	r31, 0xFD	; 253
    220e:	90 83       	st	Z, r25
    2210:	f7 01       	movw	r30, r14
    2212:	e7 5e       	subi	r30, 0xE7	; 231
    2214:	fd 4f       	sbci	r31, 0xFD	; 253
    2216:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    2218:	f7 01       	movw	r30, r14
    221a:	36 85       	ldd	r19, Z+14	; 0x0e
    221c:	27 85       	ldd	r18, Z+15	; 0x0f
    221e:	90 89       	ldd	r25, Z+16	; 0x10
    2220:	81 89       	ldd	r24, Z+17	; 0x11
    2222:	e6 5e       	subi	r30, 0xE6	; 230
    2224:	fd 4f       	sbci	r31, 0xFD	; 253
    2226:	30 83       	st	Z, r19
    2228:	f7 01       	movw	r30, r14
    222a:	e5 5e       	subi	r30, 0xE5	; 229
    222c:	fd 4f       	sbci	r31, 0xFD	; 253
    222e:	20 83       	st	Z, r18
    2230:	f7 01       	movw	r30, r14
    2232:	e4 5e       	subi	r30, 0xE4	; 228
    2234:	fd 4f       	sbci	r31, 0xFD	; 253
    2236:	90 83       	st	Z, r25
    2238:	f7 01       	movw	r30, r14
    223a:	e3 5e       	subi	r30, 0xE3	; 227
    223c:	fd 4f       	sbci	r31, 0xFD	; 253
    223e:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    2240:	f7 01       	movw	r30, r14
    2242:	32 85       	ldd	r19, Z+10	; 0x0a
    2244:	23 85       	ldd	r18, Z+11	; 0x0b
    2246:	94 85       	ldd	r25, Z+12	; 0x0c
    2248:	85 85       	ldd	r24, Z+13	; 0x0d
    224a:	e2 5e       	subi	r30, 0xE2	; 226
    224c:	fd 4f       	sbci	r31, 0xFD	; 253
    224e:	30 83       	st	Z, r19
    2250:	f7 01       	movw	r30, r14
    2252:	e1 5e       	subi	r30, 0xE1	; 225
    2254:	fd 4f       	sbci	r31, 0xFD	; 253
    2256:	20 83       	st	Z, r18
    2258:	f7 01       	movw	r30, r14
    225a:	e0 5e       	subi	r30, 0xE0	; 224
    225c:	fd 4f       	sbci	r31, 0xFD	; 253
    225e:	90 83       	st	Z, r25
    2260:	f7 01       	movw	r30, r14
    2262:	ef 5d       	subi	r30, 0xDF	; 223
    2264:	fd 4f       	sbci	r31, 0xFD	; 253
    2266:	80 83       	st	Z, r24
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    2268:	f7 01       	movw	r30, r14
    226a:	22 89       	ldd	r18, Z+18	; 0x12
    226c:	33 89       	ldd	r19, Z+19	; 0x13
    226e:	44 89       	ldd	r20, Z+20	; 0x14
    2270:	55 89       	ldd	r21, Z+21	; 0x15
    2272:	81 81       	ldd	r24, Z+1	; 0x01
    2274:	b8 01       	movw	r22, r16
    2276:	01 e0       	ldi	r16, 0x01	; 1
    2278:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
			fs->fsi_flag = 0;
    227c:	f7 01       	movw	r30, r14
    227e:	15 82       	std	Z+5, r1	; 0x05
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    2280:	f7 01       	movw	r30, r14
    2282:	81 81       	ldd	r24, Z+1	; 0x01
    2284:	60 e0       	ldi	r22, 0x00	; 0
    2286:	40 e0       	ldi	r20, 0x00	; 0
    2288:	50 e0       	ldi	r21, 0x00	; 0
    228a:	0e 94 66 03 	call	0x6cc	; 0x6cc <disk_ioctl>
    228e:	81 11       	cpse	r24, r1
			res = FR_DISK_ERR;
    2290:	c1 e0       	ldi	r28, 0x01	; 1
	}

	return res;
}
    2292:	8c 2f       	mov	r24, r28
    2294:	cf 91       	pop	r28
    2296:	1f 91       	pop	r17
    2298:	0f 91       	pop	r16
    229a:	ff 90       	pop	r15
    229c:	ef 90       	pop	r14
    229e:	08 95       	ret

000022a0 <get_fattime>:
#include "diskio.h"		/* Declarations of low level disk I/O functions */

DWORD get_fattime( void )
{
	return 0;
}
    22a0:	60 e0       	ldi	r22, 0x00	; 0
    22a2:	70 e0       	ldi	r23, 0x00	; 0
    22a4:	cb 01       	movw	r24, r22
    22a6:	08 95       	ret

000022a8 <clust2sect>:

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
    22a8:	0f 93       	push	r16
    22aa:	1f 93       	push	r17
    22ac:	cf 93       	push	r28
    22ae:	df 93       	push	r29
    22b0:	ec 01       	movw	r28, r24
    22b2:	db 01       	movw	r26, r22
    22b4:	ca 01       	movw	r24, r20
	clst -= 2;
    22b6:	02 97       	sbiw	r24, 0x02	; 2
    22b8:	a1 09       	sbc	r26, r1
    22ba:	b1 09       	sbc	r27, r1
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    22bc:	4a 8d       	ldd	r20, Y+26	; 0x1a
    22be:	5b 8d       	ldd	r21, Y+27	; 0x1b
    22c0:	6c 8d       	ldd	r22, Y+28	; 0x1c
    22c2:	7d 8d       	ldd	r23, Y+29	; 0x1d
    22c4:	42 50       	subi	r20, 0x02	; 2
    22c6:	50 40       	sbci	r21, 0x00	; 0
    22c8:	60 40       	sbci	r22, 0x00	; 0
    22ca:	70 40       	sbci	r23, 0x00	; 0
    22cc:	84 17       	cp	r24, r20
    22ce:	95 07       	cpc	r25, r21
    22d0:	a6 07       	cpc	r26, r22
    22d2:	b7 07       	cpc	r27, r23
    22d4:	98 f4       	brcc	.+38     	; 0x22fc <clust2sect+0x54>
	return clst * fs->csize + fs->database;
    22d6:	2a 81       	ldd	r18, Y+2	; 0x02
    22d8:	30 e0       	ldi	r19, 0x00	; 0
    22da:	40 e0       	ldi	r20, 0x00	; 0
    22dc:	50 e0       	ldi	r21, 0x00	; 0
    22de:	bc 01       	movw	r22, r24
    22e0:	cd 01       	movw	r24, r26
    22e2:	0e 94 2e 2b 	call	0x565c	; 0x565c <__mulsi3>
    22e6:	8b 01       	movw	r16, r22
    22e8:	9c 01       	movw	r18, r24
    22ea:	8a a5       	lds	r24, 0x6a
    22ec:	9b a5       	lds	r25, 0x6b
    22ee:	ac a5       	lds	r26, 0x6c
    22f0:	bd a5       	lds	r27, 0x6d
    22f2:	08 0f       	add	r16, r24
    22f4:	19 1f       	adc	r17, r25
    22f6:	2a 1f       	adc	r18, r26
    22f8:	3b 1f       	adc	r19, r27
    22fa:	03 c0       	rjmp	.+6      	; 0x2302 <clust2sect+0x5a>
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    22fc:	00 e0       	ldi	r16, 0x00	; 0
    22fe:	10 e0       	ldi	r17, 0x00	; 0
    2300:	98 01       	movw	r18, r16
	return clst * fs->csize + fs->database;
}
    2302:	60 2f       	mov	r22, r16
    2304:	71 2f       	mov	r23, r17
    2306:	82 2f       	mov	r24, r18
    2308:	93 2f       	mov	r25, r19
    230a:	df 91       	pop	r29
    230c:	cf 91       	pop	r28
    230e:	1f 91       	pop	r17
    2310:	0f 91       	pop	r16
    2312:	08 95       	ret

00002314 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
    2314:	8f 92       	push	r8
    2316:	9f 92       	push	r9
    2318:	af 92       	push	r10
    231a:	bf 92       	push	r11
    231c:	cf 92       	push	r12
    231e:	df 92       	push	r13
    2320:	ef 92       	push	r14
    2322:	ff 92       	push	r15
    2324:	0f 93       	push	r16
    2326:	1f 93       	push	r17
    2328:	cf 93       	push	r28
    232a:	df 93       	push	r29
    232c:	ec 01       	movw	r28, r24
    232e:	6a 01       	movw	r12, r20
    2330:	7b 01       	movw	r14, r22
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
    2332:	42 30       	cpi	r20, 0x02	; 2
    2334:	51 05       	cpc	r21, r1
    2336:	61 05       	cpc	r22, r1
    2338:	71 05       	cpc	r23, r1
    233a:	08 f4       	brcc	.+2      	; 0x233e <get_fat+0x2a>
    233c:	f4 c0       	rjmp	.+488    	; 0x2526 <get_fat+0x212>
    233e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2340:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2342:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2344:	bd 8d       	ldd	r27, Y+29	; 0x1d
    2346:	48 17       	cp	r20, r24
    2348:	59 07       	cpc	r21, r25
    234a:	6a 07       	cpc	r22, r26
    234c:	7b 07       	cpc	r23, r27
    234e:	08 f0       	brcs	.+2      	; 0x2352 <get_fat+0x3e>
    2350:	ef c0       	rjmp	.+478    	; 0x2530 <get_fat+0x21c>
		return 1;

	switch (fs->fs_type) {
    2352:	88 81       	ld	r24, Y
    2354:	82 30       	cpi	r24, 0x02	; 2
    2356:	09 f4       	brne	.+2      	; 0x235a <get_fat+0x46>
    2358:	81 c0       	rjmp	.+258    	; 0x245c <get_fat+0x148>
    235a:	83 30       	cpi	r24, 0x03	; 3
    235c:	09 f4       	brne	.+2      	; 0x2360 <get_fat+0x4c>
    235e:	a0 c0       	rjmp	.+320    	; 0x24a0 <get_fat+0x18c>
    2360:	81 30       	cpi	r24, 0x01	; 1
    2362:	09 f0       	breq	.+2      	; 0x2366 <get_fat+0x52>
    2364:	ea c0       	rjmp	.+468    	; 0x253a <get_fat+0x226>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
    2366:	4a 01       	movw	r8, r20
    2368:	5b 01       	movw	r10, r22
    236a:	b6 94       	lsr	r11
    236c:	a7 94       	ror	r10
    236e:	97 94       	ror	r9
    2370:	87 94       	ror	r8
    2372:	84 0e       	add	r8, r20
    2374:	95 1e       	adc	r9, r21
    2376:	a6 1e       	adc	r10, r22
    2378:	b7 1e       	adc	r11, r23
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    237a:	b5 01       	movw	r22, r10
    237c:	a4 01       	movw	r20, r8
    237e:	03 2e       	mov	r0, r19
    2380:	39 e0       	ldi	r19, 0x09	; 9
    2382:	76 95       	lsr	r23
    2384:	67 95       	ror	r22
    2386:	57 95       	ror	r21
    2388:	47 95       	ror	r20
    238a:	3a 95       	dec	r19
    238c:	d1 f7       	brne	.-12     	; 0x2382 <get_fat+0x6e>
    238e:	30 2d       	mov	r19, r0
    2390:	8a a1       	lds	r24, 0x4a
    2392:	9b a1       	lds	r25, 0x4b
    2394:	ac a1       	lds	r26, 0x4c
    2396:	bd a1       	lds	r27, 0x4d
    2398:	48 0f       	add	r20, r24
    239a:	59 1f       	adc	r21, r25
    239c:	6a 1f       	adc	r22, r26
    239e:	7b 1f       	adc	r23, r27
    23a0:	ce 01       	movw	r24, r28
    23a2:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
    23a6:	88 23       	and	r24, r24
    23a8:	09 f0       	breq	.+2      	; 0x23ac <get_fat+0x98>
    23aa:	cb c0       	rjmp	.+406    	; 0x2542 <get_fat+0x22e>
		wc = fs->win[bc % SS(fs)]; bc++;
    23ac:	d5 01       	movw	r26, r10
    23ae:	c4 01       	movw	r24, r8
    23b0:	91 70       	andi	r25, 0x01	; 1
    23b2:	a0 70       	andi	r26, 0x00	; 0
    23b4:	b0 70       	andi	r27, 0x00	; 0
    23b6:	fe 01       	movw	r30, r28
    23b8:	e8 0f       	add	r30, r24
    23ba:	f9 1f       	adc	r31, r25
    23bc:	12 a9       	sts	0x42, r17
    23be:	08 94       	sec
    23c0:	81 1c       	adc	r8, r1
    23c2:	91 1c       	adc	r9, r1
    23c4:	a1 1c       	adc	r10, r1
    23c6:	b1 1c       	adc	r11, r1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    23c8:	b5 01       	movw	r22, r10
    23ca:	a4 01       	movw	r20, r8
    23cc:	03 2e       	mov	r0, r19
    23ce:	39 e0       	ldi	r19, 0x09	; 9
    23d0:	76 95       	lsr	r23
    23d2:	67 95       	ror	r22
    23d4:	57 95       	ror	r21
    23d6:	47 95       	ror	r20
    23d8:	3a 95       	dec	r19
    23da:	d1 f7       	brne	.-12     	; 0x23d0 <get_fat+0xbc>
    23dc:	30 2d       	mov	r19, r0
    23de:	8a a1       	lds	r24, 0x4a
    23e0:	9b a1       	lds	r25, 0x4b
    23e2:	ac a1       	lds	r26, 0x4c
    23e4:	bd a1       	lds	r27, 0x4d
    23e6:	48 0f       	add	r20, r24
    23e8:	59 1f       	adc	r21, r25
    23ea:	6a 1f       	adc	r22, r26
    23ec:	7b 1f       	adc	r23, r27
    23ee:	ce 01       	movw	r24, r28
    23f0:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
    23f4:	88 23       	and	r24, r24
    23f6:	09 f0       	breq	.+2      	; 0x23fa <get_fat+0xe6>
    23f8:	a8 c0       	rjmp	.+336    	; 0x254a <get_fat+0x236>

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
    23fa:	41 2f       	mov	r20, r17
    23fc:	50 e0       	ldi	r21, 0x00	; 0
    23fe:	60 e0       	ldi	r22, 0x00	; 0
    2400:	70 e0       	ldi	r23, 0x00	; 0
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
    2402:	8f ef       	ldi	r24, 0xFF	; 255
    2404:	91 e0       	ldi	r25, 0x01	; 1
    2406:	a0 e0       	ldi	r26, 0x00	; 0
    2408:	b0 e0       	ldi	r27, 0x00	; 0
    240a:	88 22       	and	r8, r24
    240c:	99 22       	and	r9, r25
    240e:	aa 22       	and	r10, r26
    2410:	bb 22       	and	r11, r27
    2412:	fe 01       	movw	r30, r28
    2414:	e8 0d       	add	r30, r8
    2416:	f9 1d       	adc	r31, r9
    2418:	92 a9       	sts	0x42, r25
    241a:	80 e0       	ldi	r24, 0x00	; 0
    241c:	8c 01       	movw	r16, r24
    241e:	22 27       	eor	r18, r18
    2420:	17 fd       	sbrc	r17, 7
    2422:	20 95       	com	r18
    2424:	32 2f       	mov	r19, r18
    2426:	40 2b       	or	r20, r16
    2428:	51 2b       	or	r21, r17
    242a:	62 2b       	or	r22, r18
    242c:	73 2b       	or	r23, r19
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    242e:	91 e0       	ldi	r25, 0x01	; 1
    2430:	c9 22       	and	r12, r25
    2432:	dd 24       	eor	r13, r13
    2434:	c1 14       	cp	r12, r1
    2436:	d1 04       	cpc	r13, r1
    2438:	59 f0       	breq	.+22     	; 0x2450 <get_fat+0x13c>
    243a:	8a 01       	movw	r16, r20
    243c:	9b 01       	movw	r18, r22
    243e:	68 94       	set
    2440:	13 f8       	bld	r1, 3
    2442:	36 95       	lsr	r19
    2444:	27 95       	ror	r18
    2446:	17 95       	ror	r17
    2448:	07 95       	ror	r16
    244a:	16 94       	lsr	r1
    244c:	d1 f7       	brne	.-12     	; 0x2442 <get_fat+0x12e>
    244e:	88 c0       	rjmp	.+272    	; 0x2560 <get_fat+0x24c>
    2450:	8a 01       	movw	r16, r20
    2452:	9b 01       	movw	r18, r22
    2454:	1f 70       	andi	r17, 0x0F	; 15
    2456:	20 70       	andi	r18, 0x00	; 0
    2458:	30 70       	andi	r19, 0x00	; 0
    245a:	82 c0       	rjmp	.+260    	; 0x2560 <get_fat+0x24c>

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    245c:	45 2f       	mov	r20, r21
    245e:	56 2f       	mov	r21, r22
    2460:	67 2f       	mov	r22, r23
    2462:	77 27       	eor	r23, r23
    2464:	8a a1       	lds	r24, 0x4a
    2466:	9b a1       	lds	r25, 0x4b
    2468:	ac a1       	lds	r26, 0x4c
    246a:	bd a1       	lds	r27, 0x4d
    246c:	48 0f       	add	r20, r24
    246e:	59 1f       	adc	r21, r25
    2470:	6a 1f       	adc	r22, r26
    2472:	7b 1f       	adc	r23, r27
    2474:	ce 01       	movw	r24, r28
    2476:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
    247a:	88 23       	and	r24, r24
    247c:	09 f0       	breq	.+2      	; 0x2480 <get_fat+0x16c>
    247e:	69 c0       	rjmp	.+210    	; 0x2552 <get_fat+0x23e>
		p = &fs->win[clst * 2 % SS(fs)];
    2480:	f6 01       	movw	r30, r12
    2482:	ee 0f       	add	r30, r30
    2484:	ff 1f       	adc	r31, r31
    2486:	f1 70       	andi	r31, 0x01	; 1
		return LD_WORD(p);
    2488:	ce 0f       	add	r28, r30
    248a:	df 1f       	adc	r29, r31
    248c:	9b a9       	sts	0x4b, r25
    248e:	80 e0       	ldi	r24, 0x00	; 0
    2490:	0a a9       	sts	0x4a, r16
    2492:	10 e0       	ldi	r17, 0x00	; 0
    2494:	80 2b       	or	r24, r16
    2496:	91 2b       	or	r25, r17
    2498:	8c 01       	movw	r16, r24
    249a:	20 e0       	ldi	r18, 0x00	; 0
    249c:	30 e0       	ldi	r19, 0x00	; 0
    249e:	60 c0       	rjmp	.+192    	; 0x2560 <get_fat+0x24c>

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    24a0:	68 94       	set
    24a2:	16 f8       	bld	r1, 6
    24a4:	76 95       	lsr	r23
    24a6:	67 95       	ror	r22
    24a8:	57 95       	ror	r21
    24aa:	47 95       	ror	r20
    24ac:	16 94       	lsr	r1
    24ae:	d1 f7       	brne	.-12     	; 0x24a4 <get_fat+0x190>
    24b0:	8a a1       	lds	r24, 0x4a
    24b2:	9b a1       	lds	r25, 0x4b
    24b4:	ac a1       	lds	r26, 0x4c
    24b6:	bd a1       	lds	r27, 0x4d
    24b8:	48 0f       	add	r20, r24
    24ba:	59 1f       	adc	r21, r25
    24bc:	6a 1f       	adc	r22, r26
    24be:	7b 1f       	adc	r23, r27
    24c0:	ce 01       	movw	r24, r28
    24c2:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
    24c6:	88 23       	and	r24, r24
    24c8:	09 f0       	breq	.+2      	; 0x24cc <get_fat+0x1b8>
    24ca:	47 c0       	rjmp	.+142    	; 0x255a <get_fat+0x246>
		p = &fs->win[clst * 4 % SS(fs)];
    24cc:	f6 01       	movw	r30, r12
    24ce:	ee 0f       	add	r30, r30
    24d0:	ff 1f       	adc	r31, r31
    24d2:	ee 0f       	add	r30, r30
    24d4:	ff 1f       	adc	r31, r31
    24d6:	f1 70       	andi	r31, 0x01	; 1
		return LD_DWORD(p) & 0x0FFFFFFF;
    24d8:	ce 0f       	add	r28, r30
    24da:	df 1f       	adc	r29, r31
    24dc:	0d a9       	sts	0x4d, r16
    24de:	10 e0       	ldi	r17, 0x00	; 0
    24e0:	20 e0       	ldi	r18, 0x00	; 0
    24e2:	30 e0       	ldi	r19, 0x00	; 0
    24e4:	30 2f       	mov	r19, r16
    24e6:	22 27       	eor	r18, r18
    24e8:	11 27       	eor	r17, r17
    24ea:	00 27       	eor	r16, r16
    24ec:	8c a9       	sts	0x4c, r24
    24ee:	90 e0       	ldi	r25, 0x00	; 0
    24f0:	a0 e0       	ldi	r26, 0x00	; 0
    24f2:	b0 e0       	ldi	r27, 0x00	; 0
    24f4:	dc 01       	movw	r26, r24
    24f6:	99 27       	eor	r25, r25
    24f8:	88 27       	eor	r24, r24
    24fa:	08 2b       	or	r16, r24
    24fc:	19 2b       	or	r17, r25
    24fe:	2a 2b       	or	r18, r26
    2500:	3b 2b       	or	r19, r27
    2502:	8a a9       	sts	0x4a, r24
    2504:	90 e0       	ldi	r25, 0x00	; 0
    2506:	a0 e0       	ldi	r26, 0x00	; 0
    2508:	b0 e0       	ldi	r27, 0x00	; 0
    250a:	08 2b       	or	r16, r24
    250c:	19 2b       	or	r17, r25
    250e:	2a 2b       	or	r18, r26
    2510:	3b 2b       	or	r19, r27
    2512:	9b a9       	sts	0x4b, r25
    2514:	80 e0       	ldi	r24, 0x00	; 0
    2516:	a0 e0       	ldi	r26, 0x00	; 0
    2518:	b0 e0       	ldi	r27, 0x00	; 0
    251a:	08 2b       	or	r16, r24
    251c:	19 2b       	or	r17, r25
    251e:	2a 2b       	or	r18, r26
    2520:	3b 2b       	or	r19, r27
    2522:	3f 70       	andi	r19, 0x0F	; 15
    2524:	1d c0       	rjmp	.+58     	; 0x2560 <get_fat+0x24c>
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;
    2526:	01 e0       	ldi	r16, 0x01	; 1
    2528:	10 e0       	ldi	r17, 0x00	; 0
    252a:	20 e0       	ldi	r18, 0x00	; 0
    252c:	30 e0       	ldi	r19, 0x00	; 0
    252e:	18 c0       	rjmp	.+48     	; 0x2560 <get_fat+0x24c>
    2530:	01 e0       	ldi	r16, 0x01	; 1
    2532:	10 e0       	ldi	r17, 0x00	; 0
    2534:	20 e0       	ldi	r18, 0x00	; 0
    2536:	30 e0       	ldi	r19, 0x00	; 0
    2538:	13 c0       	rjmp	.+38     	; 0x2560 <get_fat+0x24c>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    253a:	0f ef       	ldi	r16, 0xFF	; 255
    253c:	1f ef       	ldi	r17, 0xFF	; 255
    253e:	98 01       	movw	r18, r16
    2540:	0f c0       	rjmp	.+30     	; 0x2560 <get_fat+0x24c>
    2542:	0f ef       	ldi	r16, 0xFF	; 255
    2544:	1f ef       	ldi	r17, 0xFF	; 255
    2546:	98 01       	movw	r18, r16
    2548:	0b c0       	rjmp	.+22     	; 0x2560 <get_fat+0x24c>
    254a:	0f ef       	ldi	r16, 0xFF	; 255
    254c:	1f ef       	ldi	r17, 0xFF	; 255
    254e:	98 01       	movw	r18, r16
    2550:	07 c0       	rjmp	.+14     	; 0x2560 <get_fat+0x24c>
    2552:	0f ef       	ldi	r16, 0xFF	; 255
    2554:	1f ef       	ldi	r17, 0xFF	; 255
    2556:	98 01       	movw	r18, r16
    2558:	03 c0       	rjmp	.+6      	; 0x2560 <get_fat+0x24c>
    255a:	0f ef       	ldi	r16, 0xFF	; 255
    255c:	1f ef       	ldi	r17, 0xFF	; 255
    255e:	98 01       	movw	r18, r16
}
    2560:	60 2f       	mov	r22, r16
    2562:	71 2f       	mov	r23, r17
    2564:	82 2f       	mov	r24, r18
    2566:	93 2f       	mov	r25, r19
    2568:	df 91       	pop	r29
    256a:	cf 91       	pop	r28
    256c:	1f 91       	pop	r17
    256e:	0f 91       	pop	r16
    2570:	ff 90       	pop	r15
    2572:	ef 90       	pop	r14
    2574:	df 90       	pop	r13
    2576:	cf 90       	pop	r12
    2578:	bf 90       	pop	r11
    257a:	af 90       	pop	r10
    257c:	9f 90       	pop	r9
    257e:	8f 90       	pop	r8
    2580:	08 95       	ret

00002582 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Index of directory table */
)
{
    2582:	ef 92       	push	r14
    2584:	ff 92       	push	r15
    2586:	0f 93       	push	r16
    2588:	1f 93       	push	r17
    258a:	cf 93       	push	r28
    258c:	df 93       	push	r29
    258e:	ec 01       	movw	r28, r24
    2590:	8b 01       	movw	r16, r22
	DWORD clst;
	WORD ic;


	dj->index = idx;
    2592:	7d 83       	std	Y+5, r23	; 0x05
    2594:	6c 83       	std	Y+4, r22	; 0x04
	clst = dj->sclust;
    2596:	4e 81       	ldd	r20, Y+6	; 0x06
    2598:	5f 81       	ldd	r21, Y+7	; 0x07
    259a:	68 85       	ldd	r22, Y+8	; 0x08
    259c:	79 85       	ldd	r23, Y+9	; 0x09
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    259e:	41 30       	cpi	r20, 0x01	; 1
    25a0:	51 05       	cpc	r21, r1
    25a2:	61 05       	cpc	r22, r1
    25a4:	71 05       	cpc	r23, r1
    25a6:	09 f4       	brne	.+2      	; 0x25aa <dir_sdi+0x28>
    25a8:	9f c0       	rjmp	.+318    	; 0x26e8 <dir_sdi+0x166>
    25aa:	e8 81       	ld	r30, Y
    25ac:	f9 81       	ldd	r31, Y+1	; 0x01
    25ae:	82 8d       	ldd	r24, Z+26	; 0x1a
    25b0:	93 8d       	ldd	r25, Z+27	; 0x1b
    25b2:	a4 8d       	ldd	r26, Z+28	; 0x1c
    25b4:	b5 8d       	ldd	r27, Z+29	; 0x1d
    25b6:	48 17       	cp	r20, r24
    25b8:	59 07       	cpc	r21, r25
    25ba:	6a 07       	cpc	r22, r26
    25bc:	7b 07       	cpc	r23, r27
    25be:	08 f0       	brcs	.+2      	; 0x25c2 <dir_sdi+0x40>
    25c0:	95 c0       	rjmp	.+298    	; 0x26ec <dir_sdi+0x16a>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    25c2:	41 15       	cp	r20, r1
    25c4:	51 05       	cpc	r21, r1
    25c6:	61 05       	cpc	r22, r1
    25c8:	71 05       	cpc	r23, r1
    25ca:	69 f5       	brne	.+90     	; 0x2626 <dir_sdi+0xa4>
    25cc:	80 81       	ld	r24, Z
    25ce:	83 30       	cpi	r24, 0x03	; 3
    25d0:	49 f4       	brne	.+18     	; 0x25e4 <dir_sdi+0x62>
		clst = dj->fs->dirbase;
    25d2:	46 a1       	lds	r20, 0x46
    25d4:	57 a1       	lds	r21, 0x47
    25d6:	60 a5       	lds	r22, 0x60
    25d8:	71 a5       	lds	r23, 0x61

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    25da:	41 15       	cp	r20, r1
    25dc:	51 05       	cpc	r21, r1
    25de:	61 05       	cpc	r22, r1
    25e0:	71 05       	cpc	r23, r1
    25e2:	09 f5       	brne	.+66     	; 0x2626 <dir_sdi+0xa4>
		dj->clust = clst;
    25e4:	1a 86       	std	Y+10, r1	; 0x0a
    25e6:	1b 86       	std	Y+11, r1	; 0x0b
    25e8:	1c 86       	std	Y+12, r1	; 0x0c
    25ea:	1d 86       	std	Y+13, r1	; 0x0d
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    25ec:	80 85       	ldd	r24, Z+8	; 0x08
    25ee:	91 85       	ldd	r25, Z+9	; 0x09
    25f0:	08 17       	cp	r16, r24
    25f2:	19 07       	cpc	r17, r25
    25f4:	08 f0       	brcs	.+2      	; 0x25f8 <dir_sdi+0x76>
    25f6:	7c c0       	rjmp	.+248    	; 0x26f0 <dir_sdi+0x16e>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    25f8:	c8 01       	movw	r24, r16
    25fa:	92 95       	swap	r25
    25fc:	82 95       	swap	r24
    25fe:	8f 70       	andi	r24, 0x0F	; 15
    2600:	89 27       	eor	r24, r25
    2602:	9f 70       	andi	r25, 0x0F	; 15
    2604:	89 27       	eor	r24, r25
    2606:	ac 01       	movw	r20, r24
    2608:	60 e0       	ldi	r22, 0x00	; 0
    260a:	70 e0       	ldi	r23, 0x00	; 0
    260c:	86 a1       	lds	r24, 0x46
    260e:	97 a1       	lds	r25, 0x47
    2610:	a0 a5       	lds	r26, 0x60
    2612:	b1 a5       	lds	r27, 0x61
    2614:	84 0f       	add	r24, r20
    2616:	95 1f       	adc	r25, r21
    2618:	a6 1f       	adc	r26, r22
    261a:	b7 1f       	adc	r27, r23
    261c:	8e 87       	std	Y+14, r24	; 0x0e
    261e:	9f 87       	std	Y+15, r25	; 0x0f
    2620:	a8 8b       	std	Y+16, r26	; 0x10
    2622:	b9 8b       	std	Y+17, r27	; 0x11
    2624:	4e c0       	rjmp	.+156    	; 0x26c2 <dir_sdi+0x140>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    2626:	82 81       	ldd	r24, Z+2	; 0x02
    2628:	90 e0       	ldi	r25, 0x00	; 0
    262a:	7c 01       	movw	r14, r24
    262c:	ee 0c       	add	r14, r14
    262e:	ff 1c       	adc	r15, r15
    2630:	ee 0c       	add	r14, r14
    2632:	ff 1c       	adc	r15, r15
    2634:	ee 0c       	add	r14, r14
    2636:	ff 1c       	adc	r15, r15
    2638:	ee 0c       	add	r14, r14
    263a:	ff 1c       	adc	r15, r15
		while (idx >= ic) {	/* Follow cluster chain */
    263c:	0e 15       	cp	r16, r14
    263e:	1f 05       	cpc	r17, r15
    2640:	28 f1       	brcs	.+74     	; 0x268c <dir_sdi+0x10a>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    2642:	88 81       	ld	r24, Y
    2644:	99 81       	ldd	r25, Y+1	; 0x01
    2646:	0e 94 8a 11 	call	0x2314	; 0x2314 <get_fat>
    264a:	ab 01       	movw	r20, r22
    264c:	bc 01       	movw	r22, r24
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    264e:	4f 3f       	cpi	r20, 0xFF	; 255
    2650:	8f ef       	ldi	r24, 0xFF	; 255
    2652:	58 07       	cpc	r21, r24
    2654:	8f ef       	ldi	r24, 0xFF	; 255
    2656:	68 07       	cpc	r22, r24
    2658:	8f ef       	ldi	r24, 0xFF	; 255
    265a:	78 07       	cpc	r23, r24
    265c:	09 f4       	brne	.+2      	; 0x2660 <dir_sdi+0xde>
    265e:	4a c0       	rjmp	.+148    	; 0x26f4 <dir_sdi+0x172>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    2660:	42 30       	cpi	r20, 0x02	; 2
    2662:	51 05       	cpc	r21, r1
    2664:	61 05       	cpc	r22, r1
    2666:	71 05       	cpc	r23, r1
    2668:	08 f4       	brcc	.+2      	; 0x266c <dir_sdi+0xea>
    266a:	46 c0       	rjmp	.+140    	; 0x26f8 <dir_sdi+0x176>
    266c:	e8 81       	ld	r30, Y
    266e:	f9 81       	ldd	r31, Y+1	; 0x01
    2670:	82 8d       	ldd	r24, Z+26	; 0x1a
    2672:	93 8d       	ldd	r25, Z+27	; 0x1b
    2674:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2676:	b5 8d       	ldd	r27, Z+29	; 0x1d
    2678:	48 17       	cp	r20, r24
    267a:	59 07       	cpc	r21, r25
    267c:	6a 07       	cpc	r22, r26
    267e:	7b 07       	cpc	r23, r27
    2680:	e8 f5       	brcc	.+122    	; 0x26fc <dir_sdi+0x17a>
				return FR_INT_ERR;
			idx -= ic;
    2682:	0e 19       	sub	r16, r14
    2684:	1f 09       	sbc	r17, r15
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
    2686:	0e 15       	cp	r16, r14
    2688:	1f 05       	cpc	r17, r15
    268a:	d8 f6       	brcc	.-74     	; 0x2642 <dir_sdi+0xc0>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
    268c:	4a 87       	std	Y+10, r20	; 0x0a
    268e:	5b 87       	std	Y+11, r21	; 0x0b
    2690:	6c 87       	std	Y+12, r22	; 0x0c
    2692:	7d 87       	std	Y+13, r23	; 0x0d
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    2694:	88 81       	ld	r24, Y
    2696:	99 81       	ldd	r25, Y+1	; 0x01
    2698:	0e 94 54 11 	call	0x22a8	; 0x22a8 <clust2sect>
    269c:	ab 01       	movw	r20, r22
    269e:	bc 01       	movw	r22, r24
    26a0:	c8 01       	movw	r24, r16
    26a2:	92 95       	swap	r25
    26a4:	82 95       	swap	r24
    26a6:	8f 70       	andi	r24, 0x0F	; 15
    26a8:	89 27       	eor	r24, r25
    26aa:	9f 70       	andi	r25, 0x0F	; 15
    26ac:	89 27       	eor	r24, r25
    26ae:	a0 e0       	ldi	r26, 0x00	; 0
    26b0:	b0 e0       	ldi	r27, 0x00	; 0
    26b2:	84 0f       	add	r24, r20
    26b4:	95 1f       	adc	r25, r21
    26b6:	a6 1f       	adc	r26, r22
    26b8:	b7 1f       	adc	r27, r23
    26ba:	8e 87       	std	Y+14, r24	; 0x0e
    26bc:	9f 87       	std	Y+15, r25	; 0x0f
    26be:	a8 8b       	std	Y+16, r26	; 0x10
    26c0:	b9 8b       	std	Y+17, r27	; 0x11
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    26c2:	88 81       	ld	r24, Y
    26c4:	99 81       	ldd	r25, Y+1	; 0x01
    26c6:	c2 96       	adiw	r24, 0x32	; 50
    26c8:	0f 70       	andi	r16, 0x0F	; 15
    26ca:	10 70       	andi	r17, 0x00	; 0
    26cc:	00 0f       	add	r16, r16
    26ce:	11 1f       	adc	r17, r17
    26d0:	02 95       	swap	r16
    26d2:	12 95       	swap	r17
    26d4:	10 7f       	andi	r17, 0xF0	; 240
    26d6:	10 27       	eor	r17, r16
    26d8:	00 7f       	andi	r16, 0xF0	; 240
    26da:	10 27       	eor	r17, r16
    26dc:	80 0f       	add	r24, r16
    26de:	91 1f       	adc	r25, r17
    26e0:	9b 8b       	std	Y+19, r25	; 0x13
    26e2:	8a 8b       	std	Y+18, r24	; 0x12

	return FR_OK;	/* Seek succeeded */
    26e4:	80 e0       	ldi	r24, 0x00	; 0
    26e6:	0b c0       	rjmp	.+22     	; 0x26fe <dir_sdi+0x17c>


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
    26e8:	82 e0       	ldi	r24, 0x02	; 2
    26ea:	09 c0       	rjmp	.+18     	; 0x26fe <dir_sdi+0x17c>
    26ec:	82 e0       	ldi	r24, 0x02	; 2
    26ee:	07 c0       	rjmp	.+14     	; 0x26fe <dir_sdi+0x17c>
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
    26f0:	82 e0       	ldi	r24, 0x02	; 2
    26f2:	05 c0       	rjmp	.+10     	; 0x26fe <dir_sdi+0x17c>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    26f4:	81 e0       	ldi	r24, 0x01	; 1
    26f6:	03 c0       	rjmp	.+6      	; 0x26fe <dir_sdi+0x17c>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
    26f8:	82 e0       	ldi	r24, 0x02	; 2
    26fa:	01 c0       	rjmp	.+2      	; 0x26fe <dir_sdi+0x17c>
    26fc:	82 e0       	ldi	r24, 0x02	; 2
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
    26fe:	df 91       	pop	r29
    2700:	cf 91       	pop	r28
    2702:	1f 91       	pop	r17
    2704:	0f 91       	pop	r16
    2706:	ff 90       	pop	r15
    2708:	ef 90       	pop	r14
    270a:	08 95       	ret

0000270c <dir_remove>:
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
	DIR *dj				/* Directory object pointing the entry to be removed */
)
{
    270c:	cf 93       	push	r28
    270e:	df 93       	push	r29
    2710:	ec 01       	movw	r28, r24
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
	}

#else			/* Non LFN configuration */
	res = dir_sdi(dj, dj->index);
    2712:	6c 81       	ldd	r22, Y+4	; 0x04
    2714:	7d 81       	ldd	r23, Y+5	; 0x05
    2716:	0e 94 c1 12 	call	0x2582	; 0x2582 <dir_sdi>
	if (res == FR_OK) {
    271a:	88 23       	and	r24, r24
    271c:	91 f4       	brne	.+36     	; 0x2742 <dir_remove+0x36>
		res = move_window(dj->fs, dj->sect);
    271e:	4e 85       	ldd	r20, Y+14	; 0x0e
    2720:	5f 85       	ldd	r21, Y+15	; 0x0f
    2722:	68 89       	ldd	r22, Y+16	; 0x10
    2724:	79 89       	ldd	r23, Y+17	; 0x11
    2726:	88 81       	ld	r24, Y
    2728:	99 81       	ldd	r25, Y+1	; 0x01
    272a:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
		if (res == FR_OK) {
    272e:	88 23       	and	r24, r24
    2730:	41 f4       	brne	.+16     	; 0x2742 <dir_remove+0x36>
			*dj->dir = DDE;			/* Mark the entry "deleted" */
    2732:	ea 89       	ldd	r30, Y+18	; 0x12
    2734:	fb 89       	ldd	r31, Y+19	; 0x13
    2736:	95 ee       	ldi	r25, 0xE5	; 229
    2738:	90 83       	st	Z, r25
			dj->fs->wflag = 1;
    273a:	e8 81       	ld	r30, Y
    273c:	f9 81       	ldd	r31, Y+1	; 0x01
    273e:	91 e0       	ldi	r25, 0x01	; 1
    2740:	94 83       	std	Z+4, r25	; 0x04
		}
	}
#endif

	return res;
}
    2742:	df 91       	pop	r29
    2744:	cf 91       	pop	r28
    2746:	08 95       	ret

00002748 <put_fat>:
FRESULT put_fat (
	FATFS *fs,	/* File system object */
	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
	DWORD val	/* New value to mark the cluster */
)
{
    2748:	4f 92       	push	r4
    274a:	5f 92       	push	r5
    274c:	6f 92       	push	r6
    274e:	7f 92       	push	r7
    2750:	8f 92       	push	r8
    2752:	9f 92       	push	r9
    2754:	af 92       	push	r10
    2756:	bf 92       	push	r11
    2758:	cf 92       	push	r12
    275a:	df 92       	push	r13
    275c:	ef 92       	push	r14
    275e:	ff 92       	push	r15
    2760:	0f 93       	push	r16
    2762:	1f 93       	push	r17
    2764:	cf 93       	push	r28
    2766:	df 93       	push	r29
    2768:	ec 01       	movw	r28, r24
    276a:	6a 01       	movw	r12, r20
    276c:	7b 01       	movw	r14, r22
    276e:	48 01       	movw	r8, r16
    2770:	59 01       	movw	r10, r18
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    2772:	42 30       	cpi	r20, 0x02	; 2
    2774:	51 05       	cpc	r21, r1
    2776:	61 05       	cpc	r22, r1
    2778:	71 05       	cpc	r23, r1
    277a:	08 f4       	brcc	.+2      	; 0x277e <put_fat+0x36>
    277c:	e0 c0       	rjmp	.+448    	; 0x293e <put_fat+0x1f6>
    277e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2780:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2782:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2784:	bd 8d       	ldd	r27, Y+29	; 0x1d
    2786:	48 17       	cp	r20, r24
    2788:	59 07       	cpc	r21, r25
    278a:	6a 07       	cpc	r22, r26
    278c:	7b 07       	cpc	r23, r27
    278e:	08 f0       	brcs	.+2      	; 0x2792 <put_fat+0x4a>
    2790:	d8 c0       	rjmp	.+432    	; 0x2942 <put_fat+0x1fa>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
    2792:	88 81       	ld	r24, Y
    2794:	82 30       	cpi	r24, 0x02	; 2
    2796:	09 f4       	brne	.+2      	; 0x279a <put_fat+0x52>
    2798:	80 c0       	rjmp	.+256    	; 0x289a <put_fat+0x152>
    279a:	83 30       	cpi	r24, 0x03	; 3
    279c:	09 f4       	brne	.+2      	; 0x27a0 <put_fat+0x58>
    279e:	98 c0       	rjmp	.+304    	; 0x28d0 <put_fat+0x188>
    27a0:	81 30       	cpi	r24, 0x01	; 1
    27a2:	09 f0       	breq	.+2      	; 0x27a6 <put_fat+0x5e>
    27a4:	c8 c0       	rjmp	.+400    	; 0x2936 <put_fat+0x1ee>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
    27a6:	db 01       	movw	r26, r22
    27a8:	ca 01       	movw	r24, r20
    27aa:	b6 95       	lsr	r27
    27ac:	a7 95       	ror	r26
    27ae:	97 95       	ror	r25
    27b0:	87 95       	ror	r24
    27b2:	2c 01       	movw	r4, r24
    27b4:	3d 01       	movw	r6, r26
    27b6:	44 0e       	add	r4, r20
    27b8:	55 1e       	adc	r5, r21
    27ba:	66 1e       	adc	r6, r22
    27bc:	77 1e       	adc	r7, r23
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    27be:	b3 01       	movw	r22, r6
    27c0:	a2 01       	movw	r20, r4
    27c2:	03 2e       	mov	r0, r19
    27c4:	39 e0       	ldi	r19, 0x09	; 9
    27c6:	76 95       	lsr	r23
    27c8:	67 95       	ror	r22
    27ca:	57 95       	ror	r21
    27cc:	47 95       	ror	r20
    27ce:	3a 95       	dec	r19
    27d0:	d1 f7       	brne	.-12     	; 0x27c6 <put_fat+0x7e>
    27d2:	30 2d       	mov	r19, r0
    27d4:	8a a1       	lds	r24, 0x4a
    27d6:	9b a1       	lds	r25, 0x4b
    27d8:	ac a1       	lds	r26, 0x4c
    27da:	bd a1       	lds	r27, 0x4d
    27dc:	48 0f       	add	r20, r24
    27de:	59 1f       	adc	r21, r25
    27e0:	6a 1f       	adc	r22, r26
    27e2:	7b 1f       	adc	r23, r27
    27e4:	ce 01       	movw	r24, r28
    27e6:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
			if (res != FR_OK) break;
    27ea:	88 23       	and	r24, r24
    27ec:	09 f0       	breq	.+2      	; 0x27f0 <put_fat+0xa8>
    27ee:	a4 c0       	rjmp	.+328    	; 0x2938 <put_fat+0x1f0>
			p = &fs->win[bc % SS(fs)];
    27f0:	c2 01       	movw	r24, r4
    27f2:	91 70       	andi	r25, 0x01	; 1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    27f4:	31 e0       	ldi	r19, 0x01	; 1
    27f6:	c3 22       	and	r12, r19
    27f8:	dd 24       	eor	r13, r13
    27fa:	c1 14       	cp	r12, r1
    27fc:	d1 04       	cpc	r13, r1
    27fe:	51 f0       	breq	.+20     	; 0x2814 <put_fat+0xcc>
    2800:	fe 01       	movw	r30, r28
    2802:	e8 0f       	add	r30, r24
    2804:	f9 1f       	adc	r31, r25
    2806:	22 a9       	sts	0x42, r18
    2808:	2f 70       	andi	r18, 0x0F	; 15
    280a:	38 2d       	mov	r19, r8
    280c:	32 95       	swap	r19
    280e:	30 7f       	andi	r19, 0xF0	; 240
    2810:	23 2b       	or	r18, r19
    2812:	01 c0       	rjmp	.+2      	; 0x2816 <put_fat+0xce>
    2814:	28 2d       	mov	r18, r8
    2816:	fe 01       	movw	r30, r28
    2818:	e8 0f       	add	r30, r24
    281a:	f9 1f       	adc	r31, r25
    281c:	22 ab       	sts	0x52, r18
			bc++;
    281e:	08 94       	sec
    2820:	41 1c       	adc	r4, r1
    2822:	51 1c       	adc	r5, r1
    2824:	61 1c       	adc	r6, r1
    2826:	71 1c       	adc	r7, r1
			fs->wflag = 1;
    2828:	81 e0       	ldi	r24, 0x01	; 1
    282a:	8c 83       	std	Y+4, r24	; 0x04
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    282c:	b3 01       	movw	r22, r6
    282e:	a2 01       	movw	r20, r4
    2830:	03 2e       	mov	r0, r19
    2832:	39 e0       	ldi	r19, 0x09	; 9
    2834:	76 95       	lsr	r23
    2836:	67 95       	ror	r22
    2838:	57 95       	ror	r21
    283a:	47 95       	ror	r20
    283c:	3a 95       	dec	r19
    283e:	d1 f7       	brne	.-12     	; 0x2834 <put_fat+0xec>
    2840:	30 2d       	mov	r19, r0
    2842:	8a a1       	lds	r24, 0x4a
    2844:	9b a1       	lds	r25, 0x4b
    2846:	ac a1       	lds	r26, 0x4c
    2848:	bd a1       	lds	r27, 0x4d
    284a:	48 0f       	add	r20, r24
    284c:	59 1f       	adc	r21, r25
    284e:	6a 1f       	adc	r22, r26
    2850:	7b 1f       	adc	r23, r27
    2852:	ce 01       	movw	r24, r28
    2854:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
			if (res != FR_OK) break;
    2858:	88 23       	and	r24, r24
    285a:	09 f0       	breq	.+2      	; 0x285e <put_fat+0x116>
    285c:	6d c0       	rjmp	.+218    	; 0x2938 <put_fat+0x1f0>
			p = &fs->win[bc % SS(fs)];
    285e:	ef ef       	ldi	r30, 0xFF	; 255
    2860:	f1 e0       	ldi	r31, 0x01	; 1
    2862:	4e 22       	and	r4, r30
    2864:	5f 22       	and	r5, r31
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    2866:	c1 14       	cp	r12, r1
    2868:	d1 04       	cpc	r13, r1
    286a:	49 f0       	breq	.+18     	; 0x287e <put_fat+0x136>
    286c:	68 94       	set
    286e:	13 f8       	bld	r1, 3
    2870:	b6 94       	lsr	r11
    2872:	a7 94       	ror	r10
    2874:	97 94       	ror	r9
    2876:	87 94       	ror	r8
    2878:	16 94       	lsr	r1
    287a:	d1 f7       	brne	.-12     	; 0x2870 <put_fat+0x128>
    287c:	09 c0       	rjmp	.+18     	; 0x2890 <put_fat+0x148>
    287e:	fe 01       	movw	r30, r28
    2880:	e4 0d       	add	r30, r4
    2882:	f5 1d       	adc	r31, r5
    2884:	22 a9       	sts	0x42, r18
    2886:	20 7f       	andi	r18, 0xF0	; 240
    2888:	99 2d       	mov	r25, r9
    288a:	9f 70       	andi	r25, 0x0F	; 15
    288c:	82 2e       	mov	r8, r18
    288e:	89 2a       	or	r8, r25
    2890:	4c 0e       	add	r4, r28
    2892:	5d 1e       	adc	r5, r29
    2894:	f2 01       	movw	r30, r4
    2896:	82 aa       	sts	0x92, r24
			break;
    2898:	4f c0       	rjmp	.+158    	; 0x2938 <put_fat+0x1f0>

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    289a:	45 2f       	mov	r20, r21
    289c:	56 2f       	mov	r21, r22
    289e:	67 2f       	mov	r22, r23
    28a0:	77 27       	eor	r23, r23
    28a2:	8a a1       	lds	r24, 0x4a
    28a4:	9b a1       	lds	r25, 0x4b
    28a6:	ac a1       	lds	r26, 0x4c
    28a8:	bd a1       	lds	r27, 0x4d
    28aa:	48 0f       	add	r20, r24
    28ac:	59 1f       	adc	r21, r25
    28ae:	6a 1f       	adc	r22, r26
    28b0:	7b 1f       	adc	r23, r27
    28b2:	ce 01       	movw	r24, r28
    28b4:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
			if (res != FR_OK) break;
    28b8:	88 23       	and	r24, r24
    28ba:	09 f0       	breq	.+2      	; 0x28be <put_fat+0x176>
    28bc:	3d c0       	rjmp	.+122    	; 0x2938 <put_fat+0x1f0>
			p = &fs->win[clst * 2 % SS(fs)];
    28be:	f6 01       	movw	r30, r12
    28c0:	ee 0f       	add	r30, r30
    28c2:	ff 1f       	adc	r31, r31
    28c4:	f1 70       	andi	r31, 0x01	; 1
			ST_WORD(p, (WORD)val);
    28c6:	ec 0f       	add	r30, r28
    28c8:	fd 1f       	adc	r31, r29
    28ca:	82 aa       	sts	0x92, r24
    28cc:	93 aa       	sts	0x93, r25
			break;
    28ce:	34 c0       	rjmp	.+104    	; 0x2938 <put_fat+0x1f0>

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    28d0:	68 94       	set
    28d2:	16 f8       	bld	r1, 6
    28d4:	76 95       	lsr	r23
    28d6:	67 95       	ror	r22
    28d8:	57 95       	ror	r21
    28da:	47 95       	ror	r20
    28dc:	16 94       	lsr	r1
    28de:	d1 f7       	brne	.-12     	; 0x28d4 <put_fat+0x18c>
    28e0:	8a a1       	lds	r24, 0x4a
    28e2:	9b a1       	lds	r25, 0x4b
    28e4:	ac a1       	lds	r26, 0x4c
    28e6:	bd a1       	lds	r27, 0x4d
    28e8:	48 0f       	add	r20, r24
    28ea:	59 1f       	adc	r21, r25
    28ec:	6a 1f       	adc	r22, r26
    28ee:	7b 1f       	adc	r23, r27
    28f0:	ce 01       	movw	r24, r28
    28f2:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
			if (res != FR_OK) break;
    28f6:	88 23       	and	r24, r24
    28f8:	f9 f4       	brne	.+62     	; 0x2938 <put_fat+0x1f0>
			p = &fs->win[clst * 4 % SS(fs)];
    28fa:	96 01       	movw	r18, r12
    28fc:	22 0f       	add	r18, r18
    28fe:	33 1f       	adc	r19, r19
    2900:	22 0f       	add	r18, r18
    2902:	33 1f       	adc	r19, r19
    2904:	31 70       	andi	r19, 0x01	; 1
			val |= LD_DWORD(p) & 0xF0000000;
    2906:	fe 01       	movw	r30, r28
    2908:	e2 0f       	add	r30, r18
    290a:	f3 1f       	adc	r31, r19
    290c:	45 a9       	sts	0x45, r20
    290e:	50 e0       	ldi	r21, 0x00	; 0
    2910:	60 e0       	ldi	r22, 0x00	; 0
    2912:	70 e0       	ldi	r23, 0x00	; 0
    2914:	74 2f       	mov	r23, r20
    2916:	66 27       	eor	r22, r22
    2918:	55 27       	eor	r21, r21
    291a:	44 27       	eor	r20, r20
    291c:	40 70       	andi	r20, 0x00	; 0
    291e:	50 70       	andi	r21, 0x00	; 0
    2920:	60 70       	andi	r22, 0x00	; 0
    2922:	70 7f       	andi	r23, 0xF0	; 240
    2924:	48 29       	or	r20, r8
    2926:	59 29       	or	r21, r9
    2928:	6a 29       	or	r22, r10
    292a:	7b 29       	or	r23, r11
			ST_DWORD(p, val);
    292c:	42 ab       	sts	0x52, r20
    292e:	53 ab       	sts	0x53, r21
    2930:	64 ab       	sts	0x54, r22
    2932:	75 ab       	sts	0x55, r23
			break;
    2934:	01 c0       	rjmp	.+2      	; 0x2938 <put_fat+0x1f0>

		default :
			res = FR_INT_ERR;
    2936:	82 e0       	ldi	r24, 0x02	; 2
		}
		fs->wflag = 1;
    2938:	91 e0       	ldi	r25, 0x01	; 1
    293a:	9c 83       	std	Y+4, r25	; 0x04
    293c:	03 c0       	rjmp	.+6      	; 0x2944 <put_fat+0x1fc>
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
    293e:	82 e0       	ldi	r24, 0x02	; 2
    2940:	01 c0       	rjmp	.+2      	; 0x2944 <put_fat+0x1fc>
    2942:	82 e0       	ldi	r24, 0x02	; 2
		}
		fs->wflag = 1;
	}

	return res;
}
    2944:	df 91       	pop	r29
    2946:	cf 91       	pop	r28
    2948:	1f 91       	pop	r17
    294a:	0f 91       	pop	r16
    294c:	ff 90       	pop	r15
    294e:	ef 90       	pop	r14
    2950:	df 90       	pop	r13
    2952:	cf 90       	pop	r12
    2954:	bf 90       	pop	r11
    2956:	af 90       	pop	r10
    2958:	9f 90       	pop	r9
    295a:	8f 90       	pop	r8
    295c:	7f 90       	pop	r7
    295e:	6f 90       	pop	r6
    2960:	5f 90       	pop	r5
    2962:	4f 90       	pop	r4
    2964:	08 95       	ret

00002966 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
    2966:	2f 92       	push	r2
    2968:	3f 92       	push	r3
    296a:	4f 92       	push	r4
    296c:	5f 92       	push	r5
    296e:	6f 92       	push	r6
    2970:	7f 92       	push	r7
    2972:	8f 92       	push	r8
    2974:	9f 92       	push	r9
    2976:	af 92       	push	r10
    2978:	bf 92       	push	r11
    297a:	cf 92       	push	r12
    297c:	df 92       	push	r13
    297e:	ef 92       	push	r14
    2980:	ff 92       	push	r15
    2982:	0f 93       	push	r16
    2984:	1f 93       	push	r17
    2986:	cf 93       	push	r28
    2988:	df 93       	push	r29
    298a:	00 d0       	rcall	.+0      	; 0x298c <create_chain+0x26>
    298c:	00 d0       	rcall	.+0      	; 0x298e <create_chain+0x28>
    298e:	cd b7       	in	r28, 0x3d	; 61
    2990:	de b7       	in	r29, 0x3e	; 62
    2992:	1c 01       	movw	r2, r24
    2994:	49 83       	std	Y+1, r20	; 0x01
    2996:	5a 83       	std	Y+2, r21	; 0x02
    2998:	6b 83       	std	Y+3, r22	; 0x03
    299a:	7c 83       	std	Y+4, r23	; 0x04
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
    299c:	41 15       	cp	r20, r1
    299e:	51 05       	cpc	r21, r1
    29a0:	61 05       	cpc	r22, r1
    29a2:	71 05       	cpc	r23, r1
    29a4:	c1 f4       	brne	.+48     	; 0x29d6 <create_chain+0x70>
		scl = fs->last_clust;			/* Get suggested start point */
    29a6:	dc 01       	movw	r26, r24
    29a8:	1a 96       	adiw	r26, 0x0a	; 10
    29aa:	8d 90       	ld	r8, X+
    29ac:	9d 90       	ld	r9, X+
    29ae:	ad 90       	ld	r10, X+
    29b0:	bc 90       	ld	r11, X
    29b2:	1d 97       	sbiw	r26, 0x0d	; 13
		if (!scl || scl >= fs->n_fatent) scl = 1;
    29b4:	81 14       	cp	r8, r1
    29b6:	91 04       	cpc	r9, r1
    29b8:	a1 04       	cpc	r10, r1
    29ba:	b1 04       	cpc	r11, r1
    29bc:	51 f1       	breq	.+84     	; 0x2a12 <create_chain+0xac>
    29be:	5a 96       	adiw	r26, 0x1a	; 26
    29c0:	8d 91       	ld	r24, X+
    29c2:	9d 91       	ld	r25, X+
    29c4:	0d 90       	ld	r0, X+
    29c6:	bc 91       	ld	r27, X
    29c8:	a0 2d       	mov	r26, r0
    29ca:	88 16       	cp	r8, r24
    29cc:	99 06       	cpc	r9, r25
    29ce:	aa 06       	cpc	r10, r26
    29d0:	bb 06       	cpc	r11, r27
    29d2:	20 f5       	brcc	.+72     	; 0x2a1c <create_chain+0xb6>
    29d4:	27 c0       	rjmp	.+78     	; 0x2a24 <create_chain+0xbe>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
    29d6:	49 81       	ldd	r20, Y+1	; 0x01
    29d8:	5a 81       	ldd	r21, Y+2	; 0x02
    29da:	6b 81       	ldd	r22, Y+3	; 0x03
    29dc:	7c 81       	ldd	r23, Y+4	; 0x04
    29de:	0e 94 8a 11 	call	0x2314	; 0x2314 <get_fat>
    29e2:	8b 01       	movw	r16, r22
    29e4:	9c 01       	movw	r18, r24
		if (cs < 2) return 1;			/* It is an invalid cluster */
    29e6:	62 30       	cpi	r22, 0x02	; 2
    29e8:	71 05       	cpc	r23, r1
    29ea:	81 05       	cpc	r24, r1
    29ec:	91 05       	cpc	r25, r1
    29ee:	08 f4       	brcc	.+2      	; 0x29f2 <create_chain+0x8c>
    29f0:	ad c0       	rjmp	.+346    	; 0x2b4c <create_chain+0x1e6>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    29f2:	f1 01       	movw	r30, r2
    29f4:	82 8d       	ldd	r24, Z+26	; 0x1a
    29f6:	93 8d       	ldd	r25, Z+27	; 0x1b
    29f8:	a4 8d       	ldd	r26, Z+28	; 0x1c
    29fa:	b5 8d       	ldd	r27, Z+29	; 0x1d
    29fc:	08 17       	cp	r16, r24
    29fe:	19 07       	cpc	r17, r25
    2a00:	2a 07       	cpc	r18, r26
    2a02:	3b 07       	cpc	r19, r27
    2a04:	08 f4       	brcc	.+2      	; 0x2a08 <create_chain+0xa2>
    2a06:	b6 c0       	rjmp	.+364    	; 0x2b74 <create_chain+0x20e>
		scl = clst;
    2a08:	89 80       	ldd	r8, Y+1	; 0x01
    2a0a:	9a 80       	ldd	r9, Y+2	; 0x02
    2a0c:	ab 80       	ldd	r10, Y+3	; 0x03
    2a0e:	bc 80       	ldd	r11, Y+4	; 0x04
    2a10:	09 c0       	rjmp	.+18     	; 0x2a24 <create_chain+0xbe>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
    2a12:	88 24       	eor	r8, r8
    2a14:	99 24       	eor	r9, r9
    2a16:	54 01       	movw	r10, r8
    2a18:	83 94       	inc	r8
    2a1a:	04 c0       	rjmp	.+8      	; 0x2a24 <create_chain+0xbe>
    2a1c:	88 24       	eor	r8, r8
    2a1e:	99 24       	eor	r9, r9
    2a20:	54 01       	movw	r10, r8
    2a22:	83 94       	inc	r8
		if (cs < 2) return 1;			/* It is an invalid cluster */
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
    2a24:	75 01       	movw	r14, r10
    2a26:	64 01       	movw	r12, r8
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
    2a28:	44 24       	eor	r4, r4
    2a2a:	55 24       	eor	r5, r5
    2a2c:	32 01       	movw	r6, r4
    2a2e:	68 94       	set
    2a30:	41 f8       	bld	r4, 1
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
    2a32:	08 94       	sec
    2a34:	c1 1c       	adc	r12, r1
    2a36:	d1 1c       	adc	r13, r1
    2a38:	e1 1c       	adc	r14, r1
    2a3a:	f1 1c       	adc	r15, r1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
    2a3c:	f1 01       	movw	r30, r2
    2a3e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a40:	93 8d       	ldd	r25, Z+27	; 0x1b
    2a42:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2a44:	b5 8d       	ldd	r27, Z+29	; 0x1d
    2a46:	c8 16       	cp	r12, r24
    2a48:	d9 06       	cpc	r13, r25
    2a4a:	ea 06       	cpc	r14, r26
    2a4c:	fb 06       	cpc	r15, r27
    2a4e:	48 f0       	brcs	.+18     	; 0x2a62 <create_chain+0xfc>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
    2a50:	f2 e0       	ldi	r31, 0x02	; 2
    2a52:	8f 16       	cp	r8, r31
    2a54:	91 04       	cpc	r9, r1
    2a56:	a1 04       	cpc	r10, r1
    2a58:	b1 04       	cpc	r11, r1
    2a5a:	08 f4       	brcc	.+2      	; 0x2a5e <create_chain+0xf8>
    2a5c:	7c c0       	rjmp	.+248    	; 0x2b56 <create_chain+0x1f0>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
    2a5e:	73 01       	movw	r14, r6
    2a60:	62 01       	movw	r12, r4
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
    2a62:	c1 01       	movw	r24, r2
    2a64:	b7 01       	movw	r22, r14
    2a66:	a6 01       	movw	r20, r12
    2a68:	0e 94 8a 11 	call	0x2314	; 0x2314 <get_fat>
    2a6c:	8b 01       	movw	r16, r22
    2a6e:	9c 01       	movw	r18, r24
		if (cs == 0) break;				/* Found a free cluster */
    2a70:	61 15       	cp	r22, r1
    2a72:	71 05       	cpc	r23, r1
    2a74:	81 05       	cpc	r24, r1
    2a76:	91 05       	cpc	r25, r1
    2a78:	a9 f0       	breq	.+42     	; 0x2aa4 <create_chain+0x13e>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    2a7a:	0f 3f       	cpi	r16, 0xFF	; 255
    2a7c:	8f ef       	ldi	r24, 0xFF	; 255
    2a7e:	18 07       	cpc	r17, r24
    2a80:	8f ef       	ldi	r24, 0xFF	; 255
    2a82:	28 07       	cpc	r18, r24
    2a84:	8f ef       	ldi	r24, 0xFF	; 255
    2a86:	38 07       	cpc	r19, r24
    2a88:	09 f4       	brne	.+2      	; 0x2a8c <create_chain+0x126>
    2a8a:	74 c0       	rjmp	.+232    	; 0x2b74 <create_chain+0x20e>
    2a8c:	01 30       	cpi	r16, 0x01	; 1
    2a8e:	11 05       	cpc	r17, r1
    2a90:	21 05       	cpc	r18, r1
    2a92:	31 05       	cpc	r19, r1
    2a94:	09 f4       	brne	.+2      	; 0x2a98 <create_chain+0x132>
    2a96:	6e c0       	rjmp	.+220    	; 0x2b74 <create_chain+0x20e>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
    2a98:	c8 14       	cp	r12, r8
    2a9a:	d9 04       	cpc	r13, r9
    2a9c:	ea 04       	cpc	r14, r10
    2a9e:	fb 04       	cpc	r15, r11
    2aa0:	41 f6       	brne	.-112    	; 0x2a32 <create_chain+0xcc>
    2aa2:	5d c0       	rjmp	.+186    	; 0x2b5e <create_chain+0x1f8>
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
    2aa4:	8c 2c       	mov	r8, r12
    2aa6:	4d 2c       	mov	r4, r13
    2aa8:	be 2c       	mov	r11, r14
    2aaa:	af 2c       	mov	r10, r15
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    2aac:	c1 01       	movw	r24, r2
    2aae:	4c 2d       	mov	r20, r12
    2ab0:	5d 2d       	mov	r21, r13
    2ab2:	6e 2d       	mov	r22, r14
    2ab4:	7f 2d       	mov	r23, r15
    2ab6:	0f ef       	ldi	r16, 0xFF	; 255
    2ab8:	1f ef       	ldi	r17, 0xFF	; 255
    2aba:	2f ef       	ldi	r18, 0xFF	; 255
    2abc:	3f e0       	ldi	r19, 0x0F	; 15
    2abe:	0e 94 a4 13 	call	0x2748	; 0x2748 <put_fat>
	if (res == FR_OK && clst != 0) {
    2ac2:	88 23       	and	r24, r24
    2ac4:	e9 f5       	brne	.+122    	; 0x2b40 <create_chain+0x1da>
    2ac6:	89 81       	ldd	r24, Y+1	; 0x01
    2ac8:	9a 81       	ldd	r25, Y+2	; 0x02
    2aca:	ab 81       	ldd	r26, Y+3	; 0x03
    2acc:	bc 81       	ldd	r27, Y+4	; 0x04
    2ace:	00 97       	sbiw	r24, 0x00	; 0
    2ad0:	a1 05       	cpc	r26, r1
    2ad2:	b1 05       	cpc	r27, r1
    2ad4:	69 f0       	breq	.+26     	; 0x2af0 <create_chain+0x18a>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    2ad6:	c1 01       	movw	r24, r2
    2ad8:	49 81       	ldd	r20, Y+1	; 0x01
    2ada:	5a 81       	ldd	r21, Y+2	; 0x02
    2adc:	6b 81       	ldd	r22, Y+3	; 0x03
    2ade:	7c 81       	ldd	r23, Y+4	; 0x04
    2ae0:	0c 2d       	mov	r16, r12
    2ae2:	1d 2d       	mov	r17, r13
    2ae4:	2e 2d       	mov	r18, r14
    2ae6:	3f 2d       	mov	r19, r15
    2ae8:	0e 94 a4 13 	call	0x2748	; 0x2748 <put_fat>
	}
	if (res == FR_OK) {
    2aec:	88 23       	and	r24, r24
    2aee:	41 f5       	brne	.+80     	; 0x2b40 <create_chain+0x1da>
		fs->last_clust = ncl;			/* Update FSINFO */
    2af0:	d1 01       	movw	r26, r2
    2af2:	1a 96       	adiw	r26, 0x0a	; 10
    2af4:	8c 92       	st	X, r8
    2af6:	1a 97       	sbiw	r26, 0x0a	; 10
    2af8:	1b 96       	adiw	r26, 0x0b	; 11
    2afa:	4c 92       	st	X, r4
    2afc:	1b 97       	sbiw	r26, 0x0b	; 11
    2afe:	1c 96       	adiw	r26, 0x0c	; 12
    2b00:	bc 92       	st	X, r11
    2b02:	1c 97       	sbiw	r26, 0x0c	; 12
    2b04:	1d 96       	adiw	r26, 0x0d	; 13
    2b06:	ac 92       	st	X, r10
    2b08:	1d 97       	sbiw	r26, 0x0d	; 13
		if (fs->free_clust != 0xFFFFFFFF) {
    2b0a:	1e 96       	adiw	r26, 0x0e	; 14
    2b0c:	8d 91       	ld	r24, X+
    2b0e:	9d 91       	ld	r25, X+
    2b10:	0d 90       	ld	r0, X+
    2b12:	bc 91       	ld	r27, X
    2b14:	a0 2d       	mov	r26, r0
    2b16:	8f 3f       	cpi	r24, 0xFF	; 255
    2b18:	ef ef       	ldi	r30, 0xFF	; 255
    2b1a:	9e 07       	cpc	r25, r30
    2b1c:	ef ef       	ldi	r30, 0xFF	; 255
    2b1e:	ae 07       	cpc	r26, r30
    2b20:	ef ef       	ldi	r30, 0xFF	; 255
    2b22:	be 07       	cpc	r27, r30
    2b24:	01 f1       	breq	.+64     	; 0x2b66 <create_chain+0x200>
			fs->free_clust--;
    2b26:	01 97       	sbiw	r24, 0x01	; 1
    2b28:	a1 09       	sbc	r26, r1
    2b2a:	b1 09       	sbc	r27, r1
    2b2c:	f1 01       	movw	r30, r2
    2b2e:	86 87       	std	Z+14, r24	; 0x0e
    2b30:	97 87       	std	Z+15, r25	; 0x0f
    2b32:	a0 8b       	std	Z+16, r26	; 0x10
    2b34:	b1 8b       	std	Z+17, r27	; 0x11
			fs->fsi_flag = 1;
    2b36:	81 e0       	ldi	r24, 0x01	; 1
    2b38:	85 83       	std	Z+5, r24	; 0x05
    2b3a:	97 01       	movw	r18, r14
    2b3c:	86 01       	movw	r16, r12
    2b3e:	1a c0       	rjmp	.+52     	; 0x2b74 <create_chain+0x20e>
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    2b40:	81 30       	cpi	r24, 0x01	; 1
    2b42:	a1 f4       	brne	.+40     	; 0x2b6c <create_chain+0x206>
    2b44:	0f ef       	ldi	r16, 0xFF	; 255
    2b46:	1f ef       	ldi	r17, 0xFF	; 255
    2b48:	98 01       	movw	r18, r16
    2b4a:	14 c0       	rjmp	.+40     	; 0x2b74 <create_chain+0x20e>
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* It is an invalid cluster */
    2b4c:	01 e0       	ldi	r16, 0x01	; 1
    2b4e:	10 e0       	ldi	r17, 0x00	; 0
    2b50:	20 e0       	ldi	r18, 0x00	; 0
    2b52:	30 e0       	ldi	r19, 0x00	; 0
    2b54:	0f c0       	rjmp	.+30     	; 0x2b74 <create_chain+0x20e>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
    2b56:	00 e0       	ldi	r16, 0x00	; 0
    2b58:	10 e0       	ldi	r17, 0x00	; 0
    2b5a:	98 01       	movw	r18, r16
    2b5c:	0b c0       	rjmp	.+22     	; 0x2b74 <create_chain+0x20e>
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
    2b5e:	00 e0       	ldi	r16, 0x00	; 0
    2b60:	10 e0       	ldi	r17, 0x00	; 0
    2b62:	98 01       	movw	r18, r16
    2b64:	07 c0       	rjmp	.+14     	; 0x2b74 <create_chain+0x20e>
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
    2b66:	97 01       	movw	r18, r14
    2b68:	86 01       	movw	r16, r12
    2b6a:	04 c0       	rjmp	.+8      	; 0x2b74 <create_chain+0x20e>
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    2b6c:	01 e0       	ldi	r16, 0x01	; 1
    2b6e:	10 e0       	ldi	r17, 0x00	; 0
    2b70:	20 e0       	ldi	r18, 0x00	; 0
    2b72:	30 e0       	ldi	r19, 0x00	; 0
	}

	return ncl;		/* Return new cluster number or error code */
}
    2b74:	60 2f       	mov	r22, r16
    2b76:	71 2f       	mov	r23, r17
    2b78:	82 2f       	mov	r24, r18
    2b7a:	93 2f       	mov	r25, r19
    2b7c:	0f 90       	pop	r0
    2b7e:	0f 90       	pop	r0
    2b80:	0f 90       	pop	r0
    2b82:	0f 90       	pop	r0
    2b84:	df 91       	pop	r29
    2b86:	cf 91       	pop	r28
    2b88:	1f 91       	pop	r17
    2b8a:	0f 91       	pop	r16
    2b8c:	ff 90       	pop	r15
    2b8e:	ef 90       	pop	r14
    2b90:	df 90       	pop	r13
    2b92:	cf 90       	pop	r12
    2b94:	bf 90       	pop	r11
    2b96:	af 90       	pop	r10
    2b98:	9f 90       	pop	r9
    2b9a:	8f 90       	pop	r8
    2b9c:	7f 90       	pop	r7
    2b9e:	6f 90       	pop	r6
    2ba0:	5f 90       	pop	r5
    2ba2:	4f 90       	pop	r4
    2ba4:	3f 90       	pop	r3
    2ba6:	2f 90       	pop	r2
    2ba8:	08 95       	ret

00002baa <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
    2baa:	8f 92       	push	r8
    2bac:	9f 92       	push	r9
    2bae:	af 92       	push	r10
    2bb0:	bf 92       	push	r11
    2bb2:	cf 92       	push	r12
    2bb4:	df 92       	push	r13
    2bb6:	ef 92       	push	r14
    2bb8:	ff 92       	push	r15
    2bba:	0f 93       	push	r16
    2bbc:	1f 93       	push	r17
    2bbe:	cf 93       	push	r28
    2bc0:	df 93       	push	r29
    2bc2:	8c 01       	movw	r16, r24
    2bc4:	eb 01       	movw	r28, r22
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
    2bc6:	dc 01       	movw	r26, r24
    2bc8:	14 96       	adiw	r26, 0x04	; 4
    2bca:	ed 90       	ld	r14, X+
    2bcc:	fc 90       	ld	r15, X
    2bce:	15 97       	sbiw	r26, 0x05	; 5
    2bd0:	08 94       	sec
    2bd2:	e1 1c       	adc	r14, r1
    2bd4:	f1 1c       	adc	r15, r1
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    2bd6:	e1 14       	cp	r14, r1
    2bd8:	f1 04       	cpc	r15, r1
    2bda:	09 f4       	brne	.+2      	; 0x2bde <dir_next+0x34>
    2bdc:	0b c1       	rjmp	.+534    	; 0x2df4 <dir_next+0x24a>
    2bde:	1e 96       	adiw	r26, 0x0e	; 14
    2be0:	8d 91       	ld	r24, X+
    2be2:	9d 91       	ld	r25, X+
    2be4:	0d 90       	ld	r0, X+
    2be6:	bc 91       	ld	r27, X
    2be8:	a0 2d       	mov	r26, r0
    2bea:	00 97       	sbiw	r24, 0x00	; 0
    2bec:	a1 05       	cpc	r26, r1
    2bee:	b1 05       	cpc	r27, r1
    2bf0:	09 f4       	brne	.+2      	; 0x2bf4 <dir_next+0x4a>
    2bf2:	02 c1       	rjmp	.+516    	; 0x2df8 <dir_next+0x24e>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    2bf4:	0f 2e       	mov	r0, r31
    2bf6:	ff e0       	ldi	r31, 0x0F	; 15
    2bf8:	cf 2e       	mov	r12, r31
    2bfa:	dd 24       	eor	r13, r13
    2bfc:	f0 2d       	mov	r31, r0
    2bfe:	ce 20       	and	r12, r14
    2c00:	df 20       	and	r13, r15
    2c02:	c1 14       	cp	r12, r1
    2c04:	d1 04       	cpc	r13, r1
    2c06:	09 f0       	breq	.+2      	; 0x2c0a <dir_next+0x60>
    2c08:	da c0       	rjmp	.+436    	; 0x2dbe <dir_next+0x214>
		dj->sect++;					/* Next sector */
    2c0a:	01 96       	adiw	r24, 0x01	; 1
    2c0c:	a1 1d       	adc	r26, r1
    2c0e:	b1 1d       	adc	r27, r1
    2c10:	f8 01       	movw	r30, r16
    2c12:	86 87       	std	Z+14, r24	; 0x0e
    2c14:	97 87       	std	Z+15, r25	; 0x0f
    2c16:	a0 8b       	std	Z+16, r26	; 0x10
    2c18:	b1 8b       	std	Z+17, r27	; 0x11

		if (dj->clust == 0) {	/* Static table */
    2c1a:	42 85       	ldd	r20, Z+10	; 0x0a
    2c1c:	53 85       	ldd	r21, Z+11	; 0x0b
    2c1e:	64 85       	ldd	r22, Z+12	; 0x0c
    2c20:	75 85       	ldd	r23, Z+13	; 0x0d
    2c22:	41 15       	cp	r20, r1
    2c24:	51 05       	cpc	r21, r1
    2c26:	61 05       	cpc	r22, r1
    2c28:	71 05       	cpc	r23, r1
    2c2a:	51 f4       	brne	.+20     	; 0x2c40 <dir_next+0x96>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    2c2c:	01 90       	ld	r0, Z+
    2c2e:	f0 81       	ld	r31, Z
    2c30:	e0 2d       	mov	r30, r0
    2c32:	80 85       	ldd	r24, Z+8	; 0x08
    2c34:	91 85       	ldd	r25, Z+9	; 0x09
    2c36:	e8 16       	cp	r14, r24
    2c38:	f9 06       	cpc	r15, r25
    2c3a:	08 f0       	brcs	.+2      	; 0x2c3e <dir_next+0x94>
    2c3c:	df c0       	rjmp	.+446    	; 0x2dfc <dir_next+0x252>
    2c3e:	bf c0       	rjmp	.+382    	; 0x2dbe <dir_next+0x214>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    2c40:	01 90       	ld	r0, Z+
    2c42:	f0 81       	ld	r31, Z
    2c44:	e0 2d       	mov	r30, r0
    2c46:	82 81       	ldd	r24, Z+2	; 0x02
    2c48:	90 e0       	ldi	r25, 0x00	; 0
    2c4a:	01 97       	sbiw	r24, 0x01	; 1
    2c4c:	97 01       	movw	r18, r14
    2c4e:	32 95       	swap	r19
    2c50:	22 95       	swap	r18
    2c52:	2f 70       	andi	r18, 0x0F	; 15
    2c54:	23 27       	eor	r18, r19
    2c56:	3f 70       	andi	r19, 0x0F	; 15
    2c58:	23 27       	eor	r18, r19
    2c5a:	82 23       	and	r24, r18
    2c5c:	93 23       	and	r25, r19
    2c5e:	00 97       	sbiw	r24, 0x00	; 0
    2c60:	09 f0       	breq	.+2      	; 0x2c64 <dir_next+0xba>
    2c62:	ad c0       	rjmp	.+346    	; 0x2dbe <dir_next+0x214>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    2c64:	cf 01       	movw	r24, r30
    2c66:	0e 94 8a 11 	call	0x2314	; 0x2314 <get_fat>
    2c6a:	4b 01       	movw	r8, r22
    2c6c:	5c 01       	movw	r10, r24
				if (clst <= 1) return FR_INT_ERR;
    2c6e:	62 30       	cpi	r22, 0x02	; 2
    2c70:	71 05       	cpc	r23, r1
    2c72:	81 05       	cpc	r24, r1
    2c74:	91 05       	cpc	r25, r1
    2c76:	08 f4       	brcc	.+2      	; 0x2c7a <dir_next+0xd0>
    2c78:	c3 c0       	rjmp	.+390    	; 0x2e00 <dir_next+0x256>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2c7a:	6f 3f       	cpi	r22, 0xFF	; 255
    2c7c:	ef ef       	ldi	r30, 0xFF	; 255
    2c7e:	7e 07       	cpc	r23, r30
    2c80:	ef ef       	ldi	r30, 0xFF	; 255
    2c82:	8e 07       	cpc	r24, r30
    2c84:	ef ef       	ldi	r30, 0xFF	; 255
    2c86:	9e 07       	cpc	r25, r30
    2c88:	09 f4       	brne	.+2      	; 0x2c8c <dir_next+0xe2>
    2c8a:	bc c0       	rjmp	.+376    	; 0x2e04 <dir_next+0x25a>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    2c8c:	d8 01       	movw	r26, r16
    2c8e:	ed 91       	ld	r30, X+
    2c90:	fc 91       	ld	r31, X
    2c92:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c94:	93 8d       	ldd	r25, Z+27	; 0x1b
    2c96:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2c98:	b5 8d       	ldd	r27, Z+29	; 0x1d
    2c9a:	88 16       	cp	r8, r24
    2c9c:	99 06       	cpc	r9, r25
    2c9e:	aa 06       	cpc	r10, r26
    2ca0:	bb 06       	cpc	r11, r27
    2ca2:	08 f4       	brcc	.+2      	; 0x2ca6 <dir_next+0xfc>
    2ca4:	7a c0       	rjmp	.+244    	; 0x2d9a <dir_next+0x1f0>
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    2ca6:	20 97       	sbiw	r28, 0x00	; 0
    2ca8:	09 f4       	brne	.+2      	; 0x2cac <dir_next+0x102>
    2caa:	ae c0       	rjmp	.+348    	; 0x2e08 <dir_next+0x25e>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
    2cac:	d8 01       	movw	r26, r16
    2cae:	1a 96       	adiw	r26, 0x0a	; 10
    2cb0:	4d 91       	ld	r20, X+
    2cb2:	5d 91       	ld	r21, X+
    2cb4:	6d 91       	ld	r22, X+
    2cb6:	7c 91       	ld	r23, X
    2cb8:	1d 97       	sbiw	r26, 0x0d	; 13
    2cba:	cf 01       	movw	r24, r30
    2cbc:	0e 94 b3 14 	call	0x2966	; 0x2966 <create_chain>
    2cc0:	4b 01       	movw	r8, r22
    2cc2:	5c 01       	movw	r10, r24
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    2cc4:	61 15       	cp	r22, r1
    2cc6:	71 05       	cpc	r23, r1
    2cc8:	81 05       	cpc	r24, r1
    2cca:	91 05       	cpc	r25, r1
    2ccc:	09 f4       	brne	.+2      	; 0x2cd0 <dir_next+0x126>
    2cce:	9e c0       	rjmp	.+316    	; 0x2e0c <dir_next+0x262>
					if (clst == 1) return FR_INT_ERR;
    2cd0:	61 30       	cpi	r22, 0x01	; 1
    2cd2:	71 05       	cpc	r23, r1
    2cd4:	81 05       	cpc	r24, r1
    2cd6:	91 05       	cpc	r25, r1
    2cd8:	09 f4       	brne	.+2      	; 0x2cdc <dir_next+0x132>
    2cda:	9a c0       	rjmp	.+308    	; 0x2e10 <dir_next+0x266>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2cdc:	6f 3f       	cpi	r22, 0xFF	; 255
    2cde:	ef ef       	ldi	r30, 0xFF	; 255
    2ce0:	7e 07       	cpc	r23, r30
    2ce2:	ef ef       	ldi	r30, 0xFF	; 255
    2ce4:	8e 07       	cpc	r24, r30
    2ce6:	ef ef       	ldi	r30, 0xFF	; 255
    2ce8:	9e 07       	cpc	r25, r30
    2cea:	09 f4       	brne	.+2      	; 0x2cee <dir_next+0x144>
    2cec:	93 c0       	rjmp	.+294    	; 0x2e14 <dir_next+0x26a>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    2cee:	d8 01       	movw	r26, r16
    2cf0:	8d 91       	ld	r24, X+
    2cf2:	9c 91       	ld	r25, X
    2cf4:	40 e0       	ldi	r20, 0x00	; 0
    2cf6:	50 e0       	ldi	r21, 0x00	; 0
    2cf8:	ba 01       	movw	r22, r20
    2cfa:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
    2cfe:	88 23       	and	r24, r24
    2d00:	09 f0       	breq	.+2      	; 0x2d04 <dir_next+0x15a>
    2d02:	8a c0       	rjmp	.+276    	; 0x2e18 <dir_next+0x26e>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
    2d04:	f8 01       	movw	r30, r16
    2d06:	80 81       	ld	r24, Z
    2d08:	91 81       	ldd	r25, Z+1	; 0x01
    2d0a:	c2 96       	adiw	r24, 0x32	; 50
    2d0c:	60 e0       	ldi	r22, 0x00	; 0
    2d0e:	70 e0       	ldi	r23, 0x00	; 0
    2d10:	20 e0       	ldi	r18, 0x00	; 0
    2d12:	32 e0       	ldi	r19, 0x02	; 2
    2d14:	40 e0       	ldi	r20, 0x00	; 0
    2d16:	50 e0       	ldi	r21, 0x00	; 0
    2d18:	0e 94 5f 0a 	call	0x14be	; 0x14be <mem_set>
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    2d1c:	d8 01       	movw	r26, r16
    2d1e:	cd 91       	ld	r28, X+
    2d20:	dc 91       	ld	r29, X
    2d22:	ce 01       	movw	r24, r28
    2d24:	b5 01       	movw	r22, r10
    2d26:	a4 01       	movw	r20, r8
    2d28:	0e 94 54 11 	call	0x22a8	; 0x22a8 <clust2sect>
    2d2c:	dc 01       	movw	r26, r24
    2d2e:	cb 01       	movw	r24, r22
    2d30:	8e a7       	lds	r24, 0x7e
    2d32:	9f a7       	lds	r25, 0x7f
    2d34:	a8 ab       	sts	0x58, r26
    2d36:	b9 ab       	sts	0x59, r27
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2d38:	c0 e0       	ldi	r28, 0x00	; 0
						dj->fs->wflag = 1;
    2d3a:	d1 e0       	ldi	r29, 0x01	; 1
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2d3c:	1b c0       	rjmp	.+54     	; 0x2d74 <dir_next+0x1ca>
						dj->fs->wflag = 1;
    2d3e:	d4 83       	std	Z+4, r29	; 0x04
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    2d40:	f8 01       	movw	r30, r16
    2d42:	80 81       	ld	r24, Z
    2d44:	91 81       	ldd	r25, Z+1	; 0x01
    2d46:	40 e0       	ldi	r20, 0x00	; 0
    2d48:	50 e0       	ldi	r21, 0x00	; 0
    2d4a:	ba 01       	movw	r22, r20
    2d4c:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
    2d50:	88 23       	and	r24, r24
    2d52:	09 f0       	breq	.+2      	; 0x2d56 <dir_next+0x1ac>
    2d54:	63 c0       	rjmp	.+198    	; 0x2e1c <dir_next+0x272>
						dj->fs->winsect++;
    2d56:	d8 01       	movw	r26, r16
    2d58:	ed 91       	ld	r30, X+
    2d5a:	fc 91       	ld	r31, X
    2d5c:	86 a5       	lds	r24, 0x66
    2d5e:	97 a5       	lds	r25, 0x67
    2d60:	a0 a9       	sts	0x40, r26
    2d62:	b1 a9       	sts	0x41, r27
    2d64:	01 96       	adiw	r24, 0x01	; 1
    2d66:	a1 1d       	adc	r26, r1
    2d68:	b1 1d       	adc	r27, r1
    2d6a:	86 a7       	lds	r24, 0x76
    2d6c:	97 a7       	lds	r25, 0x77
    2d6e:	a0 ab       	sts	0x50, r26
    2d70:	b1 ab       	sts	0x51, r27
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2d72:	cf 5f       	subi	r28, 0xFF	; 255
    2d74:	d8 01       	movw	r26, r16
    2d76:	ed 91       	ld	r30, X+
    2d78:	fc 91       	ld	r31, X
    2d7a:	11 97       	sbiw	r26, 0x01	; 1
    2d7c:	82 81       	ldd	r24, Z+2	; 0x02
    2d7e:	c8 17       	cp	r28, r24
    2d80:	f0 f2       	brcs	.-68     	; 0x2d3e <dir_next+0x194>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
    2d82:	86 a5       	lds	r24, 0x66
    2d84:	97 a5       	lds	r25, 0x67
    2d86:	a0 a9       	sts	0x40, r26
    2d88:	b1 a9       	sts	0x41, r27
    2d8a:	8c 1b       	sub	r24, r28
    2d8c:	91 09       	sbc	r25, r1
    2d8e:	a1 09       	sbc	r26, r1
    2d90:	b1 09       	sbc	r27, r1
    2d92:	86 a7       	lds	r24, 0x76
    2d94:	97 a7       	lds	r25, 0x77
    2d96:	a0 ab       	sts	0x50, r26
    2d98:	b1 ab       	sts	0x51, r27
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
    2d9a:	f8 01       	movw	r30, r16
    2d9c:	82 86       	std	Z+10, r8	; 0x0a
    2d9e:	93 86       	std	Z+11, r9	; 0x0b
    2da0:	a4 86       	std	Z+12, r10	; 0x0c
    2da2:	b5 86       	std	Z+13, r11	; 0x0d
				dj->sect = clust2sect(dj->fs, clst);
    2da4:	80 81       	ld	r24, Z
    2da6:	91 81       	ldd	r25, Z+1	; 0x01
    2da8:	b5 01       	movw	r22, r10
    2daa:	a4 01       	movw	r20, r8
    2dac:	0e 94 54 11 	call	0x22a8	; 0x22a8 <clust2sect>
    2db0:	dc 01       	movw	r26, r24
    2db2:	cb 01       	movw	r24, r22
    2db4:	f8 01       	movw	r30, r16
    2db6:	86 87       	std	Z+14, r24	; 0x0e
    2db8:	97 87       	std	Z+15, r25	; 0x0f
    2dba:	a0 8b       	std	Z+16, r26	; 0x10
    2dbc:	b1 8b       	std	Z+17, r27	; 0x11
			}
		}
	}

	dj->index = i;
    2dbe:	d8 01       	movw	r26, r16
    2dc0:	15 96       	adiw	r26, 0x05	; 5
    2dc2:	fc 92       	st	X, r15
    2dc4:	ee 92       	st	-X, r14
    2dc6:	14 97       	sbiw	r26, 0x04	; 4
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    2dc8:	8d 91       	ld	r24, X+
    2dca:	9c 91       	ld	r25, X
    2dcc:	11 97       	sbiw	r26, 0x01	; 1
    2dce:	c2 96       	adiw	r24, 0x32	; 50
    2dd0:	cc 0c       	add	r12, r12
    2dd2:	dd 1c       	adc	r13, r13
    2dd4:	cc 0c       	add	r12, r12
    2dd6:	dd 1c       	adc	r13, r13
    2dd8:	cc 0c       	add	r12, r12
    2dda:	dd 1c       	adc	r13, r13
    2ddc:	cc 0c       	add	r12, r12
    2dde:	dd 1c       	adc	r13, r13
    2de0:	cc 0c       	add	r12, r12
    2de2:	dd 1c       	adc	r13, r13
    2de4:	8c 0d       	add	r24, r12
    2de6:	9d 1d       	adc	r25, r13
    2de8:	53 96       	adiw	r26, 0x13	; 19
    2dea:	9c 93       	st	X, r25
    2dec:	8e 93       	st	-X, r24
    2dee:	52 97       	sbiw	r26, 0x12	; 18

	return FR_OK;
    2df0:	80 e0       	ldi	r24, 0x00	; 0
    2df2:	15 c0       	rjmp	.+42     	; 0x2e1e <dir_next+0x274>


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
    2df4:	84 e0       	ldi	r24, 0x04	; 4
    2df6:	13 c0       	rjmp	.+38     	; 0x2e1e <dir_next+0x274>
    2df8:	84 e0       	ldi	r24, 0x04	; 4
    2dfa:	11 c0       	rjmp	.+34     	; 0x2e1e <dir_next+0x274>
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
    2dfc:	84 e0       	ldi	r24, 0x04	; 4
    2dfe:	0f c0       	rjmp	.+30     	; 0x2e1e <dir_next+0x274>
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
    2e00:	82 e0       	ldi	r24, 0x02	; 2
    2e02:	0d c0       	rjmp	.+26     	; 0x2e1e <dir_next+0x274>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2e04:	81 e0       	ldi	r24, 0x01	; 1
    2e06:	0b c0       	rjmp	.+22     	; 0x2e1e <dir_next+0x274>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    2e08:	84 e0       	ldi	r24, 0x04	; 4
    2e0a:	09 c0       	rjmp	.+18     	; 0x2e1e <dir_next+0x274>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    2e0c:	87 e0       	ldi	r24, 0x07	; 7
    2e0e:	07 c0       	rjmp	.+14     	; 0x2e1e <dir_next+0x274>
					if (clst == 1) return FR_INT_ERR;
    2e10:	82 e0       	ldi	r24, 0x02	; 2
    2e12:	05 c0       	rjmp	.+10     	; 0x2e1e <dir_next+0x274>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2e14:	81 e0       	ldi	r24, 0x01	; 1
    2e16:	03 c0       	rjmp	.+6      	; 0x2e1e <dir_next+0x274>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    2e18:	81 e0       	ldi	r24, 0x01	; 1
    2e1a:	01 c0       	rjmp	.+2      	; 0x2e1e <dir_next+0x274>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    2e1c:	81 e0       	ldi	r24, 0x01	; 1

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
}
    2e1e:	df 91       	pop	r29
    2e20:	cf 91       	pop	r28
    2e22:	1f 91       	pop	r17
    2e24:	0f 91       	pop	r16
    2e26:	ff 90       	pop	r15
    2e28:	ef 90       	pop	r14
    2e2a:	df 90       	pop	r13
    2e2c:	cf 90       	pop	r12
    2e2e:	bf 90       	pop	r11
    2e30:	af 90       	pop	r10
    2e32:	9f 90       	pop	r9
    2e34:	8f 90       	pop	r8
    2e36:	08 95       	ret

00002e38 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
    2e38:	2f 92       	push	r2
    2e3a:	3f 92       	push	r3
    2e3c:	4f 92       	push	r4
    2e3e:	5f 92       	push	r5
    2e40:	6f 92       	push	r6
    2e42:	7f 92       	push	r7
    2e44:	8f 92       	push	r8
    2e46:	9f 92       	push	r9
    2e48:	af 92       	push	r10
    2e4a:	bf 92       	push	r11
    2e4c:	cf 92       	push	r12
    2e4e:	df 92       	push	r13
    2e50:	ef 92       	push	r14
    2e52:	ff 92       	push	r15
    2e54:	0f 93       	push	r16
    2e56:	1f 93       	push	r17
    2e58:	cf 93       	push	r28
    2e5a:	df 93       	push	r29
    2e5c:	cd b7       	in	r28, 0x3d	; 61
    2e5e:	de b7       	in	r29, 0x3e	; 62
    2e60:	2b 97       	sbiw	r28, 0x0b	; 11
    2e62:	0f b6       	in	r0, 0x3f	; 63
    2e64:	f8 94       	cli
    2e66:	de bf       	out	0x3e, r29	; 62
    2e68:	0f be       	out	0x3f, r0	; 63
    2e6a:	cd bf       	out	0x3d, r28	; 61
    2e6c:	8c 01       	movw	r16, r24
    2e6e:	2b 01       	movw	r4, r22
	FRESULT res;
	BYTE *dir, ns;


#if _FS_RPATH
	if (*path == '/' || *path == '\\') { /* There is a heading separator */
    2e70:	db 01       	movw	r26, r22
    2e72:	8c 91       	ld	r24, X
    2e74:	8f 32       	cpi	r24, 0x2F	; 47
    2e76:	11 f0       	breq	.+4      	; 0x2e7c <follow_path+0x44>
    2e78:	8c 35       	cpi	r24, 0x5C	; 92
    2e7a:	49 f4       	brne	.+18     	; 0x2e8e <follow_path+0x56>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
    2e7c:	08 94       	sec
    2e7e:	41 1c       	adc	r4, r1
    2e80:	51 1c       	adc	r5, r1
    2e82:	f8 01       	movw	r30, r16
    2e84:	16 82       	std	Z+6, r1	; 0x06
    2e86:	17 82       	std	Z+7, r1	; 0x07
    2e88:	10 86       	std	Z+8, r1	; 0x08
    2e8a:	11 86       	std	Z+9, r1	; 0x09
    2e8c:	0c c0       	rjmp	.+24     	; 0x2ea6 <follow_path+0x6e>
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
    2e8e:	d8 01       	movw	r26, r16
    2e90:	ed 91       	ld	r30, X+
    2e92:	fc 91       	ld	r31, X
    2e94:	86 89       	ldd	r24, Z+22	; 0x16
    2e96:	97 89       	ldd	r25, Z+23	; 0x17
    2e98:	a0 8d       	ldd	r26, Z+24	; 0x18
    2e9a:	b1 8d       	ldd	r27, Z+25	; 0x19
    2e9c:	f8 01       	movw	r30, r16
    2e9e:	86 83       	std	Z+6, r24	; 0x06
    2ea0:	97 83       	std	Z+7, r25	; 0x07
    2ea2:	a0 87       	std	Z+8, r26	; 0x08
    2ea4:	b1 87       	std	Z+9, r27	; 0x09
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    2ea6:	d2 01       	movw	r26, r4
    2ea8:	8c 91       	ld	r24, X
    2eaa:	80 32       	cpi	r24, 0x20	; 32
    2eac:	48 f4       	brcc	.+18     	; 0x2ec0 <follow_path+0x88>
		res = dir_sdi(dj, 0);
    2eae:	c8 01       	movw	r24, r16
    2eb0:	60 e0       	ldi	r22, 0x00	; 0
    2eb2:	70 e0       	ldi	r23, 0x00	; 0
    2eb4:	0e 94 c1 12 	call	0x2582	; 0x2582 <dir_sdi>
		dj->dir = 0;
    2eb8:	f8 01       	movw	r30, r16
    2eba:	13 8a       	std	Z+19, r1	; 0x13
    2ebc:	12 8a       	std	Z+18, r1	; 0x12
    2ebe:	a5 c1       	rjmp	.+842    	; 0x320a <follow_path+0x3d2>
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    2ec0:	f8 e0       	ldi	r31, 0x08	; 8
    2ec2:	fa 83       	std	Y+2, r31	; 0x02
    2ec4:	1b 82       	std	Y+3, r1	; 0x03
    2ec6:	1c 82       	std	Y+4, r1	; 0x04
    2ec8:	1d 82       	std	Y+5, r1	; 0x05
    2eca:	2b e0       	ldi	r18, 0x0B	; 11
    2ecc:	2e 83       	std	Y+6, r18	; 0x06
    2ece:	1f 82       	std	Y+7, r1	; 0x07
    2ed0:	18 86       	std	Y+8, r1	; 0x08
    2ed2:	19 86       	std	Y+9, r1	; 0x09
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
		res = dir_sdi(dj, 0);
		dj->dir = 0;
    2ed4:	f2 01       	movw	r30, r4
    2ed6:	9f 01       	movw	r18, r30
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    2ed8:	81 91       	ld	r24, Z+
    2eda:	8f 32       	cpi	r24, 0x2F	; 47
    2edc:	e1 f3       	breq	.-8      	; 0x2ed6 <follow_path+0x9e>
    2ede:	8c 35       	cpi	r24, 0x5C	; 92
    2ee0:	d1 f3       	breq	.-12     	; 0x2ed6 <follow_path+0x9e>
    2ee2:	3b 87       	std	Y+11, r19	; 0x0b
    2ee4:	2a 87       	std	Y+10, r18	; 0x0a
	sfn = dj->fn;
    2ee6:	d8 01       	movw	r26, r16
    2ee8:	54 96       	adiw	r26, 0x14	; 20
    2eea:	2d 90       	ld	r2, X+
    2eec:	3c 90       	ld	r3, X
    2eee:	55 97       	sbiw	r26, 0x15	; 21
	mem_set(sfn, ' ', 11);
    2ef0:	c1 01       	movw	r24, r2
    2ef2:	60 e2       	ldi	r22, 0x20	; 32
    2ef4:	70 e0       	ldi	r23, 0x00	; 0
    2ef6:	2b e0       	ldi	r18, 0x0B	; 11
    2ef8:	30 e0       	ldi	r19, 0x00	; 0
    2efa:	40 e0       	ldi	r20, 0x00	; 0
    2efc:	50 e0       	ldi	r21, 0x00	; 0
    2efe:	0e 94 5f 0a 	call	0x14be	; 0x14be <mem_set>
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
    2f02:	ea 85       	ldd	r30, Y+10	; 0x0a
    2f04:	fb 85       	ldd	r31, Y+11	; 0x0b
    2f06:	80 81       	ld	r24, Z
    2f08:	8e 32       	cpi	r24, 0x2E	; 46
    2f0a:	89 f5       	brne	.+98     	; 0x2f6e <follow_path+0x136>
		for (;;) {
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
    2f0c:	ee e2       	ldi	r30, 0x2E	; 46
    2f0e:	d1 01       	movw	r26, r2
    2f10:	ec 93       	st	X, r30
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2f12:	aa 85       	ldd	r26, Y+10	; 0x0a
    2f14:	bb 85       	ldd	r27, Y+11	; 0x0b
    2f16:	11 96       	adiw	r26, 0x01	; 1
    2f18:	2c 91       	ld	r18, X
    2f1a:	11 97       	sbiw	r26, 0x01	; 1
			if (c != '.' || si >= 3) break;
    2f1c:	2e 32       	cpi	r18, 0x2E	; 46
    2f1e:	61 f4       	brne	.+24     	; 0x2f38 <follow_path+0x100>
			sfn[i++] = c;
    2f20:	f1 01       	movw	r30, r2
    2f22:	21 83       	std	Z+1, r18	; 0x01
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2f24:	12 96       	adiw	r26, 0x02	; 2
    2f26:	2c 91       	ld	r18, X
    2f28:	12 97       	sbiw	r26, 0x02	; 2
			if (c != '.' || si >= 3) break;
    2f2a:	2e 32       	cpi	r18, 0x2E	; 46
    2f2c:	71 f0       	breq	.+28     	; 0x2f4a <follow_path+0x112>
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2f2e:	83 e0       	ldi	r24, 0x03	; 3
    2f30:	90 e0       	ldi	r25, 0x00	; 0
    2f32:	a0 e0       	ldi	r26, 0x00	; 0
    2f34:	b0 e0       	ldi	r27, 0x00	; 0
    2f36:	04 c0       	rjmp	.+8      	; 0x2f40 <follow_path+0x108>
    2f38:	82 e0       	ldi	r24, 0x02	; 2
    2f3a:	90 e0       	ldi	r25, 0x00	; 0
    2f3c:	a0 e0       	ldi	r26, 0x00	; 0
    2f3e:	b0 e0       	ldi	r27, 0x00	; 0
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    2f40:	2f 32       	cpi	r18, 0x2F	; 47
    2f42:	59 f0       	breq	.+22     	; 0x2f5a <follow_path+0x122>
    2f44:	2c 35       	cpi	r18, 0x5C	; 92
    2f46:	49 f0       	breq	.+18     	; 0x2f5a <follow_path+0x122>
    2f48:	04 c0       	rjmp	.+8      	; 0x2f52 <follow_path+0x11a>
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2f4a:	83 e0       	ldi	r24, 0x03	; 3
    2f4c:	90 e0       	ldi	r25, 0x00	; 0
    2f4e:	a0 e0       	ldi	r26, 0x00	; 0
    2f50:	b0 e0       	ldi	r27, 0x00	; 0
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    2f52:	21 32       	cpi	r18, 0x21	; 33
    2f54:	08 f0       	brcs	.+2      	; 0x2f58 <follow_path+0x120>
    2f56:	48 c1       	rjmp	.+656    	; 0x31e8 <follow_path+0x3b0>
    2f58:	71 c1       	rjmp	.+738    	; 0x323c <follow_path+0x404>
		*path = &p[si];									/* Return pointer to the next segment */
    2f5a:	4a 84       	ldd	r4, Y+10	; 0x0a
    2f5c:	5b 84       	ldd	r5, Y+11	; 0x0b
    2f5e:	48 0e       	add	r4, r24
    2f60:	59 1e       	adc	r5, r25
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
    2f62:	80 e2       	ldi	r24, 0x20	; 32
    2f64:	d1 01       	movw	r26, r2
    2f66:	1b 96       	adiw	r26, 0x0b	; 11
    2f68:	8c 93       	st	X, r24
    2f6a:	1b 97       	sbiw	r26, 0x0b	; 11
    2f6c:	74 c1       	rjmp	.+744    	; 0x3256 <follow_path+0x41e>
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
    2f6e:	cc 24       	eor	r12, r12
    2f70:	dd 24       	eor	r13, r13
    2f72:	76 01       	movw	r14, r12
    2f74:	40 e0       	ldi	r20, 0x00	; 0
    2f76:	50 e0       	ldi	r21, 0x00	; 0
    2f78:	ba 01       	movw	r22, r20
    2f7a:	88 24       	eor	r8, r8
    2f7c:	99 24       	eor	r9, r9
    2f7e:	54 01       	movw	r10, r8
    2f80:	68 94       	set
    2f82:	83 f8       	bld	r8, 3
    2f84:	19 82       	std	Y+1, r1	; 0x01
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    2f86:	ea 85       	ldd	r30, Y+10	; 0x0a
    2f88:	fb 85       	ldd	r31, Y+11	; 0x0b
    2f8a:	e4 0f       	add	r30, r20
    2f8c:	f5 1f       	adc	r31, r21
    2f8e:	20 81       	ld	r18, Z
    2f90:	2a 01       	movw	r4, r20
    2f92:	3b 01       	movw	r6, r22
    2f94:	08 94       	sec
    2f96:	41 1c       	adc	r4, r1
    2f98:	51 1c       	adc	r5, r1
    2f9a:	61 1c       	adc	r6, r1
    2f9c:	71 1c       	adc	r7, r1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    2f9e:	21 32       	cpi	r18, 0x21	; 33
    2fa0:	08 f4       	brcc	.+2      	; 0x2fa4 <follow_path+0x16c>
    2fa2:	95 c0       	rjmp	.+298    	; 0x30ce <follow_path+0x296>
    2fa4:	2f 32       	cpi	r18, 0x2F	; 47
    2fa6:	09 f4       	brne	.+2      	; 0x2faa <follow_path+0x172>
    2fa8:	4f c1       	rjmp	.+670    	; 0x3248 <follow_path+0x410>
    2faa:	2c 35       	cpi	r18, 0x5C	; 92
    2fac:	09 f4       	brne	.+2      	; 0x2fb0 <follow_path+0x178>
    2fae:	4c c1       	rjmp	.+664    	; 0x3248 <follow_path+0x410>
		if (c == '.' || i >= ni) {
    2fb0:	2e 32       	cpi	r18, 0x2E	; 46
    2fb2:	29 f0       	breq	.+10     	; 0x2fbe <follow_path+0x186>
    2fb4:	c8 14       	cp	r12, r8
    2fb6:	d9 04       	cpc	r13, r9
    2fb8:	ea 04       	cpc	r14, r10
    2fba:	fb 04       	cpc	r15, r11
    2fbc:	c8 f0       	brcs	.+50     	; 0x2ff0 <follow_path+0x1b8>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    2fbe:	f8 e0       	ldi	r31, 0x08	; 8
    2fc0:	8f 16       	cp	r8, r31
    2fc2:	91 04       	cpc	r9, r1
    2fc4:	a1 04       	cpc	r10, r1
    2fc6:	b1 04       	cpc	r11, r1
    2fc8:	09 f0       	breq	.+2      	; 0x2fcc <follow_path+0x194>
    2fca:	10 c1       	rjmp	.+544    	; 0x31ec <follow_path+0x3b4>
    2fcc:	2e 32       	cpi	r18, 0x2E	; 46
    2fce:	09 f0       	breq	.+2      	; 0x2fd2 <follow_path+0x19a>
    2fd0:	0f c1       	rjmp	.+542    	; 0x31f0 <follow_path+0x3b8>
			i = 8; ni = 11;
			b <<= 2; continue;
    2fd2:	29 81       	ldd	r18, Y+1	; 0x01
    2fd4:	22 0f       	add	r18, r18
    2fd6:	22 0f       	add	r18, r18
    2fd8:	29 83       	std	Y+1, r18	; 0x01
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    2fda:	b3 01       	movw	r22, r6
    2fdc:	a2 01       	movw	r20, r4
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    2fde:	ca 80       	ldd	r12, Y+2	; 0x02
    2fe0:	db 80       	ldd	r13, Y+3	; 0x03
    2fe2:	ec 80       	ldd	r14, Y+4	; 0x04
    2fe4:	fd 80       	ldd	r15, Y+5	; 0x05
    2fe6:	8e 80       	ldd	r8, Y+6	; 0x06
    2fe8:	9f 80       	ldd	r9, Y+7	; 0x07
    2fea:	a8 84       	ldd	r10, Y+8	; 0x08
    2fec:	b9 84       	ldd	r11, Y+9	; 0x09
    2fee:	cb cf       	rjmp	.-106    	; 0x2f86 <follow_path+0x14e>
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended char? */
    2ff0:	22 23       	and	r18, r18
    2ff2:	1c f4       	brge	.+6      	; 0x2ffa <follow_path+0x1c2>
			b |= 3;						/* Eliminate NT flag */
    2ff4:	89 81       	ldd	r24, Y+1	; 0x01
    2ff6:	83 60       	ori	r24, 0x03	; 3
    2ff8:	89 83       	std	Y+1, r24	; 0x01
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    2ffa:	82 2f       	mov	r24, r18
    2ffc:	81 58       	subi	r24, 0x81	; 129
    2ffe:	8f 31       	cpi	r24, 0x1F	; 31
    3000:	18 f0       	brcs	.+6      	; 0x3008 <follow_path+0x1d0>
    3002:	8f 55       	subi	r24, 0x5F	; 95
    3004:	8d 31       	cpi	r24, 0x1D	; 29
    3006:	90 f5       	brcc	.+100    	; 0x306c <follow_path+0x234>
			d = (BYTE)p[si++];			/* Get 2nd byte */
    3008:	ea 85       	ldd	r30, Y+10	; 0x0a
    300a:	fb 85       	ldd	r31, Y+11	; 0x0b
    300c:	e4 0d       	add	r30, r4
    300e:	f5 1d       	adc	r31, r5
    3010:	30 81       	ld	r19, Z
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    3012:	83 2f       	mov	r24, r19
    3014:	80 54       	subi	r24, 0x40	; 64
    3016:	8f 33       	cpi	r24, 0x3F	; 63
    3018:	20 f0       	brcs	.+8      	; 0x3022 <follow_path+0x1ea>
    301a:	80 54       	subi	r24, 0x40	; 64
    301c:	8d 37       	cpi	r24, 0x7D	; 125
    301e:	08 f0       	brcs	.+2      	; 0x3022 <follow_path+0x1ea>
    3020:	e9 c0       	rjmp	.+466    	; 0x31f4 <follow_path+0x3bc>
    3022:	d5 01       	movw	r26, r10
    3024:	c4 01       	movw	r24, r8
    3026:	01 97       	sbiw	r24, 0x01	; 1
    3028:	a1 09       	sbc	r26, r1
    302a:	b1 09       	sbc	r27, r1
    302c:	c8 16       	cp	r12, r24
    302e:	d9 06       	cpc	r13, r25
    3030:	ea 06       	cpc	r14, r26
    3032:	fb 06       	cpc	r15, r27
    3034:	08 f0       	brcs	.+2      	; 0x3038 <follow_path+0x200>
    3036:	e0 c0       	rjmp	.+448    	; 0x31f8 <follow_path+0x3c0>
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
    3038:	4e 5f       	subi	r20, 0xFE	; 254
    303a:	5f 4f       	sbci	r21, 0xFF	; 255
    303c:	6f 4f       	sbci	r22, 0xFF	; 255
    303e:	7f 4f       	sbci	r23, 0xFF	; 255
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
    3040:	f1 01       	movw	r30, r2
    3042:	ec 0d       	add	r30, r12
    3044:	fd 1d       	adc	r31, r13
    3046:	20 83       	st	Z, r18
    3048:	d7 01       	movw	r26, r14
    304a:	c6 01       	movw	r24, r12
    304c:	01 96       	adiw	r24, 0x01	; 1
    304e:	a1 1d       	adc	r26, r1
    3050:	b1 1d       	adc	r27, r1
			sfn[i++] = d;
    3052:	82 0d       	add	r24, r2
    3054:	93 1d       	adc	r25, r3
    3056:	dc 01       	movw	r26, r24
    3058:	3c 93       	st	X, r19
    305a:	82 e0       	ldi	r24, 0x02	; 2
    305c:	90 e0       	ldi	r25, 0x00	; 0
    305e:	a0 e0       	ldi	r26, 0x00	; 0
    3060:	b0 e0       	ldi	r27, 0x00	; 0
    3062:	c8 0e       	add	r12, r24
    3064:	d9 1e       	adc	r13, r25
    3066:	ea 1e       	adc	r14, r26
    3068:	fb 1e       	adc	r15, r27
    306a:	8d cf       	rjmp	.-230    	; 0x2f86 <follow_path+0x14e>
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    306c:	42 2f       	mov	r20, r18
    306e:	50 e0       	ldi	r21, 0x00	; 0
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    3070:	42 32       	cpi	r20, 0x22	; 34
    3072:	51 05       	cpc	r21, r1
    3074:	09 f4       	brne	.+2      	; 0x3078 <follow_path+0x240>
    3076:	c2 c0       	rjmp	.+388    	; 0x31fc <follow_path+0x3c4>
    3078:	e0 e1       	ldi	r30, 0x10	; 16
    307a:	f4 e0       	ldi	r31, 0x04	; 4
    307c:	6a 85       	ldd	r22, Y+10	; 0x0a
    307e:	7b 85       	ldd	r23, Y+11	; 0x0b
    3080:	81 91       	ld	r24, Z+
    3082:	88 23       	and	r24, r24
    3084:	31 f0       	breq	.+12     	; 0x3092 <follow_path+0x25a>
    3086:	90 e0       	ldi	r25, 0x00	; 0
    3088:	48 17       	cp	r20, r24
    308a:	59 07       	cpc	r21, r25
    308c:	c9 f7       	brne	.-14     	; 0x3080 <follow_path+0x248>
    308e:	86 e0       	ldi	r24, 0x06	; 6
    3090:	bc c0       	rjmp	.+376    	; 0x320a <follow_path+0x3d2>
    3092:	7b 87       	std	Y+11, r23	; 0x0b
    3094:	6a 87       	std	Y+10, r22	; 0x0a
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
    3096:	82 2f       	mov	r24, r18
    3098:	81 54       	subi	r24, 0x41	; 65
    309a:	8a 31       	cpi	r24, 0x1A	; 26
    309c:	20 f4       	brcc	.+8      	; 0x30a6 <follow_path+0x26e>
				b |= 2;
    309e:	99 81       	ldd	r25, Y+1	; 0x01
    30a0:	92 60       	ori	r25, 0x02	; 2
    30a2:	99 83       	std	Y+1, r25	; 0x01
    30a4:	08 c0       	rjmp	.+16     	; 0x30b6 <follow_path+0x27e>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
    30a6:	82 2f       	mov	r24, r18
    30a8:	81 56       	subi	r24, 0x61	; 97
    30aa:	8a 31       	cpi	r24, 0x1A	; 26
    30ac:	20 f4       	brcc	.+8      	; 0x30b6 <follow_path+0x27e>
					b |= 1; c -= 0x20;
    30ae:	a9 81       	ldd	r26, Y+1	; 0x01
    30b0:	a1 60       	ori	r26, 0x01	; 1
    30b2:	a9 83       	std	Y+1, r26	; 0x01
    30b4:	20 52       	subi	r18, 0x20	; 32
				}
			}
			sfn[i++] = c;
    30b6:	f1 01       	movw	r30, r2
    30b8:	ec 0d       	add	r30, r12
    30ba:	fd 1d       	adc	r31, r13
    30bc:	20 83       	st	Z, r18
    30be:	08 94       	sec
    30c0:	c1 1c       	adc	r12, r1
    30c2:	d1 1c       	adc	r13, r1
    30c4:	e1 1c       	adc	r14, r1
    30c6:	f1 1c       	adc	r15, r1
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    30c8:	b3 01       	movw	r22, r6
    30ca:	a2 01       	movw	r20, r4
    30cc:	5c cf       	rjmp	.-328    	; 0x2f86 <follow_path+0x14e>
    30ce:	ea 85       	ldd	r30, Y+10	; 0x0a
    30d0:	fb 85       	ldd	r31, Y+11	; 0x0b
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    30d2:	4e 0e       	add	r4, r30
    30d4:	5f 1e       	adc	r5, r31
    30d6:	89 81       	ldd	r24, Y+1	; 0x01
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    30d8:	44 e0       	ldi	r20, 0x04	; 4

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    30da:	c1 14       	cp	r12, r1
    30dc:	d1 04       	cpc	r13, r1
    30de:	e1 04       	cpc	r14, r1
    30e0:	f1 04       	cpc	r15, r1
    30e2:	09 f4       	brne	.+2      	; 0x30e6 <follow_path+0x2ae>
    30e4:	8d c0       	rjmp	.+282    	; 0x3200 <follow_path+0x3c8>
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    30e6:	d1 01       	movw	r26, r2
    30e8:	9c 91       	ld	r25, X
    30ea:	95 3e       	cpi	r25, 0xE5	; 229
    30ec:	11 f4       	brne	.+4      	; 0x30f2 <follow_path+0x2ba>
    30ee:	e5 e0       	ldi	r30, 0x05	; 5
    30f0:	ec 93       	st	X, r30

	if (ni == 8) b <<= 2;
    30f2:	f8 e0       	ldi	r31, 0x08	; 8
    30f4:	8f 16       	cp	r8, r31
    30f6:	91 04       	cpc	r9, r1
    30f8:	a1 04       	cpc	r10, r1
    30fa:	b1 04       	cpc	r11, r1
    30fc:	19 f4       	brne	.+6      	; 0x3104 <follow_path+0x2cc>
    30fe:	88 0f       	add	r24, r24
    3100:	88 0f       	add	r24, r24
    3102:	89 83       	std	Y+1, r24	; 0x01
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    3104:	29 81       	ldd	r18, Y+1	; 0x01
    3106:	82 2f       	mov	r24, r18
    3108:	90 e0       	ldi	r25, 0x00	; 0
    310a:	9c 01       	movw	r18, r24
    310c:	23 70       	andi	r18, 0x03	; 3
    310e:	30 70       	andi	r19, 0x00	; 0
    3110:	21 30       	cpi	r18, 0x01	; 1
    3112:	31 05       	cpc	r19, r1
    3114:	09 f4       	brne	.+2      	; 0x3118 <follow_path+0x2e0>
    3116:	40 61       	ori	r20, 0x10	; 16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    3118:	8c 70       	andi	r24, 0x0C	; 12
    311a:	90 70       	andi	r25, 0x00	; 0
    311c:	84 30       	cpi	r24, 0x04	; 4
    311e:	91 05       	cpc	r25, r1
    3120:	09 f4       	brne	.+2      	; 0x3124 <follow_path+0x2ec>
    3122:	48 60       	ori	r20, 0x08	; 8

	sfn[NS] = c;		/* Store NT flag, File name is created */
    3124:	d1 01       	movw	r26, r2
    3126:	1b 96       	adiw	r26, 0x0b	; 11
    3128:	4c 93       	st	X, r20
    312a:	1b 97       	sbiw	r26, 0x0b	; 11
    312c:	94 c0       	rjmp	.+296    	; 0x3256 <follow_path+0x41e>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
    312e:	f8 01       	movw	r30, r16
    3130:	46 85       	ldd	r20, Z+14	; 0x0e
    3132:	57 85       	ldd	r21, Z+15	; 0x0f
    3134:	60 89       	ldd	r22, Z+16	; 0x10
    3136:	71 89       	ldd	r23, Z+17	; 0x11
    3138:	80 81       	ld	r24, Z
    313a:	91 81       	ldd	r25, Z+1	; 0x01
    313c:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
		if (res != FR_OK) break;
    3140:	88 23       	and	r24, r24
    3142:	31 f5       	brne	.+76     	; 0x3190 <follow_path+0x358>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    3144:	d8 01       	movw	r26, r16
    3146:	52 96       	adiw	r26, 0x12	; 18
    3148:	6d 91       	ld	r22, X+
    314a:	7c 91       	ld	r23, X
    314c:	53 97       	sbiw	r26, 0x13	; 19
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    314e:	fb 01       	movw	r30, r22
    3150:	90 81       	ld	r25, Z
    3152:	99 23       	and	r25, r25
    3154:	09 f4       	brne	.+2      	; 0x3158 <follow_path+0x320>
    3156:	90 c0       	rjmp	.+288    	; 0x3278 <follow_path+0x440>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    3158:	93 85       	ldd	r25, Z+11	; 0x0b
    315a:	93 fd       	sbrc	r25, 3
    315c:	12 c0       	rjmp	.+36     	; 0x3182 <follow_path+0x34a>
    315e:	54 96       	adiw	r26, 0x14	; 20
    3160:	4d 91       	ld	r20, X+
    3162:	5c 91       	ld	r21, X
    3164:	55 97       	sbiw	r26, 0x15	; 21
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
    3166:	9b 01       	movw	r18, r22
    3168:	25 5f       	subi	r18, 0xF5	; 245
    316a:	3f 4f       	sbci	r19, 0xFF	; 255
}

/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    316c:	da 01       	movw	r26, r20
    316e:	6b 01       	movw	r12, r22
    3170:	04 c0       	rjmp	.+8      	; 0x317a <follow_path+0x342>
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    3172:	e2 17       	cp	r30, r18
    3174:	f3 07       	cpc	r31, r19
    3176:	09 f4       	brne	.+2      	; 0x317a <follow_path+0x342>
    3178:	77 c0       	rjmp	.+238    	; 0x3268 <follow_path+0x430>
    317a:	61 91       	ld	r22, Z+
    317c:	9d 91       	ld	r25, X+
    317e:	69 17       	cp	r22, r25
    3180:	c1 f3       	breq	.-16     	; 0x3172 <follow_path+0x33a>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
    3182:	c8 01       	movw	r24, r16
    3184:	60 e0       	ldi	r22, 0x00	; 0
    3186:	70 e0       	ldi	r23, 0x00	; 0
    3188:	0e 94 d5 15 	call	0x2baa	; 0x2baa <dir_next>
	} while (res == FR_OK);
    318c:	88 23       	and	r24, r24
    318e:	79 f2       	breq	.-98     	; 0x312e <follow_path+0x2f6>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    3190:	d8 01       	movw	r26, r16
    3192:	54 96       	adiw	r26, 0x14	; 20
    3194:	ed 91       	ld	r30, X+
    3196:	fc 91       	ld	r31, X
    3198:	55 97       	sbiw	r26, 0x15	; 21
    319a:	93 85       	ldd	r25, Z+11	; 0x0b
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
    319c:	84 30       	cpi	r24, 0x04	; 4
    319e:	a9 f5       	brne	.+106    	; 0x320a <follow_path+0x3d2>
				/* Object not found */
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
    31a0:	95 ff       	sbrs	r25, 5
    31a2:	0b c0       	rjmp	.+22     	; 0x31ba <follow_path+0x382>
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
    31a4:	f8 01       	movw	r30, r16
    31a6:	16 82       	std	Z+6, r1	; 0x06
    31a8:	17 82       	std	Z+7, r1	; 0x07
    31aa:	10 86       	std	Z+8, r1	; 0x08
    31ac:	11 86       	std	Z+9, r1	; 0x09
    31ae:	13 8a       	std	Z+19, r1	; 0x13
    31b0:	12 8a       	std	Z+18, r1	; 0x12
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
    31b2:	92 ff       	sbrs	r25, 2
    31b4:	8f ce       	rjmp	.-738    	; 0x2ed4 <follow_path+0x9c>
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
				/* Object not found */
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
    31b6:	80 e0       	ldi	r24, 0x00	; 0
    31b8:	28 c0       	rjmp	.+80     	; 0x320a <follow_path+0x3d2>
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    31ba:	92 ff       	sbrs	r25, 2
    31bc:	23 c0       	rjmp	.+70     	; 0x3204 <follow_path+0x3cc>
		dj->dir = 0;
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
    31be:	84 e0       	ldi	r24, 0x04	; 4
    31c0:	24 c0       	rjmp	.+72     	; 0x320a <follow_path+0x3d2>
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    31c2:	db 01       	movw	r26, r22
    31c4:	1b 96       	adiw	r26, 0x0b	; 11
    31c6:	8c 91       	ld	r24, X
    31c8:	1b 97       	sbiw	r26, 0x0b	; 11
    31ca:	84 ff       	sbrs	r24, 4
    31cc:	1d c0       	rjmp	.+58     	; 0x3208 <follow_path+0x3d0>
				res = FR_NO_PATH; break;
			}
			dj->sclust = ld_clust(dj->fs, dir);
    31ce:	f8 01       	movw	r30, r16
    31d0:	80 81       	ld	r24, Z
    31d2:	91 81       	ldd	r25, Z+1	; 0x01
    31d4:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ld_clust>
    31d8:	dc 01       	movw	r26, r24
    31da:	cb 01       	movw	r24, r22
    31dc:	f8 01       	movw	r30, r16
    31de:	86 83       	std	Z+6, r24	; 0x06
    31e0:	97 83       	std	Z+7, r25	; 0x07
    31e2:	a0 87       	std	Z+8, r26	; 0x08
    31e4:	b1 87       	std	Z+9, r27	; 0x09
    31e6:	76 ce       	rjmp	.-788    	; 0x2ed4 <follow_path+0x9c>
		for (;;) {
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    31e8:	86 e0       	ldi	r24, 0x06	; 6
    31ea:	0f c0       	rjmp	.+30     	; 0x320a <follow_path+0x3d2>
#endif
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    31ec:	86 e0       	ldi	r24, 0x06	; 6
    31ee:	0d c0       	rjmp	.+26     	; 0x320a <follow_path+0x3d2>
    31f0:	86 e0       	ldi	r24, 0x06	; 6
    31f2:	0b c0       	rjmp	.+22     	; 0x320a <follow_path+0x3d2>
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    31f4:	86 e0       	ldi	r24, 0x06	; 6
    31f6:	09 c0       	rjmp	.+18     	; 0x320a <follow_path+0x3d2>
    31f8:	86 e0       	ldi	r24, 0x06	; 6
    31fa:	07 c0       	rjmp	.+14     	; 0x320a <follow_path+0x3d2>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    31fc:	86 e0       	ldi	r24, 0x06	; 6
    31fe:	05 c0       	rjmp	.+10     	; 0x320a <follow_path+0x3d2>
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    3200:	86 e0       	ldi	r24, 0x06	; 6
    3202:	03 c0       	rjmp	.+6      	; 0x320a <follow_path+0x3d2>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    3204:	85 e0       	ldi	r24, 0x05	; 5
    3206:	01 c0       	rjmp	.+2      	; 0x320a <follow_path+0x3d2>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
    3208:	85 e0       	ldi	r24, 0x05	; 5
			dj->sclust = ld_clust(dj->fs, dir);
		}
	}

	return res;
}
    320a:	2b 96       	adiw	r28, 0x0b	; 11
    320c:	0f b6       	in	r0, 0x3f	; 63
    320e:	f8 94       	cli
    3210:	de bf       	out	0x3e, r29	; 62
    3212:	0f be       	out	0x3f, r0	; 63
    3214:	cd bf       	out	0x3d, r28	; 61
    3216:	df 91       	pop	r29
    3218:	cf 91       	pop	r28
    321a:	1f 91       	pop	r17
    321c:	0f 91       	pop	r16
    321e:	ff 90       	pop	r15
    3220:	ef 90       	pop	r14
    3222:	df 90       	pop	r13
    3224:	cf 90       	pop	r12
    3226:	bf 90       	pop	r11
    3228:	af 90       	pop	r10
    322a:	9f 90       	pop	r9
    322c:	8f 90       	pop	r8
    322e:	7f 90       	pop	r7
    3230:	6f 90       	pop	r6
    3232:	5f 90       	pop	r5
    3234:	4f 90       	pop	r4
    3236:	3f 90       	pop	r3
    3238:	2f 90       	pop	r2
    323a:	08 95       	ret
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
		*path = &p[si];									/* Return pointer to the next segment */
    323c:	4a 84       	ldd	r4, Y+10	; 0x0a
    323e:	5b 84       	ldd	r5, Y+11	; 0x0b
    3240:	48 0e       	add	r4, r24
    3242:	59 1e       	adc	r5, r25
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
    3244:	84 e2       	ldi	r24, 0x24	; 36
    3246:	8e ce       	rjmp	.-740    	; 0x2f64 <follow_path+0x12c>
    3248:	8a 85       	ldd	r24, Y+10	; 0x0a
    324a:	9b 85       	ldd	r25, Y+11	; 0x0b
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    324c:	48 0e       	add	r4, r24
    324e:	59 1e       	adc	r5, r25
    3250:	89 81       	ldd	r24, Y+1	; 0x01
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    3252:	40 e0       	ldi	r20, 0x00	; 0
    3254:	42 cf       	rjmp	.-380    	; 0x30da <follow_path+0x2a2>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
    3256:	c8 01       	movw	r24, r16
    3258:	60 e0       	ldi	r22, 0x00	; 0
    325a:	70 e0       	ldi	r23, 0x00	; 0
    325c:	0e 94 c1 12 	call	0x2582	; 0x2582 <dir_sdi>
	if (res != FR_OK) return res;
    3260:	88 23       	and	r24, r24
    3262:	09 f4       	brne	.+2      	; 0x3266 <follow_path+0x42e>
    3264:	64 cf       	rjmp	.-312    	; 0x312e <follow_path+0x2f6>
    3266:	94 cf       	rjmp	.-216    	; 0x3190 <follow_path+0x358>
    3268:	b6 01       	movw	r22, r12
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    326a:	da 01       	movw	r26, r20
    326c:	1b 96       	adiw	r26, 0x0b	; 11
    326e:	9c 91       	ld	r25, X
    3270:	1b 97       	sbiw	r26, 0x0b	; 11
    3272:	92 ff       	sbrs	r25, 2
    3274:	a6 cf       	rjmp	.-180    	; 0x31c2 <follow_path+0x38a>
    3276:	c9 cf       	rjmp	.-110    	; 0x320a <follow_path+0x3d2>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    3278:	d8 01       	movw	r26, r16
    327a:	54 96       	adiw	r26, 0x14	; 20
    327c:	ed 91       	ld	r30, X+
    327e:	fc 91       	ld	r31, X
    3280:	55 97       	sbiw	r26, 0x15	; 21
    3282:	93 85       	ldd	r25, Z+11	; 0x0b
    3284:	8d cf       	rjmp	.-230    	; 0x31a0 <follow_path+0x368>

00003286 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
    3286:	ef 92       	push	r14
    3288:	ff 92       	push	r15
    328a:	0f 93       	push	r16
    328c:	1f 93       	push	r17
    328e:	cf 93       	push	r28
    3290:	8c 01       	movw	r16, r24
			} while (res == FR_OK && --ne);
		}
	}

#else	/* Non LFN configuration */
	res = dir_sdi(dj, 0);
    3292:	60 e0       	ldi	r22, 0x00	; 0
    3294:	70 e0       	ldi	r23, 0x00	; 0
    3296:	0e 94 c1 12 	call	0x2582	; 0x2582 <dir_sdi>
    329a:	c8 2f       	mov	r28, r24
	if (res == FR_OK) {
    329c:	88 23       	and	r24, r24
    329e:	09 f0       	breq	.+2      	; 0x32a2 <dir_register+0x1c>
    32a0:	3f c0       	rjmp	.+126    	; 0x3320 <dir_register+0x9a>
		do {	/* Find a blank entry for the SFN */
			res = move_window(dj->fs, dj->sect);
    32a2:	d8 01       	movw	r26, r16
    32a4:	1e 96       	adiw	r26, 0x0e	; 14
    32a6:	4d 91       	ld	r20, X+
    32a8:	5d 91       	ld	r21, X+
    32aa:	6d 91       	ld	r22, X+
    32ac:	7c 91       	ld	r23, X
    32ae:	51 97       	sbiw	r26, 0x11	; 17
    32b0:	8d 91       	ld	r24, X+
    32b2:	9c 91       	ld	r25, X
    32b4:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
    32b8:	c8 2f       	mov	r28, r24
			if (res != FR_OK) break;
    32ba:	88 23       	and	r24, r24
    32bc:	89 f5       	brne	.+98     	; 0x3320 <dir_register+0x9a>
			c = *dj->dir;
    32be:	d8 01       	movw	r26, r16
    32c0:	52 96       	adiw	r26, 0x12	; 18
    32c2:	ed 91       	ld	r30, X+
    32c4:	fc 91       	ld	r31, X
    32c6:	53 97       	sbiw	r26, 0x13	; 19
    32c8:	80 81       	ld	r24, Z
			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
    32ca:	85 3e       	cpi	r24, 0xE5	; 229
    32cc:	81 f1       	breq	.+96     	; 0x332e <dir_register+0xa8>
    32ce:	88 23       	and	r24, r24
    32d0:	71 f1       	breq	.+92     	; 0x332e <dir_register+0xa8>
			res = dir_next(dj, 1);			/* Next entry with table stretch */
    32d2:	c8 01       	movw	r24, r16
    32d4:	61 e0       	ldi	r22, 0x01	; 1
    32d6:	70 e0       	ldi	r23, 0x00	; 0
    32d8:	0e 94 d5 15 	call	0x2baa	; 0x2baa <dir_next>
    32dc:	c8 2f       	mov	r28, r24
		} while (res == FR_OK);
    32de:	88 23       	and	r24, r24
    32e0:	01 f3       	breq	.-64     	; 0x32a2 <dir_register+0x1c>
    32e2:	1e c0       	rjmp	.+60     	; 0x3320 <dir_register+0x9a>
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
    32e4:	f8 01       	movw	r30, r16
    32e6:	e2 88       	ldd	r14, Z+18	; 0x12
    32e8:	f3 88       	ldd	r15, Z+19	; 0x13
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
    32ea:	c7 01       	movw	r24, r14
    32ec:	60 e0       	ldi	r22, 0x00	; 0
    32ee:	70 e0       	ldi	r23, 0x00	; 0
    32f0:	20 e2       	ldi	r18, 0x20	; 32
    32f2:	30 e0       	ldi	r19, 0x00	; 0
    32f4:	40 e0       	ldi	r20, 0x00	; 0
    32f6:	50 e0       	ldi	r21, 0x00	; 0
    32f8:	0e 94 5f 0a 	call	0x14be	; 0x14be <mem_set>
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
    32fc:	d8 01       	movw	r26, r16
    32fe:	54 96       	adiw	r26, 0x14	; 20
    3300:	6d 91       	ld	r22, X+
    3302:	7c 91       	ld	r23, X
    3304:	55 97       	sbiw	r26, 0x15	; 21
    3306:	c7 01       	movw	r24, r14
    3308:	2b e0       	ldi	r18, 0x0B	; 11
    330a:	30 e0       	ldi	r19, 0x00	; 0
    330c:	40 e0       	ldi	r20, 0x00	; 0
    330e:	50 e0       	ldi	r21, 0x00	; 0
    3310:	0e 94 4a 0a 	call	0x1494	; 0x1494 <mem_cpy>
#if _USE_LFN
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dj->fs->wflag = 1;
    3314:	d8 01       	movw	r26, r16
    3316:	ed 91       	ld	r30, X+
    3318:	fc 91       	ld	r31, X
    331a:	11 97       	sbiw	r26, 0x01	; 1
    331c:	81 e0       	ldi	r24, 0x01	; 1
    331e:	84 83       	std	Z+4, r24	; 0x04
		}
	}

	return res;
}
    3320:	8c 2f       	mov	r24, r28
    3322:	cf 91       	pop	r28
    3324:	1f 91       	pop	r17
    3326:	0f 91       	pop	r16
    3328:	ff 90       	pop	r15
    332a:	ef 90       	pop	r14
    332c:	08 95       	ret
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
    332e:	f8 01       	movw	r30, r16
    3330:	46 85       	ldd	r20, Z+14	; 0x0e
    3332:	57 85       	ldd	r21, Z+15	; 0x0f
    3334:	60 89       	ldd	r22, Z+16	; 0x10
    3336:	71 89       	ldd	r23, Z+17	; 0x11
    3338:	80 81       	ld	r24, Z
    333a:	91 81       	ldd	r25, Z+1	; 0x01
    333c:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
    3340:	c8 2f       	mov	r28, r24
		if (res == FR_OK) {
    3342:	88 23       	and	r24, r24
    3344:	69 f7       	brne	.-38     	; 0x3320 <dir_register+0x9a>
    3346:	ce cf       	rjmp	.-100    	; 0x32e4 <dir_register+0x5e>

00003348 <dir_read>:
#if _FS_MINIMIZE <= 1
static
FRESULT dir_read (
	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
)
{
    3348:	cf 93       	push	r28
    334a:	df 93       	push	r29
    334c:	ec 01       	movw	r28, r24
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
    334e:	84 e0       	ldi	r24, 0x04	; 4
	while (dj->sect) {
    3350:	17 c0       	rjmp	.+46     	; 0x3380 <dir_read+0x38>
		res = move_window(dj->fs, dj->sect);
    3352:	88 81       	ld	r24, Y
    3354:	99 81       	ldd	r25, Y+1	; 0x01
    3356:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
		if (res != FR_OK) break;
    335a:	88 23       	and	r24, r24
    335c:	e1 f4       	brne	.+56     	; 0x3396 <dir_read+0x4e>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    335e:	ea 89       	ldd	r30, Y+18	; 0x12
    3360:	fb 89       	ldd	r31, Y+19	; 0x13
		c = dir[DIR_Name];
    3362:	90 81       	ld	r25, Z
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    3364:	99 23       	and	r25, r25
    3366:	f1 f0       	breq	.+60     	; 0x33a4 <dir_read+0x5c>
					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    3368:	95 3e       	cpi	r25, 0xE5	; 229
    336a:	19 f0       	breq	.+6      	; 0x3372 <dir_read+0x2a>
    336c:	93 85       	ldd	r25, Z+11	; 0x0b
    336e:	93 ff       	sbrs	r25, 3
    3370:	16 c0       	rjmp	.+44     	; 0x339e <dir_read+0x56>
			break;
#endif
		res = dir_next(dj, 0);				/* Next entry */
    3372:	ce 01       	movw	r24, r28
    3374:	60 e0       	ldi	r22, 0x00	; 0
    3376:	70 e0       	ldi	r23, 0x00	; 0
    3378:	0e 94 d5 15 	call	0x2baa	; 0x2baa <dir_next>
		if (res != FR_OK) break;
    337c:	88 23       	and	r24, r24
    337e:	59 f4       	brne	.+22     	; 0x3396 <dir_read+0x4e>
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
    3380:	4e 85       	ldd	r20, Y+14	; 0x0e
    3382:	5f 85       	ldd	r21, Y+15	; 0x0f
    3384:	68 89       	ldd	r22, Y+16	; 0x10
    3386:	79 89       	ldd	r23, Y+17	; 0x11
    3388:	41 15       	cp	r20, r1
    338a:	51 05       	cpc	r21, r1
    338c:	61 05       	cpc	r22, r1
    338e:	71 05       	cpc	r23, r1
    3390:	01 f7       	brne	.-64     	; 0x3352 <dir_read+0xa>
#endif
		res = dir_next(dj, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
    3392:	88 23       	and	r24, r24
    3394:	21 f0       	breq	.+8      	; 0x339e <dir_read+0x56>
    3396:	1e 86       	std	Y+14, r1	; 0x0e
    3398:	1f 86       	std	Y+15, r1	; 0x0f
    339a:	18 8a       	std	Y+16, r1	; 0x10
    339c:	19 8a       	std	Y+17, r1	; 0x11

	return res;
}
    339e:	df 91       	pop	r29
    33a0:	cf 91       	pop	r28
    33a2:	08 95       	ret
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    33a4:	84 e0       	ldi	r24, 0x04	; 4
    33a6:	f7 cf       	rjmp	.-18     	; 0x3396 <dir_read+0x4e>

000033a8 <remove_chain>:
static
FRESULT remove_chain (
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
    33a8:	7f 92       	push	r7
    33aa:	8f 92       	push	r8
    33ac:	9f 92       	push	r9
    33ae:	af 92       	push	r10
    33b0:	bf 92       	push	r11
    33b2:	cf 92       	push	r12
    33b4:	df 92       	push	r13
    33b6:	ef 92       	push	r14
    33b8:	ff 92       	push	r15
    33ba:	0f 93       	push	r16
    33bc:	1f 93       	push	r17
    33be:	cf 93       	push	r28
    33c0:	df 93       	push	r29
    33c2:	ec 01       	movw	r28, r24
    33c4:	4a 01       	movw	r8, r20
    33c6:	5b 01       	movw	r10, r22
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    33c8:	42 30       	cpi	r20, 0x02	; 2
    33ca:	51 05       	cpc	r21, r1
    33cc:	61 05       	cpc	r22, r1
    33ce:	71 05       	cpc	r23, r1
    33d0:	08 f4       	brcc	.+2      	; 0x33d4 <remove_chain+0x2c>
    33d2:	55 c0       	rjmp	.+170    	; 0x347e <remove_chain+0xd6>
    33d4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    33d6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    33d8:	ac 8d       	ldd	r26, Y+28	; 0x1c
    33da:	bd 8d       	ldd	r27, Y+29	; 0x1d
    33dc:	48 17       	cp	r20, r24
    33de:	59 07       	cpc	r21, r25
    33e0:	6a 07       	cpc	r22, r26
    33e2:	7b 07       	cpc	r23, r27
    33e4:	08 f0       	brcs	.+2      	; 0x33e8 <remove_chain+0x40>
    33e6:	4d c0       	rjmp	.+154    	; 0x3482 <remove_chain+0xda>
    33e8:	03 c0       	rjmp	.+6      	; 0x33f0 <remove_chain+0x48>
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
    33ea:	46 01       	movw	r8, r12
    33ec:	57 01       	movw	r10, r14
    33ee:	02 c0       	rjmp	.+4      	; 0x33f4 <remove_chain+0x4c>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
				fs->free_clust++;
				fs->fsi_flag = 1;
    33f0:	77 24       	eor	r7, r7
    33f2:	73 94       	inc	r7
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
    33f4:	ce 01       	movw	r24, r28
    33f6:	b5 01       	movw	r22, r10
    33f8:	a4 01       	movw	r20, r8
    33fa:	0e 94 8a 11 	call	0x2314	; 0x2314 <get_fat>
    33fe:	6b 01       	movw	r12, r22
    3400:	7c 01       	movw	r14, r24
			if (nxt == 0) break;				/* Empty cluster? */
    3402:	61 15       	cp	r22, r1
    3404:	71 05       	cpc	r23, r1
    3406:	81 05       	cpc	r24, r1
    3408:	91 05       	cpc	r25, r1
    340a:	e9 f1       	breq	.+122    	; 0x3486 <remove_chain+0xde>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    340c:	91 e0       	ldi	r25, 0x01	; 1
    340e:	c9 16       	cp	r12, r25
    3410:	d1 04       	cpc	r13, r1
    3412:	e1 04       	cpc	r14, r1
    3414:	f1 04       	cpc	r15, r1
    3416:	c9 f1       	breq	.+114    	; 0x348a <remove_chain+0xe2>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    3418:	8f ef       	ldi	r24, 0xFF	; 255
    341a:	c8 16       	cp	r12, r24
    341c:	8f ef       	ldi	r24, 0xFF	; 255
    341e:	d8 06       	cpc	r13, r24
    3420:	8f ef       	ldi	r24, 0xFF	; 255
    3422:	e8 06       	cpc	r14, r24
    3424:	8f ef       	ldi	r24, 0xFF	; 255
    3426:	f8 06       	cpc	r15, r24
    3428:	91 f1       	breq	.+100    	; 0x348e <remove_chain+0xe6>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    342a:	ce 01       	movw	r24, r28
    342c:	b5 01       	movw	r22, r10
    342e:	a4 01       	movw	r20, r8
    3430:	00 e0       	ldi	r16, 0x00	; 0
    3432:	10 e0       	ldi	r17, 0x00	; 0
    3434:	98 01       	movw	r18, r16
    3436:	0e 94 a4 13 	call	0x2748	; 0x2748 <put_fat>
			if (res != FR_OK) break;
    343a:	88 23       	and	r24, r24
    343c:	49 f5       	brne	.+82     	; 0x3490 <remove_chain+0xe8>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    343e:	4e 85       	ldd	r20, Y+14	; 0x0e
    3440:	5f 85       	ldd	r21, Y+15	; 0x0f
    3442:	68 89       	ldd	r22, Y+16	; 0x10
    3444:	79 89       	ldd	r23, Y+17	; 0x11
    3446:	4f 3f       	cpi	r20, 0xFF	; 255
    3448:	9f ef       	ldi	r25, 0xFF	; 255
    344a:	59 07       	cpc	r21, r25
    344c:	9f ef       	ldi	r25, 0xFF	; 255
    344e:	69 07       	cpc	r22, r25
    3450:	9f ef       	ldi	r25, 0xFF	; 255
    3452:	79 07       	cpc	r23, r25
    3454:	49 f0       	breq	.+18     	; 0x3468 <remove_chain+0xc0>
				fs->free_clust++;
    3456:	4f 5f       	subi	r20, 0xFF	; 255
    3458:	5f 4f       	sbci	r21, 0xFF	; 255
    345a:	6f 4f       	sbci	r22, 0xFF	; 255
    345c:	7f 4f       	sbci	r23, 0xFF	; 255
    345e:	4e 87       	std	Y+14, r20	; 0x0e
    3460:	5f 87       	std	Y+15, r21	; 0x0f
    3462:	68 8b       	std	Y+16, r22	; 0x10
    3464:	79 8b       	std	Y+17, r23	; 0x11
				fs->fsi_flag = 1;
    3466:	7d 82       	std	Y+5, r7	; 0x05
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
    3468:	4a 8d       	ldd	r20, Y+26	; 0x1a
    346a:	5b 8d       	ldd	r21, Y+27	; 0x1b
    346c:	6c 8d       	ldd	r22, Y+28	; 0x1c
    346e:	7d 8d       	ldd	r23, Y+29	; 0x1d
    3470:	c4 16       	cp	r12, r20
    3472:	d5 06       	cpc	r13, r21
    3474:	e6 06       	cpc	r14, r22
    3476:	f7 06       	cpc	r15, r23
    3478:	08 f4       	brcc	.+2      	; 0x347c <remove_chain+0xd4>
    347a:	b7 cf       	rjmp	.-146    	; 0x33ea <remove_chain+0x42>
    347c:	09 c0       	rjmp	.+18     	; 0x3490 <remove_chain+0xe8>
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
    347e:	82 e0       	ldi	r24, 0x02	; 2
    3480:	07 c0       	rjmp	.+14     	; 0x3490 <remove_chain+0xe8>
    3482:	82 e0       	ldi	r24, 0x02	; 2
    3484:	05 c0       	rjmp	.+10     	; 0x3490 <remove_chain+0xe8>

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
    3486:	80 e0       	ldi	r24, 0x00	; 0
    3488:	03 c0       	rjmp	.+6      	; 0x3490 <remove_chain+0xe8>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    348a:	82 e0       	ldi	r24, 0x02	; 2
    348c:	01 c0       	rjmp	.+2      	; 0x3490 <remove_chain+0xe8>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    348e:	81 e0       	ldi	r24, 0x01	; 1
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
    3490:	df 91       	pop	r29
    3492:	cf 91       	pop	r28
    3494:	1f 91       	pop	r17
    3496:	0f 91       	pop	r16
    3498:	ff 90       	pop	r15
    349a:	ef 90       	pop	r14
    349c:	df 90       	pop	r13
    349e:	cf 90       	pop	r12
    34a0:	bf 90       	pop	r11
    34a2:	af 90       	pop	r10
    34a4:	9f 90       	pop	r9
    34a6:	8f 90       	pop	r8
    34a8:	7f 90       	pop	r7
    34aa:	08 95       	ret

000034ac <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
    34ac:	88 23       	and	r24, r24
    34ae:	91 f4       	brne	.+36     	; 0x34d4 <f_mount+0x28>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
    34b0:	e0 91 23 04 	lds	r30, 0x0423
    34b4:	f0 91 24 04 	lds	r31, 0x0424

	if (rfs) {
    34b8:	30 97       	sbiw	r30, 0x00	; 0
    34ba:	09 f0       	breq	.+2      	; 0x34be <f_mount+0x12>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
    34bc:	10 82       	st	Z, r1
	}

	if (fs) {
    34be:	61 15       	cp	r22, r1
    34c0:	71 05       	cpc	r23, r1
    34c2:	11 f0       	breq	.+4      	; 0x34c8 <f_mount+0x1c>
		fs->fs_type = 0;		/* Clear new fs object */
    34c4:	fb 01       	movw	r30, r22
    34c6:	10 82       	st	Z, r1
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
    34c8:	70 93 24 04 	sts	0x0424, r23
    34cc:	60 93 23 04 	sts	0x0423, r22

	return FR_OK;
    34d0:	80 e0       	ldi	r24, 0x00	; 0
    34d2:	08 95       	ret
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
    34d4:	8b e0       	ldi	r24, 0x0B	; 11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
    34d6:	08 95       	ret

000034d8 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    34d8:	4f 92       	push	r4
    34da:	5f 92       	push	r5
    34dc:	6f 92       	push	r6
    34de:	7f 92       	push	r7
    34e0:	8f 92       	push	r8
    34e2:	9f 92       	push	r9
    34e4:	af 92       	push	r10
    34e6:	bf 92       	push	r11
    34e8:	cf 92       	push	r12
    34ea:	df 92       	push	r13
    34ec:	ef 92       	push	r14
    34ee:	ff 92       	push	r15
    34f0:	0f 93       	push	r16
    34f2:	1f 93       	push	r17
    34f4:	cf 93       	push	r28
    34f6:	df 93       	push	r29
    34f8:	cd b7       	in	r28, 0x3d	; 61
    34fa:	de b7       	in	r29, 0x3e	; 62
    34fc:	a4 97       	sbiw	r28, 0x24	; 36
    34fe:	0f b6       	in	r0, 0x3f	; 63
    3500:	f8 94       	cli
    3502:	de bf       	out	0x3e, r29	; 62
    3504:	0f be       	out	0x3f, r0	; 63
    3506:	cd bf       	out	0x3d, r28	; 61
    3508:	7c 01       	movw	r14, r24
    350a:	7c a3       	lds	r23, 0x5c
    350c:	6b a3       	lds	r22, 0x5b
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    350e:	00 97       	sbiw	r24, 0x00	; 0
    3510:	09 f4       	brne	.+2      	; 0x3514 <f_open+0x3c>
    3512:	ea c0       	rjmp	.+468    	; 0x36e8 <f_open+0x210>
	fp->fs = 0;			/* Clear file object */
    3514:	fc 01       	movw	r30, r24
    3516:	11 82       	std	Z+1, r1	; 0x01
    3518:	10 82       	st	Z, r1

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    351a:	04 2f       	mov	r16, r20
    351c:	0f 71       	andi	r16, 0x1F	; 31
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
    351e:	4e 71       	andi	r20, 0x1E	; 30
    3520:	ce 01       	movw	r24, r28
    3522:	83 96       	adiw	r24, 0x23	; 35
    3524:	be 01       	movw	r22, r28
    3526:	6f 5f       	subi	r22, 0xFF	; 255
    3528:	7f 4f       	sbci	r23, 0xFF	; 255
    352a:	0e 94 ed 0b 	call	0x17da	; 0x17da <chk_mounted>
    352e:	18 2f       	mov	r17, r24
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res == FR_OK) {
    3530:	88 23       	and	r24, r24
    3532:	09 f0       	breq	.+2      	; 0x3536 <f_open+0x5e>
    3534:	da c0       	rjmp	.+436    	; 0x36ea <f_open+0x212>
		INIT_BUF(dj);
    3536:	ce 01       	movw	r24, r28
    3538:	47 96       	adiw	r24, 0x17	; 23
    353a:	9e 8b       	std	Y+22, r25	; 0x16
    353c:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    353e:	6b a1       	lds	r22, 0x4b
    3540:	7c a1       	lds	r23, 0x4c
    3542:	ce 01       	movw	r24, r28
    3544:	01 96       	adiw	r24, 0x01	; 1
    3546:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <follow_path>
		dir = dj.dir;
    354a:	cb 88       	ldd	r12, Y+19	; 0x13
    354c:	dc 88       	ldd	r13, Y+20	; 0x14
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
    354e:	88 23       	and	r24, r24
    3550:	21 f4       	brne	.+8      	; 0x355a <f_open+0x82>
			if (!dir)	/* Current dir itself */
    3552:	c1 14       	cp	r12, r1
    3554:	d1 04       	cpc	r13, r1
    3556:	09 f4       	brne	.+2      	; 0x355a <f_open+0x82>
				res = FR_INVALID_NAME;
    3558:	86 e0       	ldi	r24, 0x06	; 6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    355a:	40 2f       	mov	r20, r16
    355c:	50 e0       	ldi	r21, 0x00	; 0
    355e:	9a 01       	movw	r18, r20
    3560:	2c 71       	andi	r18, 0x1C	; 28
    3562:	30 70       	andi	r19, 0x00	; 0
    3564:	21 15       	cp	r18, r1
    3566:	31 05       	cpc	r19, r1
    3568:	09 f4       	brne	.+2      	; 0x356c <f_open+0x94>
    356a:	5b c0       	rjmp	.+182    	; 0x3622 <f_open+0x14a>
			DWORD dw, cl;

			if (res != FR_OK) {					/* No file, create new */
    356c:	88 23       	and	r24, r24
    356e:	71 f0       	breq	.+28     	; 0x358c <f_open+0xb4>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    3570:	84 30       	cpi	r24, 0x04	; 4
    3572:	09 f0       	breq	.+2      	; 0x3576 <f_open+0x9e>
    3574:	b7 c0       	rjmp	.+366    	; 0x36e4 <f_open+0x20c>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
    3576:	ce 01       	movw	r24, r28
    3578:	01 96       	adiw	r24, 0x01	; 1
    357a:	0e 94 43 19 	call	0x3286	; 0x3286 <dir_register>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
    357e:	cb 88       	ldd	r12, Y+19	; 0x13
    3580:	dc 88       	ldd	r13, Y+20	; 0x14
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    3582:	88 23       	and	r24, r24
    3584:	09 f0       	breq	.+2      	; 0x3588 <f_open+0xb0>
    3586:	ae c0       	rjmp	.+348    	; 0x36e4 <f_open+0x20c>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
    3588:	08 60       	ori	r16, 0x08	; 8
    358a:	07 c0       	rjmp	.+14     	; 0x359a <f_open+0xc2>
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    358c:	f6 01       	movw	r30, r12
    358e:	83 85       	ldd	r24, Z+11	; 0x0b
    3590:	81 71       	andi	r24, 0x11	; 17
    3592:	09 f0       	breq	.+2      	; 0x3596 <f_open+0xbe>
    3594:	c2 c0       	rjmp	.+388    	; 0x371a <f_open+0x242>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    3596:	02 fd       	sbrc	r16, 2
    3598:	c2 c0       	rjmp	.+388    	; 0x371e <f_open+0x246>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    359a:	03 ff       	sbrs	r16, 3
    359c:	c6 c0       	rjmp	.+396    	; 0x372a <f_open+0x252>
				dw = get_fattime();					/* Created time */
    359e:	0e 94 50 11 	call	0x22a0	; 0x22a0 <get_fattime>
				ST_DWORD(dir+DIR_CrtTime, dw);
    35a2:	f6 01       	movw	r30, r12
    35a4:	66 87       	std	Z+14, r22	; 0x0e
    35a6:	77 87       	std	Z+15, r23	; 0x0f
    35a8:	80 8b       	std	Z+16, r24	; 0x10
    35aa:	91 8b       	std	Z+17, r25	; 0x11
				dir[DIR_Attr] = 0;					/* Reset attribute */
    35ac:	13 86       	std	Z+11, r1	; 0x0b
				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
    35ae:	14 8e       	std	Z+28, r1	; 0x1c
    35b0:	15 8e       	std	Z+29, r1	; 0x1d
    35b2:	16 8e       	std	Z+30, r1	; 0x1e
    35b4:	17 8e       	std	Z+31, r1	; 0x1f
				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
    35b6:	89 81       	ldd	r24, Y+1	; 0x01
    35b8:	9a 81       	ldd	r25, Y+2	; 0x02
    35ba:	b6 01       	movw	r22, r12
    35bc:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ld_clust>
    35c0:	4b 01       	movw	r8, r22
    35c2:	5c 01       	movw	r10, r24
				st_clust(dir, 0);					/* cluster = 0 */
    35c4:	c6 01       	movw	r24, r12
    35c6:	40 e0       	ldi	r20, 0x00	; 0
    35c8:	50 e0       	ldi	r21, 0x00	; 0
    35ca:	ba 01       	movw	r22, r20
    35cc:	0e 94 95 0a 	call	0x152a	; 0x152a <st_clust>
				dj.fs->wflag = 1;
    35d0:	e9 81       	ldd	r30, Y+1	; 0x01
    35d2:	fa 81       	ldd	r31, Y+2	; 0x02
    35d4:	81 e0       	ldi	r24, 0x01	; 1
    35d6:	84 83       	std	Z+4, r24	; 0x04
				if (cl) {							/* Remove the cluster chain if exist */
    35d8:	81 14       	cp	r8, r1
    35da:	91 04       	cpc	r9, r1
    35dc:	a1 04       	cpc	r10, r1
    35de:	b1 04       	cpc	r11, r1
    35e0:	09 f4       	brne	.+2      	; 0x35e4 <f_open+0x10c>
    35e2:	a3 c0       	rjmp	.+326    	; 0x372a <f_open+0x252>
					dw = dj.fs->winsect;
    35e4:	46 a4       	lds	r20, 0xa6
    35e6:	57 a4       	lds	r21, 0xa7
    35e8:	60 a8       	sts	0x00, r22
    35ea:	71 a8       	sts	0x81, r23
					res = remove_chain(dj.fs, cl);
    35ec:	cf 01       	movw	r24, r30
    35ee:	b5 01       	movw	r22, r10
    35f0:	a4 01       	movw	r20, r8
    35f2:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <remove_chain>
					if (res == FR_OK) {
    35f6:	88 23       	and	r24, r24
    35f8:	09 f0       	breq	.+2      	; 0x35fc <f_open+0x124>
    35fa:	74 c0       	rjmp	.+232    	; 0x36e4 <f_open+0x20c>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    35fc:	e9 81       	ldd	r30, Y+1	; 0x01
    35fe:	fa 81       	ldd	r31, Y+2	; 0x02
    3600:	d5 01       	movw	r26, r10
    3602:	c4 01       	movw	r24, r8
    3604:	01 97       	sbiw	r24, 0x01	; 1
    3606:	a1 09       	sbc	r26, r1
    3608:	b1 09       	sbc	r27, r1
    360a:	82 87       	std	Z+10, r24	; 0x0a
    360c:	93 87       	std	Z+11, r25	; 0x0b
    360e:	a4 87       	std	Z+12, r26	; 0x0c
    3610:	b5 87       	std	Z+13, r27	; 0x0d
						res = move_window(dj.fs, dw);
    3612:	cf 01       	movw	r24, r30
    3614:	b3 01       	movw	r22, r6
    3616:	a2 01       	movw	r20, r4
    3618:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
    361c:	88 23       	and	r24, r24
    361e:	69 f0       	breq	.+26     	; 0x363a <f_open+0x162>
    3620:	61 c0       	rjmp	.+194    	; 0x36e4 <f_open+0x20c>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {						/* Follow succeeded */
    3622:	88 23       	and	r24, r24
    3624:	09 f0       	breq	.+2      	; 0x3628 <f_open+0x150>
    3626:	5e c0       	rjmp	.+188    	; 0x36e4 <f_open+0x20c>
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    3628:	f6 01       	movw	r30, r12
    362a:	83 85       	ldd	r24, Z+11	; 0x0b
    362c:	84 fd       	sbrc	r24, 4
    362e:	79 c0       	rjmp	.+242    	; 0x3722 <f_open+0x24a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    3630:	01 ff       	sbrs	r16, 1
    3632:	7b c0       	rjmp	.+246    	; 0x372a <f_open+0x252>
    3634:	80 fd       	sbrc	r24, 0
    3636:	77 c0       	rjmp	.+238    	; 0x3726 <f_open+0x24e>
    3638:	78 c0       	rjmp	.+240    	; 0x372a <f_open+0x252>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
    363a:	00 62       	ori	r16, 0x20	; 32
			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
    363c:	a9 80       	ldd	r10, Y+1	; 0x01
    363e:	ba 80       	ldd	r11, Y+2	; 0x02
    3640:	f5 01       	movw	r30, r10
    3642:	86 a5       	lds	r24, 0x66
    3644:	97 a5       	lds	r25, 0x67
    3646:	a0 a9       	sts	0x40, r26
    3648:	b1 a9       	sts	0x41, r27
    364a:	f7 01       	movw	r30, r14
    364c:	82 8f       	std	Z+26, r24	; 0x1a
    364e:	93 8f       	std	Z+27, r25	; 0x1b
    3650:	a4 8f       	std	Z+28, r26	; 0x1c
    3652:	b5 8f       	std	Z+29, r27	; 0x1d
			fp->dir_ptr = dir;
    3654:	d7 8e       	std	Z+31, r13	; 0x1f
    3656:	c6 8e       	std	Z+30, r12	; 0x1e
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
    3658:	04 83       	std	Z+4, r16	; 0x04
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
    365a:	c5 01       	movw	r24, r10
    365c:	b6 01       	movw	r22, r12
    365e:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ld_clust>
    3662:	dc 01       	movw	r26, r24
    3664:	cb 01       	movw	r24, r22
    3666:	f7 01       	movw	r30, r14
    3668:	86 87       	std	Z+14, r24	; 0x0e
    366a:	97 87       	std	Z+15, r25	; 0x0f
    366c:	a0 8b       	std	Z+16, r26	; 0x10
    366e:	b1 8b       	std	Z+17, r27	; 0x11
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    3670:	f6 01       	movw	r30, r12
    3672:	87 8d       	ldd	r24, Z+31	; 0x1f
    3674:	90 e0       	ldi	r25, 0x00	; 0
    3676:	a0 e0       	ldi	r26, 0x00	; 0
    3678:	b0 e0       	ldi	r27, 0x00	; 0
    367a:	78 2f       	mov	r23, r24
    367c:	66 27       	eor	r22, r22
    367e:	55 27       	eor	r21, r21
    3680:	44 27       	eor	r20, r20
    3682:	86 8d       	ldd	r24, Z+30	; 0x1e
    3684:	90 e0       	ldi	r25, 0x00	; 0
    3686:	a0 e0       	ldi	r26, 0x00	; 0
    3688:	b0 e0       	ldi	r27, 0x00	; 0
    368a:	dc 01       	movw	r26, r24
    368c:	99 27       	eor	r25, r25
    368e:	88 27       	eor	r24, r24
    3690:	48 2b       	or	r20, r24
    3692:	59 2b       	or	r21, r25
    3694:	6a 2b       	or	r22, r26
    3696:	7b 2b       	or	r23, r27
    3698:	84 8d       	ldd	r24, Z+28	; 0x1c
    369a:	90 e0       	ldi	r25, 0x00	; 0
    369c:	a0 e0       	ldi	r26, 0x00	; 0
    369e:	b0 e0       	ldi	r27, 0x00	; 0
    36a0:	48 2b       	or	r20, r24
    36a2:	59 2b       	or	r21, r25
    36a4:	6a 2b       	or	r22, r26
    36a6:	7b 2b       	or	r23, r27
    36a8:	95 8d       	ldd	r25, Z+29	; 0x1d
    36aa:	80 e0       	ldi	r24, 0x00	; 0
    36ac:	a0 e0       	ldi	r26, 0x00	; 0
    36ae:	b0 e0       	ldi	r27, 0x00	; 0
    36b0:	84 2b       	or	r24, r20
    36b2:	95 2b       	or	r25, r21
    36b4:	a6 2b       	or	r26, r22
    36b6:	b7 2b       	or	r27, r23
    36b8:	f7 01       	movw	r30, r14
    36ba:	82 87       	std	Z+10, r24	; 0x0a
    36bc:	93 87       	std	Z+11, r25	; 0x0b
    36be:	a4 87       	std	Z+12, r26	; 0x0c
    36c0:	b5 87       	std	Z+13, r27	; 0x0d
			fp->fptr = 0;						/* File pointer */
    36c2:	16 82       	std	Z+6, r1	; 0x06
    36c4:	17 82       	std	Z+7, r1	; 0x07
    36c6:	10 86       	std	Z+8, r1	; 0x08
    36c8:	11 86       	std	Z+9, r1	; 0x09
			fp->dsect = 0;
    36ca:	16 8a       	std	Z+22, r1	; 0x16
    36cc:	17 8a       	std	Z+23, r1	; 0x17
    36ce:	10 8e       	std	Z+24, r1	; 0x18
    36d0:	11 8e       	std	Z+25, r1	; 0x19
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    36d2:	b1 82       	std	Z+1, r11	; 0x01
    36d4:	a0 82       	st	Z, r10
    36d6:	f5 01       	movw	r30, r10
    36d8:	86 81       	ldd	r24, Z+6	; 0x06
    36da:	97 81       	ldd	r25, Z+7	; 0x07
    36dc:	f7 01       	movw	r30, r14
    36de:	93 83       	std	Z+3, r25	; 0x03
    36e0:	82 83       	std	Z+2, r24	; 0x02
    36e2:	03 c0       	rjmp	.+6      	; 0x36ea <f_open+0x212>
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    36e4:	18 2f       	mov	r17, r24
    36e6:	01 c0       	rjmp	.+2      	; 0x36ea <f_open+0x212>
    36e8:	19 e0       	ldi	r17, 0x09	; 9
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
		}
	}

	LEAVE_FF(dj.fs, res);
}
    36ea:	81 2f       	mov	r24, r17
    36ec:	a4 96       	adiw	r28, 0x24	; 36
    36ee:	0f b6       	in	r0, 0x3f	; 63
    36f0:	f8 94       	cli
    36f2:	de bf       	out	0x3e, r29	; 62
    36f4:	0f be       	out	0x3f, r0	; 63
    36f6:	cd bf       	out	0x3d, r28	; 61
    36f8:	df 91       	pop	r29
    36fa:	cf 91       	pop	r28
    36fc:	1f 91       	pop	r17
    36fe:	0f 91       	pop	r16
    3700:	ff 90       	pop	r15
    3702:	ef 90       	pop	r14
    3704:	df 90       	pop	r13
    3706:	cf 90       	pop	r12
    3708:	bf 90       	pop	r11
    370a:	af 90       	pop	r10
    370c:	9f 90       	pop	r9
    370e:	8f 90       	pop	r8
    3710:	7f 90       	pop	r7
    3712:	6f 90       	pop	r6
    3714:	5f 90       	pop	r5
    3716:	4f 90       	pop	r4
    3718:	08 95       	ret
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
					res = FR_DENIED;
    371a:	87 e0       	ldi	r24, 0x07	; 7
    371c:	e3 cf       	rjmp	.-58     	; 0x36e4 <f_open+0x20c>
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
    371e:	88 e0       	ldi	r24, 0x08	; 8
    3720:	e1 cf       	rjmp	.-62     	; 0x36e4 <f_open+0x20c>
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {						/* Follow succeeded */
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
					res = FR_NO_FILE;
    3722:	84 e0       	ldi	r24, 0x04	; 4
    3724:	df cf       	rjmp	.-66     	; 0x36e4 <f_open+0x20c>
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
    3726:	87 e0       	ldi	r24, 0x07	; 7
    3728:	dd cf       	rjmp	.-70     	; 0x36e4 <f_open+0x20c>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
    372a:	03 ff       	sbrs	r16, 3
    372c:	87 cf       	rjmp	.-242    	; 0x363c <f_open+0x164>
    372e:	85 cf       	rjmp	.-246    	; 0x363a <f_open+0x162>

00003730 <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
    3730:	2f 92       	push	r2
    3732:	3f 92       	push	r3
    3734:	4f 92       	push	r4
    3736:	5f 92       	push	r5
    3738:	6f 92       	push	r6
    373a:	7f 92       	push	r7
    373c:	8f 92       	push	r8
    373e:	9f 92       	push	r9
    3740:	af 92       	push	r10
    3742:	bf 92       	push	r11
    3744:	cf 92       	push	r12
    3746:	df 92       	push	r13
    3748:	ef 92       	push	r14
    374a:	ff 92       	push	r15
    374c:	0f 93       	push	r16
    374e:	1f 93       	push	r17
    3750:	cf 93       	push	r28
    3752:	df 93       	push	r29
    3754:	cd b7       	in	r28, 0x3d	; 61
    3756:	de b7       	in	r29, 0x3e	; 62
    3758:	29 97       	sbiw	r28, 0x09	; 9
    375a:	0f b6       	in	r0, 0x3f	; 63
    375c:	f8 94       	cli
    375e:	de bf       	out	0x3e, r29	; 62
    3760:	0f be       	out	0x3f, r0	; 63
    3762:	cd bf       	out	0x3d, r28	; 61
    3764:	9c 83       	std	Y+4, r25	; 0x04
    3766:	8b 83       	std	Y+3, r24	; 0x03
    3768:	a6 2e       	mov	r10, r22
    376a:	97 2e       	mov	r9, r23
    376c:	c2 2e       	mov	r12, r18
    376e:	f3 2e       	mov	r15, r19
    3770:	e4 2e       	mov	r14, r20
    3772:	d5 2e       	mov	r13, r21
    3774:	18 01       	movw	r2, r16
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Clear read byte counter */
    3776:	d8 01       	movw	r26, r16
    3778:	1d 92       	st	X+, r1
    377a:	1d 92       	st	X+, r1
    377c:	1d 92       	st	X+, r1
    377e:	1c 92       	st	X, r1
    3780:	13 97       	sbiw	r26, 0x03	; 3

	res = validate(fp);							/* Check validity */
    3782:	0e 94 30 0b 	call	0x1660	; 0x1660 <validate>
    3786:	b8 2e       	mov	r11, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3788:	88 23       	and	r24, r24
    378a:	09 f0       	breq	.+2      	; 0x378e <f_read+0x5e>
    378c:	e1 c1       	rjmp	.+962    	; 0x3b50 <f_read+0x420>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
    378e:	eb 81       	ldd	r30, Y+3	; 0x03
    3790:	fc 81       	ldd	r31, Y+4	; 0x04
    3792:	84 81       	ldd	r24, Z+4	; 0x04
    3794:	88 23       	and	r24, r24
    3796:	0c f4       	brge	.+2      	; 0x379a <f_read+0x6a>
    3798:	d3 c1       	rjmp	.+934    	; 0x3b40 <f_read+0x410>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    379a:	80 ff       	sbrs	r24, 0
    379c:	d5 c1       	rjmp	.+938    	; 0x3b48 <f_read+0x418>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
    379e:	42 85       	ldd	r20, Z+10	; 0x0a
    37a0:	53 85       	ldd	r21, Z+11	; 0x0b
    37a2:	64 85       	ldd	r22, Z+12	; 0x0c
    37a4:	75 85       	ldd	r23, Z+13	; 0x0d
    37a6:	86 81       	ldd	r24, Z+6	; 0x06
    37a8:	97 81       	ldd	r25, Z+7	; 0x07
    37aa:	a0 85       	ldd	r26, Z+8	; 0x08
    37ac:	b1 85       	ldd	r27, Z+9	; 0x09
    37ae:	48 1b       	sub	r20, r24
    37b0:	59 0b       	sbc	r21, r25
    37b2:	6a 0b       	sbc	r22, r26
    37b4:	7b 0b       	sbc	r23, r27

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    37b6:	4c 2c       	mov	r4, r12
    37b8:	5f 2c       	mov	r5, r15
    37ba:	6e 2c       	mov	r6, r14
    37bc:	7d 2c       	mov	r7, r13
    37be:	44 15       	cp	r20, r4
    37c0:	55 05       	cpc	r21, r5
    37c2:	66 05       	cpc	r22, r6
    37c4:	77 05       	cpc	r23, r7
    37c6:	10 f4       	brcc	.+4      	; 0x37cc <f_read+0x9c>
    37c8:	2a 01       	movw	r4, r20
    37ca:	3b 01       	movw	r6, r22
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    37cc:	41 14       	cp	r4, r1
    37ce:	51 04       	cpc	r5, r1
    37d0:	61 04       	cpc	r6, r1
    37d2:	71 04       	cpc	r7, r1
    37d4:	09 f4       	brne	.+2      	; 0x37d8 <f_read+0xa8>
    37d6:	bc c1       	rjmp	.+888    	; 0x3b50 <f_read+0x420>
    37d8:	a9 82       	std	Y+1, r10	; 0x01
    37da:	9a 82       	std	Y+2, r9	; 0x02
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    37dc:	0b 81       	ldd	r16, Y+3	; 0x03
    37de:	1c 81       	ldd	r17, Y+4	; 0x04
    37e0:	00 5e       	subi	r16, 0xE0	; 224
    37e2:	1f 4f       	sbci	r17, 0xFF	; 255
    37e4:	1e 83       	std	Y+6, r17	; 0x06
    37e6:	0d 83       	std	Y+5, r16	; 0x05
    37e8:	bf 82       	std	Y+7, r11	; 0x07
    37ea:	2b 81       	ldd	r18, Y+3	; 0x03
    37ec:	3c 81       	ldd	r19, Y+4	; 0x04
    37ee:	39 87       	std	Y+9, r19	; 0x09
    37f0:	28 87       	std	Y+8, r18	; 0x08
    37f2:	3c 82       	std	Y+4, r3	; 0x04
    37f4:	2b 82       	std	Y+3, r2	; 0x03
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    37f6:	a8 85       	ldd	r26, Y+8	; 0x08
    37f8:	b9 85       	ldd	r27, Y+9	; 0x09
    37fa:	16 96       	adiw	r26, 0x06	; 6
    37fc:	4d 91       	ld	r20, X+
    37fe:	5d 91       	ld	r21, X+
    3800:	6d 91       	ld	r22, X+
    3802:	7c 91       	ld	r23, X
    3804:	19 97       	sbiw	r26, 0x09	; 9
    3806:	db 01       	movw	r26, r22
    3808:	ca 01       	movw	r24, r20
    380a:	91 70       	andi	r25, 0x01	; 1
    380c:	a0 70       	andi	r26, 0x00	; 0
    380e:	b0 70       	andi	r27, 0x00	; 0
    3810:	00 97       	sbiw	r24, 0x00	; 0
    3812:	a1 05       	cpc	r26, r1
    3814:	b1 05       	cpc	r27, r1
    3816:	09 f0       	breq	.+2      	; 0x381a <f_read+0xea>
    3818:	3f c1       	rjmp	.+638    	; 0x3a98 <f_read+0x368>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    381a:	a8 85       	ldd	r26, Y+8	; 0x08
    381c:	b9 85       	ldd	r27, Y+9	; 0x09
    381e:	ed 91       	ld	r30, X+
    3820:	fc 91       	ld	r31, X
    3822:	db 01       	movw	r26, r22
    3824:	ca 01       	movw	r24, r20
    3826:	07 2e       	mov	r0, r23
    3828:	79 e0       	ldi	r23, 0x09	; 9
    382a:	b6 95       	lsr	r27
    382c:	a7 95       	ror	r26
    382e:	97 95       	ror	r25
    3830:	87 95       	ror	r24
    3832:	7a 95       	dec	r23
    3834:	d1 f7       	brne	.-12     	; 0x382a <f_read+0xfa>
    3836:	70 2d       	mov	r23, r0
    3838:	02 81       	ldd	r16, Z+2	; 0x02
    383a:	01 50       	subi	r16, 0x01	; 1
    383c:	08 23       	and	r16, r24
			if (!csect) {						/* On the cluster boundary? */
    383e:	09 f0       	breq	.+2      	; 0x3842 <f_read+0x112>
    3840:	44 c0       	rjmp	.+136    	; 0x38ca <f_read+0x19a>
				if (fp->fptr == 0) {			/* On the top of the file? */
    3842:	41 15       	cp	r20, r1
    3844:	51 05       	cpc	r21, r1
    3846:	61 05       	cpc	r22, r1
    3848:	71 05       	cpc	r23, r1
    384a:	39 f4       	brne	.+14     	; 0x385a <f_read+0x12a>
					clst = fp->sclust;			/* Follow from the origin */
    384c:	e8 85       	ldd	r30, Y+8	; 0x08
    384e:	f9 85       	ldd	r31, Y+9	; 0x09
    3850:	86 85       	ldd	r24, Z+14	; 0x0e
    3852:	97 85       	ldd	r25, Z+15	; 0x0f
    3854:	a0 89       	ldd	r26, Z+16	; 0x10
    3856:	b1 89       	ldd	r27, Z+17	; 0x11
    3858:	0d c0       	rjmp	.+26     	; 0x3874 <f_read+0x144>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    385a:	a8 85       	ldd	r26, Y+8	; 0x08
    385c:	b9 85       	ldd	r27, Y+9	; 0x09
    385e:	52 96       	adiw	r26, 0x12	; 18
    3860:	4d 91       	ld	r20, X+
    3862:	5d 91       	ld	r21, X+
    3864:	6d 91       	ld	r22, X+
    3866:	7c 91       	ld	r23, X
    3868:	55 97       	sbiw	r26, 0x15	; 21
    386a:	cf 01       	movw	r24, r30
    386c:	0e 94 8a 11 	call	0x2314	; 0x2314 <get_fat>
    3870:	dc 01       	movw	r26, r24
    3872:	cb 01       	movw	r24, r22
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    3874:	82 30       	cpi	r24, 0x02	; 2
    3876:	91 05       	cpc	r25, r1
    3878:	a1 05       	cpc	r26, r1
    387a:	b1 05       	cpc	r27, r1
    387c:	48 f4       	brcc	.+18     	; 0x3890 <f_read+0x160>
    387e:	e8 85       	ldd	r30, Y+8	; 0x08
    3880:	f9 85       	ldd	r31, Y+9	; 0x09
    3882:	84 81       	ldd	r24, Z+4	; 0x04
    3884:	80 68       	ori	r24, 0x80	; 128
    3886:	84 83       	std	Z+4, r24	; 0x04
    3888:	bb 24       	eor	r11, r11
    388a:	68 94       	set
    388c:	b1 f8       	bld	r11, 1
    388e:	60 c1       	rjmp	.+704    	; 0x3b50 <f_read+0x420>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3890:	8f 3f       	cpi	r24, 0xFF	; 255
    3892:	ff ef       	ldi	r31, 0xFF	; 255
    3894:	9f 07       	cpc	r25, r31
    3896:	ff ef       	ldi	r31, 0xFF	; 255
    3898:	af 07       	cpc	r26, r31
    389a:	ff ef       	ldi	r31, 0xFF	; 255
    389c:	bf 07       	cpc	r27, r31
    389e:	79 f4       	brne	.+30     	; 0x38be <f_read+0x18e>
    38a0:	08 85       	ldd	r16, Y+8	; 0x08
    38a2:	19 85       	ldd	r17, Y+9	; 0x09
    38a4:	1c 83       	std	Y+4, r17	; 0x04
    38a6:	0b 83       	std	Y+3, r16	; 0x03
    38a8:	d8 01       	movw	r26, r16
    38aa:	14 96       	adiw	r26, 0x04	; 4
    38ac:	8c 91       	ld	r24, X
    38ae:	14 97       	sbiw	r26, 0x04	; 4
    38b0:	80 68       	ori	r24, 0x80	; 128
    38b2:	14 96       	adiw	r26, 0x04	; 4
    38b4:	8c 93       	st	X, r24
    38b6:	14 97       	sbiw	r26, 0x04	; 4
    38b8:	bb 24       	eor	r11, r11
    38ba:	b3 94       	inc	r11
    38bc:	49 c1       	rjmp	.+658    	; 0x3b50 <f_read+0x420>
				fp->clust = clst;				/* Update current cluster */
    38be:	e8 85       	ldd	r30, Y+8	; 0x08
    38c0:	f9 85       	ldd	r31, Y+9	; 0x09
    38c2:	82 8b       	std	Z+18, r24	; 0x12
    38c4:	93 8b       	std	Z+19, r25	; 0x13
    38c6:	a4 8b       	std	Z+20, r26	; 0x14
    38c8:	b5 8b       	std	Z+21, r27	; 0x15
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    38ca:	a8 85       	ldd	r26, Y+8	; 0x08
    38cc:	b9 85       	ldd	r27, Y+9	; 0x09
    38ce:	2d 90       	ld	r2, X+
    38d0:	3c 90       	ld	r3, X
    38d2:	11 97       	sbiw	r26, 0x01	; 1
    38d4:	52 96       	adiw	r26, 0x12	; 18
    38d6:	4d 91       	ld	r20, X+
    38d8:	5d 91       	ld	r21, X+
    38da:	6d 91       	ld	r22, X+
    38dc:	7c 91       	ld	r23, X
    38de:	55 97       	sbiw	r26, 0x15	; 21
    38e0:	c1 01       	movw	r24, r2
    38e2:	0e 94 54 11 	call	0x22a8	; 0x22a8 <clust2sect>
    38e6:	dc 01       	movw	r26, r24
    38e8:	cb 01       	movw	r24, r22
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    38ea:	00 97       	sbiw	r24, 0x00	; 0
    38ec:	a1 05       	cpc	r26, r1
    38ee:	b1 05       	cpc	r27, r1
    38f0:	49 f4       	brne	.+18     	; 0x3904 <f_read+0x1d4>
    38f2:	e8 85       	ldd	r30, Y+8	; 0x08
    38f4:	f9 85       	ldd	r31, Y+9	; 0x09
    38f6:	84 81       	ldd	r24, Z+4	; 0x04
    38f8:	80 68       	ori	r24, 0x80	; 128
    38fa:	84 83       	std	Z+4, r24	; 0x04
    38fc:	bb 24       	eor	r11, r11
    38fe:	68 94       	set
    3900:	b1 f8       	bld	r11, 1
    3902:	26 c1       	rjmp	.+588    	; 0x3b50 <f_read+0x420>
			sect += csect;
    3904:	40 2f       	mov	r20, r16
    3906:	50 e0       	ldi	r21, 0x00	; 0
    3908:	60 e0       	ldi	r22, 0x00	; 0
    390a:	70 e0       	ldi	r23, 0x00	; 0
    390c:	4c 01       	movw	r8, r24
    390e:	5d 01       	movw	r10, r26
    3910:	84 0e       	add	r8, r20
    3912:	95 1e       	adc	r9, r21
    3914:	a6 1e       	adc	r10, r22
    3916:	b7 1e       	adc	r11, r23
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    3918:	73 01       	movw	r14, r6
    391a:	62 01       	movw	r12, r4
    391c:	0b 2e       	mov	r0, r27
    391e:	b9 e0       	ldi	r27, 0x09	; 9
    3920:	f6 94       	lsr	r15
    3922:	e7 94       	ror	r14
    3924:	d7 94       	ror	r13
    3926:	c7 94       	ror	r12
    3928:	ba 95       	dec	r27
    392a:	d1 f7       	brne	.-12     	; 0x3920 <f_read+0x1f0>
    392c:	b0 2d       	mov	r27, r0
			if (cc) {							/* Read maximum contiguous sectors directly */
    392e:	c1 14       	cp	r12, r1
    3930:	d1 04       	cpc	r13, r1
    3932:	e1 04       	cpc	r14, r1
    3934:	f1 04       	cpc	r15, r1
    3936:	09 f4       	brne	.+2      	; 0x393a <f_read+0x20a>
    3938:	60 c0       	rjmp	.+192    	; 0x39fa <f_read+0x2ca>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    393a:	d1 01       	movw	r26, r2
    393c:	12 96       	adiw	r26, 0x02	; 2
    393e:	2c 91       	ld	r18, X
    3940:	d7 01       	movw	r26, r14
    3942:	c6 01       	movw	r24, r12
    3944:	84 0f       	add	r24, r20
    3946:	95 1f       	adc	r25, r21
    3948:	a6 1f       	adc	r26, r22
    394a:	b7 1f       	adc	r27, r23
    394c:	42 2f       	mov	r20, r18
    394e:	50 e0       	ldi	r21, 0x00	; 0
    3950:	60 e0       	ldi	r22, 0x00	; 0
    3952:	70 e0       	ldi	r23, 0x00	; 0
    3954:	48 17       	cp	r20, r24
    3956:	59 07       	cpc	r21, r25
    3958:	6a 07       	cpc	r22, r26
    395a:	7b 07       	cpc	r23, r27
    395c:	48 f4       	brcc	.+18     	; 0x3970 <f_read+0x240>
					cc = fp->fs->csize - csect;
    395e:	82 2f       	mov	r24, r18
    3960:	90 e0       	ldi	r25, 0x00	; 0
    3962:	80 1b       	sub	r24, r16
    3964:	91 09       	sbc	r25, r1
    3966:	6c 01       	movw	r12, r24
    3968:	ee 24       	eor	r14, r14
    396a:	d7 fc       	sbrc	r13, 7
    396c:	e0 94       	com	r14
    396e:	fe 2c       	mov	r15, r14
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    3970:	f1 01       	movw	r30, r2
    3972:	81 81       	ldd	r24, Z+1	; 0x01
    3974:	69 81       	ldd	r22, Y+1	; 0x01
    3976:	7a 81       	ldd	r23, Y+2	; 0x02
    3978:	a5 01       	movw	r20, r10
    397a:	94 01       	movw	r18, r8
    397c:	0c 2d       	mov	r16, r12
    397e:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    3982:	88 23       	and	r24, r24
    3984:	79 f0       	breq	.+30     	; 0x39a4 <f_read+0x274>
    3986:	08 85       	ldd	r16, Y+8	; 0x08
    3988:	19 85       	ldd	r17, Y+9	; 0x09
    398a:	1c 83       	std	Y+4, r17	; 0x04
    398c:	0b 83       	std	Y+3, r16	; 0x03
					ABORT(fp->fs, FR_DISK_ERR);
    398e:	d8 01       	movw	r26, r16
    3990:	14 96       	adiw	r26, 0x04	; 4
    3992:	8c 91       	ld	r24, X
    3994:	14 97       	sbiw	r26, 0x04	; 4
    3996:	80 68       	ori	r24, 0x80	; 128
    3998:	14 96       	adiw	r26, 0x04	; 4
    399a:	8c 93       	st	X, r24
    399c:	14 97       	sbiw	r26, 0x04	; 4
    399e:	bb 24       	eor	r11, r11
    39a0:	b3 94       	inc	r11
    39a2:	d6 c0       	rjmp	.+428    	; 0x3b50 <f_read+0x420>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
    39a4:	e8 85       	ldd	r30, Y+8	; 0x08
    39a6:	f9 85       	ldd	r31, Y+9	; 0x09
    39a8:	84 81       	ldd	r24, Z+4	; 0x04
    39aa:	86 ff       	sbrs	r24, 6
    39ac:	1c c0       	rjmp	.+56     	; 0x39e6 <f_read+0x2b6>
    39ae:	86 89       	ldd	r24, Z+22	; 0x16
    39b0:	97 89       	ldd	r25, Z+23	; 0x17
    39b2:	a0 8d       	ldd	r26, Z+24	; 0x18
    39b4:	b1 8d       	ldd	r27, Z+25	; 0x19
    39b6:	88 19       	sub	r24, r8
    39b8:	99 09       	sbc	r25, r9
    39ba:	aa 09       	sbc	r26, r10
    39bc:	bb 09       	sbc	r27, r11
    39be:	8c 15       	cp	r24, r12
    39c0:	9d 05       	cpc	r25, r13
    39c2:	ae 05       	cpc	r26, r14
    39c4:	bf 05       	cpc	r27, r15
    39c6:	78 f4       	brcc	.+30     	; 0x39e6 <f_read+0x2b6>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
    39c8:	98 2f       	mov	r25, r24
    39ca:	88 27       	eor	r24, r24
    39cc:	99 0f       	add	r25, r25
    39ce:	09 81       	ldd	r16, Y+1	; 0x01
    39d0:	1a 81       	ldd	r17, Y+2	; 0x02
    39d2:	80 0f       	add	r24, r16
    39d4:	91 1f       	adc	r25, r17
    39d6:	6d 81       	ldd	r22, Y+5	; 0x05
    39d8:	7e 81       	ldd	r23, Y+6	; 0x06
    39da:	20 e0       	ldi	r18, 0x00	; 0
    39dc:	32 e0       	ldi	r19, 0x02	; 2
    39de:	40 e0       	ldi	r20, 0x00	; 0
    39e0:	50 e0       	ldi	r21, 0x00	; 0
    39e2:	0e 94 4a 0a 	call	0x1494	; 0x1494 <mem_cpy>
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    39e6:	0b 2e       	mov	r0, r27
    39e8:	b9 e0       	ldi	r27, 0x09	; 9
    39ea:	cc 0c       	add	r12, r12
    39ec:	dd 1c       	adc	r13, r13
    39ee:	ee 1c       	adc	r14, r14
    39f0:	ff 1c       	adc	r15, r15
    39f2:	ba 95       	dec	r27
    39f4:	d1 f7       	brne	.-12     	; 0x39ea <f_read+0x2ba>
    39f6:	b0 2d       	mov	r27, r0
				continue;
    39f8:	79 c0       	rjmp	.+242    	; 0x3aec <f_read+0x3bc>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
    39fa:	a8 85       	ldd	r26, Y+8	; 0x08
    39fc:	b9 85       	ldd	r27, Y+9	; 0x09
    39fe:	56 96       	adiw	r26, 0x16	; 22
    3a00:	0d 91       	ld	r16, X+
    3a02:	1d 91       	ld	r17, X+
    3a04:	2d 91       	ld	r18, X+
    3a06:	3c 91       	ld	r19, X
    3a08:	59 97       	sbiw	r26, 0x19	; 25
    3a0a:	08 15       	cp	r16, r8
    3a0c:	19 05       	cpc	r17, r9
    3a0e:	2a 05       	cpc	r18, r10
    3a10:	3b 05       	cpc	r19, r11
    3a12:	d1 f1       	breq	.+116    	; 0x3a88 <f_read+0x358>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
    3a14:	14 96       	adiw	r26, 0x04	; 4
    3a16:	8c 91       	ld	r24, X
    3a18:	14 97       	sbiw	r26, 0x04	; 4
    3a1a:	86 ff       	sbrs	r24, 6
    3a1c:	1f c0       	rjmp	.+62     	; 0x3a5c <f_read+0x32c>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3a1e:	f1 01       	movw	r30, r2
    3a20:	81 81       	ldd	r24, Z+1	; 0x01
    3a22:	6d 81       	ldd	r22, Y+5	; 0x05
    3a24:	7e 81       	ldd	r23, Y+6	; 0x06
    3a26:	a9 01       	movw	r20, r18
    3a28:	98 01       	movw	r18, r16
    3a2a:	01 e0       	ldi	r16, 0x01	; 1
    3a2c:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    3a30:	88 23       	and	r24, r24
    3a32:	79 f0       	breq	.+30     	; 0x3a52 <f_read+0x322>
    3a34:	08 85       	ldd	r16, Y+8	; 0x08
    3a36:	19 85       	ldd	r17, Y+9	; 0x09
    3a38:	1c 83       	std	Y+4, r17	; 0x04
    3a3a:	0b 83       	std	Y+3, r16	; 0x03
						ABORT(fp->fs, FR_DISK_ERR);
    3a3c:	d8 01       	movw	r26, r16
    3a3e:	14 96       	adiw	r26, 0x04	; 4
    3a40:	8c 91       	ld	r24, X
    3a42:	14 97       	sbiw	r26, 0x04	; 4
    3a44:	80 68       	ori	r24, 0x80	; 128
    3a46:	14 96       	adiw	r26, 0x04	; 4
    3a48:	8c 93       	st	X, r24
    3a4a:	14 97       	sbiw	r26, 0x04	; 4
    3a4c:	bb 24       	eor	r11, r11
    3a4e:	b3 94       	inc	r11
    3a50:	7f c0       	rjmp	.+254    	; 0x3b50 <f_read+0x420>
					fp->flag &= ~FA__DIRTY;
    3a52:	e8 85       	ldd	r30, Y+8	; 0x08
    3a54:	f9 85       	ldd	r31, Y+9	; 0x09
    3a56:	84 81       	ldd	r24, Z+4	; 0x04
    3a58:	8f 7b       	andi	r24, 0xBF	; 191
    3a5a:	84 83       	std	Z+4, r24	; 0x04
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    3a5c:	a8 85       	ldd	r26, Y+8	; 0x08
    3a5e:	b9 85       	ldd	r27, Y+9	; 0x09
    3a60:	ed 91       	ld	r30, X+
    3a62:	fc 91       	ld	r31, X
    3a64:	81 81       	ldd	r24, Z+1	; 0x01
    3a66:	6d 81       	ldd	r22, Y+5	; 0x05
    3a68:	7e 81       	ldd	r23, Y+6	; 0x06
    3a6a:	a5 01       	movw	r20, r10
    3a6c:	94 01       	movw	r18, r8
    3a6e:	01 e0       	ldi	r16, 0x01	; 1
    3a70:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    3a74:	88 23       	and	r24, r24
    3a76:	41 f0       	breq	.+16     	; 0x3a88 <f_read+0x358>
    3a78:	e8 85       	ldd	r30, Y+8	; 0x08
    3a7a:	f9 85       	ldd	r31, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3a7c:	84 81       	ldd	r24, Z+4	; 0x04
    3a7e:	80 68       	ori	r24, 0x80	; 128
    3a80:	84 83       	std	Z+4, r24	; 0x04
    3a82:	bb 24       	eor	r11, r11
    3a84:	b3 94       	inc	r11
    3a86:	64 c0       	rjmp	.+200    	; 0x3b50 <f_read+0x420>
			}
#endif
			fp->dsect = sect;
    3a88:	a8 85       	ldd	r26, Y+8	; 0x08
    3a8a:	b9 85       	ldd	r27, Y+9	; 0x09
    3a8c:	56 96       	adiw	r26, 0x16	; 22
    3a8e:	8d 92       	st	X+, r8
    3a90:	9d 92       	st	X+, r9
    3a92:	ad 92       	st	X+, r10
    3a94:	bc 92       	st	X, r11
    3a96:	59 97       	sbiw	r26, 0x19	; 25
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    3a98:	e8 85       	ldd	r30, Y+8	; 0x08
    3a9a:	f9 85       	ldd	r31, Y+9	; 0x09
    3a9c:	46 81       	ldd	r20, Z+6	; 0x06
    3a9e:	57 81       	ldd	r21, Z+7	; 0x07
    3aa0:	60 85       	ldd	r22, Z+8	; 0x08
    3aa2:	71 85       	ldd	r23, Z+9	; 0x09
    3aa4:	db 01       	movw	r26, r22
    3aa6:	ca 01       	movw	r24, r20
    3aa8:	91 70       	andi	r25, 0x01	; 1
    3aaa:	a0 70       	andi	r26, 0x00	; 0
    3aac:	b0 70       	andi	r27, 0x00	; 0
    3aae:	00 e0       	ldi	r16, 0x00	; 0
    3ab0:	12 e0       	ldi	r17, 0x02	; 2
    3ab2:	20 e0       	ldi	r18, 0x00	; 0
    3ab4:	30 e0       	ldi	r19, 0x00	; 0
    3ab6:	08 1b       	sub	r16, r24
    3ab8:	19 0b       	sbc	r17, r25
    3aba:	2a 0b       	sbc	r18, r26
    3abc:	3b 0b       	sbc	r19, r27
    3abe:	73 01       	movw	r14, r6
    3ac0:	62 01       	movw	r12, r4
    3ac2:	04 15       	cp	r16, r4
    3ac4:	15 05       	cpc	r17, r5
    3ac6:	26 05       	cpc	r18, r6
    3ac8:	37 05       	cpc	r19, r7
    3aca:	10 f4       	brcc	.+4      	; 0x3ad0 <f_read+0x3a0>
    3acc:	68 01       	movw	r12, r16
    3ace:	79 01       	movw	r14, r18
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    3ad0:	ba 01       	movw	r22, r20
    3ad2:	71 70       	andi	r23, 0x01	; 1
    3ad4:	60 5e       	subi	r22, 0xE0	; 224
    3ad6:	7f 4f       	sbci	r23, 0xFF	; 255
    3ad8:	28 85       	ldd	r18, Y+8	; 0x08
    3ada:	39 85       	ldd	r19, Y+9	; 0x09
    3adc:	62 0f       	add	r22, r18
    3ade:	73 1f       	adc	r23, r19
    3ae0:	89 81       	ldd	r24, Y+1	; 0x01
    3ae2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ae4:	a7 01       	movw	r20, r14
    3ae6:	96 01       	movw	r18, r12
    3ae8:	0e 94 4a 0a 	call	0x1494	; 0x1494 <mem_cpy>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    3aec:	89 81       	ldd	r24, Y+1	; 0x01
    3aee:	9a 81       	ldd	r25, Y+2	; 0x02
    3af0:	8c 0d       	add	r24, r12
    3af2:	9d 1d       	adc	r25, r13
    3af4:	9a 83       	std	Y+2, r25	; 0x02
    3af6:	89 83       	std	Y+1, r24	; 0x01
    3af8:	e8 85       	ldd	r30, Y+8	; 0x08
    3afa:	f9 85       	ldd	r31, Y+9	; 0x09
    3afc:	86 81       	ldd	r24, Z+6	; 0x06
    3afe:	97 81       	ldd	r25, Z+7	; 0x07
    3b00:	a0 85       	ldd	r26, Z+8	; 0x08
    3b02:	b1 85       	ldd	r27, Z+9	; 0x09
    3b04:	8c 0d       	add	r24, r12
    3b06:	9d 1d       	adc	r25, r13
    3b08:	ae 1d       	adc	r26, r14
    3b0a:	bf 1d       	adc	r27, r15
    3b0c:	86 83       	std	Z+6, r24	; 0x06
    3b0e:	97 83       	std	Z+7, r25	; 0x07
    3b10:	a0 87       	std	Z+8, r26	; 0x08
    3b12:	b1 87       	std	Z+9, r27	; 0x09
    3b14:	eb 81       	ldd	r30, Y+3	; 0x03
    3b16:	fc 81       	ldd	r31, Y+4	; 0x04
    3b18:	80 81       	ld	r24, Z
    3b1a:	91 81       	ldd	r25, Z+1	; 0x01
    3b1c:	a2 81       	ldd	r26, Z+2	; 0x02
    3b1e:	b3 81       	ldd	r27, Z+3	; 0x03
    3b20:	8c 0d       	add	r24, r12
    3b22:	9d 1d       	adc	r25, r13
    3b24:	ae 1d       	adc	r26, r14
    3b26:	bf 1d       	adc	r27, r15
    3b28:	80 83       	st	Z, r24
    3b2a:	91 83       	std	Z+1, r25	; 0x01
    3b2c:	a2 83       	std	Z+2, r26	; 0x02
    3b2e:	b3 83       	std	Z+3, r27	; 0x03
    3b30:	4c 18       	sub	r4, r12
    3b32:	5d 08       	sbc	r5, r13
    3b34:	6e 08       	sbc	r6, r14
    3b36:	7f 08       	sbc	r7, r15
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    3b38:	09 f0       	breq	.+2      	; 0x3b3c <f_read+0x40c>
    3b3a:	5d ce       	rjmp	.-838    	; 0x37f6 <f_read+0xc6>
    3b3c:	bf 80       	ldd	r11, Y+7	; 0x07
    3b3e:	08 c0       	rjmp	.+16     	; 0x3b50 <f_read+0x420>
	*br = 0;	/* Clear read byte counter */

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    3b40:	bb 24       	eor	r11, r11
    3b42:	68 94       	set
    3b44:	b1 f8       	bld	r11, 1
    3b46:	04 c0       	rjmp	.+8      	; 0x3b50 <f_read+0x420>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    3b48:	0f 2e       	mov	r0, r31
    3b4a:	f7 e0       	ldi	r31, 0x07	; 7
    3b4c:	bf 2e       	mov	r11, r31
    3b4e:	f0 2d       	mov	r31, r0
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    3b50:	8b 2d       	mov	r24, r11
    3b52:	29 96       	adiw	r28, 0x09	; 9
    3b54:	0f b6       	in	r0, 0x3f	; 63
    3b56:	f8 94       	cli
    3b58:	de bf       	out	0x3e, r29	; 62
    3b5a:	0f be       	out	0x3f, r0	; 63
    3b5c:	cd bf       	out	0x3d, r28	; 61
    3b5e:	df 91       	pop	r29
    3b60:	cf 91       	pop	r28
    3b62:	1f 91       	pop	r17
    3b64:	0f 91       	pop	r16
    3b66:	ff 90       	pop	r15
    3b68:	ef 90       	pop	r14
    3b6a:	df 90       	pop	r13
    3b6c:	cf 90       	pop	r12
    3b6e:	bf 90       	pop	r11
    3b70:	af 90       	pop	r10
    3b72:	9f 90       	pop	r9
    3b74:	8f 90       	pop	r8
    3b76:	7f 90       	pop	r7
    3b78:	6f 90       	pop	r6
    3b7a:	5f 90       	pop	r5
    3b7c:	4f 90       	pop	r4
    3b7e:	3f 90       	pop	r3
    3b80:	2f 90       	pop	r2
    3b82:	08 95       	ret

00003b84 <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
    3b84:	2f 92       	push	r2
    3b86:	3f 92       	push	r3
    3b88:	4f 92       	push	r4
    3b8a:	5f 92       	push	r5
    3b8c:	6f 92       	push	r6
    3b8e:	7f 92       	push	r7
    3b90:	8f 92       	push	r8
    3b92:	9f 92       	push	r9
    3b94:	af 92       	push	r10
    3b96:	bf 92       	push	r11
    3b98:	cf 92       	push	r12
    3b9a:	df 92       	push	r13
    3b9c:	ef 92       	push	r14
    3b9e:	ff 92       	push	r15
    3ba0:	0f 93       	push	r16
    3ba2:	1f 93       	push	r17
    3ba4:	cf 93       	push	r28
    3ba6:	df 93       	push	r29
    3ba8:	cd b7       	in	r28, 0x3d	; 61
    3baa:	de b7       	in	r29, 0x3e	; 62
    3bac:	29 97       	sbiw	r28, 0x09	; 9
    3bae:	0f b6       	in	r0, 0x3f	; 63
    3bb0:	f8 94       	cli
    3bb2:	de bf       	out	0x3e, r29	; 62
    3bb4:	0f be       	out	0x3f, r0	; 63
    3bb6:	cd bf       	out	0x3d, r28	; 61
    3bb8:	2c 01       	movw	r4, r24
    3bba:	c6 2e       	mov	r12, r22
    3bbc:	f7 2e       	mov	r15, r23
    3bbe:	49 01       	movw	r8, r18
    3bc0:	5a 01       	movw	r10, r20
    3bc2:	1a 83       	std	Y+2, r17	; 0x02
    3bc4:	09 83       	std	Y+1, r16	; 0x01
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
    3bc6:	d8 01       	movw	r26, r16
    3bc8:	1d 92       	st	X+, r1
    3bca:	1d 92       	st	X+, r1
    3bcc:	1d 92       	st	X+, r1
    3bce:	1c 92       	st	X, r1
    3bd0:	13 97       	sbiw	r26, 0x03	; 3

	res = validate(fp);						/* Check validity */
    3bd2:	0e 94 30 0b 	call	0x1660	; 0x1660 <validate>
    3bd6:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3bd8:	88 23       	and	r24, r24
    3bda:	09 f0       	breq	.+2      	; 0x3bde <f_write+0x5a>
    3bdc:	17 c2       	rjmp	.+1070   	; 0x400c <f_write+0x488>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
    3bde:	f2 01       	movw	r30, r4
    3be0:	84 81       	ldd	r24, Z+4	; 0x04
    3be2:	88 23       	and	r24, r24
    3be4:	0c f4       	brge	.+2      	; 0x3be8 <f_write+0x64>
    3be6:	0f c2       	rjmp	.+1054   	; 0x4006 <f_write+0x482>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    3be8:	81 ff       	sbrs	r24, 1
    3bea:	0f c2       	rjmp	.+1054   	; 0x400a <f_write+0x486>
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
    3bec:	82 85       	ldd	r24, Z+10	; 0x0a
    3bee:	93 85       	ldd	r25, Z+11	; 0x0b
    3bf0:	a4 85       	ldd	r26, Z+12	; 0x0c
    3bf2:	b5 85       	ldd	r27, Z+13	; 0x0d
    3bf4:	b5 01       	movw	r22, r10
    3bf6:	a4 01       	movw	r20, r8
    3bf8:	48 0f       	add	r20, r24
    3bfa:	59 1f       	adc	r21, r25
    3bfc:	6a 1f       	adc	r22, r26
    3bfe:	7b 1f       	adc	r23, r27
    3c00:	48 17       	cp	r20, r24
    3c02:	59 07       	cpc	r21, r25
    3c04:	6a 07       	cpc	r22, r26
    3c06:	7b 07       	cpc	r23, r27
    3c08:	08 f4       	brcc	.+2      	; 0x3c0c <f_write+0x88>
    3c0a:	e2 c1       	rjmp	.+964    	; 0x3fd0 <f_write+0x44c>

	for ( ;  btw;							/* Repeat until all data written */
    3c0c:	81 14       	cp	r8, r1
    3c0e:	91 04       	cpc	r9, r1
    3c10:	a1 04       	cpc	r10, r1
    3c12:	b1 04       	cpc	r11, r1
    3c14:	09 f4       	brne	.+2      	; 0x3c18 <f_write+0x94>
    3c16:	dc c1       	rjmp	.+952    	; 0x3fd0 <f_write+0x44c>
    3c18:	cb 82       	std	Y+3, r12	; 0x03
    3c1a:	fc 82       	std	Y+4, r15	; 0x04
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    3c1c:	92 01       	movw	r18, r4
    3c1e:	20 5e       	subi	r18, 0xE0	; 224
    3c20:	3f 4f       	sbci	r19, 0xFF	; 255
    3c22:	3e 83       	std	Y+6, r19	; 0x06
    3c24:	2d 83       	std	Y+5, r18	; 0x05
    3c26:	1f 83       	std	Y+7, r17	; 0x07
    3c28:	59 86       	std	Y+9, r5	; 0x09
    3c2a:	48 86       	std	Y+8, r4	; 0x08
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    3c2c:	a8 85       	ldd	r26, Y+8	; 0x08
    3c2e:	b9 85       	ldd	r27, Y+9	; 0x09
    3c30:	16 96       	adiw	r26, 0x06	; 6
    3c32:	4d 91       	ld	r20, X+
    3c34:	5d 91       	ld	r21, X+
    3c36:	6d 91       	ld	r22, X+
    3c38:	7c 91       	ld	r23, X
    3c3a:	19 97       	sbiw	r26, 0x09	; 9
    3c3c:	db 01       	movw	r26, r22
    3c3e:	ca 01       	movw	r24, r20
    3c40:	91 70       	andi	r25, 0x01	; 1
    3c42:	a0 70       	andi	r26, 0x00	; 0
    3c44:	b0 70       	andi	r27, 0x00	; 0
    3c46:	00 97       	sbiw	r24, 0x00	; 0
    3c48:	a1 05       	cpc	r26, r1
    3c4a:	b1 05       	cpc	r27, r1
    3c4c:	09 f0       	breq	.+2      	; 0x3c50 <f_write+0xcc>
    3c4e:	60 c1       	rjmp	.+704    	; 0x3f10 <f_write+0x38c>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    3c50:	e8 85       	ldd	r30, Y+8	; 0x08
    3c52:	f9 85       	ldd	r31, Y+9	; 0x09
    3c54:	20 81       	ld	r18, Z
    3c56:	31 81       	ldd	r19, Z+1	; 0x01
    3c58:	db 01       	movw	r26, r22
    3c5a:	ca 01       	movw	r24, r20
    3c5c:	07 2e       	mov	r0, r23
    3c5e:	79 e0       	ldi	r23, 0x09	; 9
    3c60:	b6 95       	lsr	r27
    3c62:	a7 95       	ror	r26
    3c64:	97 95       	ror	r25
    3c66:	87 95       	ror	r24
    3c68:	7a 95       	dec	r23
    3c6a:	d1 f7       	brne	.-12     	; 0x3c60 <f_write+0xdc>
    3c6c:	70 2d       	mov	r23, r0
    3c6e:	f9 01       	movw	r30, r18
    3c70:	12 81       	ldd	r17, Z+2	; 0x02
    3c72:	11 50       	subi	r17, 0x01	; 1
    3c74:	18 23       	and	r17, r24
			if (!csect) {					/* On the cluster boundary? */
    3c76:	09 f0       	breq	.+2      	; 0x3c7a <f_write+0xf6>
    3c78:	57 c0       	rjmp	.+174    	; 0x3d28 <f_write+0x1a4>
				if (fp->fptr == 0) {		/* On the top of the file? */
    3c7a:	41 15       	cp	r20, r1
    3c7c:	51 05       	cpc	r21, r1
    3c7e:	61 05       	cpc	r22, r1
    3c80:	71 05       	cpc	r23, r1
    3c82:	c9 f4       	brne	.+50     	; 0x3cb6 <f_write+0x132>
					clst = fp->sclust;		/* Follow from the origin */
    3c84:	e8 85       	ldd	r30, Y+8	; 0x08
    3c86:	f9 85       	ldd	r31, Y+9	; 0x09
    3c88:	86 85       	ldd	r24, Z+14	; 0x0e
    3c8a:	97 85       	ldd	r25, Z+15	; 0x0f
    3c8c:	a0 89       	ldd	r26, Z+16	; 0x10
    3c8e:	b1 89       	ldd	r27, Z+17	; 0x11
					if (clst == 0)			/* When no cluster is allocated, */
    3c90:	00 97       	sbiw	r24, 0x00	; 0
    3c92:	a1 05       	cpc	r26, r1
    3c94:	b1 05       	cpc	r27, r1
    3c96:	09 f5       	brne	.+66     	; 0x3cda <f_write+0x156>
						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    3c98:	c9 01       	movw	r24, r18
    3c9a:	40 e0       	ldi	r20, 0x00	; 0
    3c9c:	50 e0       	ldi	r21, 0x00	; 0
    3c9e:	ba 01       	movw	r22, r20
    3ca0:	0e 94 b3 14 	call	0x2966	; 0x2966 <create_chain>
    3ca4:	dc 01       	movw	r26, r24
    3ca6:	cb 01       	movw	r24, r22
    3ca8:	e8 85       	ldd	r30, Y+8	; 0x08
    3caa:	f9 85       	ldd	r31, Y+9	; 0x09
    3cac:	86 87       	std	Z+14, r24	; 0x0e
    3cae:	97 87       	std	Z+15, r25	; 0x0f
    3cb0:	a0 8b       	std	Z+16, r26	; 0x10
    3cb2:	b1 8b       	std	Z+17, r27	; 0x11
    3cb4:	0d c0       	rjmp	.+26     	; 0x3cd0 <f_write+0x14c>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    3cb6:	a8 85       	ldd	r26, Y+8	; 0x08
    3cb8:	b9 85       	ldd	r27, Y+9	; 0x09
    3cba:	52 96       	adiw	r26, 0x12	; 18
    3cbc:	4d 91       	ld	r20, X+
    3cbe:	5d 91       	ld	r21, X+
    3cc0:	6d 91       	ld	r22, X+
    3cc2:	7c 91       	ld	r23, X
    3cc4:	55 97       	sbiw	r26, 0x15	; 21
    3cc6:	c9 01       	movw	r24, r18
    3cc8:	0e 94 b3 14 	call	0x2966	; 0x2966 <create_chain>
    3ccc:	dc 01       	movw	r26, r24
    3cce:	cb 01       	movw	r24, r22
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    3cd0:	00 97       	sbiw	r24, 0x00	; 0
    3cd2:	a1 05       	cpc	r26, r1
    3cd4:	b1 05       	cpc	r27, r1
    3cd6:	09 f4       	brne	.+2      	; 0x3cda <f_write+0x156>
    3cd8:	78 c1       	rjmp	.+752    	; 0x3fca <f_write+0x446>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    3cda:	81 30       	cpi	r24, 0x01	; 1
    3cdc:	91 05       	cpc	r25, r1
    3cde:	a1 05       	cpc	r26, r1
    3ce0:	b1 05       	cpc	r27, r1
    3ce2:	41 f4       	brne	.+16     	; 0x3cf4 <f_write+0x170>
    3ce4:	48 84       	ldd	r4, Y+8	; 0x08
    3ce6:	59 84       	ldd	r5, Y+9	; 0x09
    3ce8:	f2 01       	movw	r30, r4
    3cea:	84 81       	ldd	r24, Z+4	; 0x04
    3cec:	80 68       	ori	r24, 0x80	; 128
    3cee:	84 83       	std	Z+4, r24	; 0x04
    3cf0:	12 e0       	ldi	r17, 0x02	; 2
    3cf2:	8c c1       	rjmp	.+792    	; 0x400c <f_write+0x488>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3cf4:	8f 3f       	cpi	r24, 0xFF	; 255
    3cf6:	ff ef       	ldi	r31, 0xFF	; 255
    3cf8:	9f 07       	cpc	r25, r31
    3cfa:	ff ef       	ldi	r31, 0xFF	; 255
    3cfc:	af 07       	cpc	r26, r31
    3cfe:	ff ef       	ldi	r31, 0xFF	; 255
    3d00:	bf 07       	cpc	r27, r31
    3d02:	61 f4       	brne	.+24     	; 0x3d1c <f_write+0x198>
    3d04:	48 84       	ldd	r4, Y+8	; 0x08
    3d06:	59 84       	ldd	r5, Y+9	; 0x09
    3d08:	d2 01       	movw	r26, r4
    3d0a:	14 96       	adiw	r26, 0x04	; 4
    3d0c:	8c 91       	ld	r24, X
    3d0e:	14 97       	sbiw	r26, 0x04	; 4
    3d10:	80 68       	ori	r24, 0x80	; 128
    3d12:	14 96       	adiw	r26, 0x04	; 4
    3d14:	8c 93       	st	X, r24
    3d16:	14 97       	sbiw	r26, 0x04	; 4
    3d18:	11 e0       	ldi	r17, 0x01	; 1
    3d1a:	78 c1       	rjmp	.+752    	; 0x400c <f_write+0x488>
				fp->clust = clst;			/* Update current cluster */
    3d1c:	e8 85       	ldd	r30, Y+8	; 0x08
    3d1e:	f9 85       	ldd	r31, Y+9	; 0x09
    3d20:	82 8b       	std	Z+18, r24	; 0x12
    3d22:	93 8b       	std	Z+19, r25	; 0x13
    3d24:	a4 8b       	std	Z+20, r26	; 0x14
    3d26:	b5 8b       	std	Z+21, r27	; 0x15
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
    3d28:	a8 85       	ldd	r26, Y+8	; 0x08
    3d2a:	b9 85       	ldd	r27, Y+9	; 0x09
    3d2c:	14 96       	adiw	r26, 0x04	; 4
    3d2e:	8c 91       	ld	r24, X
    3d30:	14 97       	sbiw	r26, 0x04	; 4
    3d32:	86 ff       	sbrs	r24, 6
    3d34:	21 c0       	rjmp	.+66     	; 0x3d78 <f_write+0x1f4>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3d36:	ed 91       	ld	r30, X+
    3d38:	fc 91       	ld	r31, X
    3d3a:	11 97       	sbiw	r26, 0x01	; 1
    3d3c:	56 96       	adiw	r26, 0x16	; 22
    3d3e:	2d 91       	ld	r18, X+
    3d40:	3d 91       	ld	r19, X+
    3d42:	4d 91       	ld	r20, X+
    3d44:	5c 91       	ld	r21, X
    3d46:	59 97       	sbiw	r26, 0x19	; 25
    3d48:	81 81       	ldd	r24, Z+1	; 0x01
    3d4a:	6d 81       	ldd	r22, Y+5	; 0x05
    3d4c:	7e 81       	ldd	r23, Y+6	; 0x06
    3d4e:	01 e0       	ldi	r16, 0x01	; 1
    3d50:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    3d54:	88 23       	and	r24, r24
    3d56:	41 f0       	breq	.+16     	; 0x3d68 <f_write+0x1e4>
    3d58:	48 84       	ldd	r4, Y+8	; 0x08
    3d5a:	59 84       	ldd	r5, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3d5c:	f2 01       	movw	r30, r4
    3d5e:	84 81       	ldd	r24, Z+4	; 0x04
    3d60:	80 68       	ori	r24, 0x80	; 128
    3d62:	84 83       	std	Z+4, r24	; 0x04
    3d64:	11 e0       	ldi	r17, 0x01	; 1
    3d66:	52 c1       	rjmp	.+676    	; 0x400c <f_write+0x488>
				fp->flag &= ~FA__DIRTY;
    3d68:	a8 85       	ldd	r26, Y+8	; 0x08
    3d6a:	b9 85       	ldd	r27, Y+9	; 0x09
    3d6c:	14 96       	adiw	r26, 0x04	; 4
    3d6e:	8c 91       	ld	r24, X
    3d70:	14 97       	sbiw	r26, 0x04	; 4
    3d72:	8f 7b       	andi	r24, 0xBF	; 191
    3d74:	14 96       	adiw	r26, 0x04	; 4
    3d76:	8c 93       	st	X, r24
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    3d78:	e8 85       	ldd	r30, Y+8	; 0x08
    3d7a:	f9 85       	ldd	r31, Y+9	; 0x09
    3d7c:	20 80       	ld	r2, Z
    3d7e:	31 80       	ldd	r3, Z+1	; 0x01
    3d80:	42 89       	ldd	r20, Z+18	; 0x12
    3d82:	53 89       	ldd	r21, Z+19	; 0x13
    3d84:	64 89       	ldd	r22, Z+20	; 0x14
    3d86:	75 89       	ldd	r23, Z+21	; 0x15
    3d88:	c1 01       	movw	r24, r2
    3d8a:	0e 94 54 11 	call	0x22a8	; 0x22a8 <clust2sect>
    3d8e:	dc 01       	movw	r26, r24
    3d90:	cb 01       	movw	r24, r22
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    3d92:	00 97       	sbiw	r24, 0x00	; 0
    3d94:	a1 05       	cpc	r26, r1
    3d96:	b1 05       	cpc	r27, r1
    3d98:	61 f4       	brne	.+24     	; 0x3db2 <f_write+0x22e>
    3d9a:	48 84       	ldd	r4, Y+8	; 0x08
    3d9c:	59 84       	ldd	r5, Y+9	; 0x09
    3d9e:	d2 01       	movw	r26, r4
    3da0:	14 96       	adiw	r26, 0x04	; 4
    3da2:	8c 91       	ld	r24, X
    3da4:	14 97       	sbiw	r26, 0x04	; 4
    3da6:	80 68       	ori	r24, 0x80	; 128
    3da8:	14 96       	adiw	r26, 0x04	; 4
    3daa:	8c 93       	st	X, r24
    3dac:	14 97       	sbiw	r26, 0x04	; 4
    3dae:	12 e0       	ldi	r17, 0x02	; 2
    3db0:	2d c1       	rjmp	.+602    	; 0x400c <f_write+0x488>
			sect += csect;
    3db2:	41 2f       	mov	r20, r17
    3db4:	50 e0       	ldi	r21, 0x00	; 0
    3db6:	60 e0       	ldi	r22, 0x00	; 0
    3db8:	70 e0       	ldi	r23, 0x00	; 0
    3dba:	2c 01       	movw	r4, r24
    3dbc:	3d 01       	movw	r6, r26
    3dbe:	44 0e       	add	r4, r20
    3dc0:	55 1e       	adc	r5, r21
    3dc2:	66 1e       	adc	r6, r22
    3dc4:	77 1e       	adc	r7, r23
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    3dc6:	75 01       	movw	r14, r10
    3dc8:	64 01       	movw	r12, r8
    3dca:	0b 2e       	mov	r0, r27
    3dcc:	b9 e0       	ldi	r27, 0x09	; 9
    3dce:	f6 94       	lsr	r15
    3dd0:	e7 94       	ror	r14
    3dd2:	d7 94       	ror	r13
    3dd4:	c7 94       	ror	r12
    3dd6:	ba 95       	dec	r27
    3dd8:	d1 f7       	brne	.-12     	; 0x3dce <f_write+0x24a>
    3dda:	b0 2d       	mov	r27, r0
			if (cc) {						/* Write maximum contiguous sectors directly */
    3ddc:	c1 14       	cp	r12, r1
    3dde:	d1 04       	cpc	r13, r1
    3de0:	e1 04       	cpc	r14, r1
    3de2:	f1 04       	cpc	r15, r1
    3de4:	09 f4       	brne	.+2      	; 0x3de8 <f_write+0x264>
    3de6:	60 c0       	rjmp	.+192    	; 0x3ea8 <f_write+0x324>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    3de8:	f1 01       	movw	r30, r2
    3dea:	22 81       	ldd	r18, Z+2	; 0x02
    3dec:	d7 01       	movw	r26, r14
    3dee:	c6 01       	movw	r24, r12
    3df0:	84 0f       	add	r24, r20
    3df2:	95 1f       	adc	r25, r21
    3df4:	a6 1f       	adc	r26, r22
    3df6:	b7 1f       	adc	r27, r23
    3df8:	42 2f       	mov	r20, r18
    3dfa:	50 e0       	ldi	r21, 0x00	; 0
    3dfc:	60 e0       	ldi	r22, 0x00	; 0
    3dfe:	70 e0       	ldi	r23, 0x00	; 0
    3e00:	48 17       	cp	r20, r24
    3e02:	59 07       	cpc	r21, r25
    3e04:	6a 07       	cpc	r22, r26
    3e06:	7b 07       	cpc	r23, r27
    3e08:	48 f4       	brcc	.+18     	; 0x3e1c <f_write+0x298>
					cc = fp->fs->csize - csect;
    3e0a:	82 2f       	mov	r24, r18
    3e0c:	90 e0       	ldi	r25, 0x00	; 0
    3e0e:	81 1b       	sub	r24, r17
    3e10:	91 09       	sbc	r25, r1
    3e12:	6c 01       	movw	r12, r24
    3e14:	ee 24       	eor	r14, r14
    3e16:	d7 fc       	sbrc	r13, 7
    3e18:	e0 94       	com	r14
    3e1a:	fe 2c       	mov	r15, r14
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
    3e1c:	d1 01       	movw	r26, r2
    3e1e:	11 96       	adiw	r26, 0x01	; 1
    3e20:	8c 91       	ld	r24, X
    3e22:	6b 81       	ldd	r22, Y+3	; 0x03
    3e24:	7c 81       	ldd	r23, Y+4	; 0x04
    3e26:	a3 01       	movw	r20, r6
    3e28:	92 01       	movw	r18, r4
    3e2a:	0c 2d       	mov	r16, r12
    3e2c:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    3e30:	88 23       	and	r24, r24
    3e32:	41 f0       	breq	.+16     	; 0x3e44 <f_write+0x2c0>
    3e34:	48 84       	ldd	r4, Y+8	; 0x08
    3e36:	59 84       	ldd	r5, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3e38:	f2 01       	movw	r30, r4
    3e3a:	84 81       	ldd	r24, Z+4	; 0x04
    3e3c:	80 68       	ori	r24, 0x80	; 128
    3e3e:	84 83       	std	Z+4, r24	; 0x04
    3e40:	11 e0       	ldi	r17, 0x01	; 1
    3e42:	e4 c0       	rjmp	.+456    	; 0x400c <f_write+0x488>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
    3e44:	e8 85       	ldd	r30, Y+8	; 0x08
    3e46:	f9 85       	ldd	r31, Y+9	; 0x09
    3e48:	86 89       	ldd	r24, Z+22	; 0x16
    3e4a:	97 89       	ldd	r25, Z+23	; 0x17
    3e4c:	a0 8d       	ldd	r26, Z+24	; 0x18
    3e4e:	b1 8d       	ldd	r27, Z+25	; 0x19
    3e50:	84 19       	sub	r24, r4
    3e52:	95 09       	sbc	r25, r5
    3e54:	a6 09       	sbc	r26, r6
    3e56:	b7 09       	sbc	r27, r7
    3e58:	8c 15       	cp	r24, r12
    3e5a:	9d 05       	cpc	r25, r13
    3e5c:	ae 05       	cpc	r26, r14
    3e5e:	bf 05       	cpc	r27, r15
    3e60:	c8 f4       	brcc	.+50     	; 0x3e94 <f_write+0x310>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
    3e62:	bc 01       	movw	r22, r24
    3e64:	76 2f       	mov	r23, r22
    3e66:	66 27       	eor	r22, r22
    3e68:	77 0f       	add	r23, r23
    3e6a:	0b 81       	ldd	r16, Y+3	; 0x03
    3e6c:	1c 81       	ldd	r17, Y+4	; 0x04
    3e6e:	60 0f       	add	r22, r16
    3e70:	71 1f       	adc	r23, r17
    3e72:	8d 81       	ldd	r24, Y+5	; 0x05
    3e74:	9e 81       	ldd	r25, Y+6	; 0x06
    3e76:	20 e0       	ldi	r18, 0x00	; 0
    3e78:	32 e0       	ldi	r19, 0x02	; 2
    3e7a:	40 e0       	ldi	r20, 0x00	; 0
    3e7c:	50 e0       	ldi	r21, 0x00	; 0
    3e7e:	0e 94 4a 0a 	call	0x1494	; 0x1494 <mem_cpy>
					fp->flag &= ~FA__DIRTY;
    3e82:	a8 85       	ldd	r26, Y+8	; 0x08
    3e84:	b9 85       	ldd	r27, Y+9	; 0x09
    3e86:	14 96       	adiw	r26, 0x04	; 4
    3e88:	8c 91       	ld	r24, X
    3e8a:	14 97       	sbiw	r26, 0x04	; 4
    3e8c:	8f 7b       	andi	r24, 0xBF	; 191
    3e8e:	14 96       	adiw	r26, 0x04	; 4
    3e90:	8c 93       	st	X, r24
    3e92:	14 97       	sbiw	r26, 0x04	; 4
				}
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    3e94:	0b 2e       	mov	r0, r27
    3e96:	b9 e0       	ldi	r27, 0x09	; 9
    3e98:	cc 0c       	add	r12, r12
    3e9a:	dd 1c       	adc	r13, r13
    3e9c:	ee 1c       	adc	r14, r14
    3e9e:	ff 1c       	adc	r15, r15
    3ea0:	ba 95       	dec	r27
    3ea2:	d1 f7       	brne	.-12     	; 0x3e98 <f_write+0x314>
    3ea4:	b0 2d       	mov	r27, r0
				continue;
    3ea6:	65 c0       	rjmp	.+202    	; 0x3f72 <f_write+0x3ee>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
    3ea8:	e8 85       	ldd	r30, Y+8	; 0x08
    3eaa:	f9 85       	ldd	r31, Y+9	; 0x09
    3eac:	86 89       	ldd	r24, Z+22	; 0x16
    3eae:	97 89       	ldd	r25, Z+23	; 0x17
    3eb0:	a0 8d       	ldd	r26, Z+24	; 0x18
    3eb2:	b1 8d       	ldd	r27, Z+25	; 0x19
    3eb4:	84 15       	cp	r24, r4
    3eb6:	95 05       	cpc	r25, r5
    3eb8:	a6 05       	cpc	r26, r6
    3eba:	b7 05       	cpc	r27, r7
    3ebc:	09 f1       	breq	.+66     	; 0x3f00 <f_write+0x37c>
				if (fp->fptr < fp->fsize &&
    3ebe:	86 81       	ldd	r24, Z+6	; 0x06
    3ec0:	97 81       	ldd	r25, Z+7	; 0x07
    3ec2:	a0 85       	ldd	r26, Z+8	; 0x08
    3ec4:	b1 85       	ldd	r27, Z+9	; 0x09
    3ec6:	42 85       	ldd	r20, Z+10	; 0x0a
    3ec8:	53 85       	ldd	r21, Z+11	; 0x0b
    3eca:	64 85       	ldd	r22, Z+12	; 0x0c
    3ecc:	75 85       	ldd	r23, Z+13	; 0x0d
    3ece:	84 17       	cp	r24, r20
    3ed0:	95 07       	cpc	r25, r21
    3ed2:	a6 07       	cpc	r26, r22
    3ed4:	b7 07       	cpc	r27, r23
    3ed6:	a0 f4       	brcc	.+40     	; 0x3f00 <f_write+0x37c>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    3ed8:	d1 01       	movw	r26, r2
    3eda:	11 96       	adiw	r26, 0x01	; 1
    3edc:	8c 91       	ld	r24, X
    3ede:	6d 81       	ldd	r22, Y+5	; 0x05
    3ee0:	7e 81       	ldd	r23, Y+6	; 0x06
    3ee2:	a3 01       	movw	r20, r6
    3ee4:	92 01       	movw	r18, r4
    3ee6:	01 e0       	ldi	r16, 0x01	; 1
    3ee8:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
    3eec:	88 23       	and	r24, r24
    3eee:	41 f0       	breq	.+16     	; 0x3f00 <f_write+0x37c>
    3ef0:	48 84       	ldd	r4, Y+8	; 0x08
    3ef2:	59 84       	ldd	r5, Y+9	; 0x09
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
    3ef4:	f2 01       	movw	r30, r4
    3ef6:	84 81       	ldd	r24, Z+4	; 0x04
    3ef8:	80 68       	ori	r24, 0x80	; 128
    3efa:	84 83       	std	Z+4, r24	; 0x04
    3efc:	11 e0       	ldi	r17, 0x01	; 1
    3efe:	86 c0       	rjmp	.+268    	; 0x400c <f_write+0x488>
			}
#endif
			fp->dsect = sect;
    3f00:	a8 85       	ldd	r26, Y+8	; 0x08
    3f02:	b9 85       	ldd	r27, Y+9	; 0x09
    3f04:	56 96       	adiw	r26, 0x16	; 22
    3f06:	4d 92       	st	X+, r4
    3f08:	5d 92       	st	X+, r5
    3f0a:	6d 92       	st	X+, r6
    3f0c:	7c 92       	st	X, r7
    3f0e:	59 97       	sbiw	r26, 0x19	; 25
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    3f10:	e8 85       	ldd	r30, Y+8	; 0x08
    3f12:	f9 85       	ldd	r31, Y+9	; 0x09
    3f14:	46 81       	ldd	r20, Z+6	; 0x06
    3f16:	57 81       	ldd	r21, Z+7	; 0x07
    3f18:	60 85       	ldd	r22, Z+8	; 0x08
    3f1a:	71 85       	ldd	r23, Z+9	; 0x09
    3f1c:	db 01       	movw	r26, r22
    3f1e:	ca 01       	movw	r24, r20
    3f20:	91 70       	andi	r25, 0x01	; 1
    3f22:	a0 70       	andi	r26, 0x00	; 0
    3f24:	b0 70       	andi	r27, 0x00	; 0
    3f26:	00 e0       	ldi	r16, 0x00	; 0
    3f28:	12 e0       	ldi	r17, 0x02	; 2
    3f2a:	20 e0       	ldi	r18, 0x00	; 0
    3f2c:	30 e0       	ldi	r19, 0x00	; 0
    3f2e:	08 1b       	sub	r16, r24
    3f30:	19 0b       	sbc	r17, r25
    3f32:	2a 0b       	sbc	r18, r26
    3f34:	3b 0b       	sbc	r19, r27
    3f36:	75 01       	movw	r14, r10
    3f38:	64 01       	movw	r12, r8
    3f3a:	08 15       	cp	r16, r8
    3f3c:	19 05       	cpc	r17, r9
    3f3e:	2a 05       	cpc	r18, r10
    3f40:	3b 05       	cpc	r19, r11
    3f42:	10 f4       	brcc	.+4      	; 0x3f48 <f_write+0x3c4>
    3f44:	68 01       	movw	r12, r16
    3f46:	79 01       	movw	r14, r18
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    3f48:	ca 01       	movw	r24, r20
    3f4a:	91 70       	andi	r25, 0x01	; 1
    3f4c:	80 96       	adiw	r24, 0x20	; 32
    3f4e:	28 85       	ldd	r18, Y+8	; 0x08
    3f50:	39 85       	ldd	r19, Y+9	; 0x09
    3f52:	82 0f       	add	r24, r18
    3f54:	93 1f       	adc	r25, r19
    3f56:	6b 81       	ldd	r22, Y+3	; 0x03
    3f58:	7c 81       	ldd	r23, Y+4	; 0x04
    3f5a:	a7 01       	movw	r20, r14
    3f5c:	96 01       	movw	r18, r12
    3f5e:	0e 94 4a 0a 	call	0x1494	; 0x1494 <mem_cpy>
		fp->flag |= FA__DIRTY;
    3f62:	a8 85       	ldd	r26, Y+8	; 0x08
    3f64:	b9 85       	ldd	r27, Y+9	; 0x09
    3f66:	14 96       	adiw	r26, 0x04	; 4
    3f68:	8c 91       	ld	r24, X
    3f6a:	14 97       	sbiw	r26, 0x04	; 4
    3f6c:	80 64       	ori	r24, 0x40	; 64
    3f6e:	14 96       	adiw	r26, 0x04	; 4
    3f70:	8c 93       	st	X, r24
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    3f72:	eb 81       	ldd	r30, Y+3	; 0x03
    3f74:	fc 81       	ldd	r31, Y+4	; 0x04
    3f76:	ec 0d       	add	r30, r12
    3f78:	fd 1d       	adc	r31, r13
    3f7a:	fc 83       	std	Y+4, r31	; 0x04
    3f7c:	eb 83       	std	Y+3, r30	; 0x03
    3f7e:	e8 85       	ldd	r30, Y+8	; 0x08
    3f80:	f9 85       	ldd	r31, Y+9	; 0x09
    3f82:	86 81       	ldd	r24, Z+6	; 0x06
    3f84:	97 81       	ldd	r25, Z+7	; 0x07
    3f86:	a0 85       	ldd	r26, Z+8	; 0x08
    3f88:	b1 85       	ldd	r27, Z+9	; 0x09
    3f8a:	8c 0d       	add	r24, r12
    3f8c:	9d 1d       	adc	r25, r13
    3f8e:	ae 1d       	adc	r26, r14
    3f90:	bf 1d       	adc	r27, r15
    3f92:	86 83       	std	Z+6, r24	; 0x06
    3f94:	97 83       	std	Z+7, r25	; 0x07
    3f96:	a0 87       	std	Z+8, r26	; 0x08
    3f98:	b1 87       	std	Z+9, r27	; 0x09
    3f9a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f9c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f9e:	80 81       	ld	r24, Z
    3fa0:	91 81       	ldd	r25, Z+1	; 0x01
    3fa2:	a2 81       	ldd	r26, Z+2	; 0x02
    3fa4:	b3 81       	ldd	r27, Z+3	; 0x03
    3fa6:	8c 0d       	add	r24, r12
    3fa8:	9d 1d       	adc	r25, r13
    3faa:	ae 1d       	adc	r26, r14
    3fac:	bf 1d       	adc	r27, r15
    3fae:	80 83       	st	Z, r24
    3fb0:	91 83       	std	Z+1, r25	; 0x01
    3fb2:	a2 83       	std	Z+2, r26	; 0x02
    3fb4:	b3 83       	std	Z+3, r27	; 0x03
    3fb6:	8c 18       	sub	r8, r12
    3fb8:	9d 08       	sbc	r9, r13
    3fba:	ae 08       	sbc	r10, r14
    3fbc:	bf 08       	sbc	r11, r15
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
    3fbe:	09 f0       	breq	.+2      	; 0x3fc2 <f_write+0x43e>
    3fc0:	35 ce       	rjmp	.-918    	; 0x3c2c <f_write+0xa8>
    3fc2:	1f 81       	ldd	r17, Y+7	; 0x07
    3fc4:	48 84       	ldd	r4, Y+8	; 0x08
    3fc6:	59 84       	ldd	r5, Y+9	; 0x09
    3fc8:	03 c0       	rjmp	.+6      	; 0x3fd0 <f_write+0x44c>
    3fca:	1f 81       	ldd	r17, Y+7	; 0x07
    3fcc:	48 84       	ldd	r4, Y+8	; 0x08
    3fce:	59 84       	ldd	r5, Y+9	; 0x09
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    3fd0:	f2 01       	movw	r30, r4
    3fd2:	86 81       	ldd	r24, Z+6	; 0x06
    3fd4:	97 81       	ldd	r25, Z+7	; 0x07
    3fd6:	a0 85       	ldd	r26, Z+8	; 0x08
    3fd8:	b1 85       	ldd	r27, Z+9	; 0x09
    3fda:	42 85       	ldd	r20, Z+10	; 0x0a
    3fdc:	53 85       	ldd	r21, Z+11	; 0x0b
    3fde:	64 85       	ldd	r22, Z+12	; 0x0c
    3fe0:	75 85       	ldd	r23, Z+13	; 0x0d
    3fe2:	48 17       	cp	r20, r24
    3fe4:	59 07       	cpc	r21, r25
    3fe6:	6a 07       	cpc	r22, r26
    3fe8:	7b 07       	cpc	r23, r27
    3fea:	20 f4       	brcc	.+8      	; 0x3ff4 <f_write+0x470>
    3fec:	82 87       	std	Z+10, r24	; 0x0a
    3fee:	93 87       	std	Z+11, r25	; 0x0b
    3ff0:	a4 87       	std	Z+12, r26	; 0x0c
    3ff2:	b5 87       	std	Z+13, r27	; 0x0d
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    3ff4:	d2 01       	movw	r26, r4
    3ff6:	14 96       	adiw	r26, 0x04	; 4
    3ff8:	8c 91       	ld	r24, X
    3ffa:	14 97       	sbiw	r26, 0x04	; 4
    3ffc:	80 62       	ori	r24, 0x20	; 32
    3ffe:	14 96       	adiw	r26, 0x04	; 4
    4000:	8c 93       	st	X, r24
    4002:	14 97       	sbiw	r26, 0x04	; 4

	LEAVE_FF(fp->fs, FR_OK);
    4004:	03 c0       	rjmp	.+6      	; 0x400c <f_write+0x488>
	*bw = 0;	/* Clear write byte counter */

	res = validate(fp);						/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)				/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    4006:	12 e0       	ldi	r17, 0x02	; 2
    4008:	01 c0       	rjmp	.+2      	; 0x400c <f_write+0x488>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    400a:	17 e0       	ldi	r17, 0x07	; 7

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
    400c:	81 2f       	mov	r24, r17
    400e:	29 96       	adiw	r28, 0x09	; 9
    4010:	0f b6       	in	r0, 0x3f	; 63
    4012:	f8 94       	cli
    4014:	de bf       	out	0x3e, r29	; 62
    4016:	0f be       	out	0x3f, r0	; 63
    4018:	cd bf       	out	0x3d, r28	; 61
    401a:	df 91       	pop	r29
    401c:	cf 91       	pop	r28
    401e:	1f 91       	pop	r17
    4020:	0f 91       	pop	r16
    4022:	ff 90       	pop	r15
    4024:	ef 90       	pop	r14
    4026:	df 90       	pop	r13
    4028:	cf 90       	pop	r12
    402a:	bf 90       	pop	r11
    402c:	af 90       	pop	r10
    402e:	9f 90       	pop	r9
    4030:	8f 90       	pop	r8
    4032:	7f 90       	pop	r7
    4034:	6f 90       	pop	r6
    4036:	5f 90       	pop	r5
    4038:	4f 90       	pop	r4
    403a:	3f 90       	pop	r3
    403c:	2f 90       	pop	r2
    403e:	08 95       	ret

00004040 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
    4040:	0f 93       	push	r16
    4042:	1f 93       	push	r17
    4044:	cf 93       	push	r28
    4046:	df 93       	push	r29
    4048:	ec 01       	movw	r28, r24
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
    404a:	0e 94 30 0b 	call	0x1660	; 0x1660 <validate>
	if (res == FR_OK) {
    404e:	88 23       	and	r24, r24
    4050:	09 f0       	breq	.+2      	; 0x4054 <f_sync+0x14>
    4052:	4c c0       	rjmp	.+152    	; 0x40ec <f_sync+0xac>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    4054:	9c 81       	ldd	r25, Y+4	; 0x04
    4056:	95 ff       	sbrs	r25, 5
    4058:	49 c0       	rjmp	.+146    	; 0x40ec <f_sync+0xac>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
    405a:	96 ff       	sbrs	r25, 6
    405c:	12 c0       	rjmp	.+36     	; 0x4082 <f_sync+0x42>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    405e:	e8 81       	ld	r30, Y
    4060:	f9 81       	ldd	r31, Y+1	; 0x01
    4062:	be 01       	movw	r22, r28
    4064:	60 5e       	subi	r22, 0xE0	; 224
    4066:	7f 4f       	sbci	r23, 0xFF	; 255
    4068:	2e 89       	ldd	r18, Y+22	; 0x16
    406a:	3f 89       	ldd	r19, Y+23	; 0x17
    406c:	48 8d       	ldd	r20, Y+24	; 0x18
    406e:	59 8d       	ldd	r21, Y+25	; 0x19
    4070:	81 81       	ldd	r24, Z+1	; 0x01
    4072:	01 e0       	ldi	r16, 0x01	; 1
    4074:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    4078:	88 23       	and	r24, r24
    407a:	b9 f5       	brne	.+110    	; 0x40ea <f_sync+0xaa>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
    407c:	8c 81       	ldd	r24, Y+4	; 0x04
    407e:	8f 7b       	andi	r24, 0xBF	; 191
    4080:	8c 83       	std	Y+4, r24	; 0x04
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
    4082:	4a 8d       	ldd	r20, Y+26	; 0x1a
    4084:	5b 8d       	ldd	r21, Y+27	; 0x1b
    4086:	6c 8d       	ldd	r22, Y+28	; 0x1c
    4088:	7d 8d       	ldd	r23, Y+29	; 0x1d
    408a:	88 81       	ld	r24, Y
    408c:	99 81       	ldd	r25, Y+1	; 0x01
    408e:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
			if (res == FR_OK) {
    4092:	88 23       	and	r24, r24
    4094:	59 f5       	brne	.+86     	; 0x40ec <f_sync+0xac>
				dir = fp->dir_ptr;
    4096:	0e 8d       	ldd	r16, Y+30	; 0x1e
    4098:	1f 8d       	ldd	r17, Y+31	; 0x1f
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    409a:	f8 01       	movw	r30, r16
    409c:	83 85       	ldd	r24, Z+11	; 0x0b
    409e:	80 62       	ori	r24, 0x20	; 32
    40a0:	83 87       	std	Z+11, r24	; 0x0b
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    40a2:	8a 85       	ldd	r24, Y+10	; 0x0a
    40a4:	84 8f       	std	Z+28, r24	; 0x1c
    40a6:	8b 85       	ldd	r24, Y+11	; 0x0b
    40a8:	85 8f       	std	Z+29, r24	; 0x1d
    40aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    40ac:	86 8f       	std	Z+30, r24	; 0x1e
    40ae:	8d 85       	ldd	r24, Y+13	; 0x0d
    40b0:	87 8f       	std	Z+31, r24	; 0x1f
				st_clust(dir, fp->sclust);					/* Update start cluster */
    40b2:	4e 85       	ldd	r20, Y+14	; 0x0e
    40b4:	5f 85       	ldd	r21, Y+15	; 0x0f
    40b6:	68 89       	ldd	r22, Y+16	; 0x10
    40b8:	79 89       	ldd	r23, Y+17	; 0x11
    40ba:	c8 01       	movw	r24, r16
    40bc:	0e 94 95 0a 	call	0x152a	; 0x152a <st_clust>
				tim = get_fattime();						/* Update updated time */
    40c0:	0e 94 50 11 	call	0x22a0	; 0x22a0 <get_fattime>
				ST_DWORD(dir+DIR_WrtTime, tim);
    40c4:	f8 01       	movw	r30, r16
    40c6:	66 8b       	std	Z+22, r22	; 0x16
    40c8:	77 8b       	std	Z+23, r23	; 0x17
    40ca:	80 8f       	std	Z+24, r24	; 0x18
    40cc:	91 8f       	std	Z+25, r25	; 0x19
				ST_WORD(dir+DIR_LstAccDate, 0);
    40ce:	12 8a       	std	Z+18, r1	; 0x12
    40d0:	13 8a       	std	Z+19, r1	; 0x13
				fp->flag &= ~FA__WRITTEN;
    40d2:	8c 81       	ldd	r24, Y+4	; 0x04
    40d4:	8f 7d       	andi	r24, 0xDF	; 223
    40d6:	8c 83       	std	Y+4, r24	; 0x04
				fp->fs->wflag = 1;
    40d8:	e8 81       	ld	r30, Y
    40da:	f9 81       	ldd	r31, Y+1	; 0x01
    40dc:	81 e0       	ldi	r24, 0x01	; 1
    40de:	84 83       	std	Z+4, r24	; 0x04
				res = sync(fp->fs);
    40e0:	88 81       	ld	r24, Y
    40e2:	99 81       	ldd	r25, Y+1	; 0x01
    40e4:	0e 94 c2 10 	call	0x2184	; 0x2184 <sync>
    40e8:	01 c0       	rjmp	.+2      	; 0x40ec <f_sync+0xac>
	if (res == FR_OK) {
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
    40ea:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
    40ec:	df 91       	pop	r29
    40ee:	cf 91       	pop	r28
    40f0:	1f 91       	pop	r17
    40f2:	0f 91       	pop	r16
    40f4:	08 95       	ret

000040f6 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    40f6:	cf 93       	push	r28
    40f8:	df 93       	push	r29
    40fa:	ec 01       	movw	r28, r24
#endif
		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
		LEAVE_FF(fs, res);
	}
#else
	res = f_sync(fp);		/* Flush cached data */
    40fc:	0e 94 20 20 	call	0x4040	; 0x4040 <f_sync>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    4100:	88 23       	and	r24, r24
    4102:	11 f4       	brne	.+4      	; 0x4108 <f_close+0x12>
    4104:	19 82       	std	Y+1, r1	; 0x01
    4106:	18 82       	st	Y, r1
	return res;
#endif
}
    4108:	df 91       	pop	r29
    410a:	cf 91       	pop	r28
    410c:	08 95       	ret

0000410e <f_chdrive>:

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
    410e:	88 23       	and	r24, r24
    4110:	19 f4       	brne	.+6      	; 0x4118 <f_chdrive+0xa>

	CurrVol = drv;
    4112:	10 92 25 04 	sts	0x0425, r1

	return FR_OK;
    4116:	08 95       	ret

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
    4118:	8b e0       	ldi	r24, 0x0B	; 11

	CurrVol = drv;

	return FR_OK;
}
    411a:	08 95       	ret

0000411c <f_chdir>:


FRESULT f_chdir (
	const TCHAR *path	/* Pointer to the directory path */
)
{
    411c:	ef 92       	push	r14
    411e:	ff 92       	push	r15
    4120:	1f 93       	push	r17
    4122:	cf 93       	push	r28
    4124:	df 93       	push	r29
    4126:	cd b7       	in	r28, 0x3d	; 61
    4128:	de b7       	in	r29, 0x3e	; 62
    412a:	a4 97       	sbiw	r28, 0x24	; 36
    412c:	0f b6       	in	r0, 0x3f	; 63
    412e:	f8 94       	cli
    4130:	de bf       	out	0x3e, r29	; 62
    4132:	0f be       	out	0x3f, r0	; 63
    4134:	cd bf       	out	0x3d, r28	; 61
    4136:	9c a3       	lds	r25, 0x5c
    4138:	8b a3       	lds	r24, 0x5b
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
    413a:	ce 01       	movw	r24, r28
    413c:	83 96       	adiw	r24, 0x23	; 35
    413e:	be 01       	movw	r22, r28
    4140:	6f 5f       	subi	r22, 0xFF	; 255
    4142:	7f 4f       	sbci	r23, 0xFF	; 255
    4144:	40 e0       	ldi	r20, 0x00	; 0
    4146:	0e 94 ed 0b 	call	0x17da	; 0x17da <chk_mounted>
    414a:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    414c:	88 23       	and	r24, r24
    414e:	81 f5       	brne	.+96     	; 0x41b0 <f_chdir+0x94>
		INIT_BUF(dj);
    4150:	ce 01       	movw	r24, r28
    4152:	47 96       	adiw	r24, 0x17	; 23
    4154:	9e 8b       	std	Y+22, r25	; 0x16
    4156:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the path */
    4158:	6b a1       	lds	r22, 0x4b
    415a:	7c a1       	lds	r23, 0x4c
    415c:	ce 01       	movw	r24, r28
    415e:	01 96       	adiw	r24, 0x01	; 1
    4160:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <follow_path>
    4164:	18 2f       	mov	r17, r24
		FREE_BUF();
		if (res == FR_OK) {					/* Follow completed */
    4166:	88 23       	and	r24, r24
    4168:	01 f5       	brne	.+64     	; 0x41aa <f_chdir+0x8e>
			if (!dj.dir) {
    416a:	eb 89       	ldd	r30, Y+19	; 0x13
    416c:	fc 89       	ldd	r31, Y+20	; 0x14
    416e:	30 97       	sbiw	r30, 0x00	; 0
    4170:	59 f4       	brne	.+22     	; 0x4188 <f_chdir+0x6c>
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
    4172:	e9 81       	ldd	r30, Y+1	; 0x01
    4174:	fa 81       	ldd	r31, Y+2	; 0x02
    4176:	8f 81       	ldd	r24, Y+7	; 0x07
    4178:	98 85       	ldd	r25, Y+8	; 0x08
    417a:	a9 85       	ldd	r26, Y+9	; 0x09
    417c:	ba 85       	ldd	r27, Y+10	; 0x0a
    417e:	86 8b       	std	Z+22, r24	; 0x16
    4180:	97 8b       	std	Z+23, r25	; 0x17
    4182:	a0 8f       	std	Z+24, r26	; 0x18
    4184:	b1 8f       	std	Z+25, r27	; 0x19
    4186:	14 c0       	rjmp	.+40     	; 0x41b0 <f_chdir+0x94>
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
    4188:	83 85       	ldd	r24, Z+11	; 0x0b
    418a:	84 ff       	sbrs	r24, 4
    418c:	1e c0       	rjmp	.+60     	; 0x41ca <f_chdir+0xae>
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
    418e:	e9 80       	ldd	r14, Y+1	; 0x01
    4190:	fa 80       	ldd	r15, Y+2	; 0x02
    4192:	c7 01       	movw	r24, r14
    4194:	bf 01       	movw	r22, r30
    4196:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ld_clust>
    419a:	dc 01       	movw	r26, r24
    419c:	cb 01       	movw	r24, r22
    419e:	f7 01       	movw	r30, r14
    41a0:	86 8b       	std	Z+22, r24	; 0x16
    41a2:	97 8b       	std	Z+23, r25	; 0x17
    41a4:	a0 8f       	std	Z+24, r26	; 0x18
    41a6:	b1 8f       	std	Z+25, r27	; 0x19
    41a8:	03 c0       	rjmp	.+6      	; 0x41b0 <f_chdir+0x94>
				else
					res = FR_NO_PATH;		/* Reached but a file */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    41aa:	84 30       	cpi	r24, 0x04	; 4
    41ac:	09 f4       	brne	.+2      	; 0x41b0 <f_chdir+0x94>
    41ae:	15 e0       	ldi	r17, 0x05	; 5
	}

	LEAVE_FF(dj.fs, res);
}
    41b0:	81 2f       	mov	r24, r17
    41b2:	a4 96       	adiw	r28, 0x24	; 36
    41b4:	0f b6       	in	r0, 0x3f	; 63
    41b6:	f8 94       	cli
    41b8:	de bf       	out	0x3e, r29	; 62
    41ba:	0f be       	out	0x3f, r0	; 63
    41bc:	cd bf       	out	0x3d, r28	; 61
    41be:	df 91       	pop	r29
    41c0:	cf 91       	pop	r28
    41c2:	1f 91       	pop	r17
    41c4:	ff 90       	pop	r15
    41c6:	ef 90       	pop	r14
    41c8:	08 95       	ret
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
				else
					res = FR_NO_PATH;		/* Reached but a file */
    41ca:	15 e0       	ldi	r17, 0x05	; 5
    41cc:	f1 cf       	rjmp	.-30     	; 0x41b0 <f_chdir+0x94>

000041ce <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
    41ce:	2f 92       	push	r2
    41d0:	3f 92       	push	r3
    41d2:	4f 92       	push	r4
    41d4:	5f 92       	push	r5
    41d6:	6f 92       	push	r6
    41d8:	7f 92       	push	r7
    41da:	8f 92       	push	r8
    41dc:	9f 92       	push	r9
    41de:	af 92       	push	r10
    41e0:	bf 92       	push	r11
    41e2:	cf 92       	push	r12
    41e4:	df 92       	push	r13
    41e6:	ef 92       	push	r14
    41e8:	ff 92       	push	r15
    41ea:	0f 93       	push	r16
    41ec:	1f 93       	push	r17
    41ee:	cf 93       	push	r28
    41f0:	df 93       	push	r29
    41f2:	00 d0       	rcall	.+0      	; 0x41f4 <f_lseek+0x26>
    41f4:	00 d0       	rcall	.+0      	; 0x41f6 <f_lseek+0x28>
    41f6:	00 d0       	rcall	.+0      	; 0x41f8 <f_lseek+0x2a>
    41f8:	cd b7       	in	r28, 0x3d	; 61
    41fa:	de b7       	in	r29, 0x3e	; 62
    41fc:	9e 83       	std	Y+6, r25	; 0x06
    41fe:	8d 83       	std	Y+5, r24	; 0x05
    4200:	6a 01       	movw	r12, r20
    4202:	7b 01       	movw	r14, r22
	FRESULT res;


	res = validate(fp);					/* Check validity of the object */
    4204:	0e 94 30 0b 	call	0x1660	; 0x1660 <validate>
    4208:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    420a:	88 23       	and	r24, r24
    420c:	09 f0       	breq	.+2      	; 0x4210 <f_lseek+0x42>
    420e:	e6 c1       	rjmp	.+972    	; 0x45dc <f_lseek+0x40e>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
    4210:	ad 81       	ldd	r26, Y+5	; 0x05
    4212:	be 81       	ldd	r27, Y+6	; 0x06
    4214:	14 96       	adiw	r26, 0x04	; 4
    4216:	2c 91       	ld	r18, X
    4218:	14 97       	sbiw	r26, 0x04	; 4
    421a:	22 23       	and	r18, r18
    421c:	0c f4       	brge	.+2      	; 0x4220 <f_lseek+0x52>
    421e:	dd c1       	rjmp	.+954    	; 0x45da <f_lseek+0x40c>

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    4220:	1a 96       	adiw	r26, 0x0a	; 10
    4222:	8d 91       	ld	r24, X+
    4224:	9d 91       	ld	r25, X+
    4226:	0d 90       	ld	r0, X+
    4228:	bc 91       	ld	r27, X
    422a:	a0 2d       	mov	r26, r0
    422c:	8c 15       	cp	r24, r12
    422e:	9d 05       	cpc	r25, r13
    4230:	ae 05       	cpc	r26, r14
    4232:	bf 05       	cpc	r27, r15
    4234:	20 f4       	brcc	.+8      	; 0x423e <f_lseek+0x70>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
    4236:	21 fd       	sbrc	r18, 1
    4238:	02 c0       	rjmp	.+4      	; 0x423e <f_lseek+0x70>
#endif
			) ofs = fp->fsize;
    423a:	6c 01       	movw	r12, r24
    423c:	7d 01       	movw	r14, r26

		ifptr = fp->fptr;
    423e:	ed 81       	ldd	r30, Y+5	; 0x05
    4240:	fe 81       	ldd	r31, Y+6	; 0x06
    4242:	46 81       	ldd	r20, Z+6	; 0x06
    4244:	57 81       	ldd	r21, Z+7	; 0x07
    4246:	60 85       	ldd	r22, Z+8	; 0x08
    4248:	71 85       	ldd	r23, Z+9	; 0x09
		fp->fptr = nsect = 0;
    424a:	16 82       	std	Z+6, r1	; 0x06
    424c:	17 82       	std	Z+7, r1	; 0x07
    424e:	10 86       	std	Z+8, r1	; 0x08
    4250:	11 86       	std	Z+9, r1	; 0x09
		if (ofs) {
    4252:	c1 14       	cp	r12, r1
    4254:	d1 04       	cpc	r13, r1
    4256:	e1 04       	cpc	r14, r1
    4258:	f1 04       	cpc	r15, r1
    425a:	09 f4       	brne	.+2      	; 0x425e <f_lseek+0x90>
    425c:	bf c1       	rjmp	.+894    	; 0x45dc <f_lseek+0x40e>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    425e:	20 80       	ld	r2, Z
    4260:	31 80       	ldd	r3, Z+1	; 0x01
    4262:	f1 01       	movw	r30, r2
    4264:	82 81       	ldd	r24, Z+2	; 0x02
    4266:	90 e0       	ldi	r25, 0x00	; 0
    4268:	a0 e0       	ldi	r26, 0x00	; 0
    426a:	b0 e0       	ldi	r27, 0x00	; 0
    426c:	4c 01       	movw	r8, r24
    426e:	5d 01       	movw	r10, r26
    4270:	07 2e       	mov	r0, r23
    4272:	79 e0       	ldi	r23, 0x09	; 9
    4274:	88 0c       	add	r8, r8
    4276:	99 1c       	adc	r9, r9
    4278:	aa 1c       	adc	r10, r10
    427a:	bb 1c       	adc	r11, r11
    427c:	7a 95       	dec	r23
    427e:	d1 f7       	brne	.-12     	; 0x4274 <f_lseek+0xa6>
    4280:	70 2d       	mov	r23, r0
			if (ifptr > 0 &&
    4282:	41 15       	cp	r20, r1
    4284:	51 05       	cpc	r21, r1
    4286:	61 05       	cpc	r22, r1
    4288:	71 05       	cpc	r23, r1
    428a:	f1 f1       	breq	.+124    	; 0x4308 <f_lseek+0x13a>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
    428c:	2a 01       	movw	r4, r20
    428e:	3b 01       	movw	r6, r22
    4290:	08 94       	sec
    4292:	41 08       	sbc	r4, r1
    4294:	51 08       	sbc	r5, r1
    4296:	61 08       	sbc	r6, r1
    4298:	71 08       	sbc	r7, r1
    429a:	c7 01       	movw	r24, r14
    429c:	b6 01       	movw	r22, r12
    429e:	61 50       	subi	r22, 0x01	; 1
    42a0:	70 40       	sbci	r23, 0x00	; 0
    42a2:	80 40       	sbci	r24, 0x00	; 0
    42a4:	90 40       	sbci	r25, 0x00	; 0
    42a6:	a5 01       	movw	r20, r10
    42a8:	94 01       	movw	r18, r8
    42aa:	0e 94 4d 2b 	call	0x569a	; 0x569a <__udivmodsi4>
    42ae:	29 83       	std	Y+1, r18	; 0x01
    42b0:	3a 83       	std	Y+2, r19	; 0x02
    42b2:	4b 83       	std	Y+3, r20	; 0x03
    42b4:	5c 83       	std	Y+4, r21	; 0x04
    42b6:	c3 01       	movw	r24, r6
    42b8:	b2 01       	movw	r22, r4
    42ba:	a5 01       	movw	r20, r10
    42bc:	94 01       	movw	r18, r8
    42be:	0e 94 4d 2b 	call	0x569a	; 0x569a <__udivmodsi4>

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
    42c2:	89 81       	ldd	r24, Y+1	; 0x01
    42c4:	9a 81       	ldd	r25, Y+2	; 0x02
    42c6:	ab 81       	ldd	r26, Y+3	; 0x03
    42c8:	bc 81       	ldd	r27, Y+4	; 0x04
    42ca:	82 17       	cp	r24, r18
    42cc:	93 07       	cpc	r25, r19
    42ce:	a4 07       	cpc	r26, r20
    42d0:	b5 07       	cpc	r27, r21
    42d2:	d0 f0       	brcs	.+52     	; 0x4308 <f_lseek+0x13a>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    42d4:	88 27       	eor	r24, r24
    42d6:	99 27       	eor	r25, r25
    42d8:	dc 01       	movw	r26, r24
    42da:	88 19       	sub	r24, r8
    42dc:	99 09       	sbc	r25, r9
    42de:	aa 09       	sbc	r26, r10
    42e0:	bb 09       	sbc	r27, r11
    42e2:	84 21       	and	r24, r4
    42e4:	95 21       	and	r25, r5
    42e6:	a6 21       	and	r26, r6
    42e8:	b7 21       	and	r27, r7
    42ea:	ed 81       	ldd	r30, Y+5	; 0x05
    42ec:	fe 81       	ldd	r31, Y+6	; 0x06
    42ee:	86 83       	std	Z+6, r24	; 0x06
    42f0:	97 83       	std	Z+7, r25	; 0x07
    42f2:	a0 87       	std	Z+8, r26	; 0x08
    42f4:	b1 87       	std	Z+9, r27	; 0x09
				ofs -= fp->fptr;
    42f6:	c8 1a       	sub	r12, r24
    42f8:	d9 0a       	sbc	r13, r25
    42fa:	ea 0a       	sbc	r14, r26
    42fc:	fb 0a       	sbc	r15, r27
				clst = fp->clust;
    42fe:	42 89       	ldd	r20, Z+18	; 0x12
    4300:	53 89       	ldd	r21, Z+19	; 0x13
    4302:	64 89       	ldd	r22, Z+20	; 0x14
    4304:	75 89       	ldd	r23, Z+21	; 0x15
    4306:	42 c0       	rjmp	.+132    	; 0x438c <f_lseek+0x1be>
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
    4308:	ad 81       	ldd	r26, Y+5	; 0x05
    430a:	be 81       	ldd	r27, Y+6	; 0x06
    430c:	1e 96       	adiw	r26, 0x0e	; 14
    430e:	4d 91       	ld	r20, X+
    4310:	5d 91       	ld	r21, X+
    4312:	6d 91       	ld	r22, X+
    4314:	7c 91       	ld	r23, X
    4316:	51 97       	sbiw	r26, 0x11	; 17
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
    4318:	41 15       	cp	r20, r1
    431a:	51 05       	cpc	r21, r1
    431c:	61 05       	cpc	r22, r1
    431e:	71 05       	cpc	r23, r1
    4320:	69 f5       	brne	.+90     	; 0x437c <f_lseek+0x1ae>
					clst = create_chain(fp->fs, 0);
    4322:	c1 01       	movw	r24, r2
    4324:	40 e0       	ldi	r20, 0x00	; 0
    4326:	50 e0       	ldi	r21, 0x00	; 0
    4328:	ba 01       	movw	r22, r20
    432a:	0e 94 b3 14 	call	0x2966	; 0x2966 <create_chain>
    432e:	ab 01       	movw	r20, r22
    4330:	bc 01       	movw	r22, r24
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    4332:	41 30       	cpi	r20, 0x01	; 1
    4334:	51 05       	cpc	r21, r1
    4336:	61 05       	cpc	r22, r1
    4338:	71 05       	cpc	r23, r1
    433a:	39 f4       	brne	.+14     	; 0x434a <f_lseek+0x17c>
    433c:	ed 81       	ldd	r30, Y+5	; 0x05
    433e:	fe 81       	ldd	r31, Y+6	; 0x06
    4340:	84 81       	ldd	r24, Z+4	; 0x04
    4342:	80 68       	ori	r24, 0x80	; 128
    4344:	84 83       	std	Z+4, r24	; 0x04
    4346:	12 e0       	ldi	r17, 0x02	; 2
    4348:	49 c1       	rjmp	.+658    	; 0x45dc <f_lseek+0x40e>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    434a:	4f 3f       	cpi	r20, 0xFF	; 255
    434c:	ff ef       	ldi	r31, 0xFF	; 255
    434e:	5f 07       	cpc	r21, r31
    4350:	ff ef       	ldi	r31, 0xFF	; 255
    4352:	6f 07       	cpc	r22, r31
    4354:	ff ef       	ldi	r31, 0xFF	; 255
    4356:	7f 07       	cpc	r23, r31
    4358:	59 f4       	brne	.+22     	; 0x4370 <f_lseek+0x1a2>
    435a:	ad 81       	ldd	r26, Y+5	; 0x05
    435c:	be 81       	ldd	r27, Y+6	; 0x06
    435e:	14 96       	adiw	r26, 0x04	; 4
    4360:	8c 91       	ld	r24, X
    4362:	14 97       	sbiw	r26, 0x04	; 4
    4364:	80 68       	ori	r24, 0x80	; 128
    4366:	14 96       	adiw	r26, 0x04	; 4
    4368:	8c 93       	st	X, r24
    436a:	14 97       	sbiw	r26, 0x04	; 4
    436c:	11 e0       	ldi	r17, 0x01	; 1
    436e:	36 c1       	rjmp	.+620    	; 0x45dc <f_lseek+0x40e>
					fp->sclust = clst;
    4370:	ed 81       	ldd	r30, Y+5	; 0x05
    4372:	fe 81       	ldd	r31, Y+6	; 0x06
    4374:	46 87       	std	Z+14, r20	; 0x0e
    4376:	57 87       	std	Z+15, r21	; 0x0f
    4378:	60 8b       	std	Z+16, r22	; 0x10
    437a:	71 8b       	std	Z+17, r23	; 0x11
				}
#endif
				fp->clust = clst;
    437c:	ad 81       	ldd	r26, Y+5	; 0x05
    437e:	be 81       	ldd	r27, Y+6	; 0x06
    4380:	52 96       	adiw	r26, 0x12	; 18
    4382:	4d 93       	st	X+, r20
    4384:	5d 93       	st	X+, r21
    4386:	6d 93       	st	X+, r22
    4388:	7c 93       	st	X, r23
    438a:	55 97       	sbiw	r26, 0x15	; 21
			}
			if (clst != 0) {
    438c:	41 15       	cp	r20, r1
    438e:	51 05       	cpc	r21, r1
    4390:	61 05       	cpc	r22, r1
    4392:	71 05       	cpc	r23, r1
    4394:	09 f4       	brne	.+2      	; 0x4398 <f_lseek+0x1ca>
    4396:	aa c0       	rjmp	.+340    	; 0x44ec <f_lseek+0x31e>
				while (ofs > bcs) {						/* Cluster following loop */
    4398:	8c 14       	cp	r8, r12
    439a:	9d 04       	cpc	r9, r13
    439c:	ae 04       	cpc	r10, r14
    439e:	bf 04       	cpc	r11, r15
    43a0:	08 f0       	brcs	.+2      	; 0x43a4 <f_lseek+0x1d6>
    43a2:	68 c0       	rjmp	.+208    	; 0x4474 <f_lseek+0x2a6>
    43a4:	4d 80       	ldd	r4, Y+5	; 0x05
    43a6:	5e 80       	ldd	r5, Y+6	; 0x06
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    43a8:	f2 01       	movw	r30, r4
    43aa:	84 81       	ldd	r24, Z+4	; 0x04
    43ac:	81 ff       	sbrs	r24, 1
    43ae:	0c c0       	rjmp	.+24     	; 0x43c8 <f_lseek+0x1fa>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
    43b0:	80 81       	ld	r24, Z
    43b2:	91 81       	ldd	r25, Z+1	; 0x01
    43b4:	0e 94 b3 14 	call	0x2966	; 0x2966 <create_chain>
    43b8:	ab 01       	movw	r20, r22
    43ba:	bc 01       	movw	r22, r24
						if (clst == 0) {				/* When disk gets full, clip file size */
    43bc:	41 15       	cp	r20, r1
    43be:	51 05       	cpc	r21, r1
    43c0:	61 05       	cpc	r22, r1
    43c2:	71 05       	cpc	r23, r1
    43c4:	39 f4       	brne	.+14     	; 0x43d4 <f_lseek+0x206>
    43c6:	52 c0       	rjmp	.+164    	; 0x446c <f_lseek+0x29e>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    43c8:	80 81       	ld	r24, Z
    43ca:	91 81       	ldd	r25, Z+1	; 0x01
    43cc:	0e 94 8a 11 	call	0x2314	; 0x2314 <get_fat>
    43d0:	ab 01       	movw	r20, r22
    43d2:	bc 01       	movw	r22, r24
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    43d4:	4f 3f       	cpi	r20, 0xFF	; 255
    43d6:	bf ef       	ldi	r27, 0xFF	; 255
    43d8:	5b 07       	cpc	r21, r27
    43da:	bf ef       	ldi	r27, 0xFF	; 255
    43dc:	6b 07       	cpc	r22, r27
    43de:	bf ef       	ldi	r27, 0xFF	; 255
    43e0:	7b 07       	cpc	r23, r27
    43e2:	41 f4       	brne	.+16     	; 0x43f4 <f_lseek+0x226>
    43e4:	5e 82       	std	Y+6, r5	; 0x06
    43e6:	4d 82       	std	Y+5, r4	; 0x05
    43e8:	f2 01       	movw	r30, r4
    43ea:	84 81       	ldd	r24, Z+4	; 0x04
    43ec:	80 68       	ori	r24, 0x80	; 128
    43ee:	84 83       	std	Z+4, r24	; 0x04
    43f0:	11 e0       	ldi	r17, 0x01	; 1
    43f2:	f4 c0       	rjmp	.+488    	; 0x45dc <f_lseek+0x40e>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    43f4:	42 30       	cpi	r20, 0x02	; 2
    43f6:	51 05       	cpc	r21, r1
    43f8:	61 05       	cpc	r22, r1
    43fa:	71 05       	cpc	r23, r1
    43fc:	60 f0       	brcs	.+24     	; 0x4416 <f_lseek+0x248>
    43fe:	d2 01       	movw	r26, r4
    4400:	ed 91       	ld	r30, X+
    4402:	fc 91       	ld	r31, X
    4404:	82 8d       	ldd	r24, Z+26	; 0x1a
    4406:	93 8d       	ldd	r25, Z+27	; 0x1b
    4408:	a4 8d       	ldd	r26, Z+28	; 0x1c
    440a:	b5 8d       	ldd	r27, Z+29	; 0x1d
    440c:	48 17       	cp	r20, r24
    440e:	59 07       	cpc	r21, r25
    4410:	6a 07       	cpc	r22, r26
    4412:	7b 07       	cpc	r23, r27
    4414:	40 f0       	brcs	.+16     	; 0x4426 <f_lseek+0x258>
    4416:	5e 82       	std	Y+6, r5	; 0x06
    4418:	4d 82       	std	Y+5, r4	; 0x05
    441a:	f2 01       	movw	r30, r4
    441c:	84 81       	ldd	r24, Z+4	; 0x04
    441e:	80 68       	ori	r24, 0x80	; 128
    4420:	84 83       	std	Z+4, r24	; 0x04
    4422:	12 e0       	ldi	r17, 0x02	; 2
    4424:	db c0       	rjmp	.+438    	; 0x45dc <f_lseek+0x40e>
					fp->clust = clst;
    4426:	d2 01       	movw	r26, r4
    4428:	52 96       	adiw	r26, 0x12	; 18
    442a:	4d 93       	st	X+, r20
    442c:	5d 93       	st	X+, r21
    442e:	6d 93       	st	X+, r22
    4430:	7c 93       	st	X, r23
    4432:	55 97       	sbiw	r26, 0x15	; 21
					fp->fptr += bcs;
    4434:	16 96       	adiw	r26, 0x06	; 6
    4436:	8d 91       	ld	r24, X+
    4438:	9d 91       	ld	r25, X+
    443a:	0d 90       	ld	r0, X+
    443c:	bc 91       	ld	r27, X
    443e:	a0 2d       	mov	r26, r0
    4440:	88 0d       	add	r24, r8
    4442:	99 1d       	adc	r25, r9
    4444:	aa 1d       	adc	r26, r10
    4446:	bb 1d       	adc	r27, r11
    4448:	f2 01       	movw	r30, r4
    444a:	86 83       	std	Z+6, r24	; 0x06
    444c:	97 83       	std	Z+7, r25	; 0x07
    444e:	a0 87       	std	Z+8, r26	; 0x08
    4450:	b1 87       	std	Z+9, r27	; 0x09
					ofs -= bcs;
    4452:	c8 18       	sub	r12, r8
    4454:	d9 08       	sbc	r13, r9
    4456:	ea 08       	sbc	r14, r10
    4458:	fb 08       	sbc	r15, r11
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
    445a:	8c 14       	cp	r8, r12
    445c:	9d 04       	cpc	r9, r13
    445e:	ae 04       	cpc	r10, r14
    4460:	bf 04       	cpc	r11, r15
    4462:	08 f4       	brcc	.+2      	; 0x4466 <f_lseek+0x298>
    4464:	a1 cf       	rjmp	.-190    	; 0x43a8 <f_lseek+0x1da>
    4466:	5e 82       	std	Y+6, r5	; 0x06
    4468:	4d 82       	std	Y+5, r4	; 0x05
    446a:	04 c0       	rjmp	.+8      	; 0x4474 <f_lseek+0x2a6>
    446c:	5e 82       	std	Y+6, r5	; 0x06
    446e:	4d 82       	std	Y+5, r4	; 0x05
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
						if (clst == 0) {				/* When disk gets full, clip file size */
							ofs = bcs; break;
    4470:	75 01       	movw	r14, r10
    4472:	64 01       	movw	r12, r8
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
    4474:	ed 81       	ldd	r30, Y+5	; 0x05
    4476:	fe 81       	ldd	r31, Y+6	; 0x06
    4478:	86 81       	ldd	r24, Z+6	; 0x06
    447a:	97 81       	ldd	r25, Z+7	; 0x07
    447c:	a0 85       	ldd	r26, Z+8	; 0x08
    447e:	b1 85       	ldd	r27, Z+9	; 0x09
    4480:	8c 0d       	add	r24, r12
    4482:	9d 1d       	adc	r25, r13
    4484:	ae 1d       	adc	r26, r14
    4486:	bf 1d       	adc	r27, r15
    4488:	86 83       	std	Z+6, r24	; 0x06
    448a:	97 83       	std	Z+7, r25	; 0x07
    448c:	a0 87       	std	Z+8, r26	; 0x08
    448e:	b1 87       	std	Z+9, r27	; 0x09
				if (ofs % SS(fp->fs)) {
    4490:	d7 01       	movw	r26, r14
    4492:	c6 01       	movw	r24, r12
    4494:	91 70       	andi	r25, 0x01	; 1
    4496:	a0 70       	andi	r26, 0x00	; 0
    4498:	b0 70       	andi	r27, 0x00	; 0
    449a:	00 97       	sbiw	r24, 0x00	; 0
    449c:	a1 05       	cpc	r26, r1
    449e:	b1 05       	cpc	r27, r1
    44a0:	49 f1       	breq	.+82     	; 0x44f4 <f_lseek+0x326>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    44a2:	80 81       	ld	r24, Z
    44a4:	91 81       	ldd	r25, Z+1	; 0x01
    44a6:	0e 94 54 11 	call	0x22a8	; 0x22a8 <clust2sect>
    44aa:	dc 01       	movw	r26, r24
    44ac:	cb 01       	movw	r24, r22
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    44ae:	00 97       	sbiw	r24, 0x00	; 0
    44b0:	a1 05       	cpc	r26, r1
    44b2:	b1 05       	cpc	r27, r1
    44b4:	59 f4       	brne	.+22     	; 0x44cc <f_lseek+0x2fe>
    44b6:	ad 81       	ldd	r26, Y+5	; 0x05
    44b8:	be 81       	ldd	r27, Y+6	; 0x06
    44ba:	14 96       	adiw	r26, 0x04	; 4
    44bc:	8c 91       	ld	r24, X
    44be:	14 97       	sbiw	r26, 0x04	; 4
    44c0:	80 68       	ori	r24, 0x80	; 128
    44c2:	14 96       	adiw	r26, 0x04	; 4
    44c4:	8c 93       	st	X, r24
    44c6:	14 97       	sbiw	r26, 0x04	; 4
    44c8:	12 e0       	ldi	r17, 0x02	; 2
    44ca:	88 c0       	rjmp	.+272    	; 0x45dc <f_lseek+0x40e>
					nsect += ofs / SS(fp->fs);
    44cc:	46 01       	movw	r8, r12
    44ce:	57 01       	movw	r10, r14
    44d0:	07 2e       	mov	r0, r23
    44d2:	79 e0       	ldi	r23, 0x09	; 9
    44d4:	b6 94       	lsr	r11
    44d6:	a7 94       	ror	r10
    44d8:	97 94       	ror	r9
    44da:	87 94       	ror	r8
    44dc:	7a 95       	dec	r23
    44de:	d1 f7       	brne	.-12     	; 0x44d4 <f_lseek+0x306>
    44e0:	70 2d       	mov	r23, r0
    44e2:	88 0e       	add	r8, r24
    44e4:	99 1e       	adc	r9, r25
    44e6:	aa 1e       	adc	r10, r26
    44e8:	bb 1e       	adc	r11, r27
    44ea:	07 c0       	rjmp	.+14     	; 0x44fa <f_lseek+0x32c>
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
    44ec:	88 24       	eor	r8, r8
    44ee:	99 24       	eor	r9, r9
    44f0:	54 01       	movw	r10, r8
    44f2:	03 c0       	rjmp	.+6      	; 0x44fa <f_lseek+0x32c>
    44f4:	88 24       	eor	r8, r8
    44f6:	99 24       	eor	r9, r9
    44f8:	54 01       	movw	r10, r8
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
					nsect += ofs / SS(fp->fs);
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    44fa:	ed 81       	ldd	r30, Y+5	; 0x05
    44fc:	fe 81       	ldd	r31, Y+6	; 0x06
    44fe:	86 81       	ldd	r24, Z+6	; 0x06
    4500:	97 81       	ldd	r25, Z+7	; 0x07
    4502:	a0 85       	ldd	r26, Z+8	; 0x08
    4504:	b1 85       	ldd	r27, Z+9	; 0x09
    4506:	91 70       	andi	r25, 0x01	; 1
    4508:	a0 70       	andi	r26, 0x00	; 0
    450a:	b0 70       	andi	r27, 0x00	; 0
    450c:	00 97       	sbiw	r24, 0x00	; 0
    450e:	a1 05       	cpc	r26, r1
    4510:	b1 05       	cpc	r27, r1
    4512:	09 f4       	brne	.+2      	; 0x4516 <f_lseek+0x348>
    4514:	4b c0       	rjmp	.+150    	; 0x45ac <f_lseek+0x3de>
    4516:	c6 88       	ldd	r12, Z+22	; 0x16
    4518:	d7 88       	ldd	r13, Z+23	; 0x17
    451a:	e0 8c       	ldd	r14, Z+24	; 0x18
    451c:	f1 8c       	ldd	r15, Z+25	; 0x19
    451e:	c8 14       	cp	r12, r8
    4520:	d9 04       	cpc	r13, r9
    4522:	ea 04       	cpc	r14, r10
    4524:	fb 04       	cpc	r15, r11
    4526:	09 f4       	brne	.+2      	; 0x452a <f_lseek+0x35c>
    4528:	41 c0       	rjmp	.+130    	; 0x45ac <f_lseek+0x3de>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
    452a:	84 81       	ldd	r24, Z+4	; 0x04
    452c:	86 ff       	sbrs	r24, 6
    452e:	1f c0       	rjmp	.+62     	; 0x456e <f_lseek+0x3a0>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    4530:	01 90       	ld	r0, Z+
    4532:	f0 81       	ld	r31, Z
    4534:	e0 2d       	mov	r30, r0
    4536:	6d 81       	ldd	r22, Y+5	; 0x05
    4538:	7e 81       	ldd	r23, Y+6	; 0x06
    453a:	60 5e       	subi	r22, 0xE0	; 224
    453c:	7f 4f       	sbci	r23, 0xFF	; 255
    453e:	81 81       	ldd	r24, Z+1	; 0x01
    4540:	a7 01       	movw	r20, r14
    4542:	96 01       	movw	r18, r12
    4544:	01 e0       	ldi	r16, 0x01	; 1
    4546:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <disk_write>
    454a:	88 23       	and	r24, r24
    454c:	59 f0       	breq	.+22     	; 0x4564 <f_lseek+0x396>
					ABORT(fp->fs, FR_DISK_ERR);
    454e:	ad 81       	ldd	r26, Y+5	; 0x05
    4550:	be 81       	ldd	r27, Y+6	; 0x06
    4552:	14 96       	adiw	r26, 0x04	; 4
    4554:	8c 91       	ld	r24, X
    4556:	14 97       	sbiw	r26, 0x04	; 4
    4558:	80 68       	ori	r24, 0x80	; 128
    455a:	14 96       	adiw	r26, 0x04	; 4
    455c:	8c 93       	st	X, r24
    455e:	14 97       	sbiw	r26, 0x04	; 4
    4560:	11 e0       	ldi	r17, 0x01	; 1
    4562:	3c c0       	rjmp	.+120    	; 0x45dc <f_lseek+0x40e>
				fp->flag &= ~FA__DIRTY;
    4564:	ed 81       	ldd	r30, Y+5	; 0x05
    4566:	fe 81       	ldd	r31, Y+6	; 0x06
    4568:	84 81       	ldd	r24, Z+4	; 0x04
    456a:	8f 7b       	andi	r24, 0xBF	; 191
    456c:	84 83       	std	Z+4, r24	; 0x04
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
    456e:	ad 81       	ldd	r26, Y+5	; 0x05
    4570:	be 81       	ldd	r27, Y+6	; 0x06
    4572:	ed 91       	ld	r30, X+
    4574:	fc 91       	ld	r31, X
    4576:	11 97       	sbiw	r26, 0x01	; 1
    4578:	bd 01       	movw	r22, r26
    457a:	60 5e       	subi	r22, 0xE0	; 224
    457c:	7f 4f       	sbci	r23, 0xFF	; 255
    457e:	81 81       	ldd	r24, Z+1	; 0x01
    4580:	a5 01       	movw	r20, r10
    4582:	94 01       	movw	r18, r8
    4584:	01 e0       	ldi	r16, 0x01	; 1
    4586:	0e 94 99 02 	call	0x532	; 0x532 <disk_read>
    458a:	88 23       	and	r24, r24
    458c:	39 f0       	breq	.+14     	; 0x459c <f_lseek+0x3ce>
				ABORT(fp->fs, FR_DISK_ERR);
    458e:	ed 81       	ldd	r30, Y+5	; 0x05
    4590:	fe 81       	ldd	r31, Y+6	; 0x06
    4592:	84 81       	ldd	r24, Z+4	; 0x04
    4594:	80 68       	ori	r24, 0x80	; 128
    4596:	84 83       	std	Z+4, r24	; 0x04
    4598:	11 e0       	ldi	r17, 0x01	; 1
    459a:	20 c0       	rjmp	.+64     	; 0x45dc <f_lseek+0x40e>
#endif
			fp->dsect = nsect;
    459c:	ad 81       	ldd	r26, Y+5	; 0x05
    459e:	be 81       	ldd	r27, Y+6	; 0x06
    45a0:	56 96       	adiw	r26, 0x16	; 22
    45a2:	8d 92       	st	X+, r8
    45a4:	9d 92       	st	X+, r9
    45a6:	ad 92       	st	X+, r10
    45a8:	bc 92       	st	X, r11
    45aa:	59 97       	sbiw	r26, 0x19	; 25
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
    45ac:	ed 81       	ldd	r30, Y+5	; 0x05
    45ae:	fe 81       	ldd	r31, Y+6	; 0x06
    45b0:	86 81       	ldd	r24, Z+6	; 0x06
    45b2:	97 81       	ldd	r25, Z+7	; 0x07
    45b4:	a0 85       	ldd	r26, Z+8	; 0x08
    45b6:	b1 85       	ldd	r27, Z+9	; 0x09
    45b8:	42 85       	ldd	r20, Z+10	; 0x0a
    45ba:	53 85       	ldd	r21, Z+11	; 0x0b
    45bc:	64 85       	ldd	r22, Z+12	; 0x0c
    45be:	75 85       	ldd	r23, Z+13	; 0x0d
    45c0:	48 17       	cp	r20, r24
    45c2:	59 07       	cpc	r21, r25
    45c4:	6a 07       	cpc	r22, r26
    45c6:	7b 07       	cpc	r23, r27
    45c8:	48 f4       	brcc	.+18     	; 0x45dc <f_lseek+0x40e>
			fp->fsize = fp->fptr;
    45ca:	82 87       	std	Z+10, r24	; 0x0a
    45cc:	93 87       	std	Z+11, r25	; 0x0b
    45ce:	a4 87       	std	Z+12, r26	; 0x0c
    45d0:	b5 87       	std	Z+13, r27	; 0x0d
			fp->flag |= FA__WRITTEN;
    45d2:	84 81       	ldd	r24, Z+4	; 0x04
    45d4:	80 62       	ori	r24, 0x20	; 32
    45d6:	84 83       	std	Z+4, r24	; 0x04
    45d8:	01 c0       	rjmp	.+2      	; 0x45dc <f_lseek+0x40e>


	res = validate(fp);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)			/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    45da:	12 e0       	ldi	r17, 0x02	; 2
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
    45dc:	81 2f       	mov	r24, r17
    45de:	26 96       	adiw	r28, 0x06	; 6
    45e0:	0f b6       	in	r0, 0x3f	; 63
    45e2:	f8 94       	cli
    45e4:	de bf       	out	0x3e, r29	; 62
    45e6:	0f be       	out	0x3f, r0	; 63
    45e8:	cd bf       	out	0x3d, r28	; 61
    45ea:	df 91       	pop	r29
    45ec:	cf 91       	pop	r28
    45ee:	1f 91       	pop	r17
    45f0:	0f 91       	pop	r16
    45f2:	ff 90       	pop	r15
    45f4:	ef 90       	pop	r14
    45f6:	df 90       	pop	r13
    45f8:	cf 90       	pop	r12
    45fa:	bf 90       	pop	r11
    45fc:	af 90       	pop	r10
    45fe:	9f 90       	pop	r9
    4600:	8f 90       	pop	r8
    4602:	7f 90       	pop	r7
    4604:	6f 90       	pop	r6
    4606:	5f 90       	pop	r5
    4608:	4f 90       	pop	r4
    460a:	3f 90       	pop	r3
    460c:	2f 90       	pop	r2
    460e:	08 95       	ret

00004610 <f_opendir>:

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const TCHAR *path	/* Pointer to the directory path */
)
{
    4610:	ef 92       	push	r14
    4612:	ff 92       	push	r15
    4614:	0f 93       	push	r16
    4616:	1f 93       	push	r17
    4618:	cf 93       	push	r28
    461a:	df 93       	push	r29
    461c:	cd b7       	in	r28, 0x3d	; 61
    461e:	de b7       	in	r29, 0x3e	; 62
    4620:	2e 97       	sbiw	r28, 0x0e	; 14
    4622:	0f b6       	in	r0, 0x3f	; 63
    4624:	f8 94       	cli
    4626:	de bf       	out	0x3e, r29	; 62
    4628:	0f be       	out	0x3f, r0	; 63
    462a:	cd bf       	out	0x3d, r28	; 61
    462c:	8c 01       	movw	r16, r24
    462e:	7e 87       	std	Y+14, r23	; 0x0e
    4630:	6d 87       	std	Y+13, r22	; 0x0d
	FRESULT res;
	FATFS *fs;
	DEF_NAMEBUF;


	if (!dj) return FR_INVALID_OBJECT;
    4632:	00 97       	sbiw	r24, 0x00	; 0
    4634:	09 f4       	brne	.+2      	; 0x4638 <f_opendir+0x28>
    4636:	4c c0       	rjmp	.+152    	; 0x46d0 <f_opendir+0xc0>

	res = chk_mounted(&path, &dj->fs, 0);
    4638:	ce 01       	movw	r24, r28
    463a:	0d 96       	adiw	r24, 0x0d	; 13
    463c:	b8 01       	movw	r22, r16
    463e:	40 e0       	ldi	r20, 0x00	; 0
    4640:	0e 94 ed 0b 	call	0x17da	; 0x17da <chk_mounted>
	fs = dj->fs;
    4644:	d8 01       	movw	r26, r16
    4646:	ed 90       	ld	r14, X+
    4648:	fc 90       	ld	r15, X
    464a:	11 97       	sbiw	r26, 0x01	; 1
	if (res == FR_OK) {
    464c:	88 23       	and	r24, r24
    464e:	e1 f5       	brne	.+120    	; 0x46c8 <f_opendir+0xb8>
		INIT_BUF(*dj);
    4650:	ce 01       	movw	r24, r28
    4652:	01 96       	adiw	r24, 0x01	; 1
    4654:	55 96       	adiw	r26, 0x15	; 21
    4656:	9c 93       	st	X, r25
    4658:	8e 93       	st	-X, r24
    465a:	54 97       	sbiw	r26, 0x14	; 20
		res = follow_path(dj, path);			/* Follow the path to the directory */
    465c:	6d 85       	ldd	r22, Y+13	; 0x0d
    465e:	7e 85       	ldd	r23, Y+14	; 0x0e
    4660:	c8 01       	movw	r24, r16
    4662:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <follow_path>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
    4666:	88 23       	and	r24, r24
    4668:	11 f5       	brne	.+68     	; 0x46ae <f_opendir+0x9e>
			if (dj->dir) {						/* It is not the root dir */
    466a:	d8 01       	movw	r26, r16
    466c:	52 96       	adiw	r26, 0x12	; 18
    466e:	ed 91       	ld	r30, X+
    4670:	fc 91       	ld	r31, X
    4672:	53 97       	sbiw	r26, 0x13	; 19
    4674:	30 97       	sbiw	r30, 0x00	; 0
    4676:	71 f0       	breq	.+28     	; 0x4694 <f_opendir+0x84>
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
    4678:	83 85       	ldd	r24, Z+11	; 0x0b
    467a:	84 ff       	sbrs	r24, 4
    467c:	1b c0       	rjmp	.+54     	; 0x46b4 <f_opendir+0xa4>
					dj->sclust = ld_clust(fs, dj->dir);
    467e:	c7 01       	movw	r24, r14
    4680:	bf 01       	movw	r22, r30
    4682:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ld_clust>
    4686:	dc 01       	movw	r26, r24
    4688:	cb 01       	movw	r24, r22
    468a:	f8 01       	movw	r30, r16
    468c:	86 83       	std	Z+6, r24	; 0x06
    468e:	97 83       	std	Z+7, r25	; 0x07
    4690:	a0 87       	std	Z+8, r26	; 0x08
    4692:	b1 87       	std	Z+9, r27	; 0x09
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dj->id = fs->id;
    4694:	d7 01       	movw	r26, r14
    4696:	16 96       	adiw	r26, 0x06	; 6
    4698:	8d 91       	ld	r24, X+
    469a:	9c 91       	ld	r25, X
    469c:	17 97       	sbiw	r26, 0x07	; 7
    469e:	f8 01       	movw	r30, r16
    46a0:	93 83       	std	Z+3, r25	; 0x03
    46a2:	82 83       	std	Z+2, r24	; 0x02
				res = dir_sdi(dj, 0);			/* Rewind dir */
    46a4:	c8 01       	movw	r24, r16
    46a6:	60 e0       	ldi	r22, 0x00	; 0
    46a8:	70 e0       	ldi	r23, 0x00	; 0
    46aa:	0e 94 c1 12 	call	0x2582	; 0x2582 <dir_sdi>
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    46ae:	84 30       	cpi	r24, 0x04	; 4
    46b0:	11 f4       	brne	.+4      	; 0x46b6 <f_opendir+0xa6>
    46b2:	04 c0       	rjmp	.+8      	; 0x46bc <f_opendir+0xac>
		if (res == FR_OK) {						/* Follow completed */
			if (dj->dir) {						/* It is not the root dir */
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
					dj->sclust = ld_clust(fs, dj->dir);
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
    46b4:	85 e0       	ldi	r24, 0x05	; 5
				dj->id = fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
    46b6:	88 23       	and	r24, r24
    46b8:	61 f0       	breq	.+24     	; 0x46d2 <f_opendir+0xc2>
    46ba:	01 c0       	rjmp	.+2      	; 0x46be <f_opendir+0xae>
			if (res == FR_OK) {
				dj->id = fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    46bc:	85 e0       	ldi	r24, 0x05	; 5
		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
    46be:	d8 01       	movw	r26, r16
    46c0:	11 96       	adiw	r26, 0x01	; 1
    46c2:	1c 92       	st	X, r1
    46c4:	1e 92       	st	-X, r1
    46c6:	05 c0       	rjmp	.+10     	; 0x46d2 <f_opendir+0xc2>
	} else {
		dj->fs = 0;
    46c8:	f8 01       	movw	r30, r16
    46ca:	11 82       	std	Z+1, r1	; 0x01
    46cc:	10 82       	st	Z, r1
    46ce:	01 c0       	rjmp	.+2      	; 0x46d2 <f_opendir+0xc2>
	FRESULT res;
	FATFS *fs;
	DEF_NAMEBUF;


	if (!dj) return FR_INVALID_OBJECT;
    46d0:	89 e0       	ldi	r24, 0x09	; 9
	} else {
		dj->fs = 0;
	}

	LEAVE_FF(fs, res);
}
    46d2:	2e 96       	adiw	r28, 0x0e	; 14
    46d4:	0f b6       	in	r0, 0x3f	; 63
    46d6:	f8 94       	cli
    46d8:	de bf       	out	0x3e, r29	; 62
    46da:	0f be       	out	0x3f, r0	; 63
    46dc:	cd bf       	out	0x3d, r28	; 61
    46de:	df 91       	pop	r29
    46e0:	cf 91       	pop	r28
    46e2:	1f 91       	pop	r17
    46e4:	0f 91       	pop	r16
    46e6:	ff 90       	pop	r15
    46e8:	ef 90       	pop	r14
    46ea:	08 95       	ret

000046ec <f_readdir>:

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
    46ec:	cf 92       	push	r12
    46ee:	df 92       	push	r13
    46f0:	ef 92       	push	r14
    46f2:	ff 92       	push	r15
    46f4:	1f 93       	push	r17
    46f6:	cf 93       	push	r28
    46f8:	df 93       	push	r29
    46fa:	cd b7       	in	r28, 0x3d	; 61
    46fc:	de b7       	in	r29, 0x3e	; 62
    46fe:	2c 97       	sbiw	r28, 0x0c	; 12
    4700:	0f b6       	in	r0, 0x3f	; 63
    4702:	f8 94       	cli
    4704:	de bf       	out	0x3e, r29	; 62
    4706:	0f be       	out	0x3f, r0	; 63
    4708:	cd bf       	out	0x3d, r28	; 61
    470a:	7c 01       	movw	r14, r24
    470c:	6b 01       	movw	r12, r22
	FRESULT res;
	DEF_NAMEBUF;


	res = validate(dj);						/* Check validity of the object */
    470e:	0e 94 30 0b 	call	0x1660	; 0x1660 <validate>
    4712:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    4714:	88 23       	and	r24, r24
    4716:	81 f5       	brne	.+96     	; 0x4778 <f_readdir+0x8c>
		if (!fno) {
    4718:	c1 14       	cp	r12, r1
    471a:	d1 04       	cpc	r13, r1
    471c:	39 f4       	brne	.+14     	; 0x472c <f_readdir+0x40>
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
    471e:	c7 01       	movw	r24, r14
    4720:	60 e0       	ldi	r22, 0x00	; 0
    4722:	70 e0       	ldi	r23, 0x00	; 0
    4724:	0e 94 c1 12 	call	0x2582	; 0x2582 <dir_sdi>
    4728:	18 2f       	mov	r17, r24
    472a:	26 c0       	rjmp	.+76     	; 0x4778 <f_readdir+0x8c>
		} else {
			INIT_BUF(*dj);
    472c:	ce 01       	movw	r24, r28
    472e:	01 96       	adiw	r24, 0x01	; 1
    4730:	f7 01       	movw	r30, r14
    4732:	95 8b       	std	Z+21, r25	; 0x15
    4734:	84 8b       	std	Z+20, r24	; 0x14
			res = dir_read(dj);				/* Read an directory item */
    4736:	c7 01       	movw	r24, r14
    4738:	0e 94 a4 19 	call	0x3348	; 0x3348 <dir_read>
			if (res == FR_NO_FILE) {		/* Reached end of dir */
    473c:	84 30       	cpi	r24, 0x04	; 4
    473e:	31 f4       	brne	.+12     	; 0x474c <f_readdir+0x60>
				dj->sect = 0;
    4740:	f7 01       	movw	r30, r14
    4742:	16 86       	std	Z+14, r1	; 0x0e
    4744:	17 86       	std	Z+15, r1	; 0x0f
    4746:	10 8a       	std	Z+16, r1	; 0x10
    4748:	11 8a       	std	Z+17, r1	; 0x11
    474a:	02 c0       	rjmp	.+4      	; 0x4750 <f_readdir+0x64>
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
    474c:	88 23       	and	r24, r24
    474e:	89 f4       	brne	.+34     	; 0x4772 <f_readdir+0x86>
				get_fileinfo(dj, fno);		/* Get the object information */
    4750:	c7 01       	movw	r24, r14
    4752:	b6 01       	movw	r22, r12
    4754:	0e 94 9e 0a 	call	0x153c	; 0x153c <get_fileinfo>
				res = dir_next(dj, 0);		/* Increment index for next */
    4758:	c7 01       	movw	r24, r14
    475a:	60 e0       	ldi	r22, 0x00	; 0
    475c:	70 e0       	ldi	r23, 0x00	; 0
    475e:	0e 94 d5 15 	call	0x2baa	; 0x2baa <dir_next>
				if (res == FR_NO_FILE) {
    4762:	84 30       	cpi	r24, 0x04	; 4
    4764:	41 f4       	brne	.+16     	; 0x4776 <f_readdir+0x8a>
					dj->sect = 0;
    4766:	f7 01       	movw	r30, r14
    4768:	16 86       	std	Z+14, r1	; 0x0e
    476a:	17 86       	std	Z+15, r1	; 0x0f
    476c:	10 8a       	std	Z+16, r1	; 0x10
    476e:	11 8a       	std	Z+17, r1	; 0x11
    4770:	03 c0       	rjmp	.+6      	; 0x4778 <f_readdir+0x8c>
	if (res == FR_OK) {
		if (!fno) {
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
		} else {
			INIT_BUF(*dj);
			res = dir_read(dj);				/* Read an directory item */
    4772:	18 2f       	mov	r17, r24
    4774:	01 c0       	rjmp	.+2      	; 0x4778 <f_readdir+0x8c>
				dj->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj, 0);		/* Increment index for next */
    4776:	18 2f       	mov	r17, r24
			FREE_BUF();
		}
	}

	LEAVE_FF(dj->fs, res);
}
    4778:	81 2f       	mov	r24, r17
    477a:	2c 96       	adiw	r28, 0x0c	; 12
    477c:	0f b6       	in	r0, 0x3f	; 63
    477e:	f8 94       	cli
    4780:	de bf       	out	0x3e, r29	; 62
    4782:	0f be       	out	0x3f, r0	; 63
    4784:	cd bf       	out	0x3d, r28	; 61
    4786:	df 91       	pop	r29
    4788:	cf 91       	pop	r28
    478a:	1f 91       	pop	r17
    478c:	ff 90       	pop	r15
    478e:	ef 90       	pop	r14
    4790:	df 90       	pop	r13
    4792:	cf 90       	pop	r12
    4794:	08 95       	ret

00004796 <f_stat>:

FRESULT f_stat (
	const TCHAR *path,	/* Pointer to the file path */
	FILINFO *fno		/* Pointer to file information to return */
)
{
    4796:	ef 92       	push	r14
    4798:	ff 92       	push	r15
    479a:	1f 93       	push	r17
    479c:	cf 93       	push	r28
    479e:	df 93       	push	r29
    47a0:	cd b7       	in	r28, 0x3d	; 61
    47a2:	de b7       	in	r29, 0x3e	; 62
    47a4:	a4 97       	sbiw	r28, 0x24	; 36
    47a6:	0f b6       	in	r0, 0x3f	; 63
    47a8:	f8 94       	cli
    47aa:	de bf       	out	0x3e, r29	; 62
    47ac:	0f be       	out	0x3f, r0	; 63
    47ae:	cd bf       	out	0x3d, r28	; 61
    47b0:	9c a3       	lds	r25, 0x5c
    47b2:	8b a3       	lds	r24, 0x5b
    47b4:	7b 01       	movw	r14, r22
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
    47b6:	ce 01       	movw	r24, r28
    47b8:	83 96       	adiw	r24, 0x23	; 35
    47ba:	be 01       	movw	r22, r28
    47bc:	6f 5f       	subi	r22, 0xFF	; 255
    47be:	7f 4f       	sbci	r23, 0xFF	; 255
    47c0:	40 e0       	ldi	r20, 0x00	; 0
    47c2:	0e 94 ed 0b 	call	0x17da	; 0x17da <chk_mounted>
    47c6:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    47c8:	88 23       	and	r24, r24
    47ca:	c1 f4       	brne	.+48     	; 0x47fc <f_stat+0x66>
		INIT_BUF(dj);
    47cc:	ce 01       	movw	r24, r28
    47ce:	47 96       	adiw	r24, 0x17	; 23
    47d0:	9e 8b       	std	Y+22, r25	; 0x16
    47d2:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    47d4:	6b a1       	lds	r22, 0x4b
    47d6:	7c a1       	lds	r23, 0x4c
    47d8:	ce 01       	movw	r24, r28
    47da:	01 96       	adiw	r24, 0x01	; 1
    47dc:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <follow_path>
    47e0:	18 2f       	mov	r17, r24
		if (res == FR_OK) {				/* Follow completed */
    47e2:	88 23       	and	r24, r24
    47e4:	59 f4       	brne	.+22     	; 0x47fc <f_stat+0x66>
			if (dj.dir)		/* Found an object */
    47e6:	8b 89       	ldd	r24, Y+19	; 0x13
    47e8:	9c 89       	ldd	r25, Y+20	; 0x14
    47ea:	00 97       	sbiw	r24, 0x00	; 0
    47ec:	31 f0       	breq	.+12     	; 0x47fa <f_stat+0x64>
				get_fileinfo(&dj, fno);
    47ee:	ce 01       	movw	r24, r28
    47f0:	01 96       	adiw	r24, 0x01	; 1
    47f2:	b7 01       	movw	r22, r14
    47f4:	0e 94 9e 0a 	call	0x153c	; 0x153c <get_fileinfo>
    47f8:	01 c0       	rjmp	.+2      	; 0x47fc <f_stat+0x66>
			else			/* It is root dir */
				res = FR_INVALID_NAME;
    47fa:	16 e0       	ldi	r17, 0x06	; 6
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    47fc:	81 2f       	mov	r24, r17
    47fe:	a4 96       	adiw	r28, 0x24	; 36
    4800:	0f b6       	in	r0, 0x3f	; 63
    4802:	f8 94       	cli
    4804:	de bf       	out	0x3e, r29	; 62
    4806:	0f be       	out	0x3f, r0	; 63
    4808:	cd bf       	out	0x3d, r28	; 61
    480a:	df 91       	pop	r29
    480c:	cf 91       	pop	r28
    480e:	1f 91       	pop	r17
    4810:	ff 90       	pop	r15
    4812:	ef 90       	pop	r14
    4814:	08 95       	ret

00004816 <f_getfree>:
FRESULT f_getfree (
	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
)
{
    4816:	2f 92       	push	r2
    4818:	3f 92       	push	r3
    481a:	4f 92       	push	r4
    481c:	5f 92       	push	r5
    481e:	6f 92       	push	r6
    4820:	7f 92       	push	r7
    4822:	8f 92       	push	r8
    4824:	9f 92       	push	r9
    4826:	af 92       	push	r10
    4828:	bf 92       	push	r11
    482a:	cf 92       	push	r12
    482c:	df 92       	push	r13
    482e:	ef 92       	push	r14
    4830:	ff 92       	push	r15
    4832:	0f 93       	push	r16
    4834:	1f 93       	push	r17
    4836:	cf 93       	push	r28
    4838:	df 93       	push	r29
    483a:	cd b7       	in	r28, 0x3d	; 61
    483c:	de b7       	in	r29, 0x3e	; 62
    483e:	2c 97       	sbiw	r28, 0x0c	; 12
    4840:	0f b6       	in	r0, 0x3f	; 63
    4842:	f8 94       	cli
    4844:	de bf       	out	0x3e, r29	; 62
    4846:	0f be       	out	0x3f, r0	; 63
    4848:	cd bf       	out	0x3d, r28	; 61
    484a:	9a 83       	std	Y+2, r25	; 0x02
    484c:	89 83       	std	Y+1, r24	; 0x01
    484e:	78 87       	std	Y+8, r23	; 0x08
    4850:	6f 83       	std	Y+7, r22	; 0x07
    4852:	8a 01       	movw	r16, r20
	UINT i;
	BYTE fat, *p;


	/* Get drive number */
	res = chk_mounted(&path, fatfs, 0);
    4854:	ce 01       	movw	r24, r28
    4856:	01 96       	adiw	r24, 0x01	; 1
    4858:	ba 01       	movw	r22, r20
    485a:	40 e0       	ldi	r20, 0x00	; 0
    485c:	0e 94 ed 0b 	call	0x17da	; 0x17da <chk_mounted>
    4860:	b8 2e       	mov	r11, r24
	fs = *fatfs;
    4862:	d8 01       	movw	r26, r16
    4864:	8d 90       	ld	r8, X+
    4866:	9c 90       	ld	r9, X
    4868:	11 97       	sbiw	r26, 0x01	; 1
	if (res == FR_OK) {
    486a:	88 23       	and	r24, r24
    486c:	09 f0       	breq	.+2      	; 0x4870 <f_getfree+0x5a>
    486e:	03 c1       	rjmp	.+518    	; 0x4a76 <f_getfree+0x260>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
    4870:	f4 01       	movw	r30, r8
    4872:	86 85       	ldd	r24, Z+14	; 0x0e
    4874:	97 85       	ldd	r25, Z+15	; 0x0f
    4876:	a0 89       	ldd	r26, Z+16	; 0x10
    4878:	b1 89       	ldd	r27, Z+17	; 0x11
    487a:	c2 8c       	ldd	r12, Z+26	; 0x1a
    487c:	d3 8c       	ldd	r13, Z+27	; 0x1b
    487e:	e4 8c       	ldd	r14, Z+28	; 0x1c
    4880:	f5 8c       	ldd	r15, Z+29	; 0x1d
    4882:	b7 01       	movw	r22, r14
    4884:	a6 01       	movw	r20, r12
    4886:	42 50       	subi	r20, 0x02	; 2
    4888:	50 40       	sbci	r21, 0x00	; 0
    488a:	60 40       	sbci	r22, 0x00	; 0
    488c:	70 40       	sbci	r23, 0x00	; 0
    488e:	48 17       	cp	r20, r24
    4890:	59 07       	cpc	r21, r25
    4892:	6a 07       	cpc	r22, r26
    4894:	7b 07       	cpc	r23, r27
    4896:	38 f0       	brcs	.+14     	; 0x48a6 <f_getfree+0x90>
			*nclst = fs->free_clust;
    4898:	ef 81       	ldd	r30, Y+7	; 0x07
    489a:	f8 85       	ldd	r31, Y+8	; 0x08
    489c:	80 83       	st	Z, r24
    489e:	91 83       	std	Z+1, r25	; 0x01
    48a0:	a2 83       	std	Z+2, r26	; 0x02
    48a2:	b3 83       	std	Z+3, r27	; 0x03
    48a4:	e8 c0       	rjmp	.+464    	; 0x4a76 <f_getfree+0x260>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
    48a6:	a0 80       	ld	r10, Z
			n = 0;
			if (fat == FS_FAT12) {
    48a8:	b1 e0       	ldi	r27, 0x01	; 1
    48aa:	ab 16       	cp	r10, r27
    48ac:	d9 f5       	brne	.+118    	; 0x4924 <f_getfree+0x10e>
    48ae:	cc 24       	eor	r12, r12
    48b0:	dd 24       	eor	r13, r13
    48b2:	76 01       	movw	r14, r12
    48b4:	68 94       	set
    48b6:	c1 f8       	bld	r12, 1
    48b8:	44 24       	eor	r4, r4
    48ba:	55 24       	eor	r5, r5
    48bc:	32 01       	movw	r6, r4
				clst = 2;
				do {
					stat = get_fat(fs, clst);
    48be:	c4 01       	movw	r24, r8
    48c0:	b7 01       	movw	r22, r14
    48c2:	a6 01       	movw	r20, r12
    48c4:	0e 94 8a 11 	call	0x2314	; 0x2314 <get_fat>
    48c8:	dc 01       	movw	r26, r24
    48ca:	cb 01       	movw	r24, r22
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
    48cc:	8f 3f       	cpi	r24, 0xFF	; 255
    48ce:	ef ef       	ldi	r30, 0xFF	; 255
    48d0:	9e 07       	cpc	r25, r30
    48d2:	ef ef       	ldi	r30, 0xFF	; 255
    48d4:	ae 07       	cpc	r26, r30
    48d6:	ef ef       	ldi	r30, 0xFF	; 255
    48d8:	be 07       	cpc	r27, r30
    48da:	09 f4       	brne	.+2      	; 0x48de <f_getfree+0xc8>
    48dc:	b0 c0       	rjmp	.+352    	; 0x4a3e <f_getfree+0x228>
					if (stat == 1) { res = FR_INT_ERR; break; }
    48de:	81 30       	cpi	r24, 0x01	; 1
    48e0:	91 05       	cpc	r25, r1
    48e2:	a1 05       	cpc	r26, r1
    48e4:	b1 05       	cpc	r27, r1
    48e6:	09 f4       	brne	.+2      	; 0x48ea <f_getfree+0xd4>
    48e8:	ad c0       	rjmp	.+346    	; 0x4a44 <f_getfree+0x22e>
					if (stat == 0) n++;
    48ea:	00 97       	sbiw	r24, 0x00	; 0
    48ec:	a1 05       	cpc	r26, r1
    48ee:	b1 05       	cpc	r27, r1
    48f0:	29 f4       	brne	.+10     	; 0x48fc <f_getfree+0xe6>
    48f2:	08 94       	sec
    48f4:	41 1c       	adc	r4, r1
    48f6:	51 1c       	adc	r5, r1
    48f8:	61 1c       	adc	r6, r1
    48fa:	71 1c       	adc	r7, r1
				} while (++clst < fs->n_fatent);
    48fc:	08 94       	sec
    48fe:	c1 1c       	adc	r12, r1
    4900:	d1 1c       	adc	r13, r1
    4902:	e1 1c       	adc	r14, r1
    4904:	f1 1c       	adc	r15, r1
    4906:	f4 01       	movw	r30, r8
    4908:	82 8d       	ldd	r24, Z+26	; 0x1a
    490a:	93 8d       	ldd	r25, Z+27	; 0x1b
    490c:	a4 8d       	ldd	r26, Z+28	; 0x1c
    490e:	b5 8d       	ldd	r27, Z+29	; 0x1d
    4910:	c8 16       	cp	r12, r24
    4912:	d9 06       	cpc	r13, r25
    4914:	ea 06       	cpc	r14, r26
    4916:	fb 06       	cpc	r15, r27
    4918:	90 f2       	brcs	.-92     	; 0x48be <f_getfree+0xa8>
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
    491a:	46 86       	std	Z+14, r4	; 0x0e
    491c:	57 86       	std	Z+15, r5	; 0x0f
    491e:	60 8a       	std	Z+16, r6	; 0x10
    4920:	71 8a       	std	Z+17, r7	; 0x11
    4922:	a2 c0       	rjmp	.+324    	; 0x4a68 <f_getfree+0x252>
					if (stat == 1) { res = FR_INT_ERR; break; }
					if (stat == 0) n++;
				} while (++clst < fs->n_fatent);
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
    4924:	82 a1       	lds	r24, 0x42
    4926:	93 a1       	lds	r25, 0x43
    4928:	a4 a1       	lds	r26, 0x44
    492a:	b5 a1       	lds	r27, 0x45
    492c:	8b 83       	std	Y+3, r24	; 0x03
    492e:	9c 83       	std	Y+4, r25	; 0x04
    4930:	ad 83       	std	Y+5, r26	; 0x05
    4932:	be 83       	std	Y+6, r27	; 0x06
				i = 0; p = 0;
    4934:	e0 e0       	ldi	r30, 0x00	; 0
    4936:	f0 e0       	ldi	r31, 0x00	; 0
    4938:	00 e0       	ldi	r16, 0x00	; 0
    493a:	10 e0       	ldi	r17, 0x00	; 0
    493c:	98 01       	movw	r18, r16
		if (fs->free_clust <= fs->n_fatent - 2) {
			*nclst = fs->free_clust;
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
			n = 0;
    493e:	44 24       	eor	r4, r4
    4940:	55 24       	eor	r5, r5
    4942:	32 01       	movw	r6, r4
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
    4944:	a4 01       	movw	r20, r8
    4946:	4e 5c       	subi	r20, 0xCE	; 206
    4948:	5f 4f       	sbci	r21, 0xFF	; 255
    494a:	5c 87       	std	Y+12, r21	; 0x0c
    494c:	4b 87       	std	Y+11, r20	; 0x0b
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
    494e:	01 15       	cp	r16, r1
    4950:	11 05       	cpc	r17, r1
    4952:	21 05       	cpc	r18, r1
    4954:	31 05       	cpc	r19, r1
    4956:	d9 f4       	brne	.+54     	; 0x498e <f_getfree+0x178>
						res = move_window(fs, sect++);
    4958:	c4 01       	movw	r24, r8
    495a:	4b 81       	ldd	r20, Y+3	; 0x03
    495c:	5c 81       	ldd	r21, Y+4	; 0x04
    495e:	6d 81       	ldd	r22, Y+5	; 0x05
    4960:	7e 81       	ldd	r23, Y+6	; 0x06
    4962:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
						if (res != FR_OK) break;
    4966:	88 23       	and	r24, r24
    4968:	09 f0       	breq	.+2      	; 0x496c <f_getfree+0x156>
    496a:	70 c0       	rjmp	.+224    	; 0x4a4c <f_getfree+0x236>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
    496c:	8b 81       	ldd	r24, Y+3	; 0x03
    496e:	9c 81       	ldd	r25, Y+4	; 0x04
    4970:	ad 81       	ldd	r26, Y+5	; 0x05
    4972:	be 81       	ldd	r27, Y+6	; 0x06
    4974:	01 96       	adiw	r24, 0x01	; 1
    4976:	a1 1d       	adc	r26, r1
    4978:	b1 1d       	adc	r27, r1
    497a:	8b 83       	std	Y+3, r24	; 0x03
    497c:	9c 83       	std	Y+4, r25	; 0x04
    497e:	ad 83       	std	Y+5, r26	; 0x05
    4980:	be 83       	std	Y+6, r27	; 0x06
						if (res != FR_OK) break;
						p = fs->win;
    4982:	eb 85       	ldd	r30, Y+11	; 0x0b
    4984:	fc 85       	ldd	r31, Y+12	; 0x0c
						i = SS(fs);
    4986:	00 e0       	ldi	r16, 0x00	; 0
    4988:	12 e0       	ldi	r17, 0x02	; 2
    498a:	20 e0       	ldi	r18, 0x00	; 0
    498c:	30 e0       	ldi	r19, 0x00	; 0
					}
					if (fat == FS_FAT16) {
    498e:	92 e0       	ldi	r25, 0x02	; 2
    4990:	a9 16       	cp	r10, r25
    4992:	b1 f4       	brne	.+44     	; 0x49c0 <f_getfree+0x1aa>
						if (LD_WORD(p) == 0) n++;
    4994:	a1 81       	ldd	r26, Z+1	; 0x01
    4996:	aa 87       	std	Y+10, r26	; 0x0a
    4998:	19 86       	std	Y+9, r1	; 0x09
    499a:	80 81       	ld	r24, Z
    499c:	90 e0       	ldi	r25, 0x00	; 0
    499e:	49 85       	ldd	r20, Y+9	; 0x09
    49a0:	5a 85       	ldd	r21, Y+10	; 0x0a
    49a2:	84 2b       	or	r24, r20
    49a4:	95 2b       	or	r25, r21
    49a6:	00 97       	sbiw	r24, 0x00	; 0
    49a8:	29 f4       	brne	.+10     	; 0x49b4 <f_getfree+0x19e>
    49aa:	08 94       	sec
    49ac:	41 1c       	adc	r4, r1
    49ae:	51 1c       	adc	r5, r1
    49b0:	61 1c       	adc	r6, r1
    49b2:	71 1c       	adc	r7, r1
						p += 2; i -= 2;
    49b4:	32 96       	adiw	r30, 0x02	; 2
    49b6:	02 50       	subi	r16, 0x02	; 2
    49b8:	10 40       	sbci	r17, 0x00	; 0
    49ba:	20 40       	sbci	r18, 0x00	; 0
    49bc:	30 40       	sbci	r19, 0x00	; 0
    49be:	33 c0       	rjmp	.+102    	; 0x4a26 <f_getfree+0x210>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
    49c0:	83 81       	ldd	r24, Z+3	; 0x03
    49c2:	90 e0       	ldi	r25, 0x00	; 0
    49c4:	a0 e0       	ldi	r26, 0x00	; 0
    49c6:	b0 e0       	ldi	r27, 0x00	; 0
    49c8:	78 2f       	mov	r23, r24
    49ca:	66 27       	eor	r22, r22
    49cc:	55 27       	eor	r21, r21
    49ce:	44 27       	eor	r20, r20
    49d0:	82 81       	ldd	r24, Z+2	; 0x02
    49d2:	90 e0       	ldi	r25, 0x00	; 0
    49d4:	a0 e0       	ldi	r26, 0x00	; 0
    49d6:	b0 e0       	ldi	r27, 0x00	; 0
    49d8:	dc 01       	movw	r26, r24
    49da:	99 27       	eor	r25, r25
    49dc:	88 27       	eor	r24, r24
    49de:	48 2b       	or	r20, r24
    49e0:	59 2b       	or	r21, r25
    49e2:	6a 2b       	or	r22, r26
    49e4:	7b 2b       	or	r23, r27
    49e6:	80 81       	ld	r24, Z
    49e8:	90 e0       	ldi	r25, 0x00	; 0
    49ea:	a0 e0       	ldi	r26, 0x00	; 0
    49ec:	b0 e0       	ldi	r27, 0x00	; 0
    49ee:	84 2b       	or	r24, r20
    49f0:	95 2b       	or	r25, r21
    49f2:	a6 2b       	or	r26, r22
    49f4:	b7 2b       	or	r27, r23
    49f6:	31 80       	ldd	r3, Z+1	; 0x01
    49f8:	22 24       	eor	r2, r2
    49fa:	a1 01       	movw	r20, r2
    49fc:	60 e0       	ldi	r22, 0x00	; 0
    49fe:	70 e0       	ldi	r23, 0x00	; 0
    4a00:	84 2b       	or	r24, r20
    4a02:	95 2b       	or	r25, r21
    4a04:	a6 2b       	or	r26, r22
    4a06:	b7 2b       	or	r27, r23
    4a08:	bf 70       	andi	r27, 0x0F	; 15
    4a0a:	00 97       	sbiw	r24, 0x00	; 0
    4a0c:	a1 05       	cpc	r26, r1
    4a0e:	b1 05       	cpc	r27, r1
    4a10:	29 f4       	brne	.+10     	; 0x4a1c <f_getfree+0x206>
    4a12:	08 94       	sec
    4a14:	41 1c       	adc	r4, r1
    4a16:	51 1c       	adc	r5, r1
    4a18:	61 1c       	adc	r6, r1
    4a1a:	71 1c       	adc	r7, r1
						p += 4; i -= 4;
    4a1c:	34 96       	adiw	r30, 0x04	; 4
    4a1e:	04 50       	subi	r16, 0x04	; 4
    4a20:	10 40       	sbci	r17, 0x00	; 0
    4a22:	20 40       	sbci	r18, 0x00	; 0
    4a24:	30 40       	sbci	r19, 0x00	; 0
					}
				} while (--clst);
    4a26:	08 94       	sec
    4a28:	c1 08       	sbc	r12, r1
    4a2a:	d1 08       	sbc	r13, r1
    4a2c:	e1 08       	sbc	r14, r1
    4a2e:	f1 08       	sbc	r15, r1
    4a30:	c1 14       	cp	r12, r1
    4a32:	d1 04       	cpc	r13, r1
    4a34:	e1 04       	cpc	r14, r1
    4a36:	f1 04       	cpc	r15, r1
    4a38:	09 f0       	breq	.+2      	; 0x4a3c <f_getfree+0x226>
    4a3a:	89 cf       	rjmp	.-238    	; 0x494e <f_getfree+0x138>
    4a3c:	08 c0       	rjmp	.+16     	; 0x4a4e <f_getfree+0x238>
			n = 0;
			if (fat == FS_FAT12) {
				clst = 2;
				do {
					stat = get_fat(fs, clst);
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
    4a3e:	bb 24       	eor	r11, r11
    4a40:	b3 94       	inc	r11
    4a42:	05 c0       	rjmp	.+10     	; 0x4a4e <f_getfree+0x238>
					if (stat == 1) { res = FR_INT_ERR; break; }
    4a44:	bb 24       	eor	r11, r11
    4a46:	68 94       	set
    4a48:	b1 f8       	bld	r11, 1
    4a4a:	01 c0       	rjmp	.+2      	; 0x4a4e <f_getfree+0x238>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
    4a4c:	b8 2e       	mov	r11, r24
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
    4a4e:	d4 01       	movw	r26, r8
    4a50:	1e 96       	adiw	r26, 0x0e	; 14
    4a52:	4d 92       	st	X+, r4
    4a54:	5d 92       	st	X+, r5
    4a56:	6d 92       	st	X+, r6
    4a58:	7c 92       	st	X, r7
    4a5a:	51 97       	sbiw	r26, 0x11	; 17
			if (fat == FS_FAT32) fs->fsi_flag = 1;
    4a5c:	b3 e0       	ldi	r27, 0x03	; 3
    4a5e:	ab 16       	cp	r10, r27
    4a60:	19 f4       	brne	.+6      	; 0x4a68 <f_getfree+0x252>
    4a62:	81 e0       	ldi	r24, 0x01	; 1
    4a64:	f4 01       	movw	r30, r8
    4a66:	85 83       	std	Z+5, r24	; 0x05
			*nclst = n;
    4a68:	af 81       	ldd	r26, Y+7	; 0x07
    4a6a:	b8 85       	ldd	r27, Y+8	; 0x08
    4a6c:	4d 92       	st	X+, r4
    4a6e:	5d 92       	st	X+, r5
    4a70:	6d 92       	st	X+, r6
    4a72:	7c 92       	st	X, r7
    4a74:	13 97       	sbiw	r26, 0x03	; 3
		}
	}
	LEAVE_FF(fs, res);
}
    4a76:	8b 2d       	mov	r24, r11
    4a78:	2c 96       	adiw	r28, 0x0c	; 12
    4a7a:	0f b6       	in	r0, 0x3f	; 63
    4a7c:	f8 94       	cli
    4a7e:	de bf       	out	0x3e, r29	; 62
    4a80:	0f be       	out	0x3f, r0	; 63
    4a82:	cd bf       	out	0x3d, r28	; 61
    4a84:	df 91       	pop	r29
    4a86:	cf 91       	pop	r28
    4a88:	1f 91       	pop	r17
    4a8a:	0f 91       	pop	r16
    4a8c:	ff 90       	pop	r15
    4a8e:	ef 90       	pop	r14
    4a90:	df 90       	pop	r13
    4a92:	cf 90       	pop	r12
    4a94:	bf 90       	pop	r11
    4a96:	af 90       	pop	r10
    4a98:	9f 90       	pop	r9
    4a9a:	8f 90       	pop	r8
    4a9c:	7f 90       	pop	r7
    4a9e:	6f 90       	pop	r6
    4aa0:	5f 90       	pop	r5
    4aa2:	4f 90       	pop	r4
    4aa4:	3f 90       	pop	r3
    4aa6:	2f 90       	pop	r2
    4aa8:	08 95       	ret

00004aaa <f_truncate>:
/*-----------------------------------------------------------------------*/

FRESULT f_truncate (
	FIL *fp		/* Pointer to the file object */
)
{
    4aaa:	cf 92       	push	r12
    4aac:	df 92       	push	r13
    4aae:	ef 92       	push	r14
    4ab0:	ff 92       	push	r15
    4ab2:	0f 93       	push	r16
    4ab4:	1f 93       	push	r17
    4ab6:	cf 93       	push	r28
    4ab8:	df 93       	push	r29
    4aba:	ec 01       	movw	r28, r24
	FRESULT res;
	DWORD ncl;


	if (!fp) return FR_INVALID_OBJECT;
    4abc:	00 97       	sbiw	r24, 0x00	; 0
    4abe:	09 f4       	brne	.+2      	; 0x4ac2 <f_truncate+0x18>
    4ac0:	69 c0       	rjmp	.+210    	; 0x4b94 <f_truncate+0xea>

	res = validate(fp);						/* Check validity of the object */
    4ac2:	0e 94 30 0b 	call	0x1660	; 0x1660 <validate>
	if (res == FR_OK) {
    4ac6:	88 23       	and	r24, r24
    4ac8:	09 f0       	breq	.+2      	; 0x4acc <f_truncate+0x22>
    4aca:	65 c0       	rjmp	.+202    	; 0x4b96 <f_truncate+0xec>
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
    4acc:	9c 81       	ldd	r25, Y+4	; 0x04
    4ace:	99 23       	and	r25, r25
    4ad0:	24 f0       	brlt	.+8      	; 0x4ada <f_truncate+0x30>
			res = FR_INT_ERR;
		} else {
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
    4ad2:	91 fd       	sbrc	r25, 1
    4ad4:	69 c0       	rjmp	.+210    	; 0x4ba8 <f_truncate+0xfe>
				res = FR_DENIED;
    4ad6:	87 e0       	ldi	r24, 0x07	; 7
    4ad8:	5e c0       	rjmp	.+188    	; 0x4b96 <f_truncate+0xec>
	if (!fp) return FR_INVALID_OBJECT;

	res = validate(fp);						/* Check validity of the object */
	if (res == FR_OK) {
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
			res = FR_INT_ERR;
    4ada:	82 e0       	ldi	r24, 0x02	; 2
    4adc:	5c c0       	rjmp	.+184    	; 0x4b96 <f_truncate+0xec>
				res = FR_DENIED;
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
    4ade:	4a 87       	std	Y+10, r20	; 0x0a
    4ae0:	5b 87       	std	Y+11, r21	; 0x0b
    4ae2:	6c 87       	std	Y+12, r22	; 0x0c
    4ae4:	7d 87       	std	Y+13, r23	; 0x0d
			fp->flag |= FA__WRITTEN;
    4ae6:	8c 81       	ldd	r24, Y+4	; 0x04
    4ae8:	80 62       	ori	r24, 0x20	; 32
    4aea:	8c 83       	std	Y+4, r24	; 0x04
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
    4aec:	41 15       	cp	r20, r1
    4aee:	51 05       	cpc	r21, r1
    4af0:	61 05       	cpc	r22, r1
    4af2:	71 05       	cpc	r23, r1
    4af4:	69 f4       	brne	.+26     	; 0x4b10 <f_truncate+0x66>
				res = remove_chain(fp->fs, fp->sclust);
    4af6:	4e 85       	ldd	r20, Y+14	; 0x0e
    4af8:	5f 85       	ldd	r21, Y+15	; 0x0f
    4afa:	68 89       	ldd	r22, Y+16	; 0x10
    4afc:	79 89       	ldd	r23, Y+17	; 0x11
    4afe:	88 81       	ld	r24, Y
    4b00:	99 81       	ldd	r25, Y+1	; 0x01
    4b02:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <remove_chain>
				fp->sclust = 0;
    4b06:	1e 86       	std	Y+14, r1	; 0x0e
    4b08:	1f 86       	std	Y+15, r1	; 0x0f
    4b0a:	18 8a       	std	Y+16, r1	; 0x10
    4b0c:	19 8a       	std	Y+17, r1	; 0x11
    4b0e:	3c c0       	rjmp	.+120    	; 0x4b88 <f_truncate+0xde>
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
    4b10:	4a 89       	ldd	r20, Y+18	; 0x12
    4b12:	5b 89       	ldd	r21, Y+19	; 0x13
    4b14:	6c 89       	ldd	r22, Y+20	; 0x14
    4b16:	7d 89       	ldd	r23, Y+21	; 0x15
    4b18:	88 81       	ld	r24, Y
    4b1a:	99 81       	ldd	r25, Y+1	; 0x01
    4b1c:	0e 94 8a 11 	call	0x2314	; 0x2314 <get_fat>
    4b20:	6b 01       	movw	r12, r22
    4b22:	7c 01       	movw	r14, r24
				res = FR_OK;
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
    4b24:	81 e0       	ldi	r24, 0x01	; 1
    4b26:	c8 16       	cp	r12, r24
    4b28:	d1 04       	cpc	r13, r1
    4b2a:	e1 04       	cpc	r14, r1
    4b2c:	f1 04       	cpc	r15, r1
    4b2e:	09 f4       	brne	.+2      	; 0x4b32 <f_truncate+0x88>
    4b30:	4a c0       	rjmp	.+148    	; 0x4bc6 <f_truncate+0x11c>
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
				res = remove_chain(fp->fs, fp->sclust);
				fp->sclust = 0;
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
				res = FR_OK;
    4b32:	81 e0       	ldi	r24, 0x01	; 1
    4b34:	9f ef       	ldi	r25, 0xFF	; 255
    4b36:	c9 16       	cp	r12, r25
    4b38:	9f ef       	ldi	r25, 0xFF	; 255
    4b3a:	d9 06       	cpc	r13, r25
    4b3c:	9f ef       	ldi	r25, 0xFF	; 255
    4b3e:	e9 06       	cpc	r14, r25
    4b40:	9f ef       	ldi	r25, 0xFF	; 255
    4b42:	f9 06       	cpc	r15, r25
    4b44:	09 f0       	breq	.+2      	; 0x4b48 <f_truncate+0x9e>
    4b46:	80 e0       	ldi	r24, 0x00	; 0
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
				if (res == FR_OK && ncl < fp->fs->n_fatent) {
    4b48:	88 23       	and	r24, r24
    4b4a:	01 f5       	brne	.+64     	; 0x4b8c <f_truncate+0xe2>
    4b4c:	e8 81       	ld	r30, Y
    4b4e:	f9 81       	ldd	r31, Y+1	; 0x01
    4b50:	42 8d       	ldd	r20, Z+26	; 0x1a
    4b52:	53 8d       	ldd	r21, Z+27	; 0x1b
    4b54:	64 8d       	ldd	r22, Z+28	; 0x1c
    4b56:	75 8d       	ldd	r23, Z+29	; 0x1d
    4b58:	c4 16       	cp	r12, r20
    4b5a:	d5 06       	cpc	r13, r21
    4b5c:	e6 06       	cpc	r14, r22
    4b5e:	f7 06       	cpc	r15, r23
    4b60:	d0 f4       	brcc	.+52     	; 0x4b96 <f_truncate+0xec>
					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
    4b62:	4a 89       	ldd	r20, Y+18	; 0x12
    4b64:	5b 89       	ldd	r21, Y+19	; 0x13
    4b66:	6c 89       	ldd	r22, Y+20	; 0x14
    4b68:	7d 89       	ldd	r23, Y+21	; 0x15
    4b6a:	cf 01       	movw	r24, r30
    4b6c:	0f ef       	ldi	r16, 0xFF	; 255
    4b6e:	1f ef       	ldi	r17, 0xFF	; 255
    4b70:	2f ef       	ldi	r18, 0xFF	; 255
    4b72:	3f e0       	ldi	r19, 0x0F	; 15
    4b74:	0e 94 a4 13 	call	0x2748	; 0x2748 <put_fat>
					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
    4b78:	88 23       	and	r24, r24
    4b7a:	41 f4       	brne	.+16     	; 0x4b8c <f_truncate+0xe2>
    4b7c:	88 81       	ld	r24, Y
    4b7e:	99 81       	ldd	r25, Y+1	; 0x01
    4b80:	b7 01       	movw	r22, r14
    4b82:	a6 01       	movw	r20, r12
    4b84:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <remove_chain>
				}
			}
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
    4b88:	88 23       	and	r24, r24
    4b8a:	29 f0       	breq	.+10     	; 0x4b96 <f_truncate+0xec>
    4b8c:	9c 81       	ldd	r25, Y+4	; 0x04
    4b8e:	90 68       	ori	r25, 0x80	; 128
    4b90:	9c 83       	std	Y+4, r25	; 0x04
    4b92:	01 c0       	rjmp	.+2      	; 0x4b96 <f_truncate+0xec>
{
	FRESULT res;
	DWORD ncl;


	if (!fp) return FR_INVALID_OBJECT;
    4b94:	89 e0       	ldi	r24, 0x09	; 9
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
	}

	LEAVE_FF(fp->fs, res);
}
    4b96:	df 91       	pop	r29
    4b98:	cf 91       	pop	r28
    4b9a:	1f 91       	pop	r17
    4b9c:	0f 91       	pop	r16
    4b9e:	ff 90       	pop	r15
    4ba0:	ef 90       	pop	r14
    4ba2:	df 90       	pop	r13
    4ba4:	cf 90       	pop	r12
    4ba6:	08 95       	ret
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
				res = FR_DENIED;
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
    4ba8:	4e 81       	ldd	r20, Y+6	; 0x06
    4baa:	5f 81       	ldd	r21, Y+7	; 0x07
    4bac:	68 85       	ldd	r22, Y+8	; 0x08
    4bae:	79 85       	ldd	r23, Y+9	; 0x09
    4bb0:	0a 85       	ldd	r16, Y+10	; 0x0a
    4bb2:	1b 85       	ldd	r17, Y+11	; 0x0b
    4bb4:	2c 85       	ldd	r18, Y+12	; 0x0c
    4bb6:	3d 85       	ldd	r19, Y+13	; 0x0d
    4bb8:	40 17       	cp	r20, r16
    4bba:	51 07       	cpc	r21, r17
    4bbc:	62 07       	cpc	r22, r18
    4bbe:	73 07       	cpc	r23, r19
    4bc0:	08 f4       	brcc	.+2      	; 0x4bc4 <f_truncate+0x11a>
    4bc2:	8d cf       	rjmp	.-230    	; 0x4ade <f_truncate+0x34>
    4bc4:	e8 cf       	rjmp	.-48     	; 0x4b96 <f_truncate+0xec>
				fp->sclust = 0;
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
				res = FR_OK;
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
    4bc6:	82 e0       	ldi	r24, 0x02	; 2
    4bc8:	e1 cf       	rjmp	.-62     	; 0x4b8c <f_truncate+0xe2>

00004bca <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR *path		/* Pointer to the file or directory path */
)
{
    4bca:	cf 92       	push	r12
    4bcc:	df 92       	push	r13
    4bce:	ef 92       	push	r14
    4bd0:	ff 92       	push	r15
    4bd2:	1f 93       	push	r17
    4bd4:	cf 93       	push	r28
    4bd6:	df 93       	push	r29
    4bd8:	cd b7       	in	r28, 0x3d	; 61
    4bda:	de b7       	in	r29, 0x3e	; 62
    4bdc:	ea 97       	sbiw	r28, 0x3a	; 58
    4bde:	0f b6       	in	r0, 0x3f	; 63
    4be0:	f8 94       	cli
    4be2:	de bf       	out	0x3e, r29	; 62
    4be4:	0f be       	out	0x3f, r0	; 63
    4be6:	cd bf       	out	0x3d, r28	; 61
    4be8:	9a af       	sts	0x7a, r25
    4bea:	89 af       	sts	0x79, r24
	BYTE *dir;
	DWORD dclst;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4bec:	ce 01       	movw	r24, r28
    4bee:	c9 96       	adiw	r24, 0x39	; 57
    4bf0:	be 01       	movw	r22, r28
    4bf2:	6f 5f       	subi	r22, 0xFF	; 255
    4bf4:	7f 4f       	sbci	r23, 0xFF	; 255
    4bf6:	41 e0       	ldi	r20, 0x01	; 1
    4bf8:	0e 94 ed 0b 	call	0x17da	; 0x17da <chk_mounted>
	if (res == FR_OK) {
    4bfc:	88 23       	and	r24, r24
    4bfe:	09 f0       	breq	.+2      	; 0x4c02 <f_unlink+0x38>
    4c00:	63 c0       	rjmp	.+198    	; 0x4cc8 <f_unlink+0xfe>
		INIT_BUF(dj);
    4c02:	ce 01       	movw	r24, r28
    4c04:	8d 96       	adiw	r24, 0x2d	; 45
    4c06:	9e 8b       	std	Y+22, r25	; 0x16
    4c08:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the file path */
    4c0a:	69 ad       	sts	0x69, r22
    4c0c:	7a ad       	sts	0x6a, r23
    4c0e:	ce 01       	movw	r24, r28
    4c10:	01 96       	adiw	r24, 0x01	; 1
    4c12:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <follow_path>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    4c16:	88 23       	and	r24, r24
    4c18:	09 f0       	breq	.+2      	; 0x4c1c <f_unlink+0x52>
    4c1a:	56 c0       	rjmp	.+172    	; 0x4cc8 <f_unlink+0xfe>
    4c1c:	ed 89       	ldd	r30, Y+21	; 0x15
    4c1e:	fe 89       	ldd	r31, Y+22	; 0x16
    4c20:	83 85       	ldd	r24, Z+11	; 0x0b
    4c22:	85 ff       	sbrs	r24, 5
    4c24:	5f c0       	rjmp	.+190    	; 0x4ce4 <f_unlink+0x11a>
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
    4c26:	86 e0       	ldi	r24, 0x06	; 6
    4c28:	4f c0       	rjmp	.+158    	; 0x4cc8 <f_unlink+0xfe>
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
    4c2a:	fb 01       	movw	r30, r22
    4c2c:	13 85       	ldd	r17, Z+11	; 0x0b
    4c2e:	10 ff       	sbrs	r17, 0
    4c30:	60 c0       	rjmp	.+192    	; 0x4cf2 <f_unlink+0x128>
					res = FR_DENIED;		/* Cannot remove R/O object */
    4c32:	87 e0       	ldi	r24, 0x07	; 7
    4c34:	49 c0       	rjmp	.+146    	; 0x4cc8 <f_unlink+0xfe>
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
    4c36:	86 e0       	ldi	r24, 0x06	; 6
    4c38:	47 c0       	rjmp	.+142    	; 0x4cc8 <f_unlink+0xfe>
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = ld_clust(dj.fs, dir);
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
				if (dclst < 2) {
    4c3a:	f2 e0       	ldi	r31, 0x02	; 2
    4c3c:	cf 16       	cp	r12, r31
    4c3e:	d1 04       	cpc	r13, r1
    4c40:	e1 04       	cpc	r14, r1
    4c42:	f1 04       	cpc	r15, r1
    4c44:	08 f4       	brcc	.+2      	; 0x4c48 <f_unlink+0x7e>
    4c46:	5e c0       	rjmp	.+188    	; 0x4d04 <f_unlink+0x13a>
					res = FR_INT_ERR;
				} else {
					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
    4c48:	ce 01       	movw	r24, r28
    4c4a:	47 96       	adiw	r24, 0x17	; 23
    4c4c:	be 01       	movw	r22, r28
    4c4e:	6f 5f       	subi	r22, 0xFF	; 255
    4c50:	7f 4f       	sbci	r23, 0xFF	; 255
    4c52:	26 e1       	ldi	r18, 0x16	; 22
    4c54:	30 e0       	ldi	r19, 0x00	; 0
    4c56:	40 e0       	ldi	r20, 0x00	; 0
    4c58:	50 e0       	ldi	r21, 0x00	; 0
    4c5a:	0e 94 4a 0a 	call	0x1494	; 0x1494 <mem_cpy>
					sdj.sclust = dclst;
    4c5e:	cd 8e       	std	Y+29, r12	; 0x1d
    4c60:	de 8e       	std	Y+30, r13	; 0x1e
    4c62:	ef 8e       	std	Y+31, r14	; 0x1f
    4c64:	f8 a2       	lds	r31, 0x98
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
    4c66:	ce 01       	movw	r24, r28
    4c68:	47 96       	adiw	r24, 0x17	; 23
    4c6a:	62 e0       	ldi	r22, 0x02	; 2
    4c6c:	70 e0       	ldi	r23, 0x00	; 0
    4c6e:	0e 94 c1 12 	call	0x2582	; 0x2582 <dir_sdi>
					if (res == FR_OK) {
    4c72:	88 23       	and	r24, r24
    4c74:	49 f5       	brne	.+82     	; 0x4cc8 <f_unlink+0xfe>
						res = dir_read(&sdj);
    4c76:	ce 01       	movw	r24, r28
    4c78:	47 96       	adiw	r24, 0x17	; 23
    4c7a:	0e 94 a4 19 	call	0x3348	; 0x3348 <dir_read>
						if (res == FR_OK		/* Not empty dir */
    4c7e:	88 23       	and	r24, r24
    4c80:	71 f0       	breq	.+28     	; 0x4c9e <f_unlink+0xd4>
#if _FS_RPATH
						|| dclst == dj.fs->cdir	/* Current dir */
    4c82:	e9 81       	ldd	r30, Y+1	; 0x01
    4c84:	fa 81       	ldd	r31, Y+2	; 0x02
    4c86:	46 89       	ldd	r20, Z+22	; 0x16
    4c88:	57 89       	ldd	r21, Z+23	; 0x17
    4c8a:	60 8d       	ldd	r22, Z+24	; 0x18
    4c8c:	71 8d       	ldd	r23, Z+25	; 0x19
    4c8e:	4c 15       	cp	r20, r12
    4c90:	5d 05       	cpc	r21, r13
    4c92:	6e 05       	cpc	r22, r14
    4c94:	7f 05       	cpc	r23, r15
    4c96:	29 f0       	breq	.+10     	; 0x4ca2 <f_unlink+0xd8>
#endif
						) res = FR_DENIED;
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
    4c98:	84 30       	cpi	r24, 0x04	; 4
    4c9a:	b1 f1       	breq	.+108    	; 0x4d08 <f_unlink+0x13e>
    4c9c:	15 c0       	rjmp	.+42     	; 0x4cc8 <f_unlink+0xfe>
					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
					sdj.sclust = dclst;
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
					if (res == FR_OK) {
						res = dir_read(&sdj);
						if (res == FR_OK		/* Not empty dir */
    4c9e:	87 e0       	ldi	r24, 0x07	; 7
    4ca0:	13 c0       	rjmp	.+38     	; 0x4cc8 <f_unlink+0xfe>
#if _FS_RPATH
						|| dclst == dj.fs->cdir	/* Current dir */
    4ca2:	87 e0       	ldi	r24, 0x07	; 7
    4ca4:	11 c0       	rjmp	.+34     	; 0x4cc8 <f_unlink+0xfe>
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
				if (res == FR_OK) {
					if (dclst)				/* Remove the cluster chain if exist */
    4ca6:	c1 14       	cp	r12, r1
    4ca8:	d1 04       	cpc	r13, r1
    4caa:	e1 04       	cpc	r14, r1
    4cac:	f1 04       	cpc	r15, r1
    4cae:	41 f0       	breq	.+16     	; 0x4cc0 <f_unlink+0xf6>
						res = remove_chain(dj.fs, dclst);
    4cb0:	89 81       	ldd	r24, Y+1	; 0x01
    4cb2:	9a 81       	ldd	r25, Y+2	; 0x02
    4cb4:	b7 01       	movw	r22, r14
    4cb6:	a6 01       	movw	r20, r12
    4cb8:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <remove_chain>
					if (res == FR_OK) res = sync(dj.fs);
    4cbc:	88 23       	and	r24, r24
    4cbe:	21 f4       	brne	.+8      	; 0x4cc8 <f_unlink+0xfe>
    4cc0:	89 81       	ldd	r24, Y+1	; 0x01
    4cc2:	9a 81       	ldd	r25, Y+2	; 0x02
    4cc4:	0e 94 c2 10 	call	0x2184	; 0x2184 <sync>
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(dj.fs, res);
}
    4cc8:	ea 96       	adiw	r28, 0x3a	; 58
    4cca:	0f b6       	in	r0, 0x3f	; 63
    4ccc:	f8 94       	cli
    4cce:	de bf       	out	0x3e, r29	; 62
    4cd0:	0f be       	out	0x3f, r0	; 63
    4cd2:	cd bf       	out	0x3d, r28	; 61
    4cd4:	df 91       	pop	r29
    4cd6:	cf 91       	pop	r28
    4cd8:	1f 91       	pop	r17
    4cda:	ff 90       	pop	r15
    4cdc:	ef 90       	pop	r14
    4cde:	df 90       	pop	r13
    4ce0:	cf 90       	pop	r12
    4ce2:	08 95       	ret
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
    4ce4:	6b 89       	ldd	r22, Y+19	; 0x13
    4ce6:	7c 89       	ldd	r23, Y+20	; 0x14
			if (!dir) {
    4ce8:	61 15       	cp	r22, r1
    4cea:	71 05       	cpc	r23, r1
    4cec:	09 f0       	breq	.+2      	; 0x4cf0 <f_unlink+0x126>
    4cee:	9d cf       	rjmp	.-198    	; 0x4c2a <f_unlink+0x60>
    4cf0:	a2 cf       	rjmp	.-188    	; 0x4c36 <f_unlink+0x6c>
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = ld_clust(dj.fs, dir);
    4cf2:	89 81       	ldd	r24, Y+1	; 0x01
    4cf4:	9a 81       	ldd	r25, Y+2	; 0x02
    4cf6:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ld_clust>
    4cfa:	6b 01       	movw	r12, r22
    4cfc:	7c 01       	movw	r14, r24
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
    4cfe:	14 fd       	sbrc	r17, 4
    4d00:	9c cf       	rjmp	.-200    	; 0x4c3a <f_unlink+0x70>
    4d02:	02 c0       	rjmp	.+4      	; 0x4d08 <f_unlink+0x13e>
				if (dclst < 2) {
					res = FR_INT_ERR;
    4d04:	82 e0       	ldi	r24, 0x02	; 2
    4d06:	e0 cf       	rjmp	.-64     	; 0x4cc8 <f_unlink+0xfe>
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
    4d08:	ce 01       	movw	r24, r28
    4d0a:	01 96       	adiw	r24, 0x01	; 1
    4d0c:	0e 94 86 13 	call	0x270c	; 0x270c <dir_remove>
				if (res == FR_OK) {
    4d10:	88 23       	and	r24, r24
    4d12:	49 f2       	breq	.-110    	; 0x4ca6 <f_unlink+0xdc>
    4d14:	d9 cf       	rjmp	.-78     	; 0x4cc8 <f_unlink+0xfe>

00004d16 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR *path		/* Pointer to the directory path */
)
{
    4d16:	2f 92       	push	r2
    4d18:	3f 92       	push	r3
    4d1a:	4f 92       	push	r4
    4d1c:	5f 92       	push	r5
    4d1e:	6f 92       	push	r6
    4d20:	7f 92       	push	r7
    4d22:	8f 92       	push	r8
    4d24:	9f 92       	push	r9
    4d26:	af 92       	push	r10
    4d28:	bf 92       	push	r11
    4d2a:	cf 92       	push	r12
    4d2c:	df 92       	push	r13
    4d2e:	ef 92       	push	r14
    4d30:	ff 92       	push	r15
    4d32:	0f 93       	push	r16
    4d34:	1f 93       	push	r17
    4d36:	cf 93       	push	r28
    4d38:	df 93       	push	r29
    4d3a:	cd b7       	in	r28, 0x3d	; 61
    4d3c:	de b7       	in	r29, 0x3e	; 62
    4d3e:	a8 97       	sbiw	r28, 0x28	; 40
    4d40:	0f b6       	in	r0, 0x3f	; 63
    4d42:	f8 94       	cli
    4d44:	de bf       	out	0x3e, r29	; 62
    4d46:	0f be       	out	0x3f, r0	; 63
    4d48:	cd bf       	out	0x3d, r28	; 61
    4d4a:	9c a3       	lds	r25, 0x5c
    4d4c:	8b a3       	lds	r24, 0x5b
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tim = get_fattime();
    4d4e:	0e 94 50 11 	call	0x22a0	; 0x22a0 <get_fattime>
    4d52:	6b 01       	movw	r12, r22
    4d54:	7c 01       	movw	r14, r24
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4d56:	ce 01       	movw	r24, r28
    4d58:	83 96       	adiw	r24, 0x23	; 35
    4d5a:	be 01       	movw	r22, r28
    4d5c:	6f 5f       	subi	r22, 0xFF	; 255
    4d5e:	7f 4f       	sbci	r23, 0xFF	; 255
    4d60:	41 e0       	ldi	r20, 0x01	; 1
    4d62:	0e 94 ed 0b 	call	0x17da	; 0x17da <chk_mounted>
    4d66:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    4d68:	88 23       	and	r24, r24
    4d6a:	09 f0       	breq	.+2      	; 0x4d6e <f_mkdir+0x58>
    4d6c:	f6 c0       	rjmp	.+492    	; 0x4f5a <f_mkdir+0x244>
		INIT_BUF(dj);
    4d6e:	ce 01       	movw	r24, r28
    4d70:	47 96       	adiw	r24, 0x17	; 23
    4d72:	9e 8b       	std	Y+22, r25	; 0x16
    4d74:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);			/* Follow the file path */
    4d76:	6b a1       	lds	r22, 0x4b
    4d78:	7c a1       	lds	r23, 0x4c
    4d7a:	ce 01       	movw	r24, r28
    4d7c:	01 96       	adiw	r24, 0x01	; 1
    4d7e:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <follow_path>
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
    4d82:	88 23       	and	r24, r24
    4d84:	49 f0       	breq	.+18     	; 0x4d98 <f_mkdir+0x82>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
    4d86:	84 30       	cpi	r24, 0x04	; 4
    4d88:	41 f4       	brne	.+16     	; 0x4d9a <f_mkdir+0x84>
    4d8a:	ed 89       	ldd	r30, Y+21	; 0x15
    4d8c:	fe 89       	ldd	r31, Y+22	; 0x16
    4d8e:	83 85       	ldd	r24, Z+11	; 0x0b
    4d90:	85 ff       	sbrs	r24, 5
    4d92:	fd c0       	rjmp	.+506    	; 0x4f8e <f_mkdir+0x278>
			res = FR_INVALID_NAME;
    4d94:	86 e0       	ldi	r24, 0x06	; 6
    4d96:	01 c0       	rjmp	.+2      	; 0x4d9a <f_mkdir+0x84>

	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
    4d98:	88 e0       	ldi	r24, 0x08	; 8
				ST_DWORD(dir+DIR_WrtTime, tim);
				st_clust(dir, dcl);
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
    4d9a:	18 2f       	mov	r17, r24
    4d9c:	de c0       	rjmp	.+444    	; 0x4f5a <f_mkdir+0x244>
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
			if (dcl == 1) res = FR_INT_ERR;
    4d9e:	81 e0       	ldi	r24, 0x01	; 1
    4da0:	48 16       	cp	r4, r24
    4da2:	51 04       	cpc	r5, r1
    4da4:	61 04       	cpc	r6, r1
    4da6:	71 04       	cpc	r7, r1
    4da8:	09 f4       	brne	.+2      	; 0x4dac <f_mkdir+0x96>
    4daa:	01 c1       	rjmp	.+514    	; 0x4fae <f_mkdir+0x298>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
    4dac:	ef ef       	ldi	r30, 0xFF	; 255
    4dae:	4e 16       	cp	r4, r30
    4db0:	ef ef       	ldi	r30, 0xFF	; 255
    4db2:	5e 06       	cpc	r5, r30
    4db4:	ef ef       	ldi	r30, 0xFF	; 255
    4db6:	6e 06       	cpc	r6, r30
    4db8:	ef ef       	ldi	r30, 0xFF	; 255
    4dba:	7e 06       	cpc	r7, r30
    4dbc:	09 f4       	brne	.+2      	; 0x4dc0 <f_mkdir+0xaa>
    4dbe:	f9 c0       	rjmp	.+498    	; 0x4fb2 <f_mkdir+0x29c>
    4dc0:	01 c0       	rjmp	.+2      	; 0x4dc4 <f_mkdir+0xae>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
    4dc2:	17 e0       	ldi	r17, 0x07	; 7
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
			if (res == FR_OK)					/* Flush FAT */
    4dc4:	11 23       	and	r17, r17
    4dc6:	09 f0       	breq	.+2      	; 0x4dca <f_mkdir+0xb4>
    4dc8:	a8 c0       	rjmp	.+336    	; 0x4f1a <f_mkdir+0x204>
				res = move_window(dj.fs, 0);
    4dca:	89 81       	ldd	r24, Y+1	; 0x01
    4dcc:	9a 81       	ldd	r25, Y+2	; 0x02
    4dce:	40 e0       	ldi	r20, 0x00	; 0
    4dd0:	50 e0       	ldi	r21, 0x00	; 0
    4dd2:	ba 01       	movw	r22, r20
    4dd4:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
    4dd8:	18 2f       	mov	r17, r24
			if (res == FR_OK) {					/* Initialize the new directory table */
    4dda:	88 23       	and	r24, r24
    4ddc:	09 f0       	breq	.+2      	; 0x4de0 <f_mkdir+0xca>
    4dde:	9d c0       	rjmp	.+314    	; 0x4f1a <f_mkdir+0x204>
				dsc = clust2sect(dj.fs, dcl);
    4de0:	09 81       	ldd	r16, Y+1	; 0x01
    4de2:	1a 81       	ldd	r17, Y+2	; 0x02
    4de4:	c8 01       	movw	r24, r16
    4de6:	b3 01       	movw	r22, r6
    4de8:	a2 01       	movw	r20, r4
    4dea:	0e 94 54 11 	call	0x22a8	; 0x22a8 <clust2sect>
    4dee:	4b 01       	movw	r8, r22
    4df0:	5c 01       	movw	r10, r24
				dir = dj.fs->win;
    4df2:	0f 2e       	mov	r0, r31
    4df4:	f2 e3       	ldi	r31, 0x32	; 50
    4df6:	2f 2e       	mov	r2, r31
    4df8:	33 24       	eor	r3, r3
    4dfa:	f0 2d       	mov	r31, r0
    4dfc:	20 0e       	add	r2, r16
    4dfe:	31 1e       	adc	r3, r17
				mem_set(dir, 0, SS(dj.fs));
    4e00:	c1 01       	movw	r24, r2
    4e02:	60 e0       	ldi	r22, 0x00	; 0
    4e04:	70 e0       	ldi	r23, 0x00	; 0
    4e06:	20 e0       	ldi	r18, 0x00	; 0
    4e08:	32 e0       	ldi	r19, 0x02	; 2
    4e0a:	40 e0       	ldi	r20, 0x00	; 0
    4e0c:	50 e0       	ldi	r21, 0x00	; 0
    4e0e:	0e 94 5f 0a 	call	0x14be	; 0x14be <mem_set>
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
    4e12:	c1 01       	movw	r24, r2
    4e14:	60 e2       	ldi	r22, 0x20	; 32
    4e16:	70 e0       	ldi	r23, 0x00	; 0
    4e18:	2b e0       	ldi	r18, 0x0B	; 11
    4e1a:	30 e0       	ldi	r19, 0x00	; 0
    4e1c:	40 e0       	ldi	r20, 0x00	; 0
    4e1e:	50 e0       	ldi	r21, 0x00	; 0
    4e20:	0e 94 5f 0a 	call	0x14be	; 0x14be <mem_set>
				dir[DIR_Name] = '.';
    4e24:	8e e2       	ldi	r24, 0x2E	; 46
    4e26:	f8 01       	movw	r30, r16
    4e28:	82 ab       	sts	0x52, r24
				dir[DIR_Attr] = AM_DIR;
    4e2a:	80 e1       	ldi	r24, 0x10	; 16
    4e2c:	85 af       	sts	0x75, r24
				ST_DWORD(dir+DIR_WrtTime, tim);
    4e2e:	cd a2       	lds	r28, 0x9d
    4e30:	e8 5b       	subi	r30, 0xB8	; 184
    4e32:	ff 4f       	sbci	r31, 0xFF	; 255
    4e34:	c0 82       	st	Z, r12
    4e36:	8d 2d       	mov	r24, r13
    4e38:	99 27       	eor	r25, r25
    4e3a:	8e a3       	lds	r24, 0x5e
    4e3c:	f8 01       	movw	r30, r16
    4e3e:	e7 5b       	subi	r30, 0xB7	; 183
    4e40:	ff 4f       	sbci	r31, 0xFF	; 255
    4e42:	80 83       	st	Z, r24
    4e44:	c7 01       	movw	r24, r14
    4e46:	aa 27       	eor	r26, r26
    4e48:	bb 27       	eor	r27, r27
    4e4a:	8f a3       	lds	r24, 0x5f
    4e4c:	f8 01       	movw	r30, r16
    4e4e:	e6 5b       	subi	r30, 0xB6	; 182
    4e50:	ff 4f       	sbci	r31, 0xFF	; 255
    4e52:	80 83       	st	Z, r24
    4e54:	cf 2c       	mov	r12, r15
    4e56:	dd 24       	eor	r13, r13
    4e58:	ee 24       	eor	r14, r14
    4e5a:	ff 24       	eor	r15, r15
    4e5c:	c8 a6       	lds	r28, 0xb8
    4e5e:	f8 01       	movw	r30, r16
    4e60:	e5 5b       	subi	r30, 0xB5	; 181
    4e62:	ff 4f       	sbci	r31, 0xFF	; 255
    4e64:	c0 82       	st	Z, r12
				st_clust(dir, dcl);
    4e66:	c1 01       	movw	r24, r2
    4e68:	b3 01       	movw	r22, r6
    4e6a:	a2 01       	movw	r20, r4
    4e6c:	0e 94 95 0a 	call	0x152a	; 0x152a <st_clust>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
    4e70:	0f 2e       	mov	r0, r31
    4e72:	f2 e5       	ldi	r31, 0x52	; 82
    4e74:	cf 2e       	mov	r12, r31
    4e76:	dd 24       	eor	r13, r13
    4e78:	f0 2d       	mov	r31, r0
    4e7a:	c0 0e       	add	r12, r16
    4e7c:	d1 1e       	adc	r13, r17
    4e7e:	c6 01       	movw	r24, r12
    4e80:	b1 01       	movw	r22, r2
    4e82:	20 e2       	ldi	r18, 0x20	; 32
    4e84:	30 e0       	ldi	r19, 0x00	; 0
    4e86:	40 e0       	ldi	r20, 0x00	; 0
    4e88:	50 e0       	ldi	r21, 0x00	; 0
    4e8a:	0e 94 4a 0a 	call	0x1494	; 0x1494 <mem_cpy>
				dir[33] = '.'; pcl = dj.sclust;
    4e8e:	f8 01       	movw	r30, r16
    4e90:	ed 5a       	subi	r30, 0xAD	; 173
    4e92:	ff 4f       	sbci	r31, 0xFF	; 255
    4e94:	8e e2       	ldi	r24, 0x2E	; 46
    4e96:	80 83       	st	Z, r24
    4e98:	4f 81       	ldd	r20, Y+7	; 0x07
    4e9a:	58 85       	ldd	r21, Y+8	; 0x08
    4e9c:	69 85       	ldd	r22, Y+9	; 0x09
    4e9e:	7a 85       	ldd	r23, Y+10	; 0x0a
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
    4ea0:	e9 81       	ldd	r30, Y+1	; 0x01
    4ea2:	fa 81       	ldd	r31, Y+2	; 0x02
    4ea4:	80 81       	ld	r24, Z
    4ea6:	83 30       	cpi	r24, 0x03	; 3
    4ea8:	61 f4       	brne	.+24     	; 0x4ec2 <f_mkdir+0x1ac>
    4eaa:	86 a1       	lds	r24, 0x46
    4eac:	97 a1       	lds	r25, 0x47
    4eae:	a0 a5       	lds	r26, 0x60
    4eb0:	b1 a5       	lds	r27, 0x61
    4eb2:	84 17       	cp	r24, r20
    4eb4:	95 07       	cpc	r25, r21
    4eb6:	a6 07       	cpc	r26, r22
    4eb8:	b7 07       	cpc	r27, r23
    4eba:	19 f4       	brne	.+6      	; 0x4ec2 <f_mkdir+0x1ac>
					pcl = 0;
    4ebc:	40 e0       	ldi	r20, 0x00	; 0
    4ebe:	50 e0       	ldi	r21, 0x00	; 0
    4ec0:	ba 01       	movw	r22, r20
				st_clust(dir+SZ_DIR, pcl);
    4ec2:	c6 01       	movw	r24, r12
    4ec4:	0e 94 95 0a 	call	0x152a	; 0x152a <st_clust>
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
    4ec8:	e9 81       	ldd	r30, Y+1	; 0x01
    4eca:	fa 81       	ldd	r31, Y+2	; 0x02
    4ecc:	02 81       	ldd	r16, Z+2	; 0x02
    4ece:	00 23       	and	r16, r16
    4ed0:	09 f4       	brne	.+2      	; 0x4ed4 <f_mkdir+0x1be>
    4ed2:	71 c0       	rjmp	.+226    	; 0x4fb6 <f_mkdir+0x2a0>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
    4ed4:	cc 24       	eor	r12, r12
    4ed6:	c3 94       	inc	r12
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
    4ed8:	89 81       	ldd	r24, Y+1	; 0x01
    4eda:	9a 81       	ldd	r25, Y+2	; 0x02
    4edc:	fc 01       	movw	r30, r24
    4ede:	86 a6       	lds	r24, 0xb6
    4ee0:	97 a6       	lds	r25, 0xb7
    4ee2:	a0 aa       	sts	0x90, r26
    4ee4:	b1 aa       	sts	0x91, r27
    4ee6:	08 94       	sec
    4ee8:	81 1c       	adc	r8, r1
    4eea:	91 1c       	adc	r9, r1
    4eec:	a1 1c       	adc	r10, r1
    4eee:	b1 1c       	adc	r11, r1
					dj.fs->wflag = 1;
    4ef0:	c4 82       	std	Z+4, r12	; 0x04
					res = move_window(dj.fs, 0);
    4ef2:	40 e0       	ldi	r20, 0x00	; 0
    4ef4:	50 e0       	ldi	r21, 0x00	; 0
    4ef6:	ba 01       	movw	r22, r20
    4ef8:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
    4efc:	18 2f       	mov	r17, r24
					if (res != FR_OK) break;
    4efe:	88 23       	and	r24, r24
    4f00:	61 f4       	brne	.+24     	; 0x4f1a <f_mkdir+0x204>
					mem_set(dir, 0, SS(dj.fs));
    4f02:	c1 01       	movw	r24, r2
    4f04:	60 e0       	ldi	r22, 0x00	; 0
    4f06:	70 e0       	ldi	r23, 0x00	; 0
    4f08:	20 e0       	ldi	r18, 0x00	; 0
    4f0a:	32 e0       	ldi	r19, 0x02	; 2
    4f0c:	40 e0       	ldi	r20, 0x00	; 0
    4f0e:	50 e0       	ldi	r21, 0x00	; 0
    4f10:	0e 94 5f 0a 	call	0x14be	; 0x14be <mem_set>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
    4f14:	01 50       	subi	r16, 0x01	; 1
    4f16:	01 f7       	brne	.-64     	; 0x4ed8 <f_mkdir+0x1c2>
    4f18:	4e c0       	rjmp	.+156    	; 0x4fb6 <f_mkdir+0x2a0>
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
    4f1a:	89 81       	ldd	r24, Y+1	; 0x01
    4f1c:	9a 81       	ldd	r25, Y+2	; 0x02
    4f1e:	b3 01       	movw	r22, r6
    4f20:	a2 01       	movw	r20, r4
    4f22:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <remove_chain>
    4f26:	19 c0       	rjmp	.+50     	; 0x4f5a <f_mkdir+0x244>
			} else {
				dir = dj.dir;
    4f28:	eb 89       	ldd	r30, Y+19	; 0x13
    4f2a:	fc 89       	ldd	r31, Y+20	; 0x14
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
    4f2c:	80 e1       	ldi	r24, 0x10	; 16
    4f2e:	83 87       	std	Z+11, r24	; 0x0b
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
    4f30:	8d a1       	lds	r24, 0x4d
    4f32:	86 8b       	std	Z+22, r24	; 0x16
    4f34:	8e a1       	lds	r24, 0x4e
    4f36:	87 8b       	std	Z+23, r24	; 0x17
    4f38:	8f a1       	lds	r24, 0x4f
    4f3a:	80 8f       	std	Z+24, r24	; 0x18
    4f3c:	88 a5       	lds	r24, 0x68
    4f3e:	81 8f       	std	Z+25, r24	; 0x19
				st_clust(dir, dcl);					/* Table start cluster */
    4f40:	cf 01       	movw	r24, r30
    4f42:	b3 01       	movw	r22, r6
    4f44:	a2 01       	movw	r20, r4
    4f46:	0e 94 95 0a 	call	0x152a	; 0x152a <st_clust>
				dj.fs->wflag = 1;
    4f4a:	89 81       	ldd	r24, Y+1	; 0x01
    4f4c:	9a 81       	ldd	r25, Y+2	; 0x02
    4f4e:	21 e0       	ldi	r18, 0x01	; 1
    4f50:	fc 01       	movw	r30, r24
    4f52:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    4f54:	0e 94 c2 10 	call	0x2184	; 0x2184 <sync>
    4f58:	18 2f       	mov	r17, r24
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    4f5a:	81 2f       	mov	r24, r17
    4f5c:	a8 96       	adiw	r28, 0x28	; 40
    4f5e:	0f b6       	in	r0, 0x3f	; 63
    4f60:	f8 94       	cli
    4f62:	de bf       	out	0x3e, r29	; 62
    4f64:	0f be       	out	0x3f, r0	; 63
    4f66:	cd bf       	out	0x3d, r28	; 61
    4f68:	df 91       	pop	r29
    4f6a:	cf 91       	pop	r28
    4f6c:	1f 91       	pop	r17
    4f6e:	0f 91       	pop	r16
    4f70:	ff 90       	pop	r15
    4f72:	ef 90       	pop	r14
    4f74:	df 90       	pop	r13
    4f76:	cf 90       	pop	r12
    4f78:	bf 90       	pop	r11
    4f7a:	af 90       	pop	r10
    4f7c:	9f 90       	pop	r9
    4f7e:	8f 90       	pop	r8
    4f80:	7f 90       	pop	r7
    4f82:	6f 90       	pop	r6
    4f84:	5f 90       	pop	r5
    4f86:	4f 90       	pop	r4
    4f88:	3f 90       	pop	r3
    4f8a:	2f 90       	pop	r2
    4f8c:	08 95       	ret
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
    4f8e:	89 81       	ldd	r24, Y+1	; 0x01
    4f90:	9a 81       	ldd	r25, Y+2	; 0x02
    4f92:	40 e0       	ldi	r20, 0x00	; 0
    4f94:	50 e0       	ldi	r21, 0x00	; 0
    4f96:	ba 01       	movw	r22, r20
    4f98:	0e 94 b3 14 	call	0x2966	; 0x2966 <create_chain>
    4f9c:	2b 01       	movw	r4, r22
    4f9e:	3c 01       	movw	r6, r24
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
    4fa0:	61 15       	cp	r22, r1
    4fa2:	71 05       	cpc	r23, r1
    4fa4:	81 05       	cpc	r24, r1
    4fa6:	91 05       	cpc	r25, r1
    4fa8:	09 f4       	brne	.+2      	; 0x4fac <f_mkdir+0x296>
    4faa:	0b cf       	rjmp	.-490    	; 0x4dc2 <f_mkdir+0xac>
    4fac:	f8 ce       	rjmp	.-528    	; 0x4d9e <f_mkdir+0x88>
			if (dcl == 1) res = FR_INT_ERR;
    4fae:	12 e0       	ldi	r17, 0x02	; 2
    4fb0:	b4 cf       	rjmp	.-152    	; 0x4f1a <f_mkdir+0x204>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
    4fb2:	11 e0       	ldi	r17, 0x01	; 1
    4fb4:	b2 cf       	rjmp	.-156    	; 0x4f1a <f_mkdir+0x204>
					res = move_window(dj.fs, 0);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
    4fb6:	ce 01       	movw	r24, r28
    4fb8:	01 96       	adiw	r24, 0x01	; 1
    4fba:	0e 94 43 19 	call	0x3286	; 0x3286 <dir_register>
    4fbe:	18 2f       	mov	r17, r24
			if (res != FR_OK) {
    4fc0:	88 23       	and	r24, r24
    4fc2:	09 f4       	brne	.+2      	; 0x4fc6 <f_mkdir+0x2b0>
    4fc4:	b1 cf       	rjmp	.-158    	; 0x4f28 <f_mkdir+0x212>
    4fc6:	a9 cf       	rjmp	.-174    	; 0x4f1a <f_mkdir+0x204>

00004fc8 <f_chmod>:
FRESULT f_chmod (
	const TCHAR *path,	/* Pointer to the file path */
	BYTE value,			/* Attribute bits */
	BYTE mask			/* Attribute mask to change */
)
{
    4fc8:	0f 93       	push	r16
    4fca:	1f 93       	push	r17
    4fcc:	cf 93       	push	r28
    4fce:	df 93       	push	r29
    4fd0:	cd b7       	in	r28, 0x3d	; 61
    4fd2:	de b7       	in	r29, 0x3e	; 62
    4fd4:	a4 97       	sbiw	r28, 0x24	; 36
    4fd6:	0f b6       	in	r0, 0x3f	; 63
    4fd8:	f8 94       	cli
    4fda:	de bf       	out	0x3e, r29	; 62
    4fdc:	0f be       	out	0x3f, r0	; 63
    4fde:	cd bf       	out	0x3d, r28	; 61
    4fe0:	9c a3       	lds	r25, 0x5c
    4fe2:	8b a3       	lds	r24, 0x5b
    4fe4:	06 2f       	mov	r16, r22
    4fe6:	14 2f       	mov	r17, r20
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4fe8:	ce 01       	movw	r24, r28
    4fea:	83 96       	adiw	r24, 0x23	; 35
    4fec:	be 01       	movw	r22, r28
    4fee:	6f 5f       	subi	r22, 0xFF	; 255
    4ff0:	7f 4f       	sbci	r23, 0xFF	; 255
    4ff2:	41 e0       	ldi	r20, 0x01	; 1
    4ff4:	0e 94 ed 0b 	call	0x17da	; 0x17da <chk_mounted>
	if (res == FR_OK) {
    4ff8:	88 23       	and	r24, r24
    4ffa:	29 f5       	brne	.+74     	; 0x5046 <f_chmod+0x7e>
		INIT_BUF(dj);
    4ffc:	ce 01       	movw	r24, r28
    4ffe:	47 96       	adiw	r24, 0x17	; 23
    5000:	9e 8b       	std	Y+22, r25	; 0x16
    5002:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the file path */
    5004:	6b a1       	lds	r22, 0x4b
    5006:	7c a1       	lds	r23, 0x4c
    5008:	ce 01       	movw	r24, r28
    500a:	01 96       	adiw	r24, 0x01	; 1
    500c:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <follow_path>
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    5010:	88 23       	and	r24, r24
    5012:	c9 f4       	brne	.+50     	; 0x5046 <f_chmod+0x7e>
    5014:	ed 89       	ldd	r30, Y+21	; 0x15
    5016:	fe 89       	ldd	r31, Y+22	; 0x16
    5018:	83 85       	ldd	r24, Z+11	; 0x0b
    501a:	85 ff       	sbrs	r24, 5
    501c:	1f c0       	rjmp	.+62     	; 0x505c <f_chmod+0x94>
			res = FR_INVALID_NAME;
    501e:	86 e0       	ldi	r24, 0x06	; 6
    5020:	12 c0       	rjmp	.+36     	; 0x5046 <f_chmod+0x7e>
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
			} else {						/* File or sub directory */
				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
    5022:	17 72       	andi	r17, 0x27	; 39
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
    5024:	91 2f       	mov	r25, r17
    5026:	90 95       	com	r25
    5028:	83 85       	ldd	r24, Z+11	; 0x0b
    502a:	89 23       	and	r24, r25
    502c:	01 23       	and	r16, r17
    502e:	18 2f       	mov	r17, r24
    5030:	10 2b       	or	r17, r16
    5032:	13 87       	std	Z+11, r17	; 0x0b
				dj.fs->wflag = 1;
    5034:	89 81       	ldd	r24, Y+1	; 0x01
    5036:	9a 81       	ldd	r25, Y+2	; 0x02
    5038:	21 e0       	ldi	r18, 0x01	; 1
    503a:	fc 01       	movw	r30, r24
    503c:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    503e:	0e 94 c2 10 	call	0x2184	; 0x2184 <sync>
    5042:	01 c0       	rjmp	.+2      	; 0x5046 <f_chmod+0x7e>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
    5044:	86 e0       	ldi	r24, 0x06	; 6
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
    5046:	a4 96       	adiw	r28, 0x24	; 36
    5048:	0f b6       	in	r0, 0x3f	; 63
    504a:	f8 94       	cli
    504c:	de bf       	out	0x3e, r29	; 62
    504e:	0f be       	out	0x3f, r0	; 63
    5050:	cd bf       	out	0x3d, r28	; 61
    5052:	df 91       	pop	r29
    5054:	cf 91       	pop	r28
    5056:	1f 91       	pop	r17
    5058:	0f 91       	pop	r16
    505a:	08 95       	ret
		res = follow_path(&dj, path);		/* Follow the file path */
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
    505c:	eb 89       	ldd	r30, Y+19	; 0x13
    505e:	fc 89       	ldd	r31, Y+20	; 0x14
			if (!dir) {						/* Is it a root directory? */
    5060:	30 97       	sbiw	r30, 0x00	; 0
    5062:	f9 f6       	brne	.-66     	; 0x5022 <f_chmod+0x5a>
    5064:	ef cf       	rjmp	.-34     	; 0x5044 <f_chmod+0x7c>

00005066 <f_utime>:

FRESULT f_utime (
	const TCHAR *path,	/* Pointer to the file/directory name */
	const FILINFO *fno	/* Pointer to the time stamp to be set */
)
{
    5066:	0f 93       	push	r16
    5068:	1f 93       	push	r17
    506a:	cf 93       	push	r28
    506c:	df 93       	push	r29
    506e:	cd b7       	in	r28, 0x3d	; 61
    5070:	de b7       	in	r29, 0x3e	; 62
    5072:	a4 97       	sbiw	r28, 0x24	; 36
    5074:	0f b6       	in	r0, 0x3f	; 63
    5076:	f8 94       	cli
    5078:	de bf       	out	0x3e, r29	; 62
    507a:	0f be       	out	0x3f, r0	; 63
    507c:	cd bf       	out	0x3d, r28	; 61
    507e:	9c a3       	lds	r25, 0x5c
    5080:	8b a3       	lds	r24, 0x5b
    5082:	8b 01       	movw	r16, r22
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    5084:	ce 01       	movw	r24, r28
    5086:	83 96       	adiw	r24, 0x23	; 35
    5088:	be 01       	movw	r22, r28
    508a:	6f 5f       	subi	r22, 0xFF	; 255
    508c:	7f 4f       	sbci	r23, 0xFF	; 255
    508e:	41 e0       	ldi	r20, 0x01	; 1
    5090:	0e 94 ed 0b 	call	0x17da	; 0x17da <chk_mounted>
	if (res == FR_OK) {
    5094:	88 23       	and	r24, r24
    5096:	61 f5       	brne	.+88     	; 0x50f0 <f_utime+0x8a>
		INIT_BUF(dj);
    5098:	ce 01       	movw	r24, r28
    509a:	47 96       	adiw	r24, 0x17	; 23
    509c:	9e 8b       	std	Y+22, r25	; 0x16
    509e:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    50a0:	6b a1       	lds	r22, 0x4b
    50a2:	7c a1       	lds	r23, 0x4c
    50a4:	ce 01       	movw	r24, r28
    50a6:	01 96       	adiw	r24, 0x01	; 1
    50a8:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <follow_path>
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    50ac:	88 23       	and	r24, r24
    50ae:	01 f5       	brne	.+64     	; 0x50f0 <f_utime+0x8a>
    50b0:	ed 89       	ldd	r30, Y+21	; 0x15
    50b2:	fe 89       	ldd	r31, Y+22	; 0x16
    50b4:	83 85       	ldd	r24, Z+11	; 0x0b
    50b6:	85 ff       	sbrs	r24, 5
    50b8:	26 c0       	rjmp	.+76     	; 0x5106 <f_utime+0xa0>
			res = FR_INVALID_NAME;
    50ba:	86 e0       	ldi	r24, 0x06	; 6
    50bc:	19 c0       	rjmp	.+50     	; 0x50f0 <f_utime+0x8a>
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {					/* Root directory */
				res = FR_INVALID_NAME;
			} else {					/* File or sub-directory */
				ST_WORD(dir+DIR_WrtTime, fno->ftime);
    50be:	d8 01       	movw	r26, r16
    50c0:	16 96       	adiw	r26, 0x06	; 6
    50c2:	8c 91       	ld	r24, X
    50c4:	16 97       	sbiw	r26, 0x06	; 6
    50c6:	86 8b       	std	Z+22, r24	; 0x16
    50c8:	17 96       	adiw	r26, 0x07	; 7
    50ca:	8c 91       	ld	r24, X
    50cc:	17 97       	sbiw	r26, 0x07	; 7
    50ce:	87 8b       	std	Z+23, r24	; 0x17
				ST_WORD(dir+DIR_WrtDate, fno->fdate);
    50d0:	14 96       	adiw	r26, 0x04	; 4
    50d2:	8c 91       	ld	r24, X
    50d4:	14 97       	sbiw	r26, 0x04	; 4
    50d6:	80 8f       	std	Z+24, r24	; 0x18
    50d8:	15 96       	adiw	r26, 0x05	; 5
    50da:	8c 91       	ld	r24, X
    50dc:	81 8f       	std	Z+25, r24	; 0x19
				dj.fs->wflag = 1;
    50de:	89 81       	ldd	r24, Y+1	; 0x01
    50e0:	9a 81       	ldd	r25, Y+2	; 0x02
    50e2:	21 e0       	ldi	r18, 0x01	; 1
    50e4:	fc 01       	movw	r30, r24
    50e6:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    50e8:	0e 94 c2 10 	call	0x2184	; 0x2184 <sync>
    50ec:	01 c0       	rjmp	.+2      	; 0x50f0 <f_utime+0x8a>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {					/* Root directory */
				res = FR_INVALID_NAME;
    50ee:	86 e0       	ldi	r24, 0x06	; 6
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
    50f0:	a4 96       	adiw	r28, 0x24	; 36
    50f2:	0f b6       	in	r0, 0x3f	; 63
    50f4:	f8 94       	cli
    50f6:	de bf       	out	0x3e, r29	; 62
    50f8:	0f be       	out	0x3f, r0	; 63
    50fa:	cd bf       	out	0x3d, r28	; 61
    50fc:	df 91       	pop	r29
    50fe:	cf 91       	pop	r28
    5100:	1f 91       	pop	r17
    5102:	0f 91       	pop	r16
    5104:	08 95       	ret
		res = follow_path(&dj, path);	/* Follow the file path */
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
    5106:	eb 89       	ldd	r30, Y+19	; 0x13
    5108:	fc 89       	ldd	r31, Y+20	; 0x14
			if (!dir) {					/* Root directory */
    510a:	30 97       	sbiw	r30, 0x00	; 0
    510c:	c1 f6       	brne	.-80     	; 0x50be <f_utime+0x58>
    510e:	ef cf       	rjmp	.-34     	; 0x50ee <f_utime+0x88>

00005110 <f_rename>:

FRESULT f_rename (
	const TCHAR *path_old,	/* Pointer to the old name */
	const TCHAR *path_new	/* Pointer to the new name */
)
{
    5110:	ef 92       	push	r14
    5112:	ff 92       	push	r15
    5114:	0f 93       	push	r16
    5116:	1f 93       	push	r17
    5118:	cf 93       	push	r28
    511a:	df 93       	push	r29
    511c:	cd b7       	in	r28, 0x3d	; 61
    511e:	de b7       	in	r29, 0x3e	; 62
    5120:	cf 54       	subi	r28, 0x4F	; 79
    5122:	d0 40       	sbci	r29, 0x00	; 0
    5124:	0f b6       	in	r0, 0x3f	; 63
    5126:	f8 94       	cli
    5128:	de bf       	out	0x3e, r29	; 62
    512a:	0f be       	out	0x3f, r0	; 63
    512c:	cd bf       	out	0x3d, r28	; 61
    512e:	60 96       	adiw	r28, 0x10	; 16
    5130:	9f af       	sts	0x7f, r25
    5132:	8e af       	sts	0x7e, r24
    5134:	60 97       	sbiw	r28, 0x10	; 16
    5136:	8b 01       	movw	r16, r22
	BYTE buf[21], *dir;
	DWORD dw;
	DEF_NAMEBUF;


	res = chk_mounted(&path_old, &djo.fs, 1);
    5138:	ce 01       	movw	r24, r28
    513a:	82 5b       	subi	r24, 0xB2	; 178
    513c:	9f 4f       	sbci	r25, 0xFF	; 255
    513e:	be 01       	movw	r22, r28
    5140:	6f 5f       	subi	r22, 0xFF	; 255
    5142:	7f 4f       	sbci	r23, 0xFF	; 255
    5144:	41 e0       	ldi	r20, 0x01	; 1
    5146:	0e 94 ed 0b 	call	0x17da	; 0x17da <chk_mounted>
	if (res == FR_OK) {
    514a:	88 23       	and	r24, r24
    514c:	09 f0       	breq	.+2      	; 0x5150 <f_rename+0x40>
    514e:	b7 c0       	rjmp	.+366    	; 0x52be <f_rename+0x1ae>
		djn.fs = djo.fs;
    5150:	89 81       	ldd	r24, Y+1	; 0x01
    5152:	9a 81       	ldd	r25, Y+2	; 0x02
    5154:	98 8f       	std	Y+24, r25	; 0x18
    5156:	8f 8b       	std	Y+23, r24	; 0x17
		INIT_BUF(djo);
    5158:	ce 01       	movw	r24, r28
    515a:	8e 5b       	subi	r24, 0xBE	; 190
    515c:	9f 4f       	sbci	r25, 0xFF	; 255
    515e:	9e 8b       	std	Y+22, r25	; 0x16
    5160:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&djo, path_old);		/* Check old object */
    5162:	60 96       	adiw	r28, 0x10	; 16
    5164:	6e ad       	sts	0x6e, r22
    5166:	7f ad       	sts	0x6f, r23
    5168:	60 97       	sbiw	r28, 0x10	; 16
    516a:	ce 01       	movw	r24, r28
    516c:	01 96       	adiw	r24, 0x01	; 1
    516e:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <follow_path>
		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
    5172:	88 23       	and	r24, r24
    5174:	09 f0       	breq	.+2      	; 0x5178 <f_rename+0x68>
    5176:	a3 c0       	rjmp	.+326    	; 0x52be <f_rename+0x1ae>
    5178:	ed 89       	ldd	r30, Y+21	; 0x15
    517a:	fe 89       	ldd	r31, Y+22	; 0x16
    517c:	83 85       	ldd	r24, Z+11	; 0x0b
    517e:	85 ff       	sbrs	r24, 5
    5180:	ac c0       	rjmp	.+344    	; 0x52da <f_rename+0x1ca>
			res = FR_INVALID_NAME;
    5182:	86 e0       	ldi	r24, 0x06	; 6
    5184:	9c c0       	rjmp	.+312    	; 0x52be <f_rename+0x1ae>
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
    5186:	65 5f       	subi	r22, 0xF5	; 245
    5188:	7f 4f       	sbci	r23, 0xFF	; 255
    518a:	ce 01       	movw	r24, r28
    518c:	8d 96       	adiw	r24, 0x2d	; 45
    518e:	25 e1       	ldi	r18, 0x15	; 21
    5190:	30 e0       	ldi	r19, 0x00	; 0
    5192:	40 e0       	ldi	r20, 0x00	; 0
    5194:	50 e0       	ldi	r21, 0x00	; 0
    5196:	0e 94 4a 0a 	call	0x1494	; 0x1494 <mem_cpy>
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
    519a:	ce 01       	movw	r24, r28
    519c:	47 96       	adiw	r24, 0x17	; 23
    519e:	be 01       	movw	r22, r28
    51a0:	6f 5f       	subi	r22, 0xFF	; 255
    51a2:	7f 4f       	sbci	r23, 0xFF	; 255
    51a4:	26 e1       	ldi	r18, 0x16	; 22
    51a6:	30 e0       	ldi	r19, 0x00	; 0
    51a8:	40 e0       	ldi	r20, 0x00	; 0
    51aa:	50 e0       	ldi	r21, 0x00	; 0
    51ac:	0e 94 4a 0a 	call	0x1494	; 0x1494 <mem_cpy>
				res = follow_path(&djn, path_new);
    51b0:	ce 01       	movw	r24, r28
    51b2:	47 96       	adiw	r24, 0x17	; 23
    51b4:	b8 01       	movw	r22, r16
    51b6:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <follow_path>
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
    51ba:	88 23       	and	r24, r24
    51bc:	09 f4       	brne	.+2      	; 0x51c0 <f_rename+0xb0>
    51be:	7c c0       	rjmp	.+248    	; 0x52b8 <f_rename+0x1a8>
				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
    51c0:	84 30       	cpi	r24, 0x04	; 4
    51c2:	09 f0       	breq	.+2      	; 0x51c6 <f_rename+0xb6>
    51c4:	7c c0       	rjmp	.+248    	; 0x52be <f_rename+0x1ae>
/* Start critical section that an interruption or error can cause cross-link */
					res = dir_register(&djn);			/* Register the new entry */
    51c6:	ce 01       	movw	r24, r28
    51c8:	47 96       	adiw	r24, 0x17	; 23
    51ca:	0e 94 43 19 	call	0x3286	; 0x3286 <dir_register>
					if (res == FR_OK) {
    51ce:	88 23       	and	r24, r24
    51d0:	09 f0       	breq	.+2      	; 0x51d4 <f_rename+0xc4>
    51d2:	75 c0       	rjmp	.+234    	; 0x52be <f_rename+0x1ae>
						dir = djn.dir;					/* Copy object information except for name */
    51d4:	09 a5       	lds	r16, 0x69
    51d6:	1a a5       	lds	r17, 0x6a
						mem_cpy(dir+13, buf+2, 19);
    51d8:	c8 01       	movw	r24, r16
    51da:	0d 96       	adiw	r24, 0x0d	; 13
    51dc:	be 01       	movw	r22, r28
    51de:	61 5d       	subi	r22, 0xD1	; 209
    51e0:	7f 4f       	sbci	r23, 0xFF	; 255
    51e2:	23 e1       	ldi	r18, 0x13	; 19
    51e4:	30 e0       	ldi	r19, 0x00	; 0
    51e6:	40 e0       	ldi	r20, 0x00	; 0
    51e8:	50 e0       	ldi	r21, 0x00	; 0
    51ea:	0e 94 4a 0a 	call	0x1494	; 0x1494 <mem_cpy>
						dir[DIR_Attr] = buf[0] | AM_ARC;
    51ee:	8d a5       	lds	r24, 0x6d
    51f0:	80 62       	ori	r24, 0x20	; 32
    51f2:	f8 01       	movw	r30, r16
    51f4:	83 87       	std	Z+11, r24	; 0x0b
						djo.fs->wflag = 1;
    51f6:	e9 80       	ldd	r14, Y+1	; 0x01
    51f8:	fa 80       	ldd	r15, Y+2	; 0x02
    51fa:	81 e0       	ldi	r24, 0x01	; 1
    51fc:	f7 01       	movw	r30, r14
    51fe:	84 83       	std	Z+4, r24	; 0x04
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
    5200:	4f 81       	ldd	r20, Y+7	; 0x07
    5202:	58 85       	ldd	r21, Y+8	; 0x08
    5204:	69 85       	ldd	r22, Y+9	; 0x09
    5206:	7a 85       	ldd	r23, Y+10	; 0x0a
    5208:	8d 8d       	ldd	r24, Y+29	; 0x1d
    520a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    520c:	af 8d       	ldd	r26, Y+31	; 0x1f
    520e:	b8 a1       	lds	r27, 0x48
    5210:	48 17       	cp	r20, r24
    5212:	59 07       	cpc	r21, r25
    5214:	6a 07       	cpc	r22, r26
    5216:	7b 07       	cpc	r23, r27
    5218:	09 f4       	brne	.+2      	; 0x521c <f_rename+0x10c>
    521a:	43 c0       	rjmp	.+134    	; 0x52a2 <f_rename+0x192>
    521c:	f8 01       	movw	r30, r16
    521e:	83 85       	ldd	r24, Z+11	; 0x0b
    5220:	84 ff       	sbrs	r24, 4
    5222:	3f c0       	rjmp	.+126    	; 0x52a2 <f_rename+0x192>
							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
    5224:	c7 01       	movw	r24, r14
    5226:	b8 01       	movw	r22, r16
    5228:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <ld_clust>
    522c:	ab 01       	movw	r20, r22
    522e:	bc 01       	movw	r22, r24
    5230:	c7 01       	movw	r24, r14
    5232:	0e 94 54 11 	call	0x22a8	; 0x22a8 <clust2sect>
    5236:	ab 01       	movw	r20, r22
    5238:	bc 01       	movw	r22, r24
							if (!dw) {
    523a:	41 15       	cp	r20, r1
    523c:	51 05       	cpc	r21, r1
    523e:	61 05       	cpc	r22, r1
    5240:	71 05       	cpc	r23, r1
    5242:	09 f4       	brne	.+2      	; 0x5246 <f_rename+0x136>
    5244:	51 c0       	rjmp	.+162    	; 0x52e8 <f_rename+0x1d8>
								res = FR_INT_ERR;
							} else {
								res = move_window(djo.fs, dw);
    5246:	c7 01       	movw	r24, r14
    5248:	0e 94 3c 10 	call	0x2078	; 0x2078 <move_window>
								dir = djo.fs->win+SZ_DIR;	/* .. entry */
    524c:	e9 81       	ldd	r30, Y+1	; 0x01
    524e:	fa 81       	ldd	r31, Y+2	; 0x02
								if (res == FR_OK && dir[1] == '.') {
    5250:	88 23       	and	r24, r24
    5252:	a9 f5       	brne	.+106    	; 0x52be <f_rename+0x1ae>
    5254:	df 01       	movw	r26, r30
    5256:	ad 5a       	subi	r26, 0xAD	; 173
    5258:	bf 4f       	sbci	r27, 0xFF	; 255
    525a:	8c 91       	ld	r24, X
    525c:	8e 32       	cpi	r24, 0x2E	; 46
    525e:	09 f5       	brne	.+66     	; 0x52a2 <f_rename+0x192>
									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
    5260:	80 81       	ld	r24, Z
    5262:	83 30       	cpi	r24, 0x03	; 3
    5264:	69 f4       	brne	.+26     	; 0x5280 <f_rename+0x170>
    5266:	4d 8d       	ldd	r20, Y+29	; 0x1d
    5268:	5e 8d       	ldd	r21, Y+30	; 0x1e
    526a:	6f 8d       	ldd	r22, Y+31	; 0x1f
    526c:	78 a1       	lds	r23, 0x48
    526e:	86 a1       	lds	r24, 0x46
    5270:	97 a1       	lds	r25, 0x47
    5272:	a0 a5       	lds	r26, 0x60
    5274:	b1 a5       	lds	r27, 0x61
    5276:	48 17       	cp	r20, r24
    5278:	59 07       	cpc	r21, r25
    527a:	6a 07       	cpc	r22, r26
    527c:	7b 07       	cpc	r23, r27
    527e:	29 f0       	breq	.+10     	; 0x528a <f_rename+0x17a>
    5280:	4d 8d       	ldd	r20, Y+29	; 0x1d
    5282:	5e 8d       	ldd	r21, Y+30	; 0x1e
    5284:	6f 8d       	ldd	r22, Y+31	; 0x1f
    5286:	78 a1       	lds	r23, 0x48
    5288:	03 c0       	rjmp	.+6      	; 0x5290 <f_rename+0x180>
    528a:	40 e0       	ldi	r20, 0x00	; 0
    528c:	50 e0       	ldi	r21, 0x00	; 0
    528e:	ba 01       	movw	r22, r20
									st_clust(dir, dw);
    5290:	cf 01       	movw	r24, r30
    5292:	8e 5a       	subi	r24, 0xAE	; 174
    5294:	9f 4f       	sbci	r25, 0xFF	; 255
    5296:	0e 94 95 0a 	call	0x152a	; 0x152a <st_clust>
									djo.fs->wflag = 1;
    529a:	e9 81       	ldd	r30, Y+1	; 0x01
    529c:	fa 81       	ldd	r31, Y+2	; 0x02
    529e:	81 e0       	ldi	r24, 0x01	; 1
    52a0:	84 83       	std	Z+4, r24	; 0x04
								}
							}
						}
						if (res == FR_OK) {
							res = dir_remove(&djo);		/* Remove old entry */
    52a2:	ce 01       	movw	r24, r28
    52a4:	01 96       	adiw	r24, 0x01	; 1
    52a6:	0e 94 86 13 	call	0x270c	; 0x270c <dir_remove>
							if (res == FR_OK)
    52aa:	88 23       	and	r24, r24
    52ac:	41 f4       	brne	.+16     	; 0x52be <f_rename+0x1ae>
								res = sync(djo.fs);
    52ae:	89 81       	ldd	r24, Y+1	; 0x01
    52b0:	9a 81       	ldd	r25, Y+2	; 0x02
    52b2:	0e 94 c2 10 	call	0x2184	; 0x2184 <sync>
    52b6:	03 c0       	rjmp	.+6      	; 0x52be <f_rename+0x1ae>
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
				res = follow_path(&djn, path_new);
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
    52b8:	88 e0       	ldi	r24, 0x08	; 8
    52ba:	01 c0       	rjmp	.+2      	; 0x52be <f_rename+0x1ae>
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
    52bc:	84 e0       	ldi	r24, 0x04	; 4
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(djo.fs, res);
}
    52be:	c1 5b       	subi	r28, 0xB1	; 177
    52c0:	df 4f       	sbci	r29, 0xFF	; 255
    52c2:	0f b6       	in	r0, 0x3f	; 63
    52c4:	f8 94       	cli
    52c6:	de bf       	out	0x3e, r29	; 62
    52c8:	0f be       	out	0x3f, r0	; 63
    52ca:	cd bf       	out	0x3d, r28	; 61
    52cc:	df 91       	pop	r29
    52ce:	cf 91       	pop	r28
    52d0:	1f 91       	pop	r17
    52d2:	0f 91       	pop	r16
    52d4:	ff 90       	pop	r15
    52d6:	ef 90       	pop	r14
    52d8:	08 95       	ret
			res = FR_INVALID_NAME;
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
    52da:	6b 89       	ldd	r22, Y+19	; 0x13
    52dc:	7c 89       	ldd	r23, Y+20	; 0x14
    52de:	61 15       	cp	r22, r1
    52e0:	71 05       	cpc	r23, r1
    52e2:	09 f0       	breq	.+2      	; 0x52e6 <f_rename+0x1d6>
    52e4:	50 cf       	rjmp	.-352    	; 0x5186 <f_rename+0x76>
    52e6:	ea cf       	rjmp	.-44     	; 0x52bc <f_rename+0x1ac>
						dir[DIR_Attr] = buf[0] | AM_ARC;
						djo.fs->wflag = 1;
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
							if (!dw) {
								res = FR_INT_ERR;
    52e8:	82 e0       	ldi	r24, 0x02	; 2
    52ea:	e9 cf       	rjmp	.-46     	; 0x52be <f_rename+0x1ae>

000052ec <PCA9542A_Init>:
 */ 
#include "PCA9542A.h"


unsigned char PCA9542A_Init()
{
    52ec:	cf 93       	push	r28
    52ee:	df 93       	push	r29
    52f0:	00 d0       	rcall	.+0      	; 0x52f2 <PCA9542A_Init+0x6>
    52f2:	00 d0       	rcall	.+0      	; 0x52f4 <PCA9542A_Init+0x8>
    52f4:	cd b7       	in	r28, 0x3d	; 61
    52f6:	de b7       	in	r29, 0x3e	; 62
	unsigned char messageBuf[TWI_BUFFER_SIZE];
	messageBuf[0] = (PCA9542A_ADDR  <<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consit of General Call code or the TWI slave address.
    52f8:	88 ee       	ldi	r24, 0xE8	; 232
    52fa:	89 83       	std	Y+1, r24	; 0x01
	messageBuf[1] = NO_SELECT;             // The first byte is used for commands.
    52fc:	1a 82       	std	Y+2, r1	; 0x02
	// The second byte is used for the data.
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
    52fe:	ce 01       	movw	r24, r28
    5300:	01 96       	adiw	r24, 0x01	; 1
    5302:	62 e0       	ldi	r22, 0x02	; 2
    5304:	0e 94 e3 29 	call	0x53c6	; 0x53c6 <TWI_Start_Transceiver_With_Data>
	
	while(TWI_Transceiver_Busy()) ; //Wait for transceiver to clear
    5308:	0e 94 d8 29 	call	0x53b0	; 0x53b0 <TWI_Transceiver_Busy>
    530c:	88 23       	and	r24, r24
    530e:	e1 f7       	brne	.-8      	; 0x5308 <PCA9542A_Init+0x1c>
	
	return TWI_statusReg.lastTransOK;
    5310:	80 91 28 04 	lds	r24, 0x0428
}
    5314:	81 70       	andi	r24, 0x01	; 1
    5316:	0f 90       	pop	r0
    5318:	0f 90       	pop	r0
    531a:	0f 90       	pop	r0
    531c:	0f 90       	pop	r0
    531e:	df 91       	pop	r29
    5320:	cf 91       	pop	r28
    5322:	08 95       	ret

00005324 <PCA9542A_SetChannel>:

unsigned char PCA9542A_SetChannel( uint8_t Channel )
{
    5324:	cf 93       	push	r28
    5326:	df 93       	push	r29
    5328:	00 d0       	rcall	.+0      	; 0x532a <PCA9542A_SetChannel+0x6>
    532a:	00 d0       	rcall	.+0      	; 0x532c <PCA9542A_SetChannel+0x8>
    532c:	cd b7       	in	r28, 0x3d	; 61
    532e:	de b7       	in	r29, 0x3e	; 62
	unsigned char messageBuf[TWI_BUFFER_SIZE];
	messageBuf[0] = (PCA9542A_ADDR  <<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consit of General Call code or the TWI slave address.
    5330:	98 ee       	ldi	r25, 0xE8	; 232
    5332:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = Channel;             // The first byte is used for commands.
    5334:	8a 83       	std	Y+2, r24	; 0x02
		                    // The second byte is used for the data.
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
    5336:	ce 01       	movw	r24, r28
    5338:	01 96       	adiw	r24, 0x01	; 1
    533a:	62 e0       	ldi	r22, 0x02	; 2
    533c:	0e 94 e3 29 	call	0x53c6	; 0x53c6 <TWI_Start_Transceiver_With_Data>
		
	while(TWI_Transceiver_Busy()) ; //Wait for transceiver to clear
    5340:	0e 94 d8 29 	call	0x53b0	; 0x53b0 <TWI_Transceiver_Busy>
    5344:	88 23       	and	r24, r24
    5346:	e1 f7       	brne	.-8      	; 0x5340 <PCA9542A_SetChannel+0x1c>
		
	return TWI_statusReg.lastTransOK;
    5348:	80 91 28 04 	lds	r24, 0x0428
}
    534c:	81 70       	andi	r24, 0x01	; 1
    534e:	0f 90       	pop	r0
    5350:	0f 90       	pop	r0
    5352:	0f 90       	pop	r0
    5354:	0f 90       	pop	r0
    5356:	df 91       	pop	r29
    5358:	cf 91       	pop	r28
    535a:	08 95       	ret

0000535c <PCA9542A_ReadChannel>:

unsigned char PCA9542A_ReadChannel()
{
    535c:	cf 93       	push	r28
    535e:	df 93       	push	r29
    5360:	00 d0       	rcall	.+0      	; 0x5362 <PCA9542A_ReadChannel+0x6>
    5362:	00 d0       	rcall	.+0      	; 0x5364 <PCA9542A_ReadChannel+0x8>
    5364:	cd b7       	in	r28, 0x3d	; 61
    5366:	de b7       	in	r29, 0x3e	; 62
	unsigned char messageBuf[TWI_BUFFER_SIZE];
	messageBuf[0] = (PCA9542A_ADDR  <<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT); // The first byte must always consit of General Call code or the TWI slave address.
    5368:	89 ee       	ldi	r24, 0xE9	; 233
    536a:	89 83       	std	Y+1, r24	; 0x01

	TWI_Start_Transceiver_With_Data( messageBuf, 1 );
    536c:	ce 01       	movw	r24, r28
    536e:	01 96       	adiw	r24, 0x01	; 1
    5370:	61 e0       	ldi	r22, 0x01	; 1
    5372:	0e 94 e3 29 	call	0x53c6	; 0x53c6 <TWI_Start_Transceiver_With_Data>
	
	while(TWI_Transceiver_Busy()) ; //Wait for transceiver to clear
    5376:	0e 94 d8 29 	call	0x53b0	; 0x53b0 <TWI_Transceiver_Busy>
    537a:	88 23       	and	r24, r24
    537c:	e1 f7       	brne	.-8      	; 0x5376 <PCA9542A_ReadChannel+0x1a>
	// Get the received data from the transceiver buffer
	TWI_Get_Data_From_Transceiver( messageBuf, 2 );
    537e:	ce 01       	movw	r24, r28
    5380:	01 96       	adiw	r24, 0x01	; 1
    5382:	62 e0       	ldi	r22, 0x02	; 2
    5384:	0e 94 19 2a 	call	0x5432	; 0x5432 <TWI_Get_Data_From_Transceiver>
	return TWI_statusReg.lastTransOK;
    5388:	80 91 28 04 	lds	r24, 0x0428
    538c:	81 70       	andi	r24, 0x01	; 1
    538e:	0f 90       	pop	r0
    5390:	0f 90       	pop	r0
    5392:	0f 90       	pop	r0
    5394:	0f 90       	pop	r0
    5396:	df 91       	pop	r29
    5398:	cf 91       	pop	r28
    539a:	08 95       	ret

0000539c <TWI_Master_Initialise>:
		DDRC = 0x00;
		PORTC = (1 << PC0) | (1 << PC1);
	#else
		#pragma message("External I2C Pull Ups Required.")
	#endif
	TWBR = TWI_TWBR;                                  // Set bit rate register (Baudrate). Defined in header file.
    539c:	84 e3       	ldi	r24, 0x34	; 52
    539e:	80 93 b8 00 	sts	0x00B8, r24
	// TWSR = TWI_TWPS;                                  // Not used. Driver presumes prescaler to be 00.
	TWDR = 0xFF;                                      // Default content = SDA released.
    53a2:	8f ef       	ldi	r24, 0xFF	; 255
    53a4:	80 93 bb 00 	sts	0x00BB, r24
	TWCR =	(1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
    53a8:	84 e0       	ldi	r24, 0x04	; 4
    53aa:	80 93 bc 00 	sts	0x00BC, r24
			(0<<TWIE)|(0<<TWINT)|                      // Disable Interupt.
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests.
			(0<<TWWC);                                 //
}    
    53ae:	08 95       	ret

000053b0 <TWI_Transceiver_Busy>:
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
    53b0:	80 91 bc 00 	lds	r24, 0x00BC
}
    53b4:	81 70       	andi	r24, 0x01	; 1
    53b6:	08 95       	ret

000053b8 <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
    53b8:	0e 94 d8 29 	call	0x53b0	; 0x53b0 <TWI_Transceiver_Busy>
    53bc:	88 23       	and	r24, r24
    53be:	e1 f7       	brne	.-8      	; 0x53b8 <TWI_Get_State_Info>
  return ( TWI_state );                         // Return error state.
}
    53c0:	80 91 1e 04 	lds	r24, 0x041E
    53c4:	08 95       	ret

000053c6 <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
    53c6:	0f 93       	push	r16
    53c8:	1f 93       	push	r17
    53ca:	cf 93       	push	r28
    53cc:	8c 01       	movw	r16, r24
    53ce:	c6 2f       	mov	r28, r22
  unsigned char temp;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    53d0:	0e 94 d8 29 	call	0x53b0	; 0x53b0 <TWI_Transceiver_Busy>
    53d4:	88 23       	and	r24, r24
    53d6:	e1 f7       	brne	.-8      	; 0x53d0 <TWI_Start_Transceiver_With_Data+0xa>

  TWI_msgSize = msgSize;                        // Number of data to transmit.
    53d8:	c0 93 29 04 	sts	0x0429, r28
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
    53dc:	f8 01       	movw	r30, r16
    53de:	80 81       	ld	r24, Z
    53e0:	80 93 2a 04 	sts	0x042A, r24
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
    53e4:	80 fd       	sbrc	r24, 0
    53e6:	0c c0       	rjmp	.+24     	; 0x5400 <TWI_Start_Transceiver_With_Data+0x3a>
  {
    for ( temp = 1; temp < msgSize; temp++ )
    53e8:	c2 30       	cpi	r28, 0x02	; 2
    53ea:	50 f0       	brcs	.+20     	; 0x5400 <TWI_Start_Transceiver_With_Data+0x3a>
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    53ec:	d8 01       	movw	r26, r16
    53ee:	11 96       	adiw	r26, 0x01	; 1

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    53f0:	eb e2       	ldi	r30, 0x2B	; 43
    53f2:	f4 e0       	ldi	r31, 0x04	; 4
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    53f4:	81 e0       	ldi	r24, 0x01	; 1
  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
      TWI_buf[ temp ] = msg[ temp ];
    53f6:	9d 91       	ld	r25, X+
    53f8:	91 93       	st	Z+, r25

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    53fa:	8f 5f       	subi	r24, 0xFF	; 255
    53fc:	8c 17       	cp	r24, r28
    53fe:	d9 f7       	brne	.-10     	; 0x53f6 <TWI_Start_Transceiver_With_Data+0x30>
      TWI_buf[ temp ] = msg[ temp ];
  }
  TWI_statusReg.all = 0;      
    5400:	10 92 28 04 	sts	0x0428, r1
  TWI_state         = TWI_NO_STATE ;
    5404:	88 ef       	ldi	r24, 0xF8	; 248
    5406:	80 93 1e 04 	sts	0x041E, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    540a:	85 ea       	ldi	r24, 0xA5	; 165
    540c:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    5410:	cf 91       	pop	r28
    5412:	1f 91       	pop	r17
    5414:	0f 91       	pop	r16
    5416:	08 95       	ret

00005418 <TWI_Start_Transceiver>:
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    5418:	0e 94 d8 29 	call	0x53b0	; 0x53b0 <TWI_Transceiver_Busy>
    541c:	88 23       	and	r24, r24
    541e:	e1 f7       	brne	.-8      	; 0x5418 <TWI_Start_Transceiver>
  TWI_statusReg.all = 0;      
    5420:	10 92 28 04 	sts	0x0428, r1
  TWI_state         = TWI_NO_STATE ;
    5424:	88 ef       	ldi	r24, 0xF8	; 248
    5426:	80 93 1e 04 	sts	0x041E, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    542a:	85 ea       	ldi	r24, 0xA5	; 165
    542c:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    5430:	08 95       	ret

00005432 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    5432:	1f 93       	push	r17
    5434:	cf 93       	push	r28
    5436:	df 93       	push	r29
    5438:	d8 2f       	mov	r29, r24
    543a:	19 2f       	mov	r17, r25
    543c:	c6 2f       	mov	r28, r22
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    543e:	0e 94 d8 29 	call	0x53b0	; 0x53b0 <TWI_Transceiver_Busy>
    5442:	88 23       	and	r24, r24
    5444:	e1 f7       	brne	.-8      	; 0x543e <TWI_Get_Data_From_Transceiver+0xc>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    5446:	80 91 28 04 	lds	r24, 0x0428
    544a:	80 ff       	sbrs	r24, 0
    544c:	0d c0       	rjmp	.+26     	; 0x5468 <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    544e:	cc 23       	and	r28, r28
    5450:	59 f0       	breq	.+22     	; 0x5468 <TWI_Get_Data_From_Transceiver+0x36>
    5452:	aa e2       	ldi	r26, 0x2A	; 42
    5454:	b4 e0       	ldi	r27, 0x04	; 4
    5456:	9d 2f       	mov	r25, r29
    5458:	ed 2f       	mov	r30, r29
    545a:	f1 2f       	mov	r31, r17
    {
      msg[ i ] = TWI_buf[ i ];
    545c:	8d 91       	ld	r24, X+
    545e:	81 93       	st	Z+, r24

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    5460:	8e 2f       	mov	r24, r30
    5462:	89 1b       	sub	r24, r25
    5464:	8c 17       	cp	r24, r28
    5466:	d0 f3       	brcs	.-12     	; 0x545c <TWI_Get_Data_From_Transceiver+0x2a>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    5468:	80 91 28 04 	lds	r24, 0x0428
}
    546c:	81 70       	andi	r24, 0x01	; 1
    546e:	df 91       	pop	r29
    5470:	cf 91       	pop	r28
    5472:	1f 91       	pop	r17
    5474:	08 95       	ret

00005476 <__vector_26>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/

ISR(TWI_vect)
{
    5476:	1f 92       	push	r1
    5478:	0f 92       	push	r0
    547a:	0f b6       	in	r0, 0x3f	; 63
    547c:	0f 92       	push	r0
    547e:	11 24       	eor	r1, r1
    5480:	2f 93       	push	r18
    5482:	3f 93       	push	r19
    5484:	8f 93       	push	r24
    5486:	9f 93       	push	r25
    5488:	ef 93       	push	r30
    548a:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    548c:	80 91 b9 00 	lds	r24, 0x00B9
    5490:	88 32       	cpi	r24, 0x28	; 40
    5492:	d1 f0       	breq	.+52     	; 0x54c8 <__vector_26+0x52>
    5494:	89 32       	cpi	r24, 0x29	; 41
    5496:	40 f4       	brcc	.+16     	; 0x54a8 <__vector_26+0x32>
    5498:	80 31       	cpi	r24, 0x10	; 16
    549a:	a1 f0       	breq	.+40     	; 0x54c4 <__vector_26+0x4e>
    549c:	88 31       	cpi	r24, 0x18	; 24
    549e:	a1 f0       	breq	.+40     	; 0x54c8 <__vector_26+0x52>
    54a0:	88 30       	cpi	r24, 0x08	; 8
    54a2:	09 f0       	breq	.+2      	; 0x54a6 <__vector_26+0x30>
    54a4:	61 c0       	rjmp	.+194    	; 0x5568 <__vector_26+0xf2>
    54a6:	0e c0       	rjmp	.+28     	; 0x54c4 <__vector_26+0x4e>
    54a8:	80 34       	cpi	r24, 0x40	; 64
    54aa:	b9 f1       	breq	.+110    	; 0x551a <__vector_26+0xa4>
    54ac:	81 34       	cpi	r24, 0x41	; 65
    54ae:	20 f4       	brcc	.+8      	; 0x54b8 <__vector_26+0x42>
    54b0:	88 33       	cpi	r24, 0x38	; 56
    54b2:	09 f0       	breq	.+2      	; 0x54b6 <__vector_26+0x40>
    54b4:	59 c0       	rjmp	.+178    	; 0x5568 <__vector_26+0xf2>
    54b6:	54 c0       	rjmp	.+168    	; 0x5560 <__vector_26+0xea>
    54b8:	80 35       	cpi	r24, 0x50	; 80
    54ba:	19 f1       	breq	.+70     	; 0x5502 <__vector_26+0x8c>
    54bc:	88 35       	cpi	r24, 0x58	; 88
    54be:	09 f0       	breq	.+2      	; 0x54c2 <__vector_26+0x4c>
    54c0:	53 c0       	rjmp	.+166    	; 0x5568 <__vector_26+0xf2>
    54c2:	3d c0       	rjmp	.+122    	; 0x553e <__vector_26+0xc8>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    54c4:	10 92 2e 04 	sts	0x042E, r1
    case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    54c8:	80 91 2e 04 	lds	r24, 0x042E
    54cc:	90 91 29 04 	lds	r25, 0x0429
    54d0:	89 17       	cp	r24, r25
    54d2:	70 f4       	brcc	.+28     	; 0x54f0 <__vector_26+0x7a>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    54d4:	e8 2f       	mov	r30, r24
    54d6:	f0 e0       	ldi	r31, 0x00	; 0
    54d8:	e6 5d       	subi	r30, 0xD6	; 214
    54da:	fb 4f       	sbci	r31, 0xFB	; 251
    54dc:	90 81       	ld	r25, Z
    54de:	90 93 bb 00 	sts	0x00BB, r25
    54e2:	8f 5f       	subi	r24, 0xFF	; 255
    54e4:	80 93 2e 04 	sts	0x042E, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    54e8:	85 e8       	ldi	r24, 0x85	; 133
    54ea:	80 93 bc 00 	sts	0x00BC, r24
    54ee:	43 c0       	rjmp	.+134    	; 0x5576 <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    54f0:	80 91 28 04 	lds	r24, 0x0428
    54f4:	81 60       	ori	r24, 0x01	; 1
    54f6:	80 93 28 04 	sts	0x0428, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    54fa:	84 e9       	ldi	r24, 0x94	; 148
    54fc:	80 93 bc 00 	sts	0x00BC, r24
    5500:	3a c0       	rjmp	.+116    	; 0x5576 <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    5502:	80 91 2e 04 	lds	r24, 0x042E
    5506:	90 91 bb 00 	lds	r25, 0x00BB
    550a:	e8 2f       	mov	r30, r24
    550c:	f0 e0       	ldi	r31, 0x00	; 0
    550e:	e6 5d       	subi	r30, 0xD6	; 214
    5510:	fb 4f       	sbci	r31, 0xFB	; 251
    5512:	90 83       	st	Z, r25
    5514:	8f 5f       	subi	r24, 0xFF	; 255
    5516:	80 93 2e 04 	sts	0x042E, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    551a:	20 91 2e 04 	lds	r18, 0x042E
    551e:	30 e0       	ldi	r19, 0x00	; 0
    5520:	80 91 29 04 	lds	r24, 0x0429
    5524:	90 e0       	ldi	r25, 0x00	; 0
    5526:	01 97       	sbiw	r24, 0x01	; 1
    5528:	28 17       	cp	r18, r24
    552a:	39 07       	cpc	r19, r25
    552c:	24 f4       	brge	.+8      	; 0x5536 <__vector_26+0xc0>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    552e:	85 ec       	ldi	r24, 0xC5	; 197
    5530:	80 93 bc 00 	sts	0x00BC, r24
    5534:	20 c0       	rjmp	.+64     	; 0x5576 <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    5536:	85 e8       	ldi	r24, 0x85	; 133
    5538:	80 93 bc 00 	sts	0x00BC, r24
    553c:	1c c0       	rjmp	.+56     	; 0x5576 <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    553e:	80 91 bb 00 	lds	r24, 0x00BB
    5542:	e0 91 2e 04 	lds	r30, 0x042E
    5546:	f0 e0       	ldi	r31, 0x00	; 0
    5548:	e6 5d       	subi	r30, 0xD6	; 214
    554a:	fb 4f       	sbci	r31, 0xFB	; 251
    554c:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    554e:	80 91 28 04 	lds	r24, 0x0428
    5552:	81 60       	ori	r24, 0x01	; 1
    5554:	80 93 28 04 	sts	0x0428, r24
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    5558:	84 e9       	ldi	r24, 0x94	; 148
    555a:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    555e:	0b c0       	rjmp	.+22     	; 0x5576 <__vector_26+0x100>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    5560:	85 ea       	ldi	r24, 0xA5	; 165
    5562:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    5566:	07 c0       	rjmp	.+14     	; 0x5576 <__vector_26+0x100>
    case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
//    case TWI_NO_STATE              // No relevant state information available; TWINT = 0
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    5568:	80 91 b9 00 	lds	r24, 0x00B9
    556c:	80 93 1e 04 	sts	0x041E, r24
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    5570:	84 e0       	ldi	r24, 0x04	; 4
    5572:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    5576:	ff 91       	pop	r31
    5578:	ef 91       	pop	r30
    557a:	9f 91       	pop	r25
    557c:	8f 91       	pop	r24
    557e:	3f 91       	pop	r19
    5580:	2f 91       	pop	r18
    5582:	0f 90       	pop	r0
    5584:	0f be       	out	0x3f, r0	; 63
    5586:	0f 90       	pop	r0
    5588:	1f 90       	pop	r1
    558a:	18 95       	reti

0000558c <USART0_Init>:

void USART0_Init()
{
	uint16_t ubrr = UBBR;
	//Set baud rate
	UBRR0H = (unsigned char)(ubrr >>8);
    558c:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (unsigned char)ubrr ;
    5590:	8c e0       	ldi	r24, 0x0C	; 12
    5592:	80 93 c4 00 	sts	0x00C4, r24
	//Enable receiver and transmitter
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    5596:	88 e1       	ldi	r24, 0x18	; 24
    5598:	80 93 c1 00 	sts	0x00C1, r24
	
	UCSR0C = 0x06; //set asynchronous, no parity, one stop bit, 8 bit transfer.
    559c:	86 e0       	ldi	r24, 0x06	; 6
    559e:	80 93 c2 00 	sts	0x00C2, r24
	
	//UCSR0B |= (1 << RXCIE0) | (1 << TXCIE0); //set RX and TX interrupt on
}
    55a2:	08 95       	ret

000055a4 <Usart_SendChar>:
void Usart_SendChar(char data) 
{
    // Wait for empty transmit buffer
    while ( !(UCSR0A & (1 << UDRE0)) );
    55a4:	e0 ec       	ldi	r30, 0xC0	; 192
    55a6:	f0 e0       	ldi	r31, 0x00	; 0
    55a8:	90 81       	ld	r25, Z
    55aa:	95 ff       	sbrs	r25, 5
    55ac:	fd cf       	rjmp	.-6      	; 0x55a8 <Usart_SendChar+0x4>
    // Start transmission
    UDR0 = data; 
    55ae:	80 93 c6 00 	sts	0x00C6, r24
}
    55b2:	08 95       	ret

000055b4 <Usart_Receive>:
unsigned char Usart_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
    55b4:	e0 ec       	ldi	r30, 0xC0	; 192
    55b6:	f0 e0       	ldi	r31, 0x00	; 0
    55b8:	80 81       	ld	r24, Z
    55ba:	88 23       	and	r24, r24
    55bc:	ec f7       	brge	.-6      	; 0x55b8 <Usart_Receive+0x4>
	;
	/* Get and return received data from buffer */
	//Usart_SendChar(UDR0);
	return UDR0;
    55be:	80 91 c6 00 	lds	r24, 0x00C6
}
    55c2:	08 95       	ret

000055c4 <Usart_printf>:
//to use this copy the following as a global- 
//		static FILE mystdout = FDEV_SETUP_STREAM(Usart_printf, NULL, _FDEV_SETUP_WRITE);
// and add this line at the beginning of main:
//		stdout = &mystdout;
//	stdio.h must be used.
int Usart_printf(char var, FILE *stream) {
    55c4:	cf 93       	push	r28
    55c6:	c8 2f       	mov	r28, r24
    // translate \n to \r for br@y++ terminal
    if (var == '\n') Usart_SendChar('\r');
    55c8:	8a 30       	cpi	r24, 0x0A	; 10
    55ca:	19 f4       	brne	.+6      	; 0x55d2 <Usart_printf+0xe>
    55cc:	8d e0       	ldi	r24, 0x0D	; 13
    55ce:	0e 94 d2 2a 	call	0x55a4	; 0x55a4 <Usart_SendChar>
    Usart_SendChar(var);
    55d2:	8c 2f       	mov	r24, r28
    55d4:	0e 94 d2 2a 	call	0x55a4	; 0x55a4 <Usart_SendChar>
    return 0;
}
    55d8:	80 e0       	ldi	r24, 0x00	; 0
    55da:	90 e0       	ldi	r25, 0x00	; 0
    55dc:	cf 91       	pop	r28
    55de:	08 95       	ret

000055e0 <Usart_get_line>:

void Usart_get_line (char *buff, int len)
{
    55e0:	ef 92       	push	r14
    55e2:	ff 92       	push	r15
    55e4:	0f 93       	push	r16
    55e6:	1f 93       	push	r17
    55e8:	cf 93       	push	r28
    55ea:	df 93       	push	r29
    55ec:	7c 01       	movw	r14, r24
	cli();
    55ee:	f8 94       	cli
	char c;
	int i = 0;
    55f0:	c0 e0       	ldi	r28, 0x00	; 0
    55f2:	d0 e0       	ldi	r29, 0x00	; 0
		if ((c == '\b') && i) {
			i--;
			Usart_SendChar(c);
			continue;
		}
		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    55f4:	8b 01       	movw	r16, r22
    55f6:	01 50       	subi	r16, 0x01	; 1
    55f8:	10 40       	sbci	r17, 0x00	; 0
	char c;
	int i = 0;


	for (;;) {
		c = Usart_Receive();
    55fa:	0e 94 da 2a 	call	0x55b4	; 0x55b4 <Usart_Receive>
		if (c == '\r') break;
    55fe:	8d 30       	cpi	r24, 0x0D	; 13
    5600:	a9 f0       	breq	.+42     	; 0x562c <Usart_get_line+0x4c>
		if ((c == '\b') && i) {
    5602:	88 30       	cpi	r24, 0x08	; 8
    5604:	31 f4       	brne	.+12     	; 0x5612 <Usart_get_line+0x32>
    5606:	20 97       	sbiw	r28, 0x00	; 0
    5608:	c1 f3       	breq	.-16     	; 0x55fa <Usart_get_line+0x1a>
			i--;
    560a:	21 97       	sbiw	r28, 0x01	; 1
			Usart_SendChar(c);
    560c:	0e 94 d2 2a 	call	0x55a4	; 0x55a4 <Usart_SendChar>
			continue;
    5610:	f4 cf       	rjmp	.-24     	; 0x55fa <Usart_get_line+0x1a>
		}
		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    5612:	80 32       	cpi	r24, 0x20	; 32
    5614:	90 f3       	brcs	.-28     	; 0x55fa <Usart_get_line+0x1a>
    5616:	c0 17       	cp	r28, r16
    5618:	d1 07       	cpc	r29, r17
    561a:	7c f7       	brge	.-34     	; 0x55fa <Usart_get_line+0x1a>
			buff[i++] = c;
    561c:	f7 01       	movw	r30, r14
    561e:	ec 0f       	add	r30, r28
    5620:	fd 1f       	adc	r31, r29
    5622:	80 83       	st	Z, r24
    5624:	21 96       	adiw	r28, 0x01	; 1
			Usart_SendChar(c);
    5626:	0e 94 d2 2a 	call	0x55a4	; 0x55a4 <Usart_SendChar>
    562a:	e7 cf       	rjmp	.-50     	; 0x55fa <Usart_get_line+0x1a>
		}
	}
	buff[i] = 0;
    562c:	ce 0d       	add	r28, r14
    562e:	df 1d       	adc	r29, r15
    5630:	18 82       	st	Y, r1
	Usart_SendChar('\n');
    5632:	8a e0       	ldi	r24, 0x0A	; 10
    5634:	0e 94 d2 2a 	call	0x55a4	; 0x55a4 <Usart_SendChar>
	sei();
    5638:	78 94       	sei
}
    563a:	df 91       	pop	r29
    563c:	cf 91       	pop	r28
    563e:	1f 91       	pop	r17
    5640:	0f 91       	pop	r16
    5642:	ff 90       	pop	r15
    5644:	ef 90       	pop	r14
    5646:	08 95       	ret

00005648 <USART0_Senduint16>:
void USART0_Senduint16 (uint16_t Data)
{
    5648:	cf 93       	push	r28
    564a:	c8 2f       	mov	r28, r24
	Usart_SendChar(Data >> 8);
    564c:	89 2f       	mov	r24, r25
    564e:	0e 94 d2 2a 	call	0x55a4	; 0x55a4 <Usart_SendChar>
	Usart_SendChar(Data & 0xFF);
    5652:	8c 2f       	mov	r24, r28
    5654:	0e 94 d2 2a 	call	0x55a4	; 0x55a4 <Usart_SendChar>
    5658:	cf 91       	pop	r28
    565a:	08 95       	ret

0000565c <__mulsi3>:
    565c:	62 9f       	mul	r22, r18
    565e:	d0 01       	movw	r26, r0
    5660:	73 9f       	mul	r23, r19
    5662:	f0 01       	movw	r30, r0
    5664:	82 9f       	mul	r24, r18
    5666:	e0 0d       	add	r30, r0
    5668:	f1 1d       	adc	r31, r1
    566a:	64 9f       	mul	r22, r20
    566c:	e0 0d       	add	r30, r0
    566e:	f1 1d       	adc	r31, r1
    5670:	92 9f       	mul	r25, r18
    5672:	f0 0d       	add	r31, r0
    5674:	83 9f       	mul	r24, r19
    5676:	f0 0d       	add	r31, r0
    5678:	74 9f       	mul	r23, r20
    567a:	f0 0d       	add	r31, r0
    567c:	65 9f       	mul	r22, r21
    567e:	f0 0d       	add	r31, r0
    5680:	99 27       	eor	r25, r25
    5682:	72 9f       	mul	r23, r18
    5684:	b0 0d       	add	r27, r0
    5686:	e1 1d       	adc	r30, r1
    5688:	f9 1f       	adc	r31, r25
    568a:	63 9f       	mul	r22, r19
    568c:	b0 0d       	add	r27, r0
    568e:	e1 1d       	adc	r30, r1
    5690:	f9 1f       	adc	r31, r25
    5692:	bd 01       	movw	r22, r26
    5694:	cf 01       	movw	r24, r30
    5696:	11 24       	eor	r1, r1
    5698:	08 95       	ret

0000569a <__udivmodsi4>:
    569a:	a1 e2       	ldi	r26, 0x21	; 33
    569c:	1a 2e       	mov	r1, r26
    569e:	aa 1b       	sub	r26, r26
    56a0:	bb 1b       	sub	r27, r27
    56a2:	fd 01       	movw	r30, r26
    56a4:	0d c0       	rjmp	.+26     	; 0x56c0 <__udivmodsi4_ep>

000056a6 <__udivmodsi4_loop>:
    56a6:	aa 1f       	adc	r26, r26
    56a8:	bb 1f       	adc	r27, r27
    56aa:	ee 1f       	adc	r30, r30
    56ac:	ff 1f       	adc	r31, r31
    56ae:	a2 17       	cp	r26, r18
    56b0:	b3 07       	cpc	r27, r19
    56b2:	e4 07       	cpc	r30, r20
    56b4:	f5 07       	cpc	r31, r21
    56b6:	20 f0       	brcs	.+8      	; 0x56c0 <__udivmodsi4_ep>
    56b8:	a2 1b       	sub	r26, r18
    56ba:	b3 0b       	sbc	r27, r19
    56bc:	e4 0b       	sbc	r30, r20
    56be:	f5 0b       	sbc	r31, r21

000056c0 <__udivmodsi4_ep>:
    56c0:	66 1f       	adc	r22, r22
    56c2:	77 1f       	adc	r23, r23
    56c4:	88 1f       	adc	r24, r24
    56c6:	99 1f       	adc	r25, r25
    56c8:	1a 94       	dec	r1
    56ca:	69 f7       	brne	.-38     	; 0x56a6 <__udivmodsi4_loop>
    56cc:	60 95       	com	r22
    56ce:	70 95       	com	r23
    56d0:	80 95       	com	r24
    56d2:	90 95       	com	r25
    56d4:	9b 01       	movw	r18, r22
    56d6:	ac 01       	movw	r20, r24
    56d8:	bd 01       	movw	r22, r26
    56da:	cf 01       	movw	r24, r30
    56dc:	08 95       	ret

000056de <sprintf>:
    56de:	ae e0       	ldi	r26, 0x0E	; 14
    56e0:	b0 e0       	ldi	r27, 0x00	; 0
    56e2:	e5 e7       	ldi	r30, 0x75	; 117
    56e4:	fb e2       	ldi	r31, 0x2B	; 43
    56e6:	0c 94 1d 2e 	jmp	0x5c3a	; 0x5c3a <__prologue_saves__+0x1c>
    56ea:	0d 89       	ldd	r16, Y+21	; 0x15
    56ec:	1e 89       	ldd	r17, Y+22	; 0x16
    56ee:	86 e0       	ldi	r24, 0x06	; 6
    56f0:	8c 83       	std	Y+4, r24	; 0x04
    56f2:	1a 83       	std	Y+2, r17	; 0x02
    56f4:	09 83       	std	Y+1, r16	; 0x01
    56f6:	8f ef       	ldi	r24, 0xFF	; 255
    56f8:	9f e7       	ldi	r25, 0x7F	; 127
    56fa:	9e 83       	std	Y+6, r25	; 0x06
    56fc:	8d 83       	std	Y+5, r24	; 0x05
    56fe:	ae 01       	movw	r20, r28
    5700:	47 5e       	subi	r20, 0xE7	; 231
    5702:	5f 4f       	sbci	r21, 0xFF	; 255
    5704:	ce 01       	movw	r24, r28
    5706:	01 96       	adiw	r24, 0x01	; 1
    5708:	6f 89       	ldd	r22, Y+23	; 0x17
    570a:	78 8d       	ldd	r23, Y+24	; 0x18
    570c:	0e 94 91 2b 	call	0x5722	; 0x5722 <vfprintf>
    5710:	ef 81       	ldd	r30, Y+7	; 0x07
    5712:	f8 85       	ldd	r31, Y+8	; 0x08
    5714:	e0 0f       	add	r30, r16
    5716:	f1 1f       	adc	r31, r17
    5718:	10 82       	st	Z, r1
    571a:	2e 96       	adiw	r28, 0x0e	; 14
    571c:	e4 e0       	ldi	r30, 0x04	; 4
    571e:	0c 94 39 2e 	jmp	0x5c72	; 0x5c72 <__epilogue_restores__+0x1c>

00005722 <vfprintf>:
    5722:	ad e0       	ldi	r26, 0x0D	; 13
    5724:	b0 e0       	ldi	r27, 0x00	; 0
    5726:	e7 e9       	ldi	r30, 0x97	; 151
    5728:	fb e2       	ldi	r31, 0x2B	; 43
    572a:	0c 94 0f 2e 	jmp	0x5c1e	; 0x5c1e <__prologue_saves__>
    572e:	3c 01       	movw	r6, r24
    5730:	7d 87       	std	Y+13, r23	; 0x0d
    5732:	6c 87       	std	Y+12, r22	; 0x0c
    5734:	5a 01       	movw	r10, r20
    5736:	fc 01       	movw	r30, r24
    5738:	17 82       	std	Z+7, r1	; 0x07
    573a:	16 82       	std	Z+6, r1	; 0x06
    573c:	83 81       	ldd	r24, Z+3	; 0x03
    573e:	81 ff       	sbrs	r24, 1
    5740:	c8 c1       	rjmp	.+912    	; 0x5ad2 <vfprintf+0x3b0>
    5742:	2e 01       	movw	r4, r28
    5744:	08 94       	sec
    5746:	41 1c       	adc	r4, r1
    5748:	51 1c       	adc	r5, r1
    574a:	f3 01       	movw	r30, r6
    574c:	93 81       	ldd	r25, Z+3	; 0x03
    574e:	ec 85       	ldd	r30, Y+12	; 0x0c
    5750:	fd 85       	ldd	r31, Y+13	; 0x0d
    5752:	93 fd       	sbrc	r25, 3
    5754:	85 91       	lpm	r24, Z+
    5756:	93 ff       	sbrs	r25, 3
    5758:	81 91       	ld	r24, Z+
    575a:	fd 87       	std	Y+13, r31	; 0x0d
    575c:	ec 87       	std	Y+12, r30	; 0x0c
    575e:	88 23       	and	r24, r24
    5760:	09 f4       	brne	.+2      	; 0x5764 <vfprintf+0x42>
    5762:	b3 c1       	rjmp	.+870    	; 0x5aca <vfprintf+0x3a8>
    5764:	85 32       	cpi	r24, 0x25	; 37
    5766:	41 f4       	brne	.+16     	; 0x5778 <vfprintf+0x56>
    5768:	93 fd       	sbrc	r25, 3
    576a:	85 91       	lpm	r24, Z+
    576c:	93 ff       	sbrs	r25, 3
    576e:	81 91       	ld	r24, Z+
    5770:	fd 87       	std	Y+13, r31	; 0x0d
    5772:	ec 87       	std	Y+12, r30	; 0x0c
    5774:	85 32       	cpi	r24, 0x25	; 37
    5776:	29 f4       	brne	.+10     	; 0x5782 <vfprintf+0x60>
    5778:	90 e0       	ldi	r25, 0x00	; 0
    577a:	b3 01       	movw	r22, r6
    577c:	0e 94 85 2d 	call	0x5b0a	; 0x5b0a <fputc>
    5780:	e4 cf       	rjmp	.-56     	; 0x574a <vfprintf+0x28>
    5782:	ff 24       	eor	r15, r15
    5784:	ee 24       	eor	r14, r14
    5786:	10 e0       	ldi	r17, 0x00	; 0
    5788:	10 32       	cpi	r17, 0x20	; 32
    578a:	b0 f4       	brcc	.+44     	; 0x57b8 <vfprintf+0x96>
    578c:	8b 32       	cpi	r24, 0x2B	; 43
    578e:	69 f0       	breq	.+26     	; 0x57aa <vfprintf+0x88>
    5790:	8c 32       	cpi	r24, 0x2C	; 44
    5792:	28 f4       	brcc	.+10     	; 0x579e <vfprintf+0x7c>
    5794:	80 32       	cpi	r24, 0x20	; 32
    5796:	51 f0       	breq	.+20     	; 0x57ac <vfprintf+0x8a>
    5798:	83 32       	cpi	r24, 0x23	; 35
    579a:	71 f4       	brne	.+28     	; 0x57b8 <vfprintf+0x96>
    579c:	0b c0       	rjmp	.+22     	; 0x57b4 <vfprintf+0x92>
    579e:	8d 32       	cpi	r24, 0x2D	; 45
    57a0:	39 f0       	breq	.+14     	; 0x57b0 <vfprintf+0x8e>
    57a2:	80 33       	cpi	r24, 0x30	; 48
    57a4:	49 f4       	brne	.+18     	; 0x57b8 <vfprintf+0x96>
    57a6:	11 60       	ori	r17, 0x01	; 1
    57a8:	2c c0       	rjmp	.+88     	; 0x5802 <vfprintf+0xe0>
    57aa:	12 60       	ori	r17, 0x02	; 2
    57ac:	14 60       	ori	r17, 0x04	; 4
    57ae:	29 c0       	rjmp	.+82     	; 0x5802 <vfprintf+0xe0>
    57b0:	18 60       	ori	r17, 0x08	; 8
    57b2:	27 c0       	rjmp	.+78     	; 0x5802 <vfprintf+0xe0>
    57b4:	10 61       	ori	r17, 0x10	; 16
    57b6:	25 c0       	rjmp	.+74     	; 0x5802 <vfprintf+0xe0>
    57b8:	17 fd       	sbrc	r17, 7
    57ba:	2e c0       	rjmp	.+92     	; 0x5818 <vfprintf+0xf6>
    57bc:	28 2f       	mov	r18, r24
    57be:	20 53       	subi	r18, 0x30	; 48
    57c0:	2a 30       	cpi	r18, 0x0A	; 10
    57c2:	98 f4       	brcc	.+38     	; 0x57ea <vfprintf+0xc8>
    57c4:	16 ff       	sbrs	r17, 6
    57c6:	08 c0       	rjmp	.+16     	; 0x57d8 <vfprintf+0xb6>
    57c8:	8f 2d       	mov	r24, r15
    57ca:	88 0f       	add	r24, r24
    57cc:	f8 2e       	mov	r15, r24
    57ce:	ff 0c       	add	r15, r15
    57d0:	ff 0c       	add	r15, r15
    57d2:	f8 0e       	add	r15, r24
    57d4:	f2 0e       	add	r15, r18
    57d6:	15 c0       	rjmp	.+42     	; 0x5802 <vfprintf+0xe0>
    57d8:	8e 2d       	mov	r24, r14
    57da:	88 0f       	add	r24, r24
    57dc:	e8 2e       	mov	r14, r24
    57de:	ee 0c       	add	r14, r14
    57e0:	ee 0c       	add	r14, r14
    57e2:	e8 0e       	add	r14, r24
    57e4:	e2 0e       	add	r14, r18
    57e6:	10 62       	ori	r17, 0x20	; 32
    57e8:	0c c0       	rjmp	.+24     	; 0x5802 <vfprintf+0xe0>
    57ea:	8e 32       	cpi	r24, 0x2E	; 46
    57ec:	21 f4       	brne	.+8      	; 0x57f6 <vfprintf+0xd4>
    57ee:	16 fd       	sbrc	r17, 6
    57f0:	6c c1       	rjmp	.+728    	; 0x5aca <vfprintf+0x3a8>
    57f2:	10 64       	ori	r17, 0x40	; 64
    57f4:	06 c0       	rjmp	.+12     	; 0x5802 <vfprintf+0xe0>
    57f6:	8c 36       	cpi	r24, 0x6C	; 108
    57f8:	11 f4       	brne	.+4      	; 0x57fe <vfprintf+0xdc>
    57fa:	10 68       	ori	r17, 0x80	; 128
    57fc:	02 c0       	rjmp	.+4      	; 0x5802 <vfprintf+0xe0>
    57fe:	88 36       	cpi	r24, 0x68	; 104
    5800:	59 f4       	brne	.+22     	; 0x5818 <vfprintf+0xf6>
    5802:	ec 85       	ldd	r30, Y+12	; 0x0c
    5804:	fd 85       	ldd	r31, Y+13	; 0x0d
    5806:	93 fd       	sbrc	r25, 3
    5808:	85 91       	lpm	r24, Z+
    580a:	93 ff       	sbrs	r25, 3
    580c:	81 91       	ld	r24, Z+
    580e:	fd 87       	std	Y+13, r31	; 0x0d
    5810:	ec 87       	std	Y+12, r30	; 0x0c
    5812:	88 23       	and	r24, r24
    5814:	09 f0       	breq	.+2      	; 0x5818 <vfprintf+0xf6>
    5816:	b8 cf       	rjmp	.-144    	; 0x5788 <vfprintf+0x66>
    5818:	98 2f       	mov	r25, r24
    581a:	95 54       	subi	r25, 0x45	; 69
    581c:	93 30       	cpi	r25, 0x03	; 3
    581e:	18 f0       	brcs	.+6      	; 0x5826 <vfprintf+0x104>
    5820:	90 52       	subi	r25, 0x20	; 32
    5822:	93 30       	cpi	r25, 0x03	; 3
    5824:	38 f4       	brcc	.+14     	; 0x5834 <vfprintf+0x112>
    5826:	24 e0       	ldi	r18, 0x04	; 4
    5828:	30 e0       	ldi	r19, 0x00	; 0
    582a:	a2 0e       	add	r10, r18
    582c:	b3 1e       	adc	r11, r19
    582e:	3f e3       	ldi	r19, 0x3F	; 63
    5830:	39 83       	std	Y+1, r19	; 0x01
    5832:	0f c0       	rjmp	.+30     	; 0x5852 <vfprintf+0x130>
    5834:	83 36       	cpi	r24, 0x63	; 99
    5836:	31 f0       	breq	.+12     	; 0x5844 <vfprintf+0x122>
    5838:	83 37       	cpi	r24, 0x73	; 115
    583a:	81 f0       	breq	.+32     	; 0x585c <vfprintf+0x13a>
    583c:	83 35       	cpi	r24, 0x53	; 83
    583e:	09 f0       	breq	.+2      	; 0x5842 <vfprintf+0x120>
    5840:	5a c0       	rjmp	.+180    	; 0x58f6 <vfprintf+0x1d4>
    5842:	22 c0       	rjmp	.+68     	; 0x5888 <vfprintf+0x166>
    5844:	f5 01       	movw	r30, r10
    5846:	80 81       	ld	r24, Z
    5848:	89 83       	std	Y+1, r24	; 0x01
    584a:	22 e0       	ldi	r18, 0x02	; 2
    584c:	30 e0       	ldi	r19, 0x00	; 0
    584e:	a2 0e       	add	r10, r18
    5850:	b3 1e       	adc	r11, r19
    5852:	21 e0       	ldi	r18, 0x01	; 1
    5854:	c2 2e       	mov	r12, r18
    5856:	d1 2c       	mov	r13, r1
    5858:	42 01       	movw	r8, r4
    585a:	14 c0       	rjmp	.+40     	; 0x5884 <vfprintf+0x162>
    585c:	92 e0       	ldi	r25, 0x02	; 2
    585e:	29 2e       	mov	r2, r25
    5860:	31 2c       	mov	r3, r1
    5862:	2a 0c       	add	r2, r10
    5864:	3b 1c       	adc	r3, r11
    5866:	f5 01       	movw	r30, r10
    5868:	80 80       	ld	r8, Z
    586a:	91 80       	ldd	r9, Z+1	; 0x01
    586c:	16 ff       	sbrs	r17, 6
    586e:	03 c0       	rjmp	.+6      	; 0x5876 <vfprintf+0x154>
    5870:	6f 2d       	mov	r22, r15
    5872:	70 e0       	ldi	r23, 0x00	; 0
    5874:	02 c0       	rjmp	.+4      	; 0x587a <vfprintf+0x158>
    5876:	6f ef       	ldi	r22, 0xFF	; 255
    5878:	7f ef       	ldi	r23, 0xFF	; 255
    587a:	c4 01       	movw	r24, r8
    587c:	0e 94 7a 2d 	call	0x5af4	; 0x5af4 <strnlen>
    5880:	6c 01       	movw	r12, r24
    5882:	51 01       	movw	r10, r2
    5884:	1f 77       	andi	r17, 0x7F	; 127
    5886:	15 c0       	rjmp	.+42     	; 0x58b2 <vfprintf+0x190>
    5888:	82 e0       	ldi	r24, 0x02	; 2
    588a:	28 2e       	mov	r2, r24
    588c:	31 2c       	mov	r3, r1
    588e:	2a 0c       	add	r2, r10
    5890:	3b 1c       	adc	r3, r11
    5892:	f5 01       	movw	r30, r10
    5894:	80 80       	ld	r8, Z
    5896:	91 80       	ldd	r9, Z+1	; 0x01
    5898:	16 ff       	sbrs	r17, 6
    589a:	03 c0       	rjmp	.+6      	; 0x58a2 <vfprintf+0x180>
    589c:	6f 2d       	mov	r22, r15
    589e:	70 e0       	ldi	r23, 0x00	; 0
    58a0:	02 c0       	rjmp	.+4      	; 0x58a6 <vfprintf+0x184>
    58a2:	6f ef       	ldi	r22, 0xFF	; 255
    58a4:	7f ef       	ldi	r23, 0xFF	; 255
    58a6:	c4 01       	movw	r24, r8
    58a8:	0e 94 6f 2d 	call	0x5ade	; 0x5ade <strnlen_P>
    58ac:	6c 01       	movw	r12, r24
    58ae:	10 68       	ori	r17, 0x80	; 128
    58b0:	51 01       	movw	r10, r2
    58b2:	13 fd       	sbrc	r17, 3
    58b4:	1c c0       	rjmp	.+56     	; 0x58ee <vfprintf+0x1cc>
    58b6:	06 c0       	rjmp	.+12     	; 0x58c4 <vfprintf+0x1a2>
    58b8:	80 e2       	ldi	r24, 0x20	; 32
    58ba:	90 e0       	ldi	r25, 0x00	; 0
    58bc:	b3 01       	movw	r22, r6
    58be:	0e 94 85 2d 	call	0x5b0a	; 0x5b0a <fputc>
    58c2:	ea 94       	dec	r14
    58c4:	8e 2d       	mov	r24, r14
    58c6:	90 e0       	ldi	r25, 0x00	; 0
    58c8:	c8 16       	cp	r12, r24
    58ca:	d9 06       	cpc	r13, r25
    58cc:	a8 f3       	brcs	.-22     	; 0x58b8 <vfprintf+0x196>
    58ce:	0f c0       	rjmp	.+30     	; 0x58ee <vfprintf+0x1cc>
    58d0:	f4 01       	movw	r30, r8
    58d2:	17 fd       	sbrc	r17, 7
    58d4:	85 91       	lpm	r24, Z+
    58d6:	17 ff       	sbrs	r17, 7
    58d8:	81 91       	ld	r24, Z+
    58da:	4f 01       	movw	r8, r30
    58dc:	90 e0       	ldi	r25, 0x00	; 0
    58de:	b3 01       	movw	r22, r6
    58e0:	0e 94 85 2d 	call	0x5b0a	; 0x5b0a <fputc>
    58e4:	e1 10       	cpse	r14, r1
    58e6:	ea 94       	dec	r14
    58e8:	08 94       	sec
    58ea:	c1 08       	sbc	r12, r1
    58ec:	d1 08       	sbc	r13, r1
    58ee:	c1 14       	cp	r12, r1
    58f0:	d1 04       	cpc	r13, r1
    58f2:	71 f7       	brne	.-36     	; 0x58d0 <vfprintf+0x1ae>
    58f4:	e7 c0       	rjmp	.+462    	; 0x5ac4 <vfprintf+0x3a2>
    58f6:	84 36       	cpi	r24, 0x64	; 100
    58f8:	11 f0       	breq	.+4      	; 0x58fe <vfprintf+0x1dc>
    58fa:	89 36       	cpi	r24, 0x69	; 105
    58fc:	51 f5       	brne	.+84     	; 0x5952 <vfprintf+0x230>
    58fe:	f5 01       	movw	r30, r10
    5900:	17 ff       	sbrs	r17, 7
    5902:	07 c0       	rjmp	.+14     	; 0x5912 <vfprintf+0x1f0>
    5904:	80 81       	ld	r24, Z
    5906:	91 81       	ldd	r25, Z+1	; 0x01
    5908:	a2 81       	ldd	r26, Z+2	; 0x02
    590a:	b3 81       	ldd	r27, Z+3	; 0x03
    590c:	24 e0       	ldi	r18, 0x04	; 4
    590e:	30 e0       	ldi	r19, 0x00	; 0
    5910:	08 c0       	rjmp	.+16     	; 0x5922 <vfprintf+0x200>
    5912:	80 81       	ld	r24, Z
    5914:	91 81       	ldd	r25, Z+1	; 0x01
    5916:	aa 27       	eor	r26, r26
    5918:	97 fd       	sbrc	r25, 7
    591a:	a0 95       	com	r26
    591c:	ba 2f       	mov	r27, r26
    591e:	22 e0       	ldi	r18, 0x02	; 2
    5920:	30 e0       	ldi	r19, 0x00	; 0
    5922:	a2 0e       	add	r10, r18
    5924:	b3 1e       	adc	r11, r19
    5926:	01 2f       	mov	r16, r17
    5928:	0f 76       	andi	r16, 0x6F	; 111
    592a:	b7 ff       	sbrs	r27, 7
    592c:	08 c0       	rjmp	.+16     	; 0x593e <vfprintf+0x21c>
    592e:	b0 95       	com	r27
    5930:	a0 95       	com	r26
    5932:	90 95       	com	r25
    5934:	81 95       	neg	r24
    5936:	9f 4f       	sbci	r25, 0xFF	; 255
    5938:	af 4f       	sbci	r26, 0xFF	; 255
    593a:	bf 4f       	sbci	r27, 0xFF	; 255
    593c:	00 68       	ori	r16, 0x80	; 128
    593e:	bc 01       	movw	r22, r24
    5940:	cd 01       	movw	r24, r26
    5942:	a2 01       	movw	r20, r4
    5944:	2a e0       	ldi	r18, 0x0A	; 10
    5946:	30 e0       	ldi	r19, 0x00	; 0
    5948:	0e 94 b1 2d 	call	0x5b62	; 0x5b62 <__ultoa_invert>
    594c:	d8 2e       	mov	r13, r24
    594e:	d4 18       	sub	r13, r4
    5950:	3f c0       	rjmp	.+126    	; 0x59d0 <vfprintf+0x2ae>
    5952:	85 37       	cpi	r24, 0x75	; 117
    5954:	21 f4       	brne	.+8      	; 0x595e <vfprintf+0x23c>
    5956:	1f 7e       	andi	r17, 0xEF	; 239
    5958:	2a e0       	ldi	r18, 0x0A	; 10
    595a:	30 e0       	ldi	r19, 0x00	; 0
    595c:	20 c0       	rjmp	.+64     	; 0x599e <vfprintf+0x27c>
    595e:	19 7f       	andi	r17, 0xF9	; 249
    5960:	8f 36       	cpi	r24, 0x6F	; 111
    5962:	a9 f0       	breq	.+42     	; 0x598e <vfprintf+0x26c>
    5964:	80 37       	cpi	r24, 0x70	; 112
    5966:	20 f4       	brcc	.+8      	; 0x5970 <vfprintf+0x24e>
    5968:	88 35       	cpi	r24, 0x58	; 88
    596a:	09 f0       	breq	.+2      	; 0x596e <vfprintf+0x24c>
    596c:	ae c0       	rjmp	.+348    	; 0x5aca <vfprintf+0x3a8>
    596e:	0b c0       	rjmp	.+22     	; 0x5986 <vfprintf+0x264>
    5970:	80 37       	cpi	r24, 0x70	; 112
    5972:	21 f0       	breq	.+8      	; 0x597c <vfprintf+0x25a>
    5974:	88 37       	cpi	r24, 0x78	; 120
    5976:	09 f0       	breq	.+2      	; 0x597a <vfprintf+0x258>
    5978:	a8 c0       	rjmp	.+336    	; 0x5aca <vfprintf+0x3a8>
    597a:	01 c0       	rjmp	.+2      	; 0x597e <vfprintf+0x25c>
    597c:	10 61       	ori	r17, 0x10	; 16
    597e:	14 ff       	sbrs	r17, 4
    5980:	09 c0       	rjmp	.+18     	; 0x5994 <vfprintf+0x272>
    5982:	14 60       	ori	r17, 0x04	; 4
    5984:	07 c0       	rjmp	.+14     	; 0x5994 <vfprintf+0x272>
    5986:	14 ff       	sbrs	r17, 4
    5988:	08 c0       	rjmp	.+16     	; 0x599a <vfprintf+0x278>
    598a:	16 60       	ori	r17, 0x06	; 6
    598c:	06 c0       	rjmp	.+12     	; 0x599a <vfprintf+0x278>
    598e:	28 e0       	ldi	r18, 0x08	; 8
    5990:	30 e0       	ldi	r19, 0x00	; 0
    5992:	05 c0       	rjmp	.+10     	; 0x599e <vfprintf+0x27c>
    5994:	20 e1       	ldi	r18, 0x10	; 16
    5996:	30 e0       	ldi	r19, 0x00	; 0
    5998:	02 c0       	rjmp	.+4      	; 0x599e <vfprintf+0x27c>
    599a:	20 e1       	ldi	r18, 0x10	; 16
    599c:	32 e0       	ldi	r19, 0x02	; 2
    599e:	f5 01       	movw	r30, r10
    59a0:	17 ff       	sbrs	r17, 7
    59a2:	07 c0       	rjmp	.+14     	; 0x59b2 <vfprintf+0x290>
    59a4:	60 81       	ld	r22, Z
    59a6:	71 81       	ldd	r23, Z+1	; 0x01
    59a8:	82 81       	ldd	r24, Z+2	; 0x02
    59aa:	93 81       	ldd	r25, Z+3	; 0x03
    59ac:	44 e0       	ldi	r20, 0x04	; 4
    59ae:	50 e0       	ldi	r21, 0x00	; 0
    59b0:	06 c0       	rjmp	.+12     	; 0x59be <vfprintf+0x29c>
    59b2:	60 81       	ld	r22, Z
    59b4:	71 81       	ldd	r23, Z+1	; 0x01
    59b6:	80 e0       	ldi	r24, 0x00	; 0
    59b8:	90 e0       	ldi	r25, 0x00	; 0
    59ba:	42 e0       	ldi	r20, 0x02	; 2
    59bc:	50 e0       	ldi	r21, 0x00	; 0
    59be:	a4 0e       	add	r10, r20
    59c0:	b5 1e       	adc	r11, r21
    59c2:	a2 01       	movw	r20, r4
    59c4:	0e 94 b1 2d 	call	0x5b62	; 0x5b62 <__ultoa_invert>
    59c8:	d8 2e       	mov	r13, r24
    59ca:	d4 18       	sub	r13, r4
    59cc:	01 2f       	mov	r16, r17
    59ce:	0f 77       	andi	r16, 0x7F	; 127
    59d0:	06 ff       	sbrs	r16, 6
    59d2:	09 c0       	rjmp	.+18     	; 0x59e6 <vfprintf+0x2c4>
    59d4:	0e 7f       	andi	r16, 0xFE	; 254
    59d6:	df 14       	cp	r13, r15
    59d8:	30 f4       	brcc	.+12     	; 0x59e6 <vfprintf+0x2c4>
    59da:	04 ff       	sbrs	r16, 4
    59dc:	06 c0       	rjmp	.+12     	; 0x59ea <vfprintf+0x2c8>
    59de:	02 fd       	sbrc	r16, 2
    59e0:	04 c0       	rjmp	.+8      	; 0x59ea <vfprintf+0x2c8>
    59e2:	0f 7e       	andi	r16, 0xEF	; 239
    59e4:	02 c0       	rjmp	.+4      	; 0x59ea <vfprintf+0x2c8>
    59e6:	1d 2d       	mov	r17, r13
    59e8:	01 c0       	rjmp	.+2      	; 0x59ec <vfprintf+0x2ca>
    59ea:	1f 2d       	mov	r17, r15
    59ec:	80 2f       	mov	r24, r16
    59ee:	90 e0       	ldi	r25, 0x00	; 0
    59f0:	04 ff       	sbrs	r16, 4
    59f2:	0c c0       	rjmp	.+24     	; 0x5a0c <vfprintf+0x2ea>
    59f4:	fe 01       	movw	r30, r28
    59f6:	ed 0d       	add	r30, r13
    59f8:	f1 1d       	adc	r31, r1
    59fa:	20 81       	ld	r18, Z
    59fc:	20 33       	cpi	r18, 0x30	; 48
    59fe:	11 f4       	brne	.+4      	; 0x5a04 <vfprintf+0x2e2>
    5a00:	09 7e       	andi	r16, 0xE9	; 233
    5a02:	09 c0       	rjmp	.+18     	; 0x5a16 <vfprintf+0x2f4>
    5a04:	02 ff       	sbrs	r16, 2
    5a06:	06 c0       	rjmp	.+12     	; 0x5a14 <vfprintf+0x2f2>
    5a08:	1e 5f       	subi	r17, 0xFE	; 254
    5a0a:	05 c0       	rjmp	.+10     	; 0x5a16 <vfprintf+0x2f4>
    5a0c:	86 78       	andi	r24, 0x86	; 134
    5a0e:	90 70       	andi	r25, 0x00	; 0
    5a10:	00 97       	sbiw	r24, 0x00	; 0
    5a12:	09 f0       	breq	.+2      	; 0x5a16 <vfprintf+0x2f4>
    5a14:	1f 5f       	subi	r17, 0xFF	; 255
    5a16:	80 2e       	mov	r8, r16
    5a18:	99 24       	eor	r9, r9
    5a1a:	03 fd       	sbrc	r16, 3
    5a1c:	12 c0       	rjmp	.+36     	; 0x5a42 <vfprintf+0x320>
    5a1e:	00 ff       	sbrs	r16, 0
    5a20:	0d c0       	rjmp	.+26     	; 0x5a3c <vfprintf+0x31a>
    5a22:	fd 2c       	mov	r15, r13
    5a24:	1e 15       	cp	r17, r14
    5a26:	50 f4       	brcc	.+20     	; 0x5a3c <vfprintf+0x31a>
    5a28:	fe 0c       	add	r15, r14
    5a2a:	f1 1a       	sub	r15, r17
    5a2c:	1e 2d       	mov	r17, r14
    5a2e:	06 c0       	rjmp	.+12     	; 0x5a3c <vfprintf+0x31a>
    5a30:	80 e2       	ldi	r24, 0x20	; 32
    5a32:	90 e0       	ldi	r25, 0x00	; 0
    5a34:	b3 01       	movw	r22, r6
    5a36:	0e 94 85 2d 	call	0x5b0a	; 0x5b0a <fputc>
    5a3a:	1f 5f       	subi	r17, 0xFF	; 255
    5a3c:	1e 15       	cp	r17, r14
    5a3e:	c0 f3       	brcs	.-16     	; 0x5a30 <vfprintf+0x30e>
    5a40:	04 c0       	rjmp	.+8      	; 0x5a4a <vfprintf+0x328>
    5a42:	1e 15       	cp	r17, r14
    5a44:	10 f4       	brcc	.+4      	; 0x5a4a <vfprintf+0x328>
    5a46:	e1 1a       	sub	r14, r17
    5a48:	01 c0       	rjmp	.+2      	; 0x5a4c <vfprintf+0x32a>
    5a4a:	ee 24       	eor	r14, r14
    5a4c:	84 fe       	sbrs	r8, 4
    5a4e:	0f c0       	rjmp	.+30     	; 0x5a6e <vfprintf+0x34c>
    5a50:	80 e3       	ldi	r24, 0x30	; 48
    5a52:	90 e0       	ldi	r25, 0x00	; 0
    5a54:	b3 01       	movw	r22, r6
    5a56:	0e 94 85 2d 	call	0x5b0a	; 0x5b0a <fputc>
    5a5a:	82 fe       	sbrs	r8, 2
    5a5c:	1f c0       	rjmp	.+62     	; 0x5a9c <vfprintf+0x37a>
    5a5e:	81 fe       	sbrs	r8, 1
    5a60:	03 c0       	rjmp	.+6      	; 0x5a68 <vfprintf+0x346>
    5a62:	88 e5       	ldi	r24, 0x58	; 88
    5a64:	90 e0       	ldi	r25, 0x00	; 0
    5a66:	10 c0       	rjmp	.+32     	; 0x5a88 <vfprintf+0x366>
    5a68:	88 e7       	ldi	r24, 0x78	; 120
    5a6a:	90 e0       	ldi	r25, 0x00	; 0
    5a6c:	0d c0       	rjmp	.+26     	; 0x5a88 <vfprintf+0x366>
    5a6e:	c4 01       	movw	r24, r8
    5a70:	86 78       	andi	r24, 0x86	; 134
    5a72:	90 70       	andi	r25, 0x00	; 0
    5a74:	00 97       	sbiw	r24, 0x00	; 0
    5a76:	91 f0       	breq	.+36     	; 0x5a9c <vfprintf+0x37a>
    5a78:	81 fc       	sbrc	r8, 1
    5a7a:	02 c0       	rjmp	.+4      	; 0x5a80 <vfprintf+0x35e>
    5a7c:	80 e2       	ldi	r24, 0x20	; 32
    5a7e:	01 c0       	rjmp	.+2      	; 0x5a82 <vfprintf+0x360>
    5a80:	8b e2       	ldi	r24, 0x2B	; 43
    5a82:	07 fd       	sbrc	r16, 7
    5a84:	8d e2       	ldi	r24, 0x2D	; 45
    5a86:	90 e0       	ldi	r25, 0x00	; 0
    5a88:	b3 01       	movw	r22, r6
    5a8a:	0e 94 85 2d 	call	0x5b0a	; 0x5b0a <fputc>
    5a8e:	06 c0       	rjmp	.+12     	; 0x5a9c <vfprintf+0x37a>
    5a90:	80 e3       	ldi	r24, 0x30	; 48
    5a92:	90 e0       	ldi	r25, 0x00	; 0
    5a94:	b3 01       	movw	r22, r6
    5a96:	0e 94 85 2d 	call	0x5b0a	; 0x5b0a <fputc>
    5a9a:	fa 94       	dec	r15
    5a9c:	df 14       	cp	r13, r15
    5a9e:	c0 f3       	brcs	.-16     	; 0x5a90 <vfprintf+0x36e>
    5aa0:	da 94       	dec	r13
    5aa2:	f2 01       	movw	r30, r4
    5aa4:	ed 0d       	add	r30, r13
    5aa6:	f1 1d       	adc	r31, r1
    5aa8:	80 81       	ld	r24, Z
    5aaa:	90 e0       	ldi	r25, 0x00	; 0
    5aac:	b3 01       	movw	r22, r6
    5aae:	0e 94 85 2d 	call	0x5b0a	; 0x5b0a <fputc>
    5ab2:	dd 20       	and	r13, r13
    5ab4:	a9 f7       	brne	.-22     	; 0x5aa0 <vfprintf+0x37e>
    5ab6:	06 c0       	rjmp	.+12     	; 0x5ac4 <vfprintf+0x3a2>
    5ab8:	80 e2       	ldi	r24, 0x20	; 32
    5aba:	90 e0       	ldi	r25, 0x00	; 0
    5abc:	b3 01       	movw	r22, r6
    5abe:	0e 94 85 2d 	call	0x5b0a	; 0x5b0a <fputc>
    5ac2:	ea 94       	dec	r14
    5ac4:	ee 20       	and	r14, r14
    5ac6:	c1 f7       	brne	.-16     	; 0x5ab8 <vfprintf+0x396>
    5ac8:	40 ce       	rjmp	.-896    	; 0x574a <vfprintf+0x28>
    5aca:	f3 01       	movw	r30, r6
    5acc:	86 81       	ldd	r24, Z+6	; 0x06
    5ace:	97 81       	ldd	r25, Z+7	; 0x07
    5ad0:	02 c0       	rjmp	.+4      	; 0x5ad6 <vfprintf+0x3b4>
    5ad2:	8f ef       	ldi	r24, 0xFF	; 255
    5ad4:	9f ef       	ldi	r25, 0xFF	; 255
    5ad6:	2d 96       	adiw	r28, 0x0d	; 13
    5ad8:	e2 e1       	ldi	r30, 0x12	; 18
    5ada:	0c 94 2b 2e 	jmp	0x5c56	; 0x5c56 <__epilogue_restores__>

00005ade <strnlen_P>:
    5ade:	fc 01       	movw	r30, r24
    5ae0:	05 90       	lpm	r0, Z+
    5ae2:	61 50       	subi	r22, 0x01	; 1
    5ae4:	70 40       	sbci	r23, 0x00	; 0
    5ae6:	01 10       	cpse	r0, r1
    5ae8:	d8 f7       	brcc	.-10     	; 0x5ae0 <strnlen_P+0x2>
    5aea:	80 95       	com	r24
    5aec:	90 95       	com	r25
    5aee:	8e 0f       	add	r24, r30
    5af0:	9f 1f       	adc	r25, r31
    5af2:	08 95       	ret

00005af4 <strnlen>:
    5af4:	fc 01       	movw	r30, r24
    5af6:	61 50       	subi	r22, 0x01	; 1
    5af8:	70 40       	sbci	r23, 0x00	; 0
    5afa:	01 90       	ld	r0, Z+
    5afc:	01 10       	cpse	r0, r1
    5afe:	d8 f7       	brcc	.-10     	; 0x5af6 <strnlen+0x2>
    5b00:	80 95       	com	r24
    5b02:	90 95       	com	r25
    5b04:	8e 0f       	add	r24, r30
    5b06:	9f 1f       	adc	r25, r31
    5b08:	08 95       	ret

00005b0a <fputc>:
    5b0a:	0f 93       	push	r16
    5b0c:	1f 93       	push	r17
    5b0e:	cf 93       	push	r28
    5b10:	df 93       	push	r29
    5b12:	8c 01       	movw	r16, r24
    5b14:	eb 01       	movw	r28, r22
    5b16:	8b 81       	ldd	r24, Y+3	; 0x03
    5b18:	81 ff       	sbrs	r24, 1
    5b1a:	1b c0       	rjmp	.+54     	; 0x5b52 <fputc+0x48>
    5b1c:	82 ff       	sbrs	r24, 2
    5b1e:	0d c0       	rjmp	.+26     	; 0x5b3a <fputc+0x30>
    5b20:	2e 81       	ldd	r18, Y+6	; 0x06
    5b22:	3f 81       	ldd	r19, Y+7	; 0x07
    5b24:	8c 81       	ldd	r24, Y+4	; 0x04
    5b26:	9d 81       	ldd	r25, Y+5	; 0x05
    5b28:	28 17       	cp	r18, r24
    5b2a:	39 07       	cpc	r19, r25
    5b2c:	64 f4       	brge	.+24     	; 0x5b46 <fputc+0x3c>
    5b2e:	e8 81       	ld	r30, Y
    5b30:	f9 81       	ldd	r31, Y+1	; 0x01
    5b32:	01 93       	st	Z+, r16
    5b34:	f9 83       	std	Y+1, r31	; 0x01
    5b36:	e8 83       	st	Y, r30
    5b38:	06 c0       	rjmp	.+12     	; 0x5b46 <fputc+0x3c>
    5b3a:	e8 85       	ldd	r30, Y+8	; 0x08
    5b3c:	f9 85       	ldd	r31, Y+9	; 0x09
    5b3e:	80 2f       	mov	r24, r16
    5b40:	09 95       	icall
    5b42:	00 97       	sbiw	r24, 0x00	; 0
    5b44:	31 f4       	brne	.+12     	; 0x5b52 <fputc+0x48>
    5b46:	8e 81       	ldd	r24, Y+6	; 0x06
    5b48:	9f 81       	ldd	r25, Y+7	; 0x07
    5b4a:	01 96       	adiw	r24, 0x01	; 1
    5b4c:	9f 83       	std	Y+7, r25	; 0x07
    5b4e:	8e 83       	std	Y+6, r24	; 0x06
    5b50:	02 c0       	rjmp	.+4      	; 0x5b56 <fputc+0x4c>
    5b52:	0f ef       	ldi	r16, 0xFF	; 255
    5b54:	1f ef       	ldi	r17, 0xFF	; 255
    5b56:	c8 01       	movw	r24, r16
    5b58:	df 91       	pop	r29
    5b5a:	cf 91       	pop	r28
    5b5c:	1f 91       	pop	r17
    5b5e:	0f 91       	pop	r16
    5b60:	08 95       	ret

00005b62 <__ultoa_invert>:
    5b62:	fa 01       	movw	r30, r20
    5b64:	aa 27       	eor	r26, r26
    5b66:	28 30       	cpi	r18, 0x08	; 8
    5b68:	51 f1       	breq	.+84     	; 0x5bbe <__ultoa_invert+0x5c>
    5b6a:	20 31       	cpi	r18, 0x10	; 16
    5b6c:	81 f1       	breq	.+96     	; 0x5bce <__ultoa_invert+0x6c>
    5b6e:	e8 94       	clt
    5b70:	6f 93       	push	r22
    5b72:	6e 7f       	andi	r22, 0xFE	; 254
    5b74:	6e 5f       	subi	r22, 0xFE	; 254
    5b76:	7f 4f       	sbci	r23, 0xFF	; 255
    5b78:	8f 4f       	sbci	r24, 0xFF	; 255
    5b7a:	9f 4f       	sbci	r25, 0xFF	; 255
    5b7c:	af 4f       	sbci	r26, 0xFF	; 255
    5b7e:	b1 e0       	ldi	r27, 0x01	; 1
    5b80:	3e d0       	rcall	.+124    	; 0x5bfe <__ultoa_invert+0x9c>
    5b82:	b4 e0       	ldi	r27, 0x04	; 4
    5b84:	3c d0       	rcall	.+120    	; 0x5bfe <__ultoa_invert+0x9c>
    5b86:	67 0f       	add	r22, r23
    5b88:	78 1f       	adc	r23, r24
    5b8a:	89 1f       	adc	r24, r25
    5b8c:	9a 1f       	adc	r25, r26
    5b8e:	a1 1d       	adc	r26, r1
    5b90:	68 0f       	add	r22, r24
    5b92:	79 1f       	adc	r23, r25
    5b94:	8a 1f       	adc	r24, r26
    5b96:	91 1d       	adc	r25, r1
    5b98:	a1 1d       	adc	r26, r1
    5b9a:	6a 0f       	add	r22, r26
    5b9c:	71 1d       	adc	r23, r1
    5b9e:	81 1d       	adc	r24, r1
    5ba0:	91 1d       	adc	r25, r1
    5ba2:	a1 1d       	adc	r26, r1
    5ba4:	20 d0       	rcall	.+64     	; 0x5be6 <__ultoa_invert+0x84>
    5ba6:	09 f4       	brne	.+2      	; 0x5baa <__ultoa_invert+0x48>
    5ba8:	68 94       	set
    5baa:	3f 91       	pop	r19
    5bac:	2a e0       	ldi	r18, 0x0A	; 10
    5bae:	26 9f       	mul	r18, r22
    5bb0:	11 24       	eor	r1, r1
    5bb2:	30 19       	sub	r19, r0
    5bb4:	30 5d       	subi	r19, 0xD0	; 208
    5bb6:	31 93       	st	Z+, r19
    5bb8:	de f6       	brtc	.-74     	; 0x5b70 <__ultoa_invert+0xe>
    5bba:	cf 01       	movw	r24, r30
    5bbc:	08 95       	ret
    5bbe:	46 2f       	mov	r20, r22
    5bc0:	47 70       	andi	r20, 0x07	; 7
    5bc2:	40 5d       	subi	r20, 0xD0	; 208
    5bc4:	41 93       	st	Z+, r20
    5bc6:	b3 e0       	ldi	r27, 0x03	; 3
    5bc8:	0f d0       	rcall	.+30     	; 0x5be8 <__ultoa_invert+0x86>
    5bca:	c9 f7       	brne	.-14     	; 0x5bbe <__ultoa_invert+0x5c>
    5bcc:	f6 cf       	rjmp	.-20     	; 0x5bba <__ultoa_invert+0x58>
    5bce:	46 2f       	mov	r20, r22
    5bd0:	4f 70       	andi	r20, 0x0F	; 15
    5bd2:	40 5d       	subi	r20, 0xD0	; 208
    5bd4:	4a 33       	cpi	r20, 0x3A	; 58
    5bd6:	18 f0       	brcs	.+6      	; 0x5bde <__ultoa_invert+0x7c>
    5bd8:	49 5d       	subi	r20, 0xD9	; 217
    5bda:	31 fd       	sbrc	r19, 1
    5bdc:	40 52       	subi	r20, 0x20	; 32
    5bde:	41 93       	st	Z+, r20
    5be0:	02 d0       	rcall	.+4      	; 0x5be6 <__ultoa_invert+0x84>
    5be2:	a9 f7       	brne	.-22     	; 0x5bce <__ultoa_invert+0x6c>
    5be4:	ea cf       	rjmp	.-44     	; 0x5bba <__ultoa_invert+0x58>
    5be6:	b4 e0       	ldi	r27, 0x04	; 4
    5be8:	a6 95       	lsr	r26
    5bea:	97 95       	ror	r25
    5bec:	87 95       	ror	r24
    5bee:	77 95       	ror	r23
    5bf0:	67 95       	ror	r22
    5bf2:	ba 95       	dec	r27
    5bf4:	c9 f7       	brne	.-14     	; 0x5be8 <__ultoa_invert+0x86>
    5bf6:	00 97       	sbiw	r24, 0x00	; 0
    5bf8:	61 05       	cpc	r22, r1
    5bfa:	71 05       	cpc	r23, r1
    5bfc:	08 95       	ret
    5bfe:	9b 01       	movw	r18, r22
    5c00:	ac 01       	movw	r20, r24
    5c02:	0a 2e       	mov	r0, r26
    5c04:	06 94       	lsr	r0
    5c06:	57 95       	ror	r21
    5c08:	47 95       	ror	r20
    5c0a:	37 95       	ror	r19
    5c0c:	27 95       	ror	r18
    5c0e:	ba 95       	dec	r27
    5c10:	c9 f7       	brne	.-14     	; 0x5c04 <__ultoa_invert+0xa2>
    5c12:	62 0f       	add	r22, r18
    5c14:	73 1f       	adc	r23, r19
    5c16:	84 1f       	adc	r24, r20
    5c18:	95 1f       	adc	r25, r21
    5c1a:	a0 1d       	adc	r26, r0
    5c1c:	08 95       	ret

00005c1e <__prologue_saves__>:
    5c1e:	2f 92       	push	r2
    5c20:	3f 92       	push	r3
    5c22:	4f 92       	push	r4
    5c24:	5f 92       	push	r5
    5c26:	6f 92       	push	r6
    5c28:	7f 92       	push	r7
    5c2a:	8f 92       	push	r8
    5c2c:	9f 92       	push	r9
    5c2e:	af 92       	push	r10
    5c30:	bf 92       	push	r11
    5c32:	cf 92       	push	r12
    5c34:	df 92       	push	r13
    5c36:	ef 92       	push	r14
    5c38:	ff 92       	push	r15
    5c3a:	0f 93       	push	r16
    5c3c:	1f 93       	push	r17
    5c3e:	cf 93       	push	r28
    5c40:	df 93       	push	r29
    5c42:	cd b7       	in	r28, 0x3d	; 61
    5c44:	de b7       	in	r29, 0x3e	; 62
    5c46:	ca 1b       	sub	r28, r26
    5c48:	db 0b       	sbc	r29, r27
    5c4a:	0f b6       	in	r0, 0x3f	; 63
    5c4c:	f8 94       	cli
    5c4e:	de bf       	out	0x3e, r29	; 62
    5c50:	0f be       	out	0x3f, r0	; 63
    5c52:	cd bf       	out	0x3d, r28	; 61
    5c54:	09 94       	ijmp

00005c56 <__epilogue_restores__>:
    5c56:	2a 88       	ldd	r2, Y+18	; 0x12
    5c58:	39 88       	ldd	r3, Y+17	; 0x11
    5c5a:	48 88       	ldd	r4, Y+16	; 0x10
    5c5c:	5f 84       	ldd	r5, Y+15	; 0x0f
    5c5e:	6e 84       	ldd	r6, Y+14	; 0x0e
    5c60:	7d 84       	ldd	r7, Y+13	; 0x0d
    5c62:	8c 84       	ldd	r8, Y+12	; 0x0c
    5c64:	9b 84       	ldd	r9, Y+11	; 0x0b
    5c66:	aa 84       	ldd	r10, Y+10	; 0x0a
    5c68:	b9 84       	ldd	r11, Y+9	; 0x09
    5c6a:	c8 84       	ldd	r12, Y+8	; 0x08
    5c6c:	df 80       	ldd	r13, Y+7	; 0x07
    5c6e:	ee 80       	ldd	r14, Y+6	; 0x06
    5c70:	fd 80       	ldd	r15, Y+5	; 0x05
    5c72:	0c 81       	ldd	r16, Y+4	; 0x04
    5c74:	1b 81       	ldd	r17, Y+3	; 0x03
    5c76:	aa 81       	ldd	r26, Y+2	; 0x02
    5c78:	b9 81       	ldd	r27, Y+1	; 0x01
    5c7a:	ce 0f       	add	r28, r30
    5c7c:	d1 1d       	adc	r29, r1
    5c7e:	0f b6       	in	r0, 0x3f	; 63
    5c80:	f8 94       	cli
    5c82:	de bf       	out	0x3e, r29	; 62
    5c84:	0f be       	out	0x3f, r0	; 63
    5c86:	cd bf       	out	0x3d, r28	; 61
    5c88:	ed 01       	movw	r28, r26
    5c8a:	08 95       	ret

00005c8c <_exit>:
    5c8c:	f8 94       	cli

00005c8e <__stop_program>:
    5c8e:	ff cf       	rjmp	.-2      	; 0x5c8e <__stop_program>
