
DualOV7670.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000384  00800100  000058dc  00005970  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000058dc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000703  00800484  00800484  00005cf4  2**0
                  ALLOC
  3 .stab         00000c84  00000000  00000000  00005cf4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001b6  00000000  00000000  00006978  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000260  00000000  00000000  00006b30  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004e09  00000000  00000000  00006d90  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000013e8  00000000  00000000  0000bb99  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001f79  00000000  00000000  0000cf81  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001020  00000000  00000000  0000eefc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000b8c  00000000  00000000  0000ff1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000067fd  00000000  00000000  00010aa8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000128  00000000  00000000  000172a5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 02 26 	jmp	0x4c04	; 0x4c04 <__vector_1>
       8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 7c 05 	jmp	0xaf8	; 0xaf8 <__vector_16>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 4a 28 	jmp	0x5094	; 0x5094 <__vector_26>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d0 e1       	ldi	r29, 0x10	; 16
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	14 e0       	ldi	r17, 0x04	; 4
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	ec ed       	ldi	r30, 0xDC	; 220
      90:	f8 e5       	ldi	r31, 0x58	; 88
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	a4 38       	cpi	r26, 0x84	; 132
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	1b e0       	ldi	r17, 0x0B	; 11
      a0:	a4 e8       	ldi	r26, 0x84	; 132
      a2:	b4 e0       	ldi	r27, 0x04	; 4
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	a7 38       	cpi	r26, 0x87	; 135
      aa:	b1 07       	cpc	r27, r17
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 a0 05 	call	0xb40	; 0xb40 <main>
      b2:	0c 94 6c 2c 	jmp	0x58d8	; 0x58d8 <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <WriteBMPHeader>:
										};



FRESULT WriteBMPHeader(FIL *File)
{
      ba:	0f 93       	push	r16
      bc:	1f 93       	push	r17
      be:	cf 93       	push	r28
      c0:	df 93       	push	r29
      c2:	00 d0       	rcall	.+0      	; 0xc4 <WriteBMPHeader+0xa>
      c4:	00 d0       	rcall	.+0      	; 0xc6 <WriteBMPHeader+0xc>
      c6:	cd b7       	in	r28, 0x3d	; 61
      c8:	de b7       	in	r29, 0x3e	; 62
      ca:	8c 01       	movw	r16, r24
	uint32_t p;
	FRESULT f; 
	
	f_lseek(File, 0);
      cc:	40 e0       	ldi	r20, 0x00	; 0
      ce:	50 e0       	ldi	r21, 0x00	; 0
      d0:	ba 01       	movw	r22, r20
      d2:	0e 94 73 1d 	call	0x3ae6	; 0x3ae6 <f_lseek>
	f = f_write(File, BMPHeader, BMPHEADERSIZE, &p);
      d6:	c8 01       	movw	r24, r16
      d8:	60 e0       	ldi	r22, 0x00	; 0
      da:	71 e0       	ldi	r23, 0x01	; 1
      dc:	2e e0       	ldi	r18, 0x0E	; 14
      de:	30 e0       	ldi	r19, 0x00	; 0
      e0:	40 e0       	ldi	r20, 0x00	; 0
      e2:	50 e0       	ldi	r21, 0x00	; 0
      e4:	8e 01       	movw	r16, r28
      e6:	0f 5f       	subi	r16, 0xFF	; 255
      e8:	1f 4f       	sbci	r17, 0xFF	; 255
      ea:	0e 94 4e 1a 	call	0x349c	; 0x349c <f_write>
	
	return f;
}
      ee:	0f 90       	pop	r0
      f0:	0f 90       	pop	r0
      f2:	0f 90       	pop	r0
      f4:	0f 90       	pop	r0
      f6:	df 91       	pop	r29
      f8:	cf 91       	pop	r28
      fa:	1f 91       	pop	r17
      fc:	0f 91       	pop	r16
      fe:	08 95       	ret

00000100 <WriteDIBHeader>:

FRESULT WriteDIBHeader(FIL *File)
{
     100:	0f 93       	push	r16
     102:	1f 93       	push	r17
     104:	cf 93       	push	r28
     106:	df 93       	push	r29
     108:	00 d0       	rcall	.+0      	; 0x10a <WriteDIBHeader+0xa>
     10a:	00 d0       	rcall	.+0      	; 0x10c <WriteDIBHeader+0xc>
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
     110:	8c 01       	movw	r16, r24
	uint32_t p;
	FRESULT f;
	
	f_lseek(File, BMPHEADERSIZE);//place just after the bitmap header
     112:	4e e0       	ldi	r20, 0x0E	; 14
     114:	50 e0       	ldi	r21, 0x00	; 0
     116:	60 e0       	ldi	r22, 0x00	; 0
     118:	70 e0       	ldi	r23, 0x00	; 0
     11a:	0e 94 73 1d 	call	0x3ae6	; 0x3ae6 <f_lseek>
	f = f_write(File, DIBHead, DIBHEADERSIZE, &p);
     11e:	c8 01       	movw	r24, r16
     120:	6e e0       	ldi	r22, 0x0E	; 14
     122:	71 e0       	ldi	r23, 0x01	; 1
     124:	2c e7       	ldi	r18, 0x7C	; 124
     126:	30 e0       	ldi	r19, 0x00	; 0
     128:	40 e0       	ldi	r20, 0x00	; 0
     12a:	50 e0       	ldi	r21, 0x00	; 0
     12c:	8e 01       	movw	r16, r28
     12e:	0f 5f       	subi	r16, 0xFF	; 255
     130:	1f 4f       	sbci	r17, 0xFF	; 255
     132:	0e 94 4e 1a 	call	0x349c	; 0x349c <f_write>
	return f;
}
     136:	0f 90       	pop	r0
     138:	0f 90       	pop	r0
     13a:	0f 90       	pop	r0
     13c:	0f 90       	pop	r0
     13e:	df 91       	pop	r29
     140:	cf 91       	pop	r28
     142:	1f 91       	pop	r17
     144:	0f 91       	pop	r16
     146:	08 95       	ret

00000148 <IO_Init>:
#include "Config.h"
#include <avr/io.h>
void IO_Init(void)
{
	//initialise timer 0 to interrupt every 10 ms
	TIMSK0 |= (1 << OCIE0A);
     148:	ee e6       	ldi	r30, 0x6E	; 110
     14a:	f0 e0       	ldi	r31, 0x00	; 0
     14c:	80 81       	ld	r24, Z
     14e:	82 60       	ori	r24, 0x02	; 2
     150:	80 83       	st	Z, r24
	TCCR0A |= (1 << WGM01);
     152:	84 b5       	in	r24, 0x24	; 36
     154:	82 60       	ori	r24, 0x02	; 2
     156:	84 bd       	out	0x24, r24	; 36
	OCR0A = 117; //10ms interrupt at 12MHz
     158:	85 e7       	ldi	r24, 0x75	; 117
     15a:	87 bd       	out	0x27, r24	; 39
	TCCR0B |= (1 << CS02) | (1 << CS00);
     15c:	85 b5       	in	r24, 0x25	; 37
     15e:	85 60       	ori	r24, 0x05	; 5
     160:	85 bd       	out	0x25, r24	; 37
	
	DDRC = 0xC0;
     162:	80 ec       	ldi	r24, 0xC0	; 192
     164:	87 b9       	out	0x07, r24	; 7
	DDRD = 0xF2;
     166:	82 ef       	ldi	r24, 0xF2	; 242
     168:	8a b9       	out	0x0a, r24	; 10
     16a:	08 95       	ret

0000016c <power_off>:
}

static
void power_off (void)
{
	SPCR = 0;				/* Disable SPI function */
     16c:	1c bc       	out	0x2c, r1	; 44
// 	DDRB  &= ~0b00110111;	/* Set SCK/MOSI/CS as hi-z, INS#/WP as pull-up */
// 	PORTB &= ~0b00000111;
// 	PORTB |=  0b00110000;


	PORTB = ~0b00010000;      // SS high
     16e:	8f ee       	ldi	r24, 0xEF	; 239
     170:	85 b9       	out	0x05, r24	; 5
	DDRB =  ~(uint8_t)0b10110000;      // !SS,SCK and MOSI outputs
     172:	8f e4       	ldi	r24, 0x4F	; 79
     174:	84 b9       	out	0x04, r24	; 4
// 	{	/* Remove this block if no socket power control */
// 		PORTE |= _BV(7);		/* Socket power off (PE7=high) */
// 		for (Timer1 = 20; Timer1; );	/* Wait for 20ms */
// 	}
}
     176:	08 95       	ret

00000178 <xchg_spi>:
static
BYTE xchg_spi (		/* Returns received data */
	BYTE dat		/* Data to be sent */
)
{
	SPDR = dat;
     178:	8e bd       	out	0x2e, r24	; 46
	loop_until_bit_is_set(SPSR, SPIF);
     17a:	0d b4       	in	r0, 0x2d	; 45
     17c:	07 fe       	sbrs	r0, 7
     17e:	fd cf       	rjmp	.-6      	; 0x17a <xchg_spi+0x2>
	return SPDR;
     180:	8e b5       	in	r24, 0x2e	; 46
}
     182:	08 95       	ret

00000184 <wait_ready>:
int wait_ready (void)	/* 1:OK, 0:Timeout */
{
	BYTE d;


	Timer2 = 50;	/* Wait for ready in timeout of 500ms */
     184:	82 e3       	ldi	r24, 0x32	; 50
     186:	80 93 84 04 	sts	0x0484, r24
	do
		d = xchg_spi(0xFF);
     18a:	8f ef       	ldi	r24, 0xFF	; 255
     18c:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
	while (d != 0xFF && Timer2);
     190:	8f 3f       	cpi	r24, 0xFF	; 255
     192:	21 f0       	breq	.+8      	; 0x19c <wait_ready+0x18>
     194:	90 91 84 04 	lds	r25, 0x0484
     198:	99 23       	and	r25, r25
     19a:	b9 f7       	brne	.-18     	; 0x18a <wait_ready+0x6>

	return (d == 0xFF) ? 1 : 0;
     19c:	21 e0       	ldi	r18, 0x01	; 1
     19e:	30 e0       	ldi	r19, 0x00	; 0
     1a0:	8f 3f       	cpi	r24, 0xFF	; 255
     1a2:	11 f0       	breq	.+4      	; 0x1a8 <wait_ready+0x24>
     1a4:	20 e0       	ldi	r18, 0x00	; 0
     1a6:	30 e0       	ldi	r19, 0x00	; 0
}
     1a8:	82 2f       	mov	r24, r18
     1aa:	93 2f       	mov	r25, r19
     1ac:	08 95       	ret

000001ae <deselect>:
/*-----------------------------------------------------------------------*/

static
void deselect (void)
{
	CS_HIGH();
     1ae:	2c 9a       	sbi	0x05, 4	; 5
	xchg_spi(0xFF);	/* Dummy clock (force DO hi-z for multiple slave SPI) */
     1b0:	8f ef       	ldi	r24, 0xFF	; 255
     1b2:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
}
     1b6:	08 95       	ret

000001b8 <select>:
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:Successful, 0:Timeout */
{
	CS_LOW();
     1b8:	2c 98       	cbi	0x05, 4	; 5
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */
     1ba:	8f ef       	ldi	r24, 0xFF	; 255
     1bc:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>

	if (wait_ready()) return 1;	/* OK */
     1c0:	0e 94 c2 00 	call	0x184	; 0x184 <wait_ready>
     1c4:	00 97       	sbiw	r24, 0x00	; 0
     1c6:	29 f4       	brne	.+10     	; 0x1d2 <select+0x1a>
	deselect();
     1c8:	0e 94 d7 00 	call	0x1ae	; 0x1ae <deselect>
	return 0;	/* Timeout */
     1cc:	80 e0       	ldi	r24, 0x00	; 0
     1ce:	90 e0       	ldi	r25, 0x00	; 0
     1d0:	08 95       	ret
int select (void)	/* 1:Successful, 0:Timeout */
{
	CS_LOW();
	xchg_spi(0xFF);	/* Dummy clock (force DO enabled) */

	if (wait_ready()) return 1;	/* OK */
     1d2:	81 e0       	ldi	r24, 0x01	; 1
     1d4:	90 e0       	ldi	r25, 0x00	; 0
	deselect();
	return 0;	/* Timeout */
}
     1d6:	08 95       	ret

000001d8 <rcvr_datablock>:
static
int rcvr_datablock (
	BYTE *buff,			/* Data buffer to store received data */
	UINT btr			/* Byte count (must be multiple of 4) */
)
{
     1d8:	cf 92       	push	r12
     1da:	df 92       	push	r13
     1dc:	ef 92       	push	r14
     1de:	ff 92       	push	r15
     1e0:	cf 93       	push	r28
     1e2:	df 93       	push	r29
     1e4:	ec 01       	movw	r28, r24
     1e6:	6a 01       	movw	r12, r20
     1e8:	7b 01       	movw	r14, r22
	BYTE token;


	Timer1 = 20;
     1ea:	84 e1       	ldi	r24, 0x14	; 20
     1ec:	80 93 85 04 	sts	0x0485, r24
	do {							/* Wait for data packet in timeout of 200ms */
		token = xchg_spi(0xFF);
     1f0:	8f ef       	ldi	r24, 0xFF	; 255
     1f2:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
	} while ((token == 0xFF) && Timer1);
     1f6:	8f 3f       	cpi	r24, 0xFF	; 255
     1f8:	39 f4       	brne	.+14     	; 0x208 <rcvr_datablock+0x30>
     1fa:	80 91 85 04 	lds	r24, 0x0485
     1fe:	88 23       	and	r24, r24
     200:	b9 f7       	brne	.-18     	; 0x1f0 <rcvr_datablock+0x18>
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */
     202:	80 e0       	ldi	r24, 0x00	; 0
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	28 c0       	rjmp	.+80     	; 0x258 <rcvr_datablock+0x80>
     208:	8e 3f       	cpi	r24, 0xFE	; 254
     20a:	21 f5       	brne	.+72     	; 0x254 <rcvr_datablock+0x7c>
	BYTE *p,	/* Data buffer */
	UINT cnt	/* Size of data block */
)
{
	do {
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
     20c:	8f ef       	ldi	r24, 0xFF	; 255
     20e:	8e bd       	out	0x2e, r24	; 46
     210:	0d b4       	in	r0, 0x2d	; 45
     212:	07 fe       	sbrs	r0, 7
     214:	fd cf       	rjmp	.-6      	; 0x210 <rcvr_datablock+0x38>
     216:	9e b5       	in	r25, 0x2e	; 46
     218:	98 83       	st	Y, r25
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
     21a:	8e bd       	out	0x2e, r24	; 46
     21c:	0d b4       	in	r0, 0x2d	; 45
     21e:	07 fe       	sbrs	r0, 7
     220:	fd cf       	rjmp	.-6      	; 0x21c <rcvr_datablock+0x44>
     222:	9e b5       	in	r25, 0x2e	; 46
     224:	99 83       	std	Y+1, r25	; 0x01
/*-----------------------------------------------------------------------*/
/* Receive a data packet from MMC                                        */
/*-----------------------------------------------------------------------*/

static
int rcvr_datablock (
     226:	22 96       	adiw	r28, 0x02	; 2
)
{
	do {
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
		SPDR = 0xFF; loop_until_bit_is_set(SPSR,SPIF); *p++ = SPDR;
	} while (cnt -= 2);
     228:	2e ef       	ldi	r18, 0xFE	; 254
     22a:	3f ef       	ldi	r19, 0xFF	; 255
     22c:	4f ef       	ldi	r20, 0xFF	; 255
     22e:	5f ef       	ldi	r21, 0xFF	; 255
     230:	c2 0e       	add	r12, r18
     232:	d3 1e       	adc	r13, r19
     234:	e4 1e       	adc	r14, r20
     236:	f5 1e       	adc	r15, r21
     238:	c1 14       	cp	r12, r1
     23a:	d1 04       	cpc	r13, r1
     23c:	e1 04       	cpc	r14, r1
     23e:	f1 04       	cpc	r15, r1
     240:	31 f7       	brne	.-52     	; 0x20e <rcvr_datablock+0x36>
		token = xchg_spi(0xFF);
	} while ((token == 0xFF) && Timer1);
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */

	rcvr_spi_multi(buff, btr);		/* Receive the data block into buffer */
	xchg_spi(0xFF);					/* Discard CRC */
     242:	8f ef       	ldi	r24, 0xFF	; 255
     244:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
	xchg_spi(0xFF);
     248:	8f ef       	ldi	r24, 0xFF	; 255
     24a:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>

	return 1;						/* Return with success */
     24e:	81 e0       	ldi	r24, 0x01	; 1
     250:	90 e0       	ldi	r25, 0x00	; 0
     252:	02 c0       	rjmp	.+4      	; 0x258 <rcvr_datablock+0x80>

	Timer1 = 20;
	do {							/* Wait for data packet in timeout of 200ms */
		token = xchg_spi(0xFF);
	} while ((token == 0xFF) && Timer1);
	if (token != 0xFE) return 0;	/* If not valid data token, retutn with error */
     254:	80 e0       	ldi	r24, 0x00	; 0
     256:	90 e0       	ldi	r25, 0x00	; 0
	rcvr_spi_multi(buff, btr);		/* Receive the data block into buffer */
	xchg_spi(0xFF);					/* Discard CRC */
	xchg_spi(0xFF);

	return 1;						/* Return with success */
}
     258:	df 91       	pop	r29
     25a:	cf 91       	pop	r28
     25c:	ff 90       	pop	r15
     25e:	ef 90       	pop	r14
     260:	df 90       	pop	r13
     262:	cf 90       	pop	r12
     264:	08 95       	ret

00000266 <xmit_datablock>:
static
int xmit_datablock (
	const BYTE *buff,	/* 512 byte data block to be transmitted */
	BYTE token			/* Data/Stop token */
)
{
     266:	1f 93       	push	r17
     268:	cf 93       	push	r28
     26a:	df 93       	push	r29
     26c:	ec 01       	movw	r28, r24
     26e:	16 2f       	mov	r17, r22
	BYTE resp;


	if (!wait_ready()) return 0;
     270:	0e 94 c2 00 	call	0x184	; 0x184 <wait_ready>
     274:	00 97       	sbiw	r24, 0x00	; 0
     276:	41 f1       	breq	.+80     	; 0x2c8 <xmit_datablock+0x62>

	xchg_spi(token);					/* Xmit data token */
     278:	81 2f       	mov	r24, r17
     27a:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
	if (token != 0xFD) {	/* Is data token */
     27e:	1d 3f       	cpi	r17, 0xFD	; 253
     280:	31 f1       	breq	.+76     	; 0x2ce <xmit_datablock+0x68>
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     282:	ce 01       	movw	r24, r28
     284:	80 50       	subi	r24, 0x00	; 0
     286:	9e 4f       	sbci	r25, 0xFE	; 254
	const BYTE *p,	/* Data block to be sent */
	UINT cnt		/* Size of data block */
)
{
	do {
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     288:	28 81       	ld	r18, Y
     28a:	2e bd       	out	0x2e, r18	; 46
     28c:	0d b4       	in	r0, 0x2d	; 45
     28e:	07 fe       	sbrs	r0, 7
     290:	fd cf       	rjmp	.-6      	; 0x28c <xmit_datablock+0x26>
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     292:	29 81       	ldd	r18, Y+1	; 0x01
     294:	2e bd       	out	0x2e, r18	; 46
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     296:	22 96       	adiw	r28, 0x02	; 2
	UINT cnt		/* Size of data block */
)
{
	do {
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
		SPDR = *p++; loop_until_bit_is_set(SPSR,SPIF);
     298:	0d b4       	in	r0, 0x2d	; 45
     29a:	07 fe       	sbrs	r0, 7
     29c:	fd cf       	rjmp	.-6      	; 0x298 <xmit_datablock+0x32>
	} while (cnt -= 2);
     29e:	8c 17       	cp	r24, r28
     2a0:	9d 07       	cpc	r25, r29
     2a2:	91 f7       	brne	.-28     	; 0x288 <xmit_datablock+0x22>
	if (!wait_ready()) return 0;

	xchg_spi(token);					/* Xmit data token */
	if (token != 0xFD) {	/* Is data token */
		xmit_spi_multi(buff, 512);		/* Xmit the data block to the MMC */
		xchg_spi(0xFF);					/* CRC (Dummy) */
     2a4:	8f ef       	ldi	r24, 0xFF	; 255
     2a6:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
		xchg_spi(0xFF);
     2aa:	8f ef       	ldi	r24, 0xFF	; 255
     2ac:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
		resp = xchg_spi(0xFF);			/* Reveive data response */
     2b0:	8f ef       	ldi	r24, 0xFF	; 255
     2b2:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
     2b6:	8f 71       	andi	r24, 0x1F	; 31
/*-----------------------------------------------------------------------*/
/* Send a data packet to MMC                                             */
/*-----------------------------------------------------------------------*/

static
int xmit_datablock (
     2b8:	21 e0       	ldi	r18, 0x01	; 1
     2ba:	30 e0       	ldi	r19, 0x00	; 0
     2bc:	85 30       	cpi	r24, 0x05	; 5
     2be:	11 f0       	breq	.+4      	; 0x2c4 <xmit_datablock+0x5e>
     2c0:	20 e0       	ldi	r18, 0x00	; 0
     2c2:	30 e0       	ldi	r19, 0x00	; 0
)
{
	BYTE resp;


	if (!wait_ready()) return 0;
     2c4:	c9 01       	movw	r24, r18
     2c6:	05 c0       	rjmp	.+10     	; 0x2d2 <xmit_datablock+0x6c>
     2c8:	80 e0       	ldi	r24, 0x00	; 0
     2ca:	90 e0       	ldi	r25, 0x00	; 0
     2cc:	02 c0       	rjmp	.+4      	; 0x2d2 <xmit_datablock+0x6c>
		resp = xchg_spi(0xFF);			/* Reveive data response */
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
			return 0;
	}

	return 1;
     2ce:	81 e0       	ldi	r24, 0x01	; 1
     2d0:	90 e0       	ldi	r25, 0x00	; 0
}
     2d2:	df 91       	pop	r29
     2d4:	cf 91       	pop	r28
     2d6:	1f 91       	pop	r17
     2d8:	08 95       	ret

000002da <send_cmd>:
static
BYTE send_cmd (		/* Returns R1 resp (bit7==1:Send failed) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
     2da:	ff 92       	push	r15
     2dc:	0f 93       	push	r16
     2de:	1f 93       	push	r17
     2e0:	cf 93       	push	r28
     2e2:	df 93       	push	r29
     2e4:	c8 2f       	mov	r28, r24
     2e6:	d4 2f       	mov	r29, r20
     2e8:	15 2f       	mov	r17, r21
     2ea:	06 2f       	mov	r16, r22
     2ec:	f7 2e       	mov	r15, r23
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
     2ee:	88 23       	and	r24, r24
     2f0:	4c f4       	brge	.+18     	; 0x304 <send_cmd+0x2a>
		cmd &= 0x7F;
		res = send_cmd(CMD55, 0);
     2f2:	87 e3       	ldi	r24, 0x37	; 55
     2f4:	40 e0       	ldi	r20, 0x00	; 0
     2f6:	50 e0       	ldi	r21, 0x00	; 0
     2f8:	ba 01       	movw	r22, r20
     2fa:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
		if (res > 1) return res;
     2fe:	82 30       	cpi	r24, 0x02	; 2
     300:	68 f5       	brcc	.+90     	; 0x35c <send_cmd+0x82>
{
	BYTE n, res;


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
     302:	cf 77       	andi	r28, 0x7F	; 127
		res = send_cmd(CMD55, 0);
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	deselect();
     304:	0e 94 d7 00 	call	0x1ae	; 0x1ae <deselect>
	if (!select()) return 0xFF;
     308:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <select>
     30c:	00 97       	sbiw	r24, 0x00	; 0
     30e:	29 f1       	breq	.+74     	; 0x35a <send_cmd+0x80>

	/* Send command packet */
	xchg_spi(0x40 | cmd);				/* Start + Command index */
     310:	8c 2f       	mov	r24, r28
     312:	80 64       	ori	r24, 0x40	; 64
     314:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
	xchg_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
     318:	8f 2d       	mov	r24, r15
     31a:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
	xchg_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
     31e:	80 2f       	mov	r24, r16
     320:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
     324:	81 2f       	mov	r24, r17
     326:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
     32a:	8d 2f       	mov	r24, r29
     32c:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) + Stop */
     330:	cc 23       	and	r28, r28
     332:	f1 f0       	breq	.+60     	; 0x370 <send_cmd+0x96>
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) Stop */
     334:	c8 30       	cpi	r28, 0x08	; 8
     336:	c1 f0       	breq	.+48     	; 0x368 <send_cmd+0x8e>
	xchg_spi(n);
     338:	81 e0       	ldi	r24, 0x01	; 1
     33a:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>

	/* Receive command response */
	if (cmd == CMD12) xchg_spi(0xFF);		/* Skip a stuff byte when stop reading */
     33e:	cc 30       	cpi	r28, 0x0C	; 12
     340:	19 f4       	brne	.+6      	; 0x348 <send_cmd+0x6e>
     342:	8f ef       	ldi	r24, 0xFF	; 255
     344:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
static
BYTE send_cmd (		/* Returns R1 resp (bit7==1:Send failed) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
     348:	ca e0       	ldi	r28, 0x0A	; 10

	/* Receive command response */
	if (cmd == CMD12) xchg_spi(0xFF);		/* Skip a stuff byte when stop reading */
	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do
		res = xchg_spi(0xFF);
     34a:	8f ef       	ldi	r24, 0xFF	; 255
     34c:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
	while ((res & 0x80) && --n);
     350:	88 23       	and	r24, r24
     352:	24 f4       	brge	.+8      	; 0x35c <send_cmd+0x82>
     354:	c1 50       	subi	r28, 0x01	; 1
     356:	c9 f7       	brne	.-14     	; 0x34a <send_cmd+0x70>
     358:	01 c0       	rjmp	.+2      	; 0x35c <send_cmd+0x82>
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	deselect();
	if (!select()) return 0xFF;
     35a:	8f ef       	ldi	r24, 0xFF	; 255
	do
		res = xchg_spi(0xFF);
	while ((res & 0x80) && --n);

	return res;			/* Return with the response value */
}
     35c:	df 91       	pop	r29
     35e:	cf 91       	pop	r28
     360:	1f 91       	pop	r17
     362:	0f 91       	pop	r16
     364:	ff 90       	pop	r15
     366:	08 95       	ret
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) + Stop */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) Stop */
	xchg_spi(n);
     368:	87 e8       	ldi	r24, 0x87	; 135
     36a:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
     36e:	ec cf       	rjmp	.-40     	; 0x348 <send_cmd+0x6e>
     370:	85 e9       	ldi	r24, 0x95	; 149
     372:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
     376:	e8 cf       	rjmp	.-48     	; 0x348 <send_cmd+0x6e>

00000378 <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
     378:	cf 92       	push	r12
     37a:	df 92       	push	r13
     37c:	ef 92       	push	r14
     37e:	ff 92       	push	r15
     380:	0f 93       	push	r16
     382:	1f 93       	push	r17
     384:	cf 93       	push	r28
     386:	df 93       	push	r29
     388:	00 d0       	rcall	.+0      	; 0x38a <disk_initialize+0x12>
     38a:	00 d0       	rcall	.+0      	; 0x38c <disk_initialize+0x14>
     38c:	cd b7       	in	r28, 0x3d	; 61
     38e:	de b7       	in	r29, 0x3e	; 62
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only single drive */
     390:	88 23       	and	r24, r24
     392:	09 f0       	breq	.+2      	; 0x396 <disk_initialize+0x1e>
     394:	a8 c0       	rjmp	.+336    	; 0x4e6 <disk_initialize+0x16e>
	power_off();						/* Turn off the socket power to reset the card */
     396:	0e 94 b6 00 	call	0x16c	; 0x16c <power_off>
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
     39a:	80 91 8a 01 	lds	r24, 0x018A
     39e:	81 ff       	sbrs	r24, 1
     3a0:	03 c0       	rjmp	.+6      	; 0x3a8 <disk_initialize+0x30>
     3a2:	80 91 8a 01 	lds	r24, 0x018A
     3a6:	a0 c0       	rjmp	.+320    	; 0x4e8 <disk_initialize+0x170>
	// Configure for: PB4 - /SS
	//                PB5 - MOSI
	//                PB6 - MISO
	//                PB7 - SCK

	PORTB = 0b00010000;      // SS high
     3a8:	80 e1       	ldi	r24, 0x10	; 16
     3aa:	85 b9       	out	0x05, r24	; 5
	DDRB =  0b10110000;      // !SS,SCK and MOSI outputs
     3ac:	80 eb       	ldi	r24, 0xB0	; 176
     3ae:	84 b9       	out	0x04, r24	; 4

	/* Set MOSI and SCK output, all others input */
	//DDR_SPI = (1<<DD_MOSI)|(1<<DD_SCK);
	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
     3b0:	81 e5       	ldi	r24, 0x51	; 81
     3b2:	8c bd       	out	0x2c, r24	; 44

	if (drv) return STA_NOINIT;			/* Supports only single drive */
	power_off();						/* Turn off the socket power to reset the card */
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
	power_on();							/* Turn on the socket power */
	FCLK_SLOW();
     3b4:	82 e5       	ldi	r24, 0x52	; 82
     3b6:	8c bd       	out	0x2c, r24	; 44
     3b8:	0a e0       	ldi	r16, 0x0A	; 10
	for (n = 10; n; n--) xchg_spi(0xFF);	/* 80 dummy clocks */
     3ba:	8f ef       	ldi	r24, 0xFF	; 255
     3bc:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
     3c0:	01 50       	subi	r16, 0x01	; 1
     3c2:	d9 f7       	brne	.-10     	; 0x3ba <disk_initialize+0x42>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
     3c4:	80 e0       	ldi	r24, 0x00	; 0
     3c6:	40 e0       	ldi	r20, 0x00	; 0
     3c8:	50 e0       	ldi	r21, 0x00	; 0
     3ca:	ba 01       	movw	r22, r20
     3cc:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     3d0:	81 30       	cpi	r24, 0x01	; 1
     3d2:	09 f0       	breq	.+2      	; 0x3d6 <disk_initialize+0x5e>
     3d4:	9c c0       	rjmp	.+312    	; 0x50e <disk_initialize+0x196>
		Timer1 = 100;						/* Initialization timeout of 1000 msec */
     3d6:	84 e6       	ldi	r24, 0x64	; 100
     3d8:	80 93 85 04 	sts	0x0485, r24
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
     3dc:	88 e0       	ldi	r24, 0x08	; 8
     3de:	4a ea       	ldi	r20, 0xAA	; 170
     3e0:	51 e0       	ldi	r21, 0x01	; 1
     3e2:	60 e0       	ldi	r22, 0x00	; 0
     3e4:	70 e0       	ldi	r23, 0x00	; 0
     3e6:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     3ea:	81 30       	cpi	r24, 0x01	; 1
     3ec:	09 f0       	breq	.+2      	; 0x3f0 <disk_initialize+0x78>
     3ee:	42 c0       	rjmp	.+132    	; 0x474 <disk_initialize+0xfc>
     3f0:	6e 01       	movw	r12, r28
     3f2:	08 94       	sec
     3f4:	c1 1c       	adc	r12, r1
     3f6:	d1 1c       	adc	r13, r1

/*-----------------------------------------------------------------------*/
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
     3f8:	8e 01       	movw	r16, r28
     3fa:	0b 5f       	subi	r16, 0xFB	; 251
     3fc:	1f 4f       	sbci	r17, 0xFF	; 255
     3fe:	76 01       	movw	r14, r12

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		Timer1 = 100;						/* Initialization timeout of 1000 msec */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);		/* Get trailing return value of R7 resp */
     400:	8f ef       	ldi	r24, 0xFF	; 255
     402:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
     406:	f7 01       	movw	r30, r14
     408:	81 93       	st	Z+, r24
     40a:	7f 01       	movw	r14, r30
     40c:	e0 17       	cp	r30, r16
     40e:	f1 07       	cpc	r31, r17
     410:	b9 f7       	brne	.-18     	; 0x400 <disk_initialize+0x88>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
     412:	8b 81       	ldd	r24, Y+3	; 0x03
     414:	81 30       	cpi	r24, 0x01	; 1
     416:	09 f0       	breq	.+2      	; 0x41a <disk_initialize+0xa2>
     418:	7a c0       	rjmp	.+244    	; 0x50e <disk_initialize+0x196>
     41a:	8c 81       	ldd	r24, Y+4	; 0x04
     41c:	8a 3a       	cpi	r24, 0xAA	; 170
     41e:	09 f0       	breq	.+2      	; 0x422 <disk_initialize+0xaa>
     420:	76 c0       	rjmp	.+236    	; 0x50e <disk_initialize+0x196>
				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
     422:	80 91 85 04 	lds	r24, 0x0485
     426:	88 23       	and	r24, r24
     428:	49 f0       	breq	.+18     	; 0x43c <disk_initialize+0xc4>
     42a:	89 ea       	ldi	r24, 0xA9	; 169
     42c:	40 e0       	ldi	r20, 0x00	; 0
     42e:	50 e0       	ldi	r21, 0x00	; 0
     430:	60 e0       	ldi	r22, 0x00	; 0
     432:	70 e4       	ldi	r23, 0x40	; 64
     434:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     438:	88 23       	and	r24, r24
     43a:	99 f7       	brne	.-26     	; 0x422 <disk_initialize+0xaa>
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
     43c:	80 91 85 04 	lds	r24, 0x0485
     440:	88 23       	and	r24, r24
     442:	09 f4       	brne	.+2      	; 0x446 <disk_initialize+0xce>
     444:	64 c0       	rjmp	.+200    	; 0x50e <disk_initialize+0x196>
     446:	8a e3       	ldi	r24, 0x3A	; 58
     448:	40 e0       	ldi	r20, 0x00	; 0
     44a:	50 e0       	ldi	r21, 0x00	; 0
     44c:	ba 01       	movw	r22, r20
     44e:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     452:	88 23       	and	r24, r24
     454:	09 f0       	breq	.+2      	; 0x458 <disk_initialize+0xe0>
     456:	5b c0       	rjmp	.+182    	; 0x50e <disk_initialize+0x196>
     458:	04 e0       	ldi	r16, 0x04	; 4
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
     45a:	8f ef       	ldi	r24, 0xFF	; 255
     45c:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
     460:	f6 01       	movw	r30, r12
     462:	81 93       	st	Z+, r24
     464:	6f 01       	movw	r12, r30
     466:	01 50       	subi	r16, 0x01	; 1
     468:	c1 f7       	brne	.-16     	; 0x45a <disk_initialize+0xe2>
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
     46a:	89 81       	ldd	r24, Y+1	; 0x01
     46c:	86 fd       	sbrc	r24, 6
     46e:	49 c0       	rjmp	.+146    	; 0x502 <disk_initialize+0x18a>
     470:	84 e0       	ldi	r24, 0x04	; 4
     472:	48 c0       	rjmp	.+144    	; 0x504 <disk_initialize+0x18c>
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
     474:	89 ea       	ldi	r24, 0xA9	; 169
     476:	40 e0       	ldi	r20, 0x00	; 0
     478:	50 e0       	ldi	r21, 0x00	; 0
     47a:	ba 01       	movw	r22, r20
     47c:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     480:	82 30       	cpi	r24, 0x02	; 2
     482:	18 f4       	brcc	.+6      	; 0x48a <disk_initialize+0x112>
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
     484:	12 e0       	ldi	r17, 0x02	; 2
     486:	09 ea       	ldi	r16, 0xA9	; 169
     488:	02 c0       	rjmp	.+4      	; 0x48e <disk_initialize+0x116>
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
     48a:	11 e0       	ldi	r17, 0x01	; 1
     48c:	01 e0       	ldi	r16, 0x01	; 1
			}
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
     48e:	80 91 85 04 	lds	r24, 0x0485
     492:	88 23       	and	r24, r24
     494:	41 f0       	breq	.+16     	; 0x4a6 <disk_initialize+0x12e>
     496:	80 2f       	mov	r24, r16
     498:	40 e0       	ldi	r20, 0x00	; 0
     49a:	50 e0       	ldi	r21, 0x00	; 0
     49c:	ba 01       	movw	r22, r20
     49e:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     4a2:	88 23       	and	r24, r24
     4a4:	a1 f7       	brne	.-24     	; 0x48e <disk_initialize+0x116>
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
     4a6:	80 91 85 04 	lds	r24, 0x0485
     4aa:	88 23       	and	r24, r24
     4ac:	81 f1       	breq	.+96     	; 0x50e <disk_initialize+0x196>
     4ae:	80 e1       	ldi	r24, 0x10	; 16
     4b0:	40 e0       	ldi	r20, 0x00	; 0
     4b2:	52 e0       	ldi	r21, 0x02	; 2
     4b4:	60 e0       	ldi	r22, 0x00	; 0
     4b6:	70 e0       	ldi	r23, 0x00	; 0
     4b8:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     4bc:	88 23       	and	r24, r24
     4be:	39 f5       	brne	.+78     	; 0x50e <disk_initialize+0x196>
				ty = 0;
		}
	}
	CardType = ty;
     4c0:	10 93 86 04 	sts	0x0486, r17
	deselect();
     4c4:	0e 94 d7 00 	call	0x1ae	; 0x1ae <deselect>

	if (ty) {			/* Initialization succeded */
     4c8:	11 23       	and	r17, r17
     4ca:	41 f0       	breq	.+16     	; 0x4dc <disk_initialize+0x164>
		Stat &= ~STA_NOINIT;		/* Clear STA_NOINIT */
     4cc:	80 91 8a 01 	lds	r24, 0x018A
     4d0:	8e 7f       	andi	r24, 0xFE	; 254
     4d2:	80 93 8a 01 	sts	0x018A, r24
		FCLK_FAST();
     4d6:	80 e5       	ldi	r24, 0x50	; 80
     4d8:	8c bd       	out	0x2c, r24	; 44
     4da:	02 c0       	rjmp	.+4      	; 0x4e0 <disk_initialize+0x168>
	} else {			/* Initialization failed */
		power_off();
     4dc:	0e 94 b6 00 	call	0x16c	; 0x16c <power_off>
	}

	return Stat;
     4e0:	80 91 8a 01 	lds	r24, 0x018A
     4e4:	01 c0       	rjmp	.+2      	; 0x4e8 <disk_initialize+0x170>
)
{
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only single drive */
     4e6:	81 e0       	ldi	r24, 0x01	; 1
	} else {			/* Initialization failed */
		power_off();
	}

	return Stat;
}
     4e8:	0f 90       	pop	r0
     4ea:	0f 90       	pop	r0
     4ec:	0f 90       	pop	r0
     4ee:	0f 90       	pop	r0
     4f0:	df 91       	pop	r29
     4f2:	cf 91       	pop	r28
     4f4:	1f 91       	pop	r17
     4f6:	0f 91       	pop	r16
     4f8:	ff 90       	pop	r15
     4fa:	ef 90       	pop	r14
     4fc:	df 90       	pop	r13
     4fe:	cf 90       	pop	r12
     500:	08 95       	ret
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);		/* Get trailing return value of R7 resp */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
				while (Timer1 && send_cmd(ACMD41, 1UL << 30));	/* Wait for leaving idle state (ACMD41 with HCS bit) */
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
     502:	8c e0       	ldi	r24, 0x0C	; 12
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
     504:	80 93 86 04 	sts	0x0486, r24
	deselect();
     508:	0e 94 d7 00 	call	0x1ae	; 0x1ae <deselect>
     50c:	df cf       	rjmp	.-66     	; 0x4cc <disk_initialize+0x154>
			while (Timer1 && send_cmd(cmd, 0));			/* Wait for leaving idle state */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
     50e:	10 92 86 04 	sts	0x0486, r1
	deselect();
     512:	0e 94 d7 00 	call	0x1ae	; 0x1ae <deselect>
     516:	e2 cf       	rjmp	.-60     	; 0x4dc <disk_initialize+0x164>

00000518 <disk_status>:

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
     518:	88 23       	and	r24, r24
     51a:	19 f4       	brne	.+6      	; 0x522 <disk_status+0xa>
	return Stat;
     51c:	80 91 8a 01 	lds	r24, 0x018A
     520:	08 95       	ret

DSTATUS disk_status (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
     522:	81 e0       	ldi	r24, 0x01	; 1
	return Stat;
}
     524:	08 95       	ret

00000526 <disk_read>:
	BYTE drv,			/* Physical drive nmuber (0) */
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
     526:	0f 93       	push	r16
     528:	cf 93       	push	r28
     52a:	df 93       	push	r29
     52c:	eb 01       	movw	r28, r22
	if (drv || !count) return RES_PARERR;
     52e:	88 23       	and	r24, r24
     530:	09 f0       	breq	.+2      	; 0x534 <disk_read+0xe>
     532:	4a c0       	rjmp	.+148    	; 0x5c8 <disk_read+0xa2>
     534:	00 23       	and	r16, r16
     536:	09 f4       	brne	.+2      	; 0x53a <disk_read+0x14>
     538:	49 c0       	rjmp	.+146    	; 0x5cc <disk_read+0xa6>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     53a:	80 91 8a 01 	lds	r24, 0x018A
     53e:	80 fd       	sbrc	r24, 0
     540:	47 c0       	rjmp	.+142    	; 0x5d0 <disk_read+0xaa>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
     542:	80 91 86 04 	lds	r24, 0x0486
     546:	83 fd       	sbrc	r24, 3
     548:	09 c0       	rjmp	.+18     	; 0x55c <disk_read+0x36>
     54a:	01 2e       	mov	r0, r17
     54c:	19 e0       	ldi	r17, 0x09	; 9
     54e:	22 0f       	add	r18, r18
     550:	33 1f       	adc	r19, r19
     552:	44 1f       	adc	r20, r20
     554:	55 1f       	adc	r21, r21
     556:	1a 95       	dec	r17
     558:	d1 f7       	brne	.-12     	; 0x54e <disk_read+0x28>
     55a:	10 2d       	mov	r17, r0

	if (count == 1) {	/* Single block read */
     55c:	01 30       	cpi	r16, 0x01	; 1
     55e:	89 f4       	brne	.+34     	; 0x582 <disk_read+0x5c>
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
     560:	81 e1       	ldi	r24, 0x11	; 17
     562:	ba 01       	movw	r22, r20
     564:	a9 01       	movw	r20, r18
     566:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     56a:	88 23       	and	r24, r24
     56c:	31 f5       	brne	.+76     	; 0x5ba <disk_read+0x94>
			&& rcvr_datablock(buff, 512))
     56e:	ce 01       	movw	r24, r28
     570:	40 e0       	ldi	r20, 0x00	; 0
     572:	52 e0       	ldi	r21, 0x02	; 2
     574:	60 e0       	ldi	r22, 0x00	; 0
     576:	70 e0       	ldi	r23, 0x00	; 0
     578:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <rcvr_datablock>
     57c:	00 97       	sbiw	r24, 0x00	; 0
     57e:	e1 f4       	brne	.+56     	; 0x5b8 <disk_read+0x92>
     580:	1c c0       	rjmp	.+56     	; 0x5ba <disk_read+0x94>
			count = 0;
	}
	else {				/* Multiple block read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
     582:	82 e1       	ldi	r24, 0x12	; 18
     584:	ba 01       	movw	r22, r20
     586:	a9 01       	movw	r20, r18
     588:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     58c:	88 23       	and	r24, r24
     58e:	a9 f4       	brne	.+42     	; 0x5ba <disk_read+0x94>
			do {
				if (!rcvr_datablock(buff, 512)) break;
     590:	ce 01       	movw	r24, r28
     592:	40 e0       	ldi	r20, 0x00	; 0
     594:	52 e0       	ldi	r21, 0x02	; 2
     596:	60 e0       	ldi	r22, 0x00	; 0
     598:	70 e0       	ldi	r23, 0x00	; 0
     59a:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <rcvr_datablock>
     59e:	00 97       	sbiw	r24, 0x00	; 0
     5a0:	21 f0       	breq	.+8      	; 0x5aa <disk_read+0x84>
				buff += 512;
     5a2:	c0 50       	subi	r28, 0x00	; 0
     5a4:	de 4f       	sbci	r29, 0xFE	; 254
			} while (--count);
     5a6:	01 50       	subi	r16, 0x01	; 1
     5a8:	99 f7       	brne	.-26     	; 0x590 <disk_read+0x6a>
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
     5aa:	8c e0       	ldi	r24, 0x0C	; 12
     5ac:	40 e0       	ldi	r20, 0x00	; 0
     5ae:	50 e0       	ldi	r21, 0x00	; 0
     5b0:	ba 01       	movw	r22, r20
     5b2:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     5b6:	01 c0       	rjmp	.+2      	; 0x5ba <disk_read+0x94>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */

	if (count == 1) {	/* Single block read */
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
			&& rcvr_datablock(buff, 512))
			count = 0;
     5b8:	00 e0       	ldi	r16, 0x00	; 0
				buff += 512;
			} while (--count);
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
		}
	}
	deselect();
     5ba:	0e 94 d7 00 	call	0x1ae	; 0x1ae <deselect>

	return count ? RES_ERROR : RES_OK;
     5be:	81 e0       	ldi	r24, 0x01	; 1
     5c0:	00 23       	and	r16, r16
     5c2:	39 f4       	brne	.+14     	; 0x5d2 <disk_read+0xac>
     5c4:	80 e0       	ldi	r24, 0x00	; 0
     5c6:	05 c0       	rjmp	.+10     	; 0x5d2 <disk_read+0xac>
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
	if (drv || !count) return RES_PARERR;
     5c8:	84 e0       	ldi	r24, 0x04	; 4
     5ca:	03 c0       	rjmp	.+6      	; 0x5d2 <disk_read+0xac>
     5cc:	84 e0       	ldi	r24, 0x04	; 4
     5ce:	01 c0       	rjmp	.+2      	; 0x5d2 <disk_read+0xac>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     5d0:	83 e0       	ldi	r24, 0x03	; 3
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
     5d2:	df 91       	pop	r29
     5d4:	cf 91       	pop	r28
     5d6:	0f 91       	pop	r16
     5d8:	08 95       	ret

000005da <disk_write>:
	BYTE drv,			/* Physical drive nmuber (0) */
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
     5da:	cf 92       	push	r12
     5dc:	df 92       	push	r13
     5de:	ef 92       	push	r14
     5e0:	ff 92       	push	r15
     5e2:	0f 93       	push	r16
     5e4:	cf 93       	push	r28
     5e6:	df 93       	push	r29
     5e8:	eb 01       	movw	r28, r22
     5ea:	69 01       	movw	r12, r18
     5ec:	7a 01       	movw	r14, r20
	if (drv || !count) return RES_PARERR;
     5ee:	88 23       	and	r24, r24
     5f0:	09 f0       	breq	.+2      	; 0x5f4 <disk_write+0x1a>
     5f2:	57 c0       	rjmp	.+174    	; 0x6a2 <disk_write+0xc8>
     5f4:	00 23       	and	r16, r16
     5f6:	09 f4       	brne	.+2      	; 0x5fa <disk_write+0x20>
     5f8:	56 c0       	rjmp	.+172    	; 0x6a6 <disk_write+0xcc>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     5fa:	80 91 8a 01 	lds	r24, 0x018A
     5fe:	80 fd       	sbrc	r24, 0
     600:	54 c0       	rjmp	.+168    	; 0x6aa <disk_write+0xd0>
	if (Stat & STA_PROTECT) return RES_WRPRT;
     602:	80 91 8a 01 	lds	r24, 0x018A
     606:	82 fd       	sbrc	r24, 2
     608:	52 c0       	rjmp	.+164    	; 0x6ae <disk_write+0xd4>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
     60a:	80 91 86 04 	lds	r24, 0x0486
     60e:	90 e0       	ldi	r25, 0x00	; 0
     610:	83 fd       	sbrc	r24, 3
     612:	09 c0       	rjmp	.+18     	; 0x626 <disk_write+0x4c>
     614:	0b 2e       	mov	r0, r27
     616:	b9 e0       	ldi	r27, 0x09	; 9
     618:	cc 0c       	add	r12, r12
     61a:	dd 1c       	adc	r13, r13
     61c:	ee 1c       	adc	r14, r14
     61e:	ff 1c       	adc	r15, r15
     620:	ba 95       	dec	r27
     622:	d1 f7       	brne	.-12     	; 0x618 <disk_write+0x3e>
     624:	b0 2d       	mov	r27, r0

	if (count == 1) {	/* Single block write */
     626:	01 30       	cpi	r16, 0x01	; 1
     628:	71 f4       	brne	.+28     	; 0x646 <disk_write+0x6c>
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
     62a:	88 e1       	ldi	r24, 0x18	; 24
     62c:	b7 01       	movw	r22, r14
     62e:	a6 01       	movw	r20, r12
     630:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     634:	88 23       	and	r24, r24
     636:	71 f5       	brne	.+92     	; 0x694 <disk_write+0xba>
			&& xmit_datablock(buff, 0xFE))
     638:	ce 01       	movw	r24, r28
     63a:	6e ef       	ldi	r22, 0xFE	; 254
     63c:	0e 94 33 01 	call	0x266	; 0x266 <xmit_datablock>
     640:	00 97       	sbiw	r24, 0x00	; 0
     642:	29 f5       	brne	.+74     	; 0x68e <disk_write+0xb4>
     644:	27 c0       	rjmp	.+78     	; 0x694 <disk_write+0xba>
			count = 0;
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
     646:	86 70       	andi	r24, 0x06	; 6
     648:	90 70       	andi	r25, 0x00	; 0
     64a:	00 97       	sbiw	r24, 0x00	; 0
     64c:	39 f0       	breq	.+14     	; 0x65c <disk_write+0x82>
     64e:	40 2f       	mov	r20, r16
     650:	50 e0       	ldi	r21, 0x00	; 0
     652:	60 e0       	ldi	r22, 0x00	; 0
     654:	70 e0       	ldi	r23, 0x00	; 0
     656:	87 e9       	ldi	r24, 0x97	; 151
     658:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
     65c:	89 e1       	ldi	r24, 0x19	; 25
     65e:	b7 01       	movw	r22, r14
     660:	a6 01       	movw	r20, r12
     662:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     666:	88 23       	and	r24, r24
     668:	a9 f4       	brne	.+42     	; 0x694 <disk_write+0xba>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
     66a:	ce 01       	movw	r24, r28
     66c:	6c ef       	ldi	r22, 0xFC	; 252
     66e:	0e 94 33 01 	call	0x266	; 0x266 <xmit_datablock>
     672:	00 97       	sbiw	r24, 0x00	; 0
     674:	21 f0       	breq	.+8      	; 0x67e <disk_write+0xa4>
				buff += 512;
     676:	c0 50       	subi	r28, 0x00	; 0
     678:	de 4f       	sbci	r29, 0xFE	; 254
			} while (--count);
     67a:	01 50       	subi	r16, 0x01	; 1
     67c:	b1 f7       	brne	.-20     	; 0x66a <disk_write+0x90>
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
     67e:	80 e0       	ldi	r24, 0x00	; 0
     680:	90 e0       	ldi	r25, 0x00	; 0
     682:	6d ef       	ldi	r22, 0xFD	; 253
     684:	0e 94 33 01 	call	0x266	; 0x266 <xmit_datablock>
     688:	00 97       	sbiw	r24, 0x00	; 0
     68a:	19 f0       	breq	.+6      	; 0x692 <disk_write+0xb8>
     68c:	03 c0       	rjmp	.+6      	; 0x694 <disk_write+0xba>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */

	if (count == 1) {	/* Single block write */
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
			&& xmit_datablock(buff, 0xFE))
			count = 0;
     68e:	00 e0       	ldi	r16, 0x00	; 0
     690:	01 c0       	rjmp	.+2      	; 0x694 <disk_write+0xba>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
				buff += 512;
			} while (--count);
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
				count = 1;
     692:	01 e0       	ldi	r16, 0x01	; 1
		}
	}
	deselect();
     694:	0e 94 d7 00 	call	0x1ae	; 0x1ae <deselect>

	return count ? RES_ERROR : RES_OK;
     698:	81 e0       	ldi	r24, 0x01	; 1
     69a:	00 23       	and	r16, r16
     69c:	49 f4       	brne	.+18     	; 0x6b0 <disk_write+0xd6>
     69e:	80 e0       	ldi	r24, 0x00	; 0
     6a0:	07 c0       	rjmp	.+14     	; 0x6b0 <disk_write+0xd6>
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	BYTE count			/* Sector count (1..255) */
)
{
	if (drv || !count) return RES_PARERR;
     6a2:	84 e0       	ldi	r24, 0x04	; 4
     6a4:	05 c0       	rjmp	.+10     	; 0x6b0 <disk_write+0xd6>
     6a6:	84 e0       	ldi	r24, 0x04	; 4
     6a8:	03 c0       	rjmp	.+6      	; 0x6b0 <disk_write+0xd6>
	if (Stat & STA_NOINIT) return RES_NOTRDY;
     6aa:	83 e0       	ldi	r24, 0x03	; 3
     6ac:	01 c0       	rjmp	.+2      	; 0x6b0 <disk_write+0xd6>
	if (Stat & STA_PROTECT) return RES_WRPRT;
     6ae:	82 e0       	ldi	r24, 0x02	; 2
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
     6b0:	df 91       	pop	r29
     6b2:	cf 91       	pop	r28
     6b4:	0f 91       	pop	r16
     6b6:	ff 90       	pop	r15
     6b8:	ef 90       	pop	r14
     6ba:	df 90       	pop	r13
     6bc:	cf 90       	pop	r12
     6be:	08 95       	ret

000006c0 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
     6c0:	ef 92       	push	r14
     6c2:	ff 92       	push	r15
     6c4:	0f 93       	push	r16
     6c6:	1f 93       	push	r17
     6c8:	cf 93       	push	r28
     6ca:	df 93       	push	r29
     6cc:	cd b7       	in	r28, 0x3d	; 61
     6ce:	de b7       	in	r29, 0x3e	; 62
     6d0:	60 97       	sbiw	r28, 0x10	; 16
     6d2:	0f b6       	in	r0, 0x3f	; 63
     6d4:	f8 94       	cli
     6d6:	de bf       	out	0x3e, r29	; 62
     6d8:	0f be       	out	0x3f, r0	; 63
     6da:	cd bf       	out	0x3d, r28	; 61
     6dc:	7a 01       	movw	r14, r20
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	DWORD csize;


	if (drv) return RES_PARERR;
     6de:	88 23       	and	r24, r24
     6e0:	09 f0       	breq	.+2      	; 0x6e4 <disk_ioctl+0x24>
     6e2:	da c1       	rjmp	.+948    	; 0xa98 <disk_ioctl+0x3d8>

	res = RES_ERROR;

	if (ctrl == CTRL_POWER) {
     6e4:	65 30       	cpi	r22, 0x05	; 5
     6e6:	89 f4       	brne	.+34     	; 0x70a <disk_ioctl+0x4a>
		switch (ptr[0]) {
     6e8:	fa 01       	movw	r30, r20
     6ea:	80 81       	ld	r24, Z
     6ec:	88 23       	and	r24, r24
     6ee:	21 f0       	breq	.+8      	; 0x6f8 <disk_ioctl+0x38>
     6f0:	81 30       	cpi	r24, 0x01	; 1
     6f2:	09 f0       	breq	.+2      	; 0x6f6 <disk_ioctl+0x36>
     6f4:	d3 c1       	rjmp	.+934    	; 0xa9c <disk_ioctl+0x3dc>
     6f6:	04 c0       	rjmp	.+8      	; 0x700 <disk_ioctl+0x40>
		case 0:		/* Sub control code (POWER_OFF) */
			power_off();		/* Power off */
     6f8:	0e 94 b6 00 	call	0x16c	; 0x16c <power_off>
			res = RES_OK;
     6fc:	00 e0       	ldi	r16, 0x00	; 0
			break;
     6fe:	d1 c1       	rjmp	.+930    	; 0xaa2 <disk_ioctl+0x3e2>
		case 1:		/* Sub control code (POWER_GET) */
			ptr[1] = (BYTE)power_status();
     700:	81 e0       	ldi	r24, 0x01	; 1
     702:	fa 01       	movw	r30, r20
     704:	81 83       	std	Z+1, r24	; 0x01
			res = RES_OK;
     706:	00 e0       	ldi	r16, 0x00	; 0
			break;
     708:	cc c1       	rjmp	.+920    	; 0xaa2 <disk_ioctl+0x3e2>
		default :
			res = RES_PARERR;
		}
	}
	else {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
     70a:	80 91 8a 01 	lds	r24, 0x018A
     70e:	80 fd       	sbrc	r24, 0
     710:	c7 c1       	rjmp	.+910    	; 0xaa0 <disk_ioctl+0x3e0>

		switch (ctrl) {
     712:	6a 30       	cpi	r22, 0x0A	; 10
     714:	09 f4       	brne	.+2      	; 0x718 <disk_ioctl+0x58>
     716:	44 c1       	rjmp	.+648    	; 0x9a0 <disk_ioctl+0x2e0>
     718:	6b 30       	cpi	r22, 0x0B	; 11
     71a:	58 f4       	brcc	.+22     	; 0x732 <disk_ioctl+0x72>
     71c:	61 30       	cpi	r22, 0x01	; 1
     71e:	f9 f0       	breq	.+62     	; 0x75e <disk_ioctl+0x9e>
     720:	61 30       	cpi	r22, 0x01	; 1
     722:	a0 f0       	brcs	.+40     	; 0x74c <disk_ioctl+0x8c>
     724:	62 30       	cpi	r22, 0x02	; 2
     726:	09 f4       	brne	.+2      	; 0x72a <disk_ioctl+0x6a>
     728:	98 c0       	rjmp	.+304    	; 0x85a <disk_ioctl+0x19a>
     72a:	63 30       	cpi	r22, 0x03	; 3
     72c:	09 f0       	breq	.+2      	; 0x730 <disk_ioctl+0x70>
     72e:	94 c1       	rjmp	.+808    	; 0xa58 <disk_ioctl+0x398>
     730:	9b c0       	rjmp	.+310    	; 0x868 <disk_ioctl+0x1a8>
     732:	6c 30       	cpi	r22, 0x0C	; 12
     734:	09 f4       	brne	.+2      	; 0x738 <disk_ioctl+0x78>
     736:	4f c1       	rjmp	.+670    	; 0x9d6 <disk_ioctl+0x316>
     738:	6c 30       	cpi	r22, 0x0C	; 12
     73a:	08 f4       	brcc	.+2      	; 0x73e <disk_ioctl+0x7e>
     73c:	37 c1       	rjmp	.+622    	; 0x9ac <disk_ioctl+0x2ec>
     73e:	6d 30       	cpi	r22, 0x0D	; 13
     740:	09 f4       	brne	.+2      	; 0x744 <disk_ioctl+0x84>
     742:	5e c1       	rjmp	.+700    	; 0xa00 <disk_ioctl+0x340>
     744:	6e 30       	cpi	r22, 0x0E	; 14
     746:	09 f0       	breq	.+2      	; 0x74a <disk_ioctl+0x8a>
     748:	87 c1       	rjmp	.+782    	; 0xa58 <disk_ioctl+0x398>
     74a:	70 c1       	rjmp	.+736    	; 0xa2c <disk_ioctl+0x36c>
		case CTRL_SYNC :		/* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
			if (select()) {
     74c:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <select>
     750:	00 97       	sbiw	r24, 0x00	; 0
     752:	09 f4       	brne	.+2      	; 0x756 <disk_ioctl+0x96>
     754:	83 c1       	rjmp	.+774    	; 0xa5c <disk_ioctl+0x39c>
				deselect();
     756:	0e 94 d7 00 	call	0x1ae	; 0x1ae <deselect>
				res = RES_OK;
     75a:	00 e0       	ldi	r16, 0x00	; 0
     75c:	9a c1       	rjmp	.+820    	; 0xa92 <disk_ioctl+0x3d2>
			}
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
     75e:	89 e0       	ldi	r24, 0x09	; 9
     760:	40 e0       	ldi	r20, 0x00	; 0
     762:	50 e0       	ldi	r21, 0x00	; 0
     764:	ba 01       	movw	r22, r20
     766:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     76a:	88 23       	and	r24, r24
     76c:	09 f0       	breq	.+2      	; 0x770 <disk_ioctl+0xb0>
     76e:	78 c1       	rjmp	.+752    	; 0xa60 <disk_ioctl+0x3a0>
     770:	ce 01       	movw	r24, r28
     772:	01 96       	adiw	r24, 0x01	; 1
     774:	40 e1       	ldi	r20, 0x10	; 16
     776:	50 e0       	ldi	r21, 0x00	; 0
     778:	60 e0       	ldi	r22, 0x00	; 0
     77a:	70 e0       	ldi	r23, 0x00	; 0
     77c:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <rcvr_datablock>
     780:	00 97       	sbiw	r24, 0x00	; 0
     782:	09 f4       	brne	.+2      	; 0x786 <disk_ioctl+0xc6>
     784:	6f c1       	rjmp	.+734    	; 0xa64 <disk_ioctl+0x3a4>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
     786:	89 81       	ldd	r24, Y+1	; 0x01
     788:	82 95       	swap	r24
     78a:	86 95       	lsr	r24
     78c:	86 95       	lsr	r24
     78e:	83 70       	andi	r24, 0x03	; 3
     790:	81 30       	cpi	r24, 0x01	; 1
     792:	51 f5       	brne	.+84     	; 0x7e8 <disk_ioctl+0x128>
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
     794:	48 85       	ldd	r20, Y+8	; 0x08
     796:	50 e0       	ldi	r21, 0x00	; 0
     798:	60 e0       	ldi	r22, 0x00	; 0
     79a:	70 e0       	ldi	r23, 0x00	; 0
     79c:	4f 73       	andi	r20, 0x3F	; 63
     79e:	50 70       	andi	r21, 0x00	; 0
     7a0:	60 70       	andi	r22, 0x00	; 0
     7a2:	70 70       	andi	r23, 0x00	; 0
     7a4:	ba 01       	movw	r22, r20
     7a6:	55 27       	eor	r21, r21
     7a8:	44 27       	eor	r20, r20
     7aa:	4f 5f       	subi	r20, 0xFF	; 255
     7ac:	5f 4f       	sbci	r21, 0xFF	; 255
     7ae:	6f 4f       	sbci	r22, 0xFF	; 255
     7b0:	7f 4f       	sbci	r23, 0xFF	; 255
     7b2:	99 85       	ldd	r25, Y+9	; 0x09
     7b4:	80 e0       	ldi	r24, 0x00	; 0
     7b6:	2a 85       	ldd	r18, Y+10	; 0x0a
     7b8:	82 0f       	add	r24, r18
     7ba:	91 1d       	adc	r25, r1
     7bc:	a0 e0       	ldi	r26, 0x00	; 0
     7be:	b0 e0       	ldi	r27, 0x00	; 0
     7c0:	84 0f       	add	r24, r20
     7c2:	95 1f       	adc	r25, r21
     7c4:	a6 1f       	adc	r26, r22
     7c6:	b7 1f       	adc	r27, r23
					*(DWORD*)buff = csize << 10;
     7c8:	07 2e       	mov	r0, r23
     7ca:	7a e0       	ldi	r23, 0x0A	; 10
     7cc:	88 0f       	add	r24, r24
     7ce:	99 1f       	adc	r25, r25
     7d0:	aa 1f       	adc	r26, r26
     7d2:	bb 1f       	adc	r27, r27
     7d4:	7a 95       	dec	r23
     7d6:	d1 f7       	brne	.-12     	; 0x7cc <disk_ioctl+0x10c>
     7d8:	70 2d       	mov	r23, r0
     7da:	f7 01       	movw	r30, r14
     7dc:	80 83       	st	Z, r24
     7de:	91 83       	std	Z+1, r25	; 0x01
     7e0:	a2 83       	std	Z+2, r26	; 0x02
     7e2:	b3 83       	std	Z+3, r27	; 0x03
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = csize << (n - 9);
				}
				res = RES_OK;
     7e4:	00 e0       	ldi	r16, 0x00	; 0
     7e6:	55 c1       	rjmp	.+682    	; 0xa92 <disk_ioctl+0x3d2>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = csize << 10;
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
     7e8:	29 85       	ldd	r18, Y+9	; 0x09
     7ea:	22 95       	swap	r18
     7ec:	26 95       	lsr	r18
     7ee:	26 95       	lsr	r18
     7f0:	23 70       	andi	r18, 0x03	; 3
     7f2:	88 85       	ldd	r24, Y+8	; 0x08
     7f4:	90 e0       	ldi	r25, 0x00	; 0
     7f6:	88 0f       	add	r24, r24
     7f8:	99 1f       	adc	r25, r25
     7fa:	88 0f       	add	r24, r24
     7fc:	99 1f       	adc	r25, r25
     7fe:	82 0f       	add	r24, r18
     800:	91 1d       	adc	r25, r1
     802:	01 96       	adiw	r24, 0x01	; 1
     804:	2f 81       	ldd	r18, Y+7	; 0x07
     806:	30 e0       	ldi	r19, 0x00	; 0
     808:	23 70       	andi	r18, 0x03	; 3
     80a:	30 70       	andi	r19, 0x00	; 0
     80c:	32 2f       	mov	r19, r18
     80e:	22 27       	eor	r18, r18
     810:	33 0f       	add	r19, r19
     812:	33 0f       	add	r19, r19
     814:	82 0f       	add	r24, r18
     816:	93 1f       	adc	r25, r19
     818:	ac 01       	movw	r20, r24
     81a:	60 e0       	ldi	r22, 0x00	; 0
     81c:	70 e0       	ldi	r23, 0x00	; 0
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = csize << 10;
				} else {					/* SDC ver 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
     81e:	9e 81       	ldd	r25, Y+6	; 0x06
     820:	9f 70       	andi	r25, 0x0F	; 15
     822:	8b 85       	ldd	r24, Y+11	; 0x0b
     824:	88 1f       	adc	r24, r24
     826:	88 27       	eor	r24, r24
     828:	88 1f       	adc	r24, r24
     82a:	98 0f       	add	r25, r24
     82c:	9e 5f       	subi	r25, 0xFE	; 254
     82e:	8a 85       	ldd	r24, Y+10	; 0x0a
     830:	83 70       	andi	r24, 0x03	; 3
     832:	88 0f       	add	r24, r24
     834:	89 0f       	add	r24, r25
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = csize << (n - 9);
     836:	90 e0       	ldi	r25, 0x00	; 0
     838:	09 97       	sbiw	r24, 0x09	; 9
     83a:	8a 01       	movw	r16, r20
     83c:	9b 01       	movw	r18, r22
     83e:	04 c0       	rjmp	.+8      	; 0x848 <disk_ioctl+0x188>
     840:	00 0f       	add	r16, r16
     842:	11 1f       	adc	r17, r17
     844:	22 1f       	adc	r18, r18
     846:	33 1f       	adc	r19, r19
     848:	8a 95       	dec	r24
     84a:	d2 f7       	brpl	.-12     	; 0x840 <disk_ioctl+0x180>
     84c:	f7 01       	movw	r30, r14
     84e:	00 83       	st	Z, r16
     850:	11 83       	std	Z+1, r17	; 0x01
     852:	22 83       	std	Z+2, r18	; 0x02
     854:	33 83       	std	Z+3, r19	; 0x03
				}
				res = RES_OK;
     856:	00 e0       	ldi	r16, 0x00	; 0
     858:	1c c1       	rjmp	.+568    	; 0xa92 <disk_ioctl+0x3d2>
			}
			break;

		case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
			*(WORD*)buff = 512;
     85a:	80 e0       	ldi	r24, 0x00	; 0
     85c:	92 e0       	ldi	r25, 0x02	; 2
     85e:	fa 01       	movw	r30, r20
     860:	91 83       	std	Z+1, r25	; 0x01
     862:	80 83       	st	Z, r24
			res = RES_OK;
     864:	00 e0       	ldi	r16, 0x00	; 0
			break;
     866:	15 c1       	rjmp	.+554    	; 0xa92 <disk_ioctl+0x3d2>

		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
			if (CardType & CT_SD2) {	/* SDv2? */
     868:	00 91 86 04 	lds	r16, 0x0486
     86c:	02 ff       	sbrs	r16, 2
     86e:	31 c0       	rjmp	.+98     	; 0x8d2 <disk_ioctl+0x212>
				if (send_cmd(ACMD13, 0) == 0) {	/* Read SD status */
     870:	8d e8       	ldi	r24, 0x8D	; 141
     872:	40 e0       	ldi	r20, 0x00	; 0
     874:	50 e0       	ldi	r21, 0x00	; 0
     876:	ba 01       	movw	r22, r20
     878:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     87c:	88 23       	and	r24, r24
     87e:	09 f0       	breq	.+2      	; 0x882 <disk_ioctl+0x1c2>
     880:	f3 c0       	rjmp	.+486    	; 0xa68 <disk_ioctl+0x3a8>
					xchg_spi(0xFF);
     882:	8f ef       	ldi	r24, 0xFF	; 255
     884:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
					if (rcvr_datablock(csd, 16)) {				/* Read partial block */
     888:	ce 01       	movw	r24, r28
     88a:	01 96       	adiw	r24, 0x01	; 1
     88c:	40 e1       	ldi	r20, 0x10	; 16
     88e:	50 e0       	ldi	r21, 0x00	; 0
     890:	60 e0       	ldi	r22, 0x00	; 0
     892:	70 e0       	ldi	r23, 0x00	; 0
     894:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <rcvr_datablock>
     898:	00 97       	sbiw	r24, 0x00	; 0
     89a:	09 f4       	brne	.+2      	; 0x89e <disk_ioctl+0x1de>
     89c:	e7 c0       	rjmp	.+462    	; 0xa6c <disk_ioctl+0x3ac>
     89e:	00 e3       	ldi	r16, 0x30	; 48
						for (n = 64 - 16; n; n--) xchg_spi(0xFF);	/* Purge trailing data */
     8a0:	8f ef       	ldi	r24, 0xFF	; 255
     8a2:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
     8a6:	01 50       	subi	r16, 0x01	; 1
     8a8:	d9 f7       	brne	.-10     	; 0x8a0 <disk_ioctl+0x1e0>
						*(DWORD*)buff = 16UL << (csd[10] >> 4);
     8aa:	2b 85       	ldd	r18, Y+11	; 0x0b
     8ac:	22 95       	swap	r18
     8ae:	2f 70       	andi	r18, 0x0F	; 15
     8b0:	80 e1       	ldi	r24, 0x10	; 16
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	04 c0       	rjmp	.+8      	; 0x8c2 <disk_ioctl+0x202>
     8ba:	88 0f       	add	r24, r24
     8bc:	99 1f       	adc	r25, r25
     8be:	aa 1f       	adc	r26, r26
     8c0:	bb 1f       	adc	r27, r27
     8c2:	2a 95       	dec	r18
     8c4:	d2 f7       	brpl	.-12     	; 0x8ba <disk_ioctl+0x1fa>
     8c6:	f7 01       	movw	r30, r14
     8c8:	80 83       	st	Z, r24
     8ca:	91 83       	std	Z+1, r25	; 0x01
     8cc:	a2 83       	std	Z+2, r26	; 0x02
     8ce:	b3 83       	std	Z+3, r27	; 0x03
     8d0:	e0 c0       	rjmp	.+448    	; 0xa92 <disk_ioctl+0x3d2>
						res = RES_OK;
					}
				}
			} else {					/* SDv1 or MMCv3 */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
     8d2:	89 e0       	ldi	r24, 0x09	; 9
     8d4:	40 e0       	ldi	r20, 0x00	; 0
     8d6:	50 e0       	ldi	r21, 0x00	; 0
     8d8:	ba 01       	movw	r22, r20
     8da:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     8de:	88 23       	and	r24, r24
     8e0:	09 f0       	breq	.+2      	; 0x8e4 <disk_ioctl+0x224>
     8e2:	c6 c0       	rjmp	.+396    	; 0xa70 <disk_ioctl+0x3b0>
     8e4:	ce 01       	movw	r24, r28
     8e6:	01 96       	adiw	r24, 0x01	; 1
     8e8:	40 e1       	ldi	r20, 0x10	; 16
     8ea:	50 e0       	ldi	r21, 0x00	; 0
     8ec:	60 e0       	ldi	r22, 0x00	; 0
     8ee:	70 e0       	ldi	r23, 0x00	; 0
     8f0:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <rcvr_datablock>
     8f4:	00 97       	sbiw	r24, 0x00	; 0
     8f6:	09 f4       	brne	.+2      	; 0x8fa <disk_ioctl+0x23a>
     8f8:	bd c0       	rjmp	.+378    	; 0xa74 <disk_ioctl+0x3b4>
					if (CardType & CT_SD1) {	/* SDv1 */
     8fa:	01 ff       	sbrs	r16, 1
     8fc:	25 c0       	rjmp	.+74     	; 0x948 <disk_ioctl+0x288>
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
     8fe:	8c 85       	ldd	r24, Y+12	; 0x0c
     900:	88 1f       	adc	r24, r24
     902:	88 27       	eor	r24, r24
     904:	88 1f       	adc	r24, r24
     906:	90 e0       	ldi	r25, 0x00	; 0
     908:	01 96       	adiw	r24, 0x01	; 1
     90a:	2b 85       	ldd	r18, Y+11	; 0x0b
     90c:	30 e0       	ldi	r19, 0x00	; 0
     90e:	2f 73       	andi	r18, 0x3F	; 63
     910:	30 70       	andi	r19, 0x00	; 0
     912:	22 0f       	add	r18, r18
     914:	33 1f       	adc	r19, r19
     916:	28 0f       	add	r18, r24
     918:	39 1f       	adc	r19, r25
     91a:	8e 85       	ldd	r24, Y+14	; 0x0e
     91c:	82 95       	swap	r24
     91e:	86 95       	lsr	r24
     920:	86 95       	lsr	r24
     922:	83 70       	andi	r24, 0x03	; 3
     924:	90 e0       	ldi	r25, 0x00	; 0
     926:	01 97       	sbiw	r24, 0x01	; 1
     928:	89 01       	movw	r16, r18
     92a:	02 c0       	rjmp	.+4      	; 0x930 <disk_ioctl+0x270>
     92c:	00 0f       	add	r16, r16
     92e:	11 1f       	adc	r17, r17
     930:	8a 95       	dec	r24
     932:	e2 f7       	brpl	.-8      	; 0x92c <disk_ioctl+0x26c>
     934:	c8 01       	movw	r24, r16
     936:	a0 e0       	ldi	r26, 0x00	; 0
     938:	b0 e0       	ldi	r27, 0x00	; 0
     93a:	f7 01       	movw	r30, r14
     93c:	80 83       	st	Z, r24
     93e:	91 83       	std	Z+1, r25	; 0x01
     940:	a2 83       	std	Z+2, r26	; 0x02
     942:	b3 83       	std	Z+3, r27	; 0x03
					} else {					/* MMCv3 */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
					}
					res = RES_OK;
     944:	00 e0       	ldi	r16, 0x00	; 0
     946:	a5 c0       	rjmp	.+330    	; 0xa92 <disk_ioctl+0x3d2>
			} else {					/* SDv1 or MMCv3 */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {	/* Read CSD */
					if (CardType & CT_SD1) {	/* SDv1 */
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
					} else {					/* MMCv3 */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
     948:	8c 85       	ldd	r24, Y+12	; 0x0c
     94a:	48 2f       	mov	r20, r24
     94c:	50 e0       	ldi	r21, 0x00	; 0
     94e:	43 70       	andi	r20, 0x03	; 3
     950:	50 70       	andi	r21, 0x00	; 0
     952:	44 0f       	add	r20, r20
     954:	55 1f       	adc	r21, r21
     956:	44 0f       	add	r20, r20
     958:	55 1f       	adc	r21, r21
     95a:	44 0f       	add	r20, r20
     95c:	55 1f       	adc	r21, r21
     95e:	82 95       	swap	r24
     960:	86 95       	lsr	r24
     962:	87 70       	andi	r24, 0x07	; 7
     964:	48 0f       	add	r20, r24
     966:	51 1d       	adc	r21, r1
     968:	4f 5f       	subi	r20, 0xFF	; 255
     96a:	5f 4f       	sbci	r21, 0xFF	; 255
     96c:	2b 85       	ldd	r18, Y+11	; 0x0b
     96e:	30 e0       	ldi	r19, 0x00	; 0
     970:	2c 77       	andi	r18, 0x7C	; 124
     972:	30 70       	andi	r19, 0x00	; 0
     974:	35 95       	asr	r19
     976:	27 95       	ror	r18
     978:	35 95       	asr	r19
     97a:	27 95       	ror	r18
     97c:	2f 5f       	subi	r18, 0xFF	; 255
     97e:	3f 4f       	sbci	r19, 0xFF	; 255
     980:	42 9f       	mul	r20, r18
     982:	c0 01       	movw	r24, r0
     984:	43 9f       	mul	r20, r19
     986:	90 0d       	add	r25, r0
     988:	52 9f       	mul	r21, r18
     98a:	90 0d       	add	r25, r0
     98c:	11 24       	eor	r1, r1
     98e:	a0 e0       	ldi	r26, 0x00	; 0
     990:	b0 e0       	ldi	r27, 0x00	; 0
     992:	f7 01       	movw	r30, r14
     994:	80 83       	st	Z, r24
     996:	91 83       	std	Z+1, r25	; 0x01
     998:	a2 83       	std	Z+2, r26	; 0x02
     99a:	b3 83       	std	Z+3, r27	; 0x03
					}
					res = RES_OK;
     99c:	00 e0       	ldi	r16, 0x00	; 0
     99e:	79 c0       	rjmp	.+242    	; 0xa92 <disk_ioctl+0x3d2>
				}
			}
			break;

		case MMC_GET_TYPE :		/* Get card type flags (1 byte) */
			*ptr = CardType;
     9a0:	80 91 86 04 	lds	r24, 0x0486
     9a4:	fa 01       	movw	r30, r20
     9a6:	80 83       	st	Z, r24
			res = RES_OK;
     9a8:	00 e0       	ldi	r16, 0x00	; 0
			break;
     9aa:	73 c0       	rjmp	.+230    	; 0xa92 <disk_ioctl+0x3d2>

		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
     9ac:	89 e0       	ldi	r24, 0x09	; 9
     9ae:	40 e0       	ldi	r20, 0x00	; 0
     9b0:	50 e0       	ldi	r21, 0x00	; 0
     9b2:	ba 01       	movw	r22, r20
     9b4:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     9b8:	88 23       	and	r24, r24
     9ba:	09 f0       	breq	.+2      	; 0x9be <disk_ioctl+0x2fe>
     9bc:	5d c0       	rjmp	.+186    	; 0xa78 <disk_ioctl+0x3b8>
				&& rcvr_datablock(ptr, 16))
     9be:	c7 01       	movw	r24, r14
     9c0:	40 e1       	ldi	r20, 0x10	; 16
     9c2:	50 e0       	ldi	r21, 0x00	; 0
     9c4:	60 e0       	ldi	r22, 0x00	; 0
     9c6:	70 e0       	ldi	r23, 0x00	; 0
     9c8:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <rcvr_datablock>
     9cc:	00 97       	sbiw	r24, 0x00	; 0
     9ce:	09 f0       	breq	.+2      	; 0x9d2 <disk_ioctl+0x312>
     9d0:	55 c0       	rjmp	.+170    	; 0xa7c <disk_ioctl+0x3bc>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     9d2:	01 e0       	ldi	r16, 0x01	; 1
     9d4:	5e c0       	rjmp	.+188    	; 0xa92 <disk_ioctl+0x3d2>
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
			break;

		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
     9d6:	8a e0       	ldi	r24, 0x0A	; 10
     9d8:	40 e0       	ldi	r20, 0x00	; 0
     9da:	50 e0       	ldi	r21, 0x00	; 0
     9dc:	ba 01       	movw	r22, r20
     9de:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     9e2:	88 23       	and	r24, r24
     9e4:	09 f0       	breq	.+2      	; 0x9e8 <disk_ioctl+0x328>
     9e6:	4c c0       	rjmp	.+152    	; 0xa80 <disk_ioctl+0x3c0>
				&& rcvr_datablock(ptr, 16))
     9e8:	c7 01       	movw	r24, r14
     9ea:	40 e1       	ldi	r20, 0x10	; 16
     9ec:	50 e0       	ldi	r21, 0x00	; 0
     9ee:	60 e0       	ldi	r22, 0x00	; 0
     9f0:	70 e0       	ldi	r23, 0x00	; 0
     9f2:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <rcvr_datablock>
     9f6:	00 97       	sbiw	r24, 0x00	; 0
     9f8:	09 f0       	breq	.+2      	; 0x9fc <disk_ioctl+0x33c>
     9fa:	44 c0       	rjmp	.+136    	; 0xa84 <disk_ioctl+0x3c4>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     9fc:	01 e0       	ldi	r16, 0x01	; 1
     9fe:	49 c0       	rjmp	.+146    	; 0xa92 <disk_ioctl+0x3d2>
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
			break;

		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
			if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
     a00:	8a e3       	ldi	r24, 0x3A	; 58
     a02:	40 e0       	ldi	r20, 0x00	; 0
     a04:	50 e0       	ldi	r21, 0x00	; 0
     a06:	ba 01       	movw	r22, r20
     a08:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     a0c:	88 23       	and	r24, r24
     a0e:	e1 f5       	brne	.+120    	; 0xa88 <disk_ioctl+0x3c8>
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
/*-----------------------------------------------------------------------*/

#if _USE_IOCTL
DRESULT disk_ioctl (
     a10:	87 01       	movw	r16, r14
     a12:	0c 5f       	subi	r16, 0xFC	; 252
     a14:	1f 4f       	sbci	r17, 0xFF	; 255
				res = RES_OK;
			break;

		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
			if (send_cmd(CMD58, 0) == 0) {	/* READ_OCR */
				for (n = 4; n; n--) *ptr++ = xchg_spi(0xFF);
     a16:	8f ef       	ldi	r24, 0xFF	; 255
     a18:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
     a1c:	f7 01       	movw	r30, r14
     a1e:	81 93       	st	Z+, r24
     a20:	7f 01       	movw	r14, r30
     a22:	e0 17       	cp	r30, r16
     a24:	f1 07       	cpc	r31, r17
     a26:	b9 f7       	brne	.-18     	; 0xa16 <disk_ioctl+0x356>
				res = RES_OK;
     a28:	00 e0       	ldi	r16, 0x00	; 0
     a2a:	33 c0       	rjmp	.+102    	; 0xa92 <disk_ioctl+0x3d2>
			}
			break;

		case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
			if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
     a2c:	8d e8       	ldi	r24, 0x8D	; 141
     a2e:	40 e0       	ldi	r20, 0x00	; 0
     a30:	50 e0       	ldi	r21, 0x00	; 0
     a32:	ba 01       	movw	r22, r20
     a34:	0e 94 6d 01 	call	0x2da	; 0x2da <send_cmd>
     a38:	88 23       	and	r24, r24
     a3a:	41 f5       	brne	.+80     	; 0xa8c <disk_ioctl+0x3cc>
				xchg_spi(0xFF);
     a3c:	8f ef       	ldi	r24, 0xFF	; 255
     a3e:	0e 94 bc 00 	call	0x178	; 0x178 <xchg_spi>
				if (rcvr_datablock(ptr, 64))
     a42:	c7 01       	movw	r24, r14
     a44:	40 e4       	ldi	r20, 0x40	; 64
     a46:	50 e0       	ldi	r21, 0x00	; 0
     a48:	60 e0       	ldi	r22, 0x00	; 0
     a4a:	70 e0       	ldi	r23, 0x00	; 0
     a4c:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <rcvr_datablock>
     a50:	00 97       	sbiw	r24, 0x00	; 0
     a52:	f1 f4       	brne	.+60     	; 0xa90 <disk_ioctl+0x3d0>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a54:	01 e0       	ldi	r16, 0x01	; 1
     a56:	1d c0       	rjmp	.+58     	; 0xa92 <disk_ioctl+0x3d2>
					res = RES_OK;
			}
			break;

		default:
			res = RES_PARERR;
     a58:	04 e0       	ldi	r16, 0x04	; 4
     a5a:	1b c0       	rjmp	.+54     	; 0xa92 <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a5c:	01 e0       	ldi	r16, 0x01	; 1
     a5e:	19 c0       	rjmp	.+50     	; 0xa92 <disk_ioctl+0x3d2>
     a60:	01 e0       	ldi	r16, 0x01	; 1
     a62:	17 c0       	rjmp	.+46     	; 0xa92 <disk_ioctl+0x3d2>
     a64:	01 e0       	ldi	r16, 0x01	; 1
     a66:	15 c0       	rjmp	.+42     	; 0xa92 <disk_ioctl+0x3d2>
     a68:	01 e0       	ldi	r16, 0x01	; 1
     a6a:	13 c0       	rjmp	.+38     	; 0xa92 <disk_ioctl+0x3d2>
     a6c:	01 e0       	ldi	r16, 0x01	; 1
     a6e:	11 c0       	rjmp	.+34     	; 0xa92 <disk_ioctl+0x3d2>
     a70:	01 e0       	ldi	r16, 0x01	; 1
     a72:	0f c0       	rjmp	.+30     	; 0xa92 <disk_ioctl+0x3d2>
     a74:	01 e0       	ldi	r16, 0x01	; 1
     a76:	0d c0       	rjmp	.+26     	; 0xa92 <disk_ioctl+0x3d2>
     a78:	01 e0       	ldi	r16, 0x01	; 1
     a7a:	0b c0       	rjmp	.+22     	; 0xa92 <disk_ioctl+0x3d2>
			break;

		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
     a7c:	00 e0       	ldi	r16, 0x00	; 0
     a7e:	09 c0       	rjmp	.+18     	; 0xa92 <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a80:	01 e0       	ldi	r16, 0x01	; 1
     a82:	07 c0       	rjmp	.+14     	; 0xa92 <disk_ioctl+0x3d2>
			break;

		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
     a84:	00 e0       	ldi	r16, 0x00	; 0
     a86:	05 c0       	rjmp	.+10     	; 0xa92 <disk_ioctl+0x3d2>
	DWORD csize;


	if (drv) return RES_PARERR;

	res = RES_ERROR;
     a88:	01 e0       	ldi	r16, 0x01	; 1
     a8a:	03 c0       	rjmp	.+6      	; 0xa92 <disk_ioctl+0x3d2>
     a8c:	01 e0       	ldi	r16, 0x01	; 1
     a8e:	01 c0       	rjmp	.+2      	; 0xa92 <disk_ioctl+0x3d2>

		case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
			if (send_cmd(ACMD13, 0) == 0) {	/* SD_STATUS */
				xchg_spi(0xFF);
				if (rcvr_datablock(ptr, 64))
					res = RES_OK;
     a90:	00 e0       	ldi	r16, 0x00	; 0

		default:
			res = RES_PARERR;
		}

		deselect();
     a92:	0e 94 d7 00 	call	0x1ae	; 0x1ae <deselect>
     a96:	05 c0       	rjmp	.+10     	; 0xaa2 <disk_ioctl+0x3e2>
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	DWORD csize;


	if (drv) return RES_PARERR;
     a98:	04 e0       	ldi	r16, 0x04	; 4
     a9a:	03 c0       	rjmp	.+6      	; 0xaa2 <disk_ioctl+0x3e2>
		case 1:		/* Sub control code (POWER_GET) */
			ptr[1] = (BYTE)power_status();
			res = RES_OK;
			break;
		default :
			res = RES_PARERR;
     a9c:	04 e0       	ldi	r16, 0x04	; 4
     a9e:	01 c0       	rjmp	.+2      	; 0xaa2 <disk_ioctl+0x3e2>
		}
	}
	else {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
     aa0:	03 e0       	ldi	r16, 0x03	; 3

		deselect();
	}

	return res;
}
     aa2:	80 2f       	mov	r24, r16
     aa4:	60 96       	adiw	r28, 0x10	; 16
     aa6:	0f b6       	in	r0, 0x3f	; 63
     aa8:	f8 94       	cli
     aaa:	de bf       	out	0x3e, r29	; 62
     aac:	0f be       	out	0x3f, r0	; 63
     aae:	cd bf       	out	0x3d, r28	; 61
     ab0:	df 91       	pop	r29
     ab2:	cf 91       	pop	r28
     ab4:	1f 91       	pop	r17
     ab6:	0f 91       	pop	r16
     ab8:	ff 90       	pop	r15
     aba:	ef 90       	pop	r14
     abc:	08 95       	ret

00000abe <disk_timerproc>:
void disk_timerproc (void)
{
	BYTE n, s;


	n = Timer1;				/* 100Hz decrement timer */
     abe:	80 91 85 04 	lds	r24, 0x0485
	if (n) Timer1 = --n;
     ac2:	88 23       	and	r24, r24
     ac4:	19 f0       	breq	.+6      	; 0xacc <disk_timerproc+0xe>
     ac6:	81 50       	subi	r24, 0x01	; 1
     ac8:	80 93 85 04 	sts	0x0485, r24
	n = Timer2;
     acc:	80 91 84 04 	lds	r24, 0x0484
	if (n) Timer2 = --n;
     ad0:	88 23       	and	r24, r24
     ad2:	19 f0       	breq	.+6      	; 0xada <disk_timerproc+0x1c>
     ad4:	81 50       	subi	r24, 0x01	; 1
     ad6:	80 93 84 04 	sts	0x0484, r24

	s = Stat;
     ada:	80 91 8a 01 	lds	r24, 0x018A

	if (SOCKWP)				/* Write protected */
     ade:	18 9b       	sbis	0x03, 0	; 3
     ae0:	02 c0       	rjmp	.+4      	; 0xae6 <disk_timerproc+0x28>
		s |= STA_PROTECT;
     ae2:	84 60       	ori	r24, 0x04	; 4
     ae4:	01 c0       	rjmp	.+2      	; 0xae8 <disk_timerproc+0x2a>
	else					/* Write enabled */
		s &= ~STA_PROTECT;
     ae6:	8b 7f       	andi	r24, 0xFB	; 251

	if (SOCKINS)			/* Card inserted */
     ae8:	19 99       	sbic	0x03, 1	; 3
     aea:	02 c0       	rjmp	.+4      	; 0xaf0 <disk_timerproc+0x32>
		s &= ~STA_NODISK;
     aec:	8d 7f       	andi	r24, 0xFD	; 253
     aee:	01 c0       	rjmp	.+2      	; 0xaf2 <disk_timerproc+0x34>
	else					/* Socket empty */
		s |= (STA_NODISK | STA_NOINIT);
     af0:	83 60       	ori	r24, 0x03	; 3

	Stat = s;				/* Update MMC status */
     af2:	80 93 8a 01 	sts	0x018A, r24
}
     af6:	08 95       	ret

00000af8 <__vector_16>:

// char Line[100];				/* Console input buffer */
char Buff[100];			/* Working buffer */

ISR(TIMER0_COMPA_vect)
{
     af8:	1f 92       	push	r1
     afa:	0f 92       	push	r0
     afc:	0f b6       	in	r0, 0x3f	; 63
     afe:	0f 92       	push	r0
     b00:	11 24       	eor	r1, r1
     b02:	2f 93       	push	r18
     b04:	3f 93       	push	r19
     b06:	4f 93       	push	r20
     b08:	5f 93       	push	r21
     b0a:	6f 93       	push	r22
     b0c:	7f 93       	push	r23
     b0e:	8f 93       	push	r24
     b10:	9f 93       	push	r25
     b12:	af 93       	push	r26
     b14:	bf 93       	push	r27
     b16:	ef 93       	push	r30
     b18:	ff 93       	push	r31
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
     b1a:	0e 94 5f 05 	call	0xabe	; 0xabe <disk_timerproc>
}
     b1e:	ff 91       	pop	r31
     b20:	ef 91       	pop	r30
     b22:	bf 91       	pop	r27
     b24:	af 91       	pop	r26
     b26:	9f 91       	pop	r25
     b28:	8f 91       	pop	r24
     b2a:	7f 91       	pop	r23
     b2c:	6f 91       	pop	r22
     b2e:	5f 91       	pop	r21
     b30:	4f 91       	pop	r20
     b32:	3f 91       	pop	r19
     b34:	2f 91       	pop	r18
     b36:	0f 90       	pop	r0
     b38:	0f be       	out	0x3f, r0	; 63
     b3a:	0f 90       	pop	r0
     b3c:	1f 90       	pop	r1
     b3e:	18 95       	reti

00000b40 <main>:
int main(void)
{
     b40:	cf 92       	push	r12
     b42:	df 92       	push	r13
     b44:	ef 92       	push	r14
     b46:	ff 92       	push	r15
     b48:	0f 93       	push	r16
     b4a:	1f 93       	push	r17
     b4c:	cf 93       	push	r28
     b4e:	df 93       	push	r29
     b50:	00 d0       	rcall	.+0      	; 0xb52 <main+0x12>
     b52:	00 d0       	rcall	.+0      	; 0xb54 <main+0x14>
     b54:	cd b7       	in	r28, 0x3d	; 61
     b56:	de b7       	in	r29, 0x3e	; 62
	unsigned long int a = 0;
     b58:	19 82       	std	Y+1, r1	; 0x01
     b5a:	1a 82       	std	Y+2, r1	; 0x02
     b5c:	1b 82       	std	Y+3, r1	; 0x03
     b5e:	1c 82       	std	Y+4, r1	; 0x04
	uint8_t b = 0;
	FRESULT fr;
	
	USART0_Init();
     b60:	0e 94 d5 28 	call	0x51aa	; 0x51aa <USART0_Init>
	sei();
     b64:	78 94       	sei
	stdout = &mystdout;
     b66:	88 ee       	ldi	r24, 0xE8	; 232
     b68:	92 e0       	ldi	r25, 0x02	; 2
     b6a:	90 93 84 0b 	sts	0x0B84, r25
     b6e:	80 93 83 0b 	sts	0x0B83, r24
	b = MCUSR;
     b72:	24 b7       	in	r18, 0x34	; 52
	MCUSR = 0;
     b74:	14 be       	out	0x34, r1	; 52
	printf("\n\nIl Matto Dual Camera\nMCUSR = %x\n", b);
     b76:	00 d0       	rcall	.+0      	; 0xb78 <main+0x38>
     b78:	00 d0       	rcall	.+0      	; 0xb7a <main+0x3a>
     b7a:	ed b7       	in	r30, 0x3d	; 61
     b7c:	fe b7       	in	r31, 0x3e	; 62
     b7e:	31 96       	adiw	r30, 0x01	; 1
     b80:	8b e8       	ldi	r24, 0x8B	; 139
     b82:	91 e0       	ldi	r25, 0x01	; 1
     b84:	ad b7       	in	r26, 0x3d	; 61
     b86:	be b7       	in	r27, 0x3e	; 62
     b88:	12 96       	adiw	r26, 0x02	; 2
     b8a:	9c 93       	st	X, r25
     b8c:	8e 93       	st	-X, r24
     b8e:	11 97       	sbiw	r26, 0x01	; 1
     b90:	22 83       	std	Z+2, r18	; 0x02
     b92:	13 82       	std	Z+3, r1	; 0x03
     b94:	0e 94 74 29 	call	0x52e8	; 0x52e8 <printf>
	printf("Initialising IO\n");
     b98:	0f 90       	pop	r0
     b9a:	0f 90       	pop	r0
     b9c:	0f 90       	pop	r0
     b9e:	0f 90       	pop	r0
     ba0:	8e ea       	ldi	r24, 0xAE	; 174
     ba2:	91 e0       	ldi	r25, 0x01	; 1
     ba4:	0e 94 89 29 	call	0x5312	; 0x5312 <puts>
	IO_Init();
     ba8:	0e 94 a4 00 	call	0x148	; 0x148 <IO_Init>
	printf("Initialising TWI\n");
     bac:	8e eb       	ldi	r24, 0xBE	; 190
     bae:	91 e0       	ldi	r25, 0x01	; 1
     bb0:	0e 94 89 29 	call	0x5312	; 0x5312 <puts>
	TWI_Master_Initialise();
     bb4:	0e 94 dd 27 	call	0x4fba	; 0x4fba <TWI_Master_Initialise>
	printf("Disk Initialise : %d\n", f_mount(0, &Fatfs[0]));
     bb8:	80 e0       	ldi	r24, 0x00	; 0
     bba:	65 ed       	ldi	r22, 0xD5	; 213
     bbc:	78 e0       	ldi	r23, 0x08	; 8
     bbe:	0e 94 e2 16 	call	0x2dc4	; 0x2dc4 <f_mount>
     bc2:	00 d0       	rcall	.+0      	; 0xbc4 <main+0x84>
     bc4:	00 d0       	rcall	.+0      	; 0xbc6 <main+0x86>
     bc6:	ed b7       	in	r30, 0x3d	; 61
     bc8:	fe b7       	in	r31, 0x3e	; 62
     bca:	31 96       	adiw	r30, 0x01	; 1
     bcc:	2f ec       	ldi	r18, 0xCF	; 207
     bce:	31 e0       	ldi	r19, 0x01	; 1
     bd0:	ad b7       	in	r26, 0x3d	; 61
     bd2:	be b7       	in	r27, 0x3e	; 62
     bd4:	12 96       	adiw	r26, 0x02	; 2
     bd6:	3c 93       	st	X, r19
     bd8:	2e 93       	st	-X, r18
     bda:	11 97       	sbiw	r26, 0x01	; 1
     bdc:	82 83       	std	Z+2, r24	; 0x02
     bde:	13 82       	std	Z+3, r1	; 0x03
     be0:	0e 94 74 29 	call	0x52e8	; 0x52e8 <printf>
	//sprintf(&Buff, "image.bmp");
	fr = f_open(&Files[0], "/log.txt", FA_WRITE | FA_CREATE_ALWAYS);
     be4:	0f 90       	pop	r0
     be6:	0f 90       	pop	r0
     be8:	0f 90       	pop	r0
     bea:	0f 90       	pop	r0
     bec:	83 e9       	ldi	r24, 0x93	; 147
     bee:	94 e0       	ldi	r25, 0x04	; 4
     bf0:	65 ee       	ldi	r22, 0xE5	; 229
     bf2:	71 e0       	ldi	r23, 0x01	; 1
     bf4:	4a e0       	ldi	r20, 0x0A	; 10
     bf6:	0e 94 f8 16 	call	0x2df0	; 0x2df0 <f_open>
     bfa:	18 2f       	mov	r17, r24
	printf("Open File : %d\n", fr);
     bfc:	00 d0       	rcall	.+0      	; 0xbfe <main+0xbe>
     bfe:	00 d0       	rcall	.+0      	; 0xc00 <main+0xc0>
     c00:	ed b7       	in	r30, 0x3d	; 61
     c02:	fe b7       	in	r31, 0x3e	; 62
     c04:	31 96       	adiw	r30, 0x01	; 1
     c06:	8e ee       	ldi	r24, 0xEE	; 238
     c08:	91 e0       	ldi	r25, 0x01	; 1
     c0a:	ad b7       	in	r26, 0x3d	; 61
     c0c:	be b7       	in	r27, 0x3e	; 62
     c0e:	12 96       	adiw	r26, 0x02	; 2
     c10:	9c 93       	st	X, r25
     c12:	8e 93       	st	-X, r24
     c14:	11 97       	sbiw	r26, 0x01	; 1
     c16:	12 83       	std	Z+2, r17	; 0x02
     c18:	13 82       	std	Z+3, r1	; 0x03
     c1a:	0e 94 74 29 	call	0x52e8	; 0x52e8 <printf>
	if (fr != FR_OK)
     c1e:	0f 90       	pop	r0
     c20:	0f 90       	pop	r0
     c22:	0f 90       	pop	r0
     c24:	0f 90       	pop	r0
     c26:	11 23       	and	r17, r17
     c28:	79 f0       	breq	.+30     	; 0xc48 <main+0x108>
	
    while(1)
    {
	 
    }
     c2a:	80 e0       	ldi	r24, 0x00	; 0
     c2c:	90 e0       	ldi	r25, 0x00	; 0
     c2e:	0f 90       	pop	r0
     c30:	0f 90       	pop	r0
     c32:	0f 90       	pop	r0
     c34:	0f 90       	pop	r0
     c36:	df 91       	pop	r29
     c38:	cf 91       	pop	r28
     c3a:	1f 91       	pop	r17
     c3c:	0f 91       	pop	r16
     c3e:	ff 90       	pop	r15
     c40:	ef 90       	pop	r14
     c42:	df 90       	pop	r13
     c44:	cf 90       	pop	r12
     c46:	08 95       	ret
	//sprintf(&Buff, "image.bmp");
	fr = f_open(&Files[0], "/log.txt", FA_WRITE | FA_CREATE_ALWAYS);
	printf("Open File : %d\n", fr);
	if (fr != FR_OK)
		return 0;
	f_write(&Files[0], "System Startup Complete.\n", 16, &a);
     c48:	0f 2e       	mov	r0, r31
     c4a:	f3 e9       	ldi	r31, 0x93	; 147
     c4c:	ef 2e       	mov	r14, r31
     c4e:	f4 e0       	ldi	r31, 0x04	; 4
     c50:	ff 2e       	mov	r15, r31
     c52:	f0 2d       	mov	r31, r0
     c54:	c7 01       	movw	r24, r14
     c56:	6e ef       	ldi	r22, 0xFE	; 254
     c58:	71 e0       	ldi	r23, 0x01	; 1
     c5a:	20 e1       	ldi	r18, 0x10	; 16
     c5c:	30 e0       	ldi	r19, 0x00	; 0
     c5e:	40 e0       	ldi	r20, 0x00	; 0
     c60:	50 e0       	ldi	r21, 0x00	; 0
     c62:	8e 01       	movw	r16, r28
     c64:	0f 5f       	subi	r16, 0xFF	; 255
     c66:	1f 4f       	sbci	r17, 0xFF	; 255
     c68:	0e 94 4e 1a 	call	0x349c	; 0x349c <f_write>
	f_close(&Files[0]);
     c6c:	c7 01       	movw	r24, r14
     c6e:	0e 94 07 1d 	call	0x3a0e	; 0x3a0e <f_close>
	printf("Starting Camera Initialise...\n");
     c72:	88 e1       	ldi	r24, 0x18	; 24
     c74:	92 e0       	ldi	r25, 0x02	; 2
     c76:	0e 94 89 29 	call	0x5312	; 0x5312 <puts>
	FIFO_init();
     c7a:	0e 94 d5 26 	call	0x4daa	; 0x4daa <FIFO_init>
	b = OV7670_init();
     c7e:	0e 94 78 26 	call	0x4cf0	; 0x4cf0 <OV7670_init>
	
	printf( "OV7670_0 initialised with exit code %d\n", b);
     c82:	00 d0       	rcall	.+0      	; 0xc84 <main+0x144>
     c84:	00 d0       	rcall	.+0      	; 0xc86 <main+0x146>
     c86:	ed b7       	in	r30, 0x3d	; 61
     c88:	fe b7       	in	r31, 0x3e	; 62
     c8a:	31 96       	adiw	r30, 0x01	; 1
     c8c:	26 e3       	ldi	r18, 0x36	; 54
     c8e:	32 e0       	ldi	r19, 0x02	; 2
     c90:	ad b7       	in	r26, 0x3d	; 61
     c92:	be b7       	in	r27, 0x3e	; 62
     c94:	12 96       	adiw	r26, 0x02	; 2
     c96:	3c 93       	st	X, r19
     c98:	2e 93       	st	-X, r18
     c9a:	11 97       	sbiw	r26, 0x01	; 1
     c9c:	82 83       	std	Z+2, r24	; 0x02
     c9e:	13 82       	std	Z+3, r1	; 0x03
     ca0:	0e 94 74 29 	call	0x52e8	; 0x52e8 <printf>
	//f_write(&Files[0], &Buff, sizeof(Buff), &a);
	
	
	
	printf("Image file opening.\n");
     ca4:	0f 90       	pop	r0
     ca6:	0f 90       	pop	r0
     ca8:	0f 90       	pop	r0
     caa:	0f 90       	pop	r0
     cac:	8e e5       	ldi	r24, 0x5E	; 94
     cae:	92 e0       	ldi	r25, 0x02	; 2
     cb0:	0e 94 89 29 	call	0x5312	; 0x5312 <puts>
	//f_write(&File[0], &Buff, sizeof(Buff), &a);
	fr =f_open(&Files[0], "image1.bmp", FA_CREATE_ALWAYS | FA_WRITE);
     cb4:	02 e7       	ldi	r16, 0x72	; 114
     cb6:	12 e0       	ldi	r17, 0x02	; 2
     cb8:	c7 01       	movw	r24, r14
     cba:	b8 01       	movw	r22, r16
     cbc:	4a e0       	ldi	r20, 0x0A	; 10
     cbe:	0e 94 f8 16 	call	0x2df0	; 0x2df0 <f_open>
	printf("File Opened : %d\n", fr);
     cc2:	00 d0       	rcall	.+0      	; 0xcc4 <main+0x184>
     cc4:	00 d0       	rcall	.+0      	; 0xcc6 <main+0x186>
     cc6:	ed b7       	in	r30, 0x3d	; 61
     cc8:	fe b7       	in	r31, 0x3e	; 62
     cca:	31 96       	adiw	r30, 0x01	; 1
     ccc:	0f 2e       	mov	r0, r31
     cce:	fd e7       	ldi	r31, 0x7D	; 125
     cd0:	cf 2e       	mov	r12, r31
     cd2:	f2 e0       	ldi	r31, 0x02	; 2
     cd4:	df 2e       	mov	r13, r31
     cd6:	f0 2d       	mov	r31, r0
     cd8:	ad b7       	in	r26, 0x3d	; 61
     cda:	be b7       	in	r27, 0x3e	; 62
     cdc:	12 96       	adiw	r26, 0x02	; 2
     cde:	dc 92       	st	X, r13
     ce0:	ce 92       	st	-X, r12
     ce2:	11 97       	sbiw	r26, 0x01	; 1
     ce4:	82 83       	std	Z+2, r24	; 0x02
     ce6:	13 82       	std	Z+3, r1	; 0x03
     ce8:	0e 94 74 29 	call	0x52e8	; 0x52e8 <printf>
	f_lseek(&Files[0], 155000);
     cec:	0f 90       	pop	r0
     cee:	0f 90       	pop	r0
     cf0:	0f 90       	pop	r0
     cf2:	0f 90       	pop	r0
     cf4:	c7 01       	movw	r24, r14
     cf6:	48 e7       	ldi	r20, 0x78	; 120
     cf8:	5d e5       	ldi	r21, 0x5D	; 93
     cfa:	62 e0       	ldi	r22, 0x02	; 2
     cfc:	70 e0       	ldi	r23, 0x00	; 0
     cfe:	0e 94 73 1d 	call	0x3ae6	; 0x3ae6 <f_lseek>
	printf("File Size exercised.\n");
     d02:	8f e8       	ldi	r24, 0x8F	; 143
     d04:	92 e0       	ldi	r25, 0x02	; 2
     d06:	0e 94 89 29 	call	0x5312	; 0x5312 <puts>
	f_lseek(&Files[0], 0);
     d0a:	c7 01       	movw	r24, r14
     d0c:	40 e0       	ldi	r20, 0x00	; 0
     d0e:	50 e0       	ldi	r21, 0x00	; 0
     d10:	ba 01       	movw	r22, r20
     d12:	0e 94 73 1d 	call	0x3ae6	; 0x3ae6 <f_lseek>
	printf("Closing File 1: %d\n", f_close(&Files[0]));
     d16:	c7 01       	movw	r24, r14
     d18:	0e 94 07 1d 	call	0x3a0e	; 0x3a0e <f_close>
     d1c:	00 d0       	rcall	.+0      	; 0xd1e <main+0x1de>
     d1e:	00 d0       	rcall	.+0      	; 0xd20 <main+0x1e0>
     d20:	ed b7       	in	r30, 0x3d	; 61
     d22:	fe b7       	in	r31, 0x3e	; 62
     d24:	31 96       	adiw	r30, 0x01	; 1
     d26:	24 ea       	ldi	r18, 0xA4	; 164
     d28:	32 e0       	ldi	r19, 0x02	; 2
     d2a:	ad b7       	in	r26, 0x3d	; 61
     d2c:	be b7       	in	r27, 0x3e	; 62
     d2e:	12 96       	adiw	r26, 0x02	; 2
     d30:	3c 93       	st	X, r19
     d32:	2e 93       	st	-X, r18
     d34:	11 97       	sbiw	r26, 0x01	; 1
     d36:	82 83       	std	Z+2, r24	; 0x02
     d38:	13 82       	std	Z+3, r1	; 0x03
     d3a:	0e 94 74 29 	call	0x52e8	; 0x52e8 <printf>
	fr =f_open(&Files[0], "image1.bmp", FA_WRITE);
     d3e:	0f 90       	pop	r0
     d40:	0f 90       	pop	r0
     d42:	0f 90       	pop	r0
     d44:	0f 90       	pop	r0
     d46:	c7 01       	movw	r24, r14
     d48:	b8 01       	movw	r22, r16
     d4a:	42 e0       	ldi	r20, 0x02	; 2
     d4c:	0e 94 f8 16 	call	0x2df0	; 0x2df0 <f_open>
	printf("File Opened : %d\n", fr);
     d50:	00 d0       	rcall	.+0      	; 0xd52 <main+0x212>
     d52:	00 d0       	rcall	.+0      	; 0xd54 <main+0x214>
     d54:	ed b7       	in	r30, 0x3d	; 61
     d56:	fe b7       	in	r31, 0x3e	; 62
     d58:	31 96       	adiw	r30, 0x01	; 1
     d5a:	ad b7       	in	r26, 0x3d	; 61
     d5c:	be b7       	in	r27, 0x3e	; 62
     d5e:	12 96       	adiw	r26, 0x02	; 2
     d60:	dc 92       	st	X, r13
     d62:	ce 92       	st	-X, r12
     d64:	11 97       	sbiw	r26, 0x01	; 1
     d66:	82 83       	std	Z+2, r24	; 0x02
     d68:	13 82       	std	Z+3, r1	; 0x03
     d6a:	0e 94 74 29 	call	0x52e8	; 0x52e8 <printf>
	printf("Write BMP Header.\n");
     d6e:	0f 90       	pop	r0
     d70:	0f 90       	pop	r0
     d72:	0f 90       	pop	r0
     d74:	0f 90       	pop	r0
     d76:	88 eb       	ldi	r24, 0xB8	; 184
     d78:	92 e0       	ldi	r25, 0x02	; 2
     d7a:	0e 94 89 29 	call	0x5312	; 0x5312 <puts>
	WriteBMPHeader(&Files[0]);
     d7e:	c7 01       	movw	r24, r14
     d80:	0e 94 5d 00 	call	0xba	; 0xba <WriteBMPHeader>
	printf("Write DIB Header.\n");
     d84:	8a ec       	ldi	r24, 0xCA	; 202
     d86:	92 e0       	ldi	r25, 0x02	; 2
     d88:	0e 94 89 29 	call	0x5312	; 0x5312 <puts>
	WriteDIBHeader(&Files[0]);
     d8c:	c7 01       	movw	r24, r14
     d8e:	0e 94 80 00 	call	0x100	; 0x100 <WriteDIBHeader>
	LoadImageToBuffer();
     d92:	0e 94 ba 26 	call	0x4d74	; 0x4d74 <LoadImageToBuffer>
	while(0 != GetImageIfAvailiable(DIBHEADERSIZE + BMPHEADERSIZE)) 
     d96:	8a e8       	ldi	r24, 0x8A	; 138
     d98:	90 e0       	ldi	r25, 0x00	; 0
     d9a:	0e 94 02 27 	call	0x4e04	; 0x4e04 <GetImageIfAvailiable>
     d9e:	88 23       	and	r24, r24
     da0:	d1 f7       	brne	.-12     	; 0xd96 <main+0x256>
		;
	printf("Photo Taken\n");
     da2:	8c ed       	ldi	r24, 0xDC	; 220
     da4:	92 e0       	ldi	r25, 0x02	; 2
     da6:	0e 94 89 29 	call	0x5312	; 0x5312 <puts>
     daa:	ff cf       	rjmp	.-2      	; 0xdaa <main+0x26a>

00000dac <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
     dac:	e6 2f       	mov	r30, r22
     dae:	f7 2f       	mov	r31, r23
     db0:	ba 01       	movw	r22, r20
     db2:	a9 01       	movw	r20, r18
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
     db4:	41 15       	cp	r20, r1
     db6:	51 05       	cpc	r21, r1
     db8:	61 05       	cpc	r22, r1
     dba:	71 05       	cpc	r23, r1
     dbc:	59 f0       	breq	.+22     	; 0xdd4 <mem_cpy+0x28>
     dbe:	ae 2f       	mov	r26, r30
     dc0:	bf 2f       	mov	r27, r31
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
     dc2:	e8 2f       	mov	r30, r24
     dc4:	f9 2f       	mov	r31, r25
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
     dc6:	8d 91       	ld	r24, X+
     dc8:	81 93       	st	Z+, r24
     dca:	41 50       	subi	r20, 0x01	; 1
     dcc:	50 40       	sbci	r21, 0x00	; 0
     dce:	60 40       	sbci	r22, 0x00	; 0
     dd0:	70 40       	sbci	r23, 0x00	; 0
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
     dd2:	c9 f7       	brne	.-14     	; 0xdc6 <mem_cpy+0x1a>
     dd4:	08 95       	ret

00000dd6 <mem_set>:
		*d++ = *s++;
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
     dd6:	a6 2f       	mov	r26, r22
     dd8:	ba 01       	movw	r22, r20
     dda:	a9 01       	movw	r20, r18
	BYTE *d = (BYTE*)dst;

	while (cnt--)
     ddc:	41 15       	cp	r20, r1
     dde:	51 05       	cpc	r21, r1
     de0:	61 05       	cpc	r22, r1
     de2:	71 05       	cpc	r23, r1
     de4:	41 f0       	breq	.+16     	; 0xdf6 <mem_set+0x20>
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
     de6:	e8 2f       	mov	r30, r24
     de8:	f9 2f       	mov	r31, r25

	while (cnt--)
		*d++ = (BYTE)val;
     dea:	a1 93       	st	Z+, r26
     dec:	41 50       	subi	r20, 0x01	; 1
     dee:	50 40       	sbci	r21, 0x00	; 0
     df0:	60 40       	sbci	r22, 0x00	; 0
     df2:	70 40       	sbci	r23, 0x00	; 0
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
     df4:	d1 f7       	brne	.-12     	; 0xdea <mem_set+0x14>
     df6:	08 95       	ret

00000df8 <ld_clust>:
static
DWORD ld_clust (
	FATFS *fs,	/* Pointer to the fs object */
	BYTE *dir	/* Pointer to the directory entry */
)
{
     df8:	0f 93       	push	r16
     dfa:	1f 93       	push	r17
     dfc:	dc 01       	movw	r26, r24
     dfe:	fb 01       	movw	r30, r22
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
     e00:	93 8d       	ldd	r25, Z+27	; 0x1b
     e02:	80 e0       	ldi	r24, 0x00	; 0
     e04:	02 8d       	ldd	r16, Z+26	; 0x1a
     e06:	10 e0       	ldi	r17, 0x00	; 0
     e08:	08 2b       	or	r16, r24
     e0a:	19 2b       	or	r17, r25
     e0c:	20 e0       	ldi	r18, 0x00	; 0
     e0e:	30 e0       	ldi	r19, 0x00	; 0
	if (fs->fs_type == FS_FAT32)
     e10:	8c 91       	ld	r24, X
     e12:	83 30       	cpi	r24, 0x03	; 3
     e14:	79 f4       	brne	.+30     	; 0xe34 <ld_clust+0x3c>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
     e16:	55 89       	ldd	r21, Z+21	; 0x15
     e18:	40 e0       	ldi	r20, 0x00	; 0
     e1a:	84 89       	ldd	r24, Z+20	; 0x14
     e1c:	90 e0       	ldi	r25, 0x00	; 0
     e1e:	84 2b       	or	r24, r20
     e20:	95 2b       	or	r25, r21
     e22:	a0 e0       	ldi	r26, 0x00	; 0
     e24:	b0 e0       	ldi	r27, 0x00	; 0
     e26:	dc 01       	movw	r26, r24
     e28:	99 27       	eor	r25, r25
     e2a:	88 27       	eor	r24, r24
     e2c:	08 2b       	or	r16, r24
     e2e:	19 2b       	or	r17, r25
     e30:	2a 2b       	or	r18, r26
     e32:	3b 2b       	or	r19, r27

	return cl;
}
     e34:	60 2f       	mov	r22, r16
     e36:	71 2f       	mov	r23, r17
     e38:	82 2f       	mov	r24, r18
     e3a:	93 2f       	mov	r25, r19
     e3c:	1f 91       	pop	r17
     e3e:	0f 91       	pop	r16
     e40:	08 95       	ret

00000e42 <st_clust>:
static
void st_clust (
	BYTE *dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
     e42:	fc 01       	movw	r30, r24
	ST_WORD(dir+DIR_FstClusLO, cl);
     e44:	42 8f       	std	Z+26, r20	; 0x1a
     e46:	53 8f       	std	Z+27, r21	; 0x1b
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
     e48:	ab 01       	movw	r20, r22
     e4a:	66 27       	eor	r22, r22
     e4c:	77 27       	eor	r23, r23
     e4e:	44 8b       	std	Z+20, r20	; 0x14
     e50:	55 8b       	std	Z+21, r21	; 0x15
}
     e52:	08 95       	ret

00000e54 <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to the file information to be filled */
)
{
     e54:	ef 92       	push	r14
     e56:	ff 92       	push	r15
     e58:	0f 93       	push	r16
     e5a:	1f 93       	push	r17
     e5c:	cf 93       	push	r28
     e5e:	df 93       	push	r29
     e60:	fc 01       	movw	r30, r24
     e62:	7b 01       	movw	r14, r22
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
     e64:	8b 01       	movw	r16, r22
     e66:	07 5f       	subi	r16, 0xF7	; 247
     e68:	1f 4f       	sbci	r17, 0xFF	; 255
	if (dj->sect) {
     e6a:	86 85       	ldd	r24, Z+14	; 0x0e
     e6c:	97 85       	ldd	r25, Z+15	; 0x0f
     e6e:	a0 89       	ldd	r26, Z+16	; 0x10
     e70:	b1 89       	ldd	r27, Z+17	; 0x11
     e72:	00 97       	sbiw	r24, 0x00	; 0
     e74:	a1 05       	cpc	r26, r1
     e76:	b1 05       	cpc	r27, r1
     e78:	09 f4       	brne	.+2      	; 0xe7c <get_fileinfo+0x28>
     e7a:	65 c0       	rjmp	.+202    	; 0xf46 <get_fileinfo+0xf2>
		dir = dj->dir;
     e7c:	c2 89       	ldd	r28, Z+18	; 0x12
     e7e:	d3 89       	ldd	r29, Z+19	; 0x13
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
     e80:	28 81       	ld	r18, Y
			if (c == ' ') break;
     e82:	20 32       	cpi	r18, 0x20	; 32
     e84:	99 f0       	breq	.+38     	; 0xeac <get_fileinfo+0x58>
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
     e86:	de 01       	movw	r26, r28
     e88:	11 96       	adiw	r26, 0x01	; 1
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
     e8a:	f8 01       	movw	r30, r16
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1
static
void get_fileinfo (		/* No return code */
     e8c:	80 e0       	ldi	r24, 0x00	; 0
     e8e:	90 e0       	ldi	r25, 0x00	; 0
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
     e90:	35 ee       	ldi	r19, 0xE5	; 229
     e92:	04 c0       	rjmp	.+8      	; 0xe9c <get_fileinfo+0x48>
	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
     e94:	2d 91       	ld	r18, X+
     e96:	01 96       	adiw	r24, 0x01	; 1
			if (c == ' ') break;
     e98:	20 32       	cpi	r18, 0x20	; 32
     e9a:	41 f0       	breq	.+16     	; 0xeac <get_fileinfo+0x58>
			if (c == NDDE) c = (TCHAR)DDE;
     e9c:	25 30       	cpi	r18, 0x05	; 5
     e9e:	09 f4       	brne	.+2      	; 0xea2 <get_fileinfo+0x4e>
     ea0:	23 2f       	mov	r18, r19
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
     ea2:	21 93       	st	Z+, r18
     ea4:	8f 01       	movw	r16, r30

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
     ea6:	87 30       	cpi	r24, 0x07	; 7
     ea8:	91 05       	cpc	r25, r1
     eaa:	a1 f7       	brne	.-24     	; 0xe94 <get_fileinfo+0x40>
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
     eac:	88 85       	ldd	r24, Y+8	; 0x08
     eae:	80 32       	cpi	r24, 0x20	; 32
     eb0:	81 f0       	breq	.+32     	; 0xed2 <get_fileinfo+0x7e>
			*p++ = '.';
     eb2:	8e e2       	ldi	r24, 0x2E	; 46
     eb4:	f8 01       	movw	r30, r16
     eb6:	80 83       	st	Z, r24
			for (i = 8; i < 11; i++) {
				c = dir[i];
     eb8:	88 85       	ldd	r24, Y+8	; 0x08
				if (c == ' ') break;
     eba:	80 32       	cpi	r24, 0x20	; 32
     ebc:	09 f0       	breq	.+2      	; 0xec0 <get_fileinfo+0x6c>
     ebe:	4c c0       	rjmp	.+152    	; 0xf58 <get_fileinfo+0x104>
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
     ec0:	0f 5f       	subi	r16, 0xFF	; 255
     ec2:	1f 4f       	sbci	r17, 0xFF	; 255
     ec4:	06 c0       	rjmp	.+12     	; 0xed2 <get_fileinfo+0x7e>
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
     ec6:	8c 01       	movw	r16, r24
     ec8:	04 c0       	rjmp	.+8      	; 0xed2 <get_fileinfo+0x7e>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
     eca:	f8 01       	movw	r30, r16
     ecc:	23 83       	std	Z+3, r18	; 0x03
     ece:	0c 5f       	subi	r16, 0xFC	; 252
     ed0:	1f 4f       	sbci	r17, 0xFF	; 255
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
     ed2:	8b 85       	ldd	r24, Y+11	; 0x0b
     ed4:	f7 01       	movw	r30, r14
     ed6:	80 87       	std	Z+8, r24	; 0x08
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
     ed8:	8f 8d       	ldd	r24, Y+31	; 0x1f
     eda:	90 e0       	ldi	r25, 0x00	; 0
     edc:	a0 e0       	ldi	r26, 0x00	; 0
     ede:	b0 e0       	ldi	r27, 0x00	; 0
     ee0:	b8 2f       	mov	r27, r24
     ee2:	aa 27       	eor	r26, r26
     ee4:	99 27       	eor	r25, r25
     ee6:	88 27       	eor	r24, r24
     ee8:	4e 8d       	ldd	r20, Y+30	; 0x1e
     eea:	50 e0       	ldi	r21, 0x00	; 0
     eec:	60 e0       	ldi	r22, 0x00	; 0
     eee:	70 e0       	ldi	r23, 0x00	; 0
     ef0:	ba 01       	movw	r22, r20
     ef2:	55 27       	eor	r21, r21
     ef4:	44 27       	eor	r20, r20
     ef6:	48 2b       	or	r20, r24
     ef8:	59 2b       	or	r21, r25
     efa:	6a 2b       	or	r22, r26
     efc:	7b 2b       	or	r23, r27
     efe:	8c 8d       	ldd	r24, Y+28	; 0x1c
     f00:	90 e0       	ldi	r25, 0x00	; 0
     f02:	a0 e0       	ldi	r26, 0x00	; 0
     f04:	b0 e0       	ldi	r27, 0x00	; 0
     f06:	48 2b       	or	r20, r24
     f08:	59 2b       	or	r21, r25
     f0a:	6a 2b       	or	r22, r26
     f0c:	7b 2b       	or	r23, r27
     f0e:	9d 8d       	ldd	r25, Y+29	; 0x1d
     f10:	80 e0       	ldi	r24, 0x00	; 0
     f12:	a0 e0       	ldi	r26, 0x00	; 0
     f14:	b0 e0       	ldi	r27, 0x00	; 0
     f16:	84 2b       	or	r24, r20
     f18:	95 2b       	or	r25, r21
     f1a:	a6 2b       	or	r26, r22
     f1c:	b7 2b       	or	r27, r23
     f1e:	80 83       	st	Z, r24
     f20:	91 83       	std	Z+1, r25	; 0x01
     f22:	a2 83       	std	Z+2, r26	; 0x02
     f24:	b3 83       	std	Z+3, r27	; 0x03
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
     f26:	39 8d       	ldd	r19, Y+25	; 0x19
     f28:	20 e0       	ldi	r18, 0x00	; 0
     f2a:	88 8d       	ldd	r24, Y+24	; 0x18
     f2c:	90 e0       	ldi	r25, 0x00	; 0
     f2e:	82 2b       	or	r24, r18
     f30:	93 2b       	or	r25, r19
     f32:	95 83       	std	Z+5, r25	; 0x05
     f34:	84 83       	std	Z+4, r24	; 0x04
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
     f36:	9f 89       	ldd	r25, Y+23	; 0x17
     f38:	80 e0       	ldi	r24, 0x00	; 0
     f3a:	2e 89       	ldd	r18, Y+22	; 0x16
     f3c:	30 e0       	ldi	r19, 0x00	; 0
     f3e:	82 2b       	or	r24, r18
     f40:	93 2b       	or	r25, r19
     f42:	97 83       	std	Z+7, r25	; 0x07
     f44:	86 83       	std	Z+6, r24	; 0x06
	}
	*p = 0;		/* Terminate SFN str by a \0 */
     f46:	f8 01       	movw	r30, r16
     f48:	10 82       	st	Z, r1
			}
		}
		tp[i] = 0;	/* Terminate the LFN str by a \0 */
	}
#endif
}
     f4a:	df 91       	pop	r29
     f4c:	cf 91       	pop	r28
     f4e:	1f 91       	pop	r17
     f50:	0f 91       	pop	r16
     f52:	ff 90       	pop	r15
     f54:	ef 90       	pop	r14
     f56:	08 95       	ret
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
     f58:	f8 01       	movw	r30, r16
     f5a:	81 83       	std	Z+1, r24	; 0x01
     f5c:	c8 01       	movw	r24, r16
     f5e:	02 96       	adiw	r24, 0x02	; 2
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
     f60:	29 85       	ldd	r18, Y+9	; 0x09
				if (c == ' ') break;
     f62:	20 32       	cpi	r18, 0x20	; 32
     f64:	09 f4       	brne	.+2      	; 0xf68 <get_fileinfo+0x114>
     f66:	af cf       	rjmp	.-162    	; 0xec6 <get_fileinfo+0x72>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
     f68:	22 83       	std	Z+2, r18	; 0x02
     f6a:	c8 01       	movw	r24, r16
     f6c:	03 96       	adiw	r24, 0x03	; 3
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
     f6e:	2a 85       	ldd	r18, Y+10	; 0x0a
				if (c == ' ') break;
     f70:	20 32       	cpi	r18, 0x20	; 32
     f72:	09 f0       	breq	.+2      	; 0xf76 <get_fileinfo+0x122>
     f74:	aa cf       	rjmp	.-172    	; 0xeca <get_fileinfo+0x76>
     f76:	a7 cf       	rjmp	.-178    	; 0xec6 <get_fileinfo+0x72>

00000f78 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
     f78:	dc 01       	movw	r26, r24
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
     f7a:	ed 91       	ld	r30, X+
     f7c:	fc 91       	ld	r31, X
     f7e:	11 97       	sbiw	r26, 0x01	; 1
     f80:	30 97       	sbiw	r30, 0x00	; 0
     f82:	99 f0       	breq	.+38     	; 0xfaa <validate+0x32>
     f84:	80 81       	ld	r24, Z
     f86:	88 23       	and	r24, r24
     f88:	91 f0       	breq	.+36     	; 0xfae <validate+0x36>
     f8a:	26 81       	ldd	r18, Z+6	; 0x06
     f8c:	37 81       	ldd	r19, Z+7	; 0x07
     f8e:	12 96       	adiw	r26, 0x02	; 2
     f90:	8d 91       	ld	r24, X+
     f92:	9c 91       	ld	r25, X
     f94:	13 97       	sbiw	r26, 0x03	; 3
     f96:	28 17       	cp	r18, r24
     f98:	39 07       	cpc	r19, r25
     f9a:	59 f4       	brne	.+22     	; 0xfb2 <validate+0x3a>
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
     f9c:	81 81       	ldd	r24, Z+1	; 0x01
     f9e:	0e 94 8c 02 	call	0x518	; 0x518 <disk_status>
     fa2:	80 ff       	sbrs	r24, 0
     fa4:	08 c0       	rjmp	.+16     	; 0xfb6 <validate+0x3e>
		return FR_NOT_READY;
     fa6:	83 e0       	ldi	r24, 0x03	; 3
     fa8:	08 95       	ret
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
		return FR_INVALID_OBJECT;
     faa:	89 e0       	ldi	r24, 0x09	; 9
     fac:	08 95       	ret
     fae:	89 e0       	ldi	r24, 0x09	; 9
     fb0:	08 95       	ret
     fb2:	89 e0       	ldi	r24, 0x09	; 9
     fb4:	08 95       	ret
	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
     fb6:	80 e0       	ldi	r24, 0x00	; 0
}
     fb8:	08 95       	ret

00000fba <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
     fba:	0f 93       	push	r16
     fbc:	cf 93       	push	r28
     fbe:	df 93       	push	r29
     fc0:	ec 01       	movw	r28, r24
     fc2:	9a 01       	movw	r18, r20
     fc4:	ab 01       	movw	r20, r22
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
     fc6:	bc 01       	movw	r22, r24
     fc8:	6e 5c       	subi	r22, 0xCE	; 206
     fca:	7f 4f       	sbci	r23, 0xFF	; 255
     fcc:	89 81       	ldd	r24, Y+1	; 0x01
     fce:	01 e0       	ldi	r16, 0x01	; 1
     fd0:	0e 94 93 02 	call	0x526	; 0x526 <disk_read>
     fd4:	88 23       	and	r24, r24
     fd6:	09 f0       	breq	.+2      	; 0xfda <check_fs+0x20>
     fd8:	83 c0       	rjmp	.+262    	; 0x10e0 <check_fs+0x126>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
     fda:	fe 01       	movw	r30, r28
     fdc:	ef 5c       	subi	r30, 0xCF	; 207
     fde:	fd 4f       	sbci	r31, 0xFD	; 253
     fe0:	90 81       	ld	r25, Z
     fe2:	80 e0       	ldi	r24, 0x00	; 0
     fe4:	fe 01       	movw	r30, r28
     fe6:	e0 5d       	subi	r30, 0xD0	; 208
     fe8:	fd 4f       	sbci	r31, 0xFD	; 253
     fea:	20 81       	ld	r18, Z
     fec:	30 e0       	ldi	r19, 0x00	; 0
     fee:	82 2b       	or	r24, r18
     ff0:	93 2b       	or	r25, r19
     ff2:	2a ea       	ldi	r18, 0xAA	; 170
     ff4:	85 35       	cpi	r24, 0x55	; 85
     ff6:	92 07       	cpc	r25, r18
     ff8:	09 f0       	breq	.+2      	; 0xffc <check_fs+0x42>
     ffa:	74 c0       	rjmp	.+232    	; 0x10e4 <check_fs+0x12a>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
     ffc:	fe 01       	movw	r30, r28
     ffe:	e5 59       	subi	r30, 0x95	; 149
    1000:	ff 4f       	sbci	r31, 0xFF	; 255
    1002:	80 81       	ld	r24, Z
    1004:	90 e0       	ldi	r25, 0x00	; 0
    1006:	a0 e0       	ldi	r26, 0x00	; 0
    1008:	b0 e0       	ldi	r27, 0x00	; 0
    100a:	b8 2f       	mov	r27, r24
    100c:	aa 27       	eor	r26, r26
    100e:	99 27       	eor	r25, r25
    1010:	88 27       	eor	r24, r24
    1012:	fe 01       	movw	r30, r28
    1014:	e6 59       	subi	r30, 0x96	; 150
    1016:	ff 4f       	sbci	r31, 0xFF	; 255
    1018:	40 81       	ld	r20, Z
    101a:	50 e0       	ldi	r21, 0x00	; 0
    101c:	60 e0       	ldi	r22, 0x00	; 0
    101e:	70 e0       	ldi	r23, 0x00	; 0
    1020:	ba 01       	movw	r22, r20
    1022:	55 27       	eor	r21, r21
    1024:	44 27       	eor	r20, r20
    1026:	48 2b       	or	r20, r24
    1028:	59 2b       	or	r21, r25
    102a:	6a 2b       	or	r22, r26
    102c:	7b 2b       	or	r23, r27
    102e:	fe 01       	movw	r30, r28
    1030:	e8 59       	subi	r30, 0x98	; 152
    1032:	ff 4f       	sbci	r31, 0xFF	; 255
    1034:	80 81       	ld	r24, Z
    1036:	90 e0       	ldi	r25, 0x00	; 0
    1038:	a0 e0       	ldi	r26, 0x00	; 0
    103a:	b0 e0       	ldi	r27, 0x00	; 0
    103c:	48 2b       	or	r20, r24
    103e:	59 2b       	or	r21, r25
    1040:	6a 2b       	or	r22, r26
    1042:	7b 2b       	or	r23, r27
    1044:	fe 01       	movw	r30, r28
    1046:	e7 59       	subi	r30, 0x97	; 151
    1048:	ff 4f       	sbci	r31, 0xFF	; 255
    104a:	90 81       	ld	r25, Z
    104c:	80 e0       	ldi	r24, 0x00	; 0
    104e:	a0 e0       	ldi	r26, 0x00	; 0
    1050:	b0 e0       	ldi	r27, 0x00	; 0
    1052:	48 2b       	or	r20, r24
    1054:	59 2b       	or	r21, r25
    1056:	6a 2b       	or	r22, r26
    1058:	7b 2b       	or	r23, r27
    105a:	70 70       	andi	r23, 0x00	; 0
    105c:	46 34       	cpi	r20, 0x46	; 70
    105e:	81 e4       	ldi	r24, 0x41	; 65
    1060:	58 07       	cpc	r21, r24
    1062:	84 e5       	ldi	r24, 0x54	; 84
    1064:	68 07       	cpc	r22, r24
    1066:	80 e0       	ldi	r24, 0x00	; 0
    1068:	78 07       	cpc	r23, r24
    106a:	f1 f1       	breq	.+124    	; 0x10e8 <check_fs+0x12e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    106c:	fe 01       	movw	r30, r28
    106e:	e9 57       	subi	r30, 0x79	; 121
    1070:	ff 4f       	sbci	r31, 0xFF	; 255
    1072:	80 81       	ld	r24, Z
    1074:	90 e0       	ldi	r25, 0x00	; 0
    1076:	a0 e0       	ldi	r26, 0x00	; 0
    1078:	b0 e0       	ldi	r27, 0x00	; 0
    107a:	b8 2f       	mov	r27, r24
    107c:	aa 27       	eor	r26, r26
    107e:	99 27       	eor	r25, r25
    1080:	88 27       	eor	r24, r24
    1082:	fe 01       	movw	r30, r28
    1084:	ea 57       	subi	r30, 0x7A	; 122
    1086:	ff 4f       	sbci	r31, 0xFF	; 255
    1088:	40 81       	ld	r20, Z
    108a:	50 e0       	ldi	r21, 0x00	; 0
    108c:	60 e0       	ldi	r22, 0x00	; 0
    108e:	70 e0       	ldi	r23, 0x00	; 0
    1090:	ba 01       	movw	r22, r20
    1092:	55 27       	eor	r21, r21
    1094:	44 27       	eor	r20, r20
    1096:	48 2b       	or	r20, r24
    1098:	59 2b       	or	r21, r25
    109a:	6a 2b       	or	r22, r26
    109c:	7b 2b       	or	r23, r27
    109e:	fe 01       	movw	r30, r28
    10a0:	ec 57       	subi	r30, 0x7C	; 124
    10a2:	ff 4f       	sbci	r31, 0xFF	; 255
    10a4:	80 81       	ld	r24, Z
    10a6:	90 e0       	ldi	r25, 0x00	; 0
    10a8:	a0 e0       	ldi	r26, 0x00	; 0
    10aa:	b0 e0       	ldi	r27, 0x00	; 0
    10ac:	48 2b       	or	r20, r24
    10ae:	59 2b       	or	r21, r25
    10b0:	6a 2b       	or	r22, r26
    10b2:	7b 2b       	or	r23, r27
    10b4:	cb 57       	subi	r28, 0x7B	; 123
    10b6:	df 4f       	sbci	r29, 0xFF	; 255
    10b8:	98 81       	ld	r25, Y
    10ba:	80 e0       	ldi	r24, 0x00	; 0
    10bc:	a0 e0       	ldi	r26, 0x00	; 0
    10be:	b0 e0       	ldi	r27, 0x00	; 0
    10c0:	48 2b       	or	r20, r24
    10c2:	59 2b       	or	r21, r25
    10c4:	6a 2b       	or	r22, r26
    10c6:	7b 2b       	or	r23, r27
    10c8:	70 70       	andi	r23, 0x00	; 0
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
    10ca:	81 e0       	ldi	r24, 0x01	; 1
    10cc:	46 34       	cpi	r20, 0x46	; 70
    10ce:	91 e4       	ldi	r25, 0x41	; 65
    10d0:	59 07       	cpc	r21, r25
    10d2:	94 e5       	ldi	r25, 0x54	; 84
    10d4:	69 07       	cpc	r22, r25
    10d6:	90 e0       	ldi	r25, 0x00	; 0
    10d8:	79 07       	cpc	r23, r25
    10da:	39 f4       	brne	.+14     	; 0x10ea <check_fs+0x130>
    10dc:	80 e0       	ldi	r24, 0x00	; 0
    10de:	05 c0       	rjmp	.+10     	; 0x10ea <check_fs+0x130>
    10e0:	83 e0       	ldi	r24, 0x03	; 3
    10e2:	03 c0       	rjmp	.+6      	; 0x10ea <check_fs+0x130>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
    10e4:	82 e0       	ldi	r24, 0x02	; 2
    10e6:	01 c0       	rjmp	.+2      	; 0x10ea <check_fs+0x130>

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;
    10e8:	80 e0       	ldi	r24, 0x00	; 0
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
    10ea:	df 91       	pop	r29
    10ec:	cf 91       	pop	r28
    10ee:	0f 91       	pop	r16
    10f0:	08 95       	ret

000010f2 <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
    10f2:	2f 92       	push	r2
    10f4:	3f 92       	push	r3
    10f6:	4f 92       	push	r4
    10f8:	5f 92       	push	r5
    10fa:	6f 92       	push	r6
    10fc:	7f 92       	push	r7
    10fe:	8f 92       	push	r8
    1100:	9f 92       	push	r9
    1102:	af 92       	push	r10
    1104:	bf 92       	push	r11
    1106:	cf 92       	push	r12
    1108:	df 92       	push	r13
    110a:	ef 92       	push	r14
    110c:	ff 92       	push	r15
    110e:	0f 93       	push	r16
    1110:	1f 93       	push	r17
    1112:	cf 93       	push	r28
    1114:	df 93       	push	r29
    1116:	cd b7       	in	r28, 0x3d	; 61
    1118:	de b7       	in	r29, 0x3e	; 62
    111a:	60 97       	sbiw	r28, 0x10	; 16
    111c:	0f b6       	in	r0, 0x3f	; 63
    111e:	f8 94       	cli
    1120:	de bf       	out	0x3e, r29	; 62
    1122:	0f be       	out	0x3f, r0	; 63
    1124:	cd bf       	out	0x3d, r28	; 61
    1126:	8b 01       	movw	r16, r22
    1128:	d4 2e       	mov	r13, r20
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
    112a:	dc 01       	movw	r26, r24
    112c:	ed 91       	ld	r30, X+
    112e:	fc 91       	ld	r31, X
    1130:	11 97       	sbiw	r26, 0x01	; 1
	FATFS *fs;


	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
    1132:	40 81       	ld	r20, Z
    1134:	50 e0       	ldi	r21, 0x00	; 0
    1136:	40 53       	subi	r20, 0x30	; 48
    1138:	50 40       	sbci	r21, 0x00	; 0
    113a:	66 27       	eor	r22, r22
    113c:	57 fd       	sbrc	r21, 7
    113e:	60 95       	com	r22
    1140:	76 2f       	mov	r23, r22
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    1142:	4a 30       	cpi	r20, 0x0A	; 10
    1144:	51 05       	cpc	r21, r1
    1146:	61 05       	cpc	r22, r1
    1148:	71 05       	cpc	r23, r1
    114a:	48 f4       	brcc	.+18     	; 0x115e <__stack+0x5f>
    114c:	81 81       	ldd	r24, Z+1	; 0x01
    114e:	8a 33       	cpi	r24, 0x3A	; 58
    1150:	31 f4       	brne	.+12     	; 0x115e <__stack+0x5f>
		p += 2; *path = p;				/* Return pointer to the path name */
    1152:	cf 01       	movw	r24, r30
    1154:	02 96       	adiw	r24, 0x02	; 2
    1156:	11 96       	adiw	r26, 0x01	; 1
    1158:	9c 93       	st	X, r25
    115a:	8e 93       	st	-X, r24
    115c:	05 c0       	rjmp	.+10     	; 0x1168 <__stack+0x69>
	} else {							/* No drive number is given */
#if _FS_RPATH
		vol = CurrVol;					/* Use current drive */
    115e:	40 91 89 04 	lds	r20, 0x0489
    1162:	50 e0       	ldi	r21, 0x00	; 0
    1164:	60 e0       	ldi	r22, 0x00	; 0
    1166:	70 e0       	ldi	r23, 0x00	; 0
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
    1168:	f8 01       	movw	r30, r16
    116a:	11 82       	std	Z+1, r1	; 0x01
    116c:	10 82       	st	Z, r1
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    116e:	41 15       	cp	r20, r1
    1170:	51 05       	cpc	r21, r1
    1172:	61 05       	cpc	r22, r1
    1174:	71 05       	cpc	r23, r1
    1176:	09 f0       	breq	.+2      	; 0x117a <__stack+0x7b>
    1178:	a3 c3       	rjmp	.+1862   	; 0x18c0 <__stack+0x7c1>
		return FR_INVALID_DRIVE;
	fs = FatFs[vol];					/* Get corresponding file system object */
    117a:	e0 90 87 04 	lds	r14, 0x0487
    117e:	f0 90 88 04 	lds	r15, 0x0488
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    1182:	e1 14       	cp	r14, r1
    1184:	f1 04       	cpc	r15, r1
    1186:	09 f4       	brne	.+2      	; 0x118a <__stack+0x8b>
    1188:	9d c3       	rjmp	.+1850   	; 0x18c4 <__stack+0x7c5>

	ENTER_FF(fs);						/* Lock file system */

	*rfs = fs;							/* Return pointer to the corresponding file system object */
    118a:	f1 82       	std	Z+1, r15	; 0x01
    118c:	e0 82       	st	Z, r14
	if (fs->fs_type) {					/* If the volume has been mounted */
    118e:	d7 01       	movw	r26, r14
    1190:	8c 91       	ld	r24, X
    1192:	88 23       	and	r24, r24
    1194:	69 f0       	breq	.+26     	; 0x11b0 <__stack+0xb1>
		stat = disk_status(fs->drv);
    1196:	11 96       	adiw	r26, 0x01	; 1
    1198:	8c 91       	ld	r24, X
    119a:	0e 94 8c 02 	call	0x518	; 0x518 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    119e:	80 fd       	sbrc	r24, 0
    11a0:	07 c0       	rjmp	.+14     	; 0x11b0 <__stack+0xb1>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
    11a2:	dd 20       	and	r13, r13
    11a4:	09 f4       	brne	.+2      	; 0x11a8 <__stack+0xa9>
    11a6:	90 c3       	rjmp	.+1824   	; 0x18c8 <__stack+0x7c9>
    11a8:	82 fd       	sbrc	r24, 2
    11aa:	90 c3       	rjmp	.+1824   	; 0x18cc <__stack+0x7cd>
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
    11ac:	80 e0       	ldi	r24, 0x00	; 0
    11ae:	af c3       	rjmp	.+1886   	; 0x190e <__stack+0x80f>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
    11b0:	f7 01       	movw	r30, r14
    11b2:	10 82       	st	Z, r1
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    11b4:	11 82       	std	Z+1, r1	; 0x01
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
    11b6:	80 e0       	ldi	r24, 0x00	; 0
    11b8:	0e 94 bc 01 	call	0x378	; 0x378 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    11bc:	80 fd       	sbrc	r24, 0
    11be:	88 c3       	rjmp	.+1808   	; 0x18d0 <__stack+0x7d1>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    11c0:	dd 20       	and	r13, r13
    11c2:	11 f0       	breq	.+4      	; 0x11c8 <__stack+0xc9>
    11c4:	82 fd       	sbrc	r24, 2
    11c6:	86 c3       	rjmp	.+1804   	; 0x18d4 <__stack+0x7d5>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    11c8:	c7 01       	movw	r24, r14
    11ca:	40 e0       	ldi	r20, 0x00	; 0
    11cc:	50 e0       	ldi	r21, 0x00	; 0
    11ce:	ba 01       	movw	r22, r20
    11d0:	0e 94 dd 07 	call	0xfba	; 0xfba <check_fs>
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    11d4:	81 30       	cpi	r24, 0x01	; 1
    11d6:	e9 f5       	brne	.+122    	; 0x1252 <__stack+0x153>
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
    11d8:	f7 01       	movw	r30, r14
    11da:	ec 50       	subi	r30, 0x0C	; 12
    11dc:	fe 4f       	sbci	r31, 0xFE	; 254
    11de:	80 81       	ld	r24, Z
    11e0:	88 23       	and	r24, r24
    11e2:	09 f4       	brne	.+2      	; 0x11e6 <__stack+0xe7>
    11e4:	79 c3       	rjmp	.+1778   	; 0x18d8 <__stack+0x7d9>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    11e6:	f7 01       	movw	r30, r14
    11e8:	e5 50       	subi	r30, 0x05	; 5
    11ea:	fe 4f       	sbci	r31, 0xFE	; 254
    11ec:	80 81       	ld	r24, Z
    11ee:	90 e0       	ldi	r25, 0x00	; 0
    11f0:	a0 e0       	ldi	r26, 0x00	; 0
    11f2:	b0 e0       	ldi	r27, 0x00	; 0
    11f4:	b8 2f       	mov	r27, r24
    11f6:	aa 27       	eor	r26, r26
    11f8:	99 27       	eor	r25, r25
    11fa:	88 27       	eor	r24, r24
    11fc:	f7 01       	movw	r30, r14
    11fe:	e6 50       	subi	r30, 0x06	; 6
    1200:	fe 4f       	sbci	r31, 0xFE	; 254
    1202:	40 81       	ld	r20, Z
    1204:	50 e0       	ldi	r21, 0x00	; 0
    1206:	60 e0       	ldi	r22, 0x00	; 0
    1208:	70 e0       	ldi	r23, 0x00	; 0
    120a:	ba 01       	movw	r22, r20
    120c:	55 27       	eor	r21, r21
    120e:	44 27       	eor	r20, r20
    1210:	84 2b       	or	r24, r20
    1212:	95 2b       	or	r25, r21
    1214:	a6 2b       	or	r26, r22
    1216:	b7 2b       	or	r27, r23
    1218:	f7 01       	movw	r30, r14
    121a:	e8 50       	subi	r30, 0x08	; 8
    121c:	fe 4f       	sbci	r31, 0xFE	; 254
    121e:	40 81       	ld	r20, Z
    1220:	50 e0       	ldi	r21, 0x00	; 0
    1222:	60 e0       	ldi	r22, 0x00	; 0
    1224:	70 e0       	ldi	r23, 0x00	; 0
    1226:	48 2b       	or	r20, r24
    1228:	59 2b       	or	r21, r25
    122a:	6a 2b       	or	r22, r26
    122c:	7b 2b       	or	r23, r27
    122e:	f7 01       	movw	r30, r14
    1230:	e7 50       	subi	r30, 0x07	; 7
    1232:	fe 4f       	sbci	r31, 0xFE	; 254
    1234:	90 81       	ld	r25, Z
    1236:	80 e0       	ldi	r24, 0x00	; 0
    1238:	4c 01       	movw	r8, r24
    123a:	aa 24       	eor	r10, r10
    123c:	bb 24       	eor	r11, r11
    123e:	84 2a       	or	r8, r20
    1240:	95 2a       	or	r9, r21
    1242:	a6 2a       	or	r10, r22
    1244:	b7 2a       	or	r11, r23
			fmt = check_fs(fs, bsect);		/* Check the partition */
    1246:	c7 01       	movw	r24, r14
    1248:	b5 01       	movw	r22, r10
    124a:	a4 01       	movw	r20, r8
    124c:	0e 94 dd 07 	call	0xfba	; 0xfba <check_fs>
    1250:	03 c0       	rjmp	.+6      	; 0x1258 <__stack+0x159>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    1252:	88 24       	eor	r8, r8
    1254:	99 24       	eor	r9, r9
    1256:	54 01       	movw	r10, r8
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    1258:	83 30       	cpi	r24, 0x03	; 3
    125a:	09 f4       	brne	.+2      	; 0x125e <__stack+0x15f>
    125c:	3f c3       	rjmp	.+1662   	; 0x18dc <__stack+0x7dd>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    125e:	88 23       	and	r24, r24
    1260:	09 f0       	breq	.+2      	; 0x1264 <__stack+0x165>
    1262:	3e c3       	rjmp	.+1660   	; 0x18e0 <__stack+0x7e1>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    1264:	d7 01       	movw	r26, r14
    1266:	de 96       	adiw	r26, 0x3e	; 62
    1268:	9c 91       	ld	r25, X
    126a:	de 97       	sbiw	r26, 0x3e	; 62
    126c:	80 e0       	ldi	r24, 0x00	; 0
    126e:	dd 96       	adiw	r26, 0x3d	; 61
    1270:	2c 91       	ld	r18, X
    1272:	dd 97       	sbiw	r26, 0x3d	; 61
    1274:	30 e0       	ldi	r19, 0x00	; 0
    1276:	82 2b       	or	r24, r18
    1278:	93 2b       	or	r25, r19
    127a:	b2 e0       	ldi	r27, 0x02	; 2
    127c:	80 30       	cpi	r24, 0x00	; 0
    127e:	9b 07       	cpc	r25, r27
    1280:	09 f0       	breq	.+2      	; 0x1284 <__stack+0x185>
    1282:	30 c3       	rjmp	.+1632   	; 0x18e4 <__stack+0x7e5>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    1284:	f7 01       	movw	r30, r14
    1286:	e7 5b       	subi	r30, 0xB7	; 183
    1288:	ff 4f       	sbci	r31, 0xFF	; 255
    128a:	30 81       	ld	r19, Z
    128c:	20 e0       	ldi	r18, 0x00	; 0
    128e:	f7 01       	movw	r30, r14
    1290:	e8 5b       	subi	r30, 0xB8	; 184
    1292:	ff 4f       	sbci	r31, 0xFF	; 255
    1294:	80 81       	ld	r24, Z
    1296:	90 e0       	ldi	r25, 0x00	; 0
    1298:	82 2b       	or	r24, r18
    129a:	93 2b       	or	r25, r19
    129c:	2c 01       	movw	r4, r24
    129e:	66 24       	eor	r6, r6
    12a0:	77 24       	eor	r7, r7
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    12a2:	41 14       	cp	r4, r1
    12a4:	51 04       	cpc	r5, r1
    12a6:	61 04       	cpc	r6, r1
    12a8:	71 04       	cpc	r7, r1
    12aa:	89 f5       	brne	.+98     	; 0x130e <__stack+0x20f>
    12ac:	f7 01       	movw	r30, r14
    12ae:	e7 5a       	subi	r30, 0xA7	; 167
    12b0:	ff 4f       	sbci	r31, 0xFF	; 255
    12b2:	40 81       	ld	r20, Z
    12b4:	50 e0       	ldi	r21, 0x00	; 0
    12b6:	60 e0       	ldi	r22, 0x00	; 0
    12b8:	70 e0       	ldi	r23, 0x00	; 0
    12ba:	74 2f       	mov	r23, r20
    12bc:	66 27       	eor	r22, r22
    12be:	55 27       	eor	r21, r21
    12c0:	44 27       	eor	r20, r20
    12c2:	f7 01       	movw	r30, r14
    12c4:	e8 5a       	subi	r30, 0xA8	; 168
    12c6:	ff 4f       	sbci	r31, 0xFF	; 255
    12c8:	80 81       	ld	r24, Z
    12ca:	90 e0       	ldi	r25, 0x00	; 0
    12cc:	a0 e0       	ldi	r26, 0x00	; 0
    12ce:	b0 e0       	ldi	r27, 0x00	; 0
    12d0:	dc 01       	movw	r26, r24
    12d2:	99 27       	eor	r25, r25
    12d4:	88 27       	eor	r24, r24
    12d6:	48 2b       	or	r20, r24
    12d8:	59 2b       	or	r21, r25
    12da:	6a 2b       	or	r22, r26
    12dc:	7b 2b       	or	r23, r27
    12de:	f7 01       	movw	r30, r14
    12e0:	ea 5a       	subi	r30, 0xAA	; 170
    12e2:	ff 4f       	sbci	r31, 0xFF	; 255
    12e4:	80 81       	ld	r24, Z
    12e6:	90 e0       	ldi	r25, 0x00	; 0
    12e8:	a0 e0       	ldi	r26, 0x00	; 0
    12ea:	b0 e0       	ldi	r27, 0x00	; 0
    12ec:	48 2b       	or	r20, r24
    12ee:	59 2b       	or	r21, r25
    12f0:	6a 2b       	or	r22, r26
    12f2:	7b 2b       	or	r23, r27
    12f4:	f7 01       	movw	r30, r14
    12f6:	e9 5a       	subi	r30, 0xA9	; 169
    12f8:	ff 4f       	sbci	r31, 0xFF	; 255
    12fa:	90 81       	ld	r25, Z
    12fc:	80 e0       	ldi	r24, 0x00	; 0
    12fe:	a0 e0       	ldi	r26, 0x00	; 0
    1300:	b0 e0       	ldi	r27, 0x00	; 0
    1302:	2a 01       	movw	r4, r20
    1304:	3b 01       	movw	r6, r22
    1306:	48 2a       	or	r4, r24
    1308:	59 2a       	or	r5, r25
    130a:	6a 2a       	or	r6, r26
    130c:	7b 2a       	or	r7, r27
	fs->fsize = fasize;
    130e:	f7 01       	movw	r30, r14
    1310:	46 8e       	std	Z+30, r4	; 0x1e
    1312:	57 8e       	std	Z+31, r5	; 0x1f
    1314:	60 a2       	lds	r22, 0x90
    1316:	71 a2       	lds	r23, 0x91

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    1318:	ee 5b       	subi	r30, 0xBE	; 190
    131a:	ff 4f       	sbci	r31, 0xFF	; 255
    131c:	c0 80       	ld	r12, Z
    131e:	d7 01       	movw	r26, r14
    1320:	13 96       	adiw	r26, 0x03	; 3
    1322:	cc 92       	st	X, r12
    1324:	13 97       	sbiw	r26, 0x03	; 3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    1326:	8c 2d       	mov	r24, r12
    1328:	81 50       	subi	r24, 0x01	; 1
    132a:	82 30       	cpi	r24, 0x02	; 2
    132c:	08 f0       	brcs	.+2      	; 0x1330 <__stack+0x231>
    132e:	dc c2       	rjmp	.+1464   	; 0x18e8 <__stack+0x7e9>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    1330:	df 96       	adiw	r26, 0x3f	; 63
    1332:	dc 90       	ld	r13, X
    1334:	df 97       	sbiw	r26, 0x3f	; 63
    1336:	12 96       	adiw	r26, 0x02	; 2
    1338:	dc 92       	st	X, r13
    133a:	12 97       	sbiw	r26, 0x02	; 2
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    133c:	dd 20       	and	r13, r13
    133e:	09 f4       	brne	.+2      	; 0x1342 <__stack+0x243>
    1340:	d5 c2       	rjmp	.+1450   	; 0x18ec <__stack+0x7ed>
    1342:	8d 2d       	mov	r24, r13
    1344:	90 e0       	ldi	r25, 0x00	; 0
    1346:	9c 01       	movw	r18, r24
    1348:	21 50       	subi	r18, 0x01	; 1
    134a:	30 40       	sbci	r19, 0x00	; 0
    134c:	82 23       	and	r24, r18
    134e:	93 23       	and	r25, r19
    1350:	00 97       	sbiw	r24, 0x00	; 0
    1352:	09 f0       	breq	.+2      	; 0x1356 <__stack+0x257>
    1354:	cd c2       	rjmp	.+1434   	; 0x18f0 <__stack+0x7f1>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    1356:	f7 01       	movw	r30, r14
    1358:	ec 5b       	subi	r30, 0xBC	; 188
    135a:	ff 4f       	sbci	r31, 0xFF	; 255
    135c:	30 81       	ld	r19, Z
    135e:	20 e0       	ldi	r18, 0x00	; 0
    1360:	f7 01       	movw	r30, r14
    1362:	ed 5b       	subi	r30, 0xBD	; 189
    1364:	ff 4f       	sbci	r31, 0xFF	; 255
    1366:	80 81       	ld	r24, Z
    1368:	90 e0       	ldi	r25, 0x00	; 0
    136a:	19 01       	movw	r2, r18
    136c:	28 2a       	or	r2, r24
    136e:	39 2a       	or	r3, r25
    1370:	f7 01       	movw	r30, r14
    1372:	31 86       	std	Z+9, r3	; 0x09
    1374:	20 86       	std	Z+8, r2	; 0x08
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    1376:	c1 01       	movw	r24, r2
    1378:	8f 70       	andi	r24, 0x0F	; 15
    137a:	90 70       	andi	r25, 0x00	; 0
    137c:	00 97       	sbiw	r24, 0x00	; 0
    137e:	09 f0       	breq	.+2      	; 0x1382 <__stack+0x283>
    1380:	b9 c2       	rjmp	.+1394   	; 0x18f4 <__stack+0x7f5>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    1382:	ea 5b       	subi	r30, 0xBA	; 186
    1384:	ff 4f       	sbci	r31, 0xFF	; 255
    1386:	30 81       	ld	r19, Z
    1388:	20 e0       	ldi	r18, 0x00	; 0
    138a:	f7 01       	movw	r30, r14
    138c:	eb 5b       	subi	r30, 0xBB	; 187
    138e:	ff 4f       	sbci	r31, 0xFF	; 255
    1390:	80 81       	ld	r24, Z
    1392:	90 e0       	ldi	r25, 0x00	; 0
    1394:	82 2b       	or	r24, r18
    1396:	93 2b       	or	r25, r19
    1398:	8c 01       	movw	r16, r24
    139a:	20 e0       	ldi	r18, 0x00	; 0
    139c:	30 e0       	ldi	r19, 0x00	; 0
    139e:	09 83       	std	Y+1, r16	; 0x01
    13a0:	1a 83       	std	Y+2, r17	; 0x02
    13a2:	2b 83       	std	Y+3, r18	; 0x03
    13a4:	3c 83       	std	Y+4, r19	; 0x04
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    13a6:	01 15       	cp	r16, r1
    13a8:	11 05       	cpc	r17, r1
    13aa:	21 05       	cpc	r18, r1
    13ac:	31 05       	cpc	r19, r1
    13ae:	a9 f5       	brne	.+106    	; 0x141a <__stack+0x31b>
    13b0:	f7 01       	movw	r30, r14
    13b2:	eb 5a       	subi	r30, 0xAB	; 171
    13b4:	ff 4f       	sbci	r31, 0xFF	; 255
    13b6:	80 81       	ld	r24, Z
    13b8:	90 e0       	ldi	r25, 0x00	; 0
    13ba:	a0 e0       	ldi	r26, 0x00	; 0
    13bc:	b0 e0       	ldi	r27, 0x00	; 0
    13be:	78 2f       	mov	r23, r24
    13c0:	66 27       	eor	r22, r22
    13c2:	55 27       	eor	r21, r21
    13c4:	44 27       	eor	r20, r20
    13c6:	f7 01       	movw	r30, r14
    13c8:	ec 5a       	subi	r30, 0xAC	; 172
    13ca:	ff 4f       	sbci	r31, 0xFF	; 255
    13cc:	80 81       	ld	r24, Z
    13ce:	90 e0       	ldi	r25, 0x00	; 0
    13d0:	a0 e0       	ldi	r26, 0x00	; 0
    13d2:	b0 e0       	ldi	r27, 0x00	; 0
    13d4:	dc 01       	movw	r26, r24
    13d6:	99 27       	eor	r25, r25
    13d8:	88 27       	eor	r24, r24
    13da:	48 2b       	or	r20, r24
    13dc:	59 2b       	or	r21, r25
    13de:	6a 2b       	or	r22, r26
    13e0:	7b 2b       	or	r23, r27
    13e2:	f7 01       	movw	r30, r14
    13e4:	ee 5a       	subi	r30, 0xAE	; 174
    13e6:	ff 4f       	sbci	r31, 0xFF	; 255
    13e8:	80 81       	ld	r24, Z
    13ea:	90 e0       	ldi	r25, 0x00	; 0
    13ec:	a0 e0       	ldi	r26, 0x00	; 0
    13ee:	b0 e0       	ldi	r27, 0x00	; 0
    13f0:	48 2b       	or	r20, r24
    13f2:	59 2b       	or	r21, r25
    13f4:	6a 2b       	or	r22, r26
    13f6:	7b 2b       	or	r23, r27
    13f8:	f7 01       	movw	r30, r14
    13fa:	ed 5a       	subi	r30, 0xAD	; 173
    13fc:	ff 4f       	sbci	r31, 0xFF	; 255
    13fe:	90 81       	ld	r25, Z
    1400:	80 e0       	ldi	r24, 0x00	; 0
    1402:	a0 e0       	ldi	r26, 0x00	; 0
    1404:	b0 e0       	ldi	r27, 0x00	; 0
    1406:	8a 01       	movw	r16, r20
    1408:	9b 01       	movw	r18, r22
    140a:	08 2b       	or	r16, r24
    140c:	19 2b       	or	r17, r25
    140e:	2a 2b       	or	r18, r26
    1410:	3b 2b       	or	r19, r27
    1412:	09 83       	std	Y+1, r16	; 0x01
    1414:	1a 83       	std	Y+2, r17	; 0x02
    1416:	2b 83       	std	Y+3, r18	; 0x03
    1418:	3c 83       	std	Y+4, r19	; 0x04

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    141a:	f7 01       	movw	r30, r14
    141c:	ef 5b       	subi	r30, 0xBF	; 191
    141e:	ff 4f       	sbci	r31, 0xFF	; 255
    1420:	30 81       	ld	r19, Z
    1422:	20 e0       	ldi	r18, 0x00	; 0
    1424:	f7 01       	movw	r30, r14
    1426:	e0 5c       	subi	r30, 0xC0	; 192
    1428:	ff 4f       	sbci	r31, 0xFF	; 255
    142a:	80 81       	ld	r24, Z
    142c:	90 e0       	ldi	r25, 0x00	; 0
    142e:	89 01       	movw	r16, r18
    1430:	08 2b       	or	r16, r24
    1432:	19 2b       	or	r17, r25
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    1434:	01 15       	cp	r16, r1
    1436:	11 05       	cpc	r17, r1
    1438:	09 f4       	brne	.+2      	; 0x143c <__stack+0x33d>
    143a:	5e c2       	rjmp	.+1212   	; 0x18f8 <__stack+0x7f9>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
    143c:	2c 2d       	mov	r18, r12
    143e:	30 e0       	ldi	r19, 0x00	; 0
    1440:	40 e0       	ldi	r20, 0x00	; 0
    1442:	50 e0       	ldi	r21, 0x00	; 0
    1444:	c3 01       	movw	r24, r6
    1446:	b2 01       	movw	r22, r4
    1448:	0e 94 33 29 	call	0x5266	; 0x5266 <__mulsi3>
    144c:	6d 87       	std	Y+13, r22	; 0x0d
    144e:	7e 87       	std	Y+14, r23	; 0x0e
    1450:	8f 87       	std	Y+15, r24	; 0x0f
    1452:	98 8b       	std	Y+16, r25	; 0x10

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    1454:	98 01       	movw	r18, r16
    1456:	40 e0       	ldi	r20, 0x00	; 0
    1458:	50 e0       	ldi	r21, 0x00	; 0
    145a:	29 87       	std	Y+9, r18	; 0x09
    145c:	3a 87       	std	Y+10, r19	; 0x0a
    145e:	4b 87       	std	Y+11, r20	; 0x0b
    1460:	5c 87       	std	Y+12, r21	; 0x0c
    1462:	c1 01       	movw	r24, r2
    1464:	92 95       	swap	r25
    1466:	82 95       	swap	r24
    1468:	8f 70       	andi	r24, 0x0F	; 15
    146a:	89 27       	eor	r24, r25
    146c:	9f 70       	andi	r25, 0x0F	; 15
    146e:	89 27       	eor	r24, r25
    1470:	a0 e0       	ldi	r26, 0x00	; 0
    1472:	b0 e0       	ldi	r27, 0x00	; 0
    1474:	82 0f       	add	r24, r18
    1476:	93 1f       	adc	r25, r19
    1478:	a4 1f       	adc	r26, r20
    147a:	b5 1f       	adc	r27, r21
    147c:	0d 85       	ldd	r16, Y+13	; 0x0d
    147e:	1e 85       	ldd	r17, Y+14	; 0x0e
    1480:	2f 85       	ldd	r18, Y+15	; 0x0f
    1482:	38 89       	ldd	r19, Y+16	; 0x10
    1484:	08 0f       	add	r16, r24
    1486:	19 1f       	adc	r17, r25
    1488:	2a 1f       	adc	r18, r26
    148a:	3b 1f       	adc	r19, r27
    148c:	0d 83       	std	Y+5, r16	; 0x05
    148e:	1e 83       	std	Y+6, r17	; 0x06
    1490:	2f 83       	std	Y+7, r18	; 0x07
    1492:	38 87       	std	Y+8, r19	; 0x08
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    1494:	89 81       	ldd	r24, Y+1	; 0x01
    1496:	9a 81       	ldd	r25, Y+2	; 0x02
    1498:	ab 81       	ldd	r26, Y+3	; 0x03
    149a:	bc 81       	ldd	r27, Y+4	; 0x04
    149c:	80 17       	cp	r24, r16
    149e:	91 07       	cpc	r25, r17
    14a0:	a2 07       	cpc	r26, r18
    14a2:	b3 07       	cpc	r27, r19
    14a4:	08 f4       	brcc	.+2      	; 0x14a8 <__stack+0x3a9>
    14a6:	2a c2       	rjmp	.+1108   	; 0x18fc <__stack+0x7fd>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    14a8:	bc 01       	movw	r22, r24
    14aa:	cd 01       	movw	r24, r26
    14ac:	60 1b       	sub	r22, r16
    14ae:	71 0b       	sbc	r23, r17
    14b0:	82 0b       	sbc	r24, r18
    14b2:	93 0b       	sbc	r25, r19
    14b4:	2d 2d       	mov	r18, r13
    14b6:	30 e0       	ldi	r19, 0x00	; 0
    14b8:	40 e0       	ldi	r20, 0x00	; 0
    14ba:	50 e0       	ldi	r21, 0x00	; 0
    14bc:	0e 94 52 29 	call	0x52a4	; 0x52a4 <__udivmodsi4>
    14c0:	89 01       	movw	r16, r18
    14c2:	9a 01       	movw	r18, r20
    14c4:	d9 01       	movw	r26, r18
    14c6:	c8 01       	movw	r24, r16
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    14c8:	01 15       	cp	r16, r1
    14ca:	11 05       	cpc	r17, r1
    14cc:	21 05       	cpc	r18, r1
    14ce:	31 05       	cpc	r19, r1
    14d0:	09 f4       	brne	.+2      	; 0x14d4 <__stack+0x3d5>
    14d2:	16 c2       	rjmp	.+1068   	; 0x1900 <__stack+0x801>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    14d4:	06 3f       	cpi	r16, 0xF6	; 246
    14d6:	ef e0       	ldi	r30, 0x0F	; 15
    14d8:	1e 07       	cpc	r17, r30
    14da:	e0 e0       	ldi	r30, 0x00	; 0
    14dc:	2e 07       	cpc	r18, r30
    14de:	e0 e0       	ldi	r30, 0x00	; 0
    14e0:	3e 07       	cpc	r19, r30
    14e2:	18 f4       	brcc	.+6      	; 0x14ea <__stack+0x3eb>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
    14e4:	dd 24       	eor	r13, r13
    14e6:	d3 94       	inc	r13
    14e8:	03 c0       	rjmp	.+6      	; 0x14f0 <__stack+0x3f1>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    14ea:	dd 24       	eor	r13, r13
    14ec:	68 94       	set
    14ee:	d1 f8       	bld	r13, 1
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    14f0:	86 3f       	cpi	r24, 0xF6	; 246
    14f2:	ff ef       	ldi	r31, 0xFF	; 255
    14f4:	9f 07       	cpc	r25, r31
    14f6:	f0 e0       	ldi	r31, 0x00	; 0
    14f8:	af 07       	cpc	r26, r31
    14fa:	f0 e0       	ldi	r31, 0x00	; 0
    14fc:	bf 07       	cpc	r27, r31
    14fe:	08 f0       	brcs	.+2      	; 0x1502 <__stack+0x403>
    1500:	1f c2       	rjmp	.+1086   	; 0x1940 <__stack+0x841>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    1502:	b9 01       	movw	r22, r18
    1504:	a8 01       	movw	r20, r16
    1506:	4e 5f       	subi	r20, 0xFE	; 254
    1508:	5f 4f       	sbci	r21, 0xFF	; 255
    150a:	6f 4f       	sbci	r22, 0xFF	; 255
    150c:	7f 4f       	sbci	r23, 0xFF	; 255
    150e:	d7 01       	movw	r26, r14
    1510:	5a 96       	adiw	r26, 0x1a	; 26
    1512:	4d 93       	st	X+, r20
    1514:	5d 93       	st	X+, r21
    1516:	6d 93       	st	X+, r22
    1518:	7c 93       	st	X, r23
    151a:	5d 97       	sbiw	r26, 0x1d	; 29
	fs->database = bsect + sysect;						/* Data start sector */
    151c:	8d 81       	ldd	r24, Y+5	; 0x05
    151e:	9e 81       	ldd	r25, Y+6	; 0x06
    1520:	af 81       	ldd	r26, Y+7	; 0x07
    1522:	b8 85       	ldd	r27, Y+8	; 0x08
    1524:	88 0d       	add	r24, r8
    1526:	99 1d       	adc	r25, r9
    1528:	aa 1d       	adc	r26, r10
    152a:	bb 1d       	adc	r27, r11
    152c:	f7 01       	movw	r30, r14
    152e:	82 a7       	lds	r24, 0x72
    1530:	93 a7       	lds	r25, 0x73
    1532:	a4 a7       	lds	r26, 0x74
    1534:	b5 a7       	lds	r27, 0x75
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    1536:	89 85       	ldd	r24, Y+9	; 0x09
    1538:	9a 85       	ldd	r25, Y+10	; 0x0a
    153a:	ab 85       	ldd	r26, Y+11	; 0x0b
    153c:	bc 85       	ldd	r27, Y+12	; 0x0c
    153e:	88 0d       	add	r24, r8
    1540:	99 1d       	adc	r25, r9
    1542:	aa 1d       	adc	r26, r10
    1544:	bb 1d       	adc	r27, r11
    1546:	82 a3       	lds	r24, 0x52
    1548:	93 a3       	lds	r25, 0x53
    154a:	a4 a3       	lds	r26, 0x54
    154c:	b5 a3       	lds	r27, 0x55
	if (fmt == FS_FAT32) {
    154e:	f3 e0       	ldi	r31, 0x03	; 3
    1550:	df 16       	cp	r13, r31
    1552:	09 f0       	breq	.+2      	; 0x1556 <__stack+0x457>
    1554:	41 c0       	rjmp	.+130    	; 0x15d8 <__stack+0x4d9>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    1556:	21 14       	cp	r2, r1
    1558:	31 04       	cpc	r3, r1
    155a:	09 f0       	breq	.+2      	; 0x155e <__stack+0x45f>
    155c:	d3 c1       	rjmp	.+934    	; 0x1904 <__stack+0x805>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    155e:	f7 01       	movw	r30, r14
    1560:	ef 59       	subi	r30, 0x9F	; 159
    1562:	ff 4f       	sbci	r31, 0xFF	; 255
    1564:	80 81       	ld	r24, Z
    1566:	90 e0       	ldi	r25, 0x00	; 0
    1568:	a0 e0       	ldi	r26, 0x00	; 0
    156a:	b0 e0       	ldi	r27, 0x00	; 0
    156c:	38 2f       	mov	r19, r24
    156e:	22 27       	eor	r18, r18
    1570:	11 27       	eor	r17, r17
    1572:	00 27       	eor	r16, r16
    1574:	f7 01       	movw	r30, r14
    1576:	e0 5a       	subi	r30, 0xA0	; 160
    1578:	ff 4f       	sbci	r31, 0xFF	; 255
    157a:	80 81       	ld	r24, Z
    157c:	90 e0       	ldi	r25, 0x00	; 0
    157e:	a0 e0       	ldi	r26, 0x00	; 0
    1580:	b0 e0       	ldi	r27, 0x00	; 0
    1582:	dc 01       	movw	r26, r24
    1584:	99 27       	eor	r25, r25
    1586:	88 27       	eor	r24, r24
    1588:	08 2b       	or	r16, r24
    158a:	19 2b       	or	r17, r25
    158c:	2a 2b       	or	r18, r26
    158e:	3b 2b       	or	r19, r27
    1590:	f7 01       	movw	r30, r14
    1592:	e2 5a       	subi	r30, 0xA2	; 162
    1594:	ff 4f       	sbci	r31, 0xFF	; 255
    1596:	80 81       	ld	r24, Z
    1598:	90 e0       	ldi	r25, 0x00	; 0
    159a:	a0 e0       	ldi	r26, 0x00	; 0
    159c:	b0 e0       	ldi	r27, 0x00	; 0
    159e:	08 2b       	or	r16, r24
    15a0:	19 2b       	or	r17, r25
    15a2:	2a 2b       	or	r18, r26
    15a4:	3b 2b       	or	r19, r27
    15a6:	f7 01       	movw	r30, r14
    15a8:	e1 5a       	subi	r30, 0xA1	; 161
    15aa:	ff 4f       	sbci	r31, 0xFF	; 255
    15ac:	90 81       	ld	r25, Z
    15ae:	80 e0       	ldi	r24, 0x00	; 0
    15b0:	a0 e0       	ldi	r26, 0x00	; 0
    15b2:	b0 e0       	ldi	r27, 0x00	; 0
    15b4:	80 2b       	or	r24, r16
    15b6:	91 2b       	or	r25, r17
    15b8:	a2 2b       	or	r26, r18
    15ba:	b3 2b       	or	r27, r19
    15bc:	f7 01       	movw	r30, r14
    15be:	86 a3       	lds	r24, 0x56
    15c0:	97 a3       	lds	r25, 0x57
    15c2:	a0 a7       	lds	r26, 0x70
    15c4:	b1 a7       	lds	r27, 0x71
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    15c6:	44 0f       	add	r20, r20
    15c8:	55 1f       	adc	r21, r21
    15ca:	66 1f       	adc	r22, r22
    15cc:	77 1f       	adc	r23, r23
    15ce:	44 0f       	add	r20, r20
    15d0:	55 1f       	adc	r21, r21
    15d2:	66 1f       	adc	r22, r22
    15d4:	77 1f       	adc	r23, r23
    15d6:	2f c0       	rjmp	.+94     	; 0x1636 <__stack+0x537>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    15d8:	21 14       	cp	r2, r1
    15da:	31 04       	cpc	r3, r1
    15dc:	09 f4       	brne	.+2      	; 0x15e0 <__stack+0x4e1>
    15de:	94 c1       	rjmp	.+808    	; 0x1908 <__stack+0x809>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    15e0:	0d 85       	ldd	r16, Y+13	; 0x0d
    15e2:	1e 85       	ldd	r17, Y+14	; 0x0e
    15e4:	2f 85       	ldd	r18, Y+15	; 0x0f
    15e6:	38 89       	ldd	r19, Y+16	; 0x10
    15e8:	80 0f       	add	r24, r16
    15ea:	91 1f       	adc	r25, r17
    15ec:	a2 1f       	adc	r26, r18
    15ee:	b3 1f       	adc	r27, r19
    15f0:	f7 01       	movw	r30, r14
    15f2:	86 a3       	lds	r24, 0x56
    15f4:	97 a3       	lds	r25, 0x57
    15f6:	a0 a7       	lds	r26, 0x70
    15f8:	b1 a7       	lds	r27, 0x71
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    15fa:	f2 e0       	ldi	r31, 0x02	; 2
    15fc:	df 16       	cp	r13, r31
    15fe:	29 f4       	brne	.+10     	; 0x160a <__stack+0x50b>
    1600:	44 0f       	add	r20, r20
    1602:	55 1f       	adc	r21, r21
    1604:	66 1f       	adc	r22, r22
    1606:	77 1f       	adc	r23, r23
    1608:	16 c0       	rjmp	.+44     	; 0x1636 <__stack+0x537>
    160a:	db 01       	movw	r26, r22
    160c:	ca 01       	movw	r24, r20
    160e:	88 0f       	add	r24, r24
    1610:	99 1f       	adc	r25, r25
    1612:	aa 1f       	adc	r26, r26
    1614:	bb 1f       	adc	r27, r27
    1616:	84 0f       	add	r24, r20
    1618:	95 1f       	adc	r25, r21
    161a:	a6 1f       	adc	r26, r22
    161c:	b7 1f       	adc	r27, r23
    161e:	b6 95       	lsr	r27
    1620:	a7 95       	ror	r26
    1622:	97 95       	ror	r25
    1624:	87 95       	ror	r24
    1626:	41 70       	andi	r20, 0x01	; 1
    1628:	50 70       	andi	r21, 0x00	; 0
    162a:	60 70       	andi	r22, 0x00	; 0
    162c:	70 70       	andi	r23, 0x00	; 0
    162e:	48 0f       	add	r20, r24
    1630:	59 1f       	adc	r21, r25
    1632:	6a 1f       	adc	r22, r26
    1634:	7b 1f       	adc	r23, r27
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    1636:	db 01       	movw	r26, r22
    1638:	ca 01       	movw	r24, r20
    163a:	81 50       	subi	r24, 0x01	; 1
    163c:	9e 4f       	sbci	r25, 0xFE	; 254
    163e:	af 4f       	sbci	r26, 0xFF	; 255
    1640:	bf 4f       	sbci	r27, 0xFF	; 255
    1642:	07 2e       	mov	r0, r23
    1644:	79 e0       	ldi	r23, 0x09	; 9
    1646:	b6 95       	lsr	r27
    1648:	a7 95       	ror	r26
    164a:	97 95       	ror	r25
    164c:	87 95       	ror	r24
    164e:	7a 95       	dec	r23
    1650:	d1 f7       	brne	.-12     	; 0x1646 <__stack+0x547>
    1652:	70 2d       	mov	r23, r0
    1654:	48 16       	cp	r4, r24
    1656:	59 06       	cpc	r5, r25
    1658:	6a 06       	cpc	r6, r26
    165a:	7b 06       	cpc	r7, r27
    165c:	08 f4       	brcc	.+2      	; 0x1660 <__stack+0x561>
    165e:	56 c1       	rjmp	.+684    	; 0x190c <__stack+0x80d>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
    1660:	8f ef       	ldi	r24, 0xFF	; 255
    1662:	9f ef       	ldi	r25, 0xFF	; 255
    1664:	dc 01       	movw	r26, r24
    1666:	f7 01       	movw	r30, r14
    1668:	86 87       	std	Z+14, r24	; 0x0e
    166a:	97 87       	std	Z+15, r25	; 0x0f
    166c:	a0 8b       	std	Z+16, r26	; 0x10
    166e:	b1 8b       	std	Z+17, r27	; 0x11
	fs->last_clust = 0;
    1670:	12 86       	std	Z+10, r1	; 0x0a
    1672:	13 86       	std	Z+11, r1	; 0x0b
    1674:	14 86       	std	Z+12, r1	; 0x0c
    1676:	15 86       	std	Z+13, r1	; 0x0d

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
    1678:	b3 e0       	ldi	r27, 0x03	; 3
    167a:	db 16       	cp	r13, r27
    167c:	09 f0       	breq	.+2      	; 0x1680 <__stack+0x581>
    167e:	03 c1       	rjmp	.+518    	; 0x1886 <__stack+0x787>
	 	fs->fsi_flag = 0;
    1680:	15 82       	std	Z+5, r1	; 0x05
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
    1682:	ed 59       	subi	r30, 0x9D	; 157
    1684:	ff 4f       	sbci	r31, 0xFF	; 255
    1686:	30 81       	ld	r19, Z
    1688:	20 e0       	ldi	r18, 0x00	; 0
    168a:	f7 01       	movw	r30, r14
    168c:	ee 59       	subi	r30, 0x9E	; 158
    168e:	ff 4f       	sbci	r31, 0xFF	; 255
    1690:	80 81       	ld	r24, Z
    1692:	90 e0       	ldi	r25, 0x00	; 0
    1694:	82 2b       	or	r24, r18
    1696:	93 2b       	or	r25, r19
    1698:	a0 e0       	ldi	r26, 0x00	; 0
    169a:	b0 e0       	ldi	r27, 0x00	; 0
    169c:	a5 01       	movw	r20, r10
    169e:	94 01       	movw	r18, r8
    16a0:	28 0f       	add	r18, r24
    16a2:	39 1f       	adc	r19, r25
    16a4:	4a 1f       	adc	r20, r26
    16a6:	5b 1f       	adc	r21, r27
    16a8:	d7 01       	movw	r26, r14
    16aa:	52 96       	adiw	r26, 0x12	; 18
    16ac:	2d 93       	st	X+, r18
    16ae:	3d 93       	st	X+, r19
    16b0:	4d 93       	st	X+, r20
    16b2:	5c 93       	st	X, r21
    16b4:	55 97       	sbiw	r26, 0x15	; 21
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    16b6:	b7 01       	movw	r22, r14
    16b8:	6e 5c       	subi	r22, 0xCE	; 206
    16ba:	7f 4f       	sbci	r23, 0xFF	; 255
    16bc:	11 96       	adiw	r26, 0x01	; 1
    16be:	8c 91       	ld	r24, X
    16c0:	01 e0       	ldi	r16, 0x01	; 1
    16c2:	0e 94 93 02 	call	0x526	; 0x526 <disk_read>
    16c6:	88 23       	and	r24, r24
    16c8:	09 f0       	breq	.+2      	; 0x16cc <__stack+0x5cd>
    16ca:	dd c0       	rjmp	.+442    	; 0x1886 <__stack+0x787>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
    16cc:	f7 01       	movw	r30, r14
    16ce:	ef 5c       	subi	r30, 0xCF	; 207
    16d0:	fd 4f       	sbci	r31, 0xFD	; 253
    16d2:	30 81       	ld	r19, Z
    16d4:	20 e0       	ldi	r18, 0x00	; 0
    16d6:	f7 01       	movw	r30, r14
    16d8:	e0 5d       	subi	r30, 0xD0	; 208
    16da:	fd 4f       	sbci	r31, 0xFD	; 253
    16dc:	80 81       	ld	r24, Z
    16de:	90 e0       	ldi	r25, 0x00	; 0
    16e0:	82 2b       	or	r24, r18
    16e2:	93 2b       	or	r25, r19

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    16e4:	ba ea       	ldi	r27, 0xAA	; 170
    16e6:	85 35       	cpi	r24, 0x55	; 85
    16e8:	9b 07       	cpc	r25, r27
    16ea:	09 f0       	breq	.+2      	; 0x16ee <__stack+0x5ef>
    16ec:	cc c0       	rjmp	.+408    	; 0x1886 <__stack+0x787>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
    16ee:	f7 01       	movw	r30, r14
    16f0:	45 a9       	sts	0x45, r20
    16f2:	50 e0       	ldi	r21, 0x00	; 0
    16f4:	60 e0       	ldi	r22, 0x00	; 0
    16f6:	70 e0       	ldi	r23, 0x00	; 0
    16f8:	74 2f       	mov	r23, r20
    16fa:	66 27       	eor	r22, r22
    16fc:	55 27       	eor	r21, r21
    16fe:	44 27       	eor	r20, r20
    1700:	84 a9       	sts	0x44, r24
    1702:	90 e0       	ldi	r25, 0x00	; 0
    1704:	a0 e0       	ldi	r26, 0x00	; 0
    1706:	b0 e0       	ldi	r27, 0x00	; 0
    1708:	dc 01       	movw	r26, r24
    170a:	99 27       	eor	r25, r25
    170c:	88 27       	eor	r24, r24
    170e:	48 2b       	or	r20, r24
    1710:	59 2b       	or	r21, r25
    1712:	6a 2b       	or	r22, r26
    1714:	7b 2b       	or	r23, r27
    1716:	82 a9       	sts	0x42, r24
    1718:	90 e0       	ldi	r25, 0x00	; 0
    171a:	a0 e0       	ldi	r26, 0x00	; 0
    171c:	b0 e0       	ldi	r27, 0x00	; 0
    171e:	48 2b       	or	r20, r24
    1720:	59 2b       	or	r21, r25
    1722:	6a 2b       	or	r22, r26
    1724:	7b 2b       	or	r23, r27
    1726:	93 a9       	sts	0x43, r25
    1728:	80 e0       	ldi	r24, 0x00	; 0
    172a:	a0 e0       	ldi	r26, 0x00	; 0
    172c:	b0 e0       	ldi	r27, 0x00	; 0
    172e:	84 2b       	or	r24, r20
    1730:	95 2b       	or	r25, r21
    1732:	a6 2b       	or	r26, r22
    1734:	b7 2b       	or	r27, r23
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
    1736:	82 35       	cpi	r24, 0x52	; 82
    1738:	f2 e5       	ldi	r31, 0x52	; 82
    173a:	9f 07       	cpc	r25, r31
    173c:	f1 e6       	ldi	r31, 0x61	; 97
    173e:	af 07       	cpc	r26, r31
    1740:	f1 e4       	ldi	r31, 0x41	; 65
    1742:	bf 07       	cpc	r27, r31
    1744:	09 f0       	breq	.+2      	; 0x1748 <__stack+0x649>
    1746:	9f c0       	rjmp	.+318    	; 0x1886 <__stack+0x787>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
    1748:	f7 01       	movw	r30, r14
    174a:	e7 5e       	subi	r30, 0xE7	; 231
    174c:	fd 4f       	sbci	r31, 0xFD	; 253
    174e:	80 81       	ld	r24, Z
    1750:	90 e0       	ldi	r25, 0x00	; 0
    1752:	a0 e0       	ldi	r26, 0x00	; 0
    1754:	b0 e0       	ldi	r27, 0x00	; 0
    1756:	b8 2f       	mov	r27, r24
    1758:	aa 27       	eor	r26, r26
    175a:	99 27       	eor	r25, r25
    175c:	88 27       	eor	r24, r24
    175e:	f7 01       	movw	r30, r14
    1760:	e8 5e       	subi	r30, 0xE8	; 232
    1762:	fd 4f       	sbci	r31, 0xFD	; 253
    1764:	40 81       	ld	r20, Z
    1766:	50 e0       	ldi	r21, 0x00	; 0
    1768:	60 e0       	ldi	r22, 0x00	; 0
    176a:	70 e0       	ldi	r23, 0x00	; 0
    176c:	ba 01       	movw	r22, r20
    176e:	55 27       	eor	r21, r21
    1770:	44 27       	eor	r20, r20
    1772:	84 2b       	or	r24, r20
    1774:	95 2b       	or	r25, r21
    1776:	a6 2b       	or	r26, r22
    1778:	b7 2b       	or	r27, r23
    177a:	f7 01       	movw	r30, r14
    177c:	ea 5e       	subi	r30, 0xEA	; 234
    177e:	fd 4f       	sbci	r31, 0xFD	; 253
    1780:	40 81       	ld	r20, Z
    1782:	50 e0       	ldi	r21, 0x00	; 0
    1784:	60 e0       	ldi	r22, 0x00	; 0
    1786:	70 e0       	ldi	r23, 0x00	; 0
    1788:	48 2b       	or	r20, r24
    178a:	59 2b       	or	r21, r25
    178c:	6a 2b       	or	r22, r26
    178e:	7b 2b       	or	r23, r27
    1790:	f7 01       	movw	r30, r14
    1792:	e9 5e       	subi	r30, 0xE9	; 233
    1794:	fd 4f       	sbci	r31, 0xFD	; 253
    1796:	90 81       	ld	r25, Z
    1798:	80 e0       	ldi	r24, 0x00	; 0
    179a:	a0 e0       	ldi	r26, 0x00	; 0
    179c:	b0 e0       	ldi	r27, 0x00	; 0
    179e:	84 2b       	or	r24, r20
    17a0:	95 2b       	or	r25, r21
    17a2:	a6 2b       	or	r26, r22
    17a4:	b7 2b       	or	r27, r23
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
    17a6:	82 37       	cpi	r24, 0x72	; 114
    17a8:	02 e7       	ldi	r16, 0x72	; 114
    17aa:	90 07       	cpc	r25, r16
    17ac:	01 e4       	ldi	r16, 0x41	; 65
    17ae:	a0 07       	cpc	r26, r16
    17b0:	01 e6       	ldi	r16, 0x61	; 97
    17b2:	b0 07       	cpc	r27, r16
    17b4:	09 f0       	breq	.+2      	; 0x17b8 <__stack+0x6b9>
    17b6:	67 c0       	rjmp	.+206    	; 0x1886 <__stack+0x787>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
    17b8:	f7 01       	movw	r30, r14
    17ba:	ef 5d       	subi	r30, 0xDF	; 223
    17bc:	fd 4f       	sbci	r31, 0xFD	; 253
    17be:	80 81       	ld	r24, Z
    17c0:	90 e0       	ldi	r25, 0x00	; 0
    17c2:	a0 e0       	ldi	r26, 0x00	; 0
    17c4:	b0 e0       	ldi	r27, 0x00	; 0
    17c6:	b8 2f       	mov	r27, r24
    17c8:	aa 27       	eor	r26, r26
    17ca:	99 27       	eor	r25, r25
    17cc:	88 27       	eor	r24, r24
    17ce:	f7 01       	movw	r30, r14
    17d0:	e0 5e       	subi	r30, 0xE0	; 224
    17d2:	fd 4f       	sbci	r31, 0xFD	; 253
    17d4:	40 81       	ld	r20, Z
    17d6:	50 e0       	ldi	r21, 0x00	; 0
    17d8:	60 e0       	ldi	r22, 0x00	; 0
    17da:	70 e0       	ldi	r23, 0x00	; 0
    17dc:	ba 01       	movw	r22, r20
    17de:	55 27       	eor	r21, r21
    17e0:	44 27       	eor	r20, r20
    17e2:	84 2b       	or	r24, r20
    17e4:	95 2b       	or	r25, r21
    17e6:	a6 2b       	or	r26, r22
    17e8:	b7 2b       	or	r27, r23
    17ea:	f7 01       	movw	r30, r14
    17ec:	e2 5e       	subi	r30, 0xE2	; 226
    17ee:	fd 4f       	sbci	r31, 0xFD	; 253
    17f0:	40 81       	ld	r20, Z
    17f2:	50 e0       	ldi	r21, 0x00	; 0
    17f4:	60 e0       	ldi	r22, 0x00	; 0
    17f6:	70 e0       	ldi	r23, 0x00	; 0
    17f8:	48 2b       	or	r20, r24
    17fa:	59 2b       	or	r21, r25
    17fc:	6a 2b       	or	r22, r26
    17fe:	7b 2b       	or	r23, r27
    1800:	f7 01       	movw	r30, r14
    1802:	e1 5e       	subi	r30, 0xE1	; 225
    1804:	fd 4f       	sbci	r31, 0xFD	; 253
    1806:	90 81       	ld	r25, Z
    1808:	80 e0       	ldi	r24, 0x00	; 0
    180a:	a0 e0       	ldi	r26, 0x00	; 0
    180c:	b0 e0       	ldi	r27, 0x00	; 0
    180e:	84 2b       	or	r24, r20
    1810:	95 2b       	or	r25, r21
    1812:	a6 2b       	or	r26, r22
    1814:	b7 2b       	or	r27, r23
    1816:	f7 01       	movw	r30, r14
    1818:	82 87       	std	Z+10, r24	; 0x0a
    181a:	93 87       	std	Z+11, r25	; 0x0b
    181c:	a4 87       	std	Z+12, r26	; 0x0c
    181e:	b5 87       	std	Z+13, r27	; 0x0d
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
    1820:	e3 5e       	subi	r30, 0xE3	; 227
    1822:	fd 4f       	sbci	r31, 0xFD	; 253
    1824:	80 81       	ld	r24, Z
    1826:	90 e0       	ldi	r25, 0x00	; 0
    1828:	a0 e0       	ldi	r26, 0x00	; 0
    182a:	b0 e0       	ldi	r27, 0x00	; 0
    182c:	b8 2f       	mov	r27, r24
    182e:	aa 27       	eor	r26, r26
    1830:	99 27       	eor	r25, r25
    1832:	88 27       	eor	r24, r24
    1834:	f7 01       	movw	r30, r14
    1836:	e4 5e       	subi	r30, 0xE4	; 228
    1838:	fd 4f       	sbci	r31, 0xFD	; 253
    183a:	40 81       	ld	r20, Z
    183c:	50 e0       	ldi	r21, 0x00	; 0
    183e:	60 e0       	ldi	r22, 0x00	; 0
    1840:	70 e0       	ldi	r23, 0x00	; 0
    1842:	ba 01       	movw	r22, r20
    1844:	55 27       	eor	r21, r21
    1846:	44 27       	eor	r20, r20
    1848:	84 2b       	or	r24, r20
    184a:	95 2b       	or	r25, r21
    184c:	a6 2b       	or	r26, r22
    184e:	b7 2b       	or	r27, r23
    1850:	f7 01       	movw	r30, r14
    1852:	e6 5e       	subi	r30, 0xE6	; 230
    1854:	fd 4f       	sbci	r31, 0xFD	; 253
    1856:	40 81       	ld	r20, Z
    1858:	50 e0       	ldi	r21, 0x00	; 0
    185a:	60 e0       	ldi	r22, 0x00	; 0
    185c:	70 e0       	ldi	r23, 0x00	; 0
    185e:	48 2b       	or	r20, r24
    1860:	59 2b       	or	r21, r25
    1862:	6a 2b       	or	r22, r26
    1864:	7b 2b       	or	r23, r27
    1866:	f7 01       	movw	r30, r14
    1868:	e5 5e       	subi	r30, 0xE5	; 229
    186a:	fd 4f       	sbci	r31, 0xFD	; 253
    186c:	90 81       	ld	r25, Z
    186e:	80 e0       	ldi	r24, 0x00	; 0
    1870:	a0 e0       	ldi	r26, 0x00	; 0
    1872:	b0 e0       	ldi	r27, 0x00	; 0
    1874:	84 2b       	or	r24, r20
    1876:	95 2b       	or	r25, r21
    1878:	a6 2b       	or	r26, r22
    187a:	b7 2b       	or	r27, r23
    187c:	f7 01       	movw	r30, r14
    187e:	86 87       	std	Z+14, r24	; 0x0e
    1880:	97 87       	std	Z+15, r25	; 0x0f
    1882:	a0 8b       	std	Z+16, r26	; 0x10
    1884:	b1 8b       	std	Z+17, r27	; 0x11
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
    1886:	d7 01       	movw	r26, r14
    1888:	dc 92       	st	X, r13
	fs->id = ++Fsid;		/* File system mount ID */
    188a:	80 91 8a 04 	lds	r24, 0x048A
    188e:	90 91 8b 04 	lds	r25, 0x048B
    1892:	01 96       	adiw	r24, 0x01	; 1
    1894:	90 93 8b 04 	sts	0x048B, r25
    1898:	80 93 8a 04 	sts	0x048A, r24
    189c:	17 96       	adiw	r26, 0x07	; 7
    189e:	9c 93       	st	X, r25
    18a0:	8e 93       	st	-X, r24
    18a2:	16 97       	sbiw	r26, 0x06	; 6
	fs->winsect = 0;		/* Invalidate sector cache */
    18a4:	f7 01       	movw	r30, r14
    18a6:	16 a6       	lds	r17, 0xb6
    18a8:	17 a6       	lds	r17, 0xb7
    18aa:	10 aa       	sts	0x90, r17
    18ac:	11 aa       	sts	0x91, r17
	fs->wflag = 0;
    18ae:	14 82       	std	Z+4, r1	; 0x04
#if _FS_RPATH
	fs->cdir = 0;			/* Current directory (root dir) */
    18b0:	56 96       	adiw	r26, 0x16	; 22
    18b2:	1d 92       	st	X+, r1
    18b4:	1d 92       	st	X+, r1
    18b6:	1d 92       	st	X+, r1
    18b8:	1c 92       	st	X, r1
    18ba:	59 97       	sbiw	r26, 0x19	; 25
#endif
#if _FS_LOCK				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
    18bc:	80 e0       	ldi	r24, 0x00	; 0
    18be:	27 c0       	rjmp	.+78     	; 0x190e <__stack+0x80f>
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
    18c0:	8b e0       	ldi	r24, 0x0B	; 11
    18c2:	25 c0       	rjmp	.+74     	; 0x190e <__stack+0x80f>
	fs = FatFs[vol];					/* Get corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    18c4:	8c e0       	ldi	r24, 0x0C	; 12
    18c6:	23 c0       	rjmp	.+70     	; 0x190e <__stack+0x80f>
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
    18c8:	80 e0       	ldi	r24, 0x00	; 0
    18ca:	21 c0       	rjmp	.+66     	; 0x190e <__stack+0x80f>
	*rfs = fs;							/* Return pointer to the corresponding file system object */
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
    18cc:	8a e0       	ldi	r24, 0x0A	; 10
    18ce:	1f c0       	rjmp	.+62     	; 0x190e <__stack+0x80f>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
    18d0:	83 e0       	ldi	r24, 0x03	; 3
    18d2:	1d c0       	rjmp	.+58     	; 0x190e <__stack+0x80f>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
    18d4:	8a e0       	ldi	r24, 0x0A	; 10
    18d6:	1b c0       	rjmp	.+54     	; 0x190e <__stack+0x80f>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    18d8:	8d e0       	ldi	r24, 0x0D	; 13
    18da:	19 c0       	rjmp	.+50     	; 0x190e <__stack+0x80f>
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    18dc:	81 e0       	ldi	r24, 0x01	; 1
    18de:	17 c0       	rjmp	.+46     	; 0x190e <__stack+0x80f>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    18e0:	8d e0       	ldi	r24, 0x0D	; 13
    18e2:	15 c0       	rjmp	.+42     	; 0x190e <__stack+0x80f>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;
    18e4:	8d e0       	ldi	r24, 0x0D	; 13
    18e6:	13 c0       	rjmp	.+38     	; 0x190e <__stack+0x80f>
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    18e8:	8d e0       	ldi	r24, 0x0D	; 13
    18ea:	11 c0       	rjmp	.+34     	; 0x190e <__stack+0x80f>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    18ec:	8d e0       	ldi	r24, 0x0D	; 13
    18ee:	0f c0       	rjmp	.+30     	; 0x190e <__stack+0x80f>
    18f0:	8d e0       	ldi	r24, 0x0D	; 13
    18f2:	0d c0       	rjmp	.+26     	; 0x190e <__stack+0x80f>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    18f4:	8d e0       	ldi	r24, 0x0D	; 13
    18f6:	0b c0       	rjmp	.+22     	; 0x190e <__stack+0x80f>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    18f8:	8d e0       	ldi	r24, 0x0D	; 13
    18fa:	09 c0       	rjmp	.+18     	; 0x190e <__stack+0x80f>

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    18fc:	8d e0       	ldi	r24, 0x0D	; 13
    18fe:	07 c0       	rjmp	.+14     	; 0x190e <__stack+0x80f>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    1900:	8d e0       	ldi	r24, 0x0D	; 13
    1902:	05 c0       	rjmp	.+10     	; 0x190e <__stack+0x80f>
	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    1904:	8d e0       	ldi	r24, 0x0D	; 13
    1906:	03 c0       	rjmp	.+6      	; 0x190e <__stack+0x80f>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    1908:	8d e0       	ldi	r24, 0x0D	; 13
    190a:	01 c0       	rjmp	.+2      	; 0x190e <__stack+0x80f>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;
    190c:	8d e0       	ldi	r24, 0x0D	; 13
#if _FS_LOCK				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
}
    190e:	60 96       	adiw	r28, 0x10	; 16
    1910:	0f b6       	in	r0, 0x3f	; 63
    1912:	f8 94       	cli
    1914:	de bf       	out	0x3e, r29	; 62
    1916:	0f be       	out	0x3f, r0	; 63
    1918:	cd bf       	out	0x3d, r28	; 61
    191a:	df 91       	pop	r29
    191c:	cf 91       	pop	r28
    191e:	1f 91       	pop	r17
    1920:	0f 91       	pop	r16
    1922:	ff 90       	pop	r15
    1924:	ef 90       	pop	r14
    1926:	df 90       	pop	r13
    1928:	cf 90       	pop	r12
    192a:	bf 90       	pop	r11
    192c:	af 90       	pop	r10
    192e:	9f 90       	pop	r9
    1930:	8f 90       	pop	r8
    1932:	7f 90       	pop	r7
    1934:	6f 90       	pop	r6
    1936:	5f 90       	pop	r5
    1938:	4f 90       	pop	r4
    193a:	3f 90       	pop	r3
    193c:	2f 90       	pop	r2
    193e:	08 95       	ret
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    1940:	b9 01       	movw	r22, r18
    1942:	a8 01       	movw	r20, r16
    1944:	4e 5f       	subi	r20, 0xFE	; 254
    1946:	5f 4f       	sbci	r21, 0xFF	; 255
    1948:	6f 4f       	sbci	r22, 0xFF	; 255
    194a:	7f 4f       	sbci	r23, 0xFF	; 255
    194c:	f7 01       	movw	r30, r14
    194e:	42 8f       	std	Z+26, r20	; 0x1a
    1950:	53 8f       	std	Z+27, r21	; 0x1b
    1952:	64 8f       	std	Z+28, r22	; 0x1c
    1954:	75 8f       	std	Z+29, r23	; 0x1d
	fs->database = bsect + sysect;						/* Data start sector */
    1956:	8d 81       	ldd	r24, Y+5	; 0x05
    1958:	9e 81       	ldd	r25, Y+6	; 0x06
    195a:	af 81       	ldd	r26, Y+7	; 0x07
    195c:	b8 85       	ldd	r27, Y+8	; 0x08
    195e:	88 0d       	add	r24, r8
    1960:	99 1d       	adc	r25, r9
    1962:	aa 1d       	adc	r26, r10
    1964:	bb 1d       	adc	r27, r11
    1966:	82 a7       	lds	r24, 0x72
    1968:	93 a7       	lds	r25, 0x73
    196a:	a4 a7       	lds	r26, 0x74
    196c:	b5 a7       	lds	r27, 0x75
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    196e:	89 85       	ldd	r24, Y+9	; 0x09
    1970:	9a 85       	ldd	r25, Y+10	; 0x0a
    1972:	ab 85       	ldd	r26, Y+11	; 0x0b
    1974:	bc 85       	ldd	r27, Y+12	; 0x0c
    1976:	88 0d       	add	r24, r8
    1978:	99 1d       	adc	r25, r9
    197a:	aa 1d       	adc	r26, r10
    197c:	bb 1d       	adc	r27, r11
    197e:	82 a3       	lds	r24, 0x52
    1980:	93 a3       	lds	r25, 0x53
    1982:	a4 a3       	lds	r26, 0x54
    1984:	b5 a3       	lds	r27, 0x55
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    1986:	0f 2e       	mov	r0, r31
    1988:	f3 e0       	ldi	r31, 0x03	; 3
    198a:	df 2e       	mov	r13, r31
    198c:	f0 2d       	mov	r31, r0
    198e:	e3 cd       	rjmp	.-1082   	; 0x1556 <__stack+0x457>

00001990 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
    1990:	4f 92       	push	r4
    1992:	5f 92       	push	r5
    1994:	6f 92       	push	r6
    1996:	7f 92       	push	r7
    1998:	8f 92       	push	r8
    199a:	9f 92       	push	r9
    199c:	af 92       	push	r10
    199e:	bf 92       	push	r11
    19a0:	cf 92       	push	r12
    19a2:	df 92       	push	r13
    19a4:	ef 92       	push	r14
    19a6:	ff 92       	push	r15
    19a8:	0f 93       	push	r16
    19aa:	cf 93       	push	r28
    19ac:	5c 01       	movw	r10, r24
    19ae:	2a 01       	movw	r4, r20
    19b0:	3b 01       	movw	r6, r22
	DWORD wsect;


	wsect = fs->winsect;
    19b2:	fc 01       	movw	r30, r24
    19b4:	c6 a4       	lds	r28, 0xa6
    19b6:	d7 a4       	lds	r29, 0xa7
    19b8:	e0 a8       	sts	0x00, r30
    19ba:	f1 a8       	sts	0x81, r31
	if (wsect != sector) {	/* Changed current window */
    19bc:	c4 16       	cp	r12, r20
    19be:	d5 06       	cpc	r13, r21
    19c0:	e6 06       	cpc	r14, r22
    19c2:	f7 06       	cpc	r15, r23
    19c4:	09 f4       	brne	.+2      	; 0x19c8 <move_window+0x38>
    19c6:	54 c0       	rjmp	.+168    	; 0x1a70 <move_window+0xe0>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
    19c8:	84 81       	ldd	r24, Z+4	; 0x04
    19ca:	88 23       	and	r24, r24
    19cc:	d1 f1       	breq	.+116    	; 0x1a42 <move_window+0xb2>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    19ce:	0f 2e       	mov	r0, r31
    19d0:	f2 e3       	ldi	r31, 0x32	; 50
    19d2:	8f 2e       	mov	r8, r31
    19d4:	99 24       	eor	r9, r9
    19d6:	f0 2d       	mov	r31, r0
    19d8:	8a 0c       	add	r8, r10
    19da:	9b 1c       	adc	r9, r11
    19dc:	81 81       	ldd	r24, Z+1	; 0x01
    19de:	b4 01       	movw	r22, r8
    19e0:	a7 01       	movw	r20, r14
    19e2:	96 01       	movw	r18, r12
    19e4:	01 e0       	ldi	r16, 0x01	; 1
    19e6:	0e 94 ed 02 	call	0x5da	; 0x5da <disk_write>
    19ea:	88 23       	and	r24, r24
    19ec:	09 f0       	breq	.+2      	; 0x19f0 <move_window+0x60>
    19ee:	42 c0       	rjmp	.+132    	; 0x1a74 <move_window+0xe4>
				return FR_DISK_ERR;
			fs->wflag = 0;
    19f0:	f5 01       	movw	r30, r10
    19f2:	14 82       	std	Z+4, r1	; 0x04
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    19f4:	46 8d       	ldd	r20, Z+30	; 0x1e
    19f6:	57 8d       	ldd	r21, Z+31	; 0x1f
    19f8:	60 a1       	lds	r22, 0x40
    19fa:	71 a1       	lds	r23, 0x41
    19fc:	82 a1       	lds	r24, 0x42
    19fe:	93 a1       	lds	r25, 0x43
    1a00:	a4 a1       	lds	r26, 0x44
    1a02:	b5 a1       	lds	r27, 0x45
    1a04:	84 0f       	add	r24, r20
    1a06:	95 1f       	adc	r25, r21
    1a08:	a6 1f       	adc	r26, r22
    1a0a:	b7 1f       	adc	r27, r23
    1a0c:	c8 16       	cp	r12, r24
    1a0e:	d9 06       	cpc	r13, r25
    1a10:	ea 06       	cpc	r14, r26
    1a12:	fb 06       	cpc	r15, r27
    1a14:	b0 f4       	brcc	.+44     	; 0x1a42 <move_window+0xb2>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    1a16:	c3 81       	ldd	r28, Z+3	; 0x03
    1a18:	c2 30       	cpi	r28, 0x02	; 2
    1a1a:	98 f0       	brcs	.+38     	; 0x1a42 <move_window+0xb2>
					wsect += fs->fsize;
    1a1c:	f5 01       	movw	r30, r10
    1a1e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a20:	97 8d       	ldd	r25, Z+31	; 0x1f
    1a22:	a0 a1       	lds	r26, 0x40
    1a24:	b1 a1       	lds	r27, 0x41
    1a26:	c8 0e       	add	r12, r24
    1a28:	d9 1e       	adc	r13, r25
    1a2a:	ea 1e       	adc	r14, r26
    1a2c:	fb 1e       	adc	r15, r27
					disk_write(fs->drv, fs->win, wsect, 1);
    1a2e:	81 81       	ldd	r24, Z+1	; 0x01
    1a30:	b4 01       	movw	r22, r8
    1a32:	a7 01       	movw	r20, r14
    1a34:	96 01       	movw	r18, r12
    1a36:	01 e0       	ldi	r16, 0x01	; 1
    1a38:	0e 94 ed 02 	call	0x5da	; 0x5da <disk_write>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    1a3c:	c1 50       	subi	r28, 0x01	; 1
    1a3e:	c1 30       	cpi	r28, 0x01	; 1
    1a40:	69 f7       	brne	.-38     	; 0x1a1c <move_window+0x8c>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
    1a42:	41 14       	cp	r4, r1
    1a44:	51 04       	cpc	r5, r1
    1a46:	61 04       	cpc	r6, r1
    1a48:	71 04       	cpc	r7, r1
    1a4a:	b1 f0       	breq	.+44     	; 0x1a78 <move_window+0xe8>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    1a4c:	b5 01       	movw	r22, r10
    1a4e:	6e 5c       	subi	r22, 0xCE	; 206
    1a50:	7f 4f       	sbci	r23, 0xFF	; 255
    1a52:	f5 01       	movw	r30, r10
    1a54:	81 81       	ldd	r24, Z+1	; 0x01
    1a56:	a3 01       	movw	r20, r6
    1a58:	92 01       	movw	r18, r4
    1a5a:	01 e0       	ldi	r16, 0x01	; 1
    1a5c:	0e 94 93 02 	call	0x526	; 0x526 <disk_read>
    1a60:	88 23       	and	r24, r24
    1a62:	61 f4       	brne	.+24     	; 0x1a7c <move_window+0xec>
				return FR_DISK_ERR;
			fs->winsect = sector;
    1a64:	f5 01       	movw	r30, r10
    1a66:	46 a6       	lds	r20, 0xb6
    1a68:	57 a6       	lds	r21, 0xb7
    1a6a:	60 aa       	sts	0x90, r22
    1a6c:	71 aa       	sts	0x91, r23
    1a6e:	07 c0       	rjmp	.+14     	; 0x1a7e <move_window+0xee>
		}
	}

	return FR_OK;
    1a70:	80 e0       	ldi	r24, 0x00	; 0
    1a72:	05 c0       	rjmp	.+10     	; 0x1a7e <move_window+0xee>
	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
    1a74:	81 e0       	ldi	r24, 0x01	; 1
    1a76:	03 c0       	rjmp	.+6      	; 0x1a7e <move_window+0xee>
				return FR_DISK_ERR;
			fs->winsect = sector;
		}
	}

	return FR_OK;
    1a78:	80 e0       	ldi	r24, 0x00	; 0
    1a7a:	01 c0       	rjmp	.+2      	; 0x1a7e <move_window+0xee>
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
    1a7c:	81 e0       	ldi	r24, 0x01	; 1
			fs->winsect = sector;
		}
	}

	return FR_OK;
}
    1a7e:	cf 91       	pop	r28
    1a80:	0f 91       	pop	r16
    1a82:	ff 90       	pop	r15
    1a84:	ef 90       	pop	r14
    1a86:	df 90       	pop	r13
    1a88:	cf 90       	pop	r12
    1a8a:	bf 90       	pop	r11
    1a8c:	af 90       	pop	r10
    1a8e:	9f 90       	pop	r9
    1a90:	8f 90       	pop	r8
    1a92:	7f 90       	pop	r7
    1a94:	6f 90       	pop	r6
    1a96:	5f 90       	pop	r5
    1a98:	4f 90       	pop	r4
    1a9a:	08 95       	ret

00001a9c <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
    1a9c:	ef 92       	push	r14
    1a9e:	ff 92       	push	r15
    1aa0:	0f 93       	push	r16
    1aa2:	1f 93       	push	r17
    1aa4:	cf 93       	push	r28
    1aa6:	7c 01       	movw	r14, r24
	FRESULT res;


	res = move_window(fs, 0);
    1aa8:	40 e0       	ldi	r20, 0x00	; 0
    1aaa:	50 e0       	ldi	r21, 0x00	; 0
    1aac:	ba 01       	movw	r22, r20
    1aae:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
    1ab2:	c8 2f       	mov	r28, r24
	if (res == FR_OK) {
    1ab4:	88 23       	and	r24, r24
    1ab6:	09 f0       	breq	.+2      	; 0x1aba <sync+0x1e>
    1ab8:	78 c0       	rjmp	.+240    	; 0x1baa <sync+0x10e>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    1aba:	f7 01       	movw	r30, r14
    1abc:	80 81       	ld	r24, Z
    1abe:	83 30       	cpi	r24, 0x03	; 3
    1ac0:	09 f0       	breq	.+2      	; 0x1ac4 <sync+0x28>
    1ac2:	6a c0       	rjmp	.+212    	; 0x1b98 <sync+0xfc>
    1ac4:	85 81       	ldd	r24, Z+5	; 0x05
    1ac6:	88 23       	and	r24, r24
    1ac8:	09 f4       	brne	.+2      	; 0x1acc <sync+0x30>
    1aca:	66 c0       	rjmp	.+204    	; 0x1b98 <sync+0xfc>
			fs->winsect = 0;
    1acc:	16 a6       	lds	r17, 0xb6
    1ace:	17 a6       	lds	r17, 0xb7
    1ad0:	10 aa       	sts	0x90, r17
    1ad2:	11 aa       	sts	0x91, r17
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
    1ad4:	87 01       	movw	r16, r14
    1ad6:	0e 5c       	subi	r16, 0xCE	; 206
    1ad8:	1f 4f       	sbci	r17, 0xFF	; 255
    1ada:	c8 01       	movw	r24, r16
    1adc:	60 e0       	ldi	r22, 0x00	; 0
    1ade:	70 e0       	ldi	r23, 0x00	; 0
    1ae0:	20 e0       	ldi	r18, 0x00	; 0
    1ae2:	32 e0       	ldi	r19, 0x02	; 2
    1ae4:	40 e0       	ldi	r20, 0x00	; 0
    1ae6:	50 e0       	ldi	r21, 0x00	; 0
    1ae8:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <mem_set>
			ST_WORD(fs->win+BS_55AA, 0xAA55);
    1aec:	f7 01       	movw	r30, r14
    1aee:	e0 5d       	subi	r30, 0xD0	; 208
    1af0:	fd 4f       	sbci	r31, 0xFD	; 253
    1af2:	85 e5       	ldi	r24, 0x55	; 85
    1af4:	80 83       	st	Z, r24
    1af6:	f7 01       	movw	r30, r14
    1af8:	ef 5c       	subi	r30, 0xCF	; 207
    1afa:	fd 4f       	sbci	r31, 0xFD	; 253
    1afc:	8a ea       	ldi	r24, 0xAA	; 170
    1afe:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    1b00:	82 e5       	ldi	r24, 0x52	; 82
    1b02:	f7 01       	movw	r30, r14
    1b04:	82 ab       	sts	0x52, r24
    1b06:	83 ab       	sts	0x53, r24
    1b08:	81 e6       	ldi	r24, 0x61	; 97
    1b0a:	84 ab       	sts	0x54, r24
    1b0c:	91 e4       	ldi	r25, 0x41	; 65
    1b0e:	95 ab       	sts	0x55, r25
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    1b10:	ea 5e       	subi	r30, 0xEA	; 234
    1b12:	fd 4f       	sbci	r31, 0xFD	; 253
    1b14:	22 e7       	ldi	r18, 0x72	; 114
    1b16:	20 83       	st	Z, r18
    1b18:	f7 01       	movw	r30, r14
    1b1a:	e9 5e       	subi	r30, 0xE9	; 233
    1b1c:	fd 4f       	sbci	r31, 0xFD	; 253
    1b1e:	20 83       	st	Z, r18
    1b20:	f7 01       	movw	r30, r14
    1b22:	e8 5e       	subi	r30, 0xE8	; 232
    1b24:	fd 4f       	sbci	r31, 0xFD	; 253
    1b26:	90 83       	st	Z, r25
    1b28:	f7 01       	movw	r30, r14
    1b2a:	e7 5e       	subi	r30, 0xE7	; 231
    1b2c:	fd 4f       	sbci	r31, 0xFD	; 253
    1b2e:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    1b30:	f7 01       	movw	r30, r14
    1b32:	36 85       	ldd	r19, Z+14	; 0x0e
    1b34:	27 85       	ldd	r18, Z+15	; 0x0f
    1b36:	90 89       	ldd	r25, Z+16	; 0x10
    1b38:	81 89       	ldd	r24, Z+17	; 0x11
    1b3a:	e6 5e       	subi	r30, 0xE6	; 230
    1b3c:	fd 4f       	sbci	r31, 0xFD	; 253
    1b3e:	30 83       	st	Z, r19
    1b40:	f7 01       	movw	r30, r14
    1b42:	e5 5e       	subi	r30, 0xE5	; 229
    1b44:	fd 4f       	sbci	r31, 0xFD	; 253
    1b46:	20 83       	st	Z, r18
    1b48:	f7 01       	movw	r30, r14
    1b4a:	e4 5e       	subi	r30, 0xE4	; 228
    1b4c:	fd 4f       	sbci	r31, 0xFD	; 253
    1b4e:	90 83       	st	Z, r25
    1b50:	f7 01       	movw	r30, r14
    1b52:	e3 5e       	subi	r30, 0xE3	; 227
    1b54:	fd 4f       	sbci	r31, 0xFD	; 253
    1b56:	80 83       	st	Z, r24
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    1b58:	f7 01       	movw	r30, r14
    1b5a:	32 85       	ldd	r19, Z+10	; 0x0a
    1b5c:	23 85       	ldd	r18, Z+11	; 0x0b
    1b5e:	94 85       	ldd	r25, Z+12	; 0x0c
    1b60:	85 85       	ldd	r24, Z+13	; 0x0d
    1b62:	e2 5e       	subi	r30, 0xE2	; 226
    1b64:	fd 4f       	sbci	r31, 0xFD	; 253
    1b66:	30 83       	st	Z, r19
    1b68:	f7 01       	movw	r30, r14
    1b6a:	e1 5e       	subi	r30, 0xE1	; 225
    1b6c:	fd 4f       	sbci	r31, 0xFD	; 253
    1b6e:	20 83       	st	Z, r18
    1b70:	f7 01       	movw	r30, r14
    1b72:	e0 5e       	subi	r30, 0xE0	; 224
    1b74:	fd 4f       	sbci	r31, 0xFD	; 253
    1b76:	90 83       	st	Z, r25
    1b78:	f7 01       	movw	r30, r14
    1b7a:	ef 5d       	subi	r30, 0xDF	; 223
    1b7c:	fd 4f       	sbci	r31, 0xFD	; 253
    1b7e:	80 83       	st	Z, r24
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    1b80:	f7 01       	movw	r30, r14
    1b82:	22 89       	ldd	r18, Z+18	; 0x12
    1b84:	33 89       	ldd	r19, Z+19	; 0x13
    1b86:	44 89       	ldd	r20, Z+20	; 0x14
    1b88:	55 89       	ldd	r21, Z+21	; 0x15
    1b8a:	81 81       	ldd	r24, Z+1	; 0x01
    1b8c:	b8 01       	movw	r22, r16
    1b8e:	01 e0       	ldi	r16, 0x01	; 1
    1b90:	0e 94 ed 02 	call	0x5da	; 0x5da <disk_write>
			fs->fsi_flag = 0;
    1b94:	f7 01       	movw	r30, r14
    1b96:	15 82       	std	Z+5, r1	; 0x05
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    1b98:	f7 01       	movw	r30, r14
    1b9a:	81 81       	ldd	r24, Z+1	; 0x01
    1b9c:	60 e0       	ldi	r22, 0x00	; 0
    1b9e:	40 e0       	ldi	r20, 0x00	; 0
    1ba0:	50 e0       	ldi	r21, 0x00	; 0
    1ba2:	0e 94 60 03 	call	0x6c0	; 0x6c0 <disk_ioctl>
    1ba6:	81 11       	cpse	r24, r1
			res = FR_DISK_ERR;
    1ba8:	c1 e0       	ldi	r28, 0x01	; 1
	}

	return res;
}
    1baa:	8c 2f       	mov	r24, r28
    1bac:	cf 91       	pop	r28
    1bae:	1f 91       	pop	r17
    1bb0:	0f 91       	pop	r16
    1bb2:	ff 90       	pop	r15
    1bb4:	ef 90       	pop	r14
    1bb6:	08 95       	ret

00001bb8 <get_fattime>:
#include "diskio.h"		/* Declarations of low level disk I/O functions */

DWORD get_fattime( void )
{
	return 0;
}
    1bb8:	60 e0       	ldi	r22, 0x00	; 0
    1bba:	70 e0       	ldi	r23, 0x00	; 0
    1bbc:	cb 01       	movw	r24, r22
    1bbe:	08 95       	ret

00001bc0 <clust2sect>:

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
    1bc0:	0f 93       	push	r16
    1bc2:	1f 93       	push	r17
    1bc4:	cf 93       	push	r28
    1bc6:	df 93       	push	r29
    1bc8:	ec 01       	movw	r28, r24
    1bca:	db 01       	movw	r26, r22
    1bcc:	ca 01       	movw	r24, r20
	clst -= 2;
    1bce:	02 97       	sbiw	r24, 0x02	; 2
    1bd0:	a1 09       	sbc	r26, r1
    1bd2:	b1 09       	sbc	r27, r1
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    1bd4:	4a 8d       	ldd	r20, Y+26	; 0x1a
    1bd6:	5b 8d       	ldd	r21, Y+27	; 0x1b
    1bd8:	6c 8d       	ldd	r22, Y+28	; 0x1c
    1bda:	7d 8d       	ldd	r23, Y+29	; 0x1d
    1bdc:	42 50       	subi	r20, 0x02	; 2
    1bde:	50 40       	sbci	r21, 0x00	; 0
    1be0:	60 40       	sbci	r22, 0x00	; 0
    1be2:	70 40       	sbci	r23, 0x00	; 0
    1be4:	84 17       	cp	r24, r20
    1be6:	95 07       	cpc	r25, r21
    1be8:	a6 07       	cpc	r26, r22
    1bea:	b7 07       	cpc	r27, r23
    1bec:	98 f4       	brcc	.+38     	; 0x1c14 <clust2sect+0x54>
	return clst * fs->csize + fs->database;
    1bee:	2a 81       	ldd	r18, Y+2	; 0x02
    1bf0:	30 e0       	ldi	r19, 0x00	; 0
    1bf2:	40 e0       	ldi	r20, 0x00	; 0
    1bf4:	50 e0       	ldi	r21, 0x00	; 0
    1bf6:	bc 01       	movw	r22, r24
    1bf8:	cd 01       	movw	r24, r26
    1bfa:	0e 94 33 29 	call	0x5266	; 0x5266 <__mulsi3>
    1bfe:	8b 01       	movw	r16, r22
    1c00:	9c 01       	movw	r18, r24
    1c02:	8a a5       	lds	r24, 0x6a
    1c04:	9b a5       	lds	r25, 0x6b
    1c06:	ac a5       	lds	r26, 0x6c
    1c08:	bd a5       	lds	r27, 0x6d
    1c0a:	08 0f       	add	r16, r24
    1c0c:	19 1f       	adc	r17, r25
    1c0e:	2a 1f       	adc	r18, r26
    1c10:	3b 1f       	adc	r19, r27
    1c12:	03 c0       	rjmp	.+6      	; 0x1c1a <clust2sect+0x5a>
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    1c14:	00 e0       	ldi	r16, 0x00	; 0
    1c16:	10 e0       	ldi	r17, 0x00	; 0
    1c18:	98 01       	movw	r18, r16
	return clst * fs->csize + fs->database;
}
    1c1a:	60 2f       	mov	r22, r16
    1c1c:	71 2f       	mov	r23, r17
    1c1e:	82 2f       	mov	r24, r18
    1c20:	93 2f       	mov	r25, r19
    1c22:	df 91       	pop	r29
    1c24:	cf 91       	pop	r28
    1c26:	1f 91       	pop	r17
    1c28:	0f 91       	pop	r16
    1c2a:	08 95       	ret

00001c2c <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
    1c2c:	8f 92       	push	r8
    1c2e:	9f 92       	push	r9
    1c30:	af 92       	push	r10
    1c32:	bf 92       	push	r11
    1c34:	cf 92       	push	r12
    1c36:	df 92       	push	r13
    1c38:	ef 92       	push	r14
    1c3a:	ff 92       	push	r15
    1c3c:	0f 93       	push	r16
    1c3e:	1f 93       	push	r17
    1c40:	cf 93       	push	r28
    1c42:	df 93       	push	r29
    1c44:	ec 01       	movw	r28, r24
    1c46:	6a 01       	movw	r12, r20
    1c48:	7b 01       	movw	r14, r22
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
    1c4a:	42 30       	cpi	r20, 0x02	; 2
    1c4c:	51 05       	cpc	r21, r1
    1c4e:	61 05       	cpc	r22, r1
    1c50:	71 05       	cpc	r23, r1
    1c52:	08 f4       	brcc	.+2      	; 0x1c56 <get_fat+0x2a>
    1c54:	f4 c0       	rjmp	.+488    	; 0x1e3e <get_fat+0x212>
    1c56:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c58:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1c5a:	ac 8d       	ldd	r26, Y+28	; 0x1c
    1c5c:	bd 8d       	ldd	r27, Y+29	; 0x1d
    1c5e:	48 17       	cp	r20, r24
    1c60:	59 07       	cpc	r21, r25
    1c62:	6a 07       	cpc	r22, r26
    1c64:	7b 07       	cpc	r23, r27
    1c66:	08 f0       	brcs	.+2      	; 0x1c6a <get_fat+0x3e>
    1c68:	ef c0       	rjmp	.+478    	; 0x1e48 <get_fat+0x21c>
		return 1;

	switch (fs->fs_type) {
    1c6a:	88 81       	ld	r24, Y
    1c6c:	82 30       	cpi	r24, 0x02	; 2
    1c6e:	09 f4       	brne	.+2      	; 0x1c72 <get_fat+0x46>
    1c70:	81 c0       	rjmp	.+258    	; 0x1d74 <get_fat+0x148>
    1c72:	83 30       	cpi	r24, 0x03	; 3
    1c74:	09 f4       	brne	.+2      	; 0x1c78 <get_fat+0x4c>
    1c76:	a0 c0       	rjmp	.+320    	; 0x1db8 <get_fat+0x18c>
    1c78:	81 30       	cpi	r24, 0x01	; 1
    1c7a:	09 f0       	breq	.+2      	; 0x1c7e <get_fat+0x52>
    1c7c:	ea c0       	rjmp	.+468    	; 0x1e52 <get_fat+0x226>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
    1c7e:	4a 01       	movw	r8, r20
    1c80:	5b 01       	movw	r10, r22
    1c82:	b6 94       	lsr	r11
    1c84:	a7 94       	ror	r10
    1c86:	97 94       	ror	r9
    1c88:	87 94       	ror	r8
    1c8a:	84 0e       	add	r8, r20
    1c8c:	95 1e       	adc	r9, r21
    1c8e:	a6 1e       	adc	r10, r22
    1c90:	b7 1e       	adc	r11, r23
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    1c92:	b5 01       	movw	r22, r10
    1c94:	a4 01       	movw	r20, r8
    1c96:	03 2e       	mov	r0, r19
    1c98:	39 e0       	ldi	r19, 0x09	; 9
    1c9a:	76 95       	lsr	r23
    1c9c:	67 95       	ror	r22
    1c9e:	57 95       	ror	r21
    1ca0:	47 95       	ror	r20
    1ca2:	3a 95       	dec	r19
    1ca4:	d1 f7       	brne	.-12     	; 0x1c9a <get_fat+0x6e>
    1ca6:	30 2d       	mov	r19, r0
    1ca8:	8a a1       	lds	r24, 0x4a
    1caa:	9b a1       	lds	r25, 0x4b
    1cac:	ac a1       	lds	r26, 0x4c
    1cae:	bd a1       	lds	r27, 0x4d
    1cb0:	48 0f       	add	r20, r24
    1cb2:	59 1f       	adc	r21, r25
    1cb4:	6a 1f       	adc	r22, r26
    1cb6:	7b 1f       	adc	r23, r27
    1cb8:	ce 01       	movw	r24, r28
    1cba:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
    1cbe:	88 23       	and	r24, r24
    1cc0:	09 f0       	breq	.+2      	; 0x1cc4 <get_fat+0x98>
    1cc2:	cb c0       	rjmp	.+406    	; 0x1e5a <get_fat+0x22e>
		wc = fs->win[bc % SS(fs)]; bc++;
    1cc4:	d5 01       	movw	r26, r10
    1cc6:	c4 01       	movw	r24, r8
    1cc8:	91 70       	andi	r25, 0x01	; 1
    1cca:	a0 70       	andi	r26, 0x00	; 0
    1ccc:	b0 70       	andi	r27, 0x00	; 0
    1cce:	fe 01       	movw	r30, r28
    1cd0:	e8 0f       	add	r30, r24
    1cd2:	f9 1f       	adc	r31, r25
    1cd4:	12 a9       	sts	0x42, r17
    1cd6:	08 94       	sec
    1cd8:	81 1c       	adc	r8, r1
    1cda:	91 1c       	adc	r9, r1
    1cdc:	a1 1c       	adc	r10, r1
    1cde:	b1 1c       	adc	r11, r1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    1ce0:	b5 01       	movw	r22, r10
    1ce2:	a4 01       	movw	r20, r8
    1ce4:	03 2e       	mov	r0, r19
    1ce6:	39 e0       	ldi	r19, 0x09	; 9
    1ce8:	76 95       	lsr	r23
    1cea:	67 95       	ror	r22
    1cec:	57 95       	ror	r21
    1cee:	47 95       	ror	r20
    1cf0:	3a 95       	dec	r19
    1cf2:	d1 f7       	brne	.-12     	; 0x1ce8 <get_fat+0xbc>
    1cf4:	30 2d       	mov	r19, r0
    1cf6:	8a a1       	lds	r24, 0x4a
    1cf8:	9b a1       	lds	r25, 0x4b
    1cfa:	ac a1       	lds	r26, 0x4c
    1cfc:	bd a1       	lds	r27, 0x4d
    1cfe:	48 0f       	add	r20, r24
    1d00:	59 1f       	adc	r21, r25
    1d02:	6a 1f       	adc	r22, r26
    1d04:	7b 1f       	adc	r23, r27
    1d06:	ce 01       	movw	r24, r28
    1d08:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
    1d0c:	88 23       	and	r24, r24
    1d0e:	09 f0       	breq	.+2      	; 0x1d12 <get_fat+0xe6>
    1d10:	a8 c0       	rjmp	.+336    	; 0x1e62 <get_fat+0x236>

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
    1d12:	41 2f       	mov	r20, r17
    1d14:	50 e0       	ldi	r21, 0x00	; 0
    1d16:	60 e0       	ldi	r22, 0x00	; 0
    1d18:	70 e0       	ldi	r23, 0x00	; 0
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
    1d1a:	8f ef       	ldi	r24, 0xFF	; 255
    1d1c:	91 e0       	ldi	r25, 0x01	; 1
    1d1e:	a0 e0       	ldi	r26, 0x00	; 0
    1d20:	b0 e0       	ldi	r27, 0x00	; 0
    1d22:	88 22       	and	r8, r24
    1d24:	99 22       	and	r9, r25
    1d26:	aa 22       	and	r10, r26
    1d28:	bb 22       	and	r11, r27
    1d2a:	fe 01       	movw	r30, r28
    1d2c:	e8 0d       	add	r30, r8
    1d2e:	f9 1d       	adc	r31, r9
    1d30:	92 a9       	sts	0x42, r25
    1d32:	80 e0       	ldi	r24, 0x00	; 0
    1d34:	8c 01       	movw	r16, r24
    1d36:	22 27       	eor	r18, r18
    1d38:	17 fd       	sbrc	r17, 7
    1d3a:	20 95       	com	r18
    1d3c:	32 2f       	mov	r19, r18
    1d3e:	40 2b       	or	r20, r16
    1d40:	51 2b       	or	r21, r17
    1d42:	62 2b       	or	r22, r18
    1d44:	73 2b       	or	r23, r19
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    1d46:	91 e0       	ldi	r25, 0x01	; 1
    1d48:	c9 22       	and	r12, r25
    1d4a:	dd 24       	eor	r13, r13
    1d4c:	c1 14       	cp	r12, r1
    1d4e:	d1 04       	cpc	r13, r1
    1d50:	59 f0       	breq	.+22     	; 0x1d68 <get_fat+0x13c>
    1d52:	8a 01       	movw	r16, r20
    1d54:	9b 01       	movw	r18, r22
    1d56:	68 94       	set
    1d58:	13 f8       	bld	r1, 3
    1d5a:	36 95       	lsr	r19
    1d5c:	27 95       	ror	r18
    1d5e:	17 95       	ror	r17
    1d60:	07 95       	ror	r16
    1d62:	16 94       	lsr	r1
    1d64:	d1 f7       	brne	.-12     	; 0x1d5a <get_fat+0x12e>
    1d66:	88 c0       	rjmp	.+272    	; 0x1e78 <get_fat+0x24c>
    1d68:	8a 01       	movw	r16, r20
    1d6a:	9b 01       	movw	r18, r22
    1d6c:	1f 70       	andi	r17, 0x0F	; 15
    1d6e:	20 70       	andi	r18, 0x00	; 0
    1d70:	30 70       	andi	r19, 0x00	; 0
    1d72:	82 c0       	rjmp	.+260    	; 0x1e78 <get_fat+0x24c>

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    1d74:	45 2f       	mov	r20, r21
    1d76:	56 2f       	mov	r21, r22
    1d78:	67 2f       	mov	r22, r23
    1d7a:	77 27       	eor	r23, r23
    1d7c:	8a a1       	lds	r24, 0x4a
    1d7e:	9b a1       	lds	r25, 0x4b
    1d80:	ac a1       	lds	r26, 0x4c
    1d82:	bd a1       	lds	r27, 0x4d
    1d84:	48 0f       	add	r20, r24
    1d86:	59 1f       	adc	r21, r25
    1d88:	6a 1f       	adc	r22, r26
    1d8a:	7b 1f       	adc	r23, r27
    1d8c:	ce 01       	movw	r24, r28
    1d8e:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
    1d92:	88 23       	and	r24, r24
    1d94:	09 f0       	breq	.+2      	; 0x1d98 <get_fat+0x16c>
    1d96:	69 c0       	rjmp	.+210    	; 0x1e6a <get_fat+0x23e>
		p = &fs->win[clst * 2 % SS(fs)];
    1d98:	f6 01       	movw	r30, r12
    1d9a:	ee 0f       	add	r30, r30
    1d9c:	ff 1f       	adc	r31, r31
    1d9e:	f1 70       	andi	r31, 0x01	; 1
		return LD_WORD(p);
    1da0:	ce 0f       	add	r28, r30
    1da2:	df 1f       	adc	r29, r31
    1da4:	9b a9       	sts	0x4b, r25
    1da6:	80 e0       	ldi	r24, 0x00	; 0
    1da8:	0a a9       	sts	0x4a, r16
    1daa:	10 e0       	ldi	r17, 0x00	; 0
    1dac:	80 2b       	or	r24, r16
    1dae:	91 2b       	or	r25, r17
    1db0:	8c 01       	movw	r16, r24
    1db2:	20 e0       	ldi	r18, 0x00	; 0
    1db4:	30 e0       	ldi	r19, 0x00	; 0
    1db6:	60 c0       	rjmp	.+192    	; 0x1e78 <get_fat+0x24c>

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    1db8:	68 94       	set
    1dba:	16 f8       	bld	r1, 6
    1dbc:	76 95       	lsr	r23
    1dbe:	67 95       	ror	r22
    1dc0:	57 95       	ror	r21
    1dc2:	47 95       	ror	r20
    1dc4:	16 94       	lsr	r1
    1dc6:	d1 f7       	brne	.-12     	; 0x1dbc <get_fat+0x190>
    1dc8:	8a a1       	lds	r24, 0x4a
    1dca:	9b a1       	lds	r25, 0x4b
    1dcc:	ac a1       	lds	r26, 0x4c
    1dce:	bd a1       	lds	r27, 0x4d
    1dd0:	48 0f       	add	r20, r24
    1dd2:	59 1f       	adc	r21, r25
    1dd4:	6a 1f       	adc	r22, r26
    1dd6:	7b 1f       	adc	r23, r27
    1dd8:	ce 01       	movw	r24, r28
    1dda:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
    1dde:	88 23       	and	r24, r24
    1de0:	09 f0       	breq	.+2      	; 0x1de4 <get_fat+0x1b8>
    1de2:	47 c0       	rjmp	.+142    	; 0x1e72 <get_fat+0x246>
		p = &fs->win[clst * 4 % SS(fs)];
    1de4:	f6 01       	movw	r30, r12
    1de6:	ee 0f       	add	r30, r30
    1de8:	ff 1f       	adc	r31, r31
    1dea:	ee 0f       	add	r30, r30
    1dec:	ff 1f       	adc	r31, r31
    1dee:	f1 70       	andi	r31, 0x01	; 1
		return LD_DWORD(p) & 0x0FFFFFFF;
    1df0:	ce 0f       	add	r28, r30
    1df2:	df 1f       	adc	r29, r31
    1df4:	0d a9       	sts	0x4d, r16
    1df6:	10 e0       	ldi	r17, 0x00	; 0
    1df8:	20 e0       	ldi	r18, 0x00	; 0
    1dfa:	30 e0       	ldi	r19, 0x00	; 0
    1dfc:	30 2f       	mov	r19, r16
    1dfe:	22 27       	eor	r18, r18
    1e00:	11 27       	eor	r17, r17
    1e02:	00 27       	eor	r16, r16
    1e04:	8c a9       	sts	0x4c, r24
    1e06:	90 e0       	ldi	r25, 0x00	; 0
    1e08:	a0 e0       	ldi	r26, 0x00	; 0
    1e0a:	b0 e0       	ldi	r27, 0x00	; 0
    1e0c:	dc 01       	movw	r26, r24
    1e0e:	99 27       	eor	r25, r25
    1e10:	88 27       	eor	r24, r24
    1e12:	08 2b       	or	r16, r24
    1e14:	19 2b       	or	r17, r25
    1e16:	2a 2b       	or	r18, r26
    1e18:	3b 2b       	or	r19, r27
    1e1a:	8a a9       	sts	0x4a, r24
    1e1c:	90 e0       	ldi	r25, 0x00	; 0
    1e1e:	a0 e0       	ldi	r26, 0x00	; 0
    1e20:	b0 e0       	ldi	r27, 0x00	; 0
    1e22:	08 2b       	or	r16, r24
    1e24:	19 2b       	or	r17, r25
    1e26:	2a 2b       	or	r18, r26
    1e28:	3b 2b       	or	r19, r27
    1e2a:	9b a9       	sts	0x4b, r25
    1e2c:	80 e0       	ldi	r24, 0x00	; 0
    1e2e:	a0 e0       	ldi	r26, 0x00	; 0
    1e30:	b0 e0       	ldi	r27, 0x00	; 0
    1e32:	08 2b       	or	r16, r24
    1e34:	19 2b       	or	r17, r25
    1e36:	2a 2b       	or	r18, r26
    1e38:	3b 2b       	or	r19, r27
    1e3a:	3f 70       	andi	r19, 0x0F	; 15
    1e3c:	1d c0       	rjmp	.+58     	; 0x1e78 <get_fat+0x24c>
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;
    1e3e:	01 e0       	ldi	r16, 0x01	; 1
    1e40:	10 e0       	ldi	r17, 0x00	; 0
    1e42:	20 e0       	ldi	r18, 0x00	; 0
    1e44:	30 e0       	ldi	r19, 0x00	; 0
    1e46:	18 c0       	rjmp	.+48     	; 0x1e78 <get_fat+0x24c>
    1e48:	01 e0       	ldi	r16, 0x01	; 1
    1e4a:	10 e0       	ldi	r17, 0x00	; 0
    1e4c:	20 e0       	ldi	r18, 0x00	; 0
    1e4e:	30 e0       	ldi	r19, 0x00	; 0
    1e50:	13 c0       	rjmp	.+38     	; 0x1e78 <get_fat+0x24c>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    1e52:	0f ef       	ldi	r16, 0xFF	; 255
    1e54:	1f ef       	ldi	r17, 0xFF	; 255
    1e56:	98 01       	movw	r18, r16
    1e58:	0f c0       	rjmp	.+30     	; 0x1e78 <get_fat+0x24c>
    1e5a:	0f ef       	ldi	r16, 0xFF	; 255
    1e5c:	1f ef       	ldi	r17, 0xFF	; 255
    1e5e:	98 01       	movw	r18, r16
    1e60:	0b c0       	rjmp	.+22     	; 0x1e78 <get_fat+0x24c>
    1e62:	0f ef       	ldi	r16, 0xFF	; 255
    1e64:	1f ef       	ldi	r17, 0xFF	; 255
    1e66:	98 01       	movw	r18, r16
    1e68:	07 c0       	rjmp	.+14     	; 0x1e78 <get_fat+0x24c>
    1e6a:	0f ef       	ldi	r16, 0xFF	; 255
    1e6c:	1f ef       	ldi	r17, 0xFF	; 255
    1e6e:	98 01       	movw	r18, r16
    1e70:	03 c0       	rjmp	.+6      	; 0x1e78 <get_fat+0x24c>
    1e72:	0f ef       	ldi	r16, 0xFF	; 255
    1e74:	1f ef       	ldi	r17, 0xFF	; 255
    1e76:	98 01       	movw	r18, r16
}
    1e78:	60 2f       	mov	r22, r16
    1e7a:	71 2f       	mov	r23, r17
    1e7c:	82 2f       	mov	r24, r18
    1e7e:	93 2f       	mov	r25, r19
    1e80:	df 91       	pop	r29
    1e82:	cf 91       	pop	r28
    1e84:	1f 91       	pop	r17
    1e86:	0f 91       	pop	r16
    1e88:	ff 90       	pop	r15
    1e8a:	ef 90       	pop	r14
    1e8c:	df 90       	pop	r13
    1e8e:	cf 90       	pop	r12
    1e90:	bf 90       	pop	r11
    1e92:	af 90       	pop	r10
    1e94:	9f 90       	pop	r9
    1e96:	8f 90       	pop	r8
    1e98:	08 95       	ret

00001e9a <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Index of directory table */
)
{
    1e9a:	ef 92       	push	r14
    1e9c:	ff 92       	push	r15
    1e9e:	0f 93       	push	r16
    1ea0:	1f 93       	push	r17
    1ea2:	cf 93       	push	r28
    1ea4:	df 93       	push	r29
    1ea6:	ec 01       	movw	r28, r24
    1ea8:	8b 01       	movw	r16, r22
	DWORD clst;
	WORD ic;


	dj->index = idx;
    1eaa:	7d 83       	std	Y+5, r23	; 0x05
    1eac:	6c 83       	std	Y+4, r22	; 0x04
	clst = dj->sclust;
    1eae:	4e 81       	ldd	r20, Y+6	; 0x06
    1eb0:	5f 81       	ldd	r21, Y+7	; 0x07
    1eb2:	68 85       	ldd	r22, Y+8	; 0x08
    1eb4:	79 85       	ldd	r23, Y+9	; 0x09
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    1eb6:	41 30       	cpi	r20, 0x01	; 1
    1eb8:	51 05       	cpc	r21, r1
    1eba:	61 05       	cpc	r22, r1
    1ebc:	71 05       	cpc	r23, r1
    1ebe:	09 f4       	brne	.+2      	; 0x1ec2 <dir_sdi+0x28>
    1ec0:	9f c0       	rjmp	.+318    	; 0x2000 <dir_sdi+0x166>
    1ec2:	e8 81       	ld	r30, Y
    1ec4:	f9 81       	ldd	r31, Y+1	; 0x01
    1ec6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ec8:	93 8d       	ldd	r25, Z+27	; 0x1b
    1eca:	a4 8d       	ldd	r26, Z+28	; 0x1c
    1ecc:	b5 8d       	ldd	r27, Z+29	; 0x1d
    1ece:	48 17       	cp	r20, r24
    1ed0:	59 07       	cpc	r21, r25
    1ed2:	6a 07       	cpc	r22, r26
    1ed4:	7b 07       	cpc	r23, r27
    1ed6:	08 f0       	brcs	.+2      	; 0x1eda <dir_sdi+0x40>
    1ed8:	95 c0       	rjmp	.+298    	; 0x2004 <dir_sdi+0x16a>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    1eda:	41 15       	cp	r20, r1
    1edc:	51 05       	cpc	r21, r1
    1ede:	61 05       	cpc	r22, r1
    1ee0:	71 05       	cpc	r23, r1
    1ee2:	69 f5       	brne	.+90     	; 0x1f3e <dir_sdi+0xa4>
    1ee4:	80 81       	ld	r24, Z
    1ee6:	83 30       	cpi	r24, 0x03	; 3
    1ee8:	49 f4       	brne	.+18     	; 0x1efc <dir_sdi+0x62>
		clst = dj->fs->dirbase;
    1eea:	46 a1       	lds	r20, 0x46
    1eec:	57 a1       	lds	r21, 0x47
    1eee:	60 a5       	lds	r22, 0x60
    1ef0:	71 a5       	lds	r23, 0x61

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    1ef2:	41 15       	cp	r20, r1
    1ef4:	51 05       	cpc	r21, r1
    1ef6:	61 05       	cpc	r22, r1
    1ef8:	71 05       	cpc	r23, r1
    1efa:	09 f5       	brne	.+66     	; 0x1f3e <dir_sdi+0xa4>
		dj->clust = clst;
    1efc:	1a 86       	std	Y+10, r1	; 0x0a
    1efe:	1b 86       	std	Y+11, r1	; 0x0b
    1f00:	1c 86       	std	Y+12, r1	; 0x0c
    1f02:	1d 86       	std	Y+13, r1	; 0x0d
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    1f04:	80 85       	ldd	r24, Z+8	; 0x08
    1f06:	91 85       	ldd	r25, Z+9	; 0x09
    1f08:	08 17       	cp	r16, r24
    1f0a:	19 07       	cpc	r17, r25
    1f0c:	08 f0       	brcs	.+2      	; 0x1f10 <dir_sdi+0x76>
    1f0e:	7c c0       	rjmp	.+248    	; 0x2008 <dir_sdi+0x16e>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    1f10:	c8 01       	movw	r24, r16
    1f12:	92 95       	swap	r25
    1f14:	82 95       	swap	r24
    1f16:	8f 70       	andi	r24, 0x0F	; 15
    1f18:	89 27       	eor	r24, r25
    1f1a:	9f 70       	andi	r25, 0x0F	; 15
    1f1c:	89 27       	eor	r24, r25
    1f1e:	ac 01       	movw	r20, r24
    1f20:	60 e0       	ldi	r22, 0x00	; 0
    1f22:	70 e0       	ldi	r23, 0x00	; 0
    1f24:	86 a1       	lds	r24, 0x46
    1f26:	97 a1       	lds	r25, 0x47
    1f28:	a0 a5       	lds	r26, 0x60
    1f2a:	b1 a5       	lds	r27, 0x61
    1f2c:	84 0f       	add	r24, r20
    1f2e:	95 1f       	adc	r25, r21
    1f30:	a6 1f       	adc	r26, r22
    1f32:	b7 1f       	adc	r27, r23
    1f34:	8e 87       	std	Y+14, r24	; 0x0e
    1f36:	9f 87       	std	Y+15, r25	; 0x0f
    1f38:	a8 8b       	std	Y+16, r26	; 0x10
    1f3a:	b9 8b       	std	Y+17, r27	; 0x11
    1f3c:	4e c0       	rjmp	.+156    	; 0x1fda <dir_sdi+0x140>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    1f3e:	82 81       	ldd	r24, Z+2	; 0x02
    1f40:	90 e0       	ldi	r25, 0x00	; 0
    1f42:	7c 01       	movw	r14, r24
    1f44:	ee 0c       	add	r14, r14
    1f46:	ff 1c       	adc	r15, r15
    1f48:	ee 0c       	add	r14, r14
    1f4a:	ff 1c       	adc	r15, r15
    1f4c:	ee 0c       	add	r14, r14
    1f4e:	ff 1c       	adc	r15, r15
    1f50:	ee 0c       	add	r14, r14
    1f52:	ff 1c       	adc	r15, r15
		while (idx >= ic) {	/* Follow cluster chain */
    1f54:	0e 15       	cp	r16, r14
    1f56:	1f 05       	cpc	r17, r15
    1f58:	28 f1       	brcs	.+74     	; 0x1fa4 <dir_sdi+0x10a>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    1f5a:	88 81       	ld	r24, Y
    1f5c:	99 81       	ldd	r25, Y+1	; 0x01
    1f5e:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <get_fat>
    1f62:	ab 01       	movw	r20, r22
    1f64:	bc 01       	movw	r22, r24
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    1f66:	4f 3f       	cpi	r20, 0xFF	; 255
    1f68:	8f ef       	ldi	r24, 0xFF	; 255
    1f6a:	58 07       	cpc	r21, r24
    1f6c:	8f ef       	ldi	r24, 0xFF	; 255
    1f6e:	68 07       	cpc	r22, r24
    1f70:	8f ef       	ldi	r24, 0xFF	; 255
    1f72:	78 07       	cpc	r23, r24
    1f74:	09 f4       	brne	.+2      	; 0x1f78 <dir_sdi+0xde>
    1f76:	4a c0       	rjmp	.+148    	; 0x200c <dir_sdi+0x172>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    1f78:	42 30       	cpi	r20, 0x02	; 2
    1f7a:	51 05       	cpc	r21, r1
    1f7c:	61 05       	cpc	r22, r1
    1f7e:	71 05       	cpc	r23, r1
    1f80:	08 f4       	brcc	.+2      	; 0x1f84 <dir_sdi+0xea>
    1f82:	46 c0       	rjmp	.+140    	; 0x2010 <dir_sdi+0x176>
    1f84:	e8 81       	ld	r30, Y
    1f86:	f9 81       	ldd	r31, Y+1	; 0x01
    1f88:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f8a:	93 8d       	ldd	r25, Z+27	; 0x1b
    1f8c:	a4 8d       	ldd	r26, Z+28	; 0x1c
    1f8e:	b5 8d       	ldd	r27, Z+29	; 0x1d
    1f90:	48 17       	cp	r20, r24
    1f92:	59 07       	cpc	r21, r25
    1f94:	6a 07       	cpc	r22, r26
    1f96:	7b 07       	cpc	r23, r27
    1f98:	e8 f5       	brcc	.+122    	; 0x2014 <dir_sdi+0x17a>
				return FR_INT_ERR;
			idx -= ic;
    1f9a:	0e 19       	sub	r16, r14
    1f9c:	1f 09       	sbc	r17, r15
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
    1f9e:	0e 15       	cp	r16, r14
    1fa0:	1f 05       	cpc	r17, r15
    1fa2:	d8 f6       	brcc	.-74     	; 0x1f5a <dir_sdi+0xc0>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
    1fa4:	4a 87       	std	Y+10, r20	; 0x0a
    1fa6:	5b 87       	std	Y+11, r21	; 0x0b
    1fa8:	6c 87       	std	Y+12, r22	; 0x0c
    1faa:	7d 87       	std	Y+13, r23	; 0x0d
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    1fac:	88 81       	ld	r24, Y
    1fae:	99 81       	ldd	r25, Y+1	; 0x01
    1fb0:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <clust2sect>
    1fb4:	ab 01       	movw	r20, r22
    1fb6:	bc 01       	movw	r22, r24
    1fb8:	c8 01       	movw	r24, r16
    1fba:	92 95       	swap	r25
    1fbc:	82 95       	swap	r24
    1fbe:	8f 70       	andi	r24, 0x0F	; 15
    1fc0:	89 27       	eor	r24, r25
    1fc2:	9f 70       	andi	r25, 0x0F	; 15
    1fc4:	89 27       	eor	r24, r25
    1fc6:	a0 e0       	ldi	r26, 0x00	; 0
    1fc8:	b0 e0       	ldi	r27, 0x00	; 0
    1fca:	84 0f       	add	r24, r20
    1fcc:	95 1f       	adc	r25, r21
    1fce:	a6 1f       	adc	r26, r22
    1fd0:	b7 1f       	adc	r27, r23
    1fd2:	8e 87       	std	Y+14, r24	; 0x0e
    1fd4:	9f 87       	std	Y+15, r25	; 0x0f
    1fd6:	a8 8b       	std	Y+16, r26	; 0x10
    1fd8:	b9 8b       	std	Y+17, r27	; 0x11
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    1fda:	88 81       	ld	r24, Y
    1fdc:	99 81       	ldd	r25, Y+1	; 0x01
    1fde:	c2 96       	adiw	r24, 0x32	; 50
    1fe0:	0f 70       	andi	r16, 0x0F	; 15
    1fe2:	10 70       	andi	r17, 0x00	; 0
    1fe4:	00 0f       	add	r16, r16
    1fe6:	11 1f       	adc	r17, r17
    1fe8:	02 95       	swap	r16
    1fea:	12 95       	swap	r17
    1fec:	10 7f       	andi	r17, 0xF0	; 240
    1fee:	10 27       	eor	r17, r16
    1ff0:	00 7f       	andi	r16, 0xF0	; 240
    1ff2:	10 27       	eor	r17, r16
    1ff4:	80 0f       	add	r24, r16
    1ff6:	91 1f       	adc	r25, r17
    1ff8:	9b 8b       	std	Y+19, r25	; 0x13
    1ffa:	8a 8b       	std	Y+18, r24	; 0x12

	return FR_OK;	/* Seek succeeded */
    1ffc:	80 e0       	ldi	r24, 0x00	; 0
    1ffe:	0b c0       	rjmp	.+22     	; 0x2016 <dir_sdi+0x17c>


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
    2000:	82 e0       	ldi	r24, 0x02	; 2
    2002:	09 c0       	rjmp	.+18     	; 0x2016 <dir_sdi+0x17c>
    2004:	82 e0       	ldi	r24, 0x02	; 2
    2006:	07 c0       	rjmp	.+14     	; 0x2016 <dir_sdi+0x17c>
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
    2008:	82 e0       	ldi	r24, 0x02	; 2
    200a:	05 c0       	rjmp	.+10     	; 0x2016 <dir_sdi+0x17c>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    200c:	81 e0       	ldi	r24, 0x01	; 1
    200e:	03 c0       	rjmp	.+6      	; 0x2016 <dir_sdi+0x17c>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
    2010:	82 e0       	ldi	r24, 0x02	; 2
    2012:	01 c0       	rjmp	.+2      	; 0x2016 <dir_sdi+0x17c>
    2014:	82 e0       	ldi	r24, 0x02	; 2
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
    2016:	df 91       	pop	r29
    2018:	cf 91       	pop	r28
    201a:	1f 91       	pop	r17
    201c:	0f 91       	pop	r16
    201e:	ff 90       	pop	r15
    2020:	ef 90       	pop	r14
    2022:	08 95       	ret

00002024 <dir_remove>:
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
	DIR *dj				/* Directory object pointing the entry to be removed */
)
{
    2024:	cf 93       	push	r28
    2026:	df 93       	push	r29
    2028:	ec 01       	movw	r28, r24
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
	}

#else			/* Non LFN configuration */
	res = dir_sdi(dj, dj->index);
    202a:	6c 81       	ldd	r22, Y+4	; 0x04
    202c:	7d 81       	ldd	r23, Y+5	; 0x05
    202e:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <dir_sdi>
	if (res == FR_OK) {
    2032:	88 23       	and	r24, r24
    2034:	91 f4       	brne	.+36     	; 0x205a <dir_remove+0x36>
		res = move_window(dj->fs, dj->sect);
    2036:	4e 85       	ldd	r20, Y+14	; 0x0e
    2038:	5f 85       	ldd	r21, Y+15	; 0x0f
    203a:	68 89       	ldd	r22, Y+16	; 0x10
    203c:	79 89       	ldd	r23, Y+17	; 0x11
    203e:	88 81       	ld	r24, Y
    2040:	99 81       	ldd	r25, Y+1	; 0x01
    2042:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
		if (res == FR_OK) {
    2046:	88 23       	and	r24, r24
    2048:	41 f4       	brne	.+16     	; 0x205a <dir_remove+0x36>
			*dj->dir = DDE;			/* Mark the entry "deleted" */
    204a:	ea 89       	ldd	r30, Y+18	; 0x12
    204c:	fb 89       	ldd	r31, Y+19	; 0x13
    204e:	95 ee       	ldi	r25, 0xE5	; 229
    2050:	90 83       	st	Z, r25
			dj->fs->wflag = 1;
    2052:	e8 81       	ld	r30, Y
    2054:	f9 81       	ldd	r31, Y+1	; 0x01
    2056:	91 e0       	ldi	r25, 0x01	; 1
    2058:	94 83       	std	Z+4, r25	; 0x04
		}
	}
#endif

	return res;
}
    205a:	df 91       	pop	r29
    205c:	cf 91       	pop	r28
    205e:	08 95       	ret

00002060 <put_fat>:
FRESULT put_fat (
	FATFS *fs,	/* File system object */
	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
	DWORD val	/* New value to mark the cluster */
)
{
    2060:	4f 92       	push	r4
    2062:	5f 92       	push	r5
    2064:	6f 92       	push	r6
    2066:	7f 92       	push	r7
    2068:	8f 92       	push	r8
    206a:	9f 92       	push	r9
    206c:	af 92       	push	r10
    206e:	bf 92       	push	r11
    2070:	cf 92       	push	r12
    2072:	df 92       	push	r13
    2074:	ef 92       	push	r14
    2076:	ff 92       	push	r15
    2078:	0f 93       	push	r16
    207a:	1f 93       	push	r17
    207c:	cf 93       	push	r28
    207e:	df 93       	push	r29
    2080:	ec 01       	movw	r28, r24
    2082:	6a 01       	movw	r12, r20
    2084:	7b 01       	movw	r14, r22
    2086:	48 01       	movw	r8, r16
    2088:	59 01       	movw	r10, r18
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    208a:	42 30       	cpi	r20, 0x02	; 2
    208c:	51 05       	cpc	r21, r1
    208e:	61 05       	cpc	r22, r1
    2090:	71 05       	cpc	r23, r1
    2092:	08 f4       	brcc	.+2      	; 0x2096 <put_fat+0x36>
    2094:	e0 c0       	rjmp	.+448    	; 0x2256 <put_fat+0x1f6>
    2096:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2098:	9b 8d       	ldd	r25, Y+27	; 0x1b
    209a:	ac 8d       	ldd	r26, Y+28	; 0x1c
    209c:	bd 8d       	ldd	r27, Y+29	; 0x1d
    209e:	48 17       	cp	r20, r24
    20a0:	59 07       	cpc	r21, r25
    20a2:	6a 07       	cpc	r22, r26
    20a4:	7b 07       	cpc	r23, r27
    20a6:	08 f0       	brcs	.+2      	; 0x20aa <put_fat+0x4a>
    20a8:	d8 c0       	rjmp	.+432    	; 0x225a <put_fat+0x1fa>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
    20aa:	88 81       	ld	r24, Y
    20ac:	82 30       	cpi	r24, 0x02	; 2
    20ae:	09 f4       	brne	.+2      	; 0x20b2 <put_fat+0x52>
    20b0:	80 c0       	rjmp	.+256    	; 0x21b2 <put_fat+0x152>
    20b2:	83 30       	cpi	r24, 0x03	; 3
    20b4:	09 f4       	brne	.+2      	; 0x20b8 <put_fat+0x58>
    20b6:	98 c0       	rjmp	.+304    	; 0x21e8 <put_fat+0x188>
    20b8:	81 30       	cpi	r24, 0x01	; 1
    20ba:	09 f0       	breq	.+2      	; 0x20be <put_fat+0x5e>
    20bc:	c8 c0       	rjmp	.+400    	; 0x224e <put_fat+0x1ee>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
    20be:	db 01       	movw	r26, r22
    20c0:	ca 01       	movw	r24, r20
    20c2:	b6 95       	lsr	r27
    20c4:	a7 95       	ror	r26
    20c6:	97 95       	ror	r25
    20c8:	87 95       	ror	r24
    20ca:	2c 01       	movw	r4, r24
    20cc:	3d 01       	movw	r6, r26
    20ce:	44 0e       	add	r4, r20
    20d0:	55 1e       	adc	r5, r21
    20d2:	66 1e       	adc	r6, r22
    20d4:	77 1e       	adc	r7, r23
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    20d6:	b3 01       	movw	r22, r6
    20d8:	a2 01       	movw	r20, r4
    20da:	03 2e       	mov	r0, r19
    20dc:	39 e0       	ldi	r19, 0x09	; 9
    20de:	76 95       	lsr	r23
    20e0:	67 95       	ror	r22
    20e2:	57 95       	ror	r21
    20e4:	47 95       	ror	r20
    20e6:	3a 95       	dec	r19
    20e8:	d1 f7       	brne	.-12     	; 0x20de <put_fat+0x7e>
    20ea:	30 2d       	mov	r19, r0
    20ec:	8a a1       	lds	r24, 0x4a
    20ee:	9b a1       	lds	r25, 0x4b
    20f0:	ac a1       	lds	r26, 0x4c
    20f2:	bd a1       	lds	r27, 0x4d
    20f4:	48 0f       	add	r20, r24
    20f6:	59 1f       	adc	r21, r25
    20f8:	6a 1f       	adc	r22, r26
    20fa:	7b 1f       	adc	r23, r27
    20fc:	ce 01       	movw	r24, r28
    20fe:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
			if (res != FR_OK) break;
    2102:	88 23       	and	r24, r24
    2104:	09 f0       	breq	.+2      	; 0x2108 <put_fat+0xa8>
    2106:	a4 c0       	rjmp	.+328    	; 0x2250 <put_fat+0x1f0>
			p = &fs->win[bc % SS(fs)];
    2108:	c2 01       	movw	r24, r4
    210a:	91 70       	andi	r25, 0x01	; 1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    210c:	31 e0       	ldi	r19, 0x01	; 1
    210e:	c3 22       	and	r12, r19
    2110:	dd 24       	eor	r13, r13
    2112:	c1 14       	cp	r12, r1
    2114:	d1 04       	cpc	r13, r1
    2116:	51 f0       	breq	.+20     	; 0x212c <put_fat+0xcc>
    2118:	fe 01       	movw	r30, r28
    211a:	e8 0f       	add	r30, r24
    211c:	f9 1f       	adc	r31, r25
    211e:	22 a9       	sts	0x42, r18
    2120:	2f 70       	andi	r18, 0x0F	; 15
    2122:	38 2d       	mov	r19, r8
    2124:	32 95       	swap	r19
    2126:	30 7f       	andi	r19, 0xF0	; 240
    2128:	23 2b       	or	r18, r19
    212a:	01 c0       	rjmp	.+2      	; 0x212e <put_fat+0xce>
    212c:	28 2d       	mov	r18, r8
    212e:	fe 01       	movw	r30, r28
    2130:	e8 0f       	add	r30, r24
    2132:	f9 1f       	adc	r31, r25
    2134:	22 ab       	sts	0x52, r18
			bc++;
    2136:	08 94       	sec
    2138:	41 1c       	adc	r4, r1
    213a:	51 1c       	adc	r5, r1
    213c:	61 1c       	adc	r6, r1
    213e:	71 1c       	adc	r7, r1
			fs->wflag = 1;
    2140:	81 e0       	ldi	r24, 0x01	; 1
    2142:	8c 83       	std	Y+4, r24	; 0x04
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    2144:	b3 01       	movw	r22, r6
    2146:	a2 01       	movw	r20, r4
    2148:	03 2e       	mov	r0, r19
    214a:	39 e0       	ldi	r19, 0x09	; 9
    214c:	76 95       	lsr	r23
    214e:	67 95       	ror	r22
    2150:	57 95       	ror	r21
    2152:	47 95       	ror	r20
    2154:	3a 95       	dec	r19
    2156:	d1 f7       	brne	.-12     	; 0x214c <put_fat+0xec>
    2158:	30 2d       	mov	r19, r0
    215a:	8a a1       	lds	r24, 0x4a
    215c:	9b a1       	lds	r25, 0x4b
    215e:	ac a1       	lds	r26, 0x4c
    2160:	bd a1       	lds	r27, 0x4d
    2162:	48 0f       	add	r20, r24
    2164:	59 1f       	adc	r21, r25
    2166:	6a 1f       	adc	r22, r26
    2168:	7b 1f       	adc	r23, r27
    216a:	ce 01       	movw	r24, r28
    216c:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
			if (res != FR_OK) break;
    2170:	88 23       	and	r24, r24
    2172:	09 f0       	breq	.+2      	; 0x2176 <put_fat+0x116>
    2174:	6d c0       	rjmp	.+218    	; 0x2250 <put_fat+0x1f0>
			p = &fs->win[bc % SS(fs)];
    2176:	ef ef       	ldi	r30, 0xFF	; 255
    2178:	f1 e0       	ldi	r31, 0x01	; 1
    217a:	4e 22       	and	r4, r30
    217c:	5f 22       	and	r5, r31
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    217e:	c1 14       	cp	r12, r1
    2180:	d1 04       	cpc	r13, r1
    2182:	49 f0       	breq	.+18     	; 0x2196 <put_fat+0x136>
    2184:	68 94       	set
    2186:	13 f8       	bld	r1, 3
    2188:	b6 94       	lsr	r11
    218a:	a7 94       	ror	r10
    218c:	97 94       	ror	r9
    218e:	87 94       	ror	r8
    2190:	16 94       	lsr	r1
    2192:	d1 f7       	brne	.-12     	; 0x2188 <put_fat+0x128>
    2194:	09 c0       	rjmp	.+18     	; 0x21a8 <put_fat+0x148>
    2196:	fe 01       	movw	r30, r28
    2198:	e4 0d       	add	r30, r4
    219a:	f5 1d       	adc	r31, r5
    219c:	22 a9       	sts	0x42, r18
    219e:	20 7f       	andi	r18, 0xF0	; 240
    21a0:	99 2d       	mov	r25, r9
    21a2:	9f 70       	andi	r25, 0x0F	; 15
    21a4:	82 2e       	mov	r8, r18
    21a6:	89 2a       	or	r8, r25
    21a8:	4c 0e       	add	r4, r28
    21aa:	5d 1e       	adc	r5, r29
    21ac:	f2 01       	movw	r30, r4
    21ae:	82 aa       	sts	0x92, r24
			break;
    21b0:	4f c0       	rjmp	.+158    	; 0x2250 <put_fat+0x1f0>

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    21b2:	45 2f       	mov	r20, r21
    21b4:	56 2f       	mov	r21, r22
    21b6:	67 2f       	mov	r22, r23
    21b8:	77 27       	eor	r23, r23
    21ba:	8a a1       	lds	r24, 0x4a
    21bc:	9b a1       	lds	r25, 0x4b
    21be:	ac a1       	lds	r26, 0x4c
    21c0:	bd a1       	lds	r27, 0x4d
    21c2:	48 0f       	add	r20, r24
    21c4:	59 1f       	adc	r21, r25
    21c6:	6a 1f       	adc	r22, r26
    21c8:	7b 1f       	adc	r23, r27
    21ca:	ce 01       	movw	r24, r28
    21cc:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
			if (res != FR_OK) break;
    21d0:	88 23       	and	r24, r24
    21d2:	09 f0       	breq	.+2      	; 0x21d6 <put_fat+0x176>
    21d4:	3d c0       	rjmp	.+122    	; 0x2250 <put_fat+0x1f0>
			p = &fs->win[clst * 2 % SS(fs)];
    21d6:	f6 01       	movw	r30, r12
    21d8:	ee 0f       	add	r30, r30
    21da:	ff 1f       	adc	r31, r31
    21dc:	f1 70       	andi	r31, 0x01	; 1
			ST_WORD(p, (WORD)val);
    21de:	ec 0f       	add	r30, r28
    21e0:	fd 1f       	adc	r31, r29
    21e2:	82 aa       	sts	0x92, r24
    21e4:	93 aa       	sts	0x93, r25
			break;
    21e6:	34 c0       	rjmp	.+104    	; 0x2250 <put_fat+0x1f0>

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    21e8:	68 94       	set
    21ea:	16 f8       	bld	r1, 6
    21ec:	76 95       	lsr	r23
    21ee:	67 95       	ror	r22
    21f0:	57 95       	ror	r21
    21f2:	47 95       	ror	r20
    21f4:	16 94       	lsr	r1
    21f6:	d1 f7       	brne	.-12     	; 0x21ec <put_fat+0x18c>
    21f8:	8a a1       	lds	r24, 0x4a
    21fa:	9b a1       	lds	r25, 0x4b
    21fc:	ac a1       	lds	r26, 0x4c
    21fe:	bd a1       	lds	r27, 0x4d
    2200:	48 0f       	add	r20, r24
    2202:	59 1f       	adc	r21, r25
    2204:	6a 1f       	adc	r22, r26
    2206:	7b 1f       	adc	r23, r27
    2208:	ce 01       	movw	r24, r28
    220a:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
			if (res != FR_OK) break;
    220e:	88 23       	and	r24, r24
    2210:	f9 f4       	brne	.+62     	; 0x2250 <put_fat+0x1f0>
			p = &fs->win[clst * 4 % SS(fs)];
    2212:	96 01       	movw	r18, r12
    2214:	22 0f       	add	r18, r18
    2216:	33 1f       	adc	r19, r19
    2218:	22 0f       	add	r18, r18
    221a:	33 1f       	adc	r19, r19
    221c:	31 70       	andi	r19, 0x01	; 1
			val |= LD_DWORD(p) & 0xF0000000;
    221e:	fe 01       	movw	r30, r28
    2220:	e2 0f       	add	r30, r18
    2222:	f3 1f       	adc	r31, r19
    2224:	45 a9       	sts	0x45, r20
    2226:	50 e0       	ldi	r21, 0x00	; 0
    2228:	60 e0       	ldi	r22, 0x00	; 0
    222a:	70 e0       	ldi	r23, 0x00	; 0
    222c:	74 2f       	mov	r23, r20
    222e:	66 27       	eor	r22, r22
    2230:	55 27       	eor	r21, r21
    2232:	44 27       	eor	r20, r20
    2234:	40 70       	andi	r20, 0x00	; 0
    2236:	50 70       	andi	r21, 0x00	; 0
    2238:	60 70       	andi	r22, 0x00	; 0
    223a:	70 7f       	andi	r23, 0xF0	; 240
    223c:	48 29       	or	r20, r8
    223e:	59 29       	or	r21, r9
    2240:	6a 29       	or	r22, r10
    2242:	7b 29       	or	r23, r11
			ST_DWORD(p, val);
    2244:	42 ab       	sts	0x52, r20
    2246:	53 ab       	sts	0x53, r21
    2248:	64 ab       	sts	0x54, r22
    224a:	75 ab       	sts	0x55, r23
			break;
    224c:	01 c0       	rjmp	.+2      	; 0x2250 <put_fat+0x1f0>

		default :
			res = FR_INT_ERR;
    224e:	82 e0       	ldi	r24, 0x02	; 2
		}
		fs->wflag = 1;
    2250:	91 e0       	ldi	r25, 0x01	; 1
    2252:	9c 83       	std	Y+4, r25	; 0x04
    2254:	03 c0       	rjmp	.+6      	; 0x225c <put_fat+0x1fc>
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
    2256:	82 e0       	ldi	r24, 0x02	; 2
    2258:	01 c0       	rjmp	.+2      	; 0x225c <put_fat+0x1fc>
    225a:	82 e0       	ldi	r24, 0x02	; 2
		}
		fs->wflag = 1;
	}

	return res;
}
    225c:	df 91       	pop	r29
    225e:	cf 91       	pop	r28
    2260:	1f 91       	pop	r17
    2262:	0f 91       	pop	r16
    2264:	ff 90       	pop	r15
    2266:	ef 90       	pop	r14
    2268:	df 90       	pop	r13
    226a:	cf 90       	pop	r12
    226c:	bf 90       	pop	r11
    226e:	af 90       	pop	r10
    2270:	9f 90       	pop	r9
    2272:	8f 90       	pop	r8
    2274:	7f 90       	pop	r7
    2276:	6f 90       	pop	r6
    2278:	5f 90       	pop	r5
    227a:	4f 90       	pop	r4
    227c:	08 95       	ret

0000227e <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
    227e:	2f 92       	push	r2
    2280:	3f 92       	push	r3
    2282:	4f 92       	push	r4
    2284:	5f 92       	push	r5
    2286:	6f 92       	push	r6
    2288:	7f 92       	push	r7
    228a:	8f 92       	push	r8
    228c:	9f 92       	push	r9
    228e:	af 92       	push	r10
    2290:	bf 92       	push	r11
    2292:	cf 92       	push	r12
    2294:	df 92       	push	r13
    2296:	ef 92       	push	r14
    2298:	ff 92       	push	r15
    229a:	0f 93       	push	r16
    229c:	1f 93       	push	r17
    229e:	cf 93       	push	r28
    22a0:	df 93       	push	r29
    22a2:	00 d0       	rcall	.+0      	; 0x22a4 <create_chain+0x26>
    22a4:	00 d0       	rcall	.+0      	; 0x22a6 <create_chain+0x28>
    22a6:	cd b7       	in	r28, 0x3d	; 61
    22a8:	de b7       	in	r29, 0x3e	; 62
    22aa:	1c 01       	movw	r2, r24
    22ac:	49 83       	std	Y+1, r20	; 0x01
    22ae:	5a 83       	std	Y+2, r21	; 0x02
    22b0:	6b 83       	std	Y+3, r22	; 0x03
    22b2:	7c 83       	std	Y+4, r23	; 0x04
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
    22b4:	41 15       	cp	r20, r1
    22b6:	51 05       	cpc	r21, r1
    22b8:	61 05       	cpc	r22, r1
    22ba:	71 05       	cpc	r23, r1
    22bc:	c1 f4       	brne	.+48     	; 0x22ee <create_chain+0x70>
		scl = fs->last_clust;			/* Get suggested start point */
    22be:	dc 01       	movw	r26, r24
    22c0:	1a 96       	adiw	r26, 0x0a	; 10
    22c2:	8d 90       	ld	r8, X+
    22c4:	9d 90       	ld	r9, X+
    22c6:	ad 90       	ld	r10, X+
    22c8:	bc 90       	ld	r11, X
    22ca:	1d 97       	sbiw	r26, 0x0d	; 13
		if (!scl || scl >= fs->n_fatent) scl = 1;
    22cc:	81 14       	cp	r8, r1
    22ce:	91 04       	cpc	r9, r1
    22d0:	a1 04       	cpc	r10, r1
    22d2:	b1 04       	cpc	r11, r1
    22d4:	51 f1       	breq	.+84     	; 0x232a <create_chain+0xac>
    22d6:	5a 96       	adiw	r26, 0x1a	; 26
    22d8:	8d 91       	ld	r24, X+
    22da:	9d 91       	ld	r25, X+
    22dc:	0d 90       	ld	r0, X+
    22de:	bc 91       	ld	r27, X
    22e0:	a0 2d       	mov	r26, r0
    22e2:	88 16       	cp	r8, r24
    22e4:	99 06       	cpc	r9, r25
    22e6:	aa 06       	cpc	r10, r26
    22e8:	bb 06       	cpc	r11, r27
    22ea:	20 f5       	brcc	.+72     	; 0x2334 <create_chain+0xb6>
    22ec:	27 c0       	rjmp	.+78     	; 0x233c <create_chain+0xbe>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
    22ee:	49 81       	ldd	r20, Y+1	; 0x01
    22f0:	5a 81       	ldd	r21, Y+2	; 0x02
    22f2:	6b 81       	ldd	r22, Y+3	; 0x03
    22f4:	7c 81       	ldd	r23, Y+4	; 0x04
    22f6:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <get_fat>
    22fa:	8b 01       	movw	r16, r22
    22fc:	9c 01       	movw	r18, r24
		if (cs < 2) return 1;			/* It is an invalid cluster */
    22fe:	62 30       	cpi	r22, 0x02	; 2
    2300:	71 05       	cpc	r23, r1
    2302:	81 05       	cpc	r24, r1
    2304:	91 05       	cpc	r25, r1
    2306:	08 f4       	brcc	.+2      	; 0x230a <create_chain+0x8c>
    2308:	ad c0       	rjmp	.+346    	; 0x2464 <create_chain+0x1e6>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    230a:	f1 01       	movw	r30, r2
    230c:	82 8d       	ldd	r24, Z+26	; 0x1a
    230e:	93 8d       	ldd	r25, Z+27	; 0x1b
    2310:	a4 8d       	ldd	r26, Z+28	; 0x1c
    2312:	b5 8d       	ldd	r27, Z+29	; 0x1d
    2314:	08 17       	cp	r16, r24
    2316:	19 07       	cpc	r17, r25
    2318:	2a 07       	cpc	r18, r26
    231a:	3b 07       	cpc	r19, r27
    231c:	08 f4       	brcc	.+2      	; 0x2320 <create_chain+0xa2>
    231e:	b6 c0       	rjmp	.+364    	; 0x248c <create_chain+0x20e>
		scl = clst;
    2320:	89 80       	ldd	r8, Y+1	; 0x01
    2322:	9a 80       	ldd	r9, Y+2	; 0x02
    2324:	ab 80       	ldd	r10, Y+3	; 0x03
    2326:	bc 80       	ldd	r11, Y+4	; 0x04
    2328:	09 c0       	rjmp	.+18     	; 0x233c <create_chain+0xbe>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
    232a:	88 24       	eor	r8, r8
    232c:	99 24       	eor	r9, r9
    232e:	54 01       	movw	r10, r8
    2330:	83 94       	inc	r8
    2332:	04 c0       	rjmp	.+8      	; 0x233c <create_chain+0xbe>
    2334:	88 24       	eor	r8, r8
    2336:	99 24       	eor	r9, r9
    2338:	54 01       	movw	r10, r8
    233a:	83 94       	inc	r8
		if (cs < 2) return 1;			/* It is an invalid cluster */
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
    233c:	75 01       	movw	r14, r10
    233e:	64 01       	movw	r12, r8
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
    2340:	44 24       	eor	r4, r4
    2342:	55 24       	eor	r5, r5
    2344:	32 01       	movw	r6, r4
    2346:	68 94       	set
    2348:	41 f8       	bld	r4, 1
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
    234a:	08 94       	sec
    234c:	c1 1c       	adc	r12, r1
    234e:	d1 1c       	adc	r13, r1
    2350:	e1 1c       	adc	r14, r1
    2352:	f1 1c       	adc	r15, r1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
    2354:	f1 01       	movw	r30, r2
    2356:	82 8d       	ldd	r24, Z+26	; 0x1a
    2358:	93 8d       	ldd	r25, Z+27	; 0x1b
    235a:	a4 8d       	ldd	r26, Z+28	; 0x1c
    235c:	b5 8d       	ldd	r27, Z+29	; 0x1d
    235e:	c8 16       	cp	r12, r24
    2360:	d9 06       	cpc	r13, r25
    2362:	ea 06       	cpc	r14, r26
    2364:	fb 06       	cpc	r15, r27
    2366:	48 f0       	brcs	.+18     	; 0x237a <create_chain+0xfc>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
    2368:	f2 e0       	ldi	r31, 0x02	; 2
    236a:	8f 16       	cp	r8, r31
    236c:	91 04       	cpc	r9, r1
    236e:	a1 04       	cpc	r10, r1
    2370:	b1 04       	cpc	r11, r1
    2372:	08 f4       	brcc	.+2      	; 0x2376 <create_chain+0xf8>
    2374:	7c c0       	rjmp	.+248    	; 0x246e <create_chain+0x1f0>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
    2376:	73 01       	movw	r14, r6
    2378:	62 01       	movw	r12, r4
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
    237a:	c1 01       	movw	r24, r2
    237c:	b7 01       	movw	r22, r14
    237e:	a6 01       	movw	r20, r12
    2380:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <get_fat>
    2384:	8b 01       	movw	r16, r22
    2386:	9c 01       	movw	r18, r24
		if (cs == 0) break;				/* Found a free cluster */
    2388:	61 15       	cp	r22, r1
    238a:	71 05       	cpc	r23, r1
    238c:	81 05       	cpc	r24, r1
    238e:	91 05       	cpc	r25, r1
    2390:	a9 f0       	breq	.+42     	; 0x23bc <create_chain+0x13e>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    2392:	0f 3f       	cpi	r16, 0xFF	; 255
    2394:	8f ef       	ldi	r24, 0xFF	; 255
    2396:	18 07       	cpc	r17, r24
    2398:	8f ef       	ldi	r24, 0xFF	; 255
    239a:	28 07       	cpc	r18, r24
    239c:	8f ef       	ldi	r24, 0xFF	; 255
    239e:	38 07       	cpc	r19, r24
    23a0:	09 f4       	brne	.+2      	; 0x23a4 <create_chain+0x126>
    23a2:	74 c0       	rjmp	.+232    	; 0x248c <create_chain+0x20e>
    23a4:	01 30       	cpi	r16, 0x01	; 1
    23a6:	11 05       	cpc	r17, r1
    23a8:	21 05       	cpc	r18, r1
    23aa:	31 05       	cpc	r19, r1
    23ac:	09 f4       	brne	.+2      	; 0x23b0 <create_chain+0x132>
    23ae:	6e c0       	rjmp	.+220    	; 0x248c <create_chain+0x20e>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
    23b0:	c8 14       	cp	r12, r8
    23b2:	d9 04       	cpc	r13, r9
    23b4:	ea 04       	cpc	r14, r10
    23b6:	fb 04       	cpc	r15, r11
    23b8:	41 f6       	brne	.-112    	; 0x234a <create_chain+0xcc>
    23ba:	5d c0       	rjmp	.+186    	; 0x2476 <create_chain+0x1f8>
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
    23bc:	8c 2c       	mov	r8, r12
    23be:	4d 2c       	mov	r4, r13
    23c0:	be 2c       	mov	r11, r14
    23c2:	af 2c       	mov	r10, r15
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    23c4:	c1 01       	movw	r24, r2
    23c6:	4c 2d       	mov	r20, r12
    23c8:	5d 2d       	mov	r21, r13
    23ca:	6e 2d       	mov	r22, r14
    23cc:	7f 2d       	mov	r23, r15
    23ce:	0f ef       	ldi	r16, 0xFF	; 255
    23d0:	1f ef       	ldi	r17, 0xFF	; 255
    23d2:	2f ef       	ldi	r18, 0xFF	; 255
    23d4:	3f e0       	ldi	r19, 0x0F	; 15
    23d6:	0e 94 30 10 	call	0x2060	; 0x2060 <put_fat>
	if (res == FR_OK && clst != 0) {
    23da:	88 23       	and	r24, r24
    23dc:	e9 f5       	brne	.+122    	; 0x2458 <create_chain+0x1da>
    23de:	89 81       	ldd	r24, Y+1	; 0x01
    23e0:	9a 81       	ldd	r25, Y+2	; 0x02
    23e2:	ab 81       	ldd	r26, Y+3	; 0x03
    23e4:	bc 81       	ldd	r27, Y+4	; 0x04
    23e6:	00 97       	sbiw	r24, 0x00	; 0
    23e8:	a1 05       	cpc	r26, r1
    23ea:	b1 05       	cpc	r27, r1
    23ec:	69 f0       	breq	.+26     	; 0x2408 <create_chain+0x18a>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    23ee:	c1 01       	movw	r24, r2
    23f0:	49 81       	ldd	r20, Y+1	; 0x01
    23f2:	5a 81       	ldd	r21, Y+2	; 0x02
    23f4:	6b 81       	ldd	r22, Y+3	; 0x03
    23f6:	7c 81       	ldd	r23, Y+4	; 0x04
    23f8:	0c 2d       	mov	r16, r12
    23fa:	1d 2d       	mov	r17, r13
    23fc:	2e 2d       	mov	r18, r14
    23fe:	3f 2d       	mov	r19, r15
    2400:	0e 94 30 10 	call	0x2060	; 0x2060 <put_fat>
	}
	if (res == FR_OK) {
    2404:	88 23       	and	r24, r24
    2406:	41 f5       	brne	.+80     	; 0x2458 <create_chain+0x1da>
		fs->last_clust = ncl;			/* Update FSINFO */
    2408:	d1 01       	movw	r26, r2
    240a:	1a 96       	adiw	r26, 0x0a	; 10
    240c:	8c 92       	st	X, r8
    240e:	1a 97       	sbiw	r26, 0x0a	; 10
    2410:	1b 96       	adiw	r26, 0x0b	; 11
    2412:	4c 92       	st	X, r4
    2414:	1b 97       	sbiw	r26, 0x0b	; 11
    2416:	1c 96       	adiw	r26, 0x0c	; 12
    2418:	bc 92       	st	X, r11
    241a:	1c 97       	sbiw	r26, 0x0c	; 12
    241c:	1d 96       	adiw	r26, 0x0d	; 13
    241e:	ac 92       	st	X, r10
    2420:	1d 97       	sbiw	r26, 0x0d	; 13
		if (fs->free_clust != 0xFFFFFFFF) {
    2422:	1e 96       	adiw	r26, 0x0e	; 14
    2424:	8d 91       	ld	r24, X+
    2426:	9d 91       	ld	r25, X+
    2428:	0d 90       	ld	r0, X+
    242a:	bc 91       	ld	r27, X
    242c:	a0 2d       	mov	r26, r0
    242e:	8f 3f       	cpi	r24, 0xFF	; 255
    2430:	ef ef       	ldi	r30, 0xFF	; 255
    2432:	9e 07       	cpc	r25, r30
    2434:	ef ef       	ldi	r30, 0xFF	; 255
    2436:	ae 07       	cpc	r26, r30
    2438:	ef ef       	ldi	r30, 0xFF	; 255
    243a:	be 07       	cpc	r27, r30
    243c:	01 f1       	breq	.+64     	; 0x247e <create_chain+0x200>
			fs->free_clust--;
    243e:	01 97       	sbiw	r24, 0x01	; 1
    2440:	a1 09       	sbc	r26, r1
    2442:	b1 09       	sbc	r27, r1
    2444:	f1 01       	movw	r30, r2
    2446:	86 87       	std	Z+14, r24	; 0x0e
    2448:	97 87       	std	Z+15, r25	; 0x0f
    244a:	a0 8b       	std	Z+16, r26	; 0x10
    244c:	b1 8b       	std	Z+17, r27	; 0x11
			fs->fsi_flag = 1;
    244e:	81 e0       	ldi	r24, 0x01	; 1
    2450:	85 83       	std	Z+5, r24	; 0x05
    2452:	97 01       	movw	r18, r14
    2454:	86 01       	movw	r16, r12
    2456:	1a c0       	rjmp	.+52     	; 0x248c <create_chain+0x20e>
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    2458:	81 30       	cpi	r24, 0x01	; 1
    245a:	a1 f4       	brne	.+40     	; 0x2484 <create_chain+0x206>
    245c:	0f ef       	ldi	r16, 0xFF	; 255
    245e:	1f ef       	ldi	r17, 0xFF	; 255
    2460:	98 01       	movw	r18, r16
    2462:	14 c0       	rjmp	.+40     	; 0x248c <create_chain+0x20e>
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* It is an invalid cluster */
    2464:	01 e0       	ldi	r16, 0x01	; 1
    2466:	10 e0       	ldi	r17, 0x00	; 0
    2468:	20 e0       	ldi	r18, 0x00	; 0
    246a:	30 e0       	ldi	r19, 0x00	; 0
    246c:	0f c0       	rjmp	.+30     	; 0x248c <create_chain+0x20e>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
    246e:	00 e0       	ldi	r16, 0x00	; 0
    2470:	10 e0       	ldi	r17, 0x00	; 0
    2472:	98 01       	movw	r18, r16
    2474:	0b c0       	rjmp	.+22     	; 0x248c <create_chain+0x20e>
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
    2476:	00 e0       	ldi	r16, 0x00	; 0
    2478:	10 e0       	ldi	r17, 0x00	; 0
    247a:	98 01       	movw	r18, r16
    247c:	07 c0       	rjmp	.+14     	; 0x248c <create_chain+0x20e>
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
    247e:	97 01       	movw	r18, r14
    2480:	86 01       	movw	r16, r12
    2482:	04 c0       	rjmp	.+8      	; 0x248c <create_chain+0x20e>
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    2484:	01 e0       	ldi	r16, 0x01	; 1
    2486:	10 e0       	ldi	r17, 0x00	; 0
    2488:	20 e0       	ldi	r18, 0x00	; 0
    248a:	30 e0       	ldi	r19, 0x00	; 0
	}

	return ncl;		/* Return new cluster number or error code */
}
    248c:	60 2f       	mov	r22, r16
    248e:	71 2f       	mov	r23, r17
    2490:	82 2f       	mov	r24, r18
    2492:	93 2f       	mov	r25, r19
    2494:	0f 90       	pop	r0
    2496:	0f 90       	pop	r0
    2498:	0f 90       	pop	r0
    249a:	0f 90       	pop	r0
    249c:	df 91       	pop	r29
    249e:	cf 91       	pop	r28
    24a0:	1f 91       	pop	r17
    24a2:	0f 91       	pop	r16
    24a4:	ff 90       	pop	r15
    24a6:	ef 90       	pop	r14
    24a8:	df 90       	pop	r13
    24aa:	cf 90       	pop	r12
    24ac:	bf 90       	pop	r11
    24ae:	af 90       	pop	r10
    24b0:	9f 90       	pop	r9
    24b2:	8f 90       	pop	r8
    24b4:	7f 90       	pop	r7
    24b6:	6f 90       	pop	r6
    24b8:	5f 90       	pop	r5
    24ba:	4f 90       	pop	r4
    24bc:	3f 90       	pop	r3
    24be:	2f 90       	pop	r2
    24c0:	08 95       	ret

000024c2 <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
    24c2:	8f 92       	push	r8
    24c4:	9f 92       	push	r9
    24c6:	af 92       	push	r10
    24c8:	bf 92       	push	r11
    24ca:	cf 92       	push	r12
    24cc:	df 92       	push	r13
    24ce:	ef 92       	push	r14
    24d0:	ff 92       	push	r15
    24d2:	0f 93       	push	r16
    24d4:	1f 93       	push	r17
    24d6:	cf 93       	push	r28
    24d8:	df 93       	push	r29
    24da:	8c 01       	movw	r16, r24
    24dc:	eb 01       	movw	r28, r22
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
    24de:	dc 01       	movw	r26, r24
    24e0:	14 96       	adiw	r26, 0x04	; 4
    24e2:	ed 90       	ld	r14, X+
    24e4:	fc 90       	ld	r15, X
    24e6:	15 97       	sbiw	r26, 0x05	; 5
    24e8:	08 94       	sec
    24ea:	e1 1c       	adc	r14, r1
    24ec:	f1 1c       	adc	r15, r1
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    24ee:	e1 14       	cp	r14, r1
    24f0:	f1 04       	cpc	r15, r1
    24f2:	09 f4       	brne	.+2      	; 0x24f6 <dir_next+0x34>
    24f4:	0b c1       	rjmp	.+534    	; 0x270c <dir_next+0x24a>
    24f6:	1e 96       	adiw	r26, 0x0e	; 14
    24f8:	8d 91       	ld	r24, X+
    24fa:	9d 91       	ld	r25, X+
    24fc:	0d 90       	ld	r0, X+
    24fe:	bc 91       	ld	r27, X
    2500:	a0 2d       	mov	r26, r0
    2502:	00 97       	sbiw	r24, 0x00	; 0
    2504:	a1 05       	cpc	r26, r1
    2506:	b1 05       	cpc	r27, r1
    2508:	09 f4       	brne	.+2      	; 0x250c <dir_next+0x4a>
    250a:	02 c1       	rjmp	.+516    	; 0x2710 <dir_next+0x24e>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    250c:	0f 2e       	mov	r0, r31
    250e:	ff e0       	ldi	r31, 0x0F	; 15
    2510:	cf 2e       	mov	r12, r31
    2512:	dd 24       	eor	r13, r13
    2514:	f0 2d       	mov	r31, r0
    2516:	ce 20       	and	r12, r14
    2518:	df 20       	and	r13, r15
    251a:	c1 14       	cp	r12, r1
    251c:	d1 04       	cpc	r13, r1
    251e:	09 f0       	breq	.+2      	; 0x2522 <dir_next+0x60>
    2520:	da c0       	rjmp	.+436    	; 0x26d6 <dir_next+0x214>
		dj->sect++;					/* Next sector */
    2522:	01 96       	adiw	r24, 0x01	; 1
    2524:	a1 1d       	adc	r26, r1
    2526:	b1 1d       	adc	r27, r1
    2528:	f8 01       	movw	r30, r16
    252a:	86 87       	std	Z+14, r24	; 0x0e
    252c:	97 87       	std	Z+15, r25	; 0x0f
    252e:	a0 8b       	std	Z+16, r26	; 0x10
    2530:	b1 8b       	std	Z+17, r27	; 0x11

		if (dj->clust == 0) {	/* Static table */
    2532:	42 85       	ldd	r20, Z+10	; 0x0a
    2534:	53 85       	ldd	r21, Z+11	; 0x0b
    2536:	64 85       	ldd	r22, Z+12	; 0x0c
    2538:	75 85       	ldd	r23, Z+13	; 0x0d
    253a:	41 15       	cp	r20, r1
    253c:	51 05       	cpc	r21, r1
    253e:	61 05       	cpc	r22, r1
    2540:	71 05       	cpc	r23, r1
    2542:	51 f4       	brne	.+20     	; 0x2558 <dir_next+0x96>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    2544:	01 90       	ld	r0, Z+
    2546:	f0 81       	ld	r31, Z
    2548:	e0 2d       	mov	r30, r0
    254a:	80 85       	ldd	r24, Z+8	; 0x08
    254c:	91 85       	ldd	r25, Z+9	; 0x09
    254e:	e8 16       	cp	r14, r24
    2550:	f9 06       	cpc	r15, r25
    2552:	08 f0       	brcs	.+2      	; 0x2556 <dir_next+0x94>
    2554:	df c0       	rjmp	.+446    	; 0x2714 <dir_next+0x252>
    2556:	bf c0       	rjmp	.+382    	; 0x26d6 <dir_next+0x214>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    2558:	01 90       	ld	r0, Z+
    255a:	f0 81       	ld	r31, Z
    255c:	e0 2d       	mov	r30, r0
    255e:	82 81       	ldd	r24, Z+2	; 0x02
    2560:	90 e0       	ldi	r25, 0x00	; 0
    2562:	01 97       	sbiw	r24, 0x01	; 1
    2564:	97 01       	movw	r18, r14
    2566:	32 95       	swap	r19
    2568:	22 95       	swap	r18
    256a:	2f 70       	andi	r18, 0x0F	; 15
    256c:	23 27       	eor	r18, r19
    256e:	3f 70       	andi	r19, 0x0F	; 15
    2570:	23 27       	eor	r18, r19
    2572:	82 23       	and	r24, r18
    2574:	93 23       	and	r25, r19
    2576:	00 97       	sbiw	r24, 0x00	; 0
    2578:	09 f0       	breq	.+2      	; 0x257c <dir_next+0xba>
    257a:	ad c0       	rjmp	.+346    	; 0x26d6 <dir_next+0x214>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    257c:	cf 01       	movw	r24, r30
    257e:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <get_fat>
    2582:	4b 01       	movw	r8, r22
    2584:	5c 01       	movw	r10, r24
				if (clst <= 1) return FR_INT_ERR;
    2586:	62 30       	cpi	r22, 0x02	; 2
    2588:	71 05       	cpc	r23, r1
    258a:	81 05       	cpc	r24, r1
    258c:	91 05       	cpc	r25, r1
    258e:	08 f4       	brcc	.+2      	; 0x2592 <dir_next+0xd0>
    2590:	c3 c0       	rjmp	.+390    	; 0x2718 <dir_next+0x256>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    2592:	6f 3f       	cpi	r22, 0xFF	; 255
    2594:	ef ef       	ldi	r30, 0xFF	; 255
    2596:	7e 07       	cpc	r23, r30
    2598:	ef ef       	ldi	r30, 0xFF	; 255
    259a:	8e 07       	cpc	r24, r30
    259c:	ef ef       	ldi	r30, 0xFF	; 255
    259e:	9e 07       	cpc	r25, r30
    25a0:	09 f4       	brne	.+2      	; 0x25a4 <dir_next+0xe2>
    25a2:	bc c0       	rjmp	.+376    	; 0x271c <dir_next+0x25a>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    25a4:	d8 01       	movw	r26, r16
    25a6:	ed 91       	ld	r30, X+
    25a8:	fc 91       	ld	r31, X
    25aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    25ac:	93 8d       	ldd	r25, Z+27	; 0x1b
    25ae:	a4 8d       	ldd	r26, Z+28	; 0x1c
    25b0:	b5 8d       	ldd	r27, Z+29	; 0x1d
    25b2:	88 16       	cp	r8, r24
    25b4:	99 06       	cpc	r9, r25
    25b6:	aa 06       	cpc	r10, r26
    25b8:	bb 06       	cpc	r11, r27
    25ba:	08 f4       	brcc	.+2      	; 0x25be <dir_next+0xfc>
    25bc:	7a c0       	rjmp	.+244    	; 0x26b2 <dir_next+0x1f0>
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    25be:	20 97       	sbiw	r28, 0x00	; 0
    25c0:	09 f4       	brne	.+2      	; 0x25c4 <dir_next+0x102>
    25c2:	ae c0       	rjmp	.+348    	; 0x2720 <dir_next+0x25e>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
    25c4:	d8 01       	movw	r26, r16
    25c6:	1a 96       	adiw	r26, 0x0a	; 10
    25c8:	4d 91       	ld	r20, X+
    25ca:	5d 91       	ld	r21, X+
    25cc:	6d 91       	ld	r22, X+
    25ce:	7c 91       	ld	r23, X
    25d0:	1d 97       	sbiw	r26, 0x0d	; 13
    25d2:	cf 01       	movw	r24, r30
    25d4:	0e 94 3f 11 	call	0x227e	; 0x227e <create_chain>
    25d8:	4b 01       	movw	r8, r22
    25da:	5c 01       	movw	r10, r24
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    25dc:	61 15       	cp	r22, r1
    25de:	71 05       	cpc	r23, r1
    25e0:	81 05       	cpc	r24, r1
    25e2:	91 05       	cpc	r25, r1
    25e4:	09 f4       	brne	.+2      	; 0x25e8 <dir_next+0x126>
    25e6:	9e c0       	rjmp	.+316    	; 0x2724 <dir_next+0x262>
					if (clst == 1) return FR_INT_ERR;
    25e8:	61 30       	cpi	r22, 0x01	; 1
    25ea:	71 05       	cpc	r23, r1
    25ec:	81 05       	cpc	r24, r1
    25ee:	91 05       	cpc	r25, r1
    25f0:	09 f4       	brne	.+2      	; 0x25f4 <dir_next+0x132>
    25f2:	9a c0       	rjmp	.+308    	; 0x2728 <dir_next+0x266>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    25f4:	6f 3f       	cpi	r22, 0xFF	; 255
    25f6:	ef ef       	ldi	r30, 0xFF	; 255
    25f8:	7e 07       	cpc	r23, r30
    25fa:	ef ef       	ldi	r30, 0xFF	; 255
    25fc:	8e 07       	cpc	r24, r30
    25fe:	ef ef       	ldi	r30, 0xFF	; 255
    2600:	9e 07       	cpc	r25, r30
    2602:	09 f4       	brne	.+2      	; 0x2606 <dir_next+0x144>
    2604:	93 c0       	rjmp	.+294    	; 0x272c <dir_next+0x26a>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    2606:	d8 01       	movw	r26, r16
    2608:	8d 91       	ld	r24, X+
    260a:	9c 91       	ld	r25, X
    260c:	40 e0       	ldi	r20, 0x00	; 0
    260e:	50 e0       	ldi	r21, 0x00	; 0
    2610:	ba 01       	movw	r22, r20
    2612:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
    2616:	88 23       	and	r24, r24
    2618:	09 f0       	breq	.+2      	; 0x261c <dir_next+0x15a>
    261a:	8a c0       	rjmp	.+276    	; 0x2730 <dir_next+0x26e>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
    261c:	f8 01       	movw	r30, r16
    261e:	80 81       	ld	r24, Z
    2620:	91 81       	ldd	r25, Z+1	; 0x01
    2622:	c2 96       	adiw	r24, 0x32	; 50
    2624:	60 e0       	ldi	r22, 0x00	; 0
    2626:	70 e0       	ldi	r23, 0x00	; 0
    2628:	20 e0       	ldi	r18, 0x00	; 0
    262a:	32 e0       	ldi	r19, 0x02	; 2
    262c:	40 e0       	ldi	r20, 0x00	; 0
    262e:	50 e0       	ldi	r21, 0x00	; 0
    2630:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <mem_set>
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    2634:	d8 01       	movw	r26, r16
    2636:	cd 91       	ld	r28, X+
    2638:	dc 91       	ld	r29, X
    263a:	ce 01       	movw	r24, r28
    263c:	b5 01       	movw	r22, r10
    263e:	a4 01       	movw	r20, r8
    2640:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <clust2sect>
    2644:	dc 01       	movw	r26, r24
    2646:	cb 01       	movw	r24, r22
    2648:	8e a7       	lds	r24, 0x7e
    264a:	9f a7       	lds	r25, 0x7f
    264c:	a8 ab       	sts	0x58, r26
    264e:	b9 ab       	sts	0x59, r27
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2650:	c0 e0       	ldi	r28, 0x00	; 0
						dj->fs->wflag = 1;
    2652:	d1 e0       	ldi	r29, 0x01	; 1
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    2654:	1b c0       	rjmp	.+54     	; 0x268c <dir_next+0x1ca>
						dj->fs->wflag = 1;
    2656:	d4 83       	std	Z+4, r29	; 0x04
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    2658:	f8 01       	movw	r30, r16
    265a:	80 81       	ld	r24, Z
    265c:	91 81       	ldd	r25, Z+1	; 0x01
    265e:	40 e0       	ldi	r20, 0x00	; 0
    2660:	50 e0       	ldi	r21, 0x00	; 0
    2662:	ba 01       	movw	r22, r20
    2664:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
    2668:	88 23       	and	r24, r24
    266a:	09 f0       	breq	.+2      	; 0x266e <dir_next+0x1ac>
    266c:	63 c0       	rjmp	.+198    	; 0x2734 <dir_next+0x272>
						dj->fs->winsect++;
    266e:	d8 01       	movw	r26, r16
    2670:	ed 91       	ld	r30, X+
    2672:	fc 91       	ld	r31, X
    2674:	86 a5       	lds	r24, 0x66
    2676:	97 a5       	lds	r25, 0x67
    2678:	a0 a9       	sts	0x40, r26
    267a:	b1 a9       	sts	0x41, r27
    267c:	01 96       	adiw	r24, 0x01	; 1
    267e:	a1 1d       	adc	r26, r1
    2680:	b1 1d       	adc	r27, r1
    2682:	86 a7       	lds	r24, 0x76
    2684:	97 a7       	lds	r25, 0x77
    2686:	a0 ab       	sts	0x50, r26
    2688:	b1 ab       	sts	0x51, r27
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    268a:	cf 5f       	subi	r28, 0xFF	; 255
    268c:	d8 01       	movw	r26, r16
    268e:	ed 91       	ld	r30, X+
    2690:	fc 91       	ld	r31, X
    2692:	11 97       	sbiw	r26, 0x01	; 1
    2694:	82 81       	ldd	r24, Z+2	; 0x02
    2696:	c8 17       	cp	r28, r24
    2698:	f0 f2       	brcs	.-68     	; 0x2656 <dir_next+0x194>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
    269a:	86 a5       	lds	r24, 0x66
    269c:	97 a5       	lds	r25, 0x67
    269e:	a0 a9       	sts	0x40, r26
    26a0:	b1 a9       	sts	0x41, r27
    26a2:	8c 1b       	sub	r24, r28
    26a4:	91 09       	sbc	r25, r1
    26a6:	a1 09       	sbc	r26, r1
    26a8:	b1 09       	sbc	r27, r1
    26aa:	86 a7       	lds	r24, 0x76
    26ac:	97 a7       	lds	r25, 0x77
    26ae:	a0 ab       	sts	0x50, r26
    26b0:	b1 ab       	sts	0x51, r27
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
    26b2:	f8 01       	movw	r30, r16
    26b4:	82 86       	std	Z+10, r8	; 0x0a
    26b6:	93 86       	std	Z+11, r9	; 0x0b
    26b8:	a4 86       	std	Z+12, r10	; 0x0c
    26ba:	b5 86       	std	Z+13, r11	; 0x0d
				dj->sect = clust2sect(dj->fs, clst);
    26bc:	80 81       	ld	r24, Z
    26be:	91 81       	ldd	r25, Z+1	; 0x01
    26c0:	b5 01       	movw	r22, r10
    26c2:	a4 01       	movw	r20, r8
    26c4:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <clust2sect>
    26c8:	dc 01       	movw	r26, r24
    26ca:	cb 01       	movw	r24, r22
    26cc:	f8 01       	movw	r30, r16
    26ce:	86 87       	std	Z+14, r24	; 0x0e
    26d0:	97 87       	std	Z+15, r25	; 0x0f
    26d2:	a0 8b       	std	Z+16, r26	; 0x10
    26d4:	b1 8b       	std	Z+17, r27	; 0x11
			}
		}
	}

	dj->index = i;
    26d6:	d8 01       	movw	r26, r16
    26d8:	15 96       	adiw	r26, 0x05	; 5
    26da:	fc 92       	st	X, r15
    26dc:	ee 92       	st	-X, r14
    26de:	14 97       	sbiw	r26, 0x04	; 4
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    26e0:	8d 91       	ld	r24, X+
    26e2:	9c 91       	ld	r25, X
    26e4:	11 97       	sbiw	r26, 0x01	; 1
    26e6:	c2 96       	adiw	r24, 0x32	; 50
    26e8:	cc 0c       	add	r12, r12
    26ea:	dd 1c       	adc	r13, r13
    26ec:	cc 0c       	add	r12, r12
    26ee:	dd 1c       	adc	r13, r13
    26f0:	cc 0c       	add	r12, r12
    26f2:	dd 1c       	adc	r13, r13
    26f4:	cc 0c       	add	r12, r12
    26f6:	dd 1c       	adc	r13, r13
    26f8:	cc 0c       	add	r12, r12
    26fa:	dd 1c       	adc	r13, r13
    26fc:	8c 0d       	add	r24, r12
    26fe:	9d 1d       	adc	r25, r13
    2700:	53 96       	adiw	r26, 0x13	; 19
    2702:	9c 93       	st	X, r25
    2704:	8e 93       	st	-X, r24
    2706:	52 97       	sbiw	r26, 0x12	; 18

	return FR_OK;
    2708:	80 e0       	ldi	r24, 0x00	; 0
    270a:	15 c0       	rjmp	.+42     	; 0x2736 <dir_next+0x274>


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
    270c:	84 e0       	ldi	r24, 0x04	; 4
    270e:	13 c0       	rjmp	.+38     	; 0x2736 <dir_next+0x274>
    2710:	84 e0       	ldi	r24, 0x04	; 4
    2712:	11 c0       	rjmp	.+34     	; 0x2736 <dir_next+0x274>
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
    2714:	84 e0       	ldi	r24, 0x04	; 4
    2716:	0f c0       	rjmp	.+30     	; 0x2736 <dir_next+0x274>
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
    2718:	82 e0       	ldi	r24, 0x02	; 2
    271a:	0d c0       	rjmp	.+26     	; 0x2736 <dir_next+0x274>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    271c:	81 e0       	ldi	r24, 0x01	; 1
    271e:	0b c0       	rjmp	.+22     	; 0x2736 <dir_next+0x274>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    2720:	84 e0       	ldi	r24, 0x04	; 4
    2722:	09 c0       	rjmp	.+18     	; 0x2736 <dir_next+0x274>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    2724:	87 e0       	ldi	r24, 0x07	; 7
    2726:	07 c0       	rjmp	.+14     	; 0x2736 <dir_next+0x274>
					if (clst == 1) return FR_INT_ERR;
    2728:	82 e0       	ldi	r24, 0x02	; 2
    272a:	05 c0       	rjmp	.+10     	; 0x2736 <dir_next+0x274>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    272c:	81 e0       	ldi	r24, 0x01	; 1
    272e:	03 c0       	rjmp	.+6      	; 0x2736 <dir_next+0x274>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    2730:	81 e0       	ldi	r24, 0x01	; 1
    2732:	01 c0       	rjmp	.+2      	; 0x2736 <dir_next+0x274>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    2734:	81 e0       	ldi	r24, 0x01	; 1

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
}
    2736:	df 91       	pop	r29
    2738:	cf 91       	pop	r28
    273a:	1f 91       	pop	r17
    273c:	0f 91       	pop	r16
    273e:	ff 90       	pop	r15
    2740:	ef 90       	pop	r14
    2742:	df 90       	pop	r13
    2744:	cf 90       	pop	r12
    2746:	bf 90       	pop	r11
    2748:	af 90       	pop	r10
    274a:	9f 90       	pop	r9
    274c:	8f 90       	pop	r8
    274e:	08 95       	ret

00002750 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
    2750:	2f 92       	push	r2
    2752:	3f 92       	push	r3
    2754:	4f 92       	push	r4
    2756:	5f 92       	push	r5
    2758:	6f 92       	push	r6
    275a:	7f 92       	push	r7
    275c:	8f 92       	push	r8
    275e:	9f 92       	push	r9
    2760:	af 92       	push	r10
    2762:	bf 92       	push	r11
    2764:	cf 92       	push	r12
    2766:	df 92       	push	r13
    2768:	ef 92       	push	r14
    276a:	ff 92       	push	r15
    276c:	0f 93       	push	r16
    276e:	1f 93       	push	r17
    2770:	cf 93       	push	r28
    2772:	df 93       	push	r29
    2774:	cd b7       	in	r28, 0x3d	; 61
    2776:	de b7       	in	r29, 0x3e	; 62
    2778:	2b 97       	sbiw	r28, 0x0b	; 11
    277a:	0f b6       	in	r0, 0x3f	; 63
    277c:	f8 94       	cli
    277e:	de bf       	out	0x3e, r29	; 62
    2780:	0f be       	out	0x3f, r0	; 63
    2782:	cd bf       	out	0x3d, r28	; 61
    2784:	8c 01       	movw	r16, r24
    2786:	2b 01       	movw	r4, r22
	FRESULT res;
	BYTE *dir, ns;


#if _FS_RPATH
	if (*path == '/' || *path == '\\') { /* There is a heading separator */
    2788:	db 01       	movw	r26, r22
    278a:	8c 91       	ld	r24, X
    278c:	8f 32       	cpi	r24, 0x2F	; 47
    278e:	11 f0       	breq	.+4      	; 0x2794 <follow_path+0x44>
    2790:	8c 35       	cpi	r24, 0x5C	; 92
    2792:	49 f4       	brne	.+18     	; 0x27a6 <follow_path+0x56>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
    2794:	08 94       	sec
    2796:	41 1c       	adc	r4, r1
    2798:	51 1c       	adc	r5, r1
    279a:	f8 01       	movw	r30, r16
    279c:	16 82       	std	Z+6, r1	; 0x06
    279e:	17 82       	std	Z+7, r1	; 0x07
    27a0:	10 86       	std	Z+8, r1	; 0x08
    27a2:	11 86       	std	Z+9, r1	; 0x09
    27a4:	0c c0       	rjmp	.+24     	; 0x27be <follow_path+0x6e>
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
    27a6:	d8 01       	movw	r26, r16
    27a8:	ed 91       	ld	r30, X+
    27aa:	fc 91       	ld	r31, X
    27ac:	86 89       	ldd	r24, Z+22	; 0x16
    27ae:	97 89       	ldd	r25, Z+23	; 0x17
    27b0:	a0 8d       	ldd	r26, Z+24	; 0x18
    27b2:	b1 8d       	ldd	r27, Z+25	; 0x19
    27b4:	f8 01       	movw	r30, r16
    27b6:	86 83       	std	Z+6, r24	; 0x06
    27b8:	97 83       	std	Z+7, r25	; 0x07
    27ba:	a0 87       	std	Z+8, r26	; 0x08
    27bc:	b1 87       	std	Z+9, r27	; 0x09
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    27be:	d2 01       	movw	r26, r4
    27c0:	8c 91       	ld	r24, X
    27c2:	80 32       	cpi	r24, 0x20	; 32
    27c4:	48 f4       	brcc	.+18     	; 0x27d8 <follow_path+0x88>
		res = dir_sdi(dj, 0);
    27c6:	c8 01       	movw	r24, r16
    27c8:	60 e0       	ldi	r22, 0x00	; 0
    27ca:	70 e0       	ldi	r23, 0x00	; 0
    27cc:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <dir_sdi>
		dj->dir = 0;
    27d0:	f8 01       	movw	r30, r16
    27d2:	13 8a       	std	Z+19, r1	; 0x13
    27d4:	12 8a       	std	Z+18, r1	; 0x12
    27d6:	a5 c1       	rjmp	.+842    	; 0x2b22 <follow_path+0x3d2>
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    27d8:	f8 e0       	ldi	r31, 0x08	; 8
    27da:	fa 83       	std	Y+2, r31	; 0x02
    27dc:	1b 82       	std	Y+3, r1	; 0x03
    27de:	1c 82       	std	Y+4, r1	; 0x04
    27e0:	1d 82       	std	Y+5, r1	; 0x05
    27e2:	2b e0       	ldi	r18, 0x0B	; 11
    27e4:	2e 83       	std	Y+6, r18	; 0x06
    27e6:	1f 82       	std	Y+7, r1	; 0x07
    27e8:	18 86       	std	Y+8, r1	; 0x08
    27ea:	19 86       	std	Y+9, r1	; 0x09
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
		res = dir_sdi(dj, 0);
		dj->dir = 0;
    27ec:	f2 01       	movw	r30, r4
    27ee:	9f 01       	movw	r18, r30
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    27f0:	81 91       	ld	r24, Z+
    27f2:	8f 32       	cpi	r24, 0x2F	; 47
    27f4:	e1 f3       	breq	.-8      	; 0x27ee <follow_path+0x9e>
    27f6:	8c 35       	cpi	r24, 0x5C	; 92
    27f8:	d1 f3       	breq	.-12     	; 0x27ee <follow_path+0x9e>
    27fa:	3b 87       	std	Y+11, r19	; 0x0b
    27fc:	2a 87       	std	Y+10, r18	; 0x0a
	sfn = dj->fn;
    27fe:	d8 01       	movw	r26, r16
    2800:	54 96       	adiw	r26, 0x14	; 20
    2802:	2d 90       	ld	r2, X+
    2804:	3c 90       	ld	r3, X
    2806:	55 97       	sbiw	r26, 0x15	; 21
	mem_set(sfn, ' ', 11);
    2808:	c1 01       	movw	r24, r2
    280a:	60 e2       	ldi	r22, 0x20	; 32
    280c:	70 e0       	ldi	r23, 0x00	; 0
    280e:	2b e0       	ldi	r18, 0x0B	; 11
    2810:	30 e0       	ldi	r19, 0x00	; 0
    2812:	40 e0       	ldi	r20, 0x00	; 0
    2814:	50 e0       	ldi	r21, 0x00	; 0
    2816:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <mem_set>
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
    281a:	ea 85       	ldd	r30, Y+10	; 0x0a
    281c:	fb 85       	ldd	r31, Y+11	; 0x0b
    281e:	80 81       	ld	r24, Z
    2820:	8e 32       	cpi	r24, 0x2E	; 46
    2822:	89 f5       	brne	.+98     	; 0x2886 <follow_path+0x136>
		for (;;) {
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
    2824:	ee e2       	ldi	r30, 0x2E	; 46
    2826:	d1 01       	movw	r26, r2
    2828:	ec 93       	st	X, r30
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    282a:	aa 85       	ldd	r26, Y+10	; 0x0a
    282c:	bb 85       	ldd	r27, Y+11	; 0x0b
    282e:	11 96       	adiw	r26, 0x01	; 1
    2830:	2c 91       	ld	r18, X
    2832:	11 97       	sbiw	r26, 0x01	; 1
			if (c != '.' || si >= 3) break;
    2834:	2e 32       	cpi	r18, 0x2E	; 46
    2836:	61 f4       	brne	.+24     	; 0x2850 <follow_path+0x100>
			sfn[i++] = c;
    2838:	f1 01       	movw	r30, r2
    283a:	21 83       	std	Z+1, r18	; 0x01
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    283c:	12 96       	adiw	r26, 0x02	; 2
    283e:	2c 91       	ld	r18, X
    2840:	12 97       	sbiw	r26, 0x02	; 2
			if (c != '.' || si >= 3) break;
    2842:	2e 32       	cpi	r18, 0x2E	; 46
    2844:	71 f0       	breq	.+28     	; 0x2862 <follow_path+0x112>
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2846:	83 e0       	ldi	r24, 0x03	; 3
    2848:	90 e0       	ldi	r25, 0x00	; 0
    284a:	a0 e0       	ldi	r26, 0x00	; 0
    284c:	b0 e0       	ldi	r27, 0x00	; 0
    284e:	04 c0       	rjmp	.+8      	; 0x2858 <follow_path+0x108>
    2850:	82 e0       	ldi	r24, 0x02	; 2
    2852:	90 e0       	ldi	r25, 0x00	; 0
    2854:	a0 e0       	ldi	r26, 0x00	; 0
    2856:	b0 e0       	ldi	r27, 0x00	; 0
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    2858:	2f 32       	cpi	r18, 0x2F	; 47
    285a:	59 f0       	breq	.+22     	; 0x2872 <follow_path+0x122>
    285c:	2c 35       	cpi	r18, 0x5C	; 92
    285e:	49 f0       	breq	.+18     	; 0x2872 <follow_path+0x122>
    2860:	04 c0       	rjmp	.+8      	; 0x286a <follow_path+0x11a>
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
		for (;;) {
			c = (BYTE)p[si++];
    2862:	83 e0       	ldi	r24, 0x03	; 3
    2864:	90 e0       	ldi	r25, 0x00	; 0
    2866:	a0 e0       	ldi	r26, 0x00	; 0
    2868:	b0 e0       	ldi	r27, 0x00	; 0
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    286a:	21 32       	cpi	r18, 0x21	; 33
    286c:	08 f0       	brcs	.+2      	; 0x2870 <follow_path+0x120>
    286e:	48 c1       	rjmp	.+656    	; 0x2b00 <follow_path+0x3b0>
    2870:	71 c1       	rjmp	.+738    	; 0x2b54 <follow_path+0x404>
		*path = &p[si];									/* Return pointer to the next segment */
    2872:	4a 84       	ldd	r4, Y+10	; 0x0a
    2874:	5b 84       	ldd	r5, Y+11	; 0x0b
    2876:	48 0e       	add	r4, r24
    2878:	59 1e       	adc	r5, r25
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
    287a:	80 e2       	ldi	r24, 0x20	; 32
    287c:	d1 01       	movw	r26, r2
    287e:	1b 96       	adiw	r26, 0x0b	; 11
    2880:	8c 93       	st	X, r24
    2882:	1b 97       	sbiw	r26, 0x0b	; 11
    2884:	74 c1       	rjmp	.+744    	; 0x2b6e <follow_path+0x41e>
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = b = 0; ni = 8;
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
    2886:	cc 24       	eor	r12, r12
    2888:	dd 24       	eor	r13, r13
    288a:	76 01       	movw	r14, r12
    288c:	40 e0       	ldi	r20, 0x00	; 0
    288e:	50 e0       	ldi	r21, 0x00	; 0
    2890:	ba 01       	movw	r22, r20
    2892:	88 24       	eor	r8, r8
    2894:	99 24       	eor	r9, r9
    2896:	54 01       	movw	r10, r8
    2898:	68 94       	set
    289a:	83 f8       	bld	r8, 3
    289c:	19 82       	std	Y+1, r1	; 0x01
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    289e:	ea 85       	ldd	r30, Y+10	; 0x0a
    28a0:	fb 85       	ldd	r31, Y+11	; 0x0b
    28a2:	e4 0f       	add	r30, r20
    28a4:	f5 1f       	adc	r31, r21
    28a6:	20 81       	ld	r18, Z
    28a8:	2a 01       	movw	r4, r20
    28aa:	3b 01       	movw	r6, r22
    28ac:	08 94       	sec
    28ae:	41 1c       	adc	r4, r1
    28b0:	51 1c       	adc	r5, r1
    28b2:	61 1c       	adc	r6, r1
    28b4:	71 1c       	adc	r7, r1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    28b6:	21 32       	cpi	r18, 0x21	; 33
    28b8:	08 f4       	brcc	.+2      	; 0x28bc <follow_path+0x16c>
    28ba:	95 c0       	rjmp	.+298    	; 0x29e6 <follow_path+0x296>
    28bc:	2f 32       	cpi	r18, 0x2F	; 47
    28be:	09 f4       	brne	.+2      	; 0x28c2 <follow_path+0x172>
    28c0:	4f c1       	rjmp	.+670    	; 0x2b60 <follow_path+0x410>
    28c2:	2c 35       	cpi	r18, 0x5C	; 92
    28c4:	09 f4       	brne	.+2      	; 0x28c8 <follow_path+0x178>
    28c6:	4c c1       	rjmp	.+664    	; 0x2b60 <follow_path+0x410>
		if (c == '.' || i >= ni) {
    28c8:	2e 32       	cpi	r18, 0x2E	; 46
    28ca:	29 f0       	breq	.+10     	; 0x28d6 <follow_path+0x186>
    28cc:	c8 14       	cp	r12, r8
    28ce:	d9 04       	cpc	r13, r9
    28d0:	ea 04       	cpc	r14, r10
    28d2:	fb 04       	cpc	r15, r11
    28d4:	c8 f0       	brcs	.+50     	; 0x2908 <follow_path+0x1b8>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    28d6:	f8 e0       	ldi	r31, 0x08	; 8
    28d8:	8f 16       	cp	r8, r31
    28da:	91 04       	cpc	r9, r1
    28dc:	a1 04       	cpc	r10, r1
    28de:	b1 04       	cpc	r11, r1
    28e0:	09 f0       	breq	.+2      	; 0x28e4 <follow_path+0x194>
    28e2:	10 c1       	rjmp	.+544    	; 0x2b04 <follow_path+0x3b4>
    28e4:	2e 32       	cpi	r18, 0x2E	; 46
    28e6:	09 f0       	breq	.+2      	; 0x28ea <follow_path+0x19a>
    28e8:	0f c1       	rjmp	.+542    	; 0x2b08 <follow_path+0x3b8>
			i = 8; ni = 11;
			b <<= 2; continue;
    28ea:	29 81       	ldd	r18, Y+1	; 0x01
    28ec:	22 0f       	add	r18, r18
    28ee:	22 0f       	add	r18, r18
    28f0:	29 83       	std	Y+1, r18	; 0x01
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    28f2:	b3 01       	movw	r22, r6
    28f4:	a2 01       	movw	r20, r4
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    28f6:	ca 80       	ldd	r12, Y+2	; 0x02
    28f8:	db 80       	ldd	r13, Y+3	; 0x03
    28fa:	ec 80       	ldd	r14, Y+4	; 0x04
    28fc:	fd 80       	ldd	r15, Y+5	; 0x05
    28fe:	8e 80       	ldd	r8, Y+6	; 0x06
    2900:	9f 80       	ldd	r9, Y+7	; 0x07
    2902:	a8 84       	ldd	r10, Y+8	; 0x08
    2904:	b9 84       	ldd	r11, Y+9	; 0x09
    2906:	cb cf       	rjmp	.-106    	; 0x289e <follow_path+0x14e>
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended char? */
    2908:	22 23       	and	r18, r18
    290a:	1c f4       	brge	.+6      	; 0x2912 <follow_path+0x1c2>
			b |= 3;						/* Eliminate NT flag */
    290c:	89 81       	ldd	r24, Y+1	; 0x01
    290e:	83 60       	ori	r24, 0x03	; 3
    2910:	89 83       	std	Y+1, r24	; 0x01
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    2912:	82 2f       	mov	r24, r18
    2914:	81 58       	subi	r24, 0x81	; 129
    2916:	8f 31       	cpi	r24, 0x1F	; 31
    2918:	18 f0       	brcs	.+6      	; 0x2920 <follow_path+0x1d0>
    291a:	8f 55       	subi	r24, 0x5F	; 95
    291c:	8d 31       	cpi	r24, 0x1D	; 29
    291e:	90 f5       	brcc	.+100    	; 0x2984 <follow_path+0x234>
			d = (BYTE)p[si++];			/* Get 2nd byte */
    2920:	ea 85       	ldd	r30, Y+10	; 0x0a
    2922:	fb 85       	ldd	r31, Y+11	; 0x0b
    2924:	e4 0d       	add	r30, r4
    2926:	f5 1d       	adc	r31, r5
    2928:	30 81       	ld	r19, Z
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    292a:	83 2f       	mov	r24, r19
    292c:	80 54       	subi	r24, 0x40	; 64
    292e:	8f 33       	cpi	r24, 0x3F	; 63
    2930:	20 f0       	brcs	.+8      	; 0x293a <follow_path+0x1ea>
    2932:	80 54       	subi	r24, 0x40	; 64
    2934:	8d 37       	cpi	r24, 0x7D	; 125
    2936:	08 f0       	brcs	.+2      	; 0x293a <follow_path+0x1ea>
    2938:	e9 c0       	rjmp	.+466    	; 0x2b0c <follow_path+0x3bc>
    293a:	d5 01       	movw	r26, r10
    293c:	c4 01       	movw	r24, r8
    293e:	01 97       	sbiw	r24, 0x01	; 1
    2940:	a1 09       	sbc	r26, r1
    2942:	b1 09       	sbc	r27, r1
    2944:	c8 16       	cp	r12, r24
    2946:	d9 06       	cpc	r13, r25
    2948:	ea 06       	cpc	r14, r26
    294a:	fb 06       	cpc	r15, r27
    294c:	08 f0       	brcs	.+2      	; 0x2950 <follow_path+0x200>
    294e:	e0 c0       	rjmp	.+448    	; 0x2b10 <follow_path+0x3c0>
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
    2950:	4e 5f       	subi	r20, 0xFE	; 254
    2952:	5f 4f       	sbci	r21, 0xFF	; 255
    2954:	6f 4f       	sbci	r22, 0xFF	; 255
    2956:	7f 4f       	sbci	r23, 0xFF	; 255
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
    2958:	f1 01       	movw	r30, r2
    295a:	ec 0d       	add	r30, r12
    295c:	fd 1d       	adc	r31, r13
    295e:	20 83       	st	Z, r18
    2960:	d7 01       	movw	r26, r14
    2962:	c6 01       	movw	r24, r12
    2964:	01 96       	adiw	r24, 0x01	; 1
    2966:	a1 1d       	adc	r26, r1
    2968:	b1 1d       	adc	r27, r1
			sfn[i++] = d;
    296a:	82 0d       	add	r24, r2
    296c:	93 1d       	adc	r25, r3
    296e:	dc 01       	movw	r26, r24
    2970:	3c 93       	st	X, r19
    2972:	82 e0       	ldi	r24, 0x02	; 2
    2974:	90 e0       	ldi	r25, 0x00	; 0
    2976:	a0 e0       	ldi	r26, 0x00	; 0
    2978:	b0 e0       	ldi	r27, 0x00	; 0
    297a:	c8 0e       	add	r12, r24
    297c:	d9 1e       	adc	r13, r25
    297e:	ea 1e       	adc	r14, r26
    2980:	fb 1e       	adc	r15, r27
    2982:	8d cf       	rjmp	.-230    	; 0x289e <follow_path+0x14e>
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    2984:	42 2f       	mov	r20, r18
    2986:	50 e0       	ldi	r21, 0x00	; 0
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    2988:	42 32       	cpi	r20, 0x22	; 34
    298a:	51 05       	cpc	r21, r1
    298c:	09 f4       	brne	.+2      	; 0x2990 <follow_path+0x240>
    298e:	c2 c0       	rjmp	.+388    	; 0x2b14 <follow_path+0x3c4>
    2990:	e7 ef       	ldi	r30, 0xF7	; 247
    2992:	f2 e0       	ldi	r31, 0x02	; 2
    2994:	6a 85       	ldd	r22, Y+10	; 0x0a
    2996:	7b 85       	ldd	r23, Y+11	; 0x0b
    2998:	81 91       	ld	r24, Z+
    299a:	88 23       	and	r24, r24
    299c:	31 f0       	breq	.+12     	; 0x29aa <follow_path+0x25a>
    299e:	90 e0       	ldi	r25, 0x00	; 0
    29a0:	48 17       	cp	r20, r24
    29a2:	59 07       	cpc	r21, r25
    29a4:	c9 f7       	brne	.-14     	; 0x2998 <follow_path+0x248>
    29a6:	86 e0       	ldi	r24, 0x06	; 6
    29a8:	bc c0       	rjmp	.+376    	; 0x2b22 <follow_path+0x3d2>
    29aa:	7b 87       	std	Y+11, r23	; 0x0b
    29ac:	6a 87       	std	Y+10, r22	; 0x0a
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
    29ae:	82 2f       	mov	r24, r18
    29b0:	81 54       	subi	r24, 0x41	; 65
    29b2:	8a 31       	cpi	r24, 0x1A	; 26
    29b4:	20 f4       	brcc	.+8      	; 0x29be <follow_path+0x26e>
				b |= 2;
    29b6:	99 81       	ldd	r25, Y+1	; 0x01
    29b8:	92 60       	ori	r25, 0x02	; 2
    29ba:	99 83       	std	Y+1, r25	; 0x01
    29bc:	08 c0       	rjmp	.+16     	; 0x29ce <follow_path+0x27e>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
    29be:	82 2f       	mov	r24, r18
    29c0:	81 56       	subi	r24, 0x61	; 97
    29c2:	8a 31       	cpi	r24, 0x1A	; 26
    29c4:	20 f4       	brcc	.+8      	; 0x29ce <follow_path+0x27e>
					b |= 1; c -= 0x20;
    29c6:	a9 81       	ldd	r26, Y+1	; 0x01
    29c8:	a1 60       	ori	r26, 0x01	; 1
    29ca:	a9 83       	std	Y+1, r26	; 0x01
    29cc:	20 52       	subi	r18, 0x20	; 32
				}
			}
			sfn[i++] = c;
    29ce:	f1 01       	movw	r30, r2
    29d0:	ec 0d       	add	r30, r12
    29d2:	fd 1d       	adc	r31, r13
    29d4:	20 83       	st	Z, r18
    29d6:	08 94       	sec
    29d8:	c1 1c       	adc	r12, r1
    29da:	d1 1c       	adc	r13, r1
    29dc:	e1 1c       	adc	r14, r1
    29de:	f1 1c       	adc	r15, r1
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    29e0:	b3 01       	movw	r22, r6
    29e2:	a2 01       	movw	r20, r4
    29e4:	5c cf       	rjmp	.-328    	; 0x289e <follow_path+0x14e>
    29e6:	ea 85       	ldd	r30, Y+10	; 0x0a
    29e8:	fb 85       	ldd	r31, Y+11	; 0x0b
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    29ea:	4e 0e       	add	r4, r30
    29ec:	5f 1e       	adc	r5, r31
    29ee:	89 81       	ldd	r24, Y+1	; 0x01
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    29f0:	44 e0       	ldi	r20, 0x04	; 4

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    29f2:	c1 14       	cp	r12, r1
    29f4:	d1 04       	cpc	r13, r1
    29f6:	e1 04       	cpc	r14, r1
    29f8:	f1 04       	cpc	r15, r1
    29fa:	09 f4       	brne	.+2      	; 0x29fe <follow_path+0x2ae>
    29fc:	8d c0       	rjmp	.+282    	; 0x2b18 <follow_path+0x3c8>
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    29fe:	d1 01       	movw	r26, r2
    2a00:	9c 91       	ld	r25, X
    2a02:	95 3e       	cpi	r25, 0xE5	; 229
    2a04:	11 f4       	brne	.+4      	; 0x2a0a <follow_path+0x2ba>
    2a06:	e5 e0       	ldi	r30, 0x05	; 5
    2a08:	ec 93       	st	X, r30

	if (ni == 8) b <<= 2;
    2a0a:	f8 e0       	ldi	r31, 0x08	; 8
    2a0c:	8f 16       	cp	r8, r31
    2a0e:	91 04       	cpc	r9, r1
    2a10:	a1 04       	cpc	r10, r1
    2a12:	b1 04       	cpc	r11, r1
    2a14:	19 f4       	brne	.+6      	; 0x2a1c <follow_path+0x2cc>
    2a16:	88 0f       	add	r24, r24
    2a18:	88 0f       	add	r24, r24
    2a1a:	89 83       	std	Y+1, r24	; 0x01
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    2a1c:	29 81       	ldd	r18, Y+1	; 0x01
    2a1e:	82 2f       	mov	r24, r18
    2a20:	90 e0       	ldi	r25, 0x00	; 0
    2a22:	9c 01       	movw	r18, r24
    2a24:	23 70       	andi	r18, 0x03	; 3
    2a26:	30 70       	andi	r19, 0x00	; 0
    2a28:	21 30       	cpi	r18, 0x01	; 1
    2a2a:	31 05       	cpc	r19, r1
    2a2c:	09 f4       	brne	.+2      	; 0x2a30 <follow_path+0x2e0>
    2a2e:	40 61       	ori	r20, 0x10	; 16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    2a30:	8c 70       	andi	r24, 0x0C	; 12
    2a32:	90 70       	andi	r25, 0x00	; 0
    2a34:	84 30       	cpi	r24, 0x04	; 4
    2a36:	91 05       	cpc	r25, r1
    2a38:	09 f4       	brne	.+2      	; 0x2a3c <follow_path+0x2ec>
    2a3a:	48 60       	ori	r20, 0x08	; 8

	sfn[NS] = c;		/* Store NT flag, File name is created */
    2a3c:	d1 01       	movw	r26, r2
    2a3e:	1b 96       	adiw	r26, 0x0b	; 11
    2a40:	4c 93       	st	X, r20
    2a42:	1b 97       	sbiw	r26, 0x0b	; 11
    2a44:	94 c0       	rjmp	.+296    	; 0x2b6e <follow_path+0x41e>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
    2a46:	f8 01       	movw	r30, r16
    2a48:	46 85       	ldd	r20, Z+14	; 0x0e
    2a4a:	57 85       	ldd	r21, Z+15	; 0x0f
    2a4c:	60 89       	ldd	r22, Z+16	; 0x10
    2a4e:	71 89       	ldd	r23, Z+17	; 0x11
    2a50:	80 81       	ld	r24, Z
    2a52:	91 81       	ldd	r25, Z+1	; 0x01
    2a54:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
		if (res != FR_OK) break;
    2a58:	88 23       	and	r24, r24
    2a5a:	31 f5       	brne	.+76     	; 0x2aa8 <follow_path+0x358>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    2a5c:	d8 01       	movw	r26, r16
    2a5e:	52 96       	adiw	r26, 0x12	; 18
    2a60:	6d 91       	ld	r22, X+
    2a62:	7c 91       	ld	r23, X
    2a64:	53 97       	sbiw	r26, 0x13	; 19
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    2a66:	fb 01       	movw	r30, r22
    2a68:	90 81       	ld	r25, Z
    2a6a:	99 23       	and	r25, r25
    2a6c:	09 f4       	brne	.+2      	; 0x2a70 <follow_path+0x320>
    2a6e:	90 c0       	rjmp	.+288    	; 0x2b90 <follow_path+0x440>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    2a70:	93 85       	ldd	r25, Z+11	; 0x0b
    2a72:	93 fd       	sbrc	r25, 3
    2a74:	12 c0       	rjmp	.+36     	; 0x2a9a <follow_path+0x34a>
    2a76:	54 96       	adiw	r26, 0x14	; 20
    2a78:	4d 91       	ld	r20, X+
    2a7a:	5c 91       	ld	r21, X
    2a7c:	55 97       	sbiw	r26, 0x15	; 21
/*-----------------------------------------------------------------------*/
/* Follow a file path                                                    */
/*-----------------------------------------------------------------------*/

static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
    2a7e:	9b 01       	movw	r18, r22
    2a80:	25 5f       	subi	r18, 0xF5	; 245
    2a82:	3f 4f       	sbci	r19, 0xFF	; 255
}

/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    2a84:	da 01       	movw	r26, r20
    2a86:	6b 01       	movw	r12, r22
    2a88:	04 c0       	rjmp	.+8      	; 0x2a92 <follow_path+0x342>
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    2a8a:	e2 17       	cp	r30, r18
    2a8c:	f3 07       	cpc	r31, r19
    2a8e:	09 f4       	brne	.+2      	; 0x2a92 <follow_path+0x342>
    2a90:	77 c0       	rjmp	.+238    	; 0x2b80 <follow_path+0x430>
    2a92:	61 91       	ld	r22, Z+
    2a94:	9d 91       	ld	r25, X+
    2a96:	69 17       	cp	r22, r25
    2a98:	c1 f3       	breq	.-16     	; 0x2a8a <follow_path+0x33a>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
    2a9a:	c8 01       	movw	r24, r16
    2a9c:	60 e0       	ldi	r22, 0x00	; 0
    2a9e:	70 e0       	ldi	r23, 0x00	; 0
    2aa0:	0e 94 61 12 	call	0x24c2	; 0x24c2 <dir_next>
	} while (res == FR_OK);
    2aa4:	88 23       	and	r24, r24
    2aa6:	79 f2       	breq	.-98     	; 0x2a46 <follow_path+0x2f6>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    2aa8:	d8 01       	movw	r26, r16
    2aaa:	54 96       	adiw	r26, 0x14	; 20
    2aac:	ed 91       	ld	r30, X+
    2aae:	fc 91       	ld	r31, X
    2ab0:	55 97       	sbiw	r26, 0x15	; 21
    2ab2:	93 85       	ldd	r25, Z+11	; 0x0b
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
    2ab4:	84 30       	cpi	r24, 0x04	; 4
    2ab6:	a9 f5       	brne	.+106    	; 0x2b22 <follow_path+0x3d2>
				/* Object not found */
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
    2ab8:	95 ff       	sbrs	r25, 5
    2aba:	0b c0       	rjmp	.+22     	; 0x2ad2 <follow_path+0x382>
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
    2abc:	f8 01       	movw	r30, r16
    2abe:	16 82       	std	Z+6, r1	; 0x06
    2ac0:	17 82       	std	Z+7, r1	; 0x07
    2ac2:	10 86       	std	Z+8, r1	; 0x08
    2ac4:	11 86       	std	Z+9, r1	; 0x09
    2ac6:	13 8a       	std	Z+19, r1	; 0x13
    2ac8:	12 8a       	std	Z+18, r1	; 0x12
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
    2aca:	92 ff       	sbrs	r25, 2
    2acc:	8f ce       	rjmp	.-738    	; 0x27ec <follow_path+0x9c>
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
				/* Object not found */
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
    2ace:	80 e0       	ldi	r24, 0x00	; 0
    2ad0:	28 c0       	rjmp	.+80     	; 0x2b22 <follow_path+0x3d2>
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    2ad2:	92 ff       	sbrs	r25, 2
    2ad4:	23 c0       	rjmp	.+70     	; 0x2b1c <follow_path+0x3cc>
		dj->dir = 0;
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
    2ad6:	84 e0       	ldi	r24, 0x04	; 4
    2ad8:	24 c0       	rjmp	.+72     	; 0x2b22 <follow_path+0x3d2>
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    2ada:	db 01       	movw	r26, r22
    2adc:	1b 96       	adiw	r26, 0x0b	; 11
    2ade:	8c 91       	ld	r24, X
    2ae0:	1b 97       	sbiw	r26, 0x0b	; 11
    2ae2:	84 ff       	sbrs	r24, 4
    2ae4:	1d c0       	rjmp	.+58     	; 0x2b20 <follow_path+0x3d0>
				res = FR_NO_PATH; break;
			}
			dj->sclust = ld_clust(dj->fs, dir);
    2ae6:	f8 01       	movw	r30, r16
    2ae8:	80 81       	ld	r24, Z
    2aea:	91 81       	ldd	r25, Z+1	; 0x01
    2aec:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <ld_clust>
    2af0:	dc 01       	movw	r26, r24
    2af2:	cb 01       	movw	r24, r22
    2af4:	f8 01       	movw	r30, r16
    2af6:	86 83       	std	Z+6, r24	; 0x06
    2af8:	97 83       	std	Z+7, r25	; 0x07
    2afa:	a0 87       	std	Z+8, r26	; 0x08
    2afc:	b1 87       	std	Z+9, r27	; 0x09
    2afe:	76 ce       	rjmp	.-788    	; 0x27ec <follow_path+0x9c>
		for (;;) {
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
    2b00:	86 e0       	ldi	r24, 0x06	; 6
    2b02:	0f c0       	rjmp	.+30     	; 0x2b22 <follow_path+0x3d2>
#endif
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    2b04:	86 e0       	ldi	r24, 0x06	; 6
    2b06:	0d c0       	rjmp	.+26     	; 0x2b22 <follow_path+0x3d2>
    2b08:	86 e0       	ldi	r24, 0x06	; 6
    2b0a:	0b c0       	rjmp	.+22     	; 0x2b22 <follow_path+0x3d2>
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    2b0c:	86 e0       	ldi	r24, 0x06	; 6
    2b0e:	09 c0       	rjmp	.+18     	; 0x2b22 <follow_path+0x3d2>
    2b10:	86 e0       	ldi	r24, 0x06	; 6
    2b12:	07 c0       	rjmp	.+14     	; 0x2b22 <follow_path+0x3d2>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    2b14:	86 e0       	ldi	r24, 0x06	; 6
    2b16:	05 c0       	rjmp	.+10     	; 0x2b22 <follow_path+0x3d2>
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    2b18:	86 e0       	ldi	r24, 0x06	; 6
    2b1a:	03 c0       	rjmp	.+6      	; 0x2b22 <follow_path+0x3d2>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    2b1c:	85 e0       	ldi	r24, 0x05	; 5
    2b1e:	01 c0       	rjmp	.+2      	; 0x2b22 <follow_path+0x3d2>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
    2b20:	85 e0       	ldi	r24, 0x05	; 5
			dj->sclust = ld_clust(dj->fs, dir);
		}
	}

	return res;
}
    2b22:	2b 96       	adiw	r28, 0x0b	; 11
    2b24:	0f b6       	in	r0, 0x3f	; 63
    2b26:	f8 94       	cli
    2b28:	de bf       	out	0x3e, r29	; 62
    2b2a:	0f be       	out	0x3f, r0	; 63
    2b2c:	cd bf       	out	0x3d, r28	; 61
    2b2e:	df 91       	pop	r29
    2b30:	cf 91       	pop	r28
    2b32:	1f 91       	pop	r17
    2b34:	0f 91       	pop	r16
    2b36:	ff 90       	pop	r15
    2b38:	ef 90       	pop	r14
    2b3a:	df 90       	pop	r13
    2b3c:	cf 90       	pop	r12
    2b3e:	bf 90       	pop	r11
    2b40:	af 90       	pop	r10
    2b42:	9f 90       	pop	r9
    2b44:	8f 90       	pop	r8
    2b46:	7f 90       	pop	r7
    2b48:	6f 90       	pop	r6
    2b4a:	5f 90       	pop	r5
    2b4c:	4f 90       	pop	r4
    2b4e:	3f 90       	pop	r3
    2b50:	2f 90       	pop	r2
    2b52:	08 95       	ret
			c = (BYTE)p[si++];
			if (c != '.' || si >= 3) break;
			sfn[i++] = c;
		}
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
		*path = &p[si];									/* Return pointer to the next segment */
    2b54:	4a 84       	ldd	r4, Y+10	; 0x0a
    2b56:	5b 84       	ldd	r5, Y+11	; 0x0b
    2b58:	48 0e       	add	r4, r24
    2b5a:	59 1e       	adc	r5, r25
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
    2b5c:	84 e2       	ldi	r24, 0x24	; 36
    2b5e:	8e ce       	rjmp	.-740    	; 0x287c <follow_path+0x12c>
    2b60:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b62:	9b 85       	ldd	r25, Y+11	; 0x0b
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    2b64:	48 0e       	add	r4, r24
    2b66:	59 1e       	adc	r5, r25
    2b68:	89 81       	ldd	r24, Y+1	; 0x01
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    2b6a:	40 e0       	ldi	r20, 0x00	; 0
    2b6c:	42 cf       	rjmp	.-380    	; 0x29f2 <follow_path+0x2a2>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
    2b6e:	c8 01       	movw	r24, r16
    2b70:	60 e0       	ldi	r22, 0x00	; 0
    2b72:	70 e0       	ldi	r23, 0x00	; 0
    2b74:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <dir_sdi>
	if (res != FR_OK) return res;
    2b78:	88 23       	and	r24, r24
    2b7a:	09 f4       	brne	.+2      	; 0x2b7e <follow_path+0x42e>
    2b7c:	64 cf       	rjmp	.-312    	; 0x2a46 <follow_path+0x2f6>
    2b7e:	94 cf       	rjmp	.-216    	; 0x2aa8 <follow_path+0x358>
    2b80:	b6 01       	movw	r22, r12
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    2b82:	da 01       	movw	r26, r20
    2b84:	1b 96       	adiw	r26, 0x0b	; 11
    2b86:	9c 91       	ld	r25, X
    2b88:	1b 97       	sbiw	r26, 0x0b	; 11
    2b8a:	92 ff       	sbrs	r25, 2
    2b8c:	a6 cf       	rjmp	.-180    	; 0x2ada <follow_path+0x38a>
    2b8e:	c9 cf       	rjmp	.-110    	; 0x2b22 <follow_path+0x3d2>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    2b90:	d8 01       	movw	r26, r16
    2b92:	54 96       	adiw	r26, 0x14	; 20
    2b94:	ed 91       	ld	r30, X+
    2b96:	fc 91       	ld	r31, X
    2b98:	55 97       	sbiw	r26, 0x15	; 21
    2b9a:	93 85       	ldd	r25, Z+11	; 0x0b
    2b9c:	8d cf       	rjmp	.-230    	; 0x2ab8 <follow_path+0x368>

00002b9e <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
    2b9e:	ef 92       	push	r14
    2ba0:	ff 92       	push	r15
    2ba2:	0f 93       	push	r16
    2ba4:	1f 93       	push	r17
    2ba6:	cf 93       	push	r28
    2ba8:	8c 01       	movw	r16, r24
			} while (res == FR_OK && --ne);
		}
	}

#else	/* Non LFN configuration */
	res = dir_sdi(dj, 0);
    2baa:	60 e0       	ldi	r22, 0x00	; 0
    2bac:	70 e0       	ldi	r23, 0x00	; 0
    2bae:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <dir_sdi>
    2bb2:	c8 2f       	mov	r28, r24
	if (res == FR_OK) {
    2bb4:	88 23       	and	r24, r24
    2bb6:	09 f0       	breq	.+2      	; 0x2bba <dir_register+0x1c>
    2bb8:	3f c0       	rjmp	.+126    	; 0x2c38 <dir_register+0x9a>
		do {	/* Find a blank entry for the SFN */
			res = move_window(dj->fs, dj->sect);
    2bba:	d8 01       	movw	r26, r16
    2bbc:	1e 96       	adiw	r26, 0x0e	; 14
    2bbe:	4d 91       	ld	r20, X+
    2bc0:	5d 91       	ld	r21, X+
    2bc2:	6d 91       	ld	r22, X+
    2bc4:	7c 91       	ld	r23, X
    2bc6:	51 97       	sbiw	r26, 0x11	; 17
    2bc8:	8d 91       	ld	r24, X+
    2bca:	9c 91       	ld	r25, X
    2bcc:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
    2bd0:	c8 2f       	mov	r28, r24
			if (res != FR_OK) break;
    2bd2:	88 23       	and	r24, r24
    2bd4:	89 f5       	brne	.+98     	; 0x2c38 <dir_register+0x9a>
			c = *dj->dir;
    2bd6:	d8 01       	movw	r26, r16
    2bd8:	52 96       	adiw	r26, 0x12	; 18
    2bda:	ed 91       	ld	r30, X+
    2bdc:	fc 91       	ld	r31, X
    2bde:	53 97       	sbiw	r26, 0x13	; 19
    2be0:	80 81       	ld	r24, Z
			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
    2be2:	85 3e       	cpi	r24, 0xE5	; 229
    2be4:	81 f1       	breq	.+96     	; 0x2c46 <dir_register+0xa8>
    2be6:	88 23       	and	r24, r24
    2be8:	71 f1       	breq	.+92     	; 0x2c46 <dir_register+0xa8>
			res = dir_next(dj, 1);			/* Next entry with table stretch */
    2bea:	c8 01       	movw	r24, r16
    2bec:	61 e0       	ldi	r22, 0x01	; 1
    2bee:	70 e0       	ldi	r23, 0x00	; 0
    2bf0:	0e 94 61 12 	call	0x24c2	; 0x24c2 <dir_next>
    2bf4:	c8 2f       	mov	r28, r24
		} while (res == FR_OK);
    2bf6:	88 23       	and	r24, r24
    2bf8:	01 f3       	breq	.-64     	; 0x2bba <dir_register+0x1c>
    2bfa:	1e c0       	rjmp	.+60     	; 0x2c38 <dir_register+0x9a>
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
    2bfc:	f8 01       	movw	r30, r16
    2bfe:	e2 88       	ldd	r14, Z+18	; 0x12
    2c00:	f3 88       	ldd	r15, Z+19	; 0x13
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
    2c02:	c7 01       	movw	r24, r14
    2c04:	60 e0       	ldi	r22, 0x00	; 0
    2c06:	70 e0       	ldi	r23, 0x00	; 0
    2c08:	20 e2       	ldi	r18, 0x20	; 32
    2c0a:	30 e0       	ldi	r19, 0x00	; 0
    2c0c:	40 e0       	ldi	r20, 0x00	; 0
    2c0e:	50 e0       	ldi	r21, 0x00	; 0
    2c10:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <mem_set>
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
    2c14:	d8 01       	movw	r26, r16
    2c16:	54 96       	adiw	r26, 0x14	; 20
    2c18:	6d 91       	ld	r22, X+
    2c1a:	7c 91       	ld	r23, X
    2c1c:	55 97       	sbiw	r26, 0x15	; 21
    2c1e:	c7 01       	movw	r24, r14
    2c20:	2b e0       	ldi	r18, 0x0B	; 11
    2c22:	30 e0       	ldi	r19, 0x00	; 0
    2c24:	40 e0       	ldi	r20, 0x00	; 0
    2c26:	50 e0       	ldi	r21, 0x00	; 0
    2c28:	0e 94 d6 06 	call	0xdac	; 0xdac <mem_cpy>
#if _USE_LFN
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dj->fs->wflag = 1;
    2c2c:	d8 01       	movw	r26, r16
    2c2e:	ed 91       	ld	r30, X+
    2c30:	fc 91       	ld	r31, X
    2c32:	11 97       	sbiw	r26, 0x01	; 1
    2c34:	81 e0       	ldi	r24, 0x01	; 1
    2c36:	84 83       	std	Z+4, r24	; 0x04
		}
	}

	return res;
}
    2c38:	8c 2f       	mov	r24, r28
    2c3a:	cf 91       	pop	r28
    2c3c:	1f 91       	pop	r17
    2c3e:	0f 91       	pop	r16
    2c40:	ff 90       	pop	r15
    2c42:	ef 90       	pop	r14
    2c44:	08 95       	ret
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
    2c46:	f8 01       	movw	r30, r16
    2c48:	46 85       	ldd	r20, Z+14	; 0x0e
    2c4a:	57 85       	ldd	r21, Z+15	; 0x0f
    2c4c:	60 89       	ldd	r22, Z+16	; 0x10
    2c4e:	71 89       	ldd	r23, Z+17	; 0x11
    2c50:	80 81       	ld	r24, Z
    2c52:	91 81       	ldd	r25, Z+1	; 0x01
    2c54:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
    2c58:	c8 2f       	mov	r28, r24
		if (res == FR_OK) {
    2c5a:	88 23       	and	r24, r24
    2c5c:	69 f7       	brne	.-38     	; 0x2c38 <dir_register+0x9a>
    2c5e:	ce cf       	rjmp	.-100    	; 0x2bfc <dir_register+0x5e>

00002c60 <dir_read>:
#if _FS_MINIMIZE <= 1
static
FRESULT dir_read (
	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
)
{
    2c60:	cf 93       	push	r28
    2c62:	df 93       	push	r29
    2c64:	ec 01       	movw	r28, r24
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
    2c66:	84 e0       	ldi	r24, 0x04	; 4
	while (dj->sect) {
    2c68:	17 c0       	rjmp	.+46     	; 0x2c98 <dir_read+0x38>
		res = move_window(dj->fs, dj->sect);
    2c6a:	88 81       	ld	r24, Y
    2c6c:	99 81       	ldd	r25, Y+1	; 0x01
    2c6e:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
		if (res != FR_OK) break;
    2c72:	88 23       	and	r24, r24
    2c74:	e1 f4       	brne	.+56     	; 0x2cae <dir_read+0x4e>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    2c76:	ea 89       	ldd	r30, Y+18	; 0x12
    2c78:	fb 89       	ldd	r31, Y+19	; 0x13
		c = dir[DIR_Name];
    2c7a:	90 81       	ld	r25, Z
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    2c7c:	99 23       	and	r25, r25
    2c7e:	f1 f0       	breq	.+60     	; 0x2cbc <dir_read+0x5c>
					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    2c80:	95 3e       	cpi	r25, 0xE5	; 229
    2c82:	19 f0       	breq	.+6      	; 0x2c8a <dir_read+0x2a>
    2c84:	93 85       	ldd	r25, Z+11	; 0x0b
    2c86:	93 ff       	sbrs	r25, 3
    2c88:	16 c0       	rjmp	.+44     	; 0x2cb6 <dir_read+0x56>
			break;
#endif
		res = dir_next(dj, 0);				/* Next entry */
    2c8a:	ce 01       	movw	r24, r28
    2c8c:	60 e0       	ldi	r22, 0x00	; 0
    2c8e:	70 e0       	ldi	r23, 0x00	; 0
    2c90:	0e 94 61 12 	call	0x24c2	; 0x24c2 <dir_next>
		if (res != FR_OK) break;
    2c94:	88 23       	and	r24, r24
    2c96:	59 f4       	brne	.+22     	; 0x2cae <dir_read+0x4e>
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
    2c98:	4e 85       	ldd	r20, Y+14	; 0x0e
    2c9a:	5f 85       	ldd	r21, Y+15	; 0x0f
    2c9c:	68 89       	ldd	r22, Y+16	; 0x10
    2c9e:	79 89       	ldd	r23, Y+17	; 0x11
    2ca0:	41 15       	cp	r20, r1
    2ca2:	51 05       	cpc	r21, r1
    2ca4:	61 05       	cpc	r22, r1
    2ca6:	71 05       	cpc	r23, r1
    2ca8:	01 f7       	brne	.-64     	; 0x2c6a <dir_read+0xa>
#endif
		res = dir_next(dj, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
    2caa:	88 23       	and	r24, r24
    2cac:	21 f0       	breq	.+8      	; 0x2cb6 <dir_read+0x56>
    2cae:	1e 86       	std	Y+14, r1	; 0x0e
    2cb0:	1f 86       	std	Y+15, r1	; 0x0f
    2cb2:	18 8a       	std	Y+16, r1	; 0x10
    2cb4:	19 8a       	std	Y+17, r1	; 0x11

	return res;
}
    2cb6:	df 91       	pop	r29
    2cb8:	cf 91       	pop	r28
    2cba:	08 95       	ret
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    2cbc:	84 e0       	ldi	r24, 0x04	; 4
    2cbe:	f7 cf       	rjmp	.-18     	; 0x2cae <dir_read+0x4e>

00002cc0 <remove_chain>:
static
FRESULT remove_chain (
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
    2cc0:	7f 92       	push	r7
    2cc2:	8f 92       	push	r8
    2cc4:	9f 92       	push	r9
    2cc6:	af 92       	push	r10
    2cc8:	bf 92       	push	r11
    2cca:	cf 92       	push	r12
    2ccc:	df 92       	push	r13
    2cce:	ef 92       	push	r14
    2cd0:	ff 92       	push	r15
    2cd2:	0f 93       	push	r16
    2cd4:	1f 93       	push	r17
    2cd6:	cf 93       	push	r28
    2cd8:	df 93       	push	r29
    2cda:	ec 01       	movw	r28, r24
    2cdc:	4a 01       	movw	r8, r20
    2cde:	5b 01       	movw	r10, r22
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    2ce0:	42 30       	cpi	r20, 0x02	; 2
    2ce2:	51 05       	cpc	r21, r1
    2ce4:	61 05       	cpc	r22, r1
    2ce6:	71 05       	cpc	r23, r1
    2ce8:	08 f4       	brcc	.+2      	; 0x2cec <remove_chain+0x2c>
    2cea:	55 c0       	rjmp	.+170    	; 0x2d96 <remove_chain+0xd6>
    2cec:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2cee:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2cf0:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2cf2:	bd 8d       	ldd	r27, Y+29	; 0x1d
    2cf4:	48 17       	cp	r20, r24
    2cf6:	59 07       	cpc	r21, r25
    2cf8:	6a 07       	cpc	r22, r26
    2cfa:	7b 07       	cpc	r23, r27
    2cfc:	08 f0       	brcs	.+2      	; 0x2d00 <remove_chain+0x40>
    2cfe:	4d c0       	rjmp	.+154    	; 0x2d9a <remove_chain+0xda>
    2d00:	03 c0       	rjmp	.+6      	; 0x2d08 <remove_chain+0x48>
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
    2d02:	46 01       	movw	r8, r12
    2d04:	57 01       	movw	r10, r14
    2d06:	02 c0       	rjmp	.+4      	; 0x2d0c <remove_chain+0x4c>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
				fs->free_clust++;
				fs->fsi_flag = 1;
    2d08:	77 24       	eor	r7, r7
    2d0a:	73 94       	inc	r7
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
    2d0c:	ce 01       	movw	r24, r28
    2d0e:	b5 01       	movw	r22, r10
    2d10:	a4 01       	movw	r20, r8
    2d12:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <get_fat>
    2d16:	6b 01       	movw	r12, r22
    2d18:	7c 01       	movw	r14, r24
			if (nxt == 0) break;				/* Empty cluster? */
    2d1a:	61 15       	cp	r22, r1
    2d1c:	71 05       	cpc	r23, r1
    2d1e:	81 05       	cpc	r24, r1
    2d20:	91 05       	cpc	r25, r1
    2d22:	e9 f1       	breq	.+122    	; 0x2d9e <remove_chain+0xde>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    2d24:	91 e0       	ldi	r25, 0x01	; 1
    2d26:	c9 16       	cp	r12, r25
    2d28:	d1 04       	cpc	r13, r1
    2d2a:	e1 04       	cpc	r14, r1
    2d2c:	f1 04       	cpc	r15, r1
    2d2e:	c9 f1       	breq	.+114    	; 0x2da2 <remove_chain+0xe2>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    2d30:	8f ef       	ldi	r24, 0xFF	; 255
    2d32:	c8 16       	cp	r12, r24
    2d34:	8f ef       	ldi	r24, 0xFF	; 255
    2d36:	d8 06       	cpc	r13, r24
    2d38:	8f ef       	ldi	r24, 0xFF	; 255
    2d3a:	e8 06       	cpc	r14, r24
    2d3c:	8f ef       	ldi	r24, 0xFF	; 255
    2d3e:	f8 06       	cpc	r15, r24
    2d40:	91 f1       	breq	.+100    	; 0x2da6 <remove_chain+0xe6>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    2d42:	ce 01       	movw	r24, r28
    2d44:	b5 01       	movw	r22, r10
    2d46:	a4 01       	movw	r20, r8
    2d48:	00 e0       	ldi	r16, 0x00	; 0
    2d4a:	10 e0       	ldi	r17, 0x00	; 0
    2d4c:	98 01       	movw	r18, r16
    2d4e:	0e 94 30 10 	call	0x2060	; 0x2060 <put_fat>
			if (res != FR_OK) break;
    2d52:	88 23       	and	r24, r24
    2d54:	49 f5       	brne	.+82     	; 0x2da8 <remove_chain+0xe8>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    2d56:	4e 85       	ldd	r20, Y+14	; 0x0e
    2d58:	5f 85       	ldd	r21, Y+15	; 0x0f
    2d5a:	68 89       	ldd	r22, Y+16	; 0x10
    2d5c:	79 89       	ldd	r23, Y+17	; 0x11
    2d5e:	4f 3f       	cpi	r20, 0xFF	; 255
    2d60:	9f ef       	ldi	r25, 0xFF	; 255
    2d62:	59 07       	cpc	r21, r25
    2d64:	9f ef       	ldi	r25, 0xFF	; 255
    2d66:	69 07       	cpc	r22, r25
    2d68:	9f ef       	ldi	r25, 0xFF	; 255
    2d6a:	79 07       	cpc	r23, r25
    2d6c:	49 f0       	breq	.+18     	; 0x2d80 <remove_chain+0xc0>
				fs->free_clust++;
    2d6e:	4f 5f       	subi	r20, 0xFF	; 255
    2d70:	5f 4f       	sbci	r21, 0xFF	; 255
    2d72:	6f 4f       	sbci	r22, 0xFF	; 255
    2d74:	7f 4f       	sbci	r23, 0xFF	; 255
    2d76:	4e 87       	std	Y+14, r20	; 0x0e
    2d78:	5f 87       	std	Y+15, r21	; 0x0f
    2d7a:	68 8b       	std	Y+16, r22	; 0x10
    2d7c:	79 8b       	std	Y+17, r23	; 0x11
				fs->fsi_flag = 1;
    2d7e:	7d 82       	std	Y+5, r7	; 0x05
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
    2d80:	4a 8d       	ldd	r20, Y+26	; 0x1a
    2d82:	5b 8d       	ldd	r21, Y+27	; 0x1b
    2d84:	6c 8d       	ldd	r22, Y+28	; 0x1c
    2d86:	7d 8d       	ldd	r23, Y+29	; 0x1d
    2d88:	c4 16       	cp	r12, r20
    2d8a:	d5 06       	cpc	r13, r21
    2d8c:	e6 06       	cpc	r14, r22
    2d8e:	f7 06       	cpc	r15, r23
    2d90:	08 f4       	brcc	.+2      	; 0x2d94 <remove_chain+0xd4>
    2d92:	b7 cf       	rjmp	.-146    	; 0x2d02 <remove_chain+0x42>
    2d94:	09 c0       	rjmp	.+18     	; 0x2da8 <remove_chain+0xe8>
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
    2d96:	82 e0       	ldi	r24, 0x02	; 2
    2d98:	07 c0       	rjmp	.+14     	; 0x2da8 <remove_chain+0xe8>
    2d9a:	82 e0       	ldi	r24, 0x02	; 2
    2d9c:	05 c0       	rjmp	.+10     	; 0x2da8 <remove_chain+0xe8>

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
    2d9e:	80 e0       	ldi	r24, 0x00	; 0
    2da0:	03 c0       	rjmp	.+6      	; 0x2da8 <remove_chain+0xe8>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    2da2:	82 e0       	ldi	r24, 0x02	; 2
    2da4:	01 c0       	rjmp	.+2      	; 0x2da8 <remove_chain+0xe8>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    2da6:	81 e0       	ldi	r24, 0x01	; 1
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
    2da8:	df 91       	pop	r29
    2daa:	cf 91       	pop	r28
    2dac:	1f 91       	pop	r17
    2dae:	0f 91       	pop	r16
    2db0:	ff 90       	pop	r15
    2db2:	ef 90       	pop	r14
    2db4:	df 90       	pop	r13
    2db6:	cf 90       	pop	r12
    2db8:	bf 90       	pop	r11
    2dba:	af 90       	pop	r10
    2dbc:	9f 90       	pop	r9
    2dbe:	8f 90       	pop	r8
    2dc0:	7f 90       	pop	r7
    2dc2:	08 95       	ret

00002dc4 <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
    2dc4:	88 23       	and	r24, r24
    2dc6:	91 f4       	brne	.+36     	; 0x2dec <f_mount+0x28>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
    2dc8:	e0 91 87 04 	lds	r30, 0x0487
    2dcc:	f0 91 88 04 	lds	r31, 0x0488

	if (rfs) {
    2dd0:	30 97       	sbiw	r30, 0x00	; 0
    2dd2:	09 f0       	breq	.+2      	; 0x2dd6 <f_mount+0x12>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
    2dd4:	10 82       	st	Z, r1
	}

	if (fs) {
    2dd6:	61 15       	cp	r22, r1
    2dd8:	71 05       	cpc	r23, r1
    2dda:	11 f0       	breq	.+4      	; 0x2de0 <f_mount+0x1c>
		fs->fs_type = 0;		/* Clear new fs object */
    2ddc:	fb 01       	movw	r30, r22
    2dde:	10 82       	st	Z, r1
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
    2de0:	70 93 88 04 	sts	0x0488, r23
    2de4:	60 93 87 04 	sts	0x0487, r22

	return FR_OK;
    2de8:	80 e0       	ldi	r24, 0x00	; 0
    2dea:	08 95       	ret
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
    2dec:	8b e0       	ldi	r24, 0x0B	; 11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
    2dee:	08 95       	ret

00002df0 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    2df0:	4f 92       	push	r4
    2df2:	5f 92       	push	r5
    2df4:	6f 92       	push	r6
    2df6:	7f 92       	push	r7
    2df8:	8f 92       	push	r8
    2dfa:	9f 92       	push	r9
    2dfc:	af 92       	push	r10
    2dfe:	bf 92       	push	r11
    2e00:	cf 92       	push	r12
    2e02:	df 92       	push	r13
    2e04:	ef 92       	push	r14
    2e06:	ff 92       	push	r15
    2e08:	0f 93       	push	r16
    2e0a:	1f 93       	push	r17
    2e0c:	cf 93       	push	r28
    2e0e:	df 93       	push	r29
    2e10:	cd b7       	in	r28, 0x3d	; 61
    2e12:	de b7       	in	r29, 0x3e	; 62
    2e14:	a4 97       	sbiw	r28, 0x24	; 36
    2e16:	0f b6       	in	r0, 0x3f	; 63
    2e18:	f8 94       	cli
    2e1a:	de bf       	out	0x3e, r29	; 62
    2e1c:	0f be       	out	0x3f, r0	; 63
    2e1e:	cd bf       	out	0x3d, r28	; 61
    2e20:	7c 01       	movw	r14, r24
    2e22:	7c a3       	lds	r23, 0x5c
    2e24:	6b a3       	lds	r22, 0x5b
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    2e26:	00 97       	sbiw	r24, 0x00	; 0
    2e28:	09 f4       	brne	.+2      	; 0x2e2c <f_open+0x3c>
    2e2a:	ea c0       	rjmp	.+468    	; 0x3000 <f_open+0x210>
	fp->fs = 0;			/* Clear file object */
    2e2c:	fc 01       	movw	r30, r24
    2e2e:	11 82       	std	Z+1, r1	; 0x01
    2e30:	10 82       	st	Z, r1

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    2e32:	04 2f       	mov	r16, r20
    2e34:	0f 71       	andi	r16, 0x1F	; 31
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
    2e36:	4e 71       	andi	r20, 0x1E	; 30
    2e38:	ce 01       	movw	r24, r28
    2e3a:	83 96       	adiw	r24, 0x23	; 35
    2e3c:	be 01       	movw	r22, r28
    2e3e:	6f 5f       	subi	r22, 0xFF	; 255
    2e40:	7f 4f       	sbci	r23, 0xFF	; 255
    2e42:	0e 94 79 08 	call	0x10f2	; 0x10f2 <chk_mounted>
    2e46:	18 2f       	mov	r17, r24
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res == FR_OK) {
    2e48:	88 23       	and	r24, r24
    2e4a:	09 f0       	breq	.+2      	; 0x2e4e <f_open+0x5e>
    2e4c:	da c0       	rjmp	.+436    	; 0x3002 <f_open+0x212>
		INIT_BUF(dj);
    2e4e:	ce 01       	movw	r24, r28
    2e50:	47 96       	adiw	r24, 0x17	; 23
    2e52:	9e 8b       	std	Y+22, r25	; 0x16
    2e54:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    2e56:	6b a1       	lds	r22, 0x4b
    2e58:	7c a1       	lds	r23, 0x4c
    2e5a:	ce 01       	movw	r24, r28
    2e5c:	01 96       	adiw	r24, 0x01	; 1
    2e5e:	0e 94 a8 13 	call	0x2750	; 0x2750 <follow_path>
		dir = dj.dir;
    2e62:	cb 88       	ldd	r12, Y+19	; 0x13
    2e64:	dc 88       	ldd	r13, Y+20	; 0x14
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
    2e66:	88 23       	and	r24, r24
    2e68:	21 f4       	brne	.+8      	; 0x2e72 <f_open+0x82>
			if (!dir)	/* Current dir itself */
    2e6a:	c1 14       	cp	r12, r1
    2e6c:	d1 04       	cpc	r13, r1
    2e6e:	09 f4       	brne	.+2      	; 0x2e72 <f_open+0x82>
				res = FR_INVALID_NAME;
    2e70:	86 e0       	ldi	r24, 0x06	; 6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    2e72:	40 2f       	mov	r20, r16
    2e74:	50 e0       	ldi	r21, 0x00	; 0
    2e76:	9a 01       	movw	r18, r20
    2e78:	2c 71       	andi	r18, 0x1C	; 28
    2e7a:	30 70       	andi	r19, 0x00	; 0
    2e7c:	21 15       	cp	r18, r1
    2e7e:	31 05       	cpc	r19, r1
    2e80:	09 f4       	brne	.+2      	; 0x2e84 <f_open+0x94>
    2e82:	5b c0       	rjmp	.+182    	; 0x2f3a <f_open+0x14a>
			DWORD dw, cl;

			if (res != FR_OK) {					/* No file, create new */
    2e84:	88 23       	and	r24, r24
    2e86:	71 f0       	breq	.+28     	; 0x2ea4 <f_open+0xb4>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    2e88:	84 30       	cpi	r24, 0x04	; 4
    2e8a:	09 f0       	breq	.+2      	; 0x2e8e <f_open+0x9e>
    2e8c:	b7 c0       	rjmp	.+366    	; 0x2ffc <f_open+0x20c>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
    2e8e:	ce 01       	movw	r24, r28
    2e90:	01 96       	adiw	r24, 0x01	; 1
    2e92:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <dir_register>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
    2e96:	cb 88       	ldd	r12, Y+19	; 0x13
    2e98:	dc 88       	ldd	r13, Y+20	; 0x14
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    2e9a:	88 23       	and	r24, r24
    2e9c:	09 f0       	breq	.+2      	; 0x2ea0 <f_open+0xb0>
    2e9e:	ae c0       	rjmp	.+348    	; 0x2ffc <f_open+0x20c>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
    2ea0:	08 60       	ori	r16, 0x08	; 8
    2ea2:	07 c0       	rjmp	.+14     	; 0x2eb2 <f_open+0xc2>
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    2ea4:	f6 01       	movw	r30, r12
    2ea6:	83 85       	ldd	r24, Z+11	; 0x0b
    2ea8:	81 71       	andi	r24, 0x11	; 17
    2eaa:	09 f0       	breq	.+2      	; 0x2eae <f_open+0xbe>
    2eac:	c2 c0       	rjmp	.+388    	; 0x3032 <f_open+0x242>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    2eae:	02 fd       	sbrc	r16, 2
    2eb0:	c2 c0       	rjmp	.+388    	; 0x3036 <f_open+0x246>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    2eb2:	03 ff       	sbrs	r16, 3
    2eb4:	c6 c0       	rjmp	.+396    	; 0x3042 <f_open+0x252>
				dw = get_fattime();					/* Created time */
    2eb6:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <get_fattime>
				ST_DWORD(dir+DIR_CrtTime, dw);
    2eba:	f6 01       	movw	r30, r12
    2ebc:	66 87       	std	Z+14, r22	; 0x0e
    2ebe:	77 87       	std	Z+15, r23	; 0x0f
    2ec0:	80 8b       	std	Z+16, r24	; 0x10
    2ec2:	91 8b       	std	Z+17, r25	; 0x11
				dir[DIR_Attr] = 0;					/* Reset attribute */
    2ec4:	13 86       	std	Z+11, r1	; 0x0b
				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
    2ec6:	14 8e       	std	Z+28, r1	; 0x1c
    2ec8:	15 8e       	std	Z+29, r1	; 0x1d
    2eca:	16 8e       	std	Z+30, r1	; 0x1e
    2ecc:	17 8e       	std	Z+31, r1	; 0x1f
				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
    2ece:	89 81       	ldd	r24, Y+1	; 0x01
    2ed0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ed2:	b6 01       	movw	r22, r12
    2ed4:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <ld_clust>
    2ed8:	4b 01       	movw	r8, r22
    2eda:	5c 01       	movw	r10, r24
				st_clust(dir, 0);					/* cluster = 0 */
    2edc:	c6 01       	movw	r24, r12
    2ede:	40 e0       	ldi	r20, 0x00	; 0
    2ee0:	50 e0       	ldi	r21, 0x00	; 0
    2ee2:	ba 01       	movw	r22, r20
    2ee4:	0e 94 21 07 	call	0xe42	; 0xe42 <st_clust>
				dj.fs->wflag = 1;
    2ee8:	e9 81       	ldd	r30, Y+1	; 0x01
    2eea:	fa 81       	ldd	r31, Y+2	; 0x02
    2eec:	81 e0       	ldi	r24, 0x01	; 1
    2eee:	84 83       	std	Z+4, r24	; 0x04
				if (cl) {							/* Remove the cluster chain if exist */
    2ef0:	81 14       	cp	r8, r1
    2ef2:	91 04       	cpc	r9, r1
    2ef4:	a1 04       	cpc	r10, r1
    2ef6:	b1 04       	cpc	r11, r1
    2ef8:	09 f4       	brne	.+2      	; 0x2efc <f_open+0x10c>
    2efa:	a3 c0       	rjmp	.+326    	; 0x3042 <f_open+0x252>
					dw = dj.fs->winsect;
    2efc:	46 a4       	lds	r20, 0xa6
    2efe:	57 a4       	lds	r21, 0xa7
    2f00:	60 a8       	sts	0x00, r22
    2f02:	71 a8       	sts	0x81, r23
					res = remove_chain(dj.fs, cl);
    2f04:	cf 01       	movw	r24, r30
    2f06:	b5 01       	movw	r22, r10
    2f08:	a4 01       	movw	r20, r8
    2f0a:	0e 94 60 16 	call	0x2cc0	; 0x2cc0 <remove_chain>
					if (res == FR_OK) {
    2f0e:	88 23       	and	r24, r24
    2f10:	09 f0       	breq	.+2      	; 0x2f14 <f_open+0x124>
    2f12:	74 c0       	rjmp	.+232    	; 0x2ffc <f_open+0x20c>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    2f14:	e9 81       	ldd	r30, Y+1	; 0x01
    2f16:	fa 81       	ldd	r31, Y+2	; 0x02
    2f18:	d5 01       	movw	r26, r10
    2f1a:	c4 01       	movw	r24, r8
    2f1c:	01 97       	sbiw	r24, 0x01	; 1
    2f1e:	a1 09       	sbc	r26, r1
    2f20:	b1 09       	sbc	r27, r1
    2f22:	82 87       	std	Z+10, r24	; 0x0a
    2f24:	93 87       	std	Z+11, r25	; 0x0b
    2f26:	a4 87       	std	Z+12, r26	; 0x0c
    2f28:	b5 87       	std	Z+13, r27	; 0x0d
						res = move_window(dj.fs, dw);
    2f2a:	cf 01       	movw	r24, r30
    2f2c:	b3 01       	movw	r22, r6
    2f2e:	a2 01       	movw	r20, r4
    2f30:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
    2f34:	88 23       	and	r24, r24
    2f36:	69 f0       	breq	.+26     	; 0x2f52 <f_open+0x162>
    2f38:	61 c0       	rjmp	.+194    	; 0x2ffc <f_open+0x20c>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {						/* Follow succeeded */
    2f3a:	88 23       	and	r24, r24
    2f3c:	09 f0       	breq	.+2      	; 0x2f40 <f_open+0x150>
    2f3e:	5e c0       	rjmp	.+188    	; 0x2ffc <f_open+0x20c>
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    2f40:	f6 01       	movw	r30, r12
    2f42:	83 85       	ldd	r24, Z+11	; 0x0b
    2f44:	84 fd       	sbrc	r24, 4
    2f46:	79 c0       	rjmp	.+242    	; 0x303a <f_open+0x24a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    2f48:	01 ff       	sbrs	r16, 1
    2f4a:	7b c0       	rjmp	.+246    	; 0x3042 <f_open+0x252>
    2f4c:	80 fd       	sbrc	r24, 0
    2f4e:	77 c0       	rjmp	.+238    	; 0x303e <f_open+0x24e>
    2f50:	78 c0       	rjmp	.+240    	; 0x3042 <f_open+0x252>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
    2f52:	00 62       	ori	r16, 0x20	; 32
			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
    2f54:	a9 80       	ldd	r10, Y+1	; 0x01
    2f56:	ba 80       	ldd	r11, Y+2	; 0x02
    2f58:	f5 01       	movw	r30, r10
    2f5a:	86 a5       	lds	r24, 0x66
    2f5c:	97 a5       	lds	r25, 0x67
    2f5e:	a0 a9       	sts	0x40, r26
    2f60:	b1 a9       	sts	0x41, r27
    2f62:	f7 01       	movw	r30, r14
    2f64:	82 8f       	std	Z+26, r24	; 0x1a
    2f66:	93 8f       	std	Z+27, r25	; 0x1b
    2f68:	a4 8f       	std	Z+28, r26	; 0x1c
    2f6a:	b5 8f       	std	Z+29, r27	; 0x1d
			fp->dir_ptr = dir;
    2f6c:	d7 8e       	std	Z+31, r13	; 0x1f
    2f6e:	c6 8e       	std	Z+30, r12	; 0x1e
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
    2f70:	04 83       	std	Z+4, r16	; 0x04
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
    2f72:	c5 01       	movw	r24, r10
    2f74:	b6 01       	movw	r22, r12
    2f76:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <ld_clust>
    2f7a:	dc 01       	movw	r26, r24
    2f7c:	cb 01       	movw	r24, r22
    2f7e:	f7 01       	movw	r30, r14
    2f80:	86 87       	std	Z+14, r24	; 0x0e
    2f82:	97 87       	std	Z+15, r25	; 0x0f
    2f84:	a0 8b       	std	Z+16, r26	; 0x10
    2f86:	b1 8b       	std	Z+17, r27	; 0x11
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    2f88:	f6 01       	movw	r30, r12
    2f8a:	87 8d       	ldd	r24, Z+31	; 0x1f
    2f8c:	90 e0       	ldi	r25, 0x00	; 0
    2f8e:	a0 e0       	ldi	r26, 0x00	; 0
    2f90:	b0 e0       	ldi	r27, 0x00	; 0
    2f92:	78 2f       	mov	r23, r24
    2f94:	66 27       	eor	r22, r22
    2f96:	55 27       	eor	r21, r21
    2f98:	44 27       	eor	r20, r20
    2f9a:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f9c:	90 e0       	ldi	r25, 0x00	; 0
    2f9e:	a0 e0       	ldi	r26, 0x00	; 0
    2fa0:	b0 e0       	ldi	r27, 0x00	; 0
    2fa2:	dc 01       	movw	r26, r24
    2fa4:	99 27       	eor	r25, r25
    2fa6:	88 27       	eor	r24, r24
    2fa8:	48 2b       	or	r20, r24
    2faa:	59 2b       	or	r21, r25
    2fac:	6a 2b       	or	r22, r26
    2fae:	7b 2b       	or	r23, r27
    2fb0:	84 8d       	ldd	r24, Z+28	; 0x1c
    2fb2:	90 e0       	ldi	r25, 0x00	; 0
    2fb4:	a0 e0       	ldi	r26, 0x00	; 0
    2fb6:	b0 e0       	ldi	r27, 0x00	; 0
    2fb8:	48 2b       	or	r20, r24
    2fba:	59 2b       	or	r21, r25
    2fbc:	6a 2b       	or	r22, r26
    2fbe:	7b 2b       	or	r23, r27
    2fc0:	95 8d       	ldd	r25, Z+29	; 0x1d
    2fc2:	80 e0       	ldi	r24, 0x00	; 0
    2fc4:	a0 e0       	ldi	r26, 0x00	; 0
    2fc6:	b0 e0       	ldi	r27, 0x00	; 0
    2fc8:	84 2b       	or	r24, r20
    2fca:	95 2b       	or	r25, r21
    2fcc:	a6 2b       	or	r26, r22
    2fce:	b7 2b       	or	r27, r23
    2fd0:	f7 01       	movw	r30, r14
    2fd2:	82 87       	std	Z+10, r24	; 0x0a
    2fd4:	93 87       	std	Z+11, r25	; 0x0b
    2fd6:	a4 87       	std	Z+12, r26	; 0x0c
    2fd8:	b5 87       	std	Z+13, r27	; 0x0d
			fp->fptr = 0;						/* File pointer */
    2fda:	16 82       	std	Z+6, r1	; 0x06
    2fdc:	17 82       	std	Z+7, r1	; 0x07
    2fde:	10 86       	std	Z+8, r1	; 0x08
    2fe0:	11 86       	std	Z+9, r1	; 0x09
			fp->dsect = 0;
    2fe2:	16 8a       	std	Z+22, r1	; 0x16
    2fe4:	17 8a       	std	Z+23, r1	; 0x17
    2fe6:	10 8e       	std	Z+24, r1	; 0x18
    2fe8:	11 8e       	std	Z+25, r1	; 0x19
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    2fea:	b1 82       	std	Z+1, r11	; 0x01
    2fec:	a0 82       	st	Z, r10
    2fee:	f5 01       	movw	r30, r10
    2ff0:	86 81       	ldd	r24, Z+6	; 0x06
    2ff2:	97 81       	ldd	r25, Z+7	; 0x07
    2ff4:	f7 01       	movw	r30, r14
    2ff6:	93 83       	std	Z+3, r25	; 0x03
    2ff8:	82 83       	std	Z+2, r24	; 0x02
    2ffa:	03 c0       	rjmp	.+6      	; 0x3002 <f_open+0x212>
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    2ffc:	18 2f       	mov	r17, r24
    2ffe:	01 c0       	rjmp	.+2      	; 0x3002 <f_open+0x212>
    3000:	19 e0       	ldi	r17, 0x09	; 9
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
		}
	}

	LEAVE_FF(dj.fs, res);
}
    3002:	81 2f       	mov	r24, r17
    3004:	a4 96       	adiw	r28, 0x24	; 36
    3006:	0f b6       	in	r0, 0x3f	; 63
    3008:	f8 94       	cli
    300a:	de bf       	out	0x3e, r29	; 62
    300c:	0f be       	out	0x3f, r0	; 63
    300e:	cd bf       	out	0x3d, r28	; 61
    3010:	df 91       	pop	r29
    3012:	cf 91       	pop	r28
    3014:	1f 91       	pop	r17
    3016:	0f 91       	pop	r16
    3018:	ff 90       	pop	r15
    301a:	ef 90       	pop	r14
    301c:	df 90       	pop	r13
    301e:	cf 90       	pop	r12
    3020:	bf 90       	pop	r11
    3022:	af 90       	pop	r10
    3024:	9f 90       	pop	r9
    3026:	8f 90       	pop	r8
    3028:	7f 90       	pop	r7
    302a:	6f 90       	pop	r6
    302c:	5f 90       	pop	r5
    302e:	4f 90       	pop	r4
    3030:	08 95       	ret
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
					res = FR_DENIED;
    3032:	87 e0       	ldi	r24, 0x07	; 7
    3034:	e3 cf       	rjmp	.-58     	; 0x2ffc <f_open+0x20c>
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
    3036:	88 e0       	ldi	r24, 0x08	; 8
    3038:	e1 cf       	rjmp	.-62     	; 0x2ffc <f_open+0x20c>
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {						/* Follow succeeded */
				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
					res = FR_NO_FILE;
    303a:	84 e0       	ldi	r24, 0x04	; 4
    303c:	df cf       	rjmp	.-66     	; 0x2ffc <f_open+0x20c>
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
    303e:	87 e0       	ldi	r24, 0x07	; 7
    3040:	dd cf       	rjmp	.-70     	; 0x2ffc <f_open+0x20c>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
    3042:	03 ff       	sbrs	r16, 3
    3044:	87 cf       	rjmp	.-242    	; 0x2f54 <f_open+0x164>
    3046:	85 cf       	rjmp	.-246    	; 0x2f52 <f_open+0x162>

00003048 <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
    3048:	2f 92       	push	r2
    304a:	3f 92       	push	r3
    304c:	4f 92       	push	r4
    304e:	5f 92       	push	r5
    3050:	6f 92       	push	r6
    3052:	7f 92       	push	r7
    3054:	8f 92       	push	r8
    3056:	9f 92       	push	r9
    3058:	af 92       	push	r10
    305a:	bf 92       	push	r11
    305c:	cf 92       	push	r12
    305e:	df 92       	push	r13
    3060:	ef 92       	push	r14
    3062:	ff 92       	push	r15
    3064:	0f 93       	push	r16
    3066:	1f 93       	push	r17
    3068:	cf 93       	push	r28
    306a:	df 93       	push	r29
    306c:	cd b7       	in	r28, 0x3d	; 61
    306e:	de b7       	in	r29, 0x3e	; 62
    3070:	29 97       	sbiw	r28, 0x09	; 9
    3072:	0f b6       	in	r0, 0x3f	; 63
    3074:	f8 94       	cli
    3076:	de bf       	out	0x3e, r29	; 62
    3078:	0f be       	out	0x3f, r0	; 63
    307a:	cd bf       	out	0x3d, r28	; 61
    307c:	9c 83       	std	Y+4, r25	; 0x04
    307e:	8b 83       	std	Y+3, r24	; 0x03
    3080:	a6 2e       	mov	r10, r22
    3082:	97 2e       	mov	r9, r23
    3084:	c2 2e       	mov	r12, r18
    3086:	f3 2e       	mov	r15, r19
    3088:	e4 2e       	mov	r14, r20
    308a:	d5 2e       	mov	r13, r21
    308c:	18 01       	movw	r2, r16
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Clear read byte counter */
    308e:	d8 01       	movw	r26, r16
    3090:	1d 92       	st	X+, r1
    3092:	1d 92       	st	X+, r1
    3094:	1d 92       	st	X+, r1
    3096:	1c 92       	st	X, r1
    3098:	13 97       	sbiw	r26, 0x03	; 3

	res = validate(fp);							/* Check validity */
    309a:	0e 94 bc 07 	call	0xf78	; 0xf78 <validate>
    309e:	b8 2e       	mov	r11, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    30a0:	88 23       	and	r24, r24
    30a2:	09 f0       	breq	.+2      	; 0x30a6 <f_read+0x5e>
    30a4:	e1 c1       	rjmp	.+962    	; 0x3468 <f_read+0x420>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
    30a6:	eb 81       	ldd	r30, Y+3	; 0x03
    30a8:	fc 81       	ldd	r31, Y+4	; 0x04
    30aa:	84 81       	ldd	r24, Z+4	; 0x04
    30ac:	88 23       	and	r24, r24
    30ae:	0c f4       	brge	.+2      	; 0x30b2 <f_read+0x6a>
    30b0:	d3 c1       	rjmp	.+934    	; 0x3458 <f_read+0x410>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    30b2:	80 ff       	sbrs	r24, 0
    30b4:	d5 c1       	rjmp	.+938    	; 0x3460 <f_read+0x418>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
    30b6:	42 85       	ldd	r20, Z+10	; 0x0a
    30b8:	53 85       	ldd	r21, Z+11	; 0x0b
    30ba:	64 85       	ldd	r22, Z+12	; 0x0c
    30bc:	75 85       	ldd	r23, Z+13	; 0x0d
    30be:	86 81       	ldd	r24, Z+6	; 0x06
    30c0:	97 81       	ldd	r25, Z+7	; 0x07
    30c2:	a0 85       	ldd	r26, Z+8	; 0x08
    30c4:	b1 85       	ldd	r27, Z+9	; 0x09
    30c6:	48 1b       	sub	r20, r24
    30c8:	59 0b       	sbc	r21, r25
    30ca:	6a 0b       	sbc	r22, r26
    30cc:	7b 0b       	sbc	r23, r27

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    30ce:	4c 2c       	mov	r4, r12
    30d0:	5f 2c       	mov	r5, r15
    30d2:	6e 2c       	mov	r6, r14
    30d4:	7d 2c       	mov	r7, r13
    30d6:	44 15       	cp	r20, r4
    30d8:	55 05       	cpc	r21, r5
    30da:	66 05       	cpc	r22, r6
    30dc:	77 05       	cpc	r23, r7
    30de:	10 f4       	brcc	.+4      	; 0x30e4 <f_read+0x9c>
    30e0:	2a 01       	movw	r4, r20
    30e2:	3b 01       	movw	r6, r22
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    30e4:	41 14       	cp	r4, r1
    30e6:	51 04       	cpc	r5, r1
    30e8:	61 04       	cpc	r6, r1
    30ea:	71 04       	cpc	r7, r1
    30ec:	09 f4       	brne	.+2      	; 0x30f0 <f_read+0xa8>
    30ee:	bc c1       	rjmp	.+888    	; 0x3468 <f_read+0x420>
    30f0:	a9 82       	std	Y+1, r10	; 0x01
    30f2:	9a 82       	std	Y+2, r9	; 0x02
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    30f4:	0b 81       	ldd	r16, Y+3	; 0x03
    30f6:	1c 81       	ldd	r17, Y+4	; 0x04
    30f8:	00 5e       	subi	r16, 0xE0	; 224
    30fa:	1f 4f       	sbci	r17, 0xFF	; 255
    30fc:	1e 83       	std	Y+6, r17	; 0x06
    30fe:	0d 83       	std	Y+5, r16	; 0x05
    3100:	bf 82       	std	Y+7, r11	; 0x07
    3102:	2b 81       	ldd	r18, Y+3	; 0x03
    3104:	3c 81       	ldd	r19, Y+4	; 0x04
    3106:	39 87       	std	Y+9, r19	; 0x09
    3108:	28 87       	std	Y+8, r18	; 0x08
    310a:	3c 82       	std	Y+4, r3	; 0x04
    310c:	2b 82       	std	Y+3, r2	; 0x03
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    310e:	a8 85       	ldd	r26, Y+8	; 0x08
    3110:	b9 85       	ldd	r27, Y+9	; 0x09
    3112:	16 96       	adiw	r26, 0x06	; 6
    3114:	4d 91       	ld	r20, X+
    3116:	5d 91       	ld	r21, X+
    3118:	6d 91       	ld	r22, X+
    311a:	7c 91       	ld	r23, X
    311c:	19 97       	sbiw	r26, 0x09	; 9
    311e:	db 01       	movw	r26, r22
    3120:	ca 01       	movw	r24, r20
    3122:	91 70       	andi	r25, 0x01	; 1
    3124:	a0 70       	andi	r26, 0x00	; 0
    3126:	b0 70       	andi	r27, 0x00	; 0
    3128:	00 97       	sbiw	r24, 0x00	; 0
    312a:	a1 05       	cpc	r26, r1
    312c:	b1 05       	cpc	r27, r1
    312e:	09 f0       	breq	.+2      	; 0x3132 <f_read+0xea>
    3130:	3f c1       	rjmp	.+638    	; 0x33b0 <f_read+0x368>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    3132:	a8 85       	ldd	r26, Y+8	; 0x08
    3134:	b9 85       	ldd	r27, Y+9	; 0x09
    3136:	ed 91       	ld	r30, X+
    3138:	fc 91       	ld	r31, X
    313a:	db 01       	movw	r26, r22
    313c:	ca 01       	movw	r24, r20
    313e:	07 2e       	mov	r0, r23
    3140:	79 e0       	ldi	r23, 0x09	; 9
    3142:	b6 95       	lsr	r27
    3144:	a7 95       	ror	r26
    3146:	97 95       	ror	r25
    3148:	87 95       	ror	r24
    314a:	7a 95       	dec	r23
    314c:	d1 f7       	brne	.-12     	; 0x3142 <f_read+0xfa>
    314e:	70 2d       	mov	r23, r0
    3150:	02 81       	ldd	r16, Z+2	; 0x02
    3152:	01 50       	subi	r16, 0x01	; 1
    3154:	08 23       	and	r16, r24
			if (!csect) {						/* On the cluster boundary? */
    3156:	09 f0       	breq	.+2      	; 0x315a <f_read+0x112>
    3158:	44 c0       	rjmp	.+136    	; 0x31e2 <f_read+0x19a>
				if (fp->fptr == 0) {			/* On the top of the file? */
    315a:	41 15       	cp	r20, r1
    315c:	51 05       	cpc	r21, r1
    315e:	61 05       	cpc	r22, r1
    3160:	71 05       	cpc	r23, r1
    3162:	39 f4       	brne	.+14     	; 0x3172 <f_read+0x12a>
					clst = fp->sclust;			/* Follow from the origin */
    3164:	e8 85       	ldd	r30, Y+8	; 0x08
    3166:	f9 85       	ldd	r31, Y+9	; 0x09
    3168:	86 85       	ldd	r24, Z+14	; 0x0e
    316a:	97 85       	ldd	r25, Z+15	; 0x0f
    316c:	a0 89       	ldd	r26, Z+16	; 0x10
    316e:	b1 89       	ldd	r27, Z+17	; 0x11
    3170:	0d c0       	rjmp	.+26     	; 0x318c <f_read+0x144>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    3172:	a8 85       	ldd	r26, Y+8	; 0x08
    3174:	b9 85       	ldd	r27, Y+9	; 0x09
    3176:	52 96       	adiw	r26, 0x12	; 18
    3178:	4d 91       	ld	r20, X+
    317a:	5d 91       	ld	r21, X+
    317c:	6d 91       	ld	r22, X+
    317e:	7c 91       	ld	r23, X
    3180:	55 97       	sbiw	r26, 0x15	; 21
    3182:	cf 01       	movw	r24, r30
    3184:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <get_fat>
    3188:	dc 01       	movw	r26, r24
    318a:	cb 01       	movw	r24, r22
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    318c:	82 30       	cpi	r24, 0x02	; 2
    318e:	91 05       	cpc	r25, r1
    3190:	a1 05       	cpc	r26, r1
    3192:	b1 05       	cpc	r27, r1
    3194:	48 f4       	brcc	.+18     	; 0x31a8 <f_read+0x160>
    3196:	e8 85       	ldd	r30, Y+8	; 0x08
    3198:	f9 85       	ldd	r31, Y+9	; 0x09
    319a:	84 81       	ldd	r24, Z+4	; 0x04
    319c:	80 68       	ori	r24, 0x80	; 128
    319e:	84 83       	std	Z+4, r24	; 0x04
    31a0:	bb 24       	eor	r11, r11
    31a2:	68 94       	set
    31a4:	b1 f8       	bld	r11, 1
    31a6:	60 c1       	rjmp	.+704    	; 0x3468 <f_read+0x420>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    31a8:	8f 3f       	cpi	r24, 0xFF	; 255
    31aa:	ff ef       	ldi	r31, 0xFF	; 255
    31ac:	9f 07       	cpc	r25, r31
    31ae:	ff ef       	ldi	r31, 0xFF	; 255
    31b0:	af 07       	cpc	r26, r31
    31b2:	ff ef       	ldi	r31, 0xFF	; 255
    31b4:	bf 07       	cpc	r27, r31
    31b6:	79 f4       	brne	.+30     	; 0x31d6 <f_read+0x18e>
    31b8:	08 85       	ldd	r16, Y+8	; 0x08
    31ba:	19 85       	ldd	r17, Y+9	; 0x09
    31bc:	1c 83       	std	Y+4, r17	; 0x04
    31be:	0b 83       	std	Y+3, r16	; 0x03
    31c0:	d8 01       	movw	r26, r16
    31c2:	14 96       	adiw	r26, 0x04	; 4
    31c4:	8c 91       	ld	r24, X
    31c6:	14 97       	sbiw	r26, 0x04	; 4
    31c8:	80 68       	ori	r24, 0x80	; 128
    31ca:	14 96       	adiw	r26, 0x04	; 4
    31cc:	8c 93       	st	X, r24
    31ce:	14 97       	sbiw	r26, 0x04	; 4
    31d0:	bb 24       	eor	r11, r11
    31d2:	b3 94       	inc	r11
    31d4:	49 c1       	rjmp	.+658    	; 0x3468 <f_read+0x420>
				fp->clust = clst;				/* Update current cluster */
    31d6:	e8 85       	ldd	r30, Y+8	; 0x08
    31d8:	f9 85       	ldd	r31, Y+9	; 0x09
    31da:	82 8b       	std	Z+18, r24	; 0x12
    31dc:	93 8b       	std	Z+19, r25	; 0x13
    31de:	a4 8b       	std	Z+20, r26	; 0x14
    31e0:	b5 8b       	std	Z+21, r27	; 0x15
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    31e2:	a8 85       	ldd	r26, Y+8	; 0x08
    31e4:	b9 85       	ldd	r27, Y+9	; 0x09
    31e6:	2d 90       	ld	r2, X+
    31e8:	3c 90       	ld	r3, X
    31ea:	11 97       	sbiw	r26, 0x01	; 1
    31ec:	52 96       	adiw	r26, 0x12	; 18
    31ee:	4d 91       	ld	r20, X+
    31f0:	5d 91       	ld	r21, X+
    31f2:	6d 91       	ld	r22, X+
    31f4:	7c 91       	ld	r23, X
    31f6:	55 97       	sbiw	r26, 0x15	; 21
    31f8:	c1 01       	movw	r24, r2
    31fa:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <clust2sect>
    31fe:	dc 01       	movw	r26, r24
    3200:	cb 01       	movw	r24, r22
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    3202:	00 97       	sbiw	r24, 0x00	; 0
    3204:	a1 05       	cpc	r26, r1
    3206:	b1 05       	cpc	r27, r1
    3208:	49 f4       	brne	.+18     	; 0x321c <f_read+0x1d4>
    320a:	e8 85       	ldd	r30, Y+8	; 0x08
    320c:	f9 85       	ldd	r31, Y+9	; 0x09
    320e:	84 81       	ldd	r24, Z+4	; 0x04
    3210:	80 68       	ori	r24, 0x80	; 128
    3212:	84 83       	std	Z+4, r24	; 0x04
    3214:	bb 24       	eor	r11, r11
    3216:	68 94       	set
    3218:	b1 f8       	bld	r11, 1
    321a:	26 c1       	rjmp	.+588    	; 0x3468 <f_read+0x420>
			sect += csect;
    321c:	40 2f       	mov	r20, r16
    321e:	50 e0       	ldi	r21, 0x00	; 0
    3220:	60 e0       	ldi	r22, 0x00	; 0
    3222:	70 e0       	ldi	r23, 0x00	; 0
    3224:	4c 01       	movw	r8, r24
    3226:	5d 01       	movw	r10, r26
    3228:	84 0e       	add	r8, r20
    322a:	95 1e       	adc	r9, r21
    322c:	a6 1e       	adc	r10, r22
    322e:	b7 1e       	adc	r11, r23
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    3230:	73 01       	movw	r14, r6
    3232:	62 01       	movw	r12, r4
    3234:	0b 2e       	mov	r0, r27
    3236:	b9 e0       	ldi	r27, 0x09	; 9
    3238:	f6 94       	lsr	r15
    323a:	e7 94       	ror	r14
    323c:	d7 94       	ror	r13
    323e:	c7 94       	ror	r12
    3240:	ba 95       	dec	r27
    3242:	d1 f7       	brne	.-12     	; 0x3238 <f_read+0x1f0>
    3244:	b0 2d       	mov	r27, r0
			if (cc) {							/* Read maximum contiguous sectors directly */
    3246:	c1 14       	cp	r12, r1
    3248:	d1 04       	cpc	r13, r1
    324a:	e1 04       	cpc	r14, r1
    324c:	f1 04       	cpc	r15, r1
    324e:	09 f4       	brne	.+2      	; 0x3252 <f_read+0x20a>
    3250:	60 c0       	rjmp	.+192    	; 0x3312 <f_read+0x2ca>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    3252:	d1 01       	movw	r26, r2
    3254:	12 96       	adiw	r26, 0x02	; 2
    3256:	2c 91       	ld	r18, X
    3258:	d7 01       	movw	r26, r14
    325a:	c6 01       	movw	r24, r12
    325c:	84 0f       	add	r24, r20
    325e:	95 1f       	adc	r25, r21
    3260:	a6 1f       	adc	r26, r22
    3262:	b7 1f       	adc	r27, r23
    3264:	42 2f       	mov	r20, r18
    3266:	50 e0       	ldi	r21, 0x00	; 0
    3268:	60 e0       	ldi	r22, 0x00	; 0
    326a:	70 e0       	ldi	r23, 0x00	; 0
    326c:	48 17       	cp	r20, r24
    326e:	59 07       	cpc	r21, r25
    3270:	6a 07       	cpc	r22, r26
    3272:	7b 07       	cpc	r23, r27
    3274:	48 f4       	brcc	.+18     	; 0x3288 <f_read+0x240>
					cc = fp->fs->csize - csect;
    3276:	82 2f       	mov	r24, r18
    3278:	90 e0       	ldi	r25, 0x00	; 0
    327a:	80 1b       	sub	r24, r16
    327c:	91 09       	sbc	r25, r1
    327e:	6c 01       	movw	r12, r24
    3280:	ee 24       	eor	r14, r14
    3282:	d7 fc       	sbrc	r13, 7
    3284:	e0 94       	com	r14
    3286:	fe 2c       	mov	r15, r14
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    3288:	f1 01       	movw	r30, r2
    328a:	81 81       	ldd	r24, Z+1	; 0x01
    328c:	69 81       	ldd	r22, Y+1	; 0x01
    328e:	7a 81       	ldd	r23, Y+2	; 0x02
    3290:	a5 01       	movw	r20, r10
    3292:	94 01       	movw	r18, r8
    3294:	0c 2d       	mov	r16, r12
    3296:	0e 94 93 02 	call	0x526	; 0x526 <disk_read>
    329a:	88 23       	and	r24, r24
    329c:	79 f0       	breq	.+30     	; 0x32bc <f_read+0x274>
    329e:	08 85       	ldd	r16, Y+8	; 0x08
    32a0:	19 85       	ldd	r17, Y+9	; 0x09
    32a2:	1c 83       	std	Y+4, r17	; 0x04
    32a4:	0b 83       	std	Y+3, r16	; 0x03
					ABORT(fp->fs, FR_DISK_ERR);
    32a6:	d8 01       	movw	r26, r16
    32a8:	14 96       	adiw	r26, 0x04	; 4
    32aa:	8c 91       	ld	r24, X
    32ac:	14 97       	sbiw	r26, 0x04	; 4
    32ae:	80 68       	ori	r24, 0x80	; 128
    32b0:	14 96       	adiw	r26, 0x04	; 4
    32b2:	8c 93       	st	X, r24
    32b4:	14 97       	sbiw	r26, 0x04	; 4
    32b6:	bb 24       	eor	r11, r11
    32b8:	b3 94       	inc	r11
    32ba:	d6 c0       	rjmp	.+428    	; 0x3468 <f_read+0x420>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
    32bc:	e8 85       	ldd	r30, Y+8	; 0x08
    32be:	f9 85       	ldd	r31, Y+9	; 0x09
    32c0:	84 81       	ldd	r24, Z+4	; 0x04
    32c2:	86 ff       	sbrs	r24, 6
    32c4:	1c c0       	rjmp	.+56     	; 0x32fe <f_read+0x2b6>
    32c6:	86 89       	ldd	r24, Z+22	; 0x16
    32c8:	97 89       	ldd	r25, Z+23	; 0x17
    32ca:	a0 8d       	ldd	r26, Z+24	; 0x18
    32cc:	b1 8d       	ldd	r27, Z+25	; 0x19
    32ce:	88 19       	sub	r24, r8
    32d0:	99 09       	sbc	r25, r9
    32d2:	aa 09       	sbc	r26, r10
    32d4:	bb 09       	sbc	r27, r11
    32d6:	8c 15       	cp	r24, r12
    32d8:	9d 05       	cpc	r25, r13
    32da:	ae 05       	cpc	r26, r14
    32dc:	bf 05       	cpc	r27, r15
    32de:	78 f4       	brcc	.+30     	; 0x32fe <f_read+0x2b6>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
    32e0:	98 2f       	mov	r25, r24
    32e2:	88 27       	eor	r24, r24
    32e4:	99 0f       	add	r25, r25
    32e6:	09 81       	ldd	r16, Y+1	; 0x01
    32e8:	1a 81       	ldd	r17, Y+2	; 0x02
    32ea:	80 0f       	add	r24, r16
    32ec:	91 1f       	adc	r25, r17
    32ee:	6d 81       	ldd	r22, Y+5	; 0x05
    32f0:	7e 81       	ldd	r23, Y+6	; 0x06
    32f2:	20 e0       	ldi	r18, 0x00	; 0
    32f4:	32 e0       	ldi	r19, 0x02	; 2
    32f6:	40 e0       	ldi	r20, 0x00	; 0
    32f8:	50 e0       	ldi	r21, 0x00	; 0
    32fa:	0e 94 d6 06 	call	0xdac	; 0xdac <mem_cpy>
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    32fe:	0b 2e       	mov	r0, r27
    3300:	b9 e0       	ldi	r27, 0x09	; 9
    3302:	cc 0c       	add	r12, r12
    3304:	dd 1c       	adc	r13, r13
    3306:	ee 1c       	adc	r14, r14
    3308:	ff 1c       	adc	r15, r15
    330a:	ba 95       	dec	r27
    330c:	d1 f7       	brne	.-12     	; 0x3302 <f_read+0x2ba>
    330e:	b0 2d       	mov	r27, r0
				continue;
    3310:	79 c0       	rjmp	.+242    	; 0x3404 <f_read+0x3bc>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
    3312:	a8 85       	ldd	r26, Y+8	; 0x08
    3314:	b9 85       	ldd	r27, Y+9	; 0x09
    3316:	56 96       	adiw	r26, 0x16	; 22
    3318:	0d 91       	ld	r16, X+
    331a:	1d 91       	ld	r17, X+
    331c:	2d 91       	ld	r18, X+
    331e:	3c 91       	ld	r19, X
    3320:	59 97       	sbiw	r26, 0x19	; 25
    3322:	08 15       	cp	r16, r8
    3324:	19 05       	cpc	r17, r9
    3326:	2a 05       	cpc	r18, r10
    3328:	3b 05       	cpc	r19, r11
    332a:	d1 f1       	breq	.+116    	; 0x33a0 <f_read+0x358>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
    332c:	14 96       	adiw	r26, 0x04	; 4
    332e:	8c 91       	ld	r24, X
    3330:	14 97       	sbiw	r26, 0x04	; 4
    3332:	86 ff       	sbrs	r24, 6
    3334:	1f c0       	rjmp	.+62     	; 0x3374 <f_read+0x32c>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3336:	f1 01       	movw	r30, r2
    3338:	81 81       	ldd	r24, Z+1	; 0x01
    333a:	6d 81       	ldd	r22, Y+5	; 0x05
    333c:	7e 81       	ldd	r23, Y+6	; 0x06
    333e:	a9 01       	movw	r20, r18
    3340:	98 01       	movw	r18, r16
    3342:	01 e0       	ldi	r16, 0x01	; 1
    3344:	0e 94 ed 02 	call	0x5da	; 0x5da <disk_write>
    3348:	88 23       	and	r24, r24
    334a:	79 f0       	breq	.+30     	; 0x336a <f_read+0x322>
    334c:	08 85       	ldd	r16, Y+8	; 0x08
    334e:	19 85       	ldd	r17, Y+9	; 0x09
    3350:	1c 83       	std	Y+4, r17	; 0x04
    3352:	0b 83       	std	Y+3, r16	; 0x03
						ABORT(fp->fs, FR_DISK_ERR);
    3354:	d8 01       	movw	r26, r16
    3356:	14 96       	adiw	r26, 0x04	; 4
    3358:	8c 91       	ld	r24, X
    335a:	14 97       	sbiw	r26, 0x04	; 4
    335c:	80 68       	ori	r24, 0x80	; 128
    335e:	14 96       	adiw	r26, 0x04	; 4
    3360:	8c 93       	st	X, r24
    3362:	14 97       	sbiw	r26, 0x04	; 4
    3364:	bb 24       	eor	r11, r11
    3366:	b3 94       	inc	r11
    3368:	7f c0       	rjmp	.+254    	; 0x3468 <f_read+0x420>
					fp->flag &= ~FA__DIRTY;
    336a:	e8 85       	ldd	r30, Y+8	; 0x08
    336c:	f9 85       	ldd	r31, Y+9	; 0x09
    336e:	84 81       	ldd	r24, Z+4	; 0x04
    3370:	8f 7b       	andi	r24, 0xBF	; 191
    3372:	84 83       	std	Z+4, r24	; 0x04
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    3374:	a8 85       	ldd	r26, Y+8	; 0x08
    3376:	b9 85       	ldd	r27, Y+9	; 0x09
    3378:	ed 91       	ld	r30, X+
    337a:	fc 91       	ld	r31, X
    337c:	81 81       	ldd	r24, Z+1	; 0x01
    337e:	6d 81       	ldd	r22, Y+5	; 0x05
    3380:	7e 81       	ldd	r23, Y+6	; 0x06
    3382:	a5 01       	movw	r20, r10
    3384:	94 01       	movw	r18, r8
    3386:	01 e0       	ldi	r16, 0x01	; 1
    3388:	0e 94 93 02 	call	0x526	; 0x526 <disk_read>
    338c:	88 23       	and	r24, r24
    338e:	41 f0       	breq	.+16     	; 0x33a0 <f_read+0x358>
    3390:	e8 85       	ldd	r30, Y+8	; 0x08
    3392:	f9 85       	ldd	r31, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3394:	84 81       	ldd	r24, Z+4	; 0x04
    3396:	80 68       	ori	r24, 0x80	; 128
    3398:	84 83       	std	Z+4, r24	; 0x04
    339a:	bb 24       	eor	r11, r11
    339c:	b3 94       	inc	r11
    339e:	64 c0       	rjmp	.+200    	; 0x3468 <f_read+0x420>
			}
#endif
			fp->dsect = sect;
    33a0:	a8 85       	ldd	r26, Y+8	; 0x08
    33a2:	b9 85       	ldd	r27, Y+9	; 0x09
    33a4:	56 96       	adiw	r26, 0x16	; 22
    33a6:	8d 92       	st	X+, r8
    33a8:	9d 92       	st	X+, r9
    33aa:	ad 92       	st	X+, r10
    33ac:	bc 92       	st	X, r11
    33ae:	59 97       	sbiw	r26, 0x19	; 25
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    33b0:	e8 85       	ldd	r30, Y+8	; 0x08
    33b2:	f9 85       	ldd	r31, Y+9	; 0x09
    33b4:	46 81       	ldd	r20, Z+6	; 0x06
    33b6:	57 81       	ldd	r21, Z+7	; 0x07
    33b8:	60 85       	ldd	r22, Z+8	; 0x08
    33ba:	71 85       	ldd	r23, Z+9	; 0x09
    33bc:	db 01       	movw	r26, r22
    33be:	ca 01       	movw	r24, r20
    33c0:	91 70       	andi	r25, 0x01	; 1
    33c2:	a0 70       	andi	r26, 0x00	; 0
    33c4:	b0 70       	andi	r27, 0x00	; 0
    33c6:	00 e0       	ldi	r16, 0x00	; 0
    33c8:	12 e0       	ldi	r17, 0x02	; 2
    33ca:	20 e0       	ldi	r18, 0x00	; 0
    33cc:	30 e0       	ldi	r19, 0x00	; 0
    33ce:	08 1b       	sub	r16, r24
    33d0:	19 0b       	sbc	r17, r25
    33d2:	2a 0b       	sbc	r18, r26
    33d4:	3b 0b       	sbc	r19, r27
    33d6:	73 01       	movw	r14, r6
    33d8:	62 01       	movw	r12, r4
    33da:	04 15       	cp	r16, r4
    33dc:	15 05       	cpc	r17, r5
    33de:	26 05       	cpc	r18, r6
    33e0:	37 05       	cpc	r19, r7
    33e2:	10 f4       	brcc	.+4      	; 0x33e8 <f_read+0x3a0>
    33e4:	68 01       	movw	r12, r16
    33e6:	79 01       	movw	r14, r18
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    33e8:	ba 01       	movw	r22, r20
    33ea:	71 70       	andi	r23, 0x01	; 1
    33ec:	60 5e       	subi	r22, 0xE0	; 224
    33ee:	7f 4f       	sbci	r23, 0xFF	; 255
    33f0:	28 85       	ldd	r18, Y+8	; 0x08
    33f2:	39 85       	ldd	r19, Y+9	; 0x09
    33f4:	62 0f       	add	r22, r18
    33f6:	73 1f       	adc	r23, r19
    33f8:	89 81       	ldd	r24, Y+1	; 0x01
    33fa:	9a 81       	ldd	r25, Y+2	; 0x02
    33fc:	a7 01       	movw	r20, r14
    33fe:	96 01       	movw	r18, r12
    3400:	0e 94 d6 06 	call	0xdac	; 0xdac <mem_cpy>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    3404:	89 81       	ldd	r24, Y+1	; 0x01
    3406:	9a 81       	ldd	r25, Y+2	; 0x02
    3408:	8c 0d       	add	r24, r12
    340a:	9d 1d       	adc	r25, r13
    340c:	9a 83       	std	Y+2, r25	; 0x02
    340e:	89 83       	std	Y+1, r24	; 0x01
    3410:	e8 85       	ldd	r30, Y+8	; 0x08
    3412:	f9 85       	ldd	r31, Y+9	; 0x09
    3414:	86 81       	ldd	r24, Z+6	; 0x06
    3416:	97 81       	ldd	r25, Z+7	; 0x07
    3418:	a0 85       	ldd	r26, Z+8	; 0x08
    341a:	b1 85       	ldd	r27, Z+9	; 0x09
    341c:	8c 0d       	add	r24, r12
    341e:	9d 1d       	adc	r25, r13
    3420:	ae 1d       	adc	r26, r14
    3422:	bf 1d       	adc	r27, r15
    3424:	86 83       	std	Z+6, r24	; 0x06
    3426:	97 83       	std	Z+7, r25	; 0x07
    3428:	a0 87       	std	Z+8, r26	; 0x08
    342a:	b1 87       	std	Z+9, r27	; 0x09
    342c:	eb 81       	ldd	r30, Y+3	; 0x03
    342e:	fc 81       	ldd	r31, Y+4	; 0x04
    3430:	80 81       	ld	r24, Z
    3432:	91 81       	ldd	r25, Z+1	; 0x01
    3434:	a2 81       	ldd	r26, Z+2	; 0x02
    3436:	b3 81       	ldd	r27, Z+3	; 0x03
    3438:	8c 0d       	add	r24, r12
    343a:	9d 1d       	adc	r25, r13
    343c:	ae 1d       	adc	r26, r14
    343e:	bf 1d       	adc	r27, r15
    3440:	80 83       	st	Z, r24
    3442:	91 83       	std	Z+1, r25	; 0x01
    3444:	a2 83       	std	Z+2, r26	; 0x02
    3446:	b3 83       	std	Z+3, r27	; 0x03
    3448:	4c 18       	sub	r4, r12
    344a:	5d 08       	sbc	r5, r13
    344c:	6e 08       	sbc	r6, r14
    344e:	7f 08       	sbc	r7, r15
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    3450:	09 f0       	breq	.+2      	; 0x3454 <f_read+0x40c>
    3452:	5d ce       	rjmp	.-838    	; 0x310e <f_read+0xc6>
    3454:	bf 80       	ldd	r11, Y+7	; 0x07
    3456:	08 c0       	rjmp	.+16     	; 0x3468 <f_read+0x420>
	*br = 0;	/* Clear read byte counter */

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    3458:	bb 24       	eor	r11, r11
    345a:	68 94       	set
    345c:	b1 f8       	bld	r11, 1
    345e:	04 c0       	rjmp	.+8      	; 0x3468 <f_read+0x420>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    3460:	0f 2e       	mov	r0, r31
    3462:	f7 e0       	ldi	r31, 0x07	; 7
    3464:	bf 2e       	mov	r11, r31
    3466:	f0 2d       	mov	r31, r0
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    3468:	8b 2d       	mov	r24, r11
    346a:	29 96       	adiw	r28, 0x09	; 9
    346c:	0f b6       	in	r0, 0x3f	; 63
    346e:	f8 94       	cli
    3470:	de bf       	out	0x3e, r29	; 62
    3472:	0f be       	out	0x3f, r0	; 63
    3474:	cd bf       	out	0x3d, r28	; 61
    3476:	df 91       	pop	r29
    3478:	cf 91       	pop	r28
    347a:	1f 91       	pop	r17
    347c:	0f 91       	pop	r16
    347e:	ff 90       	pop	r15
    3480:	ef 90       	pop	r14
    3482:	df 90       	pop	r13
    3484:	cf 90       	pop	r12
    3486:	bf 90       	pop	r11
    3488:	af 90       	pop	r10
    348a:	9f 90       	pop	r9
    348c:	8f 90       	pop	r8
    348e:	7f 90       	pop	r7
    3490:	6f 90       	pop	r6
    3492:	5f 90       	pop	r5
    3494:	4f 90       	pop	r4
    3496:	3f 90       	pop	r3
    3498:	2f 90       	pop	r2
    349a:	08 95       	ret

0000349c <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
    349c:	2f 92       	push	r2
    349e:	3f 92       	push	r3
    34a0:	4f 92       	push	r4
    34a2:	5f 92       	push	r5
    34a4:	6f 92       	push	r6
    34a6:	7f 92       	push	r7
    34a8:	8f 92       	push	r8
    34aa:	9f 92       	push	r9
    34ac:	af 92       	push	r10
    34ae:	bf 92       	push	r11
    34b0:	cf 92       	push	r12
    34b2:	df 92       	push	r13
    34b4:	ef 92       	push	r14
    34b6:	ff 92       	push	r15
    34b8:	0f 93       	push	r16
    34ba:	1f 93       	push	r17
    34bc:	cf 93       	push	r28
    34be:	df 93       	push	r29
    34c0:	cd b7       	in	r28, 0x3d	; 61
    34c2:	de b7       	in	r29, 0x3e	; 62
    34c4:	29 97       	sbiw	r28, 0x09	; 9
    34c6:	0f b6       	in	r0, 0x3f	; 63
    34c8:	f8 94       	cli
    34ca:	de bf       	out	0x3e, r29	; 62
    34cc:	0f be       	out	0x3f, r0	; 63
    34ce:	cd bf       	out	0x3d, r28	; 61
    34d0:	2c 01       	movw	r4, r24
    34d2:	c6 2e       	mov	r12, r22
    34d4:	f7 2e       	mov	r15, r23
    34d6:	49 01       	movw	r8, r18
    34d8:	5a 01       	movw	r10, r20
    34da:	1a 83       	std	Y+2, r17	; 0x02
    34dc:	09 83       	std	Y+1, r16	; 0x01
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
    34de:	d8 01       	movw	r26, r16
    34e0:	1d 92       	st	X+, r1
    34e2:	1d 92       	st	X+, r1
    34e4:	1d 92       	st	X+, r1
    34e6:	1c 92       	st	X, r1
    34e8:	13 97       	sbiw	r26, 0x03	; 3

	res = validate(fp);						/* Check validity */
    34ea:	0e 94 bc 07 	call	0xf78	; 0xf78 <validate>
    34ee:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    34f0:	88 23       	and	r24, r24
    34f2:	09 f0       	breq	.+2      	; 0x34f6 <f_write+0x5a>
    34f4:	17 c2       	rjmp	.+1070   	; 0x3924 <f_write+0x488>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
    34f6:	f2 01       	movw	r30, r4
    34f8:	84 81       	ldd	r24, Z+4	; 0x04
    34fa:	88 23       	and	r24, r24
    34fc:	0c f4       	brge	.+2      	; 0x3500 <f_write+0x64>
    34fe:	0f c2       	rjmp	.+1054   	; 0x391e <f_write+0x482>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    3500:	81 ff       	sbrs	r24, 1
    3502:	0f c2       	rjmp	.+1054   	; 0x3922 <f_write+0x486>
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
    3504:	82 85       	ldd	r24, Z+10	; 0x0a
    3506:	93 85       	ldd	r25, Z+11	; 0x0b
    3508:	a4 85       	ldd	r26, Z+12	; 0x0c
    350a:	b5 85       	ldd	r27, Z+13	; 0x0d
    350c:	b5 01       	movw	r22, r10
    350e:	a4 01       	movw	r20, r8
    3510:	48 0f       	add	r20, r24
    3512:	59 1f       	adc	r21, r25
    3514:	6a 1f       	adc	r22, r26
    3516:	7b 1f       	adc	r23, r27
    3518:	48 17       	cp	r20, r24
    351a:	59 07       	cpc	r21, r25
    351c:	6a 07       	cpc	r22, r26
    351e:	7b 07       	cpc	r23, r27
    3520:	08 f4       	brcc	.+2      	; 0x3524 <f_write+0x88>
    3522:	e2 c1       	rjmp	.+964    	; 0x38e8 <f_write+0x44c>

	for ( ;  btw;							/* Repeat until all data written */
    3524:	81 14       	cp	r8, r1
    3526:	91 04       	cpc	r9, r1
    3528:	a1 04       	cpc	r10, r1
    352a:	b1 04       	cpc	r11, r1
    352c:	09 f4       	brne	.+2      	; 0x3530 <f_write+0x94>
    352e:	dc c1       	rjmp	.+952    	; 0x38e8 <f_write+0x44c>
    3530:	cb 82       	std	Y+3, r12	; 0x03
    3532:	fc 82       	std	Y+4, r15	; 0x04
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    3534:	92 01       	movw	r18, r4
    3536:	20 5e       	subi	r18, 0xE0	; 224
    3538:	3f 4f       	sbci	r19, 0xFF	; 255
    353a:	3e 83       	std	Y+6, r19	; 0x06
    353c:	2d 83       	std	Y+5, r18	; 0x05
    353e:	1f 83       	std	Y+7, r17	; 0x07
    3540:	59 86       	std	Y+9, r5	; 0x09
    3542:	48 86       	std	Y+8, r4	; 0x08
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    3544:	a8 85       	ldd	r26, Y+8	; 0x08
    3546:	b9 85       	ldd	r27, Y+9	; 0x09
    3548:	16 96       	adiw	r26, 0x06	; 6
    354a:	4d 91       	ld	r20, X+
    354c:	5d 91       	ld	r21, X+
    354e:	6d 91       	ld	r22, X+
    3550:	7c 91       	ld	r23, X
    3552:	19 97       	sbiw	r26, 0x09	; 9
    3554:	db 01       	movw	r26, r22
    3556:	ca 01       	movw	r24, r20
    3558:	91 70       	andi	r25, 0x01	; 1
    355a:	a0 70       	andi	r26, 0x00	; 0
    355c:	b0 70       	andi	r27, 0x00	; 0
    355e:	00 97       	sbiw	r24, 0x00	; 0
    3560:	a1 05       	cpc	r26, r1
    3562:	b1 05       	cpc	r27, r1
    3564:	09 f0       	breq	.+2      	; 0x3568 <f_write+0xcc>
    3566:	60 c1       	rjmp	.+704    	; 0x3828 <f_write+0x38c>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    3568:	e8 85       	ldd	r30, Y+8	; 0x08
    356a:	f9 85       	ldd	r31, Y+9	; 0x09
    356c:	20 81       	ld	r18, Z
    356e:	31 81       	ldd	r19, Z+1	; 0x01
    3570:	db 01       	movw	r26, r22
    3572:	ca 01       	movw	r24, r20
    3574:	07 2e       	mov	r0, r23
    3576:	79 e0       	ldi	r23, 0x09	; 9
    3578:	b6 95       	lsr	r27
    357a:	a7 95       	ror	r26
    357c:	97 95       	ror	r25
    357e:	87 95       	ror	r24
    3580:	7a 95       	dec	r23
    3582:	d1 f7       	brne	.-12     	; 0x3578 <f_write+0xdc>
    3584:	70 2d       	mov	r23, r0
    3586:	f9 01       	movw	r30, r18
    3588:	12 81       	ldd	r17, Z+2	; 0x02
    358a:	11 50       	subi	r17, 0x01	; 1
    358c:	18 23       	and	r17, r24
			if (!csect) {					/* On the cluster boundary? */
    358e:	09 f0       	breq	.+2      	; 0x3592 <f_write+0xf6>
    3590:	57 c0       	rjmp	.+174    	; 0x3640 <f_write+0x1a4>
				if (fp->fptr == 0) {		/* On the top of the file? */
    3592:	41 15       	cp	r20, r1
    3594:	51 05       	cpc	r21, r1
    3596:	61 05       	cpc	r22, r1
    3598:	71 05       	cpc	r23, r1
    359a:	c9 f4       	brne	.+50     	; 0x35ce <f_write+0x132>
					clst = fp->sclust;		/* Follow from the origin */
    359c:	e8 85       	ldd	r30, Y+8	; 0x08
    359e:	f9 85       	ldd	r31, Y+9	; 0x09
    35a0:	86 85       	ldd	r24, Z+14	; 0x0e
    35a2:	97 85       	ldd	r25, Z+15	; 0x0f
    35a4:	a0 89       	ldd	r26, Z+16	; 0x10
    35a6:	b1 89       	ldd	r27, Z+17	; 0x11
					if (clst == 0)			/* When no cluster is allocated, */
    35a8:	00 97       	sbiw	r24, 0x00	; 0
    35aa:	a1 05       	cpc	r26, r1
    35ac:	b1 05       	cpc	r27, r1
    35ae:	09 f5       	brne	.+66     	; 0x35f2 <f_write+0x156>
						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    35b0:	c9 01       	movw	r24, r18
    35b2:	40 e0       	ldi	r20, 0x00	; 0
    35b4:	50 e0       	ldi	r21, 0x00	; 0
    35b6:	ba 01       	movw	r22, r20
    35b8:	0e 94 3f 11 	call	0x227e	; 0x227e <create_chain>
    35bc:	dc 01       	movw	r26, r24
    35be:	cb 01       	movw	r24, r22
    35c0:	e8 85       	ldd	r30, Y+8	; 0x08
    35c2:	f9 85       	ldd	r31, Y+9	; 0x09
    35c4:	86 87       	std	Z+14, r24	; 0x0e
    35c6:	97 87       	std	Z+15, r25	; 0x0f
    35c8:	a0 8b       	std	Z+16, r26	; 0x10
    35ca:	b1 8b       	std	Z+17, r27	; 0x11
    35cc:	0d c0       	rjmp	.+26     	; 0x35e8 <f_write+0x14c>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    35ce:	a8 85       	ldd	r26, Y+8	; 0x08
    35d0:	b9 85       	ldd	r27, Y+9	; 0x09
    35d2:	52 96       	adiw	r26, 0x12	; 18
    35d4:	4d 91       	ld	r20, X+
    35d6:	5d 91       	ld	r21, X+
    35d8:	6d 91       	ld	r22, X+
    35da:	7c 91       	ld	r23, X
    35dc:	55 97       	sbiw	r26, 0x15	; 21
    35de:	c9 01       	movw	r24, r18
    35e0:	0e 94 3f 11 	call	0x227e	; 0x227e <create_chain>
    35e4:	dc 01       	movw	r26, r24
    35e6:	cb 01       	movw	r24, r22
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    35e8:	00 97       	sbiw	r24, 0x00	; 0
    35ea:	a1 05       	cpc	r26, r1
    35ec:	b1 05       	cpc	r27, r1
    35ee:	09 f4       	brne	.+2      	; 0x35f2 <f_write+0x156>
    35f0:	78 c1       	rjmp	.+752    	; 0x38e2 <f_write+0x446>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    35f2:	81 30       	cpi	r24, 0x01	; 1
    35f4:	91 05       	cpc	r25, r1
    35f6:	a1 05       	cpc	r26, r1
    35f8:	b1 05       	cpc	r27, r1
    35fa:	41 f4       	brne	.+16     	; 0x360c <f_write+0x170>
    35fc:	48 84       	ldd	r4, Y+8	; 0x08
    35fe:	59 84       	ldd	r5, Y+9	; 0x09
    3600:	f2 01       	movw	r30, r4
    3602:	84 81       	ldd	r24, Z+4	; 0x04
    3604:	80 68       	ori	r24, 0x80	; 128
    3606:	84 83       	std	Z+4, r24	; 0x04
    3608:	12 e0       	ldi	r17, 0x02	; 2
    360a:	8c c1       	rjmp	.+792    	; 0x3924 <f_write+0x488>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    360c:	8f 3f       	cpi	r24, 0xFF	; 255
    360e:	ff ef       	ldi	r31, 0xFF	; 255
    3610:	9f 07       	cpc	r25, r31
    3612:	ff ef       	ldi	r31, 0xFF	; 255
    3614:	af 07       	cpc	r26, r31
    3616:	ff ef       	ldi	r31, 0xFF	; 255
    3618:	bf 07       	cpc	r27, r31
    361a:	61 f4       	brne	.+24     	; 0x3634 <f_write+0x198>
    361c:	48 84       	ldd	r4, Y+8	; 0x08
    361e:	59 84       	ldd	r5, Y+9	; 0x09
    3620:	d2 01       	movw	r26, r4
    3622:	14 96       	adiw	r26, 0x04	; 4
    3624:	8c 91       	ld	r24, X
    3626:	14 97       	sbiw	r26, 0x04	; 4
    3628:	80 68       	ori	r24, 0x80	; 128
    362a:	14 96       	adiw	r26, 0x04	; 4
    362c:	8c 93       	st	X, r24
    362e:	14 97       	sbiw	r26, 0x04	; 4
    3630:	11 e0       	ldi	r17, 0x01	; 1
    3632:	78 c1       	rjmp	.+752    	; 0x3924 <f_write+0x488>
				fp->clust = clst;			/* Update current cluster */
    3634:	e8 85       	ldd	r30, Y+8	; 0x08
    3636:	f9 85       	ldd	r31, Y+9	; 0x09
    3638:	82 8b       	std	Z+18, r24	; 0x12
    363a:	93 8b       	std	Z+19, r25	; 0x13
    363c:	a4 8b       	std	Z+20, r26	; 0x14
    363e:	b5 8b       	std	Z+21, r27	; 0x15
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
    3640:	a8 85       	ldd	r26, Y+8	; 0x08
    3642:	b9 85       	ldd	r27, Y+9	; 0x09
    3644:	14 96       	adiw	r26, 0x04	; 4
    3646:	8c 91       	ld	r24, X
    3648:	14 97       	sbiw	r26, 0x04	; 4
    364a:	86 ff       	sbrs	r24, 6
    364c:	21 c0       	rjmp	.+66     	; 0x3690 <f_write+0x1f4>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    364e:	ed 91       	ld	r30, X+
    3650:	fc 91       	ld	r31, X
    3652:	11 97       	sbiw	r26, 0x01	; 1
    3654:	56 96       	adiw	r26, 0x16	; 22
    3656:	2d 91       	ld	r18, X+
    3658:	3d 91       	ld	r19, X+
    365a:	4d 91       	ld	r20, X+
    365c:	5c 91       	ld	r21, X
    365e:	59 97       	sbiw	r26, 0x19	; 25
    3660:	81 81       	ldd	r24, Z+1	; 0x01
    3662:	6d 81       	ldd	r22, Y+5	; 0x05
    3664:	7e 81       	ldd	r23, Y+6	; 0x06
    3666:	01 e0       	ldi	r16, 0x01	; 1
    3668:	0e 94 ed 02 	call	0x5da	; 0x5da <disk_write>
    366c:	88 23       	and	r24, r24
    366e:	41 f0       	breq	.+16     	; 0x3680 <f_write+0x1e4>
    3670:	48 84       	ldd	r4, Y+8	; 0x08
    3672:	59 84       	ldd	r5, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3674:	f2 01       	movw	r30, r4
    3676:	84 81       	ldd	r24, Z+4	; 0x04
    3678:	80 68       	ori	r24, 0x80	; 128
    367a:	84 83       	std	Z+4, r24	; 0x04
    367c:	11 e0       	ldi	r17, 0x01	; 1
    367e:	52 c1       	rjmp	.+676    	; 0x3924 <f_write+0x488>
				fp->flag &= ~FA__DIRTY;
    3680:	a8 85       	ldd	r26, Y+8	; 0x08
    3682:	b9 85       	ldd	r27, Y+9	; 0x09
    3684:	14 96       	adiw	r26, 0x04	; 4
    3686:	8c 91       	ld	r24, X
    3688:	14 97       	sbiw	r26, 0x04	; 4
    368a:	8f 7b       	andi	r24, 0xBF	; 191
    368c:	14 96       	adiw	r26, 0x04	; 4
    368e:	8c 93       	st	X, r24
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    3690:	e8 85       	ldd	r30, Y+8	; 0x08
    3692:	f9 85       	ldd	r31, Y+9	; 0x09
    3694:	20 80       	ld	r2, Z
    3696:	31 80       	ldd	r3, Z+1	; 0x01
    3698:	42 89       	ldd	r20, Z+18	; 0x12
    369a:	53 89       	ldd	r21, Z+19	; 0x13
    369c:	64 89       	ldd	r22, Z+20	; 0x14
    369e:	75 89       	ldd	r23, Z+21	; 0x15
    36a0:	c1 01       	movw	r24, r2
    36a2:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <clust2sect>
    36a6:	dc 01       	movw	r26, r24
    36a8:	cb 01       	movw	r24, r22
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    36aa:	00 97       	sbiw	r24, 0x00	; 0
    36ac:	a1 05       	cpc	r26, r1
    36ae:	b1 05       	cpc	r27, r1
    36b0:	61 f4       	brne	.+24     	; 0x36ca <f_write+0x22e>
    36b2:	48 84       	ldd	r4, Y+8	; 0x08
    36b4:	59 84       	ldd	r5, Y+9	; 0x09
    36b6:	d2 01       	movw	r26, r4
    36b8:	14 96       	adiw	r26, 0x04	; 4
    36ba:	8c 91       	ld	r24, X
    36bc:	14 97       	sbiw	r26, 0x04	; 4
    36be:	80 68       	ori	r24, 0x80	; 128
    36c0:	14 96       	adiw	r26, 0x04	; 4
    36c2:	8c 93       	st	X, r24
    36c4:	14 97       	sbiw	r26, 0x04	; 4
    36c6:	12 e0       	ldi	r17, 0x02	; 2
    36c8:	2d c1       	rjmp	.+602    	; 0x3924 <f_write+0x488>
			sect += csect;
    36ca:	41 2f       	mov	r20, r17
    36cc:	50 e0       	ldi	r21, 0x00	; 0
    36ce:	60 e0       	ldi	r22, 0x00	; 0
    36d0:	70 e0       	ldi	r23, 0x00	; 0
    36d2:	2c 01       	movw	r4, r24
    36d4:	3d 01       	movw	r6, r26
    36d6:	44 0e       	add	r4, r20
    36d8:	55 1e       	adc	r5, r21
    36da:	66 1e       	adc	r6, r22
    36dc:	77 1e       	adc	r7, r23
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    36de:	75 01       	movw	r14, r10
    36e0:	64 01       	movw	r12, r8
    36e2:	0b 2e       	mov	r0, r27
    36e4:	b9 e0       	ldi	r27, 0x09	; 9
    36e6:	f6 94       	lsr	r15
    36e8:	e7 94       	ror	r14
    36ea:	d7 94       	ror	r13
    36ec:	c7 94       	ror	r12
    36ee:	ba 95       	dec	r27
    36f0:	d1 f7       	brne	.-12     	; 0x36e6 <f_write+0x24a>
    36f2:	b0 2d       	mov	r27, r0
			if (cc) {						/* Write maximum contiguous sectors directly */
    36f4:	c1 14       	cp	r12, r1
    36f6:	d1 04       	cpc	r13, r1
    36f8:	e1 04       	cpc	r14, r1
    36fa:	f1 04       	cpc	r15, r1
    36fc:	09 f4       	brne	.+2      	; 0x3700 <f_write+0x264>
    36fe:	60 c0       	rjmp	.+192    	; 0x37c0 <f_write+0x324>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    3700:	f1 01       	movw	r30, r2
    3702:	22 81       	ldd	r18, Z+2	; 0x02
    3704:	d7 01       	movw	r26, r14
    3706:	c6 01       	movw	r24, r12
    3708:	84 0f       	add	r24, r20
    370a:	95 1f       	adc	r25, r21
    370c:	a6 1f       	adc	r26, r22
    370e:	b7 1f       	adc	r27, r23
    3710:	42 2f       	mov	r20, r18
    3712:	50 e0       	ldi	r21, 0x00	; 0
    3714:	60 e0       	ldi	r22, 0x00	; 0
    3716:	70 e0       	ldi	r23, 0x00	; 0
    3718:	48 17       	cp	r20, r24
    371a:	59 07       	cpc	r21, r25
    371c:	6a 07       	cpc	r22, r26
    371e:	7b 07       	cpc	r23, r27
    3720:	48 f4       	brcc	.+18     	; 0x3734 <f_write+0x298>
					cc = fp->fs->csize - csect;
    3722:	82 2f       	mov	r24, r18
    3724:	90 e0       	ldi	r25, 0x00	; 0
    3726:	81 1b       	sub	r24, r17
    3728:	91 09       	sbc	r25, r1
    372a:	6c 01       	movw	r12, r24
    372c:	ee 24       	eor	r14, r14
    372e:	d7 fc       	sbrc	r13, 7
    3730:	e0 94       	com	r14
    3732:	fe 2c       	mov	r15, r14
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
    3734:	d1 01       	movw	r26, r2
    3736:	11 96       	adiw	r26, 0x01	; 1
    3738:	8c 91       	ld	r24, X
    373a:	6b 81       	ldd	r22, Y+3	; 0x03
    373c:	7c 81       	ldd	r23, Y+4	; 0x04
    373e:	a3 01       	movw	r20, r6
    3740:	92 01       	movw	r18, r4
    3742:	0c 2d       	mov	r16, r12
    3744:	0e 94 ed 02 	call	0x5da	; 0x5da <disk_write>
    3748:	88 23       	and	r24, r24
    374a:	41 f0       	breq	.+16     	; 0x375c <f_write+0x2c0>
    374c:	48 84       	ldd	r4, Y+8	; 0x08
    374e:	59 84       	ldd	r5, Y+9	; 0x09
					ABORT(fp->fs, FR_DISK_ERR);
    3750:	f2 01       	movw	r30, r4
    3752:	84 81       	ldd	r24, Z+4	; 0x04
    3754:	80 68       	ori	r24, 0x80	; 128
    3756:	84 83       	std	Z+4, r24	; 0x04
    3758:	11 e0       	ldi	r17, 0x01	; 1
    375a:	e4 c0       	rjmp	.+456    	; 0x3924 <f_write+0x488>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
    375c:	e8 85       	ldd	r30, Y+8	; 0x08
    375e:	f9 85       	ldd	r31, Y+9	; 0x09
    3760:	86 89       	ldd	r24, Z+22	; 0x16
    3762:	97 89       	ldd	r25, Z+23	; 0x17
    3764:	a0 8d       	ldd	r26, Z+24	; 0x18
    3766:	b1 8d       	ldd	r27, Z+25	; 0x19
    3768:	84 19       	sub	r24, r4
    376a:	95 09       	sbc	r25, r5
    376c:	a6 09       	sbc	r26, r6
    376e:	b7 09       	sbc	r27, r7
    3770:	8c 15       	cp	r24, r12
    3772:	9d 05       	cpc	r25, r13
    3774:	ae 05       	cpc	r26, r14
    3776:	bf 05       	cpc	r27, r15
    3778:	c8 f4       	brcc	.+50     	; 0x37ac <f_write+0x310>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
    377a:	bc 01       	movw	r22, r24
    377c:	76 2f       	mov	r23, r22
    377e:	66 27       	eor	r22, r22
    3780:	77 0f       	add	r23, r23
    3782:	0b 81       	ldd	r16, Y+3	; 0x03
    3784:	1c 81       	ldd	r17, Y+4	; 0x04
    3786:	60 0f       	add	r22, r16
    3788:	71 1f       	adc	r23, r17
    378a:	8d 81       	ldd	r24, Y+5	; 0x05
    378c:	9e 81       	ldd	r25, Y+6	; 0x06
    378e:	20 e0       	ldi	r18, 0x00	; 0
    3790:	32 e0       	ldi	r19, 0x02	; 2
    3792:	40 e0       	ldi	r20, 0x00	; 0
    3794:	50 e0       	ldi	r21, 0x00	; 0
    3796:	0e 94 d6 06 	call	0xdac	; 0xdac <mem_cpy>
					fp->flag &= ~FA__DIRTY;
    379a:	a8 85       	ldd	r26, Y+8	; 0x08
    379c:	b9 85       	ldd	r27, Y+9	; 0x09
    379e:	14 96       	adiw	r26, 0x04	; 4
    37a0:	8c 91       	ld	r24, X
    37a2:	14 97       	sbiw	r26, 0x04	; 4
    37a4:	8f 7b       	andi	r24, 0xBF	; 191
    37a6:	14 96       	adiw	r26, 0x04	; 4
    37a8:	8c 93       	st	X, r24
    37aa:	14 97       	sbiw	r26, 0x04	; 4
				}
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    37ac:	0b 2e       	mov	r0, r27
    37ae:	b9 e0       	ldi	r27, 0x09	; 9
    37b0:	cc 0c       	add	r12, r12
    37b2:	dd 1c       	adc	r13, r13
    37b4:	ee 1c       	adc	r14, r14
    37b6:	ff 1c       	adc	r15, r15
    37b8:	ba 95       	dec	r27
    37ba:	d1 f7       	brne	.-12     	; 0x37b0 <f_write+0x314>
    37bc:	b0 2d       	mov	r27, r0
				continue;
    37be:	65 c0       	rjmp	.+202    	; 0x388a <f_write+0x3ee>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
    37c0:	e8 85       	ldd	r30, Y+8	; 0x08
    37c2:	f9 85       	ldd	r31, Y+9	; 0x09
    37c4:	86 89       	ldd	r24, Z+22	; 0x16
    37c6:	97 89       	ldd	r25, Z+23	; 0x17
    37c8:	a0 8d       	ldd	r26, Z+24	; 0x18
    37ca:	b1 8d       	ldd	r27, Z+25	; 0x19
    37cc:	84 15       	cp	r24, r4
    37ce:	95 05       	cpc	r25, r5
    37d0:	a6 05       	cpc	r26, r6
    37d2:	b7 05       	cpc	r27, r7
    37d4:	09 f1       	breq	.+66     	; 0x3818 <f_write+0x37c>
				if (fp->fptr < fp->fsize &&
    37d6:	86 81       	ldd	r24, Z+6	; 0x06
    37d8:	97 81       	ldd	r25, Z+7	; 0x07
    37da:	a0 85       	ldd	r26, Z+8	; 0x08
    37dc:	b1 85       	ldd	r27, Z+9	; 0x09
    37de:	42 85       	ldd	r20, Z+10	; 0x0a
    37e0:	53 85       	ldd	r21, Z+11	; 0x0b
    37e2:	64 85       	ldd	r22, Z+12	; 0x0c
    37e4:	75 85       	ldd	r23, Z+13	; 0x0d
    37e6:	84 17       	cp	r24, r20
    37e8:	95 07       	cpc	r25, r21
    37ea:	a6 07       	cpc	r26, r22
    37ec:	b7 07       	cpc	r27, r23
    37ee:	a0 f4       	brcc	.+40     	; 0x3818 <f_write+0x37c>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    37f0:	d1 01       	movw	r26, r2
    37f2:	11 96       	adiw	r26, 0x01	; 1
    37f4:	8c 91       	ld	r24, X
    37f6:	6d 81       	ldd	r22, Y+5	; 0x05
    37f8:	7e 81       	ldd	r23, Y+6	; 0x06
    37fa:	a3 01       	movw	r20, r6
    37fc:	92 01       	movw	r18, r4
    37fe:	01 e0       	ldi	r16, 0x01	; 1
    3800:	0e 94 93 02 	call	0x526	; 0x526 <disk_read>
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
    3804:	88 23       	and	r24, r24
    3806:	41 f0       	breq	.+16     	; 0x3818 <f_write+0x37c>
    3808:	48 84       	ldd	r4, Y+8	; 0x08
    380a:	59 84       	ldd	r5, Y+9	; 0x09
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
    380c:	f2 01       	movw	r30, r4
    380e:	84 81       	ldd	r24, Z+4	; 0x04
    3810:	80 68       	ori	r24, 0x80	; 128
    3812:	84 83       	std	Z+4, r24	; 0x04
    3814:	11 e0       	ldi	r17, 0x01	; 1
    3816:	86 c0       	rjmp	.+268    	; 0x3924 <f_write+0x488>
			}
#endif
			fp->dsect = sect;
    3818:	a8 85       	ldd	r26, Y+8	; 0x08
    381a:	b9 85       	ldd	r27, Y+9	; 0x09
    381c:	56 96       	adiw	r26, 0x16	; 22
    381e:	4d 92       	st	X+, r4
    3820:	5d 92       	st	X+, r5
    3822:	6d 92       	st	X+, r6
    3824:	7c 92       	st	X, r7
    3826:	59 97       	sbiw	r26, 0x19	; 25
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    3828:	e8 85       	ldd	r30, Y+8	; 0x08
    382a:	f9 85       	ldd	r31, Y+9	; 0x09
    382c:	46 81       	ldd	r20, Z+6	; 0x06
    382e:	57 81       	ldd	r21, Z+7	; 0x07
    3830:	60 85       	ldd	r22, Z+8	; 0x08
    3832:	71 85       	ldd	r23, Z+9	; 0x09
    3834:	db 01       	movw	r26, r22
    3836:	ca 01       	movw	r24, r20
    3838:	91 70       	andi	r25, 0x01	; 1
    383a:	a0 70       	andi	r26, 0x00	; 0
    383c:	b0 70       	andi	r27, 0x00	; 0
    383e:	00 e0       	ldi	r16, 0x00	; 0
    3840:	12 e0       	ldi	r17, 0x02	; 2
    3842:	20 e0       	ldi	r18, 0x00	; 0
    3844:	30 e0       	ldi	r19, 0x00	; 0
    3846:	08 1b       	sub	r16, r24
    3848:	19 0b       	sbc	r17, r25
    384a:	2a 0b       	sbc	r18, r26
    384c:	3b 0b       	sbc	r19, r27
    384e:	75 01       	movw	r14, r10
    3850:	64 01       	movw	r12, r8
    3852:	08 15       	cp	r16, r8
    3854:	19 05       	cpc	r17, r9
    3856:	2a 05       	cpc	r18, r10
    3858:	3b 05       	cpc	r19, r11
    385a:	10 f4       	brcc	.+4      	; 0x3860 <f_write+0x3c4>
    385c:	68 01       	movw	r12, r16
    385e:	79 01       	movw	r14, r18
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    3860:	ca 01       	movw	r24, r20
    3862:	91 70       	andi	r25, 0x01	; 1
    3864:	80 96       	adiw	r24, 0x20	; 32
    3866:	28 85       	ldd	r18, Y+8	; 0x08
    3868:	39 85       	ldd	r19, Y+9	; 0x09
    386a:	82 0f       	add	r24, r18
    386c:	93 1f       	adc	r25, r19
    386e:	6b 81       	ldd	r22, Y+3	; 0x03
    3870:	7c 81       	ldd	r23, Y+4	; 0x04
    3872:	a7 01       	movw	r20, r14
    3874:	96 01       	movw	r18, r12
    3876:	0e 94 d6 06 	call	0xdac	; 0xdac <mem_cpy>
		fp->flag |= FA__DIRTY;
    387a:	a8 85       	ldd	r26, Y+8	; 0x08
    387c:	b9 85       	ldd	r27, Y+9	; 0x09
    387e:	14 96       	adiw	r26, 0x04	; 4
    3880:	8c 91       	ld	r24, X
    3882:	14 97       	sbiw	r26, 0x04	; 4
    3884:	80 64       	ori	r24, 0x40	; 64
    3886:	14 96       	adiw	r26, 0x04	; 4
    3888:	8c 93       	st	X, r24
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    388a:	eb 81       	ldd	r30, Y+3	; 0x03
    388c:	fc 81       	ldd	r31, Y+4	; 0x04
    388e:	ec 0d       	add	r30, r12
    3890:	fd 1d       	adc	r31, r13
    3892:	fc 83       	std	Y+4, r31	; 0x04
    3894:	eb 83       	std	Y+3, r30	; 0x03
    3896:	e8 85       	ldd	r30, Y+8	; 0x08
    3898:	f9 85       	ldd	r31, Y+9	; 0x09
    389a:	86 81       	ldd	r24, Z+6	; 0x06
    389c:	97 81       	ldd	r25, Z+7	; 0x07
    389e:	a0 85       	ldd	r26, Z+8	; 0x08
    38a0:	b1 85       	ldd	r27, Z+9	; 0x09
    38a2:	8c 0d       	add	r24, r12
    38a4:	9d 1d       	adc	r25, r13
    38a6:	ae 1d       	adc	r26, r14
    38a8:	bf 1d       	adc	r27, r15
    38aa:	86 83       	std	Z+6, r24	; 0x06
    38ac:	97 83       	std	Z+7, r25	; 0x07
    38ae:	a0 87       	std	Z+8, r26	; 0x08
    38b0:	b1 87       	std	Z+9, r27	; 0x09
    38b2:	e9 81       	ldd	r30, Y+1	; 0x01
    38b4:	fa 81       	ldd	r31, Y+2	; 0x02
    38b6:	80 81       	ld	r24, Z
    38b8:	91 81       	ldd	r25, Z+1	; 0x01
    38ba:	a2 81       	ldd	r26, Z+2	; 0x02
    38bc:	b3 81       	ldd	r27, Z+3	; 0x03
    38be:	8c 0d       	add	r24, r12
    38c0:	9d 1d       	adc	r25, r13
    38c2:	ae 1d       	adc	r26, r14
    38c4:	bf 1d       	adc	r27, r15
    38c6:	80 83       	st	Z, r24
    38c8:	91 83       	std	Z+1, r25	; 0x01
    38ca:	a2 83       	std	Z+2, r26	; 0x02
    38cc:	b3 83       	std	Z+3, r27	; 0x03
    38ce:	8c 18       	sub	r8, r12
    38d0:	9d 08       	sbc	r9, r13
    38d2:	ae 08       	sbc	r10, r14
    38d4:	bf 08       	sbc	r11, r15
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
    38d6:	09 f0       	breq	.+2      	; 0x38da <f_write+0x43e>
    38d8:	35 ce       	rjmp	.-918    	; 0x3544 <f_write+0xa8>
    38da:	1f 81       	ldd	r17, Y+7	; 0x07
    38dc:	48 84       	ldd	r4, Y+8	; 0x08
    38de:	59 84       	ldd	r5, Y+9	; 0x09
    38e0:	03 c0       	rjmp	.+6      	; 0x38e8 <f_write+0x44c>
    38e2:	1f 81       	ldd	r17, Y+7	; 0x07
    38e4:	48 84       	ldd	r4, Y+8	; 0x08
    38e6:	59 84       	ldd	r5, Y+9	; 0x09
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    38e8:	f2 01       	movw	r30, r4
    38ea:	86 81       	ldd	r24, Z+6	; 0x06
    38ec:	97 81       	ldd	r25, Z+7	; 0x07
    38ee:	a0 85       	ldd	r26, Z+8	; 0x08
    38f0:	b1 85       	ldd	r27, Z+9	; 0x09
    38f2:	42 85       	ldd	r20, Z+10	; 0x0a
    38f4:	53 85       	ldd	r21, Z+11	; 0x0b
    38f6:	64 85       	ldd	r22, Z+12	; 0x0c
    38f8:	75 85       	ldd	r23, Z+13	; 0x0d
    38fa:	48 17       	cp	r20, r24
    38fc:	59 07       	cpc	r21, r25
    38fe:	6a 07       	cpc	r22, r26
    3900:	7b 07       	cpc	r23, r27
    3902:	20 f4       	brcc	.+8      	; 0x390c <f_write+0x470>
    3904:	82 87       	std	Z+10, r24	; 0x0a
    3906:	93 87       	std	Z+11, r25	; 0x0b
    3908:	a4 87       	std	Z+12, r26	; 0x0c
    390a:	b5 87       	std	Z+13, r27	; 0x0d
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    390c:	d2 01       	movw	r26, r4
    390e:	14 96       	adiw	r26, 0x04	; 4
    3910:	8c 91       	ld	r24, X
    3912:	14 97       	sbiw	r26, 0x04	; 4
    3914:	80 62       	ori	r24, 0x20	; 32
    3916:	14 96       	adiw	r26, 0x04	; 4
    3918:	8c 93       	st	X, r24
    391a:	14 97       	sbiw	r26, 0x04	; 4

	LEAVE_FF(fp->fs, FR_OK);
    391c:	03 c0       	rjmp	.+6      	; 0x3924 <f_write+0x488>
	*bw = 0;	/* Clear write byte counter */

	res = validate(fp);						/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)				/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    391e:	12 e0       	ldi	r17, 0x02	; 2
    3920:	01 c0       	rjmp	.+2      	; 0x3924 <f_write+0x488>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    3922:	17 e0       	ldi	r17, 0x07	; 7

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
    3924:	81 2f       	mov	r24, r17
    3926:	29 96       	adiw	r28, 0x09	; 9
    3928:	0f b6       	in	r0, 0x3f	; 63
    392a:	f8 94       	cli
    392c:	de bf       	out	0x3e, r29	; 62
    392e:	0f be       	out	0x3f, r0	; 63
    3930:	cd bf       	out	0x3d, r28	; 61
    3932:	df 91       	pop	r29
    3934:	cf 91       	pop	r28
    3936:	1f 91       	pop	r17
    3938:	0f 91       	pop	r16
    393a:	ff 90       	pop	r15
    393c:	ef 90       	pop	r14
    393e:	df 90       	pop	r13
    3940:	cf 90       	pop	r12
    3942:	bf 90       	pop	r11
    3944:	af 90       	pop	r10
    3946:	9f 90       	pop	r9
    3948:	8f 90       	pop	r8
    394a:	7f 90       	pop	r7
    394c:	6f 90       	pop	r6
    394e:	5f 90       	pop	r5
    3950:	4f 90       	pop	r4
    3952:	3f 90       	pop	r3
    3954:	2f 90       	pop	r2
    3956:	08 95       	ret

00003958 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
    3958:	0f 93       	push	r16
    395a:	1f 93       	push	r17
    395c:	cf 93       	push	r28
    395e:	df 93       	push	r29
    3960:	ec 01       	movw	r28, r24
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
    3962:	0e 94 bc 07 	call	0xf78	; 0xf78 <validate>
	if (res == FR_OK) {
    3966:	88 23       	and	r24, r24
    3968:	09 f0       	breq	.+2      	; 0x396c <f_sync+0x14>
    396a:	4c c0       	rjmp	.+152    	; 0x3a04 <f_sync+0xac>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    396c:	9c 81       	ldd	r25, Y+4	; 0x04
    396e:	95 ff       	sbrs	r25, 5
    3970:	49 c0       	rjmp	.+146    	; 0x3a04 <f_sync+0xac>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
    3972:	96 ff       	sbrs	r25, 6
    3974:	12 c0       	rjmp	.+36     	; 0x399a <f_sync+0x42>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3976:	e8 81       	ld	r30, Y
    3978:	f9 81       	ldd	r31, Y+1	; 0x01
    397a:	be 01       	movw	r22, r28
    397c:	60 5e       	subi	r22, 0xE0	; 224
    397e:	7f 4f       	sbci	r23, 0xFF	; 255
    3980:	2e 89       	ldd	r18, Y+22	; 0x16
    3982:	3f 89       	ldd	r19, Y+23	; 0x17
    3984:	48 8d       	ldd	r20, Y+24	; 0x18
    3986:	59 8d       	ldd	r21, Y+25	; 0x19
    3988:	81 81       	ldd	r24, Z+1	; 0x01
    398a:	01 e0       	ldi	r16, 0x01	; 1
    398c:	0e 94 ed 02 	call	0x5da	; 0x5da <disk_write>
    3990:	88 23       	and	r24, r24
    3992:	b9 f5       	brne	.+110    	; 0x3a02 <f_sync+0xaa>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
    3994:	8c 81       	ldd	r24, Y+4	; 0x04
    3996:	8f 7b       	andi	r24, 0xBF	; 191
    3998:	8c 83       	std	Y+4, r24	; 0x04
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
    399a:	4a 8d       	ldd	r20, Y+26	; 0x1a
    399c:	5b 8d       	ldd	r21, Y+27	; 0x1b
    399e:	6c 8d       	ldd	r22, Y+28	; 0x1c
    39a0:	7d 8d       	ldd	r23, Y+29	; 0x1d
    39a2:	88 81       	ld	r24, Y
    39a4:	99 81       	ldd	r25, Y+1	; 0x01
    39a6:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
			if (res == FR_OK) {
    39aa:	88 23       	and	r24, r24
    39ac:	59 f5       	brne	.+86     	; 0x3a04 <f_sync+0xac>
				dir = fp->dir_ptr;
    39ae:	0e 8d       	ldd	r16, Y+30	; 0x1e
    39b0:	1f 8d       	ldd	r17, Y+31	; 0x1f
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    39b2:	f8 01       	movw	r30, r16
    39b4:	83 85       	ldd	r24, Z+11	; 0x0b
    39b6:	80 62       	ori	r24, 0x20	; 32
    39b8:	83 87       	std	Z+11, r24	; 0x0b
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    39ba:	8a 85       	ldd	r24, Y+10	; 0x0a
    39bc:	84 8f       	std	Z+28, r24	; 0x1c
    39be:	8b 85       	ldd	r24, Y+11	; 0x0b
    39c0:	85 8f       	std	Z+29, r24	; 0x1d
    39c2:	8c 85       	ldd	r24, Y+12	; 0x0c
    39c4:	86 8f       	std	Z+30, r24	; 0x1e
    39c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    39c8:	87 8f       	std	Z+31, r24	; 0x1f
				st_clust(dir, fp->sclust);					/* Update start cluster */
    39ca:	4e 85       	ldd	r20, Y+14	; 0x0e
    39cc:	5f 85       	ldd	r21, Y+15	; 0x0f
    39ce:	68 89       	ldd	r22, Y+16	; 0x10
    39d0:	79 89       	ldd	r23, Y+17	; 0x11
    39d2:	c8 01       	movw	r24, r16
    39d4:	0e 94 21 07 	call	0xe42	; 0xe42 <st_clust>
				tim = get_fattime();						/* Update updated time */
    39d8:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <get_fattime>
				ST_DWORD(dir+DIR_WrtTime, tim);
    39dc:	f8 01       	movw	r30, r16
    39de:	66 8b       	std	Z+22, r22	; 0x16
    39e0:	77 8b       	std	Z+23, r23	; 0x17
    39e2:	80 8f       	std	Z+24, r24	; 0x18
    39e4:	91 8f       	std	Z+25, r25	; 0x19
				ST_WORD(dir+DIR_LstAccDate, 0);
    39e6:	12 8a       	std	Z+18, r1	; 0x12
    39e8:	13 8a       	std	Z+19, r1	; 0x13
				fp->flag &= ~FA__WRITTEN;
    39ea:	8c 81       	ldd	r24, Y+4	; 0x04
    39ec:	8f 7d       	andi	r24, 0xDF	; 223
    39ee:	8c 83       	std	Y+4, r24	; 0x04
				fp->fs->wflag = 1;
    39f0:	e8 81       	ld	r30, Y
    39f2:	f9 81       	ldd	r31, Y+1	; 0x01
    39f4:	81 e0       	ldi	r24, 0x01	; 1
    39f6:	84 83       	std	Z+4, r24	; 0x04
				res = sync(fp->fs);
    39f8:	88 81       	ld	r24, Y
    39fa:	99 81       	ldd	r25, Y+1	; 0x01
    39fc:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <sync>
    3a00:	01 c0       	rjmp	.+2      	; 0x3a04 <f_sync+0xac>
	if (res == FR_OK) {
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
    3a02:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
    3a04:	df 91       	pop	r29
    3a06:	cf 91       	pop	r28
    3a08:	1f 91       	pop	r17
    3a0a:	0f 91       	pop	r16
    3a0c:	08 95       	ret

00003a0e <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    3a0e:	cf 93       	push	r28
    3a10:	df 93       	push	r29
    3a12:	ec 01       	movw	r28, r24
#endif
		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
		LEAVE_FF(fs, res);
	}
#else
	res = f_sync(fp);		/* Flush cached data */
    3a14:	0e 94 ac 1c 	call	0x3958	; 0x3958 <f_sync>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    3a18:	88 23       	and	r24, r24
    3a1a:	11 f4       	brne	.+4      	; 0x3a20 <f_close+0x12>
    3a1c:	19 82       	std	Y+1, r1	; 0x01
    3a1e:	18 82       	st	Y, r1
	return res;
#endif
}
    3a20:	df 91       	pop	r29
    3a22:	cf 91       	pop	r28
    3a24:	08 95       	ret

00003a26 <f_chdrive>:

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
    3a26:	88 23       	and	r24, r24
    3a28:	19 f4       	brne	.+6      	; 0x3a30 <f_chdrive+0xa>

	CurrVol = drv;
    3a2a:	10 92 89 04 	sts	0x0489, r1

	return FR_OK;
    3a2e:	08 95       	ret

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
    3a30:	8b e0       	ldi	r24, 0x0B	; 11

	CurrVol = drv;

	return FR_OK;
}
    3a32:	08 95       	ret

00003a34 <f_chdir>:


FRESULT f_chdir (
	const TCHAR *path	/* Pointer to the directory path */
)
{
    3a34:	ef 92       	push	r14
    3a36:	ff 92       	push	r15
    3a38:	1f 93       	push	r17
    3a3a:	cf 93       	push	r28
    3a3c:	df 93       	push	r29
    3a3e:	cd b7       	in	r28, 0x3d	; 61
    3a40:	de b7       	in	r29, 0x3e	; 62
    3a42:	a4 97       	sbiw	r28, 0x24	; 36
    3a44:	0f b6       	in	r0, 0x3f	; 63
    3a46:	f8 94       	cli
    3a48:	de bf       	out	0x3e, r29	; 62
    3a4a:	0f be       	out	0x3f, r0	; 63
    3a4c:	cd bf       	out	0x3d, r28	; 61
    3a4e:	9c a3       	lds	r25, 0x5c
    3a50:	8b a3       	lds	r24, 0x5b
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
    3a52:	ce 01       	movw	r24, r28
    3a54:	83 96       	adiw	r24, 0x23	; 35
    3a56:	be 01       	movw	r22, r28
    3a58:	6f 5f       	subi	r22, 0xFF	; 255
    3a5a:	7f 4f       	sbci	r23, 0xFF	; 255
    3a5c:	40 e0       	ldi	r20, 0x00	; 0
    3a5e:	0e 94 79 08 	call	0x10f2	; 0x10f2 <chk_mounted>
    3a62:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    3a64:	88 23       	and	r24, r24
    3a66:	81 f5       	brne	.+96     	; 0x3ac8 <f_chdir+0x94>
		INIT_BUF(dj);
    3a68:	ce 01       	movw	r24, r28
    3a6a:	47 96       	adiw	r24, 0x17	; 23
    3a6c:	9e 8b       	std	Y+22, r25	; 0x16
    3a6e:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the path */
    3a70:	6b a1       	lds	r22, 0x4b
    3a72:	7c a1       	lds	r23, 0x4c
    3a74:	ce 01       	movw	r24, r28
    3a76:	01 96       	adiw	r24, 0x01	; 1
    3a78:	0e 94 a8 13 	call	0x2750	; 0x2750 <follow_path>
    3a7c:	18 2f       	mov	r17, r24
		FREE_BUF();
		if (res == FR_OK) {					/* Follow completed */
    3a7e:	88 23       	and	r24, r24
    3a80:	01 f5       	brne	.+64     	; 0x3ac2 <f_chdir+0x8e>
			if (!dj.dir) {
    3a82:	eb 89       	ldd	r30, Y+19	; 0x13
    3a84:	fc 89       	ldd	r31, Y+20	; 0x14
    3a86:	30 97       	sbiw	r30, 0x00	; 0
    3a88:	59 f4       	brne	.+22     	; 0x3aa0 <f_chdir+0x6c>
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
    3a8a:	e9 81       	ldd	r30, Y+1	; 0x01
    3a8c:	fa 81       	ldd	r31, Y+2	; 0x02
    3a8e:	8f 81       	ldd	r24, Y+7	; 0x07
    3a90:	98 85       	ldd	r25, Y+8	; 0x08
    3a92:	a9 85       	ldd	r26, Y+9	; 0x09
    3a94:	ba 85       	ldd	r27, Y+10	; 0x0a
    3a96:	86 8b       	std	Z+22, r24	; 0x16
    3a98:	97 8b       	std	Z+23, r25	; 0x17
    3a9a:	a0 8f       	std	Z+24, r26	; 0x18
    3a9c:	b1 8f       	std	Z+25, r27	; 0x19
    3a9e:	14 c0       	rjmp	.+40     	; 0x3ac8 <f_chdir+0x94>
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
    3aa0:	83 85       	ldd	r24, Z+11	; 0x0b
    3aa2:	84 ff       	sbrs	r24, 4
    3aa4:	1e c0       	rjmp	.+60     	; 0x3ae2 <f_chdir+0xae>
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
    3aa6:	e9 80       	ldd	r14, Y+1	; 0x01
    3aa8:	fa 80       	ldd	r15, Y+2	; 0x02
    3aaa:	c7 01       	movw	r24, r14
    3aac:	bf 01       	movw	r22, r30
    3aae:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <ld_clust>
    3ab2:	dc 01       	movw	r26, r24
    3ab4:	cb 01       	movw	r24, r22
    3ab6:	f7 01       	movw	r30, r14
    3ab8:	86 8b       	std	Z+22, r24	; 0x16
    3aba:	97 8b       	std	Z+23, r25	; 0x17
    3abc:	a0 8f       	std	Z+24, r26	; 0x18
    3abe:	b1 8f       	std	Z+25, r27	; 0x19
    3ac0:	03 c0       	rjmp	.+6      	; 0x3ac8 <f_chdir+0x94>
				else
					res = FR_NO_PATH;		/* Reached but a file */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    3ac2:	84 30       	cpi	r24, 0x04	; 4
    3ac4:	09 f4       	brne	.+2      	; 0x3ac8 <f_chdir+0x94>
    3ac6:	15 e0       	ldi	r17, 0x05	; 5
	}

	LEAVE_FF(dj.fs, res);
}
    3ac8:	81 2f       	mov	r24, r17
    3aca:	a4 96       	adiw	r28, 0x24	; 36
    3acc:	0f b6       	in	r0, 0x3f	; 63
    3ace:	f8 94       	cli
    3ad0:	de bf       	out	0x3e, r29	; 62
    3ad2:	0f be       	out	0x3f, r0	; 63
    3ad4:	cd bf       	out	0x3d, r28	; 61
    3ad6:	df 91       	pop	r29
    3ad8:	cf 91       	pop	r28
    3ada:	1f 91       	pop	r17
    3adc:	ff 90       	pop	r15
    3ade:	ef 90       	pop	r14
    3ae0:	08 95       	ret
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
				else
					res = FR_NO_PATH;		/* Reached but a file */
    3ae2:	15 e0       	ldi	r17, 0x05	; 5
    3ae4:	f1 cf       	rjmp	.-30     	; 0x3ac8 <f_chdir+0x94>

00003ae6 <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
    3ae6:	2f 92       	push	r2
    3ae8:	3f 92       	push	r3
    3aea:	4f 92       	push	r4
    3aec:	5f 92       	push	r5
    3aee:	6f 92       	push	r6
    3af0:	7f 92       	push	r7
    3af2:	8f 92       	push	r8
    3af4:	9f 92       	push	r9
    3af6:	af 92       	push	r10
    3af8:	bf 92       	push	r11
    3afa:	cf 92       	push	r12
    3afc:	df 92       	push	r13
    3afe:	ef 92       	push	r14
    3b00:	ff 92       	push	r15
    3b02:	0f 93       	push	r16
    3b04:	1f 93       	push	r17
    3b06:	cf 93       	push	r28
    3b08:	df 93       	push	r29
    3b0a:	00 d0       	rcall	.+0      	; 0x3b0c <f_lseek+0x26>
    3b0c:	00 d0       	rcall	.+0      	; 0x3b0e <f_lseek+0x28>
    3b0e:	00 d0       	rcall	.+0      	; 0x3b10 <f_lseek+0x2a>
    3b10:	cd b7       	in	r28, 0x3d	; 61
    3b12:	de b7       	in	r29, 0x3e	; 62
    3b14:	9e 83       	std	Y+6, r25	; 0x06
    3b16:	8d 83       	std	Y+5, r24	; 0x05
    3b18:	6a 01       	movw	r12, r20
    3b1a:	7b 01       	movw	r14, r22
	FRESULT res;


	res = validate(fp);					/* Check validity of the object */
    3b1c:	0e 94 bc 07 	call	0xf78	; 0xf78 <validate>
    3b20:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3b22:	88 23       	and	r24, r24
    3b24:	09 f0       	breq	.+2      	; 0x3b28 <f_lseek+0x42>
    3b26:	e6 c1       	rjmp	.+972    	; 0x3ef4 <f_lseek+0x40e>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
    3b28:	ad 81       	ldd	r26, Y+5	; 0x05
    3b2a:	be 81       	ldd	r27, Y+6	; 0x06
    3b2c:	14 96       	adiw	r26, 0x04	; 4
    3b2e:	2c 91       	ld	r18, X
    3b30:	14 97       	sbiw	r26, 0x04	; 4
    3b32:	22 23       	and	r18, r18
    3b34:	0c f4       	brge	.+2      	; 0x3b38 <f_lseek+0x52>
    3b36:	dd c1       	rjmp	.+954    	; 0x3ef2 <f_lseek+0x40c>

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    3b38:	1a 96       	adiw	r26, 0x0a	; 10
    3b3a:	8d 91       	ld	r24, X+
    3b3c:	9d 91       	ld	r25, X+
    3b3e:	0d 90       	ld	r0, X+
    3b40:	bc 91       	ld	r27, X
    3b42:	a0 2d       	mov	r26, r0
    3b44:	8c 15       	cp	r24, r12
    3b46:	9d 05       	cpc	r25, r13
    3b48:	ae 05       	cpc	r26, r14
    3b4a:	bf 05       	cpc	r27, r15
    3b4c:	20 f4       	brcc	.+8      	; 0x3b56 <f_lseek+0x70>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
    3b4e:	21 fd       	sbrc	r18, 1
    3b50:	02 c0       	rjmp	.+4      	; 0x3b56 <f_lseek+0x70>
#endif
			) ofs = fp->fsize;
    3b52:	6c 01       	movw	r12, r24
    3b54:	7d 01       	movw	r14, r26

		ifptr = fp->fptr;
    3b56:	ed 81       	ldd	r30, Y+5	; 0x05
    3b58:	fe 81       	ldd	r31, Y+6	; 0x06
    3b5a:	46 81       	ldd	r20, Z+6	; 0x06
    3b5c:	57 81       	ldd	r21, Z+7	; 0x07
    3b5e:	60 85       	ldd	r22, Z+8	; 0x08
    3b60:	71 85       	ldd	r23, Z+9	; 0x09
		fp->fptr = nsect = 0;
    3b62:	16 82       	std	Z+6, r1	; 0x06
    3b64:	17 82       	std	Z+7, r1	; 0x07
    3b66:	10 86       	std	Z+8, r1	; 0x08
    3b68:	11 86       	std	Z+9, r1	; 0x09
		if (ofs) {
    3b6a:	c1 14       	cp	r12, r1
    3b6c:	d1 04       	cpc	r13, r1
    3b6e:	e1 04       	cpc	r14, r1
    3b70:	f1 04       	cpc	r15, r1
    3b72:	09 f4       	brne	.+2      	; 0x3b76 <f_lseek+0x90>
    3b74:	bf c1       	rjmp	.+894    	; 0x3ef4 <f_lseek+0x40e>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    3b76:	20 80       	ld	r2, Z
    3b78:	31 80       	ldd	r3, Z+1	; 0x01
    3b7a:	f1 01       	movw	r30, r2
    3b7c:	82 81       	ldd	r24, Z+2	; 0x02
    3b7e:	90 e0       	ldi	r25, 0x00	; 0
    3b80:	a0 e0       	ldi	r26, 0x00	; 0
    3b82:	b0 e0       	ldi	r27, 0x00	; 0
    3b84:	4c 01       	movw	r8, r24
    3b86:	5d 01       	movw	r10, r26
    3b88:	07 2e       	mov	r0, r23
    3b8a:	79 e0       	ldi	r23, 0x09	; 9
    3b8c:	88 0c       	add	r8, r8
    3b8e:	99 1c       	adc	r9, r9
    3b90:	aa 1c       	adc	r10, r10
    3b92:	bb 1c       	adc	r11, r11
    3b94:	7a 95       	dec	r23
    3b96:	d1 f7       	brne	.-12     	; 0x3b8c <f_lseek+0xa6>
    3b98:	70 2d       	mov	r23, r0
			if (ifptr > 0 &&
    3b9a:	41 15       	cp	r20, r1
    3b9c:	51 05       	cpc	r21, r1
    3b9e:	61 05       	cpc	r22, r1
    3ba0:	71 05       	cpc	r23, r1
    3ba2:	f1 f1       	breq	.+124    	; 0x3c20 <f_lseek+0x13a>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
    3ba4:	2a 01       	movw	r4, r20
    3ba6:	3b 01       	movw	r6, r22
    3ba8:	08 94       	sec
    3baa:	41 08       	sbc	r4, r1
    3bac:	51 08       	sbc	r5, r1
    3bae:	61 08       	sbc	r6, r1
    3bb0:	71 08       	sbc	r7, r1
    3bb2:	c7 01       	movw	r24, r14
    3bb4:	b6 01       	movw	r22, r12
    3bb6:	61 50       	subi	r22, 0x01	; 1
    3bb8:	70 40       	sbci	r23, 0x00	; 0
    3bba:	80 40       	sbci	r24, 0x00	; 0
    3bbc:	90 40       	sbci	r25, 0x00	; 0
    3bbe:	a5 01       	movw	r20, r10
    3bc0:	94 01       	movw	r18, r8
    3bc2:	0e 94 52 29 	call	0x52a4	; 0x52a4 <__udivmodsi4>
    3bc6:	29 83       	std	Y+1, r18	; 0x01
    3bc8:	3a 83       	std	Y+2, r19	; 0x02
    3bca:	4b 83       	std	Y+3, r20	; 0x03
    3bcc:	5c 83       	std	Y+4, r21	; 0x04
    3bce:	c3 01       	movw	r24, r6
    3bd0:	b2 01       	movw	r22, r4
    3bd2:	a5 01       	movw	r20, r10
    3bd4:	94 01       	movw	r18, r8
    3bd6:	0e 94 52 29 	call	0x52a4	; 0x52a4 <__udivmodsi4>

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
    3bda:	89 81       	ldd	r24, Y+1	; 0x01
    3bdc:	9a 81       	ldd	r25, Y+2	; 0x02
    3bde:	ab 81       	ldd	r26, Y+3	; 0x03
    3be0:	bc 81       	ldd	r27, Y+4	; 0x04
    3be2:	82 17       	cp	r24, r18
    3be4:	93 07       	cpc	r25, r19
    3be6:	a4 07       	cpc	r26, r20
    3be8:	b5 07       	cpc	r27, r21
    3bea:	d0 f0       	brcs	.+52     	; 0x3c20 <f_lseek+0x13a>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    3bec:	88 27       	eor	r24, r24
    3bee:	99 27       	eor	r25, r25
    3bf0:	dc 01       	movw	r26, r24
    3bf2:	88 19       	sub	r24, r8
    3bf4:	99 09       	sbc	r25, r9
    3bf6:	aa 09       	sbc	r26, r10
    3bf8:	bb 09       	sbc	r27, r11
    3bfa:	84 21       	and	r24, r4
    3bfc:	95 21       	and	r25, r5
    3bfe:	a6 21       	and	r26, r6
    3c00:	b7 21       	and	r27, r7
    3c02:	ed 81       	ldd	r30, Y+5	; 0x05
    3c04:	fe 81       	ldd	r31, Y+6	; 0x06
    3c06:	86 83       	std	Z+6, r24	; 0x06
    3c08:	97 83       	std	Z+7, r25	; 0x07
    3c0a:	a0 87       	std	Z+8, r26	; 0x08
    3c0c:	b1 87       	std	Z+9, r27	; 0x09
				ofs -= fp->fptr;
    3c0e:	c8 1a       	sub	r12, r24
    3c10:	d9 0a       	sbc	r13, r25
    3c12:	ea 0a       	sbc	r14, r26
    3c14:	fb 0a       	sbc	r15, r27
				clst = fp->clust;
    3c16:	42 89       	ldd	r20, Z+18	; 0x12
    3c18:	53 89       	ldd	r21, Z+19	; 0x13
    3c1a:	64 89       	ldd	r22, Z+20	; 0x14
    3c1c:	75 89       	ldd	r23, Z+21	; 0x15
    3c1e:	42 c0       	rjmp	.+132    	; 0x3ca4 <f_lseek+0x1be>
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
    3c20:	ad 81       	ldd	r26, Y+5	; 0x05
    3c22:	be 81       	ldd	r27, Y+6	; 0x06
    3c24:	1e 96       	adiw	r26, 0x0e	; 14
    3c26:	4d 91       	ld	r20, X+
    3c28:	5d 91       	ld	r21, X+
    3c2a:	6d 91       	ld	r22, X+
    3c2c:	7c 91       	ld	r23, X
    3c2e:	51 97       	sbiw	r26, 0x11	; 17
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
    3c30:	41 15       	cp	r20, r1
    3c32:	51 05       	cpc	r21, r1
    3c34:	61 05       	cpc	r22, r1
    3c36:	71 05       	cpc	r23, r1
    3c38:	69 f5       	brne	.+90     	; 0x3c94 <f_lseek+0x1ae>
					clst = create_chain(fp->fs, 0);
    3c3a:	c1 01       	movw	r24, r2
    3c3c:	40 e0       	ldi	r20, 0x00	; 0
    3c3e:	50 e0       	ldi	r21, 0x00	; 0
    3c40:	ba 01       	movw	r22, r20
    3c42:	0e 94 3f 11 	call	0x227e	; 0x227e <create_chain>
    3c46:	ab 01       	movw	r20, r22
    3c48:	bc 01       	movw	r22, r24
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    3c4a:	41 30       	cpi	r20, 0x01	; 1
    3c4c:	51 05       	cpc	r21, r1
    3c4e:	61 05       	cpc	r22, r1
    3c50:	71 05       	cpc	r23, r1
    3c52:	39 f4       	brne	.+14     	; 0x3c62 <f_lseek+0x17c>
    3c54:	ed 81       	ldd	r30, Y+5	; 0x05
    3c56:	fe 81       	ldd	r31, Y+6	; 0x06
    3c58:	84 81       	ldd	r24, Z+4	; 0x04
    3c5a:	80 68       	ori	r24, 0x80	; 128
    3c5c:	84 83       	std	Z+4, r24	; 0x04
    3c5e:	12 e0       	ldi	r17, 0x02	; 2
    3c60:	49 c1       	rjmp	.+658    	; 0x3ef4 <f_lseek+0x40e>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3c62:	4f 3f       	cpi	r20, 0xFF	; 255
    3c64:	ff ef       	ldi	r31, 0xFF	; 255
    3c66:	5f 07       	cpc	r21, r31
    3c68:	ff ef       	ldi	r31, 0xFF	; 255
    3c6a:	6f 07       	cpc	r22, r31
    3c6c:	ff ef       	ldi	r31, 0xFF	; 255
    3c6e:	7f 07       	cpc	r23, r31
    3c70:	59 f4       	brne	.+22     	; 0x3c88 <f_lseek+0x1a2>
    3c72:	ad 81       	ldd	r26, Y+5	; 0x05
    3c74:	be 81       	ldd	r27, Y+6	; 0x06
    3c76:	14 96       	adiw	r26, 0x04	; 4
    3c78:	8c 91       	ld	r24, X
    3c7a:	14 97       	sbiw	r26, 0x04	; 4
    3c7c:	80 68       	ori	r24, 0x80	; 128
    3c7e:	14 96       	adiw	r26, 0x04	; 4
    3c80:	8c 93       	st	X, r24
    3c82:	14 97       	sbiw	r26, 0x04	; 4
    3c84:	11 e0       	ldi	r17, 0x01	; 1
    3c86:	36 c1       	rjmp	.+620    	; 0x3ef4 <f_lseek+0x40e>
					fp->sclust = clst;
    3c88:	ed 81       	ldd	r30, Y+5	; 0x05
    3c8a:	fe 81       	ldd	r31, Y+6	; 0x06
    3c8c:	46 87       	std	Z+14, r20	; 0x0e
    3c8e:	57 87       	std	Z+15, r21	; 0x0f
    3c90:	60 8b       	std	Z+16, r22	; 0x10
    3c92:	71 8b       	std	Z+17, r23	; 0x11
				}
#endif
				fp->clust = clst;
    3c94:	ad 81       	ldd	r26, Y+5	; 0x05
    3c96:	be 81       	ldd	r27, Y+6	; 0x06
    3c98:	52 96       	adiw	r26, 0x12	; 18
    3c9a:	4d 93       	st	X+, r20
    3c9c:	5d 93       	st	X+, r21
    3c9e:	6d 93       	st	X+, r22
    3ca0:	7c 93       	st	X, r23
    3ca2:	55 97       	sbiw	r26, 0x15	; 21
			}
			if (clst != 0) {
    3ca4:	41 15       	cp	r20, r1
    3ca6:	51 05       	cpc	r21, r1
    3ca8:	61 05       	cpc	r22, r1
    3caa:	71 05       	cpc	r23, r1
    3cac:	09 f4       	brne	.+2      	; 0x3cb0 <f_lseek+0x1ca>
    3cae:	aa c0       	rjmp	.+340    	; 0x3e04 <f_lseek+0x31e>
				while (ofs > bcs) {						/* Cluster following loop */
    3cb0:	8c 14       	cp	r8, r12
    3cb2:	9d 04       	cpc	r9, r13
    3cb4:	ae 04       	cpc	r10, r14
    3cb6:	bf 04       	cpc	r11, r15
    3cb8:	08 f0       	brcs	.+2      	; 0x3cbc <f_lseek+0x1d6>
    3cba:	68 c0       	rjmp	.+208    	; 0x3d8c <f_lseek+0x2a6>
    3cbc:	4d 80       	ldd	r4, Y+5	; 0x05
    3cbe:	5e 80       	ldd	r5, Y+6	; 0x06
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    3cc0:	f2 01       	movw	r30, r4
    3cc2:	84 81       	ldd	r24, Z+4	; 0x04
    3cc4:	81 ff       	sbrs	r24, 1
    3cc6:	0c c0       	rjmp	.+24     	; 0x3ce0 <f_lseek+0x1fa>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
    3cc8:	80 81       	ld	r24, Z
    3cca:	91 81       	ldd	r25, Z+1	; 0x01
    3ccc:	0e 94 3f 11 	call	0x227e	; 0x227e <create_chain>
    3cd0:	ab 01       	movw	r20, r22
    3cd2:	bc 01       	movw	r22, r24
						if (clst == 0) {				/* When disk gets full, clip file size */
    3cd4:	41 15       	cp	r20, r1
    3cd6:	51 05       	cpc	r21, r1
    3cd8:	61 05       	cpc	r22, r1
    3cda:	71 05       	cpc	r23, r1
    3cdc:	39 f4       	brne	.+14     	; 0x3cec <f_lseek+0x206>
    3cde:	52 c0       	rjmp	.+164    	; 0x3d84 <f_lseek+0x29e>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    3ce0:	80 81       	ld	r24, Z
    3ce2:	91 81       	ldd	r25, Z+1	; 0x01
    3ce4:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <get_fat>
    3ce8:	ab 01       	movw	r20, r22
    3cea:	bc 01       	movw	r22, r24
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3cec:	4f 3f       	cpi	r20, 0xFF	; 255
    3cee:	bf ef       	ldi	r27, 0xFF	; 255
    3cf0:	5b 07       	cpc	r21, r27
    3cf2:	bf ef       	ldi	r27, 0xFF	; 255
    3cf4:	6b 07       	cpc	r22, r27
    3cf6:	bf ef       	ldi	r27, 0xFF	; 255
    3cf8:	7b 07       	cpc	r23, r27
    3cfa:	41 f4       	brne	.+16     	; 0x3d0c <f_lseek+0x226>
    3cfc:	5e 82       	std	Y+6, r5	; 0x06
    3cfe:	4d 82       	std	Y+5, r4	; 0x05
    3d00:	f2 01       	movw	r30, r4
    3d02:	84 81       	ldd	r24, Z+4	; 0x04
    3d04:	80 68       	ori	r24, 0x80	; 128
    3d06:	84 83       	std	Z+4, r24	; 0x04
    3d08:	11 e0       	ldi	r17, 0x01	; 1
    3d0a:	f4 c0       	rjmp	.+488    	; 0x3ef4 <f_lseek+0x40e>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    3d0c:	42 30       	cpi	r20, 0x02	; 2
    3d0e:	51 05       	cpc	r21, r1
    3d10:	61 05       	cpc	r22, r1
    3d12:	71 05       	cpc	r23, r1
    3d14:	60 f0       	brcs	.+24     	; 0x3d2e <f_lseek+0x248>
    3d16:	d2 01       	movw	r26, r4
    3d18:	ed 91       	ld	r30, X+
    3d1a:	fc 91       	ld	r31, X
    3d1c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d1e:	93 8d       	ldd	r25, Z+27	; 0x1b
    3d20:	a4 8d       	ldd	r26, Z+28	; 0x1c
    3d22:	b5 8d       	ldd	r27, Z+29	; 0x1d
    3d24:	48 17       	cp	r20, r24
    3d26:	59 07       	cpc	r21, r25
    3d28:	6a 07       	cpc	r22, r26
    3d2a:	7b 07       	cpc	r23, r27
    3d2c:	40 f0       	brcs	.+16     	; 0x3d3e <f_lseek+0x258>
    3d2e:	5e 82       	std	Y+6, r5	; 0x06
    3d30:	4d 82       	std	Y+5, r4	; 0x05
    3d32:	f2 01       	movw	r30, r4
    3d34:	84 81       	ldd	r24, Z+4	; 0x04
    3d36:	80 68       	ori	r24, 0x80	; 128
    3d38:	84 83       	std	Z+4, r24	; 0x04
    3d3a:	12 e0       	ldi	r17, 0x02	; 2
    3d3c:	db c0       	rjmp	.+438    	; 0x3ef4 <f_lseek+0x40e>
					fp->clust = clst;
    3d3e:	d2 01       	movw	r26, r4
    3d40:	52 96       	adiw	r26, 0x12	; 18
    3d42:	4d 93       	st	X+, r20
    3d44:	5d 93       	st	X+, r21
    3d46:	6d 93       	st	X+, r22
    3d48:	7c 93       	st	X, r23
    3d4a:	55 97       	sbiw	r26, 0x15	; 21
					fp->fptr += bcs;
    3d4c:	16 96       	adiw	r26, 0x06	; 6
    3d4e:	8d 91       	ld	r24, X+
    3d50:	9d 91       	ld	r25, X+
    3d52:	0d 90       	ld	r0, X+
    3d54:	bc 91       	ld	r27, X
    3d56:	a0 2d       	mov	r26, r0
    3d58:	88 0d       	add	r24, r8
    3d5a:	99 1d       	adc	r25, r9
    3d5c:	aa 1d       	adc	r26, r10
    3d5e:	bb 1d       	adc	r27, r11
    3d60:	f2 01       	movw	r30, r4
    3d62:	86 83       	std	Z+6, r24	; 0x06
    3d64:	97 83       	std	Z+7, r25	; 0x07
    3d66:	a0 87       	std	Z+8, r26	; 0x08
    3d68:	b1 87       	std	Z+9, r27	; 0x09
					ofs -= bcs;
    3d6a:	c8 18       	sub	r12, r8
    3d6c:	d9 08       	sbc	r13, r9
    3d6e:	ea 08       	sbc	r14, r10
    3d70:	fb 08       	sbc	r15, r11
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
    3d72:	8c 14       	cp	r8, r12
    3d74:	9d 04       	cpc	r9, r13
    3d76:	ae 04       	cpc	r10, r14
    3d78:	bf 04       	cpc	r11, r15
    3d7a:	08 f4       	brcc	.+2      	; 0x3d7e <f_lseek+0x298>
    3d7c:	a1 cf       	rjmp	.-190    	; 0x3cc0 <f_lseek+0x1da>
    3d7e:	5e 82       	std	Y+6, r5	; 0x06
    3d80:	4d 82       	std	Y+5, r4	; 0x05
    3d82:	04 c0       	rjmp	.+8      	; 0x3d8c <f_lseek+0x2a6>
    3d84:	5e 82       	std	Y+6, r5	; 0x06
    3d86:	4d 82       	std	Y+5, r4	; 0x05
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
						if (clst == 0) {				/* When disk gets full, clip file size */
							ofs = bcs; break;
    3d88:	75 01       	movw	r14, r10
    3d8a:	64 01       	movw	r12, r8
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
    3d8c:	ed 81       	ldd	r30, Y+5	; 0x05
    3d8e:	fe 81       	ldd	r31, Y+6	; 0x06
    3d90:	86 81       	ldd	r24, Z+6	; 0x06
    3d92:	97 81       	ldd	r25, Z+7	; 0x07
    3d94:	a0 85       	ldd	r26, Z+8	; 0x08
    3d96:	b1 85       	ldd	r27, Z+9	; 0x09
    3d98:	8c 0d       	add	r24, r12
    3d9a:	9d 1d       	adc	r25, r13
    3d9c:	ae 1d       	adc	r26, r14
    3d9e:	bf 1d       	adc	r27, r15
    3da0:	86 83       	std	Z+6, r24	; 0x06
    3da2:	97 83       	std	Z+7, r25	; 0x07
    3da4:	a0 87       	std	Z+8, r26	; 0x08
    3da6:	b1 87       	std	Z+9, r27	; 0x09
				if (ofs % SS(fp->fs)) {
    3da8:	d7 01       	movw	r26, r14
    3daa:	c6 01       	movw	r24, r12
    3dac:	91 70       	andi	r25, 0x01	; 1
    3dae:	a0 70       	andi	r26, 0x00	; 0
    3db0:	b0 70       	andi	r27, 0x00	; 0
    3db2:	00 97       	sbiw	r24, 0x00	; 0
    3db4:	a1 05       	cpc	r26, r1
    3db6:	b1 05       	cpc	r27, r1
    3db8:	49 f1       	breq	.+82     	; 0x3e0c <f_lseek+0x326>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    3dba:	80 81       	ld	r24, Z
    3dbc:	91 81       	ldd	r25, Z+1	; 0x01
    3dbe:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <clust2sect>
    3dc2:	dc 01       	movw	r26, r24
    3dc4:	cb 01       	movw	r24, r22
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    3dc6:	00 97       	sbiw	r24, 0x00	; 0
    3dc8:	a1 05       	cpc	r26, r1
    3dca:	b1 05       	cpc	r27, r1
    3dcc:	59 f4       	brne	.+22     	; 0x3de4 <f_lseek+0x2fe>
    3dce:	ad 81       	ldd	r26, Y+5	; 0x05
    3dd0:	be 81       	ldd	r27, Y+6	; 0x06
    3dd2:	14 96       	adiw	r26, 0x04	; 4
    3dd4:	8c 91       	ld	r24, X
    3dd6:	14 97       	sbiw	r26, 0x04	; 4
    3dd8:	80 68       	ori	r24, 0x80	; 128
    3dda:	14 96       	adiw	r26, 0x04	; 4
    3ddc:	8c 93       	st	X, r24
    3dde:	14 97       	sbiw	r26, 0x04	; 4
    3de0:	12 e0       	ldi	r17, 0x02	; 2
    3de2:	88 c0       	rjmp	.+272    	; 0x3ef4 <f_lseek+0x40e>
					nsect += ofs / SS(fp->fs);
    3de4:	46 01       	movw	r8, r12
    3de6:	57 01       	movw	r10, r14
    3de8:	07 2e       	mov	r0, r23
    3dea:	79 e0       	ldi	r23, 0x09	; 9
    3dec:	b6 94       	lsr	r11
    3dee:	a7 94       	ror	r10
    3df0:	97 94       	ror	r9
    3df2:	87 94       	ror	r8
    3df4:	7a 95       	dec	r23
    3df6:	d1 f7       	brne	.-12     	; 0x3dec <f_lseek+0x306>
    3df8:	70 2d       	mov	r23, r0
    3dfa:	88 0e       	add	r8, r24
    3dfc:	99 1e       	adc	r9, r25
    3dfe:	aa 1e       	adc	r10, r26
    3e00:	bb 1e       	adc	r11, r27
    3e02:	07 c0       	rjmp	.+14     	; 0x3e12 <f_lseek+0x32c>
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
    3e04:	88 24       	eor	r8, r8
    3e06:	99 24       	eor	r9, r9
    3e08:	54 01       	movw	r10, r8
    3e0a:	03 c0       	rjmp	.+6      	; 0x3e12 <f_lseek+0x32c>
    3e0c:	88 24       	eor	r8, r8
    3e0e:	99 24       	eor	r9, r9
    3e10:	54 01       	movw	r10, r8
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
					nsect += ofs / SS(fp->fs);
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    3e12:	ed 81       	ldd	r30, Y+5	; 0x05
    3e14:	fe 81       	ldd	r31, Y+6	; 0x06
    3e16:	86 81       	ldd	r24, Z+6	; 0x06
    3e18:	97 81       	ldd	r25, Z+7	; 0x07
    3e1a:	a0 85       	ldd	r26, Z+8	; 0x08
    3e1c:	b1 85       	ldd	r27, Z+9	; 0x09
    3e1e:	91 70       	andi	r25, 0x01	; 1
    3e20:	a0 70       	andi	r26, 0x00	; 0
    3e22:	b0 70       	andi	r27, 0x00	; 0
    3e24:	00 97       	sbiw	r24, 0x00	; 0
    3e26:	a1 05       	cpc	r26, r1
    3e28:	b1 05       	cpc	r27, r1
    3e2a:	09 f4       	brne	.+2      	; 0x3e2e <f_lseek+0x348>
    3e2c:	4b c0       	rjmp	.+150    	; 0x3ec4 <f_lseek+0x3de>
    3e2e:	c6 88       	ldd	r12, Z+22	; 0x16
    3e30:	d7 88       	ldd	r13, Z+23	; 0x17
    3e32:	e0 8c       	ldd	r14, Z+24	; 0x18
    3e34:	f1 8c       	ldd	r15, Z+25	; 0x19
    3e36:	c8 14       	cp	r12, r8
    3e38:	d9 04       	cpc	r13, r9
    3e3a:	ea 04       	cpc	r14, r10
    3e3c:	fb 04       	cpc	r15, r11
    3e3e:	09 f4       	brne	.+2      	; 0x3e42 <f_lseek+0x35c>
    3e40:	41 c0       	rjmp	.+130    	; 0x3ec4 <f_lseek+0x3de>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
    3e42:	84 81       	ldd	r24, Z+4	; 0x04
    3e44:	86 ff       	sbrs	r24, 6
    3e46:	1f c0       	rjmp	.+62     	; 0x3e86 <f_lseek+0x3a0>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3e48:	01 90       	ld	r0, Z+
    3e4a:	f0 81       	ld	r31, Z
    3e4c:	e0 2d       	mov	r30, r0
    3e4e:	6d 81       	ldd	r22, Y+5	; 0x05
    3e50:	7e 81       	ldd	r23, Y+6	; 0x06
    3e52:	60 5e       	subi	r22, 0xE0	; 224
    3e54:	7f 4f       	sbci	r23, 0xFF	; 255
    3e56:	81 81       	ldd	r24, Z+1	; 0x01
    3e58:	a7 01       	movw	r20, r14
    3e5a:	96 01       	movw	r18, r12
    3e5c:	01 e0       	ldi	r16, 0x01	; 1
    3e5e:	0e 94 ed 02 	call	0x5da	; 0x5da <disk_write>
    3e62:	88 23       	and	r24, r24
    3e64:	59 f0       	breq	.+22     	; 0x3e7c <f_lseek+0x396>
					ABORT(fp->fs, FR_DISK_ERR);
    3e66:	ad 81       	ldd	r26, Y+5	; 0x05
    3e68:	be 81       	ldd	r27, Y+6	; 0x06
    3e6a:	14 96       	adiw	r26, 0x04	; 4
    3e6c:	8c 91       	ld	r24, X
    3e6e:	14 97       	sbiw	r26, 0x04	; 4
    3e70:	80 68       	ori	r24, 0x80	; 128
    3e72:	14 96       	adiw	r26, 0x04	; 4
    3e74:	8c 93       	st	X, r24
    3e76:	14 97       	sbiw	r26, 0x04	; 4
    3e78:	11 e0       	ldi	r17, 0x01	; 1
    3e7a:	3c c0       	rjmp	.+120    	; 0x3ef4 <f_lseek+0x40e>
				fp->flag &= ~FA__DIRTY;
    3e7c:	ed 81       	ldd	r30, Y+5	; 0x05
    3e7e:	fe 81       	ldd	r31, Y+6	; 0x06
    3e80:	84 81       	ldd	r24, Z+4	; 0x04
    3e82:	8f 7b       	andi	r24, 0xBF	; 191
    3e84:	84 83       	std	Z+4, r24	; 0x04
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
    3e86:	ad 81       	ldd	r26, Y+5	; 0x05
    3e88:	be 81       	ldd	r27, Y+6	; 0x06
    3e8a:	ed 91       	ld	r30, X+
    3e8c:	fc 91       	ld	r31, X
    3e8e:	11 97       	sbiw	r26, 0x01	; 1
    3e90:	bd 01       	movw	r22, r26
    3e92:	60 5e       	subi	r22, 0xE0	; 224
    3e94:	7f 4f       	sbci	r23, 0xFF	; 255
    3e96:	81 81       	ldd	r24, Z+1	; 0x01
    3e98:	a5 01       	movw	r20, r10
    3e9a:	94 01       	movw	r18, r8
    3e9c:	01 e0       	ldi	r16, 0x01	; 1
    3e9e:	0e 94 93 02 	call	0x526	; 0x526 <disk_read>
    3ea2:	88 23       	and	r24, r24
    3ea4:	39 f0       	breq	.+14     	; 0x3eb4 <f_lseek+0x3ce>
				ABORT(fp->fs, FR_DISK_ERR);
    3ea6:	ed 81       	ldd	r30, Y+5	; 0x05
    3ea8:	fe 81       	ldd	r31, Y+6	; 0x06
    3eaa:	84 81       	ldd	r24, Z+4	; 0x04
    3eac:	80 68       	ori	r24, 0x80	; 128
    3eae:	84 83       	std	Z+4, r24	; 0x04
    3eb0:	11 e0       	ldi	r17, 0x01	; 1
    3eb2:	20 c0       	rjmp	.+64     	; 0x3ef4 <f_lseek+0x40e>
#endif
			fp->dsect = nsect;
    3eb4:	ad 81       	ldd	r26, Y+5	; 0x05
    3eb6:	be 81       	ldd	r27, Y+6	; 0x06
    3eb8:	56 96       	adiw	r26, 0x16	; 22
    3eba:	8d 92       	st	X+, r8
    3ebc:	9d 92       	st	X+, r9
    3ebe:	ad 92       	st	X+, r10
    3ec0:	bc 92       	st	X, r11
    3ec2:	59 97       	sbiw	r26, 0x19	; 25
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
    3ec4:	ed 81       	ldd	r30, Y+5	; 0x05
    3ec6:	fe 81       	ldd	r31, Y+6	; 0x06
    3ec8:	86 81       	ldd	r24, Z+6	; 0x06
    3eca:	97 81       	ldd	r25, Z+7	; 0x07
    3ecc:	a0 85       	ldd	r26, Z+8	; 0x08
    3ece:	b1 85       	ldd	r27, Z+9	; 0x09
    3ed0:	42 85       	ldd	r20, Z+10	; 0x0a
    3ed2:	53 85       	ldd	r21, Z+11	; 0x0b
    3ed4:	64 85       	ldd	r22, Z+12	; 0x0c
    3ed6:	75 85       	ldd	r23, Z+13	; 0x0d
    3ed8:	48 17       	cp	r20, r24
    3eda:	59 07       	cpc	r21, r25
    3edc:	6a 07       	cpc	r22, r26
    3ede:	7b 07       	cpc	r23, r27
    3ee0:	48 f4       	brcc	.+18     	; 0x3ef4 <f_lseek+0x40e>
			fp->fsize = fp->fptr;
    3ee2:	82 87       	std	Z+10, r24	; 0x0a
    3ee4:	93 87       	std	Z+11, r25	; 0x0b
    3ee6:	a4 87       	std	Z+12, r26	; 0x0c
    3ee8:	b5 87       	std	Z+13, r27	; 0x0d
			fp->flag |= FA__WRITTEN;
    3eea:	84 81       	ldd	r24, Z+4	; 0x04
    3eec:	80 62       	ori	r24, 0x20	; 32
    3eee:	84 83       	std	Z+4, r24	; 0x04
    3ef0:	01 c0       	rjmp	.+2      	; 0x3ef4 <f_lseek+0x40e>


	res = validate(fp);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)			/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    3ef2:	12 e0       	ldi	r17, 0x02	; 2
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
    3ef4:	81 2f       	mov	r24, r17
    3ef6:	26 96       	adiw	r28, 0x06	; 6
    3ef8:	0f b6       	in	r0, 0x3f	; 63
    3efa:	f8 94       	cli
    3efc:	de bf       	out	0x3e, r29	; 62
    3efe:	0f be       	out	0x3f, r0	; 63
    3f00:	cd bf       	out	0x3d, r28	; 61
    3f02:	df 91       	pop	r29
    3f04:	cf 91       	pop	r28
    3f06:	1f 91       	pop	r17
    3f08:	0f 91       	pop	r16
    3f0a:	ff 90       	pop	r15
    3f0c:	ef 90       	pop	r14
    3f0e:	df 90       	pop	r13
    3f10:	cf 90       	pop	r12
    3f12:	bf 90       	pop	r11
    3f14:	af 90       	pop	r10
    3f16:	9f 90       	pop	r9
    3f18:	8f 90       	pop	r8
    3f1a:	7f 90       	pop	r7
    3f1c:	6f 90       	pop	r6
    3f1e:	5f 90       	pop	r5
    3f20:	4f 90       	pop	r4
    3f22:	3f 90       	pop	r3
    3f24:	2f 90       	pop	r2
    3f26:	08 95       	ret

00003f28 <f_opendir>:

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const TCHAR *path	/* Pointer to the directory path */
)
{
    3f28:	ef 92       	push	r14
    3f2a:	ff 92       	push	r15
    3f2c:	0f 93       	push	r16
    3f2e:	1f 93       	push	r17
    3f30:	cf 93       	push	r28
    3f32:	df 93       	push	r29
    3f34:	cd b7       	in	r28, 0x3d	; 61
    3f36:	de b7       	in	r29, 0x3e	; 62
    3f38:	2e 97       	sbiw	r28, 0x0e	; 14
    3f3a:	0f b6       	in	r0, 0x3f	; 63
    3f3c:	f8 94       	cli
    3f3e:	de bf       	out	0x3e, r29	; 62
    3f40:	0f be       	out	0x3f, r0	; 63
    3f42:	cd bf       	out	0x3d, r28	; 61
    3f44:	8c 01       	movw	r16, r24
    3f46:	7e 87       	std	Y+14, r23	; 0x0e
    3f48:	6d 87       	std	Y+13, r22	; 0x0d
	FRESULT res;
	FATFS *fs;
	DEF_NAMEBUF;


	if (!dj) return FR_INVALID_OBJECT;
    3f4a:	00 97       	sbiw	r24, 0x00	; 0
    3f4c:	09 f4       	brne	.+2      	; 0x3f50 <f_opendir+0x28>
    3f4e:	4c c0       	rjmp	.+152    	; 0x3fe8 <f_opendir+0xc0>

	res = chk_mounted(&path, &dj->fs, 0);
    3f50:	ce 01       	movw	r24, r28
    3f52:	0d 96       	adiw	r24, 0x0d	; 13
    3f54:	b8 01       	movw	r22, r16
    3f56:	40 e0       	ldi	r20, 0x00	; 0
    3f58:	0e 94 79 08 	call	0x10f2	; 0x10f2 <chk_mounted>
	fs = dj->fs;
    3f5c:	d8 01       	movw	r26, r16
    3f5e:	ed 90       	ld	r14, X+
    3f60:	fc 90       	ld	r15, X
    3f62:	11 97       	sbiw	r26, 0x01	; 1
	if (res == FR_OK) {
    3f64:	88 23       	and	r24, r24
    3f66:	e1 f5       	brne	.+120    	; 0x3fe0 <f_opendir+0xb8>
		INIT_BUF(*dj);
    3f68:	ce 01       	movw	r24, r28
    3f6a:	01 96       	adiw	r24, 0x01	; 1
    3f6c:	55 96       	adiw	r26, 0x15	; 21
    3f6e:	9c 93       	st	X, r25
    3f70:	8e 93       	st	-X, r24
    3f72:	54 97       	sbiw	r26, 0x14	; 20
		res = follow_path(dj, path);			/* Follow the path to the directory */
    3f74:	6d 85       	ldd	r22, Y+13	; 0x0d
    3f76:	7e 85       	ldd	r23, Y+14	; 0x0e
    3f78:	c8 01       	movw	r24, r16
    3f7a:	0e 94 a8 13 	call	0x2750	; 0x2750 <follow_path>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
    3f7e:	88 23       	and	r24, r24
    3f80:	11 f5       	brne	.+68     	; 0x3fc6 <f_opendir+0x9e>
			if (dj->dir) {						/* It is not the root dir */
    3f82:	d8 01       	movw	r26, r16
    3f84:	52 96       	adiw	r26, 0x12	; 18
    3f86:	ed 91       	ld	r30, X+
    3f88:	fc 91       	ld	r31, X
    3f8a:	53 97       	sbiw	r26, 0x13	; 19
    3f8c:	30 97       	sbiw	r30, 0x00	; 0
    3f8e:	71 f0       	breq	.+28     	; 0x3fac <f_opendir+0x84>
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
    3f90:	83 85       	ldd	r24, Z+11	; 0x0b
    3f92:	84 ff       	sbrs	r24, 4
    3f94:	1b c0       	rjmp	.+54     	; 0x3fcc <f_opendir+0xa4>
					dj->sclust = ld_clust(fs, dj->dir);
    3f96:	c7 01       	movw	r24, r14
    3f98:	bf 01       	movw	r22, r30
    3f9a:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <ld_clust>
    3f9e:	dc 01       	movw	r26, r24
    3fa0:	cb 01       	movw	r24, r22
    3fa2:	f8 01       	movw	r30, r16
    3fa4:	86 83       	std	Z+6, r24	; 0x06
    3fa6:	97 83       	std	Z+7, r25	; 0x07
    3fa8:	a0 87       	std	Z+8, r26	; 0x08
    3faa:	b1 87       	std	Z+9, r27	; 0x09
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dj->id = fs->id;
    3fac:	d7 01       	movw	r26, r14
    3fae:	16 96       	adiw	r26, 0x06	; 6
    3fb0:	8d 91       	ld	r24, X+
    3fb2:	9c 91       	ld	r25, X
    3fb4:	17 97       	sbiw	r26, 0x07	; 7
    3fb6:	f8 01       	movw	r30, r16
    3fb8:	93 83       	std	Z+3, r25	; 0x03
    3fba:	82 83       	std	Z+2, r24	; 0x02
				res = dir_sdi(dj, 0);			/* Rewind dir */
    3fbc:	c8 01       	movw	r24, r16
    3fbe:	60 e0       	ldi	r22, 0x00	; 0
    3fc0:	70 e0       	ldi	r23, 0x00	; 0
    3fc2:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <dir_sdi>
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    3fc6:	84 30       	cpi	r24, 0x04	; 4
    3fc8:	11 f4       	brne	.+4      	; 0x3fce <f_opendir+0xa6>
    3fca:	04 c0       	rjmp	.+8      	; 0x3fd4 <f_opendir+0xac>
		if (res == FR_OK) {						/* Follow completed */
			if (dj->dir) {						/* It is not the root dir */
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
					dj->sclust = ld_clust(fs, dj->dir);
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
    3fcc:	85 e0       	ldi	r24, 0x05	; 5
				dj->id = fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
    3fce:	88 23       	and	r24, r24
    3fd0:	61 f0       	breq	.+24     	; 0x3fea <f_opendir+0xc2>
    3fd2:	01 c0       	rjmp	.+2      	; 0x3fd6 <f_opendir+0xae>
			if (res == FR_OK) {
				dj->id = fs->id;
				res = dir_sdi(dj, 0);			/* Rewind dir */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
    3fd4:	85 e0       	ldi	r24, 0x05	; 5
		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
    3fd6:	d8 01       	movw	r26, r16
    3fd8:	11 96       	adiw	r26, 0x01	; 1
    3fda:	1c 92       	st	X, r1
    3fdc:	1e 92       	st	-X, r1
    3fde:	05 c0       	rjmp	.+10     	; 0x3fea <f_opendir+0xc2>
	} else {
		dj->fs = 0;
    3fe0:	f8 01       	movw	r30, r16
    3fe2:	11 82       	std	Z+1, r1	; 0x01
    3fe4:	10 82       	st	Z, r1
    3fe6:	01 c0       	rjmp	.+2      	; 0x3fea <f_opendir+0xc2>
	FRESULT res;
	FATFS *fs;
	DEF_NAMEBUF;


	if (!dj) return FR_INVALID_OBJECT;
    3fe8:	89 e0       	ldi	r24, 0x09	; 9
	} else {
		dj->fs = 0;
	}

	LEAVE_FF(fs, res);
}
    3fea:	2e 96       	adiw	r28, 0x0e	; 14
    3fec:	0f b6       	in	r0, 0x3f	; 63
    3fee:	f8 94       	cli
    3ff0:	de bf       	out	0x3e, r29	; 62
    3ff2:	0f be       	out	0x3f, r0	; 63
    3ff4:	cd bf       	out	0x3d, r28	; 61
    3ff6:	df 91       	pop	r29
    3ff8:	cf 91       	pop	r28
    3ffa:	1f 91       	pop	r17
    3ffc:	0f 91       	pop	r16
    3ffe:	ff 90       	pop	r15
    4000:	ef 90       	pop	r14
    4002:	08 95       	ret

00004004 <f_readdir>:

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
    4004:	cf 92       	push	r12
    4006:	df 92       	push	r13
    4008:	ef 92       	push	r14
    400a:	ff 92       	push	r15
    400c:	1f 93       	push	r17
    400e:	cf 93       	push	r28
    4010:	df 93       	push	r29
    4012:	cd b7       	in	r28, 0x3d	; 61
    4014:	de b7       	in	r29, 0x3e	; 62
    4016:	2c 97       	sbiw	r28, 0x0c	; 12
    4018:	0f b6       	in	r0, 0x3f	; 63
    401a:	f8 94       	cli
    401c:	de bf       	out	0x3e, r29	; 62
    401e:	0f be       	out	0x3f, r0	; 63
    4020:	cd bf       	out	0x3d, r28	; 61
    4022:	7c 01       	movw	r14, r24
    4024:	6b 01       	movw	r12, r22
	FRESULT res;
	DEF_NAMEBUF;


	res = validate(dj);						/* Check validity of the object */
    4026:	0e 94 bc 07 	call	0xf78	; 0xf78 <validate>
    402a:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    402c:	88 23       	and	r24, r24
    402e:	81 f5       	brne	.+96     	; 0x4090 <f_readdir+0x8c>
		if (!fno) {
    4030:	c1 14       	cp	r12, r1
    4032:	d1 04       	cpc	r13, r1
    4034:	39 f4       	brne	.+14     	; 0x4044 <f_readdir+0x40>
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
    4036:	c7 01       	movw	r24, r14
    4038:	60 e0       	ldi	r22, 0x00	; 0
    403a:	70 e0       	ldi	r23, 0x00	; 0
    403c:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <dir_sdi>
    4040:	18 2f       	mov	r17, r24
    4042:	26 c0       	rjmp	.+76     	; 0x4090 <f_readdir+0x8c>
		} else {
			INIT_BUF(*dj);
    4044:	ce 01       	movw	r24, r28
    4046:	01 96       	adiw	r24, 0x01	; 1
    4048:	f7 01       	movw	r30, r14
    404a:	95 8b       	std	Z+21, r25	; 0x15
    404c:	84 8b       	std	Z+20, r24	; 0x14
			res = dir_read(dj);				/* Read an directory item */
    404e:	c7 01       	movw	r24, r14
    4050:	0e 94 30 16 	call	0x2c60	; 0x2c60 <dir_read>
			if (res == FR_NO_FILE) {		/* Reached end of dir */
    4054:	84 30       	cpi	r24, 0x04	; 4
    4056:	31 f4       	brne	.+12     	; 0x4064 <f_readdir+0x60>
				dj->sect = 0;
    4058:	f7 01       	movw	r30, r14
    405a:	16 86       	std	Z+14, r1	; 0x0e
    405c:	17 86       	std	Z+15, r1	; 0x0f
    405e:	10 8a       	std	Z+16, r1	; 0x10
    4060:	11 8a       	std	Z+17, r1	; 0x11
    4062:	02 c0       	rjmp	.+4      	; 0x4068 <f_readdir+0x64>
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
    4064:	88 23       	and	r24, r24
    4066:	89 f4       	brne	.+34     	; 0x408a <f_readdir+0x86>
				get_fileinfo(dj, fno);		/* Get the object information */
    4068:	c7 01       	movw	r24, r14
    406a:	b6 01       	movw	r22, r12
    406c:	0e 94 2a 07 	call	0xe54	; 0xe54 <get_fileinfo>
				res = dir_next(dj, 0);		/* Increment index for next */
    4070:	c7 01       	movw	r24, r14
    4072:	60 e0       	ldi	r22, 0x00	; 0
    4074:	70 e0       	ldi	r23, 0x00	; 0
    4076:	0e 94 61 12 	call	0x24c2	; 0x24c2 <dir_next>
				if (res == FR_NO_FILE) {
    407a:	84 30       	cpi	r24, 0x04	; 4
    407c:	41 f4       	brne	.+16     	; 0x408e <f_readdir+0x8a>
					dj->sect = 0;
    407e:	f7 01       	movw	r30, r14
    4080:	16 86       	std	Z+14, r1	; 0x0e
    4082:	17 86       	std	Z+15, r1	; 0x0f
    4084:	10 8a       	std	Z+16, r1	; 0x10
    4086:	11 8a       	std	Z+17, r1	; 0x11
    4088:	03 c0       	rjmp	.+6      	; 0x4090 <f_readdir+0x8c>
	if (res == FR_OK) {
		if (!fno) {
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
		} else {
			INIT_BUF(*dj);
			res = dir_read(dj);				/* Read an directory item */
    408a:	18 2f       	mov	r17, r24
    408c:	01 c0       	rjmp	.+2      	; 0x4090 <f_readdir+0x8c>
				dj->sect = 0;
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
				get_fileinfo(dj, fno);		/* Get the object information */
				res = dir_next(dj, 0);		/* Increment index for next */
    408e:	18 2f       	mov	r17, r24
			FREE_BUF();
		}
	}

	LEAVE_FF(dj->fs, res);
}
    4090:	81 2f       	mov	r24, r17
    4092:	2c 96       	adiw	r28, 0x0c	; 12
    4094:	0f b6       	in	r0, 0x3f	; 63
    4096:	f8 94       	cli
    4098:	de bf       	out	0x3e, r29	; 62
    409a:	0f be       	out	0x3f, r0	; 63
    409c:	cd bf       	out	0x3d, r28	; 61
    409e:	df 91       	pop	r29
    40a0:	cf 91       	pop	r28
    40a2:	1f 91       	pop	r17
    40a4:	ff 90       	pop	r15
    40a6:	ef 90       	pop	r14
    40a8:	df 90       	pop	r13
    40aa:	cf 90       	pop	r12
    40ac:	08 95       	ret

000040ae <f_stat>:

FRESULT f_stat (
	const TCHAR *path,	/* Pointer to the file path */
	FILINFO *fno		/* Pointer to file information to return */
)
{
    40ae:	ef 92       	push	r14
    40b0:	ff 92       	push	r15
    40b2:	1f 93       	push	r17
    40b4:	cf 93       	push	r28
    40b6:	df 93       	push	r29
    40b8:	cd b7       	in	r28, 0x3d	; 61
    40ba:	de b7       	in	r29, 0x3e	; 62
    40bc:	a4 97       	sbiw	r28, 0x24	; 36
    40be:	0f b6       	in	r0, 0x3f	; 63
    40c0:	f8 94       	cli
    40c2:	de bf       	out	0x3e, r29	; 62
    40c4:	0f be       	out	0x3f, r0	; 63
    40c6:	cd bf       	out	0x3d, r28	; 61
    40c8:	9c a3       	lds	r25, 0x5c
    40ca:	8b a3       	lds	r24, 0x5b
    40cc:	7b 01       	movw	r14, r22
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
    40ce:	ce 01       	movw	r24, r28
    40d0:	83 96       	adiw	r24, 0x23	; 35
    40d2:	be 01       	movw	r22, r28
    40d4:	6f 5f       	subi	r22, 0xFF	; 255
    40d6:	7f 4f       	sbci	r23, 0xFF	; 255
    40d8:	40 e0       	ldi	r20, 0x00	; 0
    40da:	0e 94 79 08 	call	0x10f2	; 0x10f2 <chk_mounted>
    40de:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    40e0:	88 23       	and	r24, r24
    40e2:	c1 f4       	brne	.+48     	; 0x4114 <f_stat+0x66>
		INIT_BUF(dj);
    40e4:	ce 01       	movw	r24, r28
    40e6:	47 96       	adiw	r24, 0x17	; 23
    40e8:	9e 8b       	std	Y+22, r25	; 0x16
    40ea:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    40ec:	6b a1       	lds	r22, 0x4b
    40ee:	7c a1       	lds	r23, 0x4c
    40f0:	ce 01       	movw	r24, r28
    40f2:	01 96       	adiw	r24, 0x01	; 1
    40f4:	0e 94 a8 13 	call	0x2750	; 0x2750 <follow_path>
    40f8:	18 2f       	mov	r17, r24
		if (res == FR_OK) {				/* Follow completed */
    40fa:	88 23       	and	r24, r24
    40fc:	59 f4       	brne	.+22     	; 0x4114 <f_stat+0x66>
			if (dj.dir)		/* Found an object */
    40fe:	8b 89       	ldd	r24, Y+19	; 0x13
    4100:	9c 89       	ldd	r25, Y+20	; 0x14
    4102:	00 97       	sbiw	r24, 0x00	; 0
    4104:	31 f0       	breq	.+12     	; 0x4112 <f_stat+0x64>
				get_fileinfo(&dj, fno);
    4106:	ce 01       	movw	r24, r28
    4108:	01 96       	adiw	r24, 0x01	; 1
    410a:	b7 01       	movw	r22, r14
    410c:	0e 94 2a 07 	call	0xe54	; 0xe54 <get_fileinfo>
    4110:	01 c0       	rjmp	.+2      	; 0x4114 <f_stat+0x66>
			else			/* It is root dir */
				res = FR_INVALID_NAME;
    4112:	16 e0       	ldi	r17, 0x06	; 6
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    4114:	81 2f       	mov	r24, r17
    4116:	a4 96       	adiw	r28, 0x24	; 36
    4118:	0f b6       	in	r0, 0x3f	; 63
    411a:	f8 94       	cli
    411c:	de bf       	out	0x3e, r29	; 62
    411e:	0f be       	out	0x3f, r0	; 63
    4120:	cd bf       	out	0x3d, r28	; 61
    4122:	df 91       	pop	r29
    4124:	cf 91       	pop	r28
    4126:	1f 91       	pop	r17
    4128:	ff 90       	pop	r15
    412a:	ef 90       	pop	r14
    412c:	08 95       	ret

0000412e <f_getfree>:
FRESULT f_getfree (
	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
)
{
    412e:	2f 92       	push	r2
    4130:	3f 92       	push	r3
    4132:	4f 92       	push	r4
    4134:	5f 92       	push	r5
    4136:	6f 92       	push	r6
    4138:	7f 92       	push	r7
    413a:	8f 92       	push	r8
    413c:	9f 92       	push	r9
    413e:	af 92       	push	r10
    4140:	bf 92       	push	r11
    4142:	cf 92       	push	r12
    4144:	df 92       	push	r13
    4146:	ef 92       	push	r14
    4148:	ff 92       	push	r15
    414a:	0f 93       	push	r16
    414c:	1f 93       	push	r17
    414e:	cf 93       	push	r28
    4150:	df 93       	push	r29
    4152:	cd b7       	in	r28, 0x3d	; 61
    4154:	de b7       	in	r29, 0x3e	; 62
    4156:	2c 97       	sbiw	r28, 0x0c	; 12
    4158:	0f b6       	in	r0, 0x3f	; 63
    415a:	f8 94       	cli
    415c:	de bf       	out	0x3e, r29	; 62
    415e:	0f be       	out	0x3f, r0	; 63
    4160:	cd bf       	out	0x3d, r28	; 61
    4162:	9a 83       	std	Y+2, r25	; 0x02
    4164:	89 83       	std	Y+1, r24	; 0x01
    4166:	78 87       	std	Y+8, r23	; 0x08
    4168:	6f 83       	std	Y+7, r22	; 0x07
    416a:	8a 01       	movw	r16, r20
	UINT i;
	BYTE fat, *p;


	/* Get drive number */
	res = chk_mounted(&path, fatfs, 0);
    416c:	ce 01       	movw	r24, r28
    416e:	01 96       	adiw	r24, 0x01	; 1
    4170:	ba 01       	movw	r22, r20
    4172:	40 e0       	ldi	r20, 0x00	; 0
    4174:	0e 94 79 08 	call	0x10f2	; 0x10f2 <chk_mounted>
    4178:	b8 2e       	mov	r11, r24
	fs = *fatfs;
    417a:	d8 01       	movw	r26, r16
    417c:	8d 90       	ld	r8, X+
    417e:	9c 90       	ld	r9, X
    4180:	11 97       	sbiw	r26, 0x01	; 1
	if (res == FR_OK) {
    4182:	88 23       	and	r24, r24
    4184:	09 f0       	breq	.+2      	; 0x4188 <f_getfree+0x5a>
    4186:	03 c1       	rjmp	.+518    	; 0x438e <f_getfree+0x260>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
    4188:	f4 01       	movw	r30, r8
    418a:	86 85       	ldd	r24, Z+14	; 0x0e
    418c:	97 85       	ldd	r25, Z+15	; 0x0f
    418e:	a0 89       	ldd	r26, Z+16	; 0x10
    4190:	b1 89       	ldd	r27, Z+17	; 0x11
    4192:	c2 8c       	ldd	r12, Z+26	; 0x1a
    4194:	d3 8c       	ldd	r13, Z+27	; 0x1b
    4196:	e4 8c       	ldd	r14, Z+28	; 0x1c
    4198:	f5 8c       	ldd	r15, Z+29	; 0x1d
    419a:	b7 01       	movw	r22, r14
    419c:	a6 01       	movw	r20, r12
    419e:	42 50       	subi	r20, 0x02	; 2
    41a0:	50 40       	sbci	r21, 0x00	; 0
    41a2:	60 40       	sbci	r22, 0x00	; 0
    41a4:	70 40       	sbci	r23, 0x00	; 0
    41a6:	48 17       	cp	r20, r24
    41a8:	59 07       	cpc	r21, r25
    41aa:	6a 07       	cpc	r22, r26
    41ac:	7b 07       	cpc	r23, r27
    41ae:	38 f0       	brcs	.+14     	; 0x41be <f_getfree+0x90>
			*nclst = fs->free_clust;
    41b0:	ef 81       	ldd	r30, Y+7	; 0x07
    41b2:	f8 85       	ldd	r31, Y+8	; 0x08
    41b4:	80 83       	st	Z, r24
    41b6:	91 83       	std	Z+1, r25	; 0x01
    41b8:	a2 83       	std	Z+2, r26	; 0x02
    41ba:	b3 83       	std	Z+3, r27	; 0x03
    41bc:	e8 c0       	rjmp	.+464    	; 0x438e <f_getfree+0x260>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
    41be:	a0 80       	ld	r10, Z
			n = 0;
			if (fat == FS_FAT12) {
    41c0:	b1 e0       	ldi	r27, 0x01	; 1
    41c2:	ab 16       	cp	r10, r27
    41c4:	d9 f5       	brne	.+118    	; 0x423c <f_getfree+0x10e>
    41c6:	cc 24       	eor	r12, r12
    41c8:	dd 24       	eor	r13, r13
    41ca:	76 01       	movw	r14, r12
    41cc:	68 94       	set
    41ce:	c1 f8       	bld	r12, 1
    41d0:	44 24       	eor	r4, r4
    41d2:	55 24       	eor	r5, r5
    41d4:	32 01       	movw	r6, r4
				clst = 2;
				do {
					stat = get_fat(fs, clst);
    41d6:	c4 01       	movw	r24, r8
    41d8:	b7 01       	movw	r22, r14
    41da:	a6 01       	movw	r20, r12
    41dc:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <get_fat>
    41e0:	dc 01       	movw	r26, r24
    41e2:	cb 01       	movw	r24, r22
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
    41e4:	8f 3f       	cpi	r24, 0xFF	; 255
    41e6:	ef ef       	ldi	r30, 0xFF	; 255
    41e8:	9e 07       	cpc	r25, r30
    41ea:	ef ef       	ldi	r30, 0xFF	; 255
    41ec:	ae 07       	cpc	r26, r30
    41ee:	ef ef       	ldi	r30, 0xFF	; 255
    41f0:	be 07       	cpc	r27, r30
    41f2:	09 f4       	brne	.+2      	; 0x41f6 <f_getfree+0xc8>
    41f4:	b0 c0       	rjmp	.+352    	; 0x4356 <f_getfree+0x228>
					if (stat == 1) { res = FR_INT_ERR; break; }
    41f6:	81 30       	cpi	r24, 0x01	; 1
    41f8:	91 05       	cpc	r25, r1
    41fa:	a1 05       	cpc	r26, r1
    41fc:	b1 05       	cpc	r27, r1
    41fe:	09 f4       	brne	.+2      	; 0x4202 <f_getfree+0xd4>
    4200:	ad c0       	rjmp	.+346    	; 0x435c <f_getfree+0x22e>
					if (stat == 0) n++;
    4202:	00 97       	sbiw	r24, 0x00	; 0
    4204:	a1 05       	cpc	r26, r1
    4206:	b1 05       	cpc	r27, r1
    4208:	29 f4       	brne	.+10     	; 0x4214 <f_getfree+0xe6>
    420a:	08 94       	sec
    420c:	41 1c       	adc	r4, r1
    420e:	51 1c       	adc	r5, r1
    4210:	61 1c       	adc	r6, r1
    4212:	71 1c       	adc	r7, r1
				} while (++clst < fs->n_fatent);
    4214:	08 94       	sec
    4216:	c1 1c       	adc	r12, r1
    4218:	d1 1c       	adc	r13, r1
    421a:	e1 1c       	adc	r14, r1
    421c:	f1 1c       	adc	r15, r1
    421e:	f4 01       	movw	r30, r8
    4220:	82 8d       	ldd	r24, Z+26	; 0x1a
    4222:	93 8d       	ldd	r25, Z+27	; 0x1b
    4224:	a4 8d       	ldd	r26, Z+28	; 0x1c
    4226:	b5 8d       	ldd	r27, Z+29	; 0x1d
    4228:	c8 16       	cp	r12, r24
    422a:	d9 06       	cpc	r13, r25
    422c:	ea 06       	cpc	r14, r26
    422e:	fb 06       	cpc	r15, r27
    4230:	90 f2       	brcs	.-92     	; 0x41d6 <f_getfree+0xa8>
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
    4232:	46 86       	std	Z+14, r4	; 0x0e
    4234:	57 86       	std	Z+15, r5	; 0x0f
    4236:	60 8a       	std	Z+16, r6	; 0x10
    4238:	71 8a       	std	Z+17, r7	; 0x11
    423a:	a2 c0       	rjmp	.+324    	; 0x4380 <f_getfree+0x252>
					if (stat == 1) { res = FR_INT_ERR; break; }
					if (stat == 0) n++;
				} while (++clst < fs->n_fatent);
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
    423c:	82 a1       	lds	r24, 0x42
    423e:	93 a1       	lds	r25, 0x43
    4240:	a4 a1       	lds	r26, 0x44
    4242:	b5 a1       	lds	r27, 0x45
    4244:	8b 83       	std	Y+3, r24	; 0x03
    4246:	9c 83       	std	Y+4, r25	; 0x04
    4248:	ad 83       	std	Y+5, r26	; 0x05
    424a:	be 83       	std	Y+6, r27	; 0x06
				i = 0; p = 0;
    424c:	e0 e0       	ldi	r30, 0x00	; 0
    424e:	f0 e0       	ldi	r31, 0x00	; 0
    4250:	00 e0       	ldi	r16, 0x00	; 0
    4252:	10 e0       	ldi	r17, 0x00	; 0
    4254:	98 01       	movw	r18, r16
		if (fs->free_clust <= fs->n_fatent - 2) {
			*nclst = fs->free_clust;
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
			n = 0;
    4256:	44 24       	eor	r4, r4
    4258:	55 24       	eor	r5, r5
    425a:	32 01       	movw	r6, r4
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
    425c:	a4 01       	movw	r20, r8
    425e:	4e 5c       	subi	r20, 0xCE	; 206
    4260:	5f 4f       	sbci	r21, 0xFF	; 255
    4262:	5c 87       	std	Y+12, r21	; 0x0c
    4264:	4b 87       	std	Y+11, r20	; 0x0b
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
    4266:	01 15       	cp	r16, r1
    4268:	11 05       	cpc	r17, r1
    426a:	21 05       	cpc	r18, r1
    426c:	31 05       	cpc	r19, r1
    426e:	d9 f4       	brne	.+54     	; 0x42a6 <f_getfree+0x178>
						res = move_window(fs, sect++);
    4270:	c4 01       	movw	r24, r8
    4272:	4b 81       	ldd	r20, Y+3	; 0x03
    4274:	5c 81       	ldd	r21, Y+4	; 0x04
    4276:	6d 81       	ldd	r22, Y+5	; 0x05
    4278:	7e 81       	ldd	r23, Y+6	; 0x06
    427a:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
						if (res != FR_OK) break;
    427e:	88 23       	and	r24, r24
    4280:	09 f0       	breq	.+2      	; 0x4284 <f_getfree+0x156>
    4282:	70 c0       	rjmp	.+224    	; 0x4364 <f_getfree+0x236>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
    4284:	8b 81       	ldd	r24, Y+3	; 0x03
    4286:	9c 81       	ldd	r25, Y+4	; 0x04
    4288:	ad 81       	ldd	r26, Y+5	; 0x05
    428a:	be 81       	ldd	r27, Y+6	; 0x06
    428c:	01 96       	adiw	r24, 0x01	; 1
    428e:	a1 1d       	adc	r26, r1
    4290:	b1 1d       	adc	r27, r1
    4292:	8b 83       	std	Y+3, r24	; 0x03
    4294:	9c 83       	std	Y+4, r25	; 0x04
    4296:	ad 83       	std	Y+5, r26	; 0x05
    4298:	be 83       	std	Y+6, r27	; 0x06
						if (res != FR_OK) break;
						p = fs->win;
    429a:	eb 85       	ldd	r30, Y+11	; 0x0b
    429c:	fc 85       	ldd	r31, Y+12	; 0x0c
						i = SS(fs);
    429e:	00 e0       	ldi	r16, 0x00	; 0
    42a0:	12 e0       	ldi	r17, 0x02	; 2
    42a2:	20 e0       	ldi	r18, 0x00	; 0
    42a4:	30 e0       	ldi	r19, 0x00	; 0
					}
					if (fat == FS_FAT16) {
    42a6:	92 e0       	ldi	r25, 0x02	; 2
    42a8:	a9 16       	cp	r10, r25
    42aa:	b1 f4       	brne	.+44     	; 0x42d8 <f_getfree+0x1aa>
						if (LD_WORD(p) == 0) n++;
    42ac:	a1 81       	ldd	r26, Z+1	; 0x01
    42ae:	aa 87       	std	Y+10, r26	; 0x0a
    42b0:	19 86       	std	Y+9, r1	; 0x09
    42b2:	80 81       	ld	r24, Z
    42b4:	90 e0       	ldi	r25, 0x00	; 0
    42b6:	49 85       	ldd	r20, Y+9	; 0x09
    42b8:	5a 85       	ldd	r21, Y+10	; 0x0a
    42ba:	84 2b       	or	r24, r20
    42bc:	95 2b       	or	r25, r21
    42be:	00 97       	sbiw	r24, 0x00	; 0
    42c0:	29 f4       	brne	.+10     	; 0x42cc <f_getfree+0x19e>
    42c2:	08 94       	sec
    42c4:	41 1c       	adc	r4, r1
    42c6:	51 1c       	adc	r5, r1
    42c8:	61 1c       	adc	r6, r1
    42ca:	71 1c       	adc	r7, r1
						p += 2; i -= 2;
    42cc:	32 96       	adiw	r30, 0x02	; 2
    42ce:	02 50       	subi	r16, 0x02	; 2
    42d0:	10 40       	sbci	r17, 0x00	; 0
    42d2:	20 40       	sbci	r18, 0x00	; 0
    42d4:	30 40       	sbci	r19, 0x00	; 0
    42d6:	33 c0       	rjmp	.+102    	; 0x433e <f_getfree+0x210>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
    42d8:	83 81       	ldd	r24, Z+3	; 0x03
    42da:	90 e0       	ldi	r25, 0x00	; 0
    42dc:	a0 e0       	ldi	r26, 0x00	; 0
    42de:	b0 e0       	ldi	r27, 0x00	; 0
    42e0:	78 2f       	mov	r23, r24
    42e2:	66 27       	eor	r22, r22
    42e4:	55 27       	eor	r21, r21
    42e6:	44 27       	eor	r20, r20
    42e8:	82 81       	ldd	r24, Z+2	; 0x02
    42ea:	90 e0       	ldi	r25, 0x00	; 0
    42ec:	a0 e0       	ldi	r26, 0x00	; 0
    42ee:	b0 e0       	ldi	r27, 0x00	; 0
    42f0:	dc 01       	movw	r26, r24
    42f2:	99 27       	eor	r25, r25
    42f4:	88 27       	eor	r24, r24
    42f6:	48 2b       	or	r20, r24
    42f8:	59 2b       	or	r21, r25
    42fa:	6a 2b       	or	r22, r26
    42fc:	7b 2b       	or	r23, r27
    42fe:	80 81       	ld	r24, Z
    4300:	90 e0       	ldi	r25, 0x00	; 0
    4302:	a0 e0       	ldi	r26, 0x00	; 0
    4304:	b0 e0       	ldi	r27, 0x00	; 0
    4306:	84 2b       	or	r24, r20
    4308:	95 2b       	or	r25, r21
    430a:	a6 2b       	or	r26, r22
    430c:	b7 2b       	or	r27, r23
    430e:	31 80       	ldd	r3, Z+1	; 0x01
    4310:	22 24       	eor	r2, r2
    4312:	a1 01       	movw	r20, r2
    4314:	60 e0       	ldi	r22, 0x00	; 0
    4316:	70 e0       	ldi	r23, 0x00	; 0
    4318:	84 2b       	or	r24, r20
    431a:	95 2b       	or	r25, r21
    431c:	a6 2b       	or	r26, r22
    431e:	b7 2b       	or	r27, r23
    4320:	bf 70       	andi	r27, 0x0F	; 15
    4322:	00 97       	sbiw	r24, 0x00	; 0
    4324:	a1 05       	cpc	r26, r1
    4326:	b1 05       	cpc	r27, r1
    4328:	29 f4       	brne	.+10     	; 0x4334 <f_getfree+0x206>
    432a:	08 94       	sec
    432c:	41 1c       	adc	r4, r1
    432e:	51 1c       	adc	r5, r1
    4330:	61 1c       	adc	r6, r1
    4332:	71 1c       	adc	r7, r1
						p += 4; i -= 4;
    4334:	34 96       	adiw	r30, 0x04	; 4
    4336:	04 50       	subi	r16, 0x04	; 4
    4338:	10 40       	sbci	r17, 0x00	; 0
    433a:	20 40       	sbci	r18, 0x00	; 0
    433c:	30 40       	sbci	r19, 0x00	; 0
					}
				} while (--clst);
    433e:	08 94       	sec
    4340:	c1 08       	sbc	r12, r1
    4342:	d1 08       	sbc	r13, r1
    4344:	e1 08       	sbc	r14, r1
    4346:	f1 08       	sbc	r15, r1
    4348:	c1 14       	cp	r12, r1
    434a:	d1 04       	cpc	r13, r1
    434c:	e1 04       	cpc	r14, r1
    434e:	f1 04       	cpc	r15, r1
    4350:	09 f0       	breq	.+2      	; 0x4354 <f_getfree+0x226>
    4352:	89 cf       	rjmp	.-238    	; 0x4266 <f_getfree+0x138>
    4354:	08 c0       	rjmp	.+16     	; 0x4366 <f_getfree+0x238>
			n = 0;
			if (fat == FS_FAT12) {
				clst = 2;
				do {
					stat = get_fat(fs, clst);
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
    4356:	bb 24       	eor	r11, r11
    4358:	b3 94       	inc	r11
    435a:	05 c0       	rjmp	.+10     	; 0x4366 <f_getfree+0x238>
					if (stat == 1) { res = FR_INT_ERR; break; }
    435c:	bb 24       	eor	r11, r11
    435e:	68 94       	set
    4360:	b1 f8       	bld	r11, 1
    4362:	01 c0       	rjmp	.+2      	; 0x4366 <f_getfree+0x238>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
    4364:	b8 2e       	mov	r11, r24
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
    4366:	d4 01       	movw	r26, r8
    4368:	1e 96       	adiw	r26, 0x0e	; 14
    436a:	4d 92       	st	X+, r4
    436c:	5d 92       	st	X+, r5
    436e:	6d 92       	st	X+, r6
    4370:	7c 92       	st	X, r7
    4372:	51 97       	sbiw	r26, 0x11	; 17
			if (fat == FS_FAT32) fs->fsi_flag = 1;
    4374:	b3 e0       	ldi	r27, 0x03	; 3
    4376:	ab 16       	cp	r10, r27
    4378:	19 f4       	brne	.+6      	; 0x4380 <f_getfree+0x252>
    437a:	81 e0       	ldi	r24, 0x01	; 1
    437c:	f4 01       	movw	r30, r8
    437e:	85 83       	std	Z+5, r24	; 0x05
			*nclst = n;
    4380:	af 81       	ldd	r26, Y+7	; 0x07
    4382:	b8 85       	ldd	r27, Y+8	; 0x08
    4384:	4d 92       	st	X+, r4
    4386:	5d 92       	st	X+, r5
    4388:	6d 92       	st	X+, r6
    438a:	7c 92       	st	X, r7
    438c:	13 97       	sbiw	r26, 0x03	; 3
		}
	}
	LEAVE_FF(fs, res);
}
    438e:	8b 2d       	mov	r24, r11
    4390:	2c 96       	adiw	r28, 0x0c	; 12
    4392:	0f b6       	in	r0, 0x3f	; 63
    4394:	f8 94       	cli
    4396:	de bf       	out	0x3e, r29	; 62
    4398:	0f be       	out	0x3f, r0	; 63
    439a:	cd bf       	out	0x3d, r28	; 61
    439c:	df 91       	pop	r29
    439e:	cf 91       	pop	r28
    43a0:	1f 91       	pop	r17
    43a2:	0f 91       	pop	r16
    43a4:	ff 90       	pop	r15
    43a6:	ef 90       	pop	r14
    43a8:	df 90       	pop	r13
    43aa:	cf 90       	pop	r12
    43ac:	bf 90       	pop	r11
    43ae:	af 90       	pop	r10
    43b0:	9f 90       	pop	r9
    43b2:	8f 90       	pop	r8
    43b4:	7f 90       	pop	r7
    43b6:	6f 90       	pop	r6
    43b8:	5f 90       	pop	r5
    43ba:	4f 90       	pop	r4
    43bc:	3f 90       	pop	r3
    43be:	2f 90       	pop	r2
    43c0:	08 95       	ret

000043c2 <f_truncate>:
/*-----------------------------------------------------------------------*/

FRESULT f_truncate (
	FIL *fp		/* Pointer to the file object */
)
{
    43c2:	cf 92       	push	r12
    43c4:	df 92       	push	r13
    43c6:	ef 92       	push	r14
    43c8:	ff 92       	push	r15
    43ca:	0f 93       	push	r16
    43cc:	1f 93       	push	r17
    43ce:	cf 93       	push	r28
    43d0:	df 93       	push	r29
    43d2:	ec 01       	movw	r28, r24
	FRESULT res;
	DWORD ncl;


	if (!fp) return FR_INVALID_OBJECT;
    43d4:	00 97       	sbiw	r24, 0x00	; 0
    43d6:	09 f4       	brne	.+2      	; 0x43da <f_truncate+0x18>
    43d8:	69 c0       	rjmp	.+210    	; 0x44ac <f_truncate+0xea>

	res = validate(fp);						/* Check validity of the object */
    43da:	0e 94 bc 07 	call	0xf78	; 0xf78 <validate>
	if (res == FR_OK) {
    43de:	88 23       	and	r24, r24
    43e0:	09 f0       	breq	.+2      	; 0x43e4 <f_truncate+0x22>
    43e2:	65 c0       	rjmp	.+202    	; 0x44ae <f_truncate+0xec>
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
    43e4:	9c 81       	ldd	r25, Y+4	; 0x04
    43e6:	99 23       	and	r25, r25
    43e8:	24 f0       	brlt	.+8      	; 0x43f2 <f_truncate+0x30>
			res = FR_INT_ERR;
		} else {
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
    43ea:	91 fd       	sbrc	r25, 1
    43ec:	69 c0       	rjmp	.+210    	; 0x44c0 <f_truncate+0xfe>
				res = FR_DENIED;
    43ee:	87 e0       	ldi	r24, 0x07	; 7
    43f0:	5e c0       	rjmp	.+188    	; 0x44ae <f_truncate+0xec>
	if (!fp) return FR_INVALID_OBJECT;

	res = validate(fp);						/* Check validity of the object */
	if (res == FR_OK) {
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
			res = FR_INT_ERR;
    43f2:	82 e0       	ldi	r24, 0x02	; 2
    43f4:	5c c0       	rjmp	.+184    	; 0x44ae <f_truncate+0xec>
				res = FR_DENIED;
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
    43f6:	4a 87       	std	Y+10, r20	; 0x0a
    43f8:	5b 87       	std	Y+11, r21	; 0x0b
    43fa:	6c 87       	std	Y+12, r22	; 0x0c
    43fc:	7d 87       	std	Y+13, r23	; 0x0d
			fp->flag |= FA__WRITTEN;
    43fe:	8c 81       	ldd	r24, Y+4	; 0x04
    4400:	80 62       	ori	r24, 0x20	; 32
    4402:	8c 83       	std	Y+4, r24	; 0x04
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
    4404:	41 15       	cp	r20, r1
    4406:	51 05       	cpc	r21, r1
    4408:	61 05       	cpc	r22, r1
    440a:	71 05       	cpc	r23, r1
    440c:	69 f4       	brne	.+26     	; 0x4428 <f_truncate+0x66>
				res = remove_chain(fp->fs, fp->sclust);
    440e:	4e 85       	ldd	r20, Y+14	; 0x0e
    4410:	5f 85       	ldd	r21, Y+15	; 0x0f
    4412:	68 89       	ldd	r22, Y+16	; 0x10
    4414:	79 89       	ldd	r23, Y+17	; 0x11
    4416:	88 81       	ld	r24, Y
    4418:	99 81       	ldd	r25, Y+1	; 0x01
    441a:	0e 94 60 16 	call	0x2cc0	; 0x2cc0 <remove_chain>
				fp->sclust = 0;
    441e:	1e 86       	std	Y+14, r1	; 0x0e
    4420:	1f 86       	std	Y+15, r1	; 0x0f
    4422:	18 8a       	std	Y+16, r1	; 0x10
    4424:	19 8a       	std	Y+17, r1	; 0x11
    4426:	3c c0       	rjmp	.+120    	; 0x44a0 <f_truncate+0xde>
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
    4428:	4a 89       	ldd	r20, Y+18	; 0x12
    442a:	5b 89       	ldd	r21, Y+19	; 0x13
    442c:	6c 89       	ldd	r22, Y+20	; 0x14
    442e:	7d 89       	ldd	r23, Y+21	; 0x15
    4430:	88 81       	ld	r24, Y
    4432:	99 81       	ldd	r25, Y+1	; 0x01
    4434:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <get_fat>
    4438:	6b 01       	movw	r12, r22
    443a:	7c 01       	movw	r14, r24
				res = FR_OK;
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
    443c:	81 e0       	ldi	r24, 0x01	; 1
    443e:	c8 16       	cp	r12, r24
    4440:	d1 04       	cpc	r13, r1
    4442:	e1 04       	cpc	r14, r1
    4444:	f1 04       	cpc	r15, r1
    4446:	09 f4       	brne	.+2      	; 0x444a <f_truncate+0x88>
    4448:	4a c0       	rjmp	.+148    	; 0x44de <f_truncate+0x11c>
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
				res = remove_chain(fp->fs, fp->sclust);
				fp->sclust = 0;
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
				res = FR_OK;
    444a:	81 e0       	ldi	r24, 0x01	; 1
    444c:	9f ef       	ldi	r25, 0xFF	; 255
    444e:	c9 16       	cp	r12, r25
    4450:	9f ef       	ldi	r25, 0xFF	; 255
    4452:	d9 06       	cpc	r13, r25
    4454:	9f ef       	ldi	r25, 0xFF	; 255
    4456:	e9 06       	cpc	r14, r25
    4458:	9f ef       	ldi	r25, 0xFF	; 255
    445a:	f9 06       	cpc	r15, r25
    445c:	09 f0       	breq	.+2      	; 0x4460 <f_truncate+0x9e>
    445e:	80 e0       	ldi	r24, 0x00	; 0
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
				if (res == FR_OK && ncl < fp->fs->n_fatent) {
    4460:	88 23       	and	r24, r24
    4462:	01 f5       	brne	.+64     	; 0x44a4 <f_truncate+0xe2>
    4464:	e8 81       	ld	r30, Y
    4466:	f9 81       	ldd	r31, Y+1	; 0x01
    4468:	42 8d       	ldd	r20, Z+26	; 0x1a
    446a:	53 8d       	ldd	r21, Z+27	; 0x1b
    446c:	64 8d       	ldd	r22, Z+28	; 0x1c
    446e:	75 8d       	ldd	r23, Z+29	; 0x1d
    4470:	c4 16       	cp	r12, r20
    4472:	d5 06       	cpc	r13, r21
    4474:	e6 06       	cpc	r14, r22
    4476:	f7 06       	cpc	r15, r23
    4478:	d0 f4       	brcc	.+52     	; 0x44ae <f_truncate+0xec>
					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
    447a:	4a 89       	ldd	r20, Y+18	; 0x12
    447c:	5b 89       	ldd	r21, Y+19	; 0x13
    447e:	6c 89       	ldd	r22, Y+20	; 0x14
    4480:	7d 89       	ldd	r23, Y+21	; 0x15
    4482:	cf 01       	movw	r24, r30
    4484:	0f ef       	ldi	r16, 0xFF	; 255
    4486:	1f ef       	ldi	r17, 0xFF	; 255
    4488:	2f ef       	ldi	r18, 0xFF	; 255
    448a:	3f e0       	ldi	r19, 0x0F	; 15
    448c:	0e 94 30 10 	call	0x2060	; 0x2060 <put_fat>
					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
    4490:	88 23       	and	r24, r24
    4492:	41 f4       	brne	.+16     	; 0x44a4 <f_truncate+0xe2>
    4494:	88 81       	ld	r24, Y
    4496:	99 81       	ldd	r25, Y+1	; 0x01
    4498:	b7 01       	movw	r22, r14
    449a:	a6 01       	movw	r20, r12
    449c:	0e 94 60 16 	call	0x2cc0	; 0x2cc0 <remove_chain>
				}
			}
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
    44a0:	88 23       	and	r24, r24
    44a2:	29 f0       	breq	.+10     	; 0x44ae <f_truncate+0xec>
    44a4:	9c 81       	ldd	r25, Y+4	; 0x04
    44a6:	90 68       	ori	r25, 0x80	; 128
    44a8:	9c 83       	std	Y+4, r25	; 0x04
    44aa:	01 c0       	rjmp	.+2      	; 0x44ae <f_truncate+0xec>
{
	FRESULT res;
	DWORD ncl;


	if (!fp) return FR_INVALID_OBJECT;
    44ac:	89 e0       	ldi	r24, 0x09	; 9
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
	}

	LEAVE_FF(fp->fs, res);
}
    44ae:	df 91       	pop	r29
    44b0:	cf 91       	pop	r28
    44b2:	1f 91       	pop	r17
    44b4:	0f 91       	pop	r16
    44b6:	ff 90       	pop	r15
    44b8:	ef 90       	pop	r14
    44ba:	df 90       	pop	r13
    44bc:	cf 90       	pop	r12
    44be:	08 95       	ret
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
				res = FR_DENIED;
		}
	}
	if (res == FR_OK) {
		if (fp->fsize > fp->fptr) {
    44c0:	4e 81       	ldd	r20, Y+6	; 0x06
    44c2:	5f 81       	ldd	r21, Y+7	; 0x07
    44c4:	68 85       	ldd	r22, Y+8	; 0x08
    44c6:	79 85       	ldd	r23, Y+9	; 0x09
    44c8:	0a 85       	ldd	r16, Y+10	; 0x0a
    44ca:	1b 85       	ldd	r17, Y+11	; 0x0b
    44cc:	2c 85       	ldd	r18, Y+12	; 0x0c
    44ce:	3d 85       	ldd	r19, Y+13	; 0x0d
    44d0:	40 17       	cp	r20, r16
    44d2:	51 07       	cpc	r21, r17
    44d4:	62 07       	cpc	r22, r18
    44d6:	73 07       	cpc	r23, r19
    44d8:	08 f4       	brcc	.+2      	; 0x44dc <f_truncate+0x11a>
    44da:	8d cf       	rjmp	.-230    	; 0x43f6 <f_truncate+0x34>
    44dc:	e8 cf       	rjmp	.-48     	; 0x44ae <f_truncate+0xec>
				fp->sclust = 0;
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
				res = FR_OK;
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
				if (ncl == 1) res = FR_INT_ERR;
    44de:	82 e0       	ldi	r24, 0x02	; 2
    44e0:	e1 cf       	rjmp	.-62     	; 0x44a4 <f_truncate+0xe2>

000044e2 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR *path		/* Pointer to the file or directory path */
)
{
    44e2:	cf 92       	push	r12
    44e4:	df 92       	push	r13
    44e6:	ef 92       	push	r14
    44e8:	ff 92       	push	r15
    44ea:	1f 93       	push	r17
    44ec:	cf 93       	push	r28
    44ee:	df 93       	push	r29
    44f0:	cd b7       	in	r28, 0x3d	; 61
    44f2:	de b7       	in	r29, 0x3e	; 62
    44f4:	ea 97       	sbiw	r28, 0x3a	; 58
    44f6:	0f b6       	in	r0, 0x3f	; 63
    44f8:	f8 94       	cli
    44fa:	de bf       	out	0x3e, r29	; 62
    44fc:	0f be       	out	0x3f, r0	; 63
    44fe:	cd bf       	out	0x3d, r28	; 61
    4500:	9a af       	sts	0x7a, r25
    4502:	89 af       	sts	0x79, r24
	BYTE *dir;
	DWORD dclst;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4504:	ce 01       	movw	r24, r28
    4506:	c9 96       	adiw	r24, 0x39	; 57
    4508:	be 01       	movw	r22, r28
    450a:	6f 5f       	subi	r22, 0xFF	; 255
    450c:	7f 4f       	sbci	r23, 0xFF	; 255
    450e:	41 e0       	ldi	r20, 0x01	; 1
    4510:	0e 94 79 08 	call	0x10f2	; 0x10f2 <chk_mounted>
	if (res == FR_OK) {
    4514:	88 23       	and	r24, r24
    4516:	09 f0       	breq	.+2      	; 0x451a <f_unlink+0x38>
    4518:	63 c0       	rjmp	.+198    	; 0x45e0 <f_unlink+0xfe>
		INIT_BUF(dj);
    451a:	ce 01       	movw	r24, r28
    451c:	8d 96       	adiw	r24, 0x2d	; 45
    451e:	9e 8b       	std	Y+22, r25	; 0x16
    4520:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the file path */
    4522:	69 ad       	sts	0x69, r22
    4524:	7a ad       	sts	0x6a, r23
    4526:	ce 01       	movw	r24, r28
    4528:	01 96       	adiw	r24, 0x01	; 1
    452a:	0e 94 a8 13 	call	0x2750	; 0x2750 <follow_path>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    452e:	88 23       	and	r24, r24
    4530:	09 f0       	breq	.+2      	; 0x4534 <f_unlink+0x52>
    4532:	56 c0       	rjmp	.+172    	; 0x45e0 <f_unlink+0xfe>
    4534:	ed 89       	ldd	r30, Y+21	; 0x15
    4536:	fe 89       	ldd	r31, Y+22	; 0x16
    4538:	83 85       	ldd	r24, Z+11	; 0x0b
    453a:	85 ff       	sbrs	r24, 5
    453c:	5f c0       	rjmp	.+190    	; 0x45fc <f_unlink+0x11a>
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
    453e:	86 e0       	ldi	r24, 0x06	; 6
    4540:	4f c0       	rjmp	.+158    	; 0x45e0 <f_unlink+0xfe>
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
    4542:	fb 01       	movw	r30, r22
    4544:	13 85       	ldd	r17, Z+11	; 0x0b
    4546:	10 ff       	sbrs	r17, 0
    4548:	60 c0       	rjmp	.+192    	; 0x460a <f_unlink+0x128>
					res = FR_DENIED;		/* Cannot remove R/O object */
    454a:	87 e0       	ldi	r24, 0x07	; 7
    454c:	49 c0       	rjmp	.+146    	; 0x45e0 <f_unlink+0xfe>
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
    454e:	86 e0       	ldi	r24, 0x06	; 6
    4550:	47 c0       	rjmp	.+142    	; 0x45e0 <f_unlink+0xfe>
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = ld_clust(dj.fs, dir);
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
				if (dclst < 2) {
    4552:	f2 e0       	ldi	r31, 0x02	; 2
    4554:	cf 16       	cp	r12, r31
    4556:	d1 04       	cpc	r13, r1
    4558:	e1 04       	cpc	r14, r1
    455a:	f1 04       	cpc	r15, r1
    455c:	08 f4       	brcc	.+2      	; 0x4560 <f_unlink+0x7e>
    455e:	5e c0       	rjmp	.+188    	; 0x461c <f_unlink+0x13a>
					res = FR_INT_ERR;
				} else {
					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
    4560:	ce 01       	movw	r24, r28
    4562:	47 96       	adiw	r24, 0x17	; 23
    4564:	be 01       	movw	r22, r28
    4566:	6f 5f       	subi	r22, 0xFF	; 255
    4568:	7f 4f       	sbci	r23, 0xFF	; 255
    456a:	26 e1       	ldi	r18, 0x16	; 22
    456c:	30 e0       	ldi	r19, 0x00	; 0
    456e:	40 e0       	ldi	r20, 0x00	; 0
    4570:	50 e0       	ldi	r21, 0x00	; 0
    4572:	0e 94 d6 06 	call	0xdac	; 0xdac <mem_cpy>
					sdj.sclust = dclst;
    4576:	cd 8e       	std	Y+29, r12	; 0x1d
    4578:	de 8e       	std	Y+30, r13	; 0x1e
    457a:	ef 8e       	std	Y+31, r14	; 0x1f
    457c:	f8 a2       	lds	r31, 0x98
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
    457e:	ce 01       	movw	r24, r28
    4580:	47 96       	adiw	r24, 0x17	; 23
    4582:	62 e0       	ldi	r22, 0x02	; 2
    4584:	70 e0       	ldi	r23, 0x00	; 0
    4586:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <dir_sdi>
					if (res == FR_OK) {
    458a:	88 23       	and	r24, r24
    458c:	49 f5       	brne	.+82     	; 0x45e0 <f_unlink+0xfe>
						res = dir_read(&sdj);
    458e:	ce 01       	movw	r24, r28
    4590:	47 96       	adiw	r24, 0x17	; 23
    4592:	0e 94 30 16 	call	0x2c60	; 0x2c60 <dir_read>
						if (res == FR_OK		/* Not empty dir */
    4596:	88 23       	and	r24, r24
    4598:	71 f0       	breq	.+28     	; 0x45b6 <f_unlink+0xd4>
#if _FS_RPATH
						|| dclst == dj.fs->cdir	/* Current dir */
    459a:	e9 81       	ldd	r30, Y+1	; 0x01
    459c:	fa 81       	ldd	r31, Y+2	; 0x02
    459e:	46 89       	ldd	r20, Z+22	; 0x16
    45a0:	57 89       	ldd	r21, Z+23	; 0x17
    45a2:	60 8d       	ldd	r22, Z+24	; 0x18
    45a4:	71 8d       	ldd	r23, Z+25	; 0x19
    45a6:	4c 15       	cp	r20, r12
    45a8:	5d 05       	cpc	r21, r13
    45aa:	6e 05       	cpc	r22, r14
    45ac:	7f 05       	cpc	r23, r15
    45ae:	29 f0       	breq	.+10     	; 0x45ba <f_unlink+0xd8>
#endif
						) res = FR_DENIED;
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
    45b0:	84 30       	cpi	r24, 0x04	; 4
    45b2:	b1 f1       	breq	.+108    	; 0x4620 <f_unlink+0x13e>
    45b4:	15 c0       	rjmp	.+42     	; 0x45e0 <f_unlink+0xfe>
					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
					sdj.sclust = dclst;
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
					if (res == FR_OK) {
						res = dir_read(&sdj);
						if (res == FR_OK		/* Not empty dir */
    45b6:	87 e0       	ldi	r24, 0x07	; 7
    45b8:	13 c0       	rjmp	.+38     	; 0x45e0 <f_unlink+0xfe>
#if _FS_RPATH
						|| dclst == dj.fs->cdir	/* Current dir */
    45ba:	87 e0       	ldi	r24, 0x07	; 7
    45bc:	11 c0       	rjmp	.+34     	; 0x45e0 <f_unlink+0xfe>
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
				if (res == FR_OK) {
					if (dclst)				/* Remove the cluster chain if exist */
    45be:	c1 14       	cp	r12, r1
    45c0:	d1 04       	cpc	r13, r1
    45c2:	e1 04       	cpc	r14, r1
    45c4:	f1 04       	cpc	r15, r1
    45c6:	41 f0       	breq	.+16     	; 0x45d8 <f_unlink+0xf6>
						res = remove_chain(dj.fs, dclst);
    45c8:	89 81       	ldd	r24, Y+1	; 0x01
    45ca:	9a 81       	ldd	r25, Y+2	; 0x02
    45cc:	b7 01       	movw	r22, r14
    45ce:	a6 01       	movw	r20, r12
    45d0:	0e 94 60 16 	call	0x2cc0	; 0x2cc0 <remove_chain>
					if (res == FR_OK) res = sync(dj.fs);
    45d4:	88 23       	and	r24, r24
    45d6:	21 f4       	brne	.+8      	; 0x45e0 <f_unlink+0xfe>
    45d8:	89 81       	ldd	r24, Y+1	; 0x01
    45da:	9a 81       	ldd	r25, Y+2	; 0x02
    45dc:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <sync>
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(dj.fs, res);
}
    45e0:	ea 96       	adiw	r28, 0x3a	; 58
    45e2:	0f b6       	in	r0, 0x3f	; 63
    45e4:	f8 94       	cli
    45e6:	de bf       	out	0x3e, r29	; 62
    45e8:	0f be       	out	0x3f, r0	; 63
    45ea:	cd bf       	out	0x3d, r28	; 61
    45ec:	df 91       	pop	r29
    45ee:	cf 91       	pop	r28
    45f0:	1f 91       	pop	r17
    45f2:	ff 90       	pop	r15
    45f4:	ef 90       	pop	r14
    45f6:	df 90       	pop	r13
    45f8:	cf 90       	pop	r12
    45fa:	08 95       	ret
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
    45fc:	6b 89       	ldd	r22, Y+19	; 0x13
    45fe:	7c 89       	ldd	r23, Y+20	; 0x14
			if (!dir) {
    4600:	61 15       	cp	r22, r1
    4602:	71 05       	cpc	r23, r1
    4604:	09 f0       	breq	.+2      	; 0x4608 <f_unlink+0x126>
    4606:	9d cf       	rjmp	.-198    	; 0x4542 <f_unlink+0x60>
    4608:	a2 cf       	rjmp	.-188    	; 0x454e <f_unlink+0x6c>
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = ld_clust(dj.fs, dir);
    460a:	89 81       	ldd	r24, Y+1	; 0x01
    460c:	9a 81       	ldd	r25, Y+2	; 0x02
    460e:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <ld_clust>
    4612:	6b 01       	movw	r12, r22
    4614:	7c 01       	movw	r14, r24
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
    4616:	14 fd       	sbrc	r17, 4
    4618:	9c cf       	rjmp	.-200    	; 0x4552 <f_unlink+0x70>
    461a:	02 c0       	rjmp	.+4      	; 0x4620 <f_unlink+0x13e>
				if (dclst < 2) {
					res = FR_INT_ERR;
    461c:	82 e0       	ldi	r24, 0x02	; 2
    461e:	e0 cf       	rjmp	.-64     	; 0x45e0 <f_unlink+0xfe>
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
    4620:	ce 01       	movw	r24, r28
    4622:	01 96       	adiw	r24, 0x01	; 1
    4624:	0e 94 12 10 	call	0x2024	; 0x2024 <dir_remove>
				if (res == FR_OK) {
    4628:	88 23       	and	r24, r24
    462a:	49 f2       	breq	.-110    	; 0x45be <f_unlink+0xdc>
    462c:	d9 cf       	rjmp	.-78     	; 0x45e0 <f_unlink+0xfe>

0000462e <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR *path		/* Pointer to the directory path */
)
{
    462e:	2f 92       	push	r2
    4630:	3f 92       	push	r3
    4632:	4f 92       	push	r4
    4634:	5f 92       	push	r5
    4636:	6f 92       	push	r6
    4638:	7f 92       	push	r7
    463a:	8f 92       	push	r8
    463c:	9f 92       	push	r9
    463e:	af 92       	push	r10
    4640:	bf 92       	push	r11
    4642:	cf 92       	push	r12
    4644:	df 92       	push	r13
    4646:	ef 92       	push	r14
    4648:	ff 92       	push	r15
    464a:	0f 93       	push	r16
    464c:	1f 93       	push	r17
    464e:	cf 93       	push	r28
    4650:	df 93       	push	r29
    4652:	cd b7       	in	r28, 0x3d	; 61
    4654:	de b7       	in	r29, 0x3e	; 62
    4656:	a8 97       	sbiw	r28, 0x28	; 40
    4658:	0f b6       	in	r0, 0x3f	; 63
    465a:	f8 94       	cli
    465c:	de bf       	out	0x3e, r29	; 62
    465e:	0f be       	out	0x3f, r0	; 63
    4660:	cd bf       	out	0x3d, r28	; 61
    4662:	9c a3       	lds	r25, 0x5c
    4664:	8b a3       	lds	r24, 0x5b
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tim = get_fattime();
    4666:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <get_fattime>
    466a:	6b 01       	movw	r12, r22
    466c:	7c 01       	movw	r14, r24
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    466e:	ce 01       	movw	r24, r28
    4670:	83 96       	adiw	r24, 0x23	; 35
    4672:	be 01       	movw	r22, r28
    4674:	6f 5f       	subi	r22, 0xFF	; 255
    4676:	7f 4f       	sbci	r23, 0xFF	; 255
    4678:	41 e0       	ldi	r20, 0x01	; 1
    467a:	0e 94 79 08 	call	0x10f2	; 0x10f2 <chk_mounted>
    467e:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    4680:	88 23       	and	r24, r24
    4682:	09 f0       	breq	.+2      	; 0x4686 <f_mkdir+0x58>
    4684:	f6 c0       	rjmp	.+492    	; 0x4872 <f_mkdir+0x244>
		INIT_BUF(dj);
    4686:	ce 01       	movw	r24, r28
    4688:	47 96       	adiw	r24, 0x17	; 23
    468a:	9e 8b       	std	Y+22, r25	; 0x16
    468c:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);			/* Follow the file path */
    468e:	6b a1       	lds	r22, 0x4b
    4690:	7c a1       	lds	r23, 0x4c
    4692:	ce 01       	movw	r24, r28
    4694:	01 96       	adiw	r24, 0x01	; 1
    4696:	0e 94 a8 13 	call	0x2750	; 0x2750 <follow_path>
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
    469a:	88 23       	and	r24, r24
    469c:	49 f0       	breq	.+18     	; 0x46b0 <f_mkdir+0x82>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
    469e:	84 30       	cpi	r24, 0x04	; 4
    46a0:	41 f4       	brne	.+16     	; 0x46b2 <f_mkdir+0x84>
    46a2:	ed 89       	ldd	r30, Y+21	; 0x15
    46a4:	fe 89       	ldd	r31, Y+22	; 0x16
    46a6:	83 85       	ldd	r24, Z+11	; 0x0b
    46a8:	85 ff       	sbrs	r24, 5
    46aa:	fd c0       	rjmp	.+506    	; 0x48a6 <f_mkdir+0x278>
			res = FR_INVALID_NAME;
    46ac:	86 e0       	ldi	r24, 0x06	; 6
    46ae:	01 c0       	rjmp	.+2      	; 0x46b2 <f_mkdir+0x84>

	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
    46b0:	88 e0       	ldi	r24, 0x08	; 8
				ST_DWORD(dir+DIR_WrtTime, tim);
				st_clust(dir, dcl);
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
    46b2:	18 2f       	mov	r17, r24
    46b4:	de c0       	rjmp	.+444    	; 0x4872 <f_mkdir+0x244>
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
			if (dcl == 1) res = FR_INT_ERR;
    46b6:	81 e0       	ldi	r24, 0x01	; 1
    46b8:	48 16       	cp	r4, r24
    46ba:	51 04       	cpc	r5, r1
    46bc:	61 04       	cpc	r6, r1
    46be:	71 04       	cpc	r7, r1
    46c0:	09 f4       	brne	.+2      	; 0x46c4 <f_mkdir+0x96>
    46c2:	01 c1       	rjmp	.+514    	; 0x48c6 <f_mkdir+0x298>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
    46c4:	ef ef       	ldi	r30, 0xFF	; 255
    46c6:	4e 16       	cp	r4, r30
    46c8:	ef ef       	ldi	r30, 0xFF	; 255
    46ca:	5e 06       	cpc	r5, r30
    46cc:	ef ef       	ldi	r30, 0xFF	; 255
    46ce:	6e 06       	cpc	r6, r30
    46d0:	ef ef       	ldi	r30, 0xFF	; 255
    46d2:	7e 06       	cpc	r7, r30
    46d4:	09 f4       	brne	.+2      	; 0x46d8 <f_mkdir+0xaa>
    46d6:	f9 c0       	rjmp	.+498    	; 0x48ca <f_mkdir+0x29c>
    46d8:	01 c0       	rjmp	.+2      	; 0x46dc <f_mkdir+0xae>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
    46da:	17 e0       	ldi	r17, 0x07	; 7
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
			if (res == FR_OK)					/* Flush FAT */
    46dc:	11 23       	and	r17, r17
    46de:	09 f0       	breq	.+2      	; 0x46e2 <f_mkdir+0xb4>
    46e0:	a8 c0       	rjmp	.+336    	; 0x4832 <f_mkdir+0x204>
				res = move_window(dj.fs, 0);
    46e2:	89 81       	ldd	r24, Y+1	; 0x01
    46e4:	9a 81       	ldd	r25, Y+2	; 0x02
    46e6:	40 e0       	ldi	r20, 0x00	; 0
    46e8:	50 e0       	ldi	r21, 0x00	; 0
    46ea:	ba 01       	movw	r22, r20
    46ec:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
    46f0:	18 2f       	mov	r17, r24
			if (res == FR_OK) {					/* Initialize the new directory table */
    46f2:	88 23       	and	r24, r24
    46f4:	09 f0       	breq	.+2      	; 0x46f8 <f_mkdir+0xca>
    46f6:	9d c0       	rjmp	.+314    	; 0x4832 <f_mkdir+0x204>
				dsc = clust2sect(dj.fs, dcl);
    46f8:	09 81       	ldd	r16, Y+1	; 0x01
    46fa:	1a 81       	ldd	r17, Y+2	; 0x02
    46fc:	c8 01       	movw	r24, r16
    46fe:	b3 01       	movw	r22, r6
    4700:	a2 01       	movw	r20, r4
    4702:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <clust2sect>
    4706:	4b 01       	movw	r8, r22
    4708:	5c 01       	movw	r10, r24
				dir = dj.fs->win;
    470a:	0f 2e       	mov	r0, r31
    470c:	f2 e3       	ldi	r31, 0x32	; 50
    470e:	2f 2e       	mov	r2, r31
    4710:	33 24       	eor	r3, r3
    4712:	f0 2d       	mov	r31, r0
    4714:	20 0e       	add	r2, r16
    4716:	31 1e       	adc	r3, r17
				mem_set(dir, 0, SS(dj.fs));
    4718:	c1 01       	movw	r24, r2
    471a:	60 e0       	ldi	r22, 0x00	; 0
    471c:	70 e0       	ldi	r23, 0x00	; 0
    471e:	20 e0       	ldi	r18, 0x00	; 0
    4720:	32 e0       	ldi	r19, 0x02	; 2
    4722:	40 e0       	ldi	r20, 0x00	; 0
    4724:	50 e0       	ldi	r21, 0x00	; 0
    4726:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <mem_set>
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
    472a:	c1 01       	movw	r24, r2
    472c:	60 e2       	ldi	r22, 0x20	; 32
    472e:	70 e0       	ldi	r23, 0x00	; 0
    4730:	2b e0       	ldi	r18, 0x0B	; 11
    4732:	30 e0       	ldi	r19, 0x00	; 0
    4734:	40 e0       	ldi	r20, 0x00	; 0
    4736:	50 e0       	ldi	r21, 0x00	; 0
    4738:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <mem_set>
				dir[DIR_Name] = '.';
    473c:	8e e2       	ldi	r24, 0x2E	; 46
    473e:	f8 01       	movw	r30, r16
    4740:	82 ab       	sts	0x52, r24
				dir[DIR_Attr] = AM_DIR;
    4742:	80 e1       	ldi	r24, 0x10	; 16
    4744:	85 af       	sts	0x75, r24
				ST_DWORD(dir+DIR_WrtTime, tim);
    4746:	cd a2       	lds	r28, 0x9d
    4748:	e8 5b       	subi	r30, 0xB8	; 184
    474a:	ff 4f       	sbci	r31, 0xFF	; 255
    474c:	c0 82       	st	Z, r12
    474e:	8d 2d       	mov	r24, r13
    4750:	99 27       	eor	r25, r25
    4752:	8e a3       	lds	r24, 0x5e
    4754:	f8 01       	movw	r30, r16
    4756:	e7 5b       	subi	r30, 0xB7	; 183
    4758:	ff 4f       	sbci	r31, 0xFF	; 255
    475a:	80 83       	st	Z, r24
    475c:	c7 01       	movw	r24, r14
    475e:	aa 27       	eor	r26, r26
    4760:	bb 27       	eor	r27, r27
    4762:	8f a3       	lds	r24, 0x5f
    4764:	f8 01       	movw	r30, r16
    4766:	e6 5b       	subi	r30, 0xB6	; 182
    4768:	ff 4f       	sbci	r31, 0xFF	; 255
    476a:	80 83       	st	Z, r24
    476c:	cf 2c       	mov	r12, r15
    476e:	dd 24       	eor	r13, r13
    4770:	ee 24       	eor	r14, r14
    4772:	ff 24       	eor	r15, r15
    4774:	c8 a6       	lds	r28, 0xb8
    4776:	f8 01       	movw	r30, r16
    4778:	e5 5b       	subi	r30, 0xB5	; 181
    477a:	ff 4f       	sbci	r31, 0xFF	; 255
    477c:	c0 82       	st	Z, r12
				st_clust(dir, dcl);
    477e:	c1 01       	movw	r24, r2
    4780:	b3 01       	movw	r22, r6
    4782:	a2 01       	movw	r20, r4
    4784:	0e 94 21 07 	call	0xe42	; 0xe42 <st_clust>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
    4788:	0f 2e       	mov	r0, r31
    478a:	f2 e5       	ldi	r31, 0x52	; 82
    478c:	cf 2e       	mov	r12, r31
    478e:	dd 24       	eor	r13, r13
    4790:	f0 2d       	mov	r31, r0
    4792:	c0 0e       	add	r12, r16
    4794:	d1 1e       	adc	r13, r17
    4796:	c6 01       	movw	r24, r12
    4798:	b1 01       	movw	r22, r2
    479a:	20 e2       	ldi	r18, 0x20	; 32
    479c:	30 e0       	ldi	r19, 0x00	; 0
    479e:	40 e0       	ldi	r20, 0x00	; 0
    47a0:	50 e0       	ldi	r21, 0x00	; 0
    47a2:	0e 94 d6 06 	call	0xdac	; 0xdac <mem_cpy>
				dir[33] = '.'; pcl = dj.sclust;
    47a6:	f8 01       	movw	r30, r16
    47a8:	ed 5a       	subi	r30, 0xAD	; 173
    47aa:	ff 4f       	sbci	r31, 0xFF	; 255
    47ac:	8e e2       	ldi	r24, 0x2E	; 46
    47ae:	80 83       	st	Z, r24
    47b0:	4f 81       	ldd	r20, Y+7	; 0x07
    47b2:	58 85       	ldd	r21, Y+8	; 0x08
    47b4:	69 85       	ldd	r22, Y+9	; 0x09
    47b6:	7a 85       	ldd	r23, Y+10	; 0x0a
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
    47b8:	e9 81       	ldd	r30, Y+1	; 0x01
    47ba:	fa 81       	ldd	r31, Y+2	; 0x02
    47bc:	80 81       	ld	r24, Z
    47be:	83 30       	cpi	r24, 0x03	; 3
    47c0:	61 f4       	brne	.+24     	; 0x47da <f_mkdir+0x1ac>
    47c2:	86 a1       	lds	r24, 0x46
    47c4:	97 a1       	lds	r25, 0x47
    47c6:	a0 a5       	lds	r26, 0x60
    47c8:	b1 a5       	lds	r27, 0x61
    47ca:	84 17       	cp	r24, r20
    47cc:	95 07       	cpc	r25, r21
    47ce:	a6 07       	cpc	r26, r22
    47d0:	b7 07       	cpc	r27, r23
    47d2:	19 f4       	brne	.+6      	; 0x47da <f_mkdir+0x1ac>
					pcl = 0;
    47d4:	40 e0       	ldi	r20, 0x00	; 0
    47d6:	50 e0       	ldi	r21, 0x00	; 0
    47d8:	ba 01       	movw	r22, r20
				st_clust(dir+SZ_DIR, pcl);
    47da:	c6 01       	movw	r24, r12
    47dc:	0e 94 21 07 	call	0xe42	; 0xe42 <st_clust>
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
    47e0:	e9 81       	ldd	r30, Y+1	; 0x01
    47e2:	fa 81       	ldd	r31, Y+2	; 0x02
    47e4:	02 81       	ldd	r16, Z+2	; 0x02
    47e6:	00 23       	and	r16, r16
    47e8:	09 f4       	brne	.+2      	; 0x47ec <f_mkdir+0x1be>
    47ea:	71 c0       	rjmp	.+226    	; 0x48ce <f_mkdir+0x2a0>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
    47ec:	cc 24       	eor	r12, r12
    47ee:	c3 94       	inc	r12
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
    47f0:	89 81       	ldd	r24, Y+1	; 0x01
    47f2:	9a 81       	ldd	r25, Y+2	; 0x02
    47f4:	fc 01       	movw	r30, r24
    47f6:	86 a6       	lds	r24, 0xb6
    47f8:	97 a6       	lds	r25, 0xb7
    47fa:	a0 aa       	sts	0x90, r26
    47fc:	b1 aa       	sts	0x91, r27
    47fe:	08 94       	sec
    4800:	81 1c       	adc	r8, r1
    4802:	91 1c       	adc	r9, r1
    4804:	a1 1c       	adc	r10, r1
    4806:	b1 1c       	adc	r11, r1
					dj.fs->wflag = 1;
    4808:	c4 82       	std	Z+4, r12	; 0x04
					res = move_window(dj.fs, 0);
    480a:	40 e0       	ldi	r20, 0x00	; 0
    480c:	50 e0       	ldi	r21, 0x00	; 0
    480e:	ba 01       	movw	r22, r20
    4810:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
    4814:	18 2f       	mov	r17, r24
					if (res != FR_OK) break;
    4816:	88 23       	and	r24, r24
    4818:	61 f4       	brne	.+24     	; 0x4832 <f_mkdir+0x204>
					mem_set(dir, 0, SS(dj.fs));
    481a:	c1 01       	movw	r24, r2
    481c:	60 e0       	ldi	r22, 0x00	; 0
    481e:	70 e0       	ldi	r23, 0x00	; 0
    4820:	20 e0       	ldi	r18, 0x00	; 0
    4822:	32 e0       	ldi	r19, 0x02	; 2
    4824:	40 e0       	ldi	r20, 0x00	; 0
    4826:	50 e0       	ldi	r21, 0x00	; 0
    4828:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <mem_set>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
    482c:	01 50       	subi	r16, 0x01	; 1
    482e:	01 f7       	brne	.-64     	; 0x47f0 <f_mkdir+0x1c2>
    4830:	4e c0       	rjmp	.+156    	; 0x48ce <f_mkdir+0x2a0>
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
    4832:	89 81       	ldd	r24, Y+1	; 0x01
    4834:	9a 81       	ldd	r25, Y+2	; 0x02
    4836:	b3 01       	movw	r22, r6
    4838:	a2 01       	movw	r20, r4
    483a:	0e 94 60 16 	call	0x2cc0	; 0x2cc0 <remove_chain>
    483e:	19 c0       	rjmp	.+50     	; 0x4872 <f_mkdir+0x244>
			} else {
				dir = dj.dir;
    4840:	eb 89       	ldd	r30, Y+19	; 0x13
    4842:	fc 89       	ldd	r31, Y+20	; 0x14
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
    4844:	80 e1       	ldi	r24, 0x10	; 16
    4846:	83 87       	std	Z+11, r24	; 0x0b
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
    4848:	8d a1       	lds	r24, 0x4d
    484a:	86 8b       	std	Z+22, r24	; 0x16
    484c:	8e a1       	lds	r24, 0x4e
    484e:	87 8b       	std	Z+23, r24	; 0x17
    4850:	8f a1       	lds	r24, 0x4f
    4852:	80 8f       	std	Z+24, r24	; 0x18
    4854:	88 a5       	lds	r24, 0x68
    4856:	81 8f       	std	Z+25, r24	; 0x19
				st_clust(dir, dcl);					/* Table start cluster */
    4858:	cf 01       	movw	r24, r30
    485a:	b3 01       	movw	r22, r6
    485c:	a2 01       	movw	r20, r4
    485e:	0e 94 21 07 	call	0xe42	; 0xe42 <st_clust>
				dj.fs->wflag = 1;
    4862:	89 81       	ldd	r24, Y+1	; 0x01
    4864:	9a 81       	ldd	r25, Y+2	; 0x02
    4866:	21 e0       	ldi	r18, 0x01	; 1
    4868:	fc 01       	movw	r30, r24
    486a:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    486c:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <sync>
    4870:	18 2f       	mov	r17, r24
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    4872:	81 2f       	mov	r24, r17
    4874:	a8 96       	adiw	r28, 0x28	; 40
    4876:	0f b6       	in	r0, 0x3f	; 63
    4878:	f8 94       	cli
    487a:	de bf       	out	0x3e, r29	; 62
    487c:	0f be       	out	0x3f, r0	; 63
    487e:	cd bf       	out	0x3d, r28	; 61
    4880:	df 91       	pop	r29
    4882:	cf 91       	pop	r28
    4884:	1f 91       	pop	r17
    4886:	0f 91       	pop	r16
    4888:	ff 90       	pop	r15
    488a:	ef 90       	pop	r14
    488c:	df 90       	pop	r13
    488e:	cf 90       	pop	r12
    4890:	bf 90       	pop	r11
    4892:	af 90       	pop	r10
    4894:	9f 90       	pop	r9
    4896:	8f 90       	pop	r8
    4898:	7f 90       	pop	r7
    489a:	6f 90       	pop	r6
    489c:	5f 90       	pop	r5
    489e:	4f 90       	pop	r4
    48a0:	3f 90       	pop	r3
    48a2:	2f 90       	pop	r2
    48a4:	08 95       	ret
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
    48a6:	89 81       	ldd	r24, Y+1	; 0x01
    48a8:	9a 81       	ldd	r25, Y+2	; 0x02
    48aa:	40 e0       	ldi	r20, 0x00	; 0
    48ac:	50 e0       	ldi	r21, 0x00	; 0
    48ae:	ba 01       	movw	r22, r20
    48b0:	0e 94 3f 11 	call	0x227e	; 0x227e <create_chain>
    48b4:	2b 01       	movw	r4, r22
    48b6:	3c 01       	movw	r6, r24
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
    48b8:	61 15       	cp	r22, r1
    48ba:	71 05       	cpc	r23, r1
    48bc:	81 05       	cpc	r24, r1
    48be:	91 05       	cpc	r25, r1
    48c0:	09 f4       	brne	.+2      	; 0x48c4 <f_mkdir+0x296>
    48c2:	0b cf       	rjmp	.-490    	; 0x46da <f_mkdir+0xac>
    48c4:	f8 ce       	rjmp	.-528    	; 0x46b6 <f_mkdir+0x88>
			if (dcl == 1) res = FR_INT_ERR;
    48c6:	12 e0       	ldi	r17, 0x02	; 2
    48c8:	b4 cf       	rjmp	.-152    	; 0x4832 <f_mkdir+0x204>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
    48ca:	11 e0       	ldi	r17, 0x01	; 1
    48cc:	b2 cf       	rjmp	.-156    	; 0x4832 <f_mkdir+0x204>
					res = move_window(dj.fs, 0);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
    48ce:	ce 01       	movw	r24, r28
    48d0:	01 96       	adiw	r24, 0x01	; 1
    48d2:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <dir_register>
    48d6:	18 2f       	mov	r17, r24
			if (res != FR_OK) {
    48d8:	88 23       	and	r24, r24
    48da:	09 f4       	brne	.+2      	; 0x48de <f_mkdir+0x2b0>
    48dc:	b1 cf       	rjmp	.-158    	; 0x4840 <f_mkdir+0x212>
    48de:	a9 cf       	rjmp	.-174    	; 0x4832 <f_mkdir+0x204>

000048e0 <f_chmod>:
FRESULT f_chmod (
	const TCHAR *path,	/* Pointer to the file path */
	BYTE value,			/* Attribute bits */
	BYTE mask			/* Attribute mask to change */
)
{
    48e0:	0f 93       	push	r16
    48e2:	1f 93       	push	r17
    48e4:	cf 93       	push	r28
    48e6:	df 93       	push	r29
    48e8:	cd b7       	in	r28, 0x3d	; 61
    48ea:	de b7       	in	r29, 0x3e	; 62
    48ec:	a4 97       	sbiw	r28, 0x24	; 36
    48ee:	0f b6       	in	r0, 0x3f	; 63
    48f0:	f8 94       	cli
    48f2:	de bf       	out	0x3e, r29	; 62
    48f4:	0f be       	out	0x3f, r0	; 63
    48f6:	cd bf       	out	0x3d, r28	; 61
    48f8:	9c a3       	lds	r25, 0x5c
    48fa:	8b a3       	lds	r24, 0x5b
    48fc:	06 2f       	mov	r16, r22
    48fe:	14 2f       	mov	r17, r20
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    4900:	ce 01       	movw	r24, r28
    4902:	83 96       	adiw	r24, 0x23	; 35
    4904:	be 01       	movw	r22, r28
    4906:	6f 5f       	subi	r22, 0xFF	; 255
    4908:	7f 4f       	sbci	r23, 0xFF	; 255
    490a:	41 e0       	ldi	r20, 0x01	; 1
    490c:	0e 94 79 08 	call	0x10f2	; 0x10f2 <chk_mounted>
	if (res == FR_OK) {
    4910:	88 23       	and	r24, r24
    4912:	29 f5       	brne	.+74     	; 0x495e <f_chmod+0x7e>
		INIT_BUF(dj);
    4914:	ce 01       	movw	r24, r28
    4916:	47 96       	adiw	r24, 0x17	; 23
    4918:	9e 8b       	std	Y+22, r25	; 0x16
    491a:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);		/* Follow the file path */
    491c:	6b a1       	lds	r22, 0x4b
    491e:	7c a1       	lds	r23, 0x4c
    4920:	ce 01       	movw	r24, r28
    4922:	01 96       	adiw	r24, 0x01	; 1
    4924:	0e 94 a8 13 	call	0x2750	; 0x2750 <follow_path>
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    4928:	88 23       	and	r24, r24
    492a:	c9 f4       	brne	.+50     	; 0x495e <f_chmod+0x7e>
    492c:	ed 89       	ldd	r30, Y+21	; 0x15
    492e:	fe 89       	ldd	r31, Y+22	; 0x16
    4930:	83 85       	ldd	r24, Z+11	; 0x0b
    4932:	85 ff       	sbrs	r24, 5
    4934:	1f c0       	rjmp	.+62     	; 0x4974 <f_chmod+0x94>
			res = FR_INVALID_NAME;
    4936:	86 e0       	ldi	r24, 0x06	; 6
    4938:	12 c0       	rjmp	.+36     	; 0x495e <f_chmod+0x7e>
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
			} else {						/* File or sub directory */
				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
    493a:	17 72       	andi	r17, 0x27	; 39
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
    493c:	91 2f       	mov	r25, r17
    493e:	90 95       	com	r25
    4940:	83 85       	ldd	r24, Z+11	; 0x0b
    4942:	89 23       	and	r24, r25
    4944:	01 23       	and	r16, r17
    4946:	18 2f       	mov	r17, r24
    4948:	10 2b       	or	r17, r16
    494a:	13 87       	std	Z+11, r17	; 0x0b
				dj.fs->wflag = 1;
    494c:	89 81       	ldd	r24, Y+1	; 0x01
    494e:	9a 81       	ldd	r25, Y+2	; 0x02
    4950:	21 e0       	ldi	r18, 0x01	; 1
    4952:	fc 01       	movw	r30, r24
    4954:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    4956:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <sync>
    495a:	01 c0       	rjmp	.+2      	; 0x495e <f_chmod+0x7e>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {						/* Is it a root directory? */
				res = FR_INVALID_NAME;
    495c:	86 e0       	ldi	r24, 0x06	; 6
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
    495e:	a4 96       	adiw	r28, 0x24	; 36
    4960:	0f b6       	in	r0, 0x3f	; 63
    4962:	f8 94       	cli
    4964:	de bf       	out	0x3e, r29	; 62
    4966:	0f be       	out	0x3f, r0	; 63
    4968:	cd bf       	out	0x3d, r28	; 61
    496a:	df 91       	pop	r29
    496c:	cf 91       	pop	r28
    496e:	1f 91       	pop	r17
    4970:	0f 91       	pop	r16
    4972:	08 95       	ret
		res = follow_path(&dj, path);		/* Follow the file path */
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
    4974:	eb 89       	ldd	r30, Y+19	; 0x13
    4976:	fc 89       	ldd	r31, Y+20	; 0x14
			if (!dir) {						/* Is it a root directory? */
    4978:	30 97       	sbiw	r30, 0x00	; 0
    497a:	f9 f6       	brne	.-66     	; 0x493a <f_chmod+0x5a>
    497c:	ef cf       	rjmp	.-34     	; 0x495c <f_chmod+0x7c>

0000497e <f_utime>:

FRESULT f_utime (
	const TCHAR *path,	/* Pointer to the file/directory name */
	const FILINFO *fno	/* Pointer to the time stamp to be set */
)
{
    497e:	0f 93       	push	r16
    4980:	1f 93       	push	r17
    4982:	cf 93       	push	r28
    4984:	df 93       	push	r29
    4986:	cd b7       	in	r28, 0x3d	; 61
    4988:	de b7       	in	r29, 0x3e	; 62
    498a:	a4 97       	sbiw	r28, 0x24	; 36
    498c:	0f b6       	in	r0, 0x3f	; 63
    498e:	f8 94       	cli
    4990:	de bf       	out	0x3e, r29	; 62
    4992:	0f be       	out	0x3f, r0	; 63
    4994:	cd bf       	out	0x3d, r28	; 61
    4996:	9c a3       	lds	r25, 0x5c
    4998:	8b a3       	lds	r24, 0x5b
    499a:	8b 01       	movw	r16, r22
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
    499c:	ce 01       	movw	r24, r28
    499e:	83 96       	adiw	r24, 0x23	; 35
    49a0:	be 01       	movw	r22, r28
    49a2:	6f 5f       	subi	r22, 0xFF	; 255
    49a4:	7f 4f       	sbci	r23, 0xFF	; 255
    49a6:	41 e0       	ldi	r20, 0x01	; 1
    49a8:	0e 94 79 08 	call	0x10f2	; 0x10f2 <chk_mounted>
	if (res == FR_OK) {
    49ac:	88 23       	and	r24, r24
    49ae:	61 f5       	brne	.+88     	; 0x4a08 <f_utime+0x8a>
		INIT_BUF(dj);
    49b0:	ce 01       	movw	r24, r28
    49b2:	47 96       	adiw	r24, 0x17	; 23
    49b4:	9e 8b       	std	Y+22, r25	; 0x16
    49b6:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    49b8:	6b a1       	lds	r22, 0x4b
    49ba:	7c a1       	lds	r23, 0x4c
    49bc:	ce 01       	movw	r24, r28
    49be:	01 96       	adiw	r24, 0x01	; 1
    49c0:	0e 94 a8 13 	call	0x2750	; 0x2750 <follow_path>
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
    49c4:	88 23       	and	r24, r24
    49c6:	01 f5       	brne	.+64     	; 0x4a08 <f_utime+0x8a>
    49c8:	ed 89       	ldd	r30, Y+21	; 0x15
    49ca:	fe 89       	ldd	r31, Y+22	; 0x16
    49cc:	83 85       	ldd	r24, Z+11	; 0x0b
    49ce:	85 ff       	sbrs	r24, 5
    49d0:	26 c0       	rjmp	.+76     	; 0x4a1e <f_utime+0xa0>
			res = FR_INVALID_NAME;
    49d2:	86 e0       	ldi	r24, 0x06	; 6
    49d4:	19 c0       	rjmp	.+50     	; 0x4a08 <f_utime+0x8a>
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {					/* Root directory */
				res = FR_INVALID_NAME;
			} else {					/* File or sub-directory */
				ST_WORD(dir+DIR_WrtTime, fno->ftime);
    49d6:	d8 01       	movw	r26, r16
    49d8:	16 96       	adiw	r26, 0x06	; 6
    49da:	8c 91       	ld	r24, X
    49dc:	16 97       	sbiw	r26, 0x06	; 6
    49de:	86 8b       	std	Z+22, r24	; 0x16
    49e0:	17 96       	adiw	r26, 0x07	; 7
    49e2:	8c 91       	ld	r24, X
    49e4:	17 97       	sbiw	r26, 0x07	; 7
    49e6:	87 8b       	std	Z+23, r24	; 0x17
				ST_WORD(dir+DIR_WrtDate, fno->fdate);
    49e8:	14 96       	adiw	r26, 0x04	; 4
    49ea:	8c 91       	ld	r24, X
    49ec:	14 97       	sbiw	r26, 0x04	; 4
    49ee:	80 8f       	std	Z+24, r24	; 0x18
    49f0:	15 96       	adiw	r26, 0x05	; 5
    49f2:	8c 91       	ld	r24, X
    49f4:	81 8f       	std	Z+25, r24	; 0x19
				dj.fs->wflag = 1;
    49f6:	89 81       	ldd	r24, Y+1	; 0x01
    49f8:	9a 81       	ldd	r25, Y+2	; 0x02
    49fa:	21 e0       	ldi	r18, 0x01	; 1
    49fc:	fc 01       	movw	r30, r24
    49fe:	24 83       	std	Z+4, r18	; 0x04
				res = sync(dj.fs);
    4a00:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <sync>
    4a04:	01 c0       	rjmp	.+2      	; 0x4a08 <f_utime+0x8a>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
			if (!dir) {					/* Root directory */
				res = FR_INVALID_NAME;
    4a06:	86 e0       	ldi	r24, 0x06	; 6
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
    4a08:	a4 96       	adiw	r28, 0x24	; 36
    4a0a:	0f b6       	in	r0, 0x3f	; 63
    4a0c:	f8 94       	cli
    4a0e:	de bf       	out	0x3e, r29	; 62
    4a10:	0f be       	out	0x3f, r0	; 63
    4a12:	cd bf       	out	0x3d, r28	; 61
    4a14:	df 91       	pop	r29
    4a16:	cf 91       	pop	r28
    4a18:	1f 91       	pop	r17
    4a1a:	0f 91       	pop	r16
    4a1c:	08 95       	ret
		res = follow_path(&dj, path);	/* Follow the file path */
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_OK) {
			dir = dj.dir;
    4a1e:	eb 89       	ldd	r30, Y+19	; 0x13
    4a20:	fc 89       	ldd	r31, Y+20	; 0x14
			if (!dir) {					/* Root directory */
    4a22:	30 97       	sbiw	r30, 0x00	; 0
    4a24:	c1 f6       	brne	.-80     	; 0x49d6 <f_utime+0x58>
    4a26:	ef cf       	rjmp	.-34     	; 0x4a06 <f_utime+0x88>

00004a28 <f_rename>:

FRESULT f_rename (
	const TCHAR *path_old,	/* Pointer to the old name */
	const TCHAR *path_new	/* Pointer to the new name */
)
{
    4a28:	ef 92       	push	r14
    4a2a:	ff 92       	push	r15
    4a2c:	0f 93       	push	r16
    4a2e:	1f 93       	push	r17
    4a30:	cf 93       	push	r28
    4a32:	df 93       	push	r29
    4a34:	cd b7       	in	r28, 0x3d	; 61
    4a36:	de b7       	in	r29, 0x3e	; 62
    4a38:	cf 54       	subi	r28, 0x4F	; 79
    4a3a:	d0 40       	sbci	r29, 0x00	; 0
    4a3c:	0f b6       	in	r0, 0x3f	; 63
    4a3e:	f8 94       	cli
    4a40:	de bf       	out	0x3e, r29	; 62
    4a42:	0f be       	out	0x3f, r0	; 63
    4a44:	cd bf       	out	0x3d, r28	; 61
    4a46:	60 96       	adiw	r28, 0x10	; 16
    4a48:	9f af       	sts	0x7f, r25
    4a4a:	8e af       	sts	0x7e, r24
    4a4c:	60 97       	sbiw	r28, 0x10	; 16
    4a4e:	8b 01       	movw	r16, r22
	BYTE buf[21], *dir;
	DWORD dw;
	DEF_NAMEBUF;


	res = chk_mounted(&path_old, &djo.fs, 1);
    4a50:	ce 01       	movw	r24, r28
    4a52:	82 5b       	subi	r24, 0xB2	; 178
    4a54:	9f 4f       	sbci	r25, 0xFF	; 255
    4a56:	be 01       	movw	r22, r28
    4a58:	6f 5f       	subi	r22, 0xFF	; 255
    4a5a:	7f 4f       	sbci	r23, 0xFF	; 255
    4a5c:	41 e0       	ldi	r20, 0x01	; 1
    4a5e:	0e 94 79 08 	call	0x10f2	; 0x10f2 <chk_mounted>
	if (res == FR_OK) {
    4a62:	88 23       	and	r24, r24
    4a64:	09 f0       	breq	.+2      	; 0x4a68 <f_rename+0x40>
    4a66:	b7 c0       	rjmp	.+366    	; 0x4bd6 <f_rename+0x1ae>
		djn.fs = djo.fs;
    4a68:	89 81       	ldd	r24, Y+1	; 0x01
    4a6a:	9a 81       	ldd	r25, Y+2	; 0x02
    4a6c:	98 8f       	std	Y+24, r25	; 0x18
    4a6e:	8f 8b       	std	Y+23, r24	; 0x17
		INIT_BUF(djo);
    4a70:	ce 01       	movw	r24, r28
    4a72:	8e 5b       	subi	r24, 0xBE	; 190
    4a74:	9f 4f       	sbci	r25, 0xFF	; 255
    4a76:	9e 8b       	std	Y+22, r25	; 0x16
    4a78:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&djo, path_old);		/* Check old object */
    4a7a:	60 96       	adiw	r28, 0x10	; 16
    4a7c:	6e ad       	sts	0x6e, r22
    4a7e:	7f ad       	sts	0x6f, r23
    4a80:	60 97       	sbiw	r28, 0x10	; 16
    4a82:	ce 01       	movw	r24, r28
    4a84:	01 96       	adiw	r24, 0x01	; 1
    4a86:	0e 94 a8 13 	call	0x2750	; 0x2750 <follow_path>
		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
    4a8a:	88 23       	and	r24, r24
    4a8c:	09 f0       	breq	.+2      	; 0x4a90 <f_rename+0x68>
    4a8e:	a3 c0       	rjmp	.+326    	; 0x4bd6 <f_rename+0x1ae>
    4a90:	ed 89       	ldd	r30, Y+21	; 0x15
    4a92:	fe 89       	ldd	r31, Y+22	; 0x16
    4a94:	83 85       	ldd	r24, Z+11	; 0x0b
    4a96:	85 ff       	sbrs	r24, 5
    4a98:	ac c0       	rjmp	.+344    	; 0x4bf2 <f_rename+0x1ca>
			res = FR_INVALID_NAME;
    4a9a:	86 e0       	ldi	r24, 0x06	; 6
    4a9c:	9c c0       	rjmp	.+312    	; 0x4bd6 <f_rename+0x1ae>
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
    4a9e:	65 5f       	subi	r22, 0xF5	; 245
    4aa0:	7f 4f       	sbci	r23, 0xFF	; 255
    4aa2:	ce 01       	movw	r24, r28
    4aa4:	8d 96       	adiw	r24, 0x2d	; 45
    4aa6:	25 e1       	ldi	r18, 0x15	; 21
    4aa8:	30 e0       	ldi	r19, 0x00	; 0
    4aaa:	40 e0       	ldi	r20, 0x00	; 0
    4aac:	50 e0       	ldi	r21, 0x00	; 0
    4aae:	0e 94 d6 06 	call	0xdac	; 0xdac <mem_cpy>
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
    4ab2:	ce 01       	movw	r24, r28
    4ab4:	47 96       	adiw	r24, 0x17	; 23
    4ab6:	be 01       	movw	r22, r28
    4ab8:	6f 5f       	subi	r22, 0xFF	; 255
    4aba:	7f 4f       	sbci	r23, 0xFF	; 255
    4abc:	26 e1       	ldi	r18, 0x16	; 22
    4abe:	30 e0       	ldi	r19, 0x00	; 0
    4ac0:	40 e0       	ldi	r20, 0x00	; 0
    4ac2:	50 e0       	ldi	r21, 0x00	; 0
    4ac4:	0e 94 d6 06 	call	0xdac	; 0xdac <mem_cpy>
				res = follow_path(&djn, path_new);
    4ac8:	ce 01       	movw	r24, r28
    4aca:	47 96       	adiw	r24, 0x17	; 23
    4acc:	b8 01       	movw	r22, r16
    4ace:	0e 94 a8 13 	call	0x2750	; 0x2750 <follow_path>
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
    4ad2:	88 23       	and	r24, r24
    4ad4:	09 f4       	brne	.+2      	; 0x4ad8 <f_rename+0xb0>
    4ad6:	7c c0       	rjmp	.+248    	; 0x4bd0 <f_rename+0x1a8>
				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
    4ad8:	84 30       	cpi	r24, 0x04	; 4
    4ada:	09 f0       	breq	.+2      	; 0x4ade <f_rename+0xb6>
    4adc:	7c c0       	rjmp	.+248    	; 0x4bd6 <f_rename+0x1ae>
/* Start critical section that an interruption or error can cause cross-link */
					res = dir_register(&djn);			/* Register the new entry */
    4ade:	ce 01       	movw	r24, r28
    4ae0:	47 96       	adiw	r24, 0x17	; 23
    4ae2:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <dir_register>
					if (res == FR_OK) {
    4ae6:	88 23       	and	r24, r24
    4ae8:	09 f0       	breq	.+2      	; 0x4aec <f_rename+0xc4>
    4aea:	75 c0       	rjmp	.+234    	; 0x4bd6 <f_rename+0x1ae>
						dir = djn.dir;					/* Copy object information except for name */
    4aec:	09 a5       	lds	r16, 0x69
    4aee:	1a a5       	lds	r17, 0x6a
						mem_cpy(dir+13, buf+2, 19);
    4af0:	c8 01       	movw	r24, r16
    4af2:	0d 96       	adiw	r24, 0x0d	; 13
    4af4:	be 01       	movw	r22, r28
    4af6:	61 5d       	subi	r22, 0xD1	; 209
    4af8:	7f 4f       	sbci	r23, 0xFF	; 255
    4afa:	23 e1       	ldi	r18, 0x13	; 19
    4afc:	30 e0       	ldi	r19, 0x00	; 0
    4afe:	40 e0       	ldi	r20, 0x00	; 0
    4b00:	50 e0       	ldi	r21, 0x00	; 0
    4b02:	0e 94 d6 06 	call	0xdac	; 0xdac <mem_cpy>
						dir[DIR_Attr] = buf[0] | AM_ARC;
    4b06:	8d a5       	lds	r24, 0x6d
    4b08:	80 62       	ori	r24, 0x20	; 32
    4b0a:	f8 01       	movw	r30, r16
    4b0c:	83 87       	std	Z+11, r24	; 0x0b
						djo.fs->wflag = 1;
    4b0e:	e9 80       	ldd	r14, Y+1	; 0x01
    4b10:	fa 80       	ldd	r15, Y+2	; 0x02
    4b12:	81 e0       	ldi	r24, 0x01	; 1
    4b14:	f7 01       	movw	r30, r14
    4b16:	84 83       	std	Z+4, r24	; 0x04
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
    4b18:	4f 81       	ldd	r20, Y+7	; 0x07
    4b1a:	58 85       	ldd	r21, Y+8	; 0x08
    4b1c:	69 85       	ldd	r22, Y+9	; 0x09
    4b1e:	7a 85       	ldd	r23, Y+10	; 0x0a
    4b20:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4b22:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4b24:	af 8d       	ldd	r26, Y+31	; 0x1f
    4b26:	b8 a1       	lds	r27, 0x48
    4b28:	48 17       	cp	r20, r24
    4b2a:	59 07       	cpc	r21, r25
    4b2c:	6a 07       	cpc	r22, r26
    4b2e:	7b 07       	cpc	r23, r27
    4b30:	09 f4       	brne	.+2      	; 0x4b34 <f_rename+0x10c>
    4b32:	43 c0       	rjmp	.+134    	; 0x4bba <f_rename+0x192>
    4b34:	f8 01       	movw	r30, r16
    4b36:	83 85       	ldd	r24, Z+11	; 0x0b
    4b38:	84 ff       	sbrs	r24, 4
    4b3a:	3f c0       	rjmp	.+126    	; 0x4bba <f_rename+0x192>
							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
    4b3c:	c7 01       	movw	r24, r14
    4b3e:	b8 01       	movw	r22, r16
    4b40:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <ld_clust>
    4b44:	ab 01       	movw	r20, r22
    4b46:	bc 01       	movw	r22, r24
    4b48:	c7 01       	movw	r24, r14
    4b4a:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <clust2sect>
    4b4e:	ab 01       	movw	r20, r22
    4b50:	bc 01       	movw	r22, r24
							if (!dw) {
    4b52:	41 15       	cp	r20, r1
    4b54:	51 05       	cpc	r21, r1
    4b56:	61 05       	cpc	r22, r1
    4b58:	71 05       	cpc	r23, r1
    4b5a:	09 f4       	brne	.+2      	; 0x4b5e <f_rename+0x136>
    4b5c:	51 c0       	rjmp	.+162    	; 0x4c00 <f_rename+0x1d8>
								res = FR_INT_ERR;
							} else {
								res = move_window(djo.fs, dw);
    4b5e:	c7 01       	movw	r24, r14
    4b60:	0e 94 c8 0c 	call	0x1990	; 0x1990 <move_window>
								dir = djo.fs->win+SZ_DIR;	/* .. entry */
    4b64:	e9 81       	ldd	r30, Y+1	; 0x01
    4b66:	fa 81       	ldd	r31, Y+2	; 0x02
								if (res == FR_OK && dir[1] == '.') {
    4b68:	88 23       	and	r24, r24
    4b6a:	a9 f5       	brne	.+106    	; 0x4bd6 <f_rename+0x1ae>
    4b6c:	df 01       	movw	r26, r30
    4b6e:	ad 5a       	subi	r26, 0xAD	; 173
    4b70:	bf 4f       	sbci	r27, 0xFF	; 255
    4b72:	8c 91       	ld	r24, X
    4b74:	8e 32       	cpi	r24, 0x2E	; 46
    4b76:	09 f5       	brne	.+66     	; 0x4bba <f_rename+0x192>
									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
    4b78:	80 81       	ld	r24, Z
    4b7a:	83 30       	cpi	r24, 0x03	; 3
    4b7c:	69 f4       	brne	.+26     	; 0x4b98 <f_rename+0x170>
    4b7e:	4d 8d       	ldd	r20, Y+29	; 0x1d
    4b80:	5e 8d       	ldd	r21, Y+30	; 0x1e
    4b82:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4b84:	78 a1       	lds	r23, 0x48
    4b86:	86 a1       	lds	r24, 0x46
    4b88:	97 a1       	lds	r25, 0x47
    4b8a:	a0 a5       	lds	r26, 0x60
    4b8c:	b1 a5       	lds	r27, 0x61
    4b8e:	48 17       	cp	r20, r24
    4b90:	59 07       	cpc	r21, r25
    4b92:	6a 07       	cpc	r22, r26
    4b94:	7b 07       	cpc	r23, r27
    4b96:	29 f0       	breq	.+10     	; 0x4ba2 <f_rename+0x17a>
    4b98:	4d 8d       	ldd	r20, Y+29	; 0x1d
    4b9a:	5e 8d       	ldd	r21, Y+30	; 0x1e
    4b9c:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4b9e:	78 a1       	lds	r23, 0x48
    4ba0:	03 c0       	rjmp	.+6      	; 0x4ba8 <f_rename+0x180>
    4ba2:	40 e0       	ldi	r20, 0x00	; 0
    4ba4:	50 e0       	ldi	r21, 0x00	; 0
    4ba6:	ba 01       	movw	r22, r20
									st_clust(dir, dw);
    4ba8:	cf 01       	movw	r24, r30
    4baa:	8e 5a       	subi	r24, 0xAE	; 174
    4bac:	9f 4f       	sbci	r25, 0xFF	; 255
    4bae:	0e 94 21 07 	call	0xe42	; 0xe42 <st_clust>
									djo.fs->wflag = 1;
    4bb2:	e9 81       	ldd	r30, Y+1	; 0x01
    4bb4:	fa 81       	ldd	r31, Y+2	; 0x02
    4bb6:	81 e0       	ldi	r24, 0x01	; 1
    4bb8:	84 83       	std	Z+4, r24	; 0x04
								}
							}
						}
						if (res == FR_OK) {
							res = dir_remove(&djo);		/* Remove old entry */
    4bba:	ce 01       	movw	r24, r28
    4bbc:	01 96       	adiw	r24, 0x01	; 1
    4bbe:	0e 94 12 10 	call	0x2024	; 0x2024 <dir_remove>
							if (res == FR_OK)
    4bc2:	88 23       	and	r24, r24
    4bc4:	41 f4       	brne	.+16     	; 0x4bd6 <f_rename+0x1ae>
								res = sync(djo.fs);
    4bc6:	89 81       	ldd	r24, Y+1	; 0x01
    4bc8:	9a 81       	ldd	r25, Y+2	; 0x02
    4bca:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <sync>
    4bce:	03 c0       	rjmp	.+6      	; 0x4bd6 <f_rename+0x1ae>
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
				res = follow_path(&djn, path_new);
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
    4bd0:	88 e0       	ldi	r24, 0x08	; 8
    4bd2:	01 c0       	rjmp	.+2      	; 0x4bd6 <f_rename+0x1ae>
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
    4bd4:	84 e0       	ldi	r24, 0x04	; 4
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(djo.fs, res);
}
    4bd6:	c1 5b       	subi	r28, 0xB1	; 177
    4bd8:	df 4f       	sbci	r29, 0xFF	; 255
    4bda:	0f b6       	in	r0, 0x3f	; 63
    4bdc:	f8 94       	cli
    4bde:	de bf       	out	0x3e, r29	; 62
    4be0:	0f be       	out	0x3f, r0	; 63
    4be2:	cd bf       	out	0x3d, r28	; 61
    4be4:	df 91       	pop	r29
    4be6:	cf 91       	pop	r28
    4be8:	1f 91       	pop	r17
    4bea:	0f 91       	pop	r16
    4bec:	ff 90       	pop	r15
    4bee:	ef 90       	pop	r14
    4bf0:	08 95       	ret
			res = FR_INVALID_NAME;
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
    4bf2:	6b 89       	ldd	r22, Y+19	; 0x13
    4bf4:	7c 89       	ldd	r23, Y+20	; 0x14
    4bf6:	61 15       	cp	r22, r1
    4bf8:	71 05       	cpc	r23, r1
    4bfa:	09 f0       	breq	.+2      	; 0x4bfe <f_rename+0x1d6>
    4bfc:	50 cf       	rjmp	.-352    	; 0x4a9e <f_rename+0x76>
    4bfe:	ea cf       	rjmp	.-44     	; 0x4bd4 <f_rename+0x1ac>
						dir[DIR_Attr] = buf[0] | AM_ARC;
						djo.fs->wflag = 1;
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
							if (!dw) {
								res = FR_INT_ERR;
    4c00:	82 e0       	ldi	r24, 0x02	; 2
    4c02:	e9 cf       	rjmp	.-46     	; 0x4bd6 <f_rename+0x1ae>

00004c04 <__vector_1>:
	
};
#endif
//ISR for controlling WEN.
ISR(INT0_vect)
{
    4c04:	1f 92       	push	r1
    4c06:	0f 92       	push	r0
    4c08:	0f b6       	in	r0, 0x3f	; 63
    4c0a:	0f 92       	push	r0
    4c0c:	11 24       	eor	r1, r1
    4c0e:	8f 93       	push	r24
    4c10:	9f 93       	push	r25
	//xprintf(PSTR("ISR Entered"));
	if (VSYNC_Count==1)//start a frame read
    4c12:	80 91 d3 08 	lds	r24, 0x08D3
    4c16:	90 91 d4 08 	lds	r25, 0x08D4
    4c1a:	81 30       	cpi	r24, 0x01	; 1
    4c1c:	91 05       	cpc	r25, r1
    4c1e:	59 f4       	brne	.+22     	; 0x4c36 <__vector_1+0x32>
	{
		/*xprintf(PSTR("WEN Set\n"));*/
		FIFO_WEN_SET;
    4c20:	5e 9a       	sbi	0x0b, 6	; 11
		VSYNC_Count++;
    4c22:	80 91 d3 08 	lds	r24, 0x08D3
    4c26:	90 91 d4 08 	lds	r25, 0x08D4
    4c2a:	01 96       	adiw	r24, 0x01	; 1
    4c2c:	90 93 d4 08 	sts	0x08D4, r25
    4c30:	80 93 d3 08 	sts	0x08D3, r24
    4c34:	0d c0       	rjmp	.+26     	; 0x4c50 <__vector_1+0x4c>
	}
	else if (VSYNC_Count==2)//end a frame read
    4c36:	80 91 d3 08 	lds	r24, 0x08D3
    4c3a:	90 91 d4 08 	lds	r25, 0x08D4
    4c3e:	82 30       	cpi	r24, 0x02	; 2
    4c40:	91 05       	cpc	r25, r1
    4c42:	11 f4       	brne	.+4      	; 0x4c48 <__vector_1+0x44>
	{
		FIFO_WEN_CLR;
    4c44:	5e 98       	cbi	0x0b, 6	; 11
    4c46:	04 c0       	rjmp	.+8      	; 0x4c50 <__vector_1+0x4c>
		/*xprintf(PSTR("WEN Clear\n"));*/
	}
	else
	{
		VSYNC_Count = 0;//wait for a read to be started
    4c48:	10 92 d4 08 	sts	0x08D4, r1
    4c4c:	10 92 d3 08 	sts	0x08D3, r1
	}
}
    4c50:	9f 91       	pop	r25
    4c52:	8f 91       	pop	r24
    4c54:	0f 90       	pop	r0
    4c56:	0f be       	out	0x3f, r0	; 63
    4c58:	0f 90       	pop	r0
    4c5a:	1f 90       	pop	r1
    4c5c:	18 95       	reti

00004c5e <wrOV7670Reg>:

//Write Register Method
unsigned char wrOV7670Reg(unsigned char regID, unsigned char regDat)
{
    4c5e:	cf 93       	push	r28
    4c60:	df 93       	push	r29
    4c62:	00 d0       	rcall	.+0      	; 0x4c64 <wrOV7670Reg+0x6>
    4c64:	00 d0       	rcall	.+0      	; 0x4c66 <wrOV7670Reg+0x8>
    4c66:	cd b7       	in	r28, 0x3d	; 61
    4c68:	de b7       	in	r29, 0x3e	; 62
	/*	I2C Traffic Generated:
	 *	S | OV_7670 + W | A | RegID | A | Data | A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE];
	messageBuf[0] = (OV7670_ADDR  <<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consit of General Call code or the TWI slave address.
    4c6a:	92 e4       	ldi	r25, 0x42	; 66
    4c6c:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for commands.
    4c6e:	8a 83       	std	Y+2, r24	; 0x02
	messageBuf[2] = regDat;                        // The second byte is used for the data.
    4c70:	6b 83       	std	Y+3, r22	; 0x03
	TWI_Start_Transceiver_With_Data( messageBuf, 3 );
    4c72:	ce 01       	movw	r24, r28
    4c74:	01 96       	adiw	r24, 0x01	; 1
    4c76:	63 e0       	ldi	r22, 0x03	; 3
    4c78:	0e 94 f2 27 	call	0x4fe4	; 0x4fe4 <TWI_Start_Transceiver_With_Data>
	
	while(TWI_Transceiver_Busy()) ; //Wait for transceiver to clear
    4c7c:	0e 94 e7 27 	call	0x4fce	; 0x4fce <TWI_Transceiver_Busy>
    4c80:	88 23       	and	r24, r24
    4c82:	e1 f7       	brne	.-8      	; 0x4c7c <wrOV7670Reg+0x1e>
	
	return TWI_statusReg.lastTransOK;
    4c84:	80 91 8c 04 	lds	r24, 0x048C
}
    4c88:	81 70       	andi	r24, 0x01	; 1
    4c8a:	0f 90       	pop	r0
    4c8c:	0f 90       	pop	r0
    4c8e:	0f 90       	pop	r0
    4c90:	0f 90       	pop	r0
    4c92:	df 91       	pop	r29
    4c94:	cf 91       	pop	r28
    4c96:	08 95       	ret

00004c98 <rdOV7670Reg>:

//Read Register Method
unsigned char rdOV7670Reg(unsigned char regID, unsigned char *regDat)
{
    4c98:	0f 93       	push	r16
    4c9a:	1f 93       	push	r17
    4c9c:	cf 93       	push	r28
    4c9e:	df 93       	push	r29
    4ca0:	00 d0       	rcall	.+0      	; 0x4ca2 <rdOV7670Reg+0xa>
    4ca2:	00 d0       	rcall	.+0      	; 0x4ca4 <rdOV7670Reg+0xc>
    4ca4:	cd b7       	in	r28, 0x3d	; 61
    4ca6:	de b7       	in	r29, 0x3e	; 62
    4ca8:	8b 01       	movw	r16, r22
	 *	S	|	OV_ADDR + W	| A | RegID | A | P |
	 *	S	|	OV_ADDR + R | A | Data	|~A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE]; //Initialise a buffer
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
    4caa:	92 e4       	ldi	r25, 0x42	; 66
    4cac:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for Address Pointer.
    4cae:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
    4cb0:	ce 01       	movw	r24, r28
    4cb2:	01 96       	adiw	r24, 0x01	; 1
    4cb4:	62 e0       	ldi	r22, 0x02	; 2
    4cb6:	0e 94 f2 27 	call	0x4fe4	; 0x4fe4 <TWI_Start_Transceiver_With_Data>
	
	// Request/collect the data from the Slave
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
    4cba:	83 e4       	ldi	r24, 0x43	; 67
    4cbc:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );              
    4cbe:	ce 01       	movw	r24, r28
    4cc0:	01 96       	adiw	r24, 0x01	; 1
    4cc2:	62 e0       	ldi	r22, 0x02	; 2
    4cc4:	0e 94 f2 27 	call	0x4fe4	; 0x4fe4 <TWI_Start_Transceiver_With_Data>
    
	// Get the received data from the transceiver buffer
	TWI_Get_Data_From_Transceiver( messageBuf, 2 );
    4cc8:	ce 01       	movw	r24, r28
    4cca:	01 96       	adiw	r24, 0x01	; 1
    4ccc:	62 e0       	ldi	r22, 0x02	; 2
    4cce:	0e 94 28 28 	call	0x5050	; 0x5050 <TWI_Get_Data_From_Transceiver>
	*regDat = messageBuf[1];       
    4cd2:	8a 81       	ldd	r24, Y+2	; 0x02
    4cd4:	f8 01       	movw	r30, r16
    4cd6:	80 83       	st	Z, r24
	return TWI_statusReg.lastTransOK;
    4cd8:	80 91 8c 04 	lds	r24, 0x048C
}
    4cdc:	81 70       	andi	r24, 0x01	; 1
    4cde:	0f 90       	pop	r0
    4ce0:	0f 90       	pop	r0
    4ce2:	0f 90       	pop	r0
    4ce4:	0f 90       	pop	r0
    4ce6:	df 91       	pop	r29
    4ce8:	cf 91       	pop	r28
    4cea:	1f 91       	pop	r17
    4cec:	0f 91       	pop	r16
    4cee:	08 95       	ret

00004cf0 <OV7670_init>:

// Initial OV7670 - TWI_Master Must be initialised before hand.
unsigned char OV7670_init(void)
{
    4cf0:	0f 93       	push	r16
    4cf2:	1f 93       	push	r17
    4cf4:	cf 93       	push	r28
    4cf6:	df 93       	push	r29
	
	VSYNC_Count = 0;
    4cf8:	10 92 d4 08 	sts	0x08D4, r1
    4cfc:	10 92 d3 08 	sts	0x08D3, r1
	unsigned char temp;
	
	unsigned int i=0;
	
	// initial the int0 interrupt for WEN
	DDRD &= ~(1<<OV7670_VSYNC);		//set OV7670_SYNC as input for INT0
    4d00:	52 98       	cbi	0x0a, 2	; 10
	PORTD |= (1<<OV7670_VSYNC);		//Enable OV7670_SYNC pull-up resistor
    4d02:	5a 9a       	sbi	0x0b, 2	; 11
	
	EIMSK = 1<<INT0;				//Enable INT0
    4d04:	81 e0       	ldi	r24, 0x01	; 1
    4d06:	8d bb       	out	0x1d, r24	; 29
	EICRA = 1<<ISC01;				//Trigger INT0 on the falling edge
    4d08:	82 e0       	ldi	r24, 0x02	; 2
    4d0a:	80 93 69 00 	sts	0x0069, r24
	
	temp=0x80;
	if(0==wrOV7670Reg(OV_COM7, temp)) //Reset Camera
    4d0e:	82 e1       	ldi	r24, 0x12	; 18
    4d10:	60 e8       	ldi	r22, 0x80	; 128
    4d12:	0e 94 2f 26 	call	0x4c5e	; 0x4c5e <wrOV7670Reg>
    4d16:	88 23       	and	r24, r24
    4d18:	f1 f0       	breq	.+60     	; 0x4d56 <OV7670_init+0x66>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    4d1a:	8f e2       	ldi	r24, 0x2F	; 47
    4d1c:	95 e7       	ldi	r25, 0x75	; 117
    4d1e:	01 97       	sbiw	r24, 0x01	; 1
    4d20:	f1 f7       	brne	.-4      	; 0x4d1e <OV7670_init+0x2e>
    4d22:	00 c0       	rjmp	.+0      	; 0x4d24 <OV7670_init+0x34>
    4d24:	00 00       	nop
    4d26:	c6 e3       	ldi	r28, 0x36	; 54
    4d28:	d3 e0       	ldi	r29, 0x03	; 3
	*regDat = messageBuf[1];       
	return TWI_statusReg.lastTransOK;
}

// Initial OV7670 - TWI_Master Must be initialised before hand.
unsigned char OV7670_init(void)
    4d2a:	04 e8       	ldi	r16, 0x84	; 132
    4d2c:	14 e0       	ldi	r17, 0x04	; 4
    4d2e:	fe 01       	movw	r30, r28
    4d30:	31 97       	sbiw	r30, 0x01	; 1
	}
	_delay_ms(10);
#if SETTINGS == PGM_SPACE
	for(i=0; i<SETTINGS_LENGTH; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
    4d32:	80 81       	ld	r24, Z
    4d34:	68 81       	ld	r22, Y
    4d36:	0e 94 2f 26 	call	0x4c5e	; 0x4c5e <wrOV7670Reg>
    4d3a:	88 23       	and	r24, r24
    4d3c:	71 f0       	breq	.+28     	; 0x4d5a <OV7670_init+0x6a>
    4d3e:	87 eb       	ldi	r24, 0xB7	; 183
    4d40:	9b e0       	ldi	r25, 0x0B	; 11
    4d42:	01 97       	sbiw	r24, 0x01	; 1
    4d44:	f1 f7       	brne	.-4      	; 0x4d42 <OV7670_init+0x52>
    4d46:	00 c0       	rjmp	.+0      	; 0x4d48 <OV7670_init+0x58>
    4d48:	00 00       	nop
    4d4a:	22 96       	adiw	r28, 0x02	; 2
	{
		return 1;
	}
	_delay_ms(10);
#if SETTINGS == PGM_SPACE
	for(i=0; i<SETTINGS_LENGTH; i++)
    4d4c:	c0 17       	cp	r28, r16
    4d4e:	d1 07       	cpc	r29, r17
    4d50:	71 f7       	brne	.-36     	; 0x4d2e <OV7670_init+0x3e>
			return 1;
		}
		_delay_ms(1);
	}	
#endif
	return 0; //ok
    4d52:	80 e0       	ldi	r24, 0x00	; 0
    4d54:	03 c0       	rjmp	.+6      	; 0x4d5c <OV7670_init+0x6c>
	EICRA = 1<<ISC01;				//Trigger INT0 on the falling edge
	
	temp=0x80;
	if(0==wrOV7670Reg(OV_COM7, temp)) //Reset Camera
	{
		return 1;
    4d56:	81 e0       	ldi	r24, 0x01	; 1
    4d58:	01 c0       	rjmp	.+2      	; 0x4d5c <OV7670_init+0x6c>
#if SETTINGS == PGM_SPACE
	for(i=0; i<SETTINGS_LENGTH; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
		{
			return 1;
    4d5a:	81 e0       	ldi	r24, 0x01	; 1
		}
		_delay_ms(1);
	}	
#endif
	return 0; //ok
}
    4d5c:	df 91       	pop	r29
    4d5e:	cf 91       	pop	r28
    4d60:	1f 91       	pop	r17
    4d62:	0f 91       	pop	r16
    4d64:	08 95       	ret

00004d66 <FIFO_Reset>:

//Resets both pointers
void FIFO_Reset() 
{
	FIFO_WRST_CLR;
    4d66:	5f 98       	cbi	0x0b, 7	; 11
	FIFO_nRRST_CLR;
    4d68:	5d 98       	cbi	0x0b, 5	; 11
	FIFO_RCLK_SET;
    4d6a:	5c 9a       	sbi	0x0b, 4	; 11
	FIFO_RCLK_CLR;
    4d6c:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_SET;
    4d6e:	5d 9a       	sbi	0x0b, 5	; 11
	FIFO_WRST_SET;
    4d70:	5f 9a       	sbi	0x0b, 7	; 11
}
    4d72:	08 95       	ret

00004d74 <LoadImageToBuffer>:
}


void LoadImageToBuffer( void )
{
	while(VSYNC_Count != 0); //wait for any frame to be written to complete
    4d74:	80 91 d3 08 	lds	r24, 0x08D3
    4d78:	90 91 d4 08 	lds	r25, 0x08D4
    4d7c:	00 97       	sbiw	r24, 0x00	; 0
    4d7e:	d1 f7       	brne	.-12     	; 0x4d74 <LoadImageToBuffer>
	FIFO_WRST_CLR;//Reset the write pointer
    4d80:	5f 98       	cbi	0x0b, 7	; 11
    4d82:	87 eb       	ldi	r24, 0xB7	; 183
    4d84:	9b e0       	ldi	r25, 0x0B	; 11
    4d86:	01 97       	sbiw	r24, 0x01	; 1
    4d88:	f1 f7       	brne	.-4      	; 0x4d86 <LoadImageToBuffer+0x12>
    4d8a:	00 c0       	rjmp	.+0      	; 0x4d8c <LoadImageToBuffer+0x18>
    4d8c:	00 00       	nop
	_delay_ms(1);//wait a few clock cycles of the internal oscillator
	FIFO_WRST_SET;
    4d8e:	5f 9a       	sbi	0x0b, 7	; 11
    4d90:	87 eb       	ldi	r24, 0xB7	; 183
    4d92:	9b e0       	ldi	r25, 0x0B	; 11
    4d94:	01 97       	sbiw	r24, 0x01	; 1
    4d96:	f1 f7       	brne	.-4      	; 0x4d94 <LoadImageToBuffer+0x20>
    4d98:	00 c0       	rjmp	.+0      	; 0x4d9a <LoadImageToBuffer+0x26>
    4d9a:	00 00       	nop
	_delay_ms(1);
	VSYNC_Count = 1;
    4d9c:	81 e0       	ldi	r24, 0x01	; 1
    4d9e:	90 e0       	ldi	r25, 0x00	; 0
    4da0:	90 93 d4 08 	sts	0x08D4, r25
    4da4:	80 93 d3 08 	sts	0x08D3, r24
}
    4da8:	08 95       	ret

00004daa <FIFO_init>:

//Initial FIFO
unsigned char FIFO_init(void)
{
	
	DDRD |=(1<<FIFO_WEN)|(1<<FIFO_nRRST)|(1<<FIFO_RCLK)|(1 << FIFO_WRST) | (1 << FIFO_nOE);
    4daa:	8a b1       	in	r24, 0x0a	; 10
    4dac:	80 6f       	ori	r24, 0xF0	; 240
    4dae:	8a b9       	out	0x0a, r24	; 10
	FIFO_WRST_CLR;
    4db0:	5f 98       	cbi	0x0b, 7	; 11
	
	FIFO_RCLK_CLR;
    4db2:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nOE_CLR;
    4db4:	46 98       	cbi	0x08, 6	; 8
	FIFO_nRRST_SET;
    4db6:	5d 9a       	sbi	0x0b, 5	; 11
	FIFO_WEN_CLR;
    4db8:	5e 98       	cbi	0x0b, 6	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    4dba:	88 e2       	ldi	r24, 0x28	; 40
    4dbc:	8a 95       	dec	r24
    4dbe:	f1 f7       	brne	.-4      	; 0x4dbc <FIFO_init+0x12>
	_delay_us(10);
	FIFO_RCLK_SET;
    4dc0:	5c 9a       	sbi	0x0b, 4	; 11
    4dc2:	88 e2       	ldi	r24, 0x28	; 40
    4dc4:	8a 95       	dec	r24
    4dc6:	f1 f7       	brne	.-4      	; 0x4dc4 <FIFO_init+0x1a>
	_delay_us(10);
	FIFO_RCLK_CLR;
    4dc8:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_CLR;
    4dca:	5d 98       	cbi	0x0b, 5	; 11
    4dcc:	88 e2       	ldi	r24, 0x28	; 40
    4dce:	8a 95       	dec	r24
    4dd0:	f1 f7       	brne	.-4      	; 0x4dce <FIFO_init+0x24>
	_delay_us(10);
	FIFO_RCLK_SET;
    4dd2:	5c 9a       	sbi	0x0b, 4	; 11
    4dd4:	88 e2       	ldi	r24, 0x28	; 40
    4dd6:	8a 95       	dec	r24
    4dd8:	f1 f7       	brne	.-4      	; 0x4dd6 <FIFO_init+0x2c>
	_delay_us(10);
	FIFO_RCLK_CLR;
    4dda:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_SET;
    4ddc:	5d 9a       	sbi	0x0b, 5	; 11
    4dde:	88 e2       	ldi	r24, 0x28	; 40
    4de0:	8a 95       	dec	r24
    4de2:	f1 f7       	brne	.-4      	; 0x4de0 <FIFO_init+0x36>
	_delay_us(10);
	FIFO_WRST_SET;
    4de4:	5f 9a       	sbi	0x0b, 7	; 11
	return 0; //okay
}
    4de6:	80 e0       	ldi	r24, 0x00	; 0
    4de8:	08 95       	ret

00004dea <FIFO_TO_AVR>:
//Write one pixel in AVR
uint16_t FIFO_TO_AVR(void)
{
	uint16_t data = 0;
	
	FIFO_AVR_DPRT=0;
    4dea:	11 b8       	out	0x01, r1	; 1
	
	FIFO_RCLK_SET;
    4dec:	5c 9a       	sbi	0x0b, 4	; 11
	data = FIFO_AVR_PINP;
    4dee:	80 b1       	in	r24, 0x00	; 0
	FIFO_RCLK_CLR;
    4df0:	5c 98       	cbi	0x0b, 4	; 11

	data <<= 8;
    4df2:	38 2f       	mov	r19, r24
    4df4:	20 e0       	ldi	r18, 0x00	; 0
	
	FIFO_RCLK_SET;
    4df6:	5c 9a       	sbi	0x0b, 4	; 11
	data |= FIFO_AVR_PINP;
    4df8:	80 b1       	in	r24, 0x00	; 0
	FIFO_RCLK_CLR;
    4dfa:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_RCLK_CLR;

	data <<= 8;
	
	FIFO_RCLK_SET;
	data |= FIFO_AVR_PINP;
    4dfc:	90 e0       	ldi	r25, 0x00	; 0
    4dfe:	82 2b       	or	r24, r18
    4e00:	93 2b       	or	r25, r19
	//	FIFO_RCLK_CLR;
	//	FIFO_RCLK_SET;
	//	FIFO_RCLK_CLR;
	
	return(data);
}
    4e02:	08 95       	ret

00004e04 <GetImageIfAvailiable>:
	FIFO_WRST_SET;
}

//Reads all data from the buffer if an image has been written
uint8_t GetImageIfAvailiable(int offset)
{
    4e04:	4f 92       	push	r4
    4e06:	5f 92       	push	r5
    4e08:	6f 92       	push	r6
    4e0a:	7f 92       	push	r7
    4e0c:	8f 92       	push	r8
    4e0e:	9f 92       	push	r9
    4e10:	af 92       	push	r10
    4e12:	bf 92       	push	r11
    4e14:	cf 92       	push	r12
    4e16:	df 92       	push	r13
    4e18:	ef 92       	push	r14
    4e1a:	ff 92       	push	r15
    4e1c:	0f 93       	push	r16
    4e1e:	1f 93       	push	r17
    4e20:	cf 93       	push	r28
    4e22:	df 93       	push	r29
    4e24:	cd b7       	in	r28, 0x3d	; 61
    4e26:	de b7       	in	r29, 0x3e	; 62
    4e28:	c4 54       	subi	r28, 0x44	; 68
    4e2a:	d1 40       	sbci	r29, 0x01	; 1
    4e2c:	0f b6       	in	r0, 0x3f	; 63
    4e2e:	f8 94       	cli
    4e30:	de bf       	out	0x3e, r29	; 62
    4e32:	0f be       	out	0x3f, r0	; 63
    4e34:	cd bf       	out	0x3d, r28	; 61
	if (VSYNC_Count == 2)//if one full frame has elapsed.
    4e36:	20 91 d3 08 	lds	r18, 0x08D3
    4e3a:	30 91 d4 08 	lds	r19, 0x08D4
    4e3e:	22 30       	cpi	r18, 0x02	; 2
    4e40:	31 05       	cpc	r19, r1
    4e42:	09 f0       	breq	.+2      	; 0x4e46 <GetImageIfAvailiable+0x42>
    4e44:	a1 c0       	rjmp	.+322    	; 0x4f88 <GetImageIfAvailiable+0x184>
		unsigned long int pointer;
		FRESULT fr;
		int i,j, ptr;
		uint16_t Temp;
		uint8_t Buff[320];
		FIFO_nRRST_CLR; //Reset Read Pointer
    4e46:	5d 98       	cbi	0x0b, 5	; 11
		FIFO_RCLK_SET;
    4e48:	5c 9a       	sbi	0x0b, 4	; 11
		FIFO_RCLK_CLR;
    4e4a:	5c 98       	cbi	0x0b, 4	; 11
		FIFO_nRRST_SET;
    4e4c:	5d 9a       	sbi	0x0b, 5	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    4e4e:	a7 eb       	ldi	r26, 0xB7	; 183
    4e50:	bb e0       	ldi	r27, 0x0B	; 11
    4e52:	11 97       	sbiw	r26, 0x01	; 1
    4e54:	f1 f7       	brne	.-4      	; 0x4e52 <GetImageIfAvailiable+0x4e>
    4e56:	00 c0       	rjmp	.+0      	; 0x4e58 <GetImageIfAvailiable+0x54>
    4e58:	00 00       	nop
	FIFO_nRRST_SET;
	FIFO_WRST_SET;
}

//Reads all data from the buffer if an image has been written
uint8_t GetImageIfAvailiable(int offset)
    4e5a:	2c 01       	movw	r4, r24
    4e5c:	66 24       	eor	r6, r6
    4e5e:	57 fc       	sbrc	r5, 7
    4e60:	60 94       	com	r6
    4e62:	76 2c       	mov	r7, r6
    4e64:	0f 2e       	mov	r0, r31
    4e66:	f0 e0       	ldi	r31, 0x00	; 0
    4e68:	8f 2e       	mov	r8, r31
    4e6a:	f8 e5       	ldi	r31, 0x58	; 88
    4e6c:	9f 2e       	mov	r9, r31
    4e6e:	f2 e0       	ldi	r31, 0x02	; 2
    4e70:	af 2e       	mov	r10, r31
    4e72:	f0 e0       	ldi	r31, 0x00	; 0
    4e74:	bf 2e       	mov	r11, r31
    4e76:	f0 2d       	mov	r31, r0
    4e78:	84 0c       	add	r8, r4
    4e7a:	95 1c       	adc	r9, r5
    4e7c:	a6 1c       	adc	r10, r6
    4e7e:	b7 1c       	adc	r11, r7
    4e80:	0f 2e       	mov	r0, r31
    4e82:	f6 e8       	ldi	r31, 0x86	; 134
    4e84:	ef 2e       	mov	r14, r31
    4e86:	f2 e0       	ldi	r31, 0x02	; 2
    4e88:	ff 2e       	mov	r15, r31
    4e8a:	f0 2d       	mov	r31, r0
    4e8c:	ec 0e       	add	r14, r28
    4e8e:	fd 1e       	adc	r15, r29
			}
			//i = (WIDTH % 4) + WIDTH * 2;//include some padding of any value if necessary NOT TESTED!
			
			pointer = (uint32_t)j * (uint32_t)WIDTH * (uint32_t)2 + offset;
			
			f_lseek(&Files[0], pointer);
    4e90:	0f 2e       	mov	r0, r31
    4e92:	f3 e9       	ldi	r31, 0x93	; 147
    4e94:	cf 2e       	mov	r12, r31
    4e96:	f4 e0       	ldi	r31, 0x04	; 4
    4e98:	df 2e       	mov	r13, r31
    4e9a:	f0 2d       	mov	r31, r0
    4e9c:	4a c0       	rjmp	.+148    	; 0x4f32 <GetImageIfAvailiable+0x12e>
		{
			ptr = 0;
			for (i=0; i < WIDTH; i++)
			{
				
				Temp=FIFO_TO_AVR();
    4e9e:	0e 94 f5 26 	call	0x4dea	; 0x4dea <FIFO_TO_AVR>
	FIFO_nRRST_SET;
	FIFO_WRST_SET;
}

//Reads all data from the buffer if an image has been written
uint8_t GetImageIfAvailiable(int offset)
    4ea2:	f8 01       	movw	r30, r16
    4ea4:	31 97       	sbiw	r30, 0x01	; 1
			for (i=0; i < WIDTH; i++)
			{
				
				Temp=FIFO_TO_AVR();
 				
 				Buff[ptr++] = (uint8_t)Temp >> 8;
    4ea6:	10 82       	st	Z, r1
				Buff[ptr++] = (uint8_t)Temp;
    4ea8:	f8 01       	movw	r30, r16
    4eaa:	80 83       	st	Z, r24
    4eac:	0e 5f       	subi	r16, 0xFE	; 254
    4eae:	1f 4f       	sbci	r17, 0xFF	; 255
		FIFO_nRRST_SET;
		_delay_ms(1);
		for (j=HEIGHT; j > 0; j--) //Read all data 
		{
			ptr = 0;
			for (i=0; i < WIDTH; i++)
    4eb0:	0e 15       	cp	r16, r14
    4eb2:	1f 05       	cpc	r17, r15
    4eb4:	a1 f7       	brne	.-24     	; 0x4e9e <GetImageIfAvailiable+0x9a>
			}
			//i = (WIDTH % 4) + WIDTH * 2;//include some padding of any value if necessary NOT TESTED!
			
			pointer = (uint32_t)j * (uint32_t)WIDTH * (uint32_t)2 + offset;
			
			f_lseek(&Files[0], pointer);
    4eb6:	c6 01       	movw	r24, r12
    4eb8:	b5 01       	movw	r22, r10
    4eba:	a4 01       	movw	r20, r8
    4ebc:	0e 94 73 1d 	call	0x3ae6	; 0x3ae6 <f_lseek>
			fr = f_write(&Files[0], Buff, WIDTH * 2, &p);
    4ec0:	c6 01       	movw	r24, r12
    4ec2:	be 01       	movw	r22, r28
    4ec4:	6b 5f       	subi	r22, 0xFB	; 251
    4ec6:	7f 4f       	sbci	r23, 0xFF	; 255
    4ec8:	20 e8       	ldi	r18, 0x80	; 128
    4eca:	32 e0       	ldi	r19, 0x02	; 2
    4ecc:	40 e0       	ldi	r20, 0x00	; 0
    4ece:	50 e0       	ldi	r21, 0x00	; 0
    4ed0:	8e 01       	movw	r16, r28
    4ed2:	0f 5f       	subi	r16, 0xFF	; 255
    4ed4:	1f 4f       	sbci	r17, 0xFF	; 255
    4ed6:	0e 94 4e 1a 	call	0x349c	; 0x349c <f_write>
			if (fr != FR_OK)
    4eda:	88 23       	and	r24, r24
    4edc:	e9 f0       	breq	.+58     	; 0x4f18 <GetImageIfAvailiable+0x114>
			{
				printf("File Write Fail : %d", fr);
    4ede:	00 d0       	rcall	.+0      	; 0x4ee0 <GetImageIfAvailiable+0xdc>
    4ee0:	00 d0       	rcall	.+0      	; 0x4ee2 <GetImageIfAvailiable+0xde>
    4ee2:	ed b7       	in	r30, 0x3d	; 61
    4ee4:	fe b7       	in	r31, 0x3e	; 62
    4ee6:	31 96       	adiw	r30, 0x01	; 1
    4ee8:	25 e0       	ldi	r18, 0x05	; 5
    4eea:	33 e0       	ldi	r19, 0x03	; 3
    4eec:	ad b7       	in	r26, 0x3d	; 61
    4eee:	be b7       	in	r27, 0x3e	; 62
    4ef0:	12 96       	adiw	r26, 0x02	; 2
    4ef2:	3c 93       	st	X, r19
    4ef4:	2e 93       	st	-X, r18
    4ef6:	11 97       	sbiw	r26, 0x01	; 1
    4ef8:	82 83       	std	Z+2, r24	; 0x02
    4efa:	13 82       	std	Z+3, r1	; 0x03
    4efc:	0e 94 74 29 	call	0x52e8	; 0x52e8 <printf>
				VSYNC_Count = 0; 
    4f00:	10 92 d4 08 	sts	0x08D4, r1
    4f04:	10 92 d3 08 	sts	0x08D3, r1
				FIFO_Reset();
    4f08:	0f 90       	pop	r0
    4f0a:	0f 90       	pop	r0
    4f0c:	0f 90       	pop	r0
    4f0e:	0f 90       	pop	r0
    4f10:	0e 94 b3 26 	call	0x4d66	; 0x4d66 <FIFO_Reset>
				return 1;
    4f14:	81 e0       	ldi	r24, 0x01	; 1
    4f16:	39 c0       	rjmp	.+114    	; 0x4f8a <GetImageIfAvailiable+0x186>
    4f18:	80 e8       	ldi	r24, 0x80	; 128
    4f1a:	9d ef       	ldi	r25, 0xFD	; 253
    4f1c:	af ef       	ldi	r26, 0xFF	; 255
    4f1e:	bf ef       	ldi	r27, 0xFF	; 255
    4f20:	88 0e       	add	r8, r24
    4f22:	99 1e       	adc	r9, r25
    4f24:	aa 1e       	adc	r10, r26
    4f26:	bb 1e       	adc	r11, r27
		FIFO_nRRST_CLR; //Reset Read Pointer
		FIFO_RCLK_SET;
		FIFO_RCLK_CLR;
		FIFO_nRRST_SET;
		_delay_ms(1);
		for (j=HEIGHT; j > 0; j--) //Read all data 
    4f28:	48 14       	cp	r4, r8
    4f2a:	59 04       	cpc	r5, r9
    4f2c:	6a 04       	cpc	r6, r10
    4f2e:	7b 04       	cpc	r7, r11
    4f30:	21 f0       	breq	.+8      	; 0x4f3a <GetImageIfAvailiable+0x136>
    4f32:	8e 01       	movw	r16, r28
    4f34:	0a 5f       	subi	r16, 0xFA	; 250
    4f36:	1f 4f       	sbci	r17, 0xFF	; 255
    4f38:	b2 cf       	rjmp	.-156    	; 0x4e9e <GetImageIfAvailiable+0x9a>
			}
			//xprintf(PSTR("%d:Write File Result %d, pointer location %u\n"), j, f_write(&File[0], Buff, WIDTH * 2, &p), pointer);
		}
		/*f_close(&File);*/
		/*FIFO_Reset();*/
		FIFO_nRRST_CLR; //Reset Read Pointer	
    4f3a:	5d 98       	cbi	0x0b, 5	; 11
		FIFO_RCLK_SET;
    4f3c:	5c 9a       	sbi	0x0b, 4	; 11
		FIFO_RCLK_CLR;
    4f3e:	5c 98       	cbi	0x0b, 4	; 11
		FIFO_nRRST_SET;
    4f40:	5d 9a       	sbi	0x0b, 5	; 11
		VSYNC_Count = 0; //No image present in buffer
    4f42:	10 92 d4 08 	sts	0x08D4, r1
    4f46:	10 92 d3 08 	sts	0x08D3, r1
		printf("Success!\n");
    4f4a:	8a e1       	ldi	r24, 0x1A	; 26
    4f4c:	93 e0       	ldi	r25, 0x03	; 3
    4f4e:	0e 94 89 29 	call	0x5312	; 0x5312 <puts>
		printf("Closing File: %d\n", f_close(&Files[0]));
    4f52:	83 e9       	ldi	r24, 0x93	; 147
    4f54:	94 e0       	ldi	r25, 0x04	; 4
    4f56:	0e 94 07 1d 	call	0x3a0e	; 0x3a0e <f_close>
    4f5a:	00 d0       	rcall	.+0      	; 0x4f5c <GetImageIfAvailiable+0x158>
    4f5c:	00 d0       	rcall	.+0      	; 0x4f5e <GetImageIfAvailiable+0x15a>
    4f5e:	ed b7       	in	r30, 0x3d	; 61
    4f60:	fe b7       	in	r31, 0x3e	; 62
    4f62:	31 96       	adiw	r30, 0x01	; 1
    4f64:	23 e2       	ldi	r18, 0x23	; 35
    4f66:	33 e0       	ldi	r19, 0x03	; 3
    4f68:	ad b7       	in	r26, 0x3d	; 61
    4f6a:	be b7       	in	r27, 0x3e	; 62
    4f6c:	12 96       	adiw	r26, 0x02	; 2
    4f6e:	3c 93       	st	X, r19
    4f70:	2e 93       	st	-X, r18
    4f72:	11 97       	sbiw	r26, 0x01	; 1
    4f74:	82 83       	std	Z+2, r24	; 0x02
    4f76:	13 82       	std	Z+3, r1	; 0x03
    4f78:	0e 94 74 29 	call	0x52e8	; 0x52e8 <printf>
		return 0; //Success!
    4f7c:	0f 90       	pop	r0
    4f7e:	0f 90       	pop	r0
    4f80:	0f 90       	pop	r0
    4f82:	0f 90       	pop	r0
    4f84:	80 e0       	ldi	r24, 0x00	; 0
    4f86:	01 c0       	rjmp	.+2      	; 0x4f8a <GetImageIfAvailiable+0x186>
	}
	else
	{
		return 2;// No image available
    4f88:	82 e0       	ldi	r24, 0x02	; 2
	}
}
    4f8a:	cc 5b       	subi	r28, 0xBC	; 188
    4f8c:	de 4f       	sbci	r29, 0xFE	; 254
    4f8e:	0f b6       	in	r0, 0x3f	; 63
    4f90:	f8 94       	cli
    4f92:	de bf       	out	0x3e, r29	; 62
    4f94:	0f be       	out	0x3f, r0	; 63
    4f96:	cd bf       	out	0x3d, r28	; 61
    4f98:	df 91       	pop	r29
    4f9a:	cf 91       	pop	r28
    4f9c:	1f 91       	pop	r17
    4f9e:	0f 91       	pop	r16
    4fa0:	ff 90       	pop	r15
    4fa2:	ef 90       	pop	r14
    4fa4:	df 90       	pop	r13
    4fa6:	cf 90       	pop	r12
    4fa8:	bf 90       	pop	r11
    4faa:	af 90       	pop	r10
    4fac:	9f 90       	pop	r9
    4fae:	8f 90       	pop	r8
    4fb0:	7f 90       	pop	r7
    4fb2:	6f 90       	pop	r6
    4fb4:	5f 90       	pop	r5
    4fb6:	4f 90       	pop	r4
    4fb8:	08 95       	ret

00004fba <TWI_Master_Initialise>:
		DDRC = 0x00;
		PORTC = (1 << PC0) | (1 << PC1);
	#else
		#pragma message("External I2C Pull Ups Required.")
	#endif
	TWBR = TWI_TWBR;                                  // Set bit rate register (Baudrate). Defined in header file.
    4fba:	84 e3       	ldi	r24, 0x34	; 52
    4fbc:	80 93 b8 00 	sts	0x00B8, r24
	// TWSR = TWI_TWPS;                                  // Not used. Driver presumes prescaler to be 00.
	TWDR = 0xFF;                                      // Default content = SDA released.
    4fc0:	8f ef       	ldi	r24, 0xFF	; 255
    4fc2:	80 93 bb 00 	sts	0x00BB, r24
	TWCR =	(1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
    4fc6:	84 e0       	ldi	r24, 0x04	; 4
    4fc8:	80 93 bc 00 	sts	0x00BC, r24
			(0<<TWIE)|(0<<TWINT)|                      // Disable Interupt.
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests.
			(0<<TWWC);                                 //
}    
    4fcc:	08 95       	ret

00004fce <TWI_Transceiver_Busy>:
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
    4fce:	80 91 bc 00 	lds	r24, 0x00BC
}
    4fd2:	81 70       	andi	r24, 0x01	; 1
    4fd4:	08 95       	ret

00004fd6 <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
    4fd6:	0e 94 e7 27 	call	0x4fce	; 0x4fce <TWI_Transceiver_Busy>
    4fda:	88 23       	and	r24, r24
    4fdc:	e1 f7       	brne	.-8      	; 0x4fd6 <TWI_Get_State_Info>
  return ( TWI_state );                         // Return error state.
}
    4fde:	80 91 83 04 	lds	r24, 0x0483
    4fe2:	08 95       	ret

00004fe4 <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
    4fe4:	0f 93       	push	r16
    4fe6:	1f 93       	push	r17
    4fe8:	cf 93       	push	r28
    4fea:	8c 01       	movw	r16, r24
    4fec:	c6 2f       	mov	r28, r22
  unsigned char temp;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    4fee:	0e 94 e7 27 	call	0x4fce	; 0x4fce <TWI_Transceiver_Busy>
    4ff2:	88 23       	and	r24, r24
    4ff4:	e1 f7       	brne	.-8      	; 0x4fee <TWI_Start_Transceiver_With_Data+0xa>

  TWI_msgSize = msgSize;                        // Number of data to transmit.
    4ff6:	c0 93 8d 04 	sts	0x048D, r28
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
    4ffa:	f8 01       	movw	r30, r16
    4ffc:	80 81       	ld	r24, Z
    4ffe:	80 93 8e 04 	sts	0x048E, r24
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
    5002:	80 fd       	sbrc	r24, 0
    5004:	0c c0       	rjmp	.+24     	; 0x501e <TWI_Start_Transceiver_With_Data+0x3a>
  {
    for ( temp = 1; temp < msgSize; temp++ )
    5006:	c2 30       	cpi	r28, 0x02	; 2
    5008:	50 f0       	brcs	.+20     	; 0x501e <TWI_Start_Transceiver_With_Data+0x3a>
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    500a:	d8 01       	movw	r26, r16
    500c:	11 96       	adiw	r26, 0x01	; 1

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    500e:	ef e8       	ldi	r30, 0x8F	; 143
    5010:	f4 e0       	ldi	r31, 0x04	; 4
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    5012:	81 e0       	ldi	r24, 0x01	; 1
  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
      TWI_buf[ temp ] = msg[ temp ];
    5014:	9d 91       	ld	r25, X+
    5016:	91 93       	st	Z+, r25

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
    5018:	8f 5f       	subi	r24, 0xFF	; 255
    501a:	8c 17       	cp	r24, r28
    501c:	d9 f7       	brne	.-10     	; 0x5014 <TWI_Start_Transceiver_With_Data+0x30>
      TWI_buf[ temp ] = msg[ temp ];
  }
  TWI_statusReg.all = 0;      
    501e:	10 92 8c 04 	sts	0x048C, r1
  TWI_state         = TWI_NO_STATE ;
    5022:	88 ef       	ldi	r24, 0xF8	; 248
    5024:	80 93 83 04 	sts	0x0483, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    5028:	85 ea       	ldi	r24, 0xA5	; 165
    502a:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    502e:	cf 91       	pop	r28
    5030:	1f 91       	pop	r17
    5032:	0f 91       	pop	r16
    5034:	08 95       	ret

00005036 <TWI_Start_Transceiver>:
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    5036:	0e 94 e7 27 	call	0x4fce	; 0x4fce <TWI_Transceiver_Busy>
    503a:	88 23       	and	r24, r24
    503c:	e1 f7       	brne	.-8      	; 0x5036 <TWI_Start_Transceiver>
  TWI_statusReg.all = 0;      
    503e:	10 92 8c 04 	sts	0x048C, r1
  TWI_state         = TWI_NO_STATE ;
    5042:	88 ef       	ldi	r24, 0xF8	; 248
    5044:	80 93 83 04 	sts	0x0483, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    5048:	85 ea       	ldi	r24, 0xA5	; 165
    504a:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
    504e:	08 95       	ret

00005050 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    5050:	1f 93       	push	r17
    5052:	cf 93       	push	r28
    5054:	df 93       	push	r29
    5056:	d8 2f       	mov	r29, r24
    5058:	19 2f       	mov	r17, r25
    505a:	c6 2f       	mov	r28, r22
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    505c:	0e 94 e7 27 	call	0x4fce	; 0x4fce <TWI_Transceiver_Busy>
    5060:	88 23       	and	r24, r24
    5062:	e1 f7       	brne	.-8      	; 0x505c <TWI_Get_Data_From_Transceiver+0xc>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    5064:	80 91 8c 04 	lds	r24, 0x048C
    5068:	80 ff       	sbrs	r24, 0
    506a:	0d c0       	rjmp	.+26     	; 0x5086 <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    506c:	cc 23       	and	r28, r28
    506e:	59 f0       	breq	.+22     	; 0x5086 <TWI_Get_Data_From_Transceiver+0x36>
    5070:	ae e8       	ldi	r26, 0x8E	; 142
    5072:	b4 e0       	ldi	r27, 0x04	; 4
    5074:	9d 2f       	mov	r25, r29
    5076:	ed 2f       	mov	r30, r29
    5078:	f1 2f       	mov	r31, r17
    {
      msg[ i ] = TWI_buf[ i ];
    507a:	8d 91       	ld	r24, X+
    507c:	81 93       	st	Z+, r24

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    507e:	8e 2f       	mov	r24, r30
    5080:	89 1b       	sub	r24, r25
    5082:	8c 17       	cp	r24, r28
    5084:	d0 f3       	brcs	.-12     	; 0x507a <TWI_Get_Data_From_Transceiver+0x2a>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    5086:	80 91 8c 04 	lds	r24, 0x048C
}
    508a:	81 70       	andi	r24, 0x01	; 1
    508c:	df 91       	pop	r29
    508e:	cf 91       	pop	r28
    5090:	1f 91       	pop	r17
    5092:	08 95       	ret

00005094 <__vector_26>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/

ISR(TWI_vect)
{
    5094:	1f 92       	push	r1
    5096:	0f 92       	push	r0
    5098:	0f b6       	in	r0, 0x3f	; 63
    509a:	0f 92       	push	r0
    509c:	11 24       	eor	r1, r1
    509e:	2f 93       	push	r18
    50a0:	3f 93       	push	r19
    50a2:	8f 93       	push	r24
    50a4:	9f 93       	push	r25
    50a6:	ef 93       	push	r30
    50a8:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    50aa:	80 91 b9 00 	lds	r24, 0x00B9
    50ae:	88 32       	cpi	r24, 0x28	; 40
    50b0:	d1 f0       	breq	.+52     	; 0x50e6 <__vector_26+0x52>
    50b2:	89 32       	cpi	r24, 0x29	; 41
    50b4:	40 f4       	brcc	.+16     	; 0x50c6 <__vector_26+0x32>
    50b6:	80 31       	cpi	r24, 0x10	; 16
    50b8:	a1 f0       	breq	.+40     	; 0x50e2 <__vector_26+0x4e>
    50ba:	88 31       	cpi	r24, 0x18	; 24
    50bc:	a1 f0       	breq	.+40     	; 0x50e6 <__vector_26+0x52>
    50be:	88 30       	cpi	r24, 0x08	; 8
    50c0:	09 f0       	breq	.+2      	; 0x50c4 <__vector_26+0x30>
    50c2:	61 c0       	rjmp	.+194    	; 0x5186 <__vector_26+0xf2>
    50c4:	0e c0       	rjmp	.+28     	; 0x50e2 <__vector_26+0x4e>
    50c6:	80 34       	cpi	r24, 0x40	; 64
    50c8:	b9 f1       	breq	.+110    	; 0x5138 <__vector_26+0xa4>
    50ca:	81 34       	cpi	r24, 0x41	; 65
    50cc:	20 f4       	brcc	.+8      	; 0x50d6 <__vector_26+0x42>
    50ce:	88 33       	cpi	r24, 0x38	; 56
    50d0:	09 f0       	breq	.+2      	; 0x50d4 <__vector_26+0x40>
    50d2:	59 c0       	rjmp	.+178    	; 0x5186 <__vector_26+0xf2>
    50d4:	54 c0       	rjmp	.+168    	; 0x517e <__vector_26+0xea>
    50d6:	80 35       	cpi	r24, 0x50	; 80
    50d8:	19 f1       	breq	.+70     	; 0x5120 <__vector_26+0x8c>
    50da:	88 35       	cpi	r24, 0x58	; 88
    50dc:	09 f0       	breq	.+2      	; 0x50e0 <__vector_26+0x4c>
    50de:	53 c0       	rjmp	.+166    	; 0x5186 <__vector_26+0xf2>
    50e0:	3d c0       	rjmp	.+122    	; 0x515c <__vector_26+0xc8>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    50e2:	10 92 92 04 	sts	0x0492, r1
    case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    50e6:	80 91 92 04 	lds	r24, 0x0492
    50ea:	90 91 8d 04 	lds	r25, 0x048D
    50ee:	89 17       	cp	r24, r25
    50f0:	70 f4       	brcc	.+28     	; 0x510e <__vector_26+0x7a>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    50f2:	e8 2f       	mov	r30, r24
    50f4:	f0 e0       	ldi	r31, 0x00	; 0
    50f6:	e2 57       	subi	r30, 0x72	; 114
    50f8:	fb 4f       	sbci	r31, 0xFB	; 251
    50fa:	90 81       	ld	r25, Z
    50fc:	90 93 bb 00 	sts	0x00BB, r25
    5100:	8f 5f       	subi	r24, 0xFF	; 255
    5102:	80 93 92 04 	sts	0x0492, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    5106:	85 e8       	ldi	r24, 0x85	; 133
    5108:	80 93 bc 00 	sts	0x00BC, r24
    510c:	43 c0       	rjmp	.+134    	; 0x5194 <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    510e:	80 91 8c 04 	lds	r24, 0x048C
    5112:	81 60       	ori	r24, 0x01	; 1
    5114:	80 93 8c 04 	sts	0x048C, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    5118:	84 e9       	ldi	r24, 0x94	; 148
    511a:	80 93 bc 00 	sts	0x00BC, r24
    511e:	3a c0       	rjmp	.+116    	; 0x5194 <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    5120:	80 91 92 04 	lds	r24, 0x0492
    5124:	90 91 bb 00 	lds	r25, 0x00BB
    5128:	e8 2f       	mov	r30, r24
    512a:	f0 e0       	ldi	r31, 0x00	; 0
    512c:	e2 57       	subi	r30, 0x72	; 114
    512e:	fb 4f       	sbci	r31, 0xFB	; 251
    5130:	90 83       	st	Z, r25
    5132:	8f 5f       	subi	r24, 0xFF	; 255
    5134:	80 93 92 04 	sts	0x0492, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    5138:	20 91 92 04 	lds	r18, 0x0492
    513c:	30 e0       	ldi	r19, 0x00	; 0
    513e:	80 91 8d 04 	lds	r24, 0x048D
    5142:	90 e0       	ldi	r25, 0x00	; 0
    5144:	01 97       	sbiw	r24, 0x01	; 1
    5146:	28 17       	cp	r18, r24
    5148:	39 07       	cpc	r19, r25
    514a:	24 f4       	brge	.+8      	; 0x5154 <__vector_26+0xc0>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    514c:	85 ec       	ldi	r24, 0xC5	; 197
    514e:	80 93 bc 00 	sts	0x00BC, r24
    5152:	20 c0       	rjmp	.+64     	; 0x5194 <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    5154:	85 e8       	ldi	r24, 0x85	; 133
    5156:	80 93 bc 00 	sts	0x00BC, r24
    515a:	1c c0       	rjmp	.+56     	; 0x5194 <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    515c:	80 91 bb 00 	lds	r24, 0x00BB
    5160:	e0 91 92 04 	lds	r30, 0x0492
    5164:	f0 e0       	ldi	r31, 0x00	; 0
    5166:	e2 57       	subi	r30, 0x72	; 114
    5168:	fb 4f       	sbci	r31, 0xFB	; 251
    516a:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    516c:	80 91 8c 04 	lds	r24, 0x048C
    5170:	81 60       	ori	r24, 0x01	; 1
    5172:	80 93 8c 04 	sts	0x048C, r24
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    5176:	84 e9       	ldi	r24, 0x94	; 148
    5178:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    517c:	0b c0       	rjmp	.+22     	; 0x5194 <__vector_26+0x100>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    517e:	85 ea       	ldi	r24, 0xA5	; 165
    5180:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    5184:	07 c0       	rjmp	.+14     	; 0x5194 <__vector_26+0x100>
    case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
//    case TWI_NO_STATE              // No relevant state information available; TWINT = 0
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    5186:	80 91 b9 00 	lds	r24, 0x00B9
    518a:	80 93 83 04 	sts	0x0483, r24
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    518e:	84 e0       	ldi	r24, 0x04	; 4
    5190:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    5194:	ff 91       	pop	r31
    5196:	ef 91       	pop	r30
    5198:	9f 91       	pop	r25
    519a:	8f 91       	pop	r24
    519c:	3f 91       	pop	r19
    519e:	2f 91       	pop	r18
    51a0:	0f 90       	pop	r0
    51a2:	0f be       	out	0x3f, r0	; 63
    51a4:	0f 90       	pop	r0
    51a6:	1f 90       	pop	r1
    51a8:	18 95       	reti

000051aa <USART0_Init>:

void USART0_Init()
{
	uint16_t ubrr = UBBR;
	//Set baud rate
	UBRR0H = (unsigned char)(ubrr >>8);
    51aa:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (unsigned char)ubrr ;
    51ae:	8c e0       	ldi	r24, 0x0C	; 12
    51b0:	80 93 c4 00 	sts	0x00C4, r24
	//Enable receiver and transmitter
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    51b4:	88 e1       	ldi	r24, 0x18	; 24
    51b6:	80 93 c1 00 	sts	0x00C1, r24
	
	UCSR0C = 0x06; //set asynchronous, no parity, one stop bit, 8 bit transfer.
    51ba:	86 e0       	ldi	r24, 0x06	; 6
    51bc:	80 93 c2 00 	sts	0x00C2, r24
	
	//UCSR0B |= (1 << RXCIE0) | (1 << TXCIE0); //set RX and TX interrupt on
}
    51c0:	08 95       	ret

000051c2 <Usart_SendChar>:
void Usart_SendChar(char data) 
{
    // Wait for empty transmit buffer
    while ( !(UCSR0A & (1 << UDRE0)) );
    51c2:	e0 ec       	ldi	r30, 0xC0	; 192
    51c4:	f0 e0       	ldi	r31, 0x00	; 0
    51c6:	90 81       	ld	r25, Z
    51c8:	95 ff       	sbrs	r25, 5
    51ca:	fd cf       	rjmp	.-6      	; 0x51c6 <Usart_SendChar+0x4>
    // Start transmission
    UDR0 = data; 
    51cc:	80 93 c6 00 	sts	0x00C6, r24
}
    51d0:	08 95       	ret

000051d2 <Usart_Receive>:
unsigned char Usart_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
    51d2:	e0 ec       	ldi	r30, 0xC0	; 192
    51d4:	f0 e0       	ldi	r31, 0x00	; 0
    51d6:	80 81       	ld	r24, Z
    51d8:	88 23       	and	r24, r24
    51da:	ec f7       	brge	.-6      	; 0x51d6 <Usart_Receive+0x4>
	;
	/* Get and return received data from buffer */
	return UDR0;
    51dc:	80 91 c6 00 	lds	r24, 0x00C6
}
    51e0:	08 95       	ret

000051e2 <Usart_printf>:
//to use this copy the following as a global- 
//		static FILE mystdout = FDEV_SETUP_STREAM(Usart_printf, NULL, _FDEV_SETUP_WRITE);
// and add this line at the beginning of main:
//		stdout = &mystdout;
//	stdio.h must be used.
int Usart_printf(char var, FILE *stream) {
    51e2:	cf 93       	push	r28
    51e4:	c8 2f       	mov	r28, r24
    // translate \n to \r for br@y++ terminal
    if (var == '\n') Usart_SendChar('\r');
    51e6:	8a 30       	cpi	r24, 0x0A	; 10
    51e8:	19 f4       	brne	.+6      	; 0x51f0 <Usart_printf+0xe>
    51ea:	8d e0       	ldi	r24, 0x0D	; 13
    51ec:	0e 94 e1 28 	call	0x51c2	; 0x51c2 <Usart_SendChar>
    Usart_SendChar(var);
    51f0:	8c 2f       	mov	r24, r28
    51f2:	0e 94 e1 28 	call	0x51c2	; 0x51c2 <Usart_SendChar>
    return 0;
}
    51f6:	80 e0       	ldi	r24, 0x00	; 0
    51f8:	90 e0       	ldi	r25, 0x00	; 0
    51fa:	cf 91       	pop	r28
    51fc:	08 95       	ret

000051fe <Usart_get_line>:

void Usart_get_line (char *buff, int len)
{
    51fe:	ef 92       	push	r14
    5200:	ff 92       	push	r15
    5202:	0f 93       	push	r16
    5204:	1f 93       	push	r17
    5206:	cf 93       	push	r28
    5208:	df 93       	push	r29
    520a:	7c 01       	movw	r14, r24
	cli();
    520c:	f8 94       	cli
	char c;
	int i = 0;
    520e:	c0 e0       	ldi	r28, 0x00	; 0
    5210:	d0 e0       	ldi	r29, 0x00	; 0
		if ((c == '\b') && i) {
			i--;
			Usart_SendChar(c);
			continue;
		}
		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    5212:	8b 01       	movw	r16, r22
    5214:	01 50       	subi	r16, 0x01	; 1
    5216:	10 40       	sbci	r17, 0x00	; 0
	char c;
	int i = 0;


	for (;;) {
		c = Usart_Receive();
    5218:	0e 94 e9 28 	call	0x51d2	; 0x51d2 <Usart_Receive>
		if (c == '\r') break;
    521c:	8d 30       	cpi	r24, 0x0D	; 13
    521e:	a9 f0       	breq	.+42     	; 0x524a <Usart_get_line+0x4c>
		if ((c == '\b') && i) {
    5220:	88 30       	cpi	r24, 0x08	; 8
    5222:	31 f4       	brne	.+12     	; 0x5230 <Usart_get_line+0x32>
    5224:	20 97       	sbiw	r28, 0x00	; 0
    5226:	c1 f3       	breq	.-16     	; 0x5218 <Usart_get_line+0x1a>
			i--;
    5228:	21 97       	sbiw	r28, 0x01	; 1
			Usart_SendChar(c);
    522a:	0e 94 e1 28 	call	0x51c2	; 0x51c2 <Usart_SendChar>
			continue;
    522e:	f4 cf       	rjmp	.-24     	; 0x5218 <Usart_get_line+0x1a>
		}
		if (c >= ' ' && i < len - 1) {	/* Visible chars */
    5230:	80 32       	cpi	r24, 0x20	; 32
    5232:	90 f3       	brcs	.-28     	; 0x5218 <Usart_get_line+0x1a>
    5234:	c0 17       	cp	r28, r16
    5236:	d1 07       	cpc	r29, r17
    5238:	7c f7       	brge	.-34     	; 0x5218 <Usart_get_line+0x1a>
			buff[i++] = c;
    523a:	f7 01       	movw	r30, r14
    523c:	ec 0f       	add	r30, r28
    523e:	fd 1f       	adc	r31, r29
    5240:	80 83       	st	Z, r24
    5242:	21 96       	adiw	r28, 0x01	; 1
			Usart_SendChar(c);
    5244:	0e 94 e1 28 	call	0x51c2	; 0x51c2 <Usart_SendChar>
    5248:	e7 cf       	rjmp	.-50     	; 0x5218 <Usart_get_line+0x1a>
		}
	}
	buff[i] = 0;
    524a:	ce 0d       	add	r28, r14
    524c:	df 1d       	adc	r29, r15
    524e:	18 82       	st	Y, r1
	Usart_SendChar('\n');
    5250:	8a e0       	ldi	r24, 0x0A	; 10
    5252:	0e 94 e1 28 	call	0x51c2	; 0x51c2 <Usart_SendChar>
	sei();
    5256:	78 94       	sei
    5258:	df 91       	pop	r29
    525a:	cf 91       	pop	r28
    525c:	1f 91       	pop	r17
    525e:	0f 91       	pop	r16
    5260:	ff 90       	pop	r15
    5262:	ef 90       	pop	r14
    5264:	08 95       	ret

00005266 <__mulsi3>:
    5266:	62 9f       	mul	r22, r18
    5268:	d0 01       	movw	r26, r0
    526a:	73 9f       	mul	r23, r19
    526c:	f0 01       	movw	r30, r0
    526e:	82 9f       	mul	r24, r18
    5270:	e0 0d       	add	r30, r0
    5272:	f1 1d       	adc	r31, r1
    5274:	64 9f       	mul	r22, r20
    5276:	e0 0d       	add	r30, r0
    5278:	f1 1d       	adc	r31, r1
    527a:	92 9f       	mul	r25, r18
    527c:	f0 0d       	add	r31, r0
    527e:	83 9f       	mul	r24, r19
    5280:	f0 0d       	add	r31, r0
    5282:	74 9f       	mul	r23, r20
    5284:	f0 0d       	add	r31, r0
    5286:	65 9f       	mul	r22, r21
    5288:	f0 0d       	add	r31, r0
    528a:	99 27       	eor	r25, r25
    528c:	72 9f       	mul	r23, r18
    528e:	b0 0d       	add	r27, r0
    5290:	e1 1d       	adc	r30, r1
    5292:	f9 1f       	adc	r31, r25
    5294:	63 9f       	mul	r22, r19
    5296:	b0 0d       	add	r27, r0
    5298:	e1 1d       	adc	r30, r1
    529a:	f9 1f       	adc	r31, r25
    529c:	bd 01       	movw	r22, r26
    529e:	cf 01       	movw	r24, r30
    52a0:	11 24       	eor	r1, r1
    52a2:	08 95       	ret

000052a4 <__udivmodsi4>:
    52a4:	a1 e2       	ldi	r26, 0x21	; 33
    52a6:	1a 2e       	mov	r1, r26
    52a8:	aa 1b       	sub	r26, r26
    52aa:	bb 1b       	sub	r27, r27
    52ac:	fd 01       	movw	r30, r26
    52ae:	0d c0       	rjmp	.+26     	; 0x52ca <__udivmodsi4_ep>

000052b0 <__udivmodsi4_loop>:
    52b0:	aa 1f       	adc	r26, r26
    52b2:	bb 1f       	adc	r27, r27
    52b4:	ee 1f       	adc	r30, r30
    52b6:	ff 1f       	adc	r31, r31
    52b8:	a2 17       	cp	r26, r18
    52ba:	b3 07       	cpc	r27, r19
    52bc:	e4 07       	cpc	r30, r20
    52be:	f5 07       	cpc	r31, r21
    52c0:	20 f0       	brcs	.+8      	; 0x52ca <__udivmodsi4_ep>
    52c2:	a2 1b       	sub	r26, r18
    52c4:	b3 0b       	sbc	r27, r19
    52c6:	e4 0b       	sbc	r30, r20
    52c8:	f5 0b       	sbc	r31, r21

000052ca <__udivmodsi4_ep>:
    52ca:	66 1f       	adc	r22, r22
    52cc:	77 1f       	adc	r23, r23
    52ce:	88 1f       	adc	r24, r24
    52d0:	99 1f       	adc	r25, r25
    52d2:	1a 94       	dec	r1
    52d4:	69 f7       	brne	.-38     	; 0x52b0 <__udivmodsi4_loop>
    52d6:	60 95       	com	r22
    52d8:	70 95       	com	r23
    52da:	80 95       	com	r24
    52dc:	90 95       	com	r25
    52de:	9b 01       	movw	r18, r22
    52e0:	ac 01       	movw	r20, r24
    52e2:	bd 01       	movw	r22, r26
    52e4:	cf 01       	movw	r24, r30
    52e6:	08 95       	ret

000052e8 <printf>:
    52e8:	a0 e0       	ldi	r26, 0x00	; 0
    52ea:	b0 e0       	ldi	r27, 0x00	; 0
    52ec:	ea e7       	ldi	r30, 0x7A	; 122
    52ee:	f9 e2       	ldi	r31, 0x29	; 41
    52f0:	0c 94 45 2c 	jmp	0x588a	; 0x588a <__prologue_saves__+0x20>
    52f4:	fe 01       	movw	r30, r28
    52f6:	35 96       	adiw	r30, 0x05	; 5
    52f8:	61 91       	ld	r22, Z+
    52fa:	71 91       	ld	r23, Z+
    52fc:	80 91 83 0b 	lds	r24, 0x0B83
    5300:	90 91 84 0b 	lds	r25, 0x0B84
    5304:	af 01       	movw	r20, r30
    5306:	0e 94 b7 29 	call	0x536e	; 0x536e <vfprintf>
    530a:	20 96       	adiw	r28, 0x00	; 0
    530c:	e2 e0       	ldi	r30, 0x02	; 2
    530e:	0c 94 61 2c 	jmp	0x58c2	; 0x58c2 <__epilogue_restores__+0x20>

00005312 <puts>:
    5312:	0f 93       	push	r16
    5314:	1f 93       	push	r17
    5316:	cf 93       	push	r28
    5318:	df 93       	push	r29
    531a:	8c 01       	movw	r16, r24
    531c:	e0 91 83 0b 	lds	r30, 0x0B83
    5320:	f0 91 84 0b 	lds	r31, 0x0B84
    5324:	83 81       	ldd	r24, Z+3	; 0x03
    5326:	81 ff       	sbrs	r24, 1
    5328:	1a c0       	rjmp	.+52     	; 0x535e <puts+0x4c>
    532a:	c0 e0       	ldi	r28, 0x00	; 0
    532c:	d0 e0       	ldi	r29, 0x00	; 0
    532e:	05 c0       	rjmp	.+10     	; 0x533a <puts+0x28>
    5330:	09 95       	icall
    5332:	00 97       	sbiw	r24, 0x00	; 0
    5334:	11 f0       	breq	.+4      	; 0x533a <puts+0x28>
    5336:	cf ef       	ldi	r28, 0xFF	; 255
    5338:	df ef       	ldi	r29, 0xFF	; 255
    533a:	f8 01       	movw	r30, r16
    533c:	81 91       	ld	r24, Z+
    533e:	8f 01       	movw	r16, r30
    5340:	60 91 83 0b 	lds	r22, 0x0B83
    5344:	70 91 84 0b 	lds	r23, 0x0B84
    5348:	db 01       	movw	r26, r22
    534a:	18 96       	adiw	r26, 0x08	; 8
    534c:	ed 91       	ld	r30, X+
    534e:	fc 91       	ld	r31, X
    5350:	19 97       	sbiw	r26, 0x09	; 9
    5352:	88 23       	and	r24, r24
    5354:	69 f7       	brne	.-38     	; 0x5330 <puts+0x1e>
    5356:	8a e0       	ldi	r24, 0x0A	; 10
    5358:	09 95       	icall
    535a:	00 97       	sbiw	r24, 0x00	; 0
    535c:	11 f0       	breq	.+4      	; 0x5362 <puts+0x50>
    535e:	cf ef       	ldi	r28, 0xFF	; 255
    5360:	df ef       	ldi	r29, 0xFF	; 255
    5362:	ce 01       	movw	r24, r28
    5364:	df 91       	pop	r29
    5366:	cf 91       	pop	r28
    5368:	1f 91       	pop	r17
    536a:	0f 91       	pop	r16
    536c:	08 95       	ret

0000536e <vfprintf>:
    536e:	ad e0       	ldi	r26, 0x0D	; 13
    5370:	b0 e0       	ldi	r27, 0x00	; 0
    5372:	ed eb       	ldi	r30, 0xBD	; 189
    5374:	f9 e2       	ldi	r31, 0x29	; 41
    5376:	0c 94 35 2c 	jmp	0x586a	; 0x586a <__prologue_saves__>
    537a:	3c 01       	movw	r6, r24
    537c:	7d 87       	std	Y+13, r23	; 0x0d
    537e:	6c 87       	std	Y+12, r22	; 0x0c
    5380:	5a 01       	movw	r10, r20
    5382:	fc 01       	movw	r30, r24
    5384:	17 82       	std	Z+7, r1	; 0x07
    5386:	16 82       	std	Z+6, r1	; 0x06
    5388:	83 81       	ldd	r24, Z+3	; 0x03
    538a:	81 ff       	sbrs	r24, 1
    538c:	c8 c1       	rjmp	.+912    	; 0x571e <vfprintf+0x3b0>
    538e:	2e 01       	movw	r4, r28
    5390:	08 94       	sec
    5392:	41 1c       	adc	r4, r1
    5394:	51 1c       	adc	r5, r1
    5396:	f3 01       	movw	r30, r6
    5398:	93 81       	ldd	r25, Z+3	; 0x03
    539a:	ec 85       	ldd	r30, Y+12	; 0x0c
    539c:	fd 85       	ldd	r31, Y+13	; 0x0d
    539e:	93 fd       	sbrc	r25, 3
    53a0:	85 91       	lpm	r24, Z+
    53a2:	93 ff       	sbrs	r25, 3
    53a4:	81 91       	ld	r24, Z+
    53a6:	fd 87       	std	Y+13, r31	; 0x0d
    53a8:	ec 87       	std	Y+12, r30	; 0x0c
    53aa:	88 23       	and	r24, r24
    53ac:	09 f4       	brne	.+2      	; 0x53b0 <vfprintf+0x42>
    53ae:	b3 c1       	rjmp	.+870    	; 0x5716 <vfprintf+0x3a8>
    53b0:	85 32       	cpi	r24, 0x25	; 37
    53b2:	41 f4       	brne	.+16     	; 0x53c4 <vfprintf+0x56>
    53b4:	93 fd       	sbrc	r25, 3
    53b6:	85 91       	lpm	r24, Z+
    53b8:	93 ff       	sbrs	r25, 3
    53ba:	81 91       	ld	r24, Z+
    53bc:	fd 87       	std	Y+13, r31	; 0x0d
    53be:	ec 87       	std	Y+12, r30	; 0x0c
    53c0:	85 32       	cpi	r24, 0x25	; 37
    53c2:	29 f4       	brne	.+10     	; 0x53ce <vfprintf+0x60>
    53c4:	90 e0       	ldi	r25, 0x00	; 0
    53c6:	b3 01       	movw	r22, r6
    53c8:	0e 94 ab 2b 	call	0x5756	; 0x5756 <fputc>
    53cc:	e4 cf       	rjmp	.-56     	; 0x5396 <vfprintf+0x28>
    53ce:	ff 24       	eor	r15, r15
    53d0:	ee 24       	eor	r14, r14
    53d2:	10 e0       	ldi	r17, 0x00	; 0
    53d4:	10 32       	cpi	r17, 0x20	; 32
    53d6:	b0 f4       	brcc	.+44     	; 0x5404 <vfprintf+0x96>
    53d8:	8b 32       	cpi	r24, 0x2B	; 43
    53da:	69 f0       	breq	.+26     	; 0x53f6 <vfprintf+0x88>
    53dc:	8c 32       	cpi	r24, 0x2C	; 44
    53de:	28 f4       	brcc	.+10     	; 0x53ea <vfprintf+0x7c>
    53e0:	80 32       	cpi	r24, 0x20	; 32
    53e2:	51 f0       	breq	.+20     	; 0x53f8 <vfprintf+0x8a>
    53e4:	83 32       	cpi	r24, 0x23	; 35
    53e6:	71 f4       	brne	.+28     	; 0x5404 <vfprintf+0x96>
    53e8:	0b c0       	rjmp	.+22     	; 0x5400 <vfprintf+0x92>
    53ea:	8d 32       	cpi	r24, 0x2D	; 45
    53ec:	39 f0       	breq	.+14     	; 0x53fc <vfprintf+0x8e>
    53ee:	80 33       	cpi	r24, 0x30	; 48
    53f0:	49 f4       	brne	.+18     	; 0x5404 <vfprintf+0x96>
    53f2:	11 60       	ori	r17, 0x01	; 1
    53f4:	2c c0       	rjmp	.+88     	; 0x544e <vfprintf+0xe0>
    53f6:	12 60       	ori	r17, 0x02	; 2
    53f8:	14 60       	ori	r17, 0x04	; 4
    53fa:	29 c0       	rjmp	.+82     	; 0x544e <vfprintf+0xe0>
    53fc:	18 60       	ori	r17, 0x08	; 8
    53fe:	27 c0       	rjmp	.+78     	; 0x544e <vfprintf+0xe0>
    5400:	10 61       	ori	r17, 0x10	; 16
    5402:	25 c0       	rjmp	.+74     	; 0x544e <vfprintf+0xe0>
    5404:	17 fd       	sbrc	r17, 7
    5406:	2e c0       	rjmp	.+92     	; 0x5464 <vfprintf+0xf6>
    5408:	28 2f       	mov	r18, r24
    540a:	20 53       	subi	r18, 0x30	; 48
    540c:	2a 30       	cpi	r18, 0x0A	; 10
    540e:	98 f4       	brcc	.+38     	; 0x5436 <vfprintf+0xc8>
    5410:	16 ff       	sbrs	r17, 6
    5412:	08 c0       	rjmp	.+16     	; 0x5424 <vfprintf+0xb6>
    5414:	8f 2d       	mov	r24, r15
    5416:	88 0f       	add	r24, r24
    5418:	f8 2e       	mov	r15, r24
    541a:	ff 0c       	add	r15, r15
    541c:	ff 0c       	add	r15, r15
    541e:	f8 0e       	add	r15, r24
    5420:	f2 0e       	add	r15, r18
    5422:	15 c0       	rjmp	.+42     	; 0x544e <vfprintf+0xe0>
    5424:	8e 2d       	mov	r24, r14
    5426:	88 0f       	add	r24, r24
    5428:	e8 2e       	mov	r14, r24
    542a:	ee 0c       	add	r14, r14
    542c:	ee 0c       	add	r14, r14
    542e:	e8 0e       	add	r14, r24
    5430:	e2 0e       	add	r14, r18
    5432:	10 62       	ori	r17, 0x20	; 32
    5434:	0c c0       	rjmp	.+24     	; 0x544e <vfprintf+0xe0>
    5436:	8e 32       	cpi	r24, 0x2E	; 46
    5438:	21 f4       	brne	.+8      	; 0x5442 <vfprintf+0xd4>
    543a:	16 fd       	sbrc	r17, 6
    543c:	6c c1       	rjmp	.+728    	; 0x5716 <vfprintf+0x3a8>
    543e:	10 64       	ori	r17, 0x40	; 64
    5440:	06 c0       	rjmp	.+12     	; 0x544e <vfprintf+0xe0>
    5442:	8c 36       	cpi	r24, 0x6C	; 108
    5444:	11 f4       	brne	.+4      	; 0x544a <vfprintf+0xdc>
    5446:	10 68       	ori	r17, 0x80	; 128
    5448:	02 c0       	rjmp	.+4      	; 0x544e <vfprintf+0xe0>
    544a:	88 36       	cpi	r24, 0x68	; 104
    544c:	59 f4       	brne	.+22     	; 0x5464 <vfprintf+0xf6>
    544e:	ec 85       	ldd	r30, Y+12	; 0x0c
    5450:	fd 85       	ldd	r31, Y+13	; 0x0d
    5452:	93 fd       	sbrc	r25, 3
    5454:	85 91       	lpm	r24, Z+
    5456:	93 ff       	sbrs	r25, 3
    5458:	81 91       	ld	r24, Z+
    545a:	fd 87       	std	Y+13, r31	; 0x0d
    545c:	ec 87       	std	Y+12, r30	; 0x0c
    545e:	88 23       	and	r24, r24
    5460:	09 f0       	breq	.+2      	; 0x5464 <vfprintf+0xf6>
    5462:	b8 cf       	rjmp	.-144    	; 0x53d4 <vfprintf+0x66>
    5464:	98 2f       	mov	r25, r24
    5466:	95 54       	subi	r25, 0x45	; 69
    5468:	93 30       	cpi	r25, 0x03	; 3
    546a:	18 f0       	brcs	.+6      	; 0x5472 <vfprintf+0x104>
    546c:	90 52       	subi	r25, 0x20	; 32
    546e:	93 30       	cpi	r25, 0x03	; 3
    5470:	38 f4       	brcc	.+14     	; 0x5480 <vfprintf+0x112>
    5472:	24 e0       	ldi	r18, 0x04	; 4
    5474:	30 e0       	ldi	r19, 0x00	; 0
    5476:	a2 0e       	add	r10, r18
    5478:	b3 1e       	adc	r11, r19
    547a:	3f e3       	ldi	r19, 0x3F	; 63
    547c:	39 83       	std	Y+1, r19	; 0x01
    547e:	0f c0       	rjmp	.+30     	; 0x549e <vfprintf+0x130>
    5480:	83 36       	cpi	r24, 0x63	; 99
    5482:	31 f0       	breq	.+12     	; 0x5490 <vfprintf+0x122>
    5484:	83 37       	cpi	r24, 0x73	; 115
    5486:	81 f0       	breq	.+32     	; 0x54a8 <vfprintf+0x13a>
    5488:	83 35       	cpi	r24, 0x53	; 83
    548a:	09 f0       	breq	.+2      	; 0x548e <vfprintf+0x120>
    548c:	5a c0       	rjmp	.+180    	; 0x5542 <vfprintf+0x1d4>
    548e:	22 c0       	rjmp	.+68     	; 0x54d4 <vfprintf+0x166>
    5490:	f5 01       	movw	r30, r10
    5492:	80 81       	ld	r24, Z
    5494:	89 83       	std	Y+1, r24	; 0x01
    5496:	22 e0       	ldi	r18, 0x02	; 2
    5498:	30 e0       	ldi	r19, 0x00	; 0
    549a:	a2 0e       	add	r10, r18
    549c:	b3 1e       	adc	r11, r19
    549e:	21 e0       	ldi	r18, 0x01	; 1
    54a0:	c2 2e       	mov	r12, r18
    54a2:	d1 2c       	mov	r13, r1
    54a4:	42 01       	movw	r8, r4
    54a6:	14 c0       	rjmp	.+40     	; 0x54d0 <vfprintf+0x162>
    54a8:	92 e0       	ldi	r25, 0x02	; 2
    54aa:	29 2e       	mov	r2, r25
    54ac:	31 2c       	mov	r3, r1
    54ae:	2a 0c       	add	r2, r10
    54b0:	3b 1c       	adc	r3, r11
    54b2:	f5 01       	movw	r30, r10
    54b4:	80 80       	ld	r8, Z
    54b6:	91 80       	ldd	r9, Z+1	; 0x01
    54b8:	16 ff       	sbrs	r17, 6
    54ba:	03 c0       	rjmp	.+6      	; 0x54c2 <vfprintf+0x154>
    54bc:	6f 2d       	mov	r22, r15
    54be:	70 e0       	ldi	r23, 0x00	; 0
    54c0:	02 c0       	rjmp	.+4      	; 0x54c6 <vfprintf+0x158>
    54c2:	6f ef       	ldi	r22, 0xFF	; 255
    54c4:	7f ef       	ldi	r23, 0xFF	; 255
    54c6:	c4 01       	movw	r24, r8
    54c8:	0e 94 a0 2b 	call	0x5740	; 0x5740 <strnlen>
    54cc:	6c 01       	movw	r12, r24
    54ce:	51 01       	movw	r10, r2
    54d0:	1f 77       	andi	r17, 0x7F	; 127
    54d2:	15 c0       	rjmp	.+42     	; 0x54fe <vfprintf+0x190>
    54d4:	82 e0       	ldi	r24, 0x02	; 2
    54d6:	28 2e       	mov	r2, r24
    54d8:	31 2c       	mov	r3, r1
    54da:	2a 0c       	add	r2, r10
    54dc:	3b 1c       	adc	r3, r11
    54de:	f5 01       	movw	r30, r10
    54e0:	80 80       	ld	r8, Z
    54e2:	91 80       	ldd	r9, Z+1	; 0x01
    54e4:	16 ff       	sbrs	r17, 6
    54e6:	03 c0       	rjmp	.+6      	; 0x54ee <vfprintf+0x180>
    54e8:	6f 2d       	mov	r22, r15
    54ea:	70 e0       	ldi	r23, 0x00	; 0
    54ec:	02 c0       	rjmp	.+4      	; 0x54f2 <vfprintf+0x184>
    54ee:	6f ef       	ldi	r22, 0xFF	; 255
    54f0:	7f ef       	ldi	r23, 0xFF	; 255
    54f2:	c4 01       	movw	r24, r8
    54f4:	0e 94 95 2b 	call	0x572a	; 0x572a <strnlen_P>
    54f8:	6c 01       	movw	r12, r24
    54fa:	10 68       	ori	r17, 0x80	; 128
    54fc:	51 01       	movw	r10, r2
    54fe:	13 fd       	sbrc	r17, 3
    5500:	1c c0       	rjmp	.+56     	; 0x553a <vfprintf+0x1cc>
    5502:	06 c0       	rjmp	.+12     	; 0x5510 <vfprintf+0x1a2>
    5504:	80 e2       	ldi	r24, 0x20	; 32
    5506:	90 e0       	ldi	r25, 0x00	; 0
    5508:	b3 01       	movw	r22, r6
    550a:	0e 94 ab 2b 	call	0x5756	; 0x5756 <fputc>
    550e:	ea 94       	dec	r14
    5510:	8e 2d       	mov	r24, r14
    5512:	90 e0       	ldi	r25, 0x00	; 0
    5514:	c8 16       	cp	r12, r24
    5516:	d9 06       	cpc	r13, r25
    5518:	a8 f3       	brcs	.-22     	; 0x5504 <vfprintf+0x196>
    551a:	0f c0       	rjmp	.+30     	; 0x553a <vfprintf+0x1cc>
    551c:	f4 01       	movw	r30, r8
    551e:	17 fd       	sbrc	r17, 7
    5520:	85 91       	lpm	r24, Z+
    5522:	17 ff       	sbrs	r17, 7
    5524:	81 91       	ld	r24, Z+
    5526:	4f 01       	movw	r8, r30
    5528:	90 e0       	ldi	r25, 0x00	; 0
    552a:	b3 01       	movw	r22, r6
    552c:	0e 94 ab 2b 	call	0x5756	; 0x5756 <fputc>
    5530:	e1 10       	cpse	r14, r1
    5532:	ea 94       	dec	r14
    5534:	08 94       	sec
    5536:	c1 08       	sbc	r12, r1
    5538:	d1 08       	sbc	r13, r1
    553a:	c1 14       	cp	r12, r1
    553c:	d1 04       	cpc	r13, r1
    553e:	71 f7       	brne	.-36     	; 0x551c <vfprintf+0x1ae>
    5540:	e7 c0       	rjmp	.+462    	; 0x5710 <vfprintf+0x3a2>
    5542:	84 36       	cpi	r24, 0x64	; 100
    5544:	11 f0       	breq	.+4      	; 0x554a <vfprintf+0x1dc>
    5546:	89 36       	cpi	r24, 0x69	; 105
    5548:	51 f5       	brne	.+84     	; 0x559e <vfprintf+0x230>
    554a:	f5 01       	movw	r30, r10
    554c:	17 ff       	sbrs	r17, 7
    554e:	07 c0       	rjmp	.+14     	; 0x555e <vfprintf+0x1f0>
    5550:	80 81       	ld	r24, Z
    5552:	91 81       	ldd	r25, Z+1	; 0x01
    5554:	a2 81       	ldd	r26, Z+2	; 0x02
    5556:	b3 81       	ldd	r27, Z+3	; 0x03
    5558:	24 e0       	ldi	r18, 0x04	; 4
    555a:	30 e0       	ldi	r19, 0x00	; 0
    555c:	08 c0       	rjmp	.+16     	; 0x556e <vfprintf+0x200>
    555e:	80 81       	ld	r24, Z
    5560:	91 81       	ldd	r25, Z+1	; 0x01
    5562:	aa 27       	eor	r26, r26
    5564:	97 fd       	sbrc	r25, 7
    5566:	a0 95       	com	r26
    5568:	ba 2f       	mov	r27, r26
    556a:	22 e0       	ldi	r18, 0x02	; 2
    556c:	30 e0       	ldi	r19, 0x00	; 0
    556e:	a2 0e       	add	r10, r18
    5570:	b3 1e       	adc	r11, r19
    5572:	01 2f       	mov	r16, r17
    5574:	0f 76       	andi	r16, 0x6F	; 111
    5576:	b7 ff       	sbrs	r27, 7
    5578:	08 c0       	rjmp	.+16     	; 0x558a <vfprintf+0x21c>
    557a:	b0 95       	com	r27
    557c:	a0 95       	com	r26
    557e:	90 95       	com	r25
    5580:	81 95       	neg	r24
    5582:	9f 4f       	sbci	r25, 0xFF	; 255
    5584:	af 4f       	sbci	r26, 0xFF	; 255
    5586:	bf 4f       	sbci	r27, 0xFF	; 255
    5588:	00 68       	ori	r16, 0x80	; 128
    558a:	bc 01       	movw	r22, r24
    558c:	cd 01       	movw	r24, r26
    558e:	a2 01       	movw	r20, r4
    5590:	2a e0       	ldi	r18, 0x0A	; 10
    5592:	30 e0       	ldi	r19, 0x00	; 0
    5594:	0e 94 d7 2b 	call	0x57ae	; 0x57ae <__ultoa_invert>
    5598:	d8 2e       	mov	r13, r24
    559a:	d4 18       	sub	r13, r4
    559c:	3f c0       	rjmp	.+126    	; 0x561c <vfprintf+0x2ae>
    559e:	85 37       	cpi	r24, 0x75	; 117
    55a0:	21 f4       	brne	.+8      	; 0x55aa <vfprintf+0x23c>
    55a2:	1f 7e       	andi	r17, 0xEF	; 239
    55a4:	2a e0       	ldi	r18, 0x0A	; 10
    55a6:	30 e0       	ldi	r19, 0x00	; 0
    55a8:	20 c0       	rjmp	.+64     	; 0x55ea <vfprintf+0x27c>
    55aa:	19 7f       	andi	r17, 0xF9	; 249
    55ac:	8f 36       	cpi	r24, 0x6F	; 111
    55ae:	a9 f0       	breq	.+42     	; 0x55da <vfprintf+0x26c>
    55b0:	80 37       	cpi	r24, 0x70	; 112
    55b2:	20 f4       	brcc	.+8      	; 0x55bc <vfprintf+0x24e>
    55b4:	88 35       	cpi	r24, 0x58	; 88
    55b6:	09 f0       	breq	.+2      	; 0x55ba <vfprintf+0x24c>
    55b8:	ae c0       	rjmp	.+348    	; 0x5716 <vfprintf+0x3a8>
    55ba:	0b c0       	rjmp	.+22     	; 0x55d2 <vfprintf+0x264>
    55bc:	80 37       	cpi	r24, 0x70	; 112
    55be:	21 f0       	breq	.+8      	; 0x55c8 <vfprintf+0x25a>
    55c0:	88 37       	cpi	r24, 0x78	; 120
    55c2:	09 f0       	breq	.+2      	; 0x55c6 <vfprintf+0x258>
    55c4:	a8 c0       	rjmp	.+336    	; 0x5716 <vfprintf+0x3a8>
    55c6:	01 c0       	rjmp	.+2      	; 0x55ca <vfprintf+0x25c>
    55c8:	10 61       	ori	r17, 0x10	; 16
    55ca:	14 ff       	sbrs	r17, 4
    55cc:	09 c0       	rjmp	.+18     	; 0x55e0 <vfprintf+0x272>
    55ce:	14 60       	ori	r17, 0x04	; 4
    55d0:	07 c0       	rjmp	.+14     	; 0x55e0 <vfprintf+0x272>
    55d2:	14 ff       	sbrs	r17, 4
    55d4:	08 c0       	rjmp	.+16     	; 0x55e6 <vfprintf+0x278>
    55d6:	16 60       	ori	r17, 0x06	; 6
    55d8:	06 c0       	rjmp	.+12     	; 0x55e6 <vfprintf+0x278>
    55da:	28 e0       	ldi	r18, 0x08	; 8
    55dc:	30 e0       	ldi	r19, 0x00	; 0
    55de:	05 c0       	rjmp	.+10     	; 0x55ea <vfprintf+0x27c>
    55e0:	20 e1       	ldi	r18, 0x10	; 16
    55e2:	30 e0       	ldi	r19, 0x00	; 0
    55e4:	02 c0       	rjmp	.+4      	; 0x55ea <vfprintf+0x27c>
    55e6:	20 e1       	ldi	r18, 0x10	; 16
    55e8:	32 e0       	ldi	r19, 0x02	; 2
    55ea:	f5 01       	movw	r30, r10
    55ec:	17 ff       	sbrs	r17, 7
    55ee:	07 c0       	rjmp	.+14     	; 0x55fe <vfprintf+0x290>
    55f0:	60 81       	ld	r22, Z
    55f2:	71 81       	ldd	r23, Z+1	; 0x01
    55f4:	82 81       	ldd	r24, Z+2	; 0x02
    55f6:	93 81       	ldd	r25, Z+3	; 0x03
    55f8:	44 e0       	ldi	r20, 0x04	; 4
    55fa:	50 e0       	ldi	r21, 0x00	; 0
    55fc:	06 c0       	rjmp	.+12     	; 0x560a <vfprintf+0x29c>
    55fe:	60 81       	ld	r22, Z
    5600:	71 81       	ldd	r23, Z+1	; 0x01
    5602:	80 e0       	ldi	r24, 0x00	; 0
    5604:	90 e0       	ldi	r25, 0x00	; 0
    5606:	42 e0       	ldi	r20, 0x02	; 2
    5608:	50 e0       	ldi	r21, 0x00	; 0
    560a:	a4 0e       	add	r10, r20
    560c:	b5 1e       	adc	r11, r21
    560e:	a2 01       	movw	r20, r4
    5610:	0e 94 d7 2b 	call	0x57ae	; 0x57ae <__ultoa_invert>
    5614:	d8 2e       	mov	r13, r24
    5616:	d4 18       	sub	r13, r4
    5618:	01 2f       	mov	r16, r17
    561a:	0f 77       	andi	r16, 0x7F	; 127
    561c:	06 ff       	sbrs	r16, 6
    561e:	09 c0       	rjmp	.+18     	; 0x5632 <vfprintf+0x2c4>
    5620:	0e 7f       	andi	r16, 0xFE	; 254
    5622:	df 14       	cp	r13, r15
    5624:	30 f4       	brcc	.+12     	; 0x5632 <vfprintf+0x2c4>
    5626:	04 ff       	sbrs	r16, 4
    5628:	06 c0       	rjmp	.+12     	; 0x5636 <vfprintf+0x2c8>
    562a:	02 fd       	sbrc	r16, 2
    562c:	04 c0       	rjmp	.+8      	; 0x5636 <vfprintf+0x2c8>
    562e:	0f 7e       	andi	r16, 0xEF	; 239
    5630:	02 c0       	rjmp	.+4      	; 0x5636 <vfprintf+0x2c8>
    5632:	1d 2d       	mov	r17, r13
    5634:	01 c0       	rjmp	.+2      	; 0x5638 <vfprintf+0x2ca>
    5636:	1f 2d       	mov	r17, r15
    5638:	80 2f       	mov	r24, r16
    563a:	90 e0       	ldi	r25, 0x00	; 0
    563c:	04 ff       	sbrs	r16, 4
    563e:	0c c0       	rjmp	.+24     	; 0x5658 <vfprintf+0x2ea>
    5640:	fe 01       	movw	r30, r28
    5642:	ed 0d       	add	r30, r13
    5644:	f1 1d       	adc	r31, r1
    5646:	20 81       	ld	r18, Z
    5648:	20 33       	cpi	r18, 0x30	; 48
    564a:	11 f4       	brne	.+4      	; 0x5650 <vfprintf+0x2e2>
    564c:	09 7e       	andi	r16, 0xE9	; 233
    564e:	09 c0       	rjmp	.+18     	; 0x5662 <vfprintf+0x2f4>
    5650:	02 ff       	sbrs	r16, 2
    5652:	06 c0       	rjmp	.+12     	; 0x5660 <vfprintf+0x2f2>
    5654:	1e 5f       	subi	r17, 0xFE	; 254
    5656:	05 c0       	rjmp	.+10     	; 0x5662 <vfprintf+0x2f4>
    5658:	86 78       	andi	r24, 0x86	; 134
    565a:	90 70       	andi	r25, 0x00	; 0
    565c:	00 97       	sbiw	r24, 0x00	; 0
    565e:	09 f0       	breq	.+2      	; 0x5662 <vfprintf+0x2f4>
    5660:	1f 5f       	subi	r17, 0xFF	; 255
    5662:	80 2e       	mov	r8, r16
    5664:	99 24       	eor	r9, r9
    5666:	03 fd       	sbrc	r16, 3
    5668:	12 c0       	rjmp	.+36     	; 0x568e <vfprintf+0x320>
    566a:	00 ff       	sbrs	r16, 0
    566c:	0d c0       	rjmp	.+26     	; 0x5688 <vfprintf+0x31a>
    566e:	fd 2c       	mov	r15, r13
    5670:	1e 15       	cp	r17, r14
    5672:	50 f4       	brcc	.+20     	; 0x5688 <vfprintf+0x31a>
    5674:	fe 0c       	add	r15, r14
    5676:	f1 1a       	sub	r15, r17
    5678:	1e 2d       	mov	r17, r14
    567a:	06 c0       	rjmp	.+12     	; 0x5688 <vfprintf+0x31a>
    567c:	80 e2       	ldi	r24, 0x20	; 32
    567e:	90 e0       	ldi	r25, 0x00	; 0
    5680:	b3 01       	movw	r22, r6
    5682:	0e 94 ab 2b 	call	0x5756	; 0x5756 <fputc>
    5686:	1f 5f       	subi	r17, 0xFF	; 255
    5688:	1e 15       	cp	r17, r14
    568a:	c0 f3       	brcs	.-16     	; 0x567c <vfprintf+0x30e>
    568c:	04 c0       	rjmp	.+8      	; 0x5696 <vfprintf+0x328>
    568e:	1e 15       	cp	r17, r14
    5690:	10 f4       	brcc	.+4      	; 0x5696 <vfprintf+0x328>
    5692:	e1 1a       	sub	r14, r17
    5694:	01 c0       	rjmp	.+2      	; 0x5698 <vfprintf+0x32a>
    5696:	ee 24       	eor	r14, r14
    5698:	84 fe       	sbrs	r8, 4
    569a:	0f c0       	rjmp	.+30     	; 0x56ba <vfprintf+0x34c>
    569c:	80 e3       	ldi	r24, 0x30	; 48
    569e:	90 e0       	ldi	r25, 0x00	; 0
    56a0:	b3 01       	movw	r22, r6
    56a2:	0e 94 ab 2b 	call	0x5756	; 0x5756 <fputc>
    56a6:	82 fe       	sbrs	r8, 2
    56a8:	1f c0       	rjmp	.+62     	; 0x56e8 <vfprintf+0x37a>
    56aa:	81 fe       	sbrs	r8, 1
    56ac:	03 c0       	rjmp	.+6      	; 0x56b4 <vfprintf+0x346>
    56ae:	88 e5       	ldi	r24, 0x58	; 88
    56b0:	90 e0       	ldi	r25, 0x00	; 0
    56b2:	10 c0       	rjmp	.+32     	; 0x56d4 <vfprintf+0x366>
    56b4:	88 e7       	ldi	r24, 0x78	; 120
    56b6:	90 e0       	ldi	r25, 0x00	; 0
    56b8:	0d c0       	rjmp	.+26     	; 0x56d4 <vfprintf+0x366>
    56ba:	c4 01       	movw	r24, r8
    56bc:	86 78       	andi	r24, 0x86	; 134
    56be:	90 70       	andi	r25, 0x00	; 0
    56c0:	00 97       	sbiw	r24, 0x00	; 0
    56c2:	91 f0       	breq	.+36     	; 0x56e8 <vfprintf+0x37a>
    56c4:	81 fc       	sbrc	r8, 1
    56c6:	02 c0       	rjmp	.+4      	; 0x56cc <vfprintf+0x35e>
    56c8:	80 e2       	ldi	r24, 0x20	; 32
    56ca:	01 c0       	rjmp	.+2      	; 0x56ce <vfprintf+0x360>
    56cc:	8b e2       	ldi	r24, 0x2B	; 43
    56ce:	07 fd       	sbrc	r16, 7
    56d0:	8d e2       	ldi	r24, 0x2D	; 45
    56d2:	90 e0       	ldi	r25, 0x00	; 0
    56d4:	b3 01       	movw	r22, r6
    56d6:	0e 94 ab 2b 	call	0x5756	; 0x5756 <fputc>
    56da:	06 c0       	rjmp	.+12     	; 0x56e8 <vfprintf+0x37a>
    56dc:	80 e3       	ldi	r24, 0x30	; 48
    56de:	90 e0       	ldi	r25, 0x00	; 0
    56e0:	b3 01       	movw	r22, r6
    56e2:	0e 94 ab 2b 	call	0x5756	; 0x5756 <fputc>
    56e6:	fa 94       	dec	r15
    56e8:	df 14       	cp	r13, r15
    56ea:	c0 f3       	brcs	.-16     	; 0x56dc <vfprintf+0x36e>
    56ec:	da 94       	dec	r13
    56ee:	f2 01       	movw	r30, r4
    56f0:	ed 0d       	add	r30, r13
    56f2:	f1 1d       	adc	r31, r1
    56f4:	80 81       	ld	r24, Z
    56f6:	90 e0       	ldi	r25, 0x00	; 0
    56f8:	b3 01       	movw	r22, r6
    56fa:	0e 94 ab 2b 	call	0x5756	; 0x5756 <fputc>
    56fe:	dd 20       	and	r13, r13
    5700:	a9 f7       	brne	.-22     	; 0x56ec <vfprintf+0x37e>
    5702:	06 c0       	rjmp	.+12     	; 0x5710 <vfprintf+0x3a2>
    5704:	80 e2       	ldi	r24, 0x20	; 32
    5706:	90 e0       	ldi	r25, 0x00	; 0
    5708:	b3 01       	movw	r22, r6
    570a:	0e 94 ab 2b 	call	0x5756	; 0x5756 <fputc>
    570e:	ea 94       	dec	r14
    5710:	ee 20       	and	r14, r14
    5712:	c1 f7       	brne	.-16     	; 0x5704 <vfprintf+0x396>
    5714:	40 ce       	rjmp	.-896    	; 0x5396 <vfprintf+0x28>
    5716:	f3 01       	movw	r30, r6
    5718:	86 81       	ldd	r24, Z+6	; 0x06
    571a:	97 81       	ldd	r25, Z+7	; 0x07
    571c:	02 c0       	rjmp	.+4      	; 0x5722 <vfprintf+0x3b4>
    571e:	8f ef       	ldi	r24, 0xFF	; 255
    5720:	9f ef       	ldi	r25, 0xFF	; 255
    5722:	2d 96       	adiw	r28, 0x0d	; 13
    5724:	e2 e1       	ldi	r30, 0x12	; 18
    5726:	0c 94 51 2c 	jmp	0x58a2	; 0x58a2 <__epilogue_restores__>

0000572a <strnlen_P>:
    572a:	fc 01       	movw	r30, r24
    572c:	05 90       	lpm	r0, Z+
    572e:	61 50       	subi	r22, 0x01	; 1
    5730:	70 40       	sbci	r23, 0x00	; 0
    5732:	01 10       	cpse	r0, r1
    5734:	d8 f7       	brcc	.-10     	; 0x572c <strnlen_P+0x2>
    5736:	80 95       	com	r24
    5738:	90 95       	com	r25
    573a:	8e 0f       	add	r24, r30
    573c:	9f 1f       	adc	r25, r31
    573e:	08 95       	ret

00005740 <strnlen>:
    5740:	fc 01       	movw	r30, r24
    5742:	61 50       	subi	r22, 0x01	; 1
    5744:	70 40       	sbci	r23, 0x00	; 0
    5746:	01 90       	ld	r0, Z+
    5748:	01 10       	cpse	r0, r1
    574a:	d8 f7       	brcc	.-10     	; 0x5742 <strnlen+0x2>
    574c:	80 95       	com	r24
    574e:	90 95       	com	r25
    5750:	8e 0f       	add	r24, r30
    5752:	9f 1f       	adc	r25, r31
    5754:	08 95       	ret

00005756 <fputc>:
    5756:	0f 93       	push	r16
    5758:	1f 93       	push	r17
    575a:	cf 93       	push	r28
    575c:	df 93       	push	r29
    575e:	8c 01       	movw	r16, r24
    5760:	eb 01       	movw	r28, r22
    5762:	8b 81       	ldd	r24, Y+3	; 0x03
    5764:	81 ff       	sbrs	r24, 1
    5766:	1b c0       	rjmp	.+54     	; 0x579e <fputc+0x48>
    5768:	82 ff       	sbrs	r24, 2
    576a:	0d c0       	rjmp	.+26     	; 0x5786 <fputc+0x30>
    576c:	2e 81       	ldd	r18, Y+6	; 0x06
    576e:	3f 81       	ldd	r19, Y+7	; 0x07
    5770:	8c 81       	ldd	r24, Y+4	; 0x04
    5772:	9d 81       	ldd	r25, Y+5	; 0x05
    5774:	28 17       	cp	r18, r24
    5776:	39 07       	cpc	r19, r25
    5778:	64 f4       	brge	.+24     	; 0x5792 <fputc+0x3c>
    577a:	e8 81       	ld	r30, Y
    577c:	f9 81       	ldd	r31, Y+1	; 0x01
    577e:	01 93       	st	Z+, r16
    5780:	f9 83       	std	Y+1, r31	; 0x01
    5782:	e8 83       	st	Y, r30
    5784:	06 c0       	rjmp	.+12     	; 0x5792 <fputc+0x3c>
    5786:	e8 85       	ldd	r30, Y+8	; 0x08
    5788:	f9 85       	ldd	r31, Y+9	; 0x09
    578a:	80 2f       	mov	r24, r16
    578c:	09 95       	icall
    578e:	00 97       	sbiw	r24, 0x00	; 0
    5790:	31 f4       	brne	.+12     	; 0x579e <fputc+0x48>
    5792:	8e 81       	ldd	r24, Y+6	; 0x06
    5794:	9f 81       	ldd	r25, Y+7	; 0x07
    5796:	01 96       	adiw	r24, 0x01	; 1
    5798:	9f 83       	std	Y+7, r25	; 0x07
    579a:	8e 83       	std	Y+6, r24	; 0x06
    579c:	02 c0       	rjmp	.+4      	; 0x57a2 <fputc+0x4c>
    579e:	0f ef       	ldi	r16, 0xFF	; 255
    57a0:	1f ef       	ldi	r17, 0xFF	; 255
    57a2:	c8 01       	movw	r24, r16
    57a4:	df 91       	pop	r29
    57a6:	cf 91       	pop	r28
    57a8:	1f 91       	pop	r17
    57aa:	0f 91       	pop	r16
    57ac:	08 95       	ret

000057ae <__ultoa_invert>:
    57ae:	fa 01       	movw	r30, r20
    57b0:	aa 27       	eor	r26, r26
    57b2:	28 30       	cpi	r18, 0x08	; 8
    57b4:	51 f1       	breq	.+84     	; 0x580a <__ultoa_invert+0x5c>
    57b6:	20 31       	cpi	r18, 0x10	; 16
    57b8:	81 f1       	breq	.+96     	; 0x581a <__ultoa_invert+0x6c>
    57ba:	e8 94       	clt
    57bc:	6f 93       	push	r22
    57be:	6e 7f       	andi	r22, 0xFE	; 254
    57c0:	6e 5f       	subi	r22, 0xFE	; 254
    57c2:	7f 4f       	sbci	r23, 0xFF	; 255
    57c4:	8f 4f       	sbci	r24, 0xFF	; 255
    57c6:	9f 4f       	sbci	r25, 0xFF	; 255
    57c8:	af 4f       	sbci	r26, 0xFF	; 255
    57ca:	b1 e0       	ldi	r27, 0x01	; 1
    57cc:	3e d0       	rcall	.+124    	; 0x584a <__ultoa_invert+0x9c>
    57ce:	b4 e0       	ldi	r27, 0x04	; 4
    57d0:	3c d0       	rcall	.+120    	; 0x584a <__ultoa_invert+0x9c>
    57d2:	67 0f       	add	r22, r23
    57d4:	78 1f       	adc	r23, r24
    57d6:	89 1f       	adc	r24, r25
    57d8:	9a 1f       	adc	r25, r26
    57da:	a1 1d       	adc	r26, r1
    57dc:	68 0f       	add	r22, r24
    57de:	79 1f       	adc	r23, r25
    57e0:	8a 1f       	adc	r24, r26
    57e2:	91 1d       	adc	r25, r1
    57e4:	a1 1d       	adc	r26, r1
    57e6:	6a 0f       	add	r22, r26
    57e8:	71 1d       	adc	r23, r1
    57ea:	81 1d       	adc	r24, r1
    57ec:	91 1d       	adc	r25, r1
    57ee:	a1 1d       	adc	r26, r1
    57f0:	20 d0       	rcall	.+64     	; 0x5832 <__ultoa_invert+0x84>
    57f2:	09 f4       	brne	.+2      	; 0x57f6 <__ultoa_invert+0x48>
    57f4:	68 94       	set
    57f6:	3f 91       	pop	r19
    57f8:	2a e0       	ldi	r18, 0x0A	; 10
    57fa:	26 9f       	mul	r18, r22
    57fc:	11 24       	eor	r1, r1
    57fe:	30 19       	sub	r19, r0
    5800:	30 5d       	subi	r19, 0xD0	; 208
    5802:	31 93       	st	Z+, r19
    5804:	de f6       	brtc	.-74     	; 0x57bc <__ultoa_invert+0xe>
    5806:	cf 01       	movw	r24, r30
    5808:	08 95       	ret
    580a:	46 2f       	mov	r20, r22
    580c:	47 70       	andi	r20, 0x07	; 7
    580e:	40 5d       	subi	r20, 0xD0	; 208
    5810:	41 93       	st	Z+, r20
    5812:	b3 e0       	ldi	r27, 0x03	; 3
    5814:	0f d0       	rcall	.+30     	; 0x5834 <__ultoa_invert+0x86>
    5816:	c9 f7       	brne	.-14     	; 0x580a <__ultoa_invert+0x5c>
    5818:	f6 cf       	rjmp	.-20     	; 0x5806 <__ultoa_invert+0x58>
    581a:	46 2f       	mov	r20, r22
    581c:	4f 70       	andi	r20, 0x0F	; 15
    581e:	40 5d       	subi	r20, 0xD0	; 208
    5820:	4a 33       	cpi	r20, 0x3A	; 58
    5822:	18 f0       	brcs	.+6      	; 0x582a <__ultoa_invert+0x7c>
    5824:	49 5d       	subi	r20, 0xD9	; 217
    5826:	31 fd       	sbrc	r19, 1
    5828:	40 52       	subi	r20, 0x20	; 32
    582a:	41 93       	st	Z+, r20
    582c:	02 d0       	rcall	.+4      	; 0x5832 <__ultoa_invert+0x84>
    582e:	a9 f7       	brne	.-22     	; 0x581a <__ultoa_invert+0x6c>
    5830:	ea cf       	rjmp	.-44     	; 0x5806 <__ultoa_invert+0x58>
    5832:	b4 e0       	ldi	r27, 0x04	; 4
    5834:	a6 95       	lsr	r26
    5836:	97 95       	ror	r25
    5838:	87 95       	ror	r24
    583a:	77 95       	ror	r23
    583c:	67 95       	ror	r22
    583e:	ba 95       	dec	r27
    5840:	c9 f7       	brne	.-14     	; 0x5834 <__ultoa_invert+0x86>
    5842:	00 97       	sbiw	r24, 0x00	; 0
    5844:	61 05       	cpc	r22, r1
    5846:	71 05       	cpc	r23, r1
    5848:	08 95       	ret
    584a:	9b 01       	movw	r18, r22
    584c:	ac 01       	movw	r20, r24
    584e:	0a 2e       	mov	r0, r26
    5850:	06 94       	lsr	r0
    5852:	57 95       	ror	r21
    5854:	47 95       	ror	r20
    5856:	37 95       	ror	r19
    5858:	27 95       	ror	r18
    585a:	ba 95       	dec	r27
    585c:	c9 f7       	brne	.-14     	; 0x5850 <__ultoa_invert+0xa2>
    585e:	62 0f       	add	r22, r18
    5860:	73 1f       	adc	r23, r19
    5862:	84 1f       	adc	r24, r20
    5864:	95 1f       	adc	r25, r21
    5866:	a0 1d       	adc	r26, r0
    5868:	08 95       	ret

0000586a <__prologue_saves__>:
    586a:	2f 92       	push	r2
    586c:	3f 92       	push	r3
    586e:	4f 92       	push	r4
    5870:	5f 92       	push	r5
    5872:	6f 92       	push	r6
    5874:	7f 92       	push	r7
    5876:	8f 92       	push	r8
    5878:	9f 92       	push	r9
    587a:	af 92       	push	r10
    587c:	bf 92       	push	r11
    587e:	cf 92       	push	r12
    5880:	df 92       	push	r13
    5882:	ef 92       	push	r14
    5884:	ff 92       	push	r15
    5886:	0f 93       	push	r16
    5888:	1f 93       	push	r17
    588a:	cf 93       	push	r28
    588c:	df 93       	push	r29
    588e:	cd b7       	in	r28, 0x3d	; 61
    5890:	de b7       	in	r29, 0x3e	; 62
    5892:	ca 1b       	sub	r28, r26
    5894:	db 0b       	sbc	r29, r27
    5896:	0f b6       	in	r0, 0x3f	; 63
    5898:	f8 94       	cli
    589a:	de bf       	out	0x3e, r29	; 62
    589c:	0f be       	out	0x3f, r0	; 63
    589e:	cd bf       	out	0x3d, r28	; 61
    58a0:	09 94       	ijmp

000058a2 <__epilogue_restores__>:
    58a2:	2a 88       	ldd	r2, Y+18	; 0x12
    58a4:	39 88       	ldd	r3, Y+17	; 0x11
    58a6:	48 88       	ldd	r4, Y+16	; 0x10
    58a8:	5f 84       	ldd	r5, Y+15	; 0x0f
    58aa:	6e 84       	ldd	r6, Y+14	; 0x0e
    58ac:	7d 84       	ldd	r7, Y+13	; 0x0d
    58ae:	8c 84       	ldd	r8, Y+12	; 0x0c
    58b0:	9b 84       	ldd	r9, Y+11	; 0x0b
    58b2:	aa 84       	ldd	r10, Y+10	; 0x0a
    58b4:	b9 84       	ldd	r11, Y+9	; 0x09
    58b6:	c8 84       	ldd	r12, Y+8	; 0x08
    58b8:	df 80       	ldd	r13, Y+7	; 0x07
    58ba:	ee 80       	ldd	r14, Y+6	; 0x06
    58bc:	fd 80       	ldd	r15, Y+5	; 0x05
    58be:	0c 81       	ldd	r16, Y+4	; 0x04
    58c0:	1b 81       	ldd	r17, Y+3	; 0x03
    58c2:	aa 81       	ldd	r26, Y+2	; 0x02
    58c4:	b9 81       	ldd	r27, Y+1	; 0x01
    58c6:	ce 0f       	add	r28, r30
    58c8:	d1 1d       	adc	r29, r1
    58ca:	0f b6       	in	r0, 0x3f	; 63
    58cc:	f8 94       	cli
    58ce:	de bf       	out	0x3e, r29	; 62
    58d0:	0f be       	out	0x3f, r0	; 63
    58d2:	cd bf       	out	0x3d, r28	; 61
    58d4:	ed 01       	movw	r28, r26
    58d6:	08 95       	ret

000058d8 <_exit>:
    58d8:	f8 94       	cli

000058da <__stop_program>:
    58da:	ff cf       	rjmp	.-2      	; 0x58da <__stop_program>
