
CameraController.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000226  00800100  00000832  000008c6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000832  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000a  00800326  00800326  00000aec  2**0
                  ALLOC
  3 .stab         00000954  00000000  00000000  00000aec  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000014d  00000000  00000000  00001440  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000100  00000000  00000000  00001590  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000ef0  00000000  00000000  00001690  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000005d0  00000000  00000000  00002580  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000007e7  00000000  00000000  00002b50  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002f4  00000000  00000000  00003338  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000036b  00000000  00000000  0000362c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000797  00000000  00000000  00003997  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000038  00000000  00000000  0000412e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
   4:	0c 94 5d 00 	jmp	0xba	; 0xba <__vector_1>
   8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
   c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  50:	0c 94 ad 02 	jmp	0x55a	; 0x55a <__vector_20>
  54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  68:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__vector_26>
  6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
  7c:	11 24       	eor	r1, r1
  7e:	1f be       	out	0x3f, r1	; 63
  80:	cf ef       	ldi	r28, 0xFF	; 255
  82:	d0 e1       	ldi	r29, 0x10	; 16
  84:	de bf       	out	0x3e, r29	; 62
  86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
  88:	13 e0       	ldi	r17, 0x03	; 3
  8a:	a0 e0       	ldi	r26, 0x00	; 0
  8c:	b1 e0       	ldi	r27, 0x01	; 1
  8e:	e2 e3       	ldi	r30, 0x32	; 50
  90:	f8 e0       	ldi	r31, 0x08	; 8
  92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
  94:	05 90       	lpm	r0, Z+
  96:	0d 92       	st	X+, r0
  98:	a6 32       	cpi	r26, 0x26	; 38
  9a:	b1 07       	cpc	r27, r17
  9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
  9e:	13 e0       	ldi	r17, 0x03	; 3
  a0:	a6 e2       	ldi	r26, 0x26	; 38
  a2:	b3 e0       	ldi	r27, 0x03	; 3
  a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
  a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
  a8:	a0 33       	cpi	r26, 0x30	; 48
  aa:	b1 07       	cpc	r27, r17
  ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
  ae:	0e 94 0c 03 	call	0x618	; 0x618 <main>
  b2:	0c 94 17 04 	jmp	0x82e	; 0x82e <_exit>

000000b6 <__bad_interrupt>:
  b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <__vector_1>:
	
};

//ISR for controlling WEN.
ISR(INT0_vect)
{
  ba:	1f 92       	push	r1
  bc:	0f 92       	push	r0
  be:	0f b6       	in	r0, 0x3f	; 63
  c0:	0f 92       	push	r0
  c2:	11 24       	eor	r1, r1
  c4:	8f 93       	push	r24
  c6:	9f 93       	push	r25
	if (VSYNC_Count==1)//start a frame read
  c8:	80 91 2e 03 	lds	r24, 0x032E
  cc:	90 91 2f 03 	lds	r25, 0x032F
  d0:	81 30       	cpi	r24, 0x01	; 1
  d2:	91 05       	cpc	r25, r1
  d4:	59 f4       	brne	.+22     	; 0xec <__vector_1+0x32>
	{
		FIFO_WEN_SET;
  d6:	5e 9a       	sbi	0x0b, 6	; 11
		VSYNC_Count++;
  d8:	80 91 2e 03 	lds	r24, 0x032E
  dc:	90 91 2f 03 	lds	r25, 0x032F
  e0:	01 96       	adiw	r24, 0x01	; 1
  e2:	90 93 2f 03 	sts	0x032F, r25
  e6:	80 93 2e 03 	sts	0x032E, r24
  ea:	0d c0       	rjmp	.+26     	; 0x106 <__vector_1+0x4c>
	}
	else if (VSYNC_Count==2)//end a frame read
  ec:	80 91 2e 03 	lds	r24, 0x032E
  f0:	90 91 2f 03 	lds	r25, 0x032F
  f4:	82 30       	cpi	r24, 0x02	; 2
  f6:	91 05       	cpc	r25, r1
  f8:	11 f4       	brne	.+4      	; 0xfe <__vector_1+0x44>
	{
		FIFO_WEN_CLR;
  fa:	5e 98       	cbi	0x0b, 6	; 11
  fc:	04 c0       	rjmp	.+8      	; 0x106 <__vector_1+0x4c>
		
	}
	else
	{
		VSYNC_Count = 0;//wait for a read to be started
  fe:	10 92 2f 03 	sts	0x032F, r1
 102:	10 92 2e 03 	sts	0x032E, r1
	}
}
 106:	9f 91       	pop	r25
 108:	8f 91       	pop	r24
 10a:	0f 90       	pop	r0
 10c:	0f be       	out	0x3f, r0	; 63
 10e:	0f 90       	pop	r0
 110:	1f 90       	pop	r1
 112:	18 95       	reti

00000114 <wrOV7670Reg>:

//Write Register Method
unsigned char wrOV7670Reg(unsigned char regID, unsigned char regDat)
{
 114:	cf 93       	push	r28
 116:	df 93       	push	r29
 118:	00 d0       	rcall	.+0      	; 0x11a <wrOV7670Reg+0x6>
 11a:	00 d0       	rcall	.+0      	; 0x11c <wrOV7670Reg+0x8>
 11c:	cd b7       	in	r28, 0x3d	; 61
 11e:	de b7       	in	r29, 0x3e	; 62
	/*	I2C Traffic Generated:
	 *	S | OV_7670 + W | A | RegID | A | Data | A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE];
	messageBuf[0] = (OV7670_ADDR  <<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consit of General Call code or the TWI slave address.
 120:	92 e4       	ldi	r25, 0x42	; 66
 122:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for commands.
 124:	8a 83       	std	Y+2, r24	; 0x02
	messageBuf[2] = regDat;                        // The second byte is used for the data.
 126:	6b 83       	std	Y+3, r22	; 0x03
	TWI_Start_Transceiver_With_Data( messageBuf, 3 );
 128:	ce 01       	movw	r24, r28
 12a:	01 96       	adiw	r24, 0x01	; 1
 12c:	63 e0       	ldi	r22, 0x03	; 3
 12e:	0e 94 a1 01 	call	0x342	; 0x342 <TWI_Start_Transceiver_With_Data>
	
	while(TWI_Transceiver_Busy()) ; //Wait for transceiver to clear
 132:	0e 94 96 01 	call	0x32c	; 0x32c <TWI_Transceiver_Busy>
 136:	88 23       	and	r24, r24
 138:	e1 f7       	brne	.-8      	; 0x132 <wrOV7670Reg+0x1e>
	
	return TWI_statusReg.lastTransOK;
 13a:	80 91 26 03 	lds	r24, 0x0326
}
 13e:	81 70       	andi	r24, 0x01	; 1
 140:	0f 90       	pop	r0
 142:	0f 90       	pop	r0
 144:	0f 90       	pop	r0
 146:	0f 90       	pop	r0
 148:	df 91       	pop	r29
 14a:	cf 91       	pop	r28
 14c:	08 95       	ret

0000014e <rdOV7670Reg>:

//Read Register Method
unsigned char rdOV7670Reg(unsigned char regID, unsigned char *regDat)
{
 14e:	0f 93       	push	r16
 150:	1f 93       	push	r17
 152:	cf 93       	push	r28
 154:	df 93       	push	r29
 156:	00 d0       	rcall	.+0      	; 0x158 <rdOV7670Reg+0xa>
 158:	00 d0       	rcall	.+0      	; 0x15a <rdOV7670Reg+0xc>
 15a:	cd b7       	in	r28, 0x3d	; 61
 15c:	de b7       	in	r29, 0x3e	; 62
 15e:	8b 01       	movw	r16, r22
	 *	S	|	OV_ADDR + W	| A | RegID | A | P |
	 *	S	|	OV_ADDR + R | A | Data	|~A | P |
	 */
	//I2C Interface
	unsigned char messageBuf[TWI_BUFFER_SIZE]; //Initialise a buffer
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (FALSE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
 160:	92 e4       	ldi	r25, 0x42	; 66
 162:	99 83       	std	Y+1, r25	; 0x01
	messageBuf[1] = regID;             // The first byte is used for Address Pointer.
 164:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );
 166:	ce 01       	movw	r24, r28
 168:	01 96       	adiw	r24, 0x01	; 1
 16a:	62 e0       	ldi	r22, 0x02	; 2
 16c:	0e 94 a1 01 	call	0x342	; 0x342 <TWI_Start_Transceiver_With_Data>
	
	// Request/collect the data from the Slave
	messageBuf[0] = (OV7670_ADDR<<TWI_ADR_BITS) | (TRUE<<TWI_READ_BIT); // The first byte must always consist of General Call code or the TWI slave address.
 170:	83 e4       	ldi	r24, 0x43	; 67
 172:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2 );              
 174:	ce 01       	movw	r24, r28
 176:	01 96       	adiw	r24, 0x01	; 1
 178:	62 e0       	ldi	r22, 0x02	; 2
 17a:	0e 94 a1 01 	call	0x342	; 0x342 <TWI_Start_Transceiver_With_Data>
    
	// Get the received data from the transceiver buffer
	TWI_Get_Data_From_Transceiver( messageBuf, 2 );
 17e:	ce 01       	movw	r24, r28
 180:	01 96       	adiw	r24, 0x01	; 1
 182:	62 e0       	ldi	r22, 0x02	; 2
 184:	0e 94 d7 01 	call	0x3ae	; 0x3ae <TWI_Get_Data_From_Transceiver>
	*regDat = messageBuf[1];       
 188:	8a 81       	ldd	r24, Y+2	; 0x02
 18a:	f8 01       	movw	r30, r16
 18c:	80 83       	st	Z, r24
	return TWI_statusReg.lastTransOK;
 18e:	80 91 26 03 	lds	r24, 0x0326
}
 192:	81 70       	andi	r24, 0x01	; 1
 194:	0f 90       	pop	r0
 196:	0f 90       	pop	r0
 198:	0f 90       	pop	r0
 19a:	0f 90       	pop	r0
 19c:	df 91       	pop	r29
 19e:	cf 91       	pop	r28
 1a0:	1f 91       	pop	r17
 1a2:	0f 91       	pop	r16
 1a4:	08 95       	ret

000001a6 <OV7670_init>:

// Initial OV7670 - TWI_Master Must be initialised before hand.
unsigned char OV7670_init(void)
{
 1a6:	0f 93       	push	r16
 1a8:	1f 93       	push	r17
 1aa:	cf 93       	push	r28
 1ac:	df 93       	push	r29
	VSYNC_Count = 0;
 1ae:	10 92 2f 03 	sts	0x032F, r1
 1b2:	10 92 2e 03 	sts	0x032E, r1
	unsigned char temp;
	
	unsigned int i=0;
	
	// initial the int0 interrupt for WEN
	DDRD &= ~(1<<OV7670_VSYNC);		//set OV7670_SYNC as input for INT0
 1b6:	52 98       	cbi	0x0a, 2	; 10
	PORTD |= (1<<OV7670_VSYNC);		//Enable OV7670_SYNC pull-up resistor
 1b8:	5a 9a       	sbi	0x0b, 2	; 11
	
	EIMSK = 1<<INT0;				//Enable INT0
 1ba:	81 e0       	ldi	r24, 0x01	; 1
 1bc:	8d bb       	out	0x1d, r24	; 29
	EICRA = 1<<ISC01;				//Trigger INT0 on the falling edge
 1be:	82 e0       	ldi	r24, 0x02	; 2
 1c0:	80 93 69 00 	sts	0x0069, r24

	temp=0x80;
	if(0==wrOV7670Reg(OV_COM7, temp)) //Reset Camera
 1c4:	82 e1       	ldi	r24, 0x12	; 18
 1c6:	60 e8       	ldi	r22, 0x80	; 128
 1c8:	0e 94 8a 00 	call	0x114	; 0x114 <wrOV7670Reg>
 1cc:	88 23       	and	r24, r24
 1ce:	f1 f0       	breq	.+60     	; 0x20c <OV7670_init+0x66>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1d0:	8f e2       	ldi	r24, 0x2F	; 47
 1d2:	95 e7       	ldi	r25, 0x75	; 117
 1d4:	01 97       	sbiw	r24, 0x01	; 1
 1d6:	f1 f7       	brne	.-4      	; 0x1d4 <OV7670_init+0x2e>
 1d8:	00 c0       	rjmp	.+0      	; 0x1da <OV7670_init+0x34>
 1da:	00 00       	nop
 1dc:	c1 e0       	ldi	r28, 0x01	; 1
 1de:	d1 e0       	ldi	r29, 0x01	; 1
	*regDat = messageBuf[1];       
	return TWI_statusReg.lastTransOK;
}

// Initial OV7670 - TWI_Master Must be initialised before hand.
unsigned char OV7670_init(void)
 1e0:	01 e6       	ldi	r16, 0x61	; 97
 1e2:	12 e0       	ldi	r17, 0x02	; 2
 1e4:	fe 01       	movw	r30, r28
 1e6:	31 97       	sbiw	r30, 0x01	; 1
	}
	_delay_ms(10);

	for(i=0; i<CHANGE_REG_NUM; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
 1e8:	80 81       	ld	r24, Z
 1ea:	68 81       	ld	r22, Y
 1ec:	0e 94 8a 00 	call	0x114	; 0x114 <wrOV7670Reg>
 1f0:	88 23       	and	r24, r24
 1f2:	71 f0       	breq	.+28     	; 0x210 <OV7670_init+0x6a>
 1f4:	87 eb       	ldi	r24, 0xB7	; 183
 1f6:	9b e0       	ldi	r25, 0x0B	; 11
 1f8:	01 97       	sbiw	r24, 0x01	; 1
 1fa:	f1 f7       	brne	.-4      	; 0x1f8 <OV7670_init+0x52>
 1fc:	00 c0       	rjmp	.+0      	; 0x1fe <OV7670_init+0x58>
 1fe:	00 00       	nop
 200:	22 96       	adiw	r28, 0x02	; 2
	{
		return 0;
	}
	_delay_ms(10);

	for(i=0; i<CHANGE_REG_NUM; i++)
 202:	c0 17       	cp	r28, r16
 204:	d1 07       	cpc	r29, r17
 206:	71 f7       	brne	.-36     	; 0x1e4 <OV7670_init+0x3e>
			return 0;
		}
		_delay_ms(1);
	}
	
	return 1; //ok
 208:	81 e0       	ldi	r24, 0x01	; 1
 20a:	03 c0       	rjmp	.+6      	; 0x212 <OV7670_init+0x6c>
	EICRA = 1<<ISC01;				//Trigger INT0 on the falling edge

	temp=0x80;
	if(0==wrOV7670Reg(OV_COM7, temp)) //Reset Camera
	{
		return 0;
 20c:	80 e0       	ldi	r24, 0x00	; 0
 20e:	01 c0       	rjmp	.+2      	; 0x212 <OV7670_init+0x6c>

	for(i=0; i<CHANGE_REG_NUM; i++)
	{
		if( 0==wrOV7670Reg(default_settings[i][0], default_settings[i][1] ))
		{
			return 0;
 210:	80 e0       	ldi	r24, 0x00	; 0
		}
		_delay_ms(1);
	}
	
	return 1; //ok
}
 212:	df 91       	pop	r29
 214:	cf 91       	pop	r28
 216:	1f 91       	pop	r17
 218:	0f 91       	pop	r16
 21a:	08 95       	ret

0000021c <FIFO_Reset>:

//Resets both pointers
void FIFO_Reset() 
{
	FIFO_WRST_CLR;
 21c:	5b 98       	cbi	0x0b, 3	; 11
	FIFO_nRRST_CLR;
 21e:	5f 98       	cbi	0x0b, 7	; 11
	FIFO_RCLK_SET;
 220:	5c 9a       	sbi	0x0b, 4	; 11
	FIFO_RCLK_CLR;
 222:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_SET;
 224:	5f 9a       	sbi	0x0b, 7	; 11
	FIFO_WRST_SET;
 226:	5b 9a       	sbi	0x0b, 3	; 11
}
 228:	08 95       	ret

0000022a <LoadImageToBuffer>:
}


void LoadImageToBuffer( void )
{
	while(VSYNC_Count != 0); //wait for any frame to be written to complete
 22a:	80 91 2e 03 	lds	r24, 0x032E
 22e:	90 91 2f 03 	lds	r25, 0x032F
 232:	00 97       	sbiw	r24, 0x00	; 0
 234:	d1 f7       	brne	.-12     	; 0x22a <LoadImageToBuffer>
		
	VSYNC_Count = 1;
 236:	81 e0       	ldi	r24, 0x01	; 1
 238:	90 e0       	ldi	r25, 0x00	; 0
 23a:	90 93 2f 03 	sts	0x032F, r25
 23e:	80 93 2e 03 	sts	0x032E, r24
}
 242:	08 95       	ret

00000244 <FIFO_init>:

//Initial FIFO
unsigned char FIFO_init(void)
{
	
	DDRD |=(1<<FIFO_WEN)|(1<<FIFO_nRRST)|(1<<FIFO_RCLK)|(1 << FIFO_WRST) | (1 << FIFO_nOE);
 244:	8a b1       	in	r24, 0x0a	; 10
 246:	88 6f       	ori	r24, 0xF8	; 248
 248:	8a b9       	out	0x0a, r24	; 10
	FIFO_WRST_CLR;
 24a:	5b 98       	cbi	0x0b, 3	; 11
	
	FIFO_RCLK_CLR;
 24c:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nOE_CLR;
 24e:	5d 98       	cbi	0x0b, 5	; 11
	FIFO_nRRST_SET;
 250:	5f 9a       	sbi	0x0b, 7	; 11
	FIFO_WEN_CLR;
 252:	5e 98       	cbi	0x0b, 6	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 254:	88 e2       	ldi	r24, 0x28	; 40
 256:	8a 95       	dec	r24
 258:	f1 f7       	brne	.-4      	; 0x256 <FIFO_init+0x12>
	_delay_us(10);
	FIFO_RCLK_SET;
 25a:	5c 9a       	sbi	0x0b, 4	; 11
 25c:	88 e2       	ldi	r24, 0x28	; 40
 25e:	8a 95       	dec	r24
 260:	f1 f7       	brne	.-4      	; 0x25e <FIFO_init+0x1a>
	_delay_us(10);
	FIFO_RCLK_CLR;
 262:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_CLR;
 264:	5f 98       	cbi	0x0b, 7	; 11
 266:	88 e2       	ldi	r24, 0x28	; 40
 268:	8a 95       	dec	r24
 26a:	f1 f7       	brne	.-4      	; 0x268 <FIFO_init+0x24>
	_delay_us(10);
	FIFO_RCLK_SET;
 26c:	5c 9a       	sbi	0x0b, 4	; 11
 26e:	88 e2       	ldi	r24, 0x28	; 40
 270:	8a 95       	dec	r24
 272:	f1 f7       	brne	.-4      	; 0x270 <FIFO_init+0x2c>
	_delay_us(10);
	FIFO_RCLK_CLR;
 274:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_nRRST_SET;
 276:	5f 9a       	sbi	0x0b, 7	; 11
 278:	88 e2       	ldi	r24, 0x28	; 40
 27a:	8a 95       	dec	r24
 27c:	f1 f7       	brne	.-4      	; 0x27a <FIFO_init+0x36>
	_delay_us(10);
	FIFO_WRST_SET;
 27e:	5b 9a       	sbi	0x0b, 3	; 11
	return 0x01; //okay
}
 280:	81 e0       	ldi	r24, 0x01	; 1
 282:	08 95       	ret

00000284 <FIFO_TO_AVR>:
//Write one pixel in AVR
uint16_t FIFO_TO_AVR(void)
{
	uint16_t data = 0;
	
	FIFO_AVR_DPRT=0;
 284:	11 b8       	out	0x01, r1	; 1
	
	FIFO_RCLK_SET;
 286:	5c 9a       	sbi	0x0b, 4	; 11
	data = FIFO_AVR_PINP;
 288:	80 b1       	in	r24, 0x00	; 0
	FIFO_RCLK_CLR;
 28a:	5c 98       	cbi	0x0b, 4	; 11

	data <<= 8;
 28c:	38 2f       	mov	r19, r24
 28e:	20 e0       	ldi	r18, 0x00	; 0
	
	FIFO_RCLK_SET;
 290:	5c 9a       	sbi	0x0b, 4	; 11
	data |= FIFO_AVR_PINP;
 292:	80 b1       	in	r24, 0x00	; 0
	FIFO_RCLK_CLR;
 294:	5c 98       	cbi	0x0b, 4	; 11
	FIFO_RCLK_CLR;

	data <<= 8;
	
	FIFO_RCLK_SET;
	data |= FIFO_AVR_PINP;
 296:	90 e0       	ldi	r25, 0x00	; 0
 298:	82 2b       	or	r24, r18
 29a:	93 2b       	or	r25, r19
	//	FIFO_RCLK_CLR;
	//	FIFO_RCLK_SET;
	//	FIFO_RCLK_CLR;
	
	return(data);
 29c:	08 95       	ret

0000029e <GetImageIfAvailiable>:
	FIFO_WRST_SET;
}

//Reads all data from the buffer if an image has been written
uint8_t GetImageIfAvailiable( void )
{
 29e:	ef 92       	push	r14
 2a0:	ff 92       	push	r15
 2a2:	0f 93       	push	r16
 2a4:	1f 93       	push	r17
 2a6:	cf 93       	push	r28
 2a8:	df 93       	push	r29
	if (VSYNC_Count == 2)//if one full frame has elapsed.
 2aa:	80 91 2e 03 	lds	r24, 0x032E
 2ae:	90 91 2f 03 	lds	r25, 0x032F
 2b2:	82 30       	cpi	r24, 0x02	; 2
 2b4:	91 05       	cpc	r25, r1
 2b6:	41 f5       	brne	.+80     	; 0x308 <GetImageIfAvailiable+0x6a>
	{
		
		unsigned int i,j;
		uint16_t Temp;
		FIFO_nRRST_CLR; //Reset Read Pointer
 2b8:	5f 98       	cbi	0x0b, 7	; 11
		FIFO_RCLK_SET;
 2ba:	5c 9a       	sbi	0x0b, 4	; 11
		FIFO_RCLK_CLR;
 2bc:	5c 98       	cbi	0x0b, 4	; 11
		FIFO_nRRST_SET;
 2be:	5f 9a       	sbi	0x0b, 7	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2c0:	87 eb       	ldi	r24, 0xB7	; 183
 2c2:	9b e0       	ldi	r25, 0x0B	; 11
 2c4:	01 97       	sbiw	r24, 0x01	; 1
 2c6:	f1 f7       	brne	.-4      	; 0x2c4 <GetImageIfAvailiable+0x26>
 2c8:	00 c0       	rjmp	.+0      	; 0x2ca <GetImageIfAvailiable+0x2c>
 2ca:	00 00       	nop
 2cc:	00 ef       	ldi	r16, 0xF0	; 240
 2ce:	10 e0       	ldi	r17, 0x00	; 0
	FIFO_WRST_SET;
}

//Reads all data from the buffer if an image has been written
uint8_t GetImageIfAvailiable( void )
{
 2d0:	0f 2e       	mov	r0, r31
 2d2:	f0 e4       	ldi	r31, 0x40	; 64
 2d4:	ef 2e       	mov	r14, r31
 2d6:	f1 e0       	ldi	r31, 0x01	; 1
 2d8:	ff 2e       	mov	r15, r31
 2da:	f0 2d       	mov	r31, r0
 2dc:	09 c0       	rjmp	.+18     	; 0x2f0 <GetImageIfAvailiable+0x52>
		_delay_ms(1);
		for (j=0; j < HEIGHT; j++) //Read all data
		{
			for (i=0; i < WIDTH; i++)
			{
				Temp=FIFO_TO_AVR();
 2de:	0e 94 42 01 	call	0x284	; 0x284 <FIFO_TO_AVR>
				//CHANGE HERE TO STORE IMAGE ELSE WEHRE
				USART0_Senduint16(Temp);//Send to computer 
 2e2:	0e 94 a3 02 	call	0x546	; 0x546 <USART0_Senduint16>
 2e6:	21 97       	sbiw	r28, 0x01	; 1
		FIFO_RCLK_CLR;
		FIFO_nRRST_SET;
		_delay_ms(1);
		for (j=0; j < HEIGHT; j++) //Read all data
		{
			for (i=0; i < WIDTH; i++)
 2e8:	d1 f7       	brne	.-12     	; 0x2de <GetImageIfAvailiable+0x40>
 2ea:	01 50       	subi	r16, 0x01	; 1
 2ec:	10 40       	sbci	r17, 0x00	; 0
		FIFO_nRRST_CLR; //Reset Read Pointer
		FIFO_RCLK_SET;
		FIFO_RCLK_CLR;
		FIFO_nRRST_SET;
		_delay_ms(1);
		for (j=0; j < HEIGHT; j++) //Read all data
 2ee:	11 f0       	breq	.+4      	; 0x2f4 <GetImageIfAvailiable+0x56>
	FIFO_WRST_SET;
}

//Reads all data from the buffer if an image has been written
uint8_t GetImageIfAvailiable( void )
{
 2f0:	e7 01       	movw	r28, r14
 2f2:	f5 cf       	rjmp	.-22     	; 0x2de <GetImageIfAvailiable+0x40>
				//CHANGE HERE TO STORE IMAGE ELSE WEHRE
				USART0_Senduint16(Temp);//Send to computer 
			}
		}
		/*FIFO_Reset();*/
		FIFO_nRRST_CLR; //Reset Read Pointer	
 2f4:	5f 98       	cbi	0x0b, 7	; 11
		FIFO_RCLK_SET;
 2f6:	5c 9a       	sbi	0x0b, 4	; 11
		FIFO_RCLK_CLR;
 2f8:	5c 98       	cbi	0x0b, 4	; 11
		FIFO_nRRST_SET;
 2fa:	5f 9a       	sbi	0x0b, 7	; 11
		VSYNC_Count = 0; //No image present in buffer
 2fc:	10 92 2f 03 	sts	0x032F, r1
 300:	10 92 2e 03 	sts	0x032E, r1
		return 1; //Success!
 304:	81 e0       	ldi	r24, 0x01	; 1
 306:	01 c0       	rjmp	.+2      	; 0x30a <GetImageIfAvailiable+0x6c>
	}
	else
	{
		return 0;// No image available
 308:	80 e0       	ldi	r24, 0x00	; 0
	}
}
 30a:	df 91       	pop	r29
 30c:	cf 91       	pop	r28
 30e:	1f 91       	pop	r17
 310:	0f 91       	pop	r16
 312:	ff 90       	pop	r15
 314:	ef 90       	pop	r14
 316:	08 95       	ret

00000318 <TWI_Master_Initialise>:
		DDRC = 0x00;
		PORTC = (1 << PC0) | (1 << PC1);
	#else
		#pragma message("External Pull Ups Required.")
	#endif
	TWBR = TWI_TWBR;                                  // Set bit rate register (Baudrate). Defined in header file.
 318:	84 e3       	ldi	r24, 0x34	; 52
 31a:	80 93 b8 00 	sts	0x00B8, r24
	// TWSR = TWI_TWPS;                                  // Not used. Driver presumes prescaler to be 00.
	TWDR = 0xFF;                                      // Default content = SDA released.
 31e:	8f ef       	ldi	r24, 0xFF	; 255
 320:	80 93 bb 00 	sts	0x00BB, r24
	TWCR =	(1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
 324:	84 e0       	ldi	r24, 0x04	; 4
 326:	80 93 bc 00 	sts	0x00BC, r24
			(0<<TWIE)|(0<<TWINT)|                      // Disable Interupt.
			(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests.
			(0<<TWWC);                                 //
}    
 32a:	08 95       	ret

0000032c <TWI_Transceiver_Busy>:
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
 32c:	80 91 bc 00 	lds	r24, 0x00BC
}
 330:	81 70       	andi	r24, 0x01	; 1
 332:	08 95       	ret

00000334 <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
 334:	0e 94 96 01 	call	0x32c	; 0x32c <TWI_Transceiver_Busy>
 338:	88 23       	and	r24, r24
 33a:	e1 f7       	brne	.-8      	; 0x334 <TWI_Get_State_Info>
  return ( TWI_state );                         // Return error state.
}
 33c:	80 91 60 02 	lds	r24, 0x0260
 340:	08 95       	ret

00000342 <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
 342:	0f 93       	push	r16
 344:	1f 93       	push	r17
 346:	cf 93       	push	r28
 348:	8c 01       	movw	r16, r24
 34a:	c6 2f       	mov	r28, r22
  unsigned char temp;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
 34c:	0e 94 96 01 	call	0x32c	; 0x32c <TWI_Transceiver_Busy>
 350:	88 23       	and	r24, r24
 352:	e1 f7       	brne	.-8      	; 0x34c <TWI_Start_Transceiver_With_Data+0xa>

  TWI_msgSize = msgSize;                        // Number of data to transmit.
 354:	c0 93 27 03 	sts	0x0327, r28
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
 358:	f8 01       	movw	r30, r16
 35a:	80 81       	ld	r24, Z
 35c:	80 93 28 03 	sts	0x0328, r24
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
 360:	80 fd       	sbrc	r24, 0
 362:	0c c0       	rjmp	.+24     	; 0x37c <TWI_Start_Transceiver_With_Data+0x3a>
  {
    for ( temp = 1; temp < msgSize; temp++ )
 364:	c2 30       	cpi	r28, 0x02	; 2
 366:	50 f0       	brcs	.+20     	; 0x37c <TWI_Start_Transceiver_With_Data+0x3a>
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
 368:	d8 01       	movw	r26, r16
 36a:	11 96       	adiw	r26, 0x01	; 1

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
 36c:	e9 e2       	ldi	r30, 0x29	; 41
 36e:	f3 e0       	ldi	r31, 0x03	; 3
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
 370:	81 e0       	ldi	r24, 0x01	; 1
  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
      TWI_buf[ temp ] = msg[ temp ];
 372:	9d 91       	ld	r25, X+
 374:	91 93       	st	Z+, r25

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
 376:	8f 5f       	subi	r24, 0xFF	; 255
 378:	8c 17       	cp	r24, r28
 37a:	d9 f7       	brne	.-10     	; 0x372 <TWI_Start_Transceiver_With_Data+0x30>
      TWI_buf[ temp ] = msg[ temp ];
  }
  TWI_statusReg.all = 0;      
 37c:	10 92 26 03 	sts	0x0326, r1
  TWI_state         = TWI_NO_STATE ;
 380:	88 ef       	ldi	r24, 0xF8	; 248
 382:	80 93 60 02 	sts	0x0260, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
 386:	85 ea       	ldi	r24, 0xA5	; 165
 388:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
 38c:	cf 91       	pop	r28
 38e:	1f 91       	pop	r17
 390:	0f 91       	pop	r16
 392:	08 95       	ret

00000394 <TWI_Start_Transceiver>:
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
 394:	0e 94 96 01 	call	0x32c	; 0x32c <TWI_Transceiver_Busy>
 398:	88 23       	and	r24, r24
 39a:	e1 f7       	brne	.-8      	; 0x394 <TWI_Start_Transceiver>
  TWI_statusReg.all = 0;      
 39c:	10 92 26 03 	sts	0x0326, r1
  TWI_state         = TWI_NO_STATE ;
 3a0:	88 ef       	ldi	r24, 0xF8	; 248
 3a2:	80 93 60 02 	sts	0x0260, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
 3a6:	85 ea       	ldi	r24, 0xA5	; 165
 3a8:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
 3ac:	08 95       	ret

000003ae <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
 3ae:	1f 93       	push	r17
 3b0:	cf 93       	push	r28
 3b2:	df 93       	push	r29
 3b4:	d8 2f       	mov	r29, r24
 3b6:	19 2f       	mov	r17, r25
 3b8:	c6 2f       	mov	r28, r22
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
 3ba:	0e 94 96 01 	call	0x32c	; 0x32c <TWI_Transceiver_Busy>
 3be:	88 23       	and	r24, r24
 3c0:	e1 f7       	brne	.-8      	; 0x3ba <TWI_Get_Data_From_Transceiver+0xc>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
 3c2:	80 91 26 03 	lds	r24, 0x0326
 3c6:	80 ff       	sbrs	r24, 0
 3c8:	0d c0       	rjmp	.+26     	; 0x3e4 <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
 3ca:	cc 23       	and	r28, r28
 3cc:	59 f0       	breq	.+22     	; 0x3e4 <TWI_Get_Data_From_Transceiver+0x36>
 3ce:	a8 e2       	ldi	r26, 0x28	; 40
 3d0:	b3 e0       	ldi	r27, 0x03	; 3
 3d2:	9d 2f       	mov	r25, r29
 3d4:	ed 2f       	mov	r30, r29
 3d6:	f1 2f       	mov	r31, r17
    {
      msg[ i ] = TWI_buf[ i ];
 3d8:	8d 91       	ld	r24, X+
 3da:	81 93       	st	Z+, r24

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
 3dc:	8e 2f       	mov	r24, r30
 3de:	89 1b       	sub	r24, r25
 3e0:	8c 17       	cp	r24, r28
 3e2:	d0 f3       	brcs	.-12     	; 0x3d8 <TWI_Get_Data_From_Transceiver+0x2a>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
 3e4:	80 91 26 03 	lds	r24, 0x0326
}
 3e8:	81 70       	andi	r24, 0x01	; 1
 3ea:	df 91       	pop	r29
 3ec:	cf 91       	pop	r28
 3ee:	1f 91       	pop	r17
 3f0:	08 95       	ret

000003f2 <__vector_26>:
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/

ISR(TWI_vect)
{
 3f2:	1f 92       	push	r1
 3f4:	0f 92       	push	r0
 3f6:	0f b6       	in	r0, 0x3f	; 63
 3f8:	0f 92       	push	r0
 3fa:	11 24       	eor	r1, r1
 3fc:	2f 93       	push	r18
 3fe:	3f 93       	push	r19
 400:	8f 93       	push	r24
 402:	9f 93       	push	r25
 404:	ef 93       	push	r30
 406:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
 408:	80 91 b9 00 	lds	r24, 0x00B9
 40c:	88 32       	cpi	r24, 0x28	; 40
 40e:	d1 f0       	breq	.+52     	; 0x444 <__vector_26+0x52>
 410:	89 32       	cpi	r24, 0x29	; 41
 412:	40 f4       	brcc	.+16     	; 0x424 <__vector_26+0x32>
 414:	80 31       	cpi	r24, 0x10	; 16
 416:	a1 f0       	breq	.+40     	; 0x440 <__vector_26+0x4e>
 418:	88 31       	cpi	r24, 0x18	; 24
 41a:	a1 f0       	breq	.+40     	; 0x444 <__vector_26+0x52>
 41c:	88 30       	cpi	r24, 0x08	; 8
 41e:	09 f0       	breq	.+2      	; 0x422 <__vector_26+0x30>
 420:	61 c0       	rjmp	.+194    	; 0x4e4 <__vector_26+0xf2>
 422:	0e c0       	rjmp	.+28     	; 0x440 <__vector_26+0x4e>
 424:	80 34       	cpi	r24, 0x40	; 64
 426:	b9 f1       	breq	.+110    	; 0x496 <__vector_26+0xa4>
 428:	81 34       	cpi	r24, 0x41	; 65
 42a:	20 f4       	brcc	.+8      	; 0x434 <__vector_26+0x42>
 42c:	88 33       	cpi	r24, 0x38	; 56
 42e:	09 f0       	breq	.+2      	; 0x432 <__vector_26+0x40>
 430:	59 c0       	rjmp	.+178    	; 0x4e4 <__vector_26+0xf2>
 432:	54 c0       	rjmp	.+168    	; 0x4dc <__vector_26+0xea>
 434:	80 35       	cpi	r24, 0x50	; 80
 436:	19 f1       	breq	.+70     	; 0x47e <__vector_26+0x8c>
 438:	88 35       	cpi	r24, 0x58	; 88
 43a:	09 f0       	breq	.+2      	; 0x43e <__vector_26+0x4c>
 43c:	53 c0       	rjmp	.+166    	; 0x4e4 <__vector_26+0xf2>
 43e:	3d c0       	rjmp	.+122    	; 0x4ba <__vector_26+0xc8>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
 440:	10 92 2c 03 	sts	0x032C, r1
    case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
 444:	80 91 2c 03 	lds	r24, 0x032C
 448:	90 91 27 03 	lds	r25, 0x0327
 44c:	89 17       	cp	r24, r25
 44e:	70 f4       	brcc	.+28     	; 0x46c <__vector_26+0x7a>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
 450:	e8 2f       	mov	r30, r24
 452:	f0 e0       	ldi	r31, 0x00	; 0
 454:	e8 5d       	subi	r30, 0xD8	; 216
 456:	fc 4f       	sbci	r31, 0xFC	; 252
 458:	90 81       	ld	r25, Z
 45a:	90 93 bb 00 	sts	0x00BB, r25
 45e:	8f 5f       	subi	r24, 0xFF	; 255
 460:	80 93 2c 03 	sts	0x032C, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 464:	85 e8       	ldi	r24, 0x85	; 133
 466:	80 93 bc 00 	sts	0x00BC, r24
 46a:	43 c0       	rjmp	.+134    	; 0x4f2 <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
 46c:	80 91 26 03 	lds	r24, 0x0326
 470:	81 60       	ori	r24, 0x01	; 1
 472:	80 93 26 03 	sts	0x0326, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 476:	84 e9       	ldi	r24, 0x94	; 148
 478:	80 93 bc 00 	sts	0x00BC, r24
 47c:	3a c0       	rjmp	.+116    	; 0x4f2 <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
 47e:	80 91 2c 03 	lds	r24, 0x032C
 482:	90 91 bb 00 	lds	r25, 0x00BB
 486:	e8 2f       	mov	r30, r24
 488:	f0 e0       	ldi	r31, 0x00	; 0
 48a:	e8 5d       	subi	r30, 0xD8	; 216
 48c:	fc 4f       	sbci	r31, 0xFC	; 252
 48e:	90 83       	st	Z, r25
 490:	8f 5f       	subi	r24, 0xFF	; 255
 492:	80 93 2c 03 	sts	0x032C, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
 496:	20 91 2c 03 	lds	r18, 0x032C
 49a:	30 e0       	ldi	r19, 0x00	; 0
 49c:	80 91 27 03 	lds	r24, 0x0327
 4a0:	90 e0       	ldi	r25, 0x00	; 0
 4a2:	01 97       	sbiw	r24, 0x01	; 1
 4a4:	28 17       	cp	r18, r24
 4a6:	39 07       	cpc	r19, r25
 4a8:	24 f4       	brge	.+8      	; 0x4b2 <__vector_26+0xc0>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 4aa:	85 ec       	ldi	r24, 0xC5	; 197
 4ac:	80 93 bc 00 	sts	0x00BC, r24
 4b0:	20 c0       	rjmp	.+64     	; 0x4f2 <__vector_26+0x100>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 4b2:	85 e8       	ldi	r24, 0x85	; 133
 4b4:	80 93 bc 00 	sts	0x00BC, r24
 4b8:	1c c0       	rjmp	.+56     	; 0x4f2 <__vector_26+0x100>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
      TWI_buf[TWI_bufPtr] = TWDR;
 4ba:	80 91 bb 00 	lds	r24, 0x00BB
 4be:	e0 91 2c 03 	lds	r30, 0x032C
 4c2:	f0 e0       	ldi	r31, 0x00	; 0
 4c4:	e8 5d       	subi	r30, 0xD8	; 216
 4c6:	fc 4f       	sbci	r31, 0xFC	; 252
 4c8:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
 4ca:	80 91 26 03 	lds	r24, 0x0326
 4ce:	81 60       	ori	r24, 0x01	; 1
 4d0:	80 93 26 03 	sts	0x0326, r24
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 4d4:	84 e9       	ldi	r24, 0x94	; 148
 4d6:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
 4da:	0b c0       	rjmp	.+22     	; 0x4f2 <__vector_26+0x100>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 4dc:	85 ea       	ldi	r24, 0xA5	; 165
 4de:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
 4e2:	07 c0       	rjmp	.+14     	; 0x4f2 <__vector_26+0x100>
    case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
//    case TWI_NO_STATE              // No relevant state information available; TWINT = “0”
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
 4e4:	80 91 b9 00 	lds	r24, 0x00B9
 4e8:	80 93 60 02 	sts	0x0260, r24
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
 4ec:	84 e0       	ldi	r24, 0x04	; 4
 4ee:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
 4f2:	ff 91       	pop	r31
 4f4:	ef 91       	pop	r30
 4f6:	9f 91       	pop	r25
 4f8:	8f 91       	pop	r24
 4fa:	3f 91       	pop	r19
 4fc:	2f 91       	pop	r18
 4fe:	0f 90       	pop	r0
 500:	0f be       	out	0x3f, r0	; 63
 502:	0f 90       	pop	r0
 504:	1f 90       	pop	r1
 506:	18 95       	reti

00000508 <USART0_Init>:


void USART0_Init (unsigned int ubrr)
{
	//Set baud rate
	UBRR0H = (unsigned char)(ubrr>>8);
 508:	90 93 c5 00 	sts	0x00C5, r25
	UBRR0L = (unsigned char)ubrr;
 50c:	80 93 c4 00 	sts	0x00C4, r24
	//Enable receiver and transmitter
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
 510:	e1 ec       	ldi	r30, 0xC1	; 193
 512:	f0 e0       	ldi	r31, 0x00	; 0
 514:	88 e1       	ldi	r24, 0x18	; 24
 516:	80 83       	st	Z, r24
	
	UCSR0C = 0x06; //set asynchronous, no parity, one stop bit, 8 bit transfer.
 518:	86 e0       	ldi	r24, 0x06	; 6
 51a:	80 93 c2 00 	sts	0x00C2, r24
	
	UCSR0B |= (1 << RXCIE0); //set RX interrupt on
 51e:	80 81       	ld	r24, Z
 520:	80 68       	ori	r24, 0x80	; 128
 522:	80 83       	st	Z, r24

}
 524:	08 95       	ret

00000526 <USART0_SendChar>:
void USART0_SendChar( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) )
 526:	e0 ec       	ldi	r30, 0xC0	; 192
 528:	f0 e0       	ldi	r31, 0x00	; 0
 52a:	90 81       	ld	r25, Z
 52c:	95 ff       	sbrs	r25, 5
 52e:	fd cf       	rjmp	.-6      	; 0x52a <USART0_SendChar+0x4>
	;
	/* Put data into buffer, sends the data */
	UDR0 = data;
 530:	80 93 c6 00 	sts	0x00C6, r24
}
 534:	08 95       	ret

00000536 <USART0_Receive>:
	USART0_SendString(buff);
}
unsigned char USART0_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
 536:	e0 ec       	ldi	r30, 0xC0	; 192
 538:	f0 e0       	ldi	r31, 0x00	; 0
 53a:	80 81       	ld	r24, Z
 53c:	88 23       	and	r24, r24
 53e:	ec f7       	brge	.-6      	; 0x53a <USART0_Receive+0x4>
	;
	/* Get and return received data from buffer */
	return UDR0;
 540:	80 91 c6 00 	lds	r24, 0x00C6
}
 544:	08 95       	ret

00000546 <USART0_Senduint16>:
void USART0_Senduint16 (uint16_t Data)
{	
 546:	cf 93       	push	r28
 548:	c8 2f       	mov	r28, r24
	USART0_SendChar(Data >> 8);
 54a:	89 2f       	mov	r24, r25
 54c:	0e 94 93 02 	call	0x526	; 0x526 <USART0_SendChar>
	USART0_SendChar(Data & 0xFF);
 550:	8c 2f       	mov	r24, r28
 552:	0e 94 93 02 	call	0x526	; 0x526 <USART0_SendChar>
}
 556:	cf 91       	pop	r28
 558:	08 95       	ret

0000055a <__vector_20>:
ISR(USART0_RX_vect) //trigger interrupt when uart1 receives data   USART_RXC1_vect
{
 55a:	1f 92       	push	r1
 55c:	0f 92       	push	r0
 55e:	0f b6       	in	r0, 0x3f	; 63
 560:	0f 92       	push	r0
 562:	11 24       	eor	r1, r1
 564:	8f 93       	push	r24
	// Code to be executed when the USART receives a byte here
	Received0 = UDR0; // Fetch the received byte value into the variable "Received0"
 566:	80 91 c6 00 	lds	r24, 0x00C6
 56a:	80 93 2d 03 	sts	0x032D, r24
	//USART0_SendChar(Received0);
}
 56e:	8f 91       	pop	r24
 570:	0f 90       	pop	r0
 572:	0f be       	out	0x3f, r0	; 63
 574:	0f 90       	pop	r0
 576:	1f 90       	pop	r1
 578:	18 95       	reti

0000057a <USART0_SendString>:

void USART0_SendString( char str[] )
{
 57a:	0f 93       	push	r16
 57c:	1f 93       	push	r17
 57e:	cf 93       	push	r28
 580:	8c 01       	movw	r16, r24
	uint8_t ptr = 0;
	while(str[ptr])
 582:	fc 01       	movw	r30, r24
 584:	80 81       	ld	r24, Z
 586:	88 23       	and	r24, r24
 588:	51 f0       	breq	.+20     	; 0x59e <USART0_SendString+0x24>
	//USART0_SendChar(Received0);
}

void USART0_SendString( char str[] )
{
	uint8_t ptr = 0;
 58a:	c0 e0       	ldi	r28, 0x00	; 0
	while(str[ptr])
	{
		USART0_SendChar(str[ptr++]);
 58c:	cf 5f       	subi	r28, 0xFF	; 255
 58e:	0e 94 93 02 	call	0x526	; 0x526 <USART0_SendChar>
}

void USART0_SendString( char str[] )
{
	uint8_t ptr = 0;
	while(str[ptr])
 592:	f8 01       	movw	r30, r16
 594:	ec 0f       	add	r30, r28
 596:	f1 1d       	adc	r31, r1
 598:	80 81       	ld	r24, Z
 59a:	88 23       	and	r24, r24
 59c:	b9 f7       	brne	.-18     	; 0x58c <USART0_SendString+0x12>
	{
		USART0_SendChar(str[ptr++]);
	}
	
}
 59e:	cf 91       	pop	r28
 5a0:	1f 91       	pop	r17
 5a2:	0f 91       	pop	r16
 5a4:	08 95       	ret

000005a6 <USART0_SendHex>:
	char buff[5];
	itoa(Data, buff, 10);
	USART0_SendString(buff);
}
void USART0_SendHex( uint8_t Data)
{
 5a6:	cf 93       	push	r28
 5a8:	df 93       	push	r29
 5aa:	00 d0       	rcall	.+0      	; 0x5ac <USART0_SendHex+0x6>
 5ac:	00 d0       	rcall	.+0      	; 0x5ae <USART0_SendHex+0x8>
 5ae:	0f 92       	push	r0
 5b0:	cd b7       	in	r28, 0x3d	; 61
 5b2:	de b7       	in	r29, 0x3e	; 62
	char buff[5];
	itoa(Data, buff, 16);
 5b4:	90 e0       	ldi	r25, 0x00	; 0
 5b6:	be 01       	movw	r22, r28
 5b8:	6f 5f       	subi	r22, 0xFF	; 255
 5ba:	7f 4f       	sbci	r23, 0xFF	; 255
 5bc:	40 e1       	ldi	r20, 0x10	; 16
 5be:	50 e0       	ldi	r21, 0x00	; 0
 5c0:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <itoa>
	USART0_SendString("0x");
 5c4:	81 e6       	ldi	r24, 0x61	; 97
 5c6:	92 e0       	ldi	r25, 0x02	; 2
 5c8:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
	USART0_SendString(buff);
 5cc:	ce 01       	movw	r24, r28
 5ce:	01 96       	adiw	r24, 0x01	; 1
 5d0:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
}
 5d4:	0f 90       	pop	r0
 5d6:	0f 90       	pop	r0
 5d8:	0f 90       	pop	r0
 5da:	0f 90       	pop	r0
 5dc:	0f 90       	pop	r0
 5de:	df 91       	pop	r29
 5e0:	cf 91       	pop	r28
 5e2:	08 95       	ret

000005e4 <USART0_SendInt>:
	;
	/* Put data into buffer, sends the data */
	UDR0 = data;
}
void USART0_SendInt( int Data)
{
 5e4:	cf 93       	push	r28
 5e6:	df 93       	push	r29
 5e8:	00 d0       	rcall	.+0      	; 0x5ea <USART0_SendInt+0x6>
 5ea:	00 d0       	rcall	.+0      	; 0x5ec <USART0_SendInt+0x8>
 5ec:	0f 92       	push	r0
 5ee:	cd b7       	in	r28, 0x3d	; 61
 5f0:	de b7       	in	r29, 0x3e	; 62
	char buff[5];
	itoa(Data, buff, 10);
 5f2:	be 01       	movw	r22, r28
 5f4:	6f 5f       	subi	r22, 0xFF	; 255
 5f6:	7f 4f       	sbci	r23, 0xFF	; 255
 5f8:	4a e0       	ldi	r20, 0x0A	; 10
 5fa:	50 e0       	ldi	r21, 0x00	; 0
 5fc:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <itoa>
	USART0_SendString(buff);
 600:	ce 01       	movw	r24, r28
 602:	01 96       	adiw	r24, 0x01	; 1
 604:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
}
 608:	0f 90       	pop	r0
 60a:	0f 90       	pop	r0
 60c:	0f 90       	pop	r0
 60e:	0f 90       	pop	r0
 610:	0f 90       	pop	r0
 612:	df 91       	pop	r29
 614:	cf 91       	pop	r28
 616:	08 95       	ret

00000618 <main>:
// {
// 	disk_timerproc();
// }
//unsigned char TWI_Buffer[TWI_BUFFER_SIZE];
int main(void)
{
 618:	cf 93       	push	r28
 61a:	df 93       	push	r29
 61c:	0f 92       	push	r0
 61e:	cd b7       	in	r28, 0x3d	; 61
 620:	de b7       	in	r29, 0x3e	; 62
// 	DSTATUS driveStatus;
// 	FATFS FileSystemObject;

	
	USART0_Init(MYUBBR0);//bit rate 250000
 622:	8c e0       	ldi	r24, 0x0C	; 12
 624:	90 e0       	ldi	r25, 0x00	; 0
 626:	0e 94 84 02 	call	0x508	; 0x508 <USART0_Init>
	USART0_SendString("Starting Up...\n\r");
 62a:	84 e6       	ldi	r24, 0x64	; 100
 62c:	92 e0       	ldi	r25, 0x02	; 2
 62e:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
	TWI_Master_Initialise();
 632:	0e 94 8c 01 	call	0x318	; 0x318 <TWI_Master_Initialise>
	USART0_SendString("TWI Initialised.\n\r");
 636:	85 e7       	ldi	r24, 0x75	; 117
 638:	92 e0       	ldi	r25, 0x02	; 2
 63a:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
	sei(); //turn global interrupts on
 63e:	78 94       	sei
	while(1 != FIFO_init()); //initialise buffer
 640:	0e 94 22 01 	call	0x244	; 0x244 <FIFO_init>
 644:	81 30       	cpi	r24, 0x01	; 1
 646:	e1 f7       	brne	.-8      	; 0x640 <main+0x28>
	USART0_SendString("FIFO Buffer Initialised\n\r");
 648:	88 e8       	ldi	r24, 0x88	; 136
 64a:	92 e0       	ldi	r25, 0x02	; 2
 64c:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
	//_delay_ms(1000);
	USART0_SendString("OV7670 Initialise ");	
 650:	82 ea       	ldi	r24, 0xA2	; 162
 652:	92 e0       	ldi	r25, 0x02	; 2
 654:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
	if(1 ==	OV7670_init())
 658:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <OV7670_init>
 65c:	81 30       	cpi	r24, 0x01	; 1
 65e:	29 f4       	brne	.+10     	; 0x66a <main+0x52>
	{
		USART0_SendString("Complete\n\r");
 660:	85 eb       	ldi	r24, 0xB5	; 181
 662:	92 e0       	ldi	r25, 0x02	; 2
 664:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
 668:	04 c0       	rjmp	.+8      	; 0x672 <main+0x5a>
	}
	else
	{
					
		USART0_SendString("Fail\n\r");
 66a:	80 ec       	ldi	r24, 0xC0	; 192
 66c:	92 e0       	ldi	r25, 0x02	; 2
 66e:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
				}
				Received0 = 0;
				break;
				
			case 'R':
				USART0_SendString("\n\rTWI Read;\n\r");
 672:	0f 2e       	mov	r0, r31
 674:	f0 ee       	ldi	r31, 0xE0	; 224
 676:	ef 2e       	mov	r14, r31
 678:	f2 e0       	ldi	r31, 0x02	; 2
 67a:	ff 2e       	mov	r15, r31
 67c:	f0 2d       	mov	r31, r0
					USART0_SendString("TWI Data Returned:\r\n");
					USART0_SendHex(Data);
				}
				else
				{
					USART0_SendString("Read Fail.\n\r");
 67e:	0f 2e       	mov	r0, r31
 680:	f3 e0       	ldi	r31, 0x03	; 3
 682:	8f 2e       	mov	r8, r31
 684:	f3 e0       	ldi	r31, 0x03	; 3
 686:	9f 2e       	mov	r9, r31
 688:	f0 2d       	mov	r31, r0
			case 'R':
				USART0_SendString("\n\rTWI Read;\n\r");
				unsigned char Data;
				if(1 == rdOV7670Reg(OV_PID, &Data))
				{
					USART0_SendString("TWI Data Returned:\r\n");
 68a:	0f 2e       	mov	r0, r31
 68c:	fe ee       	ldi	r31, 0xEE	; 238
 68e:	6f 2e       	mov	r6, r31
 690:	f2 e0       	ldi	r31, 0x02	; 2
 692:	7f 2e       	mov	r7, r31
 694:	f0 2d       	mov	r31, r0
    while(1)
	{
		switch(Received0)
		{
			case 'A':
				USART0_SendString("\n\rTWI Sent;\n\r");
 696:	0f 2e       	mov	r0, r31
 698:	f7 ec       	ldi	r31, 0xC7	; 199
 69a:	cf 2e       	mov	r12, r31
 69c:	f2 e0       	ldi	r31, 0x02	; 2
 69e:	df 2e       	mov	r13, r31
 6a0:	f0 2d       	mov	r31, r0
				{
					USART0_SendString("Success!\n\r");
				}
				else
				{
					USART0_SendString("Fail\n\r");
 6a2:	00 ec       	ldi	r16, 0xC0	; 192
 6a4:	12 e0       	ldi	r17, 0x02	; 2
		{
			case 'A':
				USART0_SendString("\n\rTWI Sent;\n\r");
				if(1 == wrOV7670Reg(OV_COM7, 0x80))
				{
					USART0_SendString("Success!\n\r");
 6a6:	0f 2e       	mov	r0, r31
 6a8:	f5 ed       	ldi	r31, 0xD5	; 213
 6aa:	4f 2e       	mov	r4, r31
 6ac:	f2 e0       	ldi	r31, 0x02	; 2
 6ae:	5f 2e       	mov	r5, r31
 6b0:	f0 2d       	mov	r31, r0
				}
				Received0 = 0;
				break;
				
			case 'I':
				USART0_SendString("\n\rOV7670 Initialise ");
 6b2:	0f 2e       	mov	r0, r31
 6b4:	f0 e1       	ldi	r31, 0x10	; 16
 6b6:	af 2e       	mov	r10, r31
 6b8:	f3 e0       	ldi	r31, 0x03	; 3
 6ba:	bf 2e       	mov	r11, r31
 6bc:	f0 2d       	mov	r31, r0
				if(1 ==	OV7670_init())
				{
					USART0_SendString("Complete\n\r");
 6be:	0f 2e       	mov	r0, r31
 6c0:	f5 eb       	ldi	r31, 0xB5	; 181
 6c2:	2f 2e       	mov	r2, r31
 6c4:	f2 e0       	ldi	r31, 0x02	; 2
 6c6:	3f 2e       	mov	r3, r31
 6c8:	f0 2d       	mov	r31, r0
// 	DDRB =  0b10110000;      // !SS,SCK and MOSI outputs

	
    while(1)
	{
		switch(Received0)
 6ca:	80 91 2d 03 	lds	r24, 0x032D
 6ce:	80 35       	cpi	r24, 0x50	; 80
 6d0:	09 f4       	brne	.+2      	; 0x6d4 <main+0xbc>
 6d2:	53 c0       	rjmp	.+166    	; 0x77a <main+0x162>
 6d4:	81 35       	cpi	r24, 0x51	; 81
 6d6:	30 f4       	brcc	.+12     	; 0x6e4 <main+0xcc>
 6d8:	81 34       	cpi	r24, 0x41	; 65
 6da:	71 f0       	breq	.+28     	; 0x6f8 <main+0xe0>
 6dc:	89 34       	cpi	r24, 0x49	; 73
 6de:	09 f0       	breq	.+2      	; 0x6e2 <main+0xca>
 6e0:	5c c0       	rjmp	.+184    	; 0x79a <main+0x182>
 6e2:	35 c0       	rjmp	.+106    	; 0x74e <main+0x136>
 6e4:	84 35       	cpi	r24, 0x54	; 84
 6e6:	09 f4       	brne	.+2      	; 0x6ea <main+0xd2>
 6e8:	43 c0       	rjmp	.+134    	; 0x770 <main+0x158>
 6ea:	81 37       	cpi	r24, 0x71	; 113
 6ec:	09 f4       	brne	.+2      	; 0x6f0 <main+0xd8>
 6ee:	4e c0       	rjmp	.+156    	; 0x78c <main+0x174>
 6f0:	82 35       	cpi	r24, 0x52	; 82
 6f2:	09 f0       	breq	.+2      	; 0x6f6 <main+0xde>
 6f4:	52 c0       	rjmp	.+164    	; 0x79a <main+0x182>
 6f6:	13 c0       	rjmp	.+38     	; 0x71e <main+0x106>
		{
			case 'A':
				USART0_SendString("\n\rTWI Sent;\n\r");
 6f8:	c6 01       	movw	r24, r12
 6fa:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
				if(1 == wrOV7670Reg(OV_COM7, 0x80))
 6fe:	82 e1       	ldi	r24, 0x12	; 18
 700:	60 e8       	ldi	r22, 0x80	; 128
 702:	0e 94 8a 00 	call	0x114	; 0x114 <wrOV7670Reg>
 706:	81 30       	cpi	r24, 0x01	; 1
 708:	21 f4       	brne	.+8      	; 0x712 <main+0xfa>
				{
					USART0_SendString("Success!\n\r");
 70a:	c2 01       	movw	r24, r4
 70c:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
 710:	03 c0       	rjmp	.+6      	; 0x718 <main+0x100>
				}
				else
				{
					USART0_SendString("Fail\n\r");
 712:	c8 01       	movw	r24, r16
 714:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
				}
				Received0 = 0;
 718:	10 92 2d 03 	sts	0x032D, r1
				break;
 71c:	d6 cf       	rjmp	.-84     	; 0x6ca <main+0xb2>
				
			case 'R':
				USART0_SendString("\n\rTWI Read;\n\r");
 71e:	c7 01       	movw	r24, r14
 720:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
				unsigned char Data;
				if(1 == rdOV7670Reg(OV_PID, &Data))
 724:	8a e0       	ldi	r24, 0x0A	; 10
 726:	be 01       	movw	r22, r28
 728:	6f 5f       	subi	r22, 0xFF	; 255
 72a:	7f 4f       	sbci	r23, 0xFF	; 255
 72c:	0e 94 a7 00 	call	0x14e	; 0x14e <rdOV7670Reg>
 730:	81 30       	cpi	r24, 0x01	; 1
 732:	39 f4       	brne	.+14     	; 0x742 <main+0x12a>
				{
					USART0_SendString("TWI Data Returned:\r\n");
 734:	c3 01       	movw	r24, r6
 736:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
					USART0_SendHex(Data);
 73a:	89 81       	ldd	r24, Y+1	; 0x01
 73c:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <USART0_SendHex>
 740:	03 c0       	rjmp	.+6      	; 0x748 <main+0x130>
				}
				else
				{
					USART0_SendString("Read Fail.\n\r");
 742:	c4 01       	movw	r24, r8
 744:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
				}
				Received0 = 0;
 748:	10 92 2d 03 	sts	0x032D, r1
				break;
 74c:	be cf       	rjmp	.-132    	; 0x6ca <main+0xb2>
				
			case 'I':
				USART0_SendString("\n\rOV7670 Initialise ");
 74e:	c5 01       	movw	r24, r10
 750:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
				if(1 ==	OV7670_init())
 754:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <OV7670_init>
 758:	81 30       	cpi	r24, 0x01	; 1
 75a:	21 f4       	brne	.+8      	; 0x764 <main+0x14c>
				{
					USART0_SendString("Complete\n\r");
 75c:	c1 01       	movw	r24, r2
 75e:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
 762:	03 c0       	rjmp	.+6      	; 0x76a <main+0x152>
				}
				else
				{
					
					USART0_SendString("Fail\n\r");
 764:	c8 01       	movw	r24, r16
 766:	0e 94 bd 02 	call	0x57a	; 0x57a <USART0_SendString>
				}
				Received0 = 0;
 76a:	10 92 2d 03 	sts	0x032D, r1
				break;
 76e:	ad cf       	rjmp	.-166    	; 0x6ca <main+0xb2>
			case 'T':
				TWI_Master_Initialise();
 770:	0e 94 8c 01 	call	0x318	; 0x318 <TWI_Master_Initialise>
				Received0 = 0;
 774:	10 92 2d 03 	sts	0x032D, r1
				break;
 778:	a8 cf       	rjmp	.-176    	; 0x6ca <main+0xb2>
			case 'P':
				LoadImageToBuffer();
 77a:	0e 94 15 01 	call	0x22a	; 0x22a <LoadImageToBuffer>
				while (1 != GetImageIfAvailiable()) ;
 77e:	0e 94 4f 01 	call	0x29e	; 0x29e <GetImageIfAvailiable>
 782:	81 30       	cpi	r24, 0x01	; 1
 784:	e1 f7       	brne	.-8      	; 0x77e <main+0x166>
				Received0 = 0;
 786:	10 92 2d 03 	sts	0x032D, r1
				break;
 78a:	9f cf       	rjmp	.-194    	; 0x6ca <main+0xb2>
			case 'q':
				wrOV7670Reg(OV_COM7, 0x80);
 78c:	82 e1       	ldi	r24, 0x12	; 18
 78e:	60 e8       	ldi	r22, 0x80	; 128
 790:	0e 94 8a 00 	call	0x114	; 0x114 <wrOV7670Reg>
				Received0 = 0;
 794:	10 92 2d 03 	sts	0x032D, r1
				break;
 798:	98 cf       	rjmp	.-208    	; 0x6ca <main+0xb2>
// 				Received0 = 0;
// 				break;
				
			
			default:
				Received0 = Received0;
 79a:	80 91 2d 03 	lds	r24, 0x032D
 79e:	80 93 2d 03 	sts	0x032D, r24
				break;
 7a2:	93 cf       	rjmp	.-218    	; 0x6ca <main+0xb2>

000007a4 <itoa>:
 7a4:	fb 01       	movw	r30, r22
 7a6:	9f 01       	movw	r18, r30
 7a8:	e8 94       	clt
 7aa:	42 30       	cpi	r20, 0x02	; 2
 7ac:	c4 f0       	brlt	.+48     	; 0x7de <itoa+0x3a>
 7ae:	45 32       	cpi	r20, 0x25	; 37
 7b0:	b4 f4       	brge	.+44     	; 0x7de <itoa+0x3a>
 7b2:	4a 30       	cpi	r20, 0x0A	; 10
 7b4:	29 f4       	brne	.+10     	; 0x7c0 <itoa+0x1c>
 7b6:	97 fb       	bst	r25, 7
 7b8:	1e f4       	brtc	.+6      	; 0x7c0 <itoa+0x1c>
 7ba:	90 95       	com	r25
 7bc:	81 95       	neg	r24
 7be:	9f 4f       	sbci	r25, 0xFF	; 255
 7c0:	64 2f       	mov	r22, r20
 7c2:	77 27       	eor	r23, r23
 7c4:	0e 94 03 04 	call	0x806	; 0x806 <__udivmodhi4>
 7c8:	80 5d       	subi	r24, 0xD0	; 208
 7ca:	8a 33       	cpi	r24, 0x3A	; 58
 7cc:	0c f0       	brlt	.+2      	; 0x7d0 <itoa+0x2c>
 7ce:	89 5d       	subi	r24, 0xD9	; 217
 7d0:	81 93       	st	Z+, r24
 7d2:	cb 01       	movw	r24, r22
 7d4:	00 97       	sbiw	r24, 0x00	; 0
 7d6:	a1 f7       	brne	.-24     	; 0x7c0 <itoa+0x1c>
 7d8:	16 f4       	brtc	.+4      	; 0x7de <itoa+0x3a>
 7da:	5d e2       	ldi	r21, 0x2D	; 45
 7dc:	51 93       	st	Z+, r21
 7de:	10 82       	st	Z, r1
 7e0:	c9 01       	movw	r24, r18
 7e2:	0c 94 f3 03 	jmp	0x7e6	; 0x7e6 <strrev>

000007e6 <strrev>:
 7e6:	dc 01       	movw	r26, r24
 7e8:	fc 01       	movw	r30, r24
 7ea:	67 2f       	mov	r22, r23
 7ec:	71 91       	ld	r23, Z+
 7ee:	77 23       	and	r23, r23
 7f0:	e1 f7       	brne	.-8      	; 0x7ea <strrev+0x4>
 7f2:	32 97       	sbiw	r30, 0x02	; 2
 7f4:	04 c0       	rjmp	.+8      	; 0x7fe <strrev+0x18>
 7f6:	7c 91       	ld	r23, X
 7f8:	6d 93       	st	X+, r22
 7fa:	70 83       	st	Z, r23
 7fc:	62 91       	ld	r22, -Z
 7fe:	ae 17       	cp	r26, r30
 800:	bf 07       	cpc	r27, r31
 802:	c8 f3       	brcs	.-14     	; 0x7f6 <strrev+0x10>
 804:	08 95       	ret

00000806 <__udivmodhi4>:
 806:	aa 1b       	sub	r26, r26
 808:	bb 1b       	sub	r27, r27
 80a:	51 e1       	ldi	r21, 0x11	; 17
 80c:	07 c0       	rjmp	.+14     	; 0x81c <__udivmodhi4_ep>

0000080e <__udivmodhi4_loop>:
 80e:	aa 1f       	adc	r26, r26
 810:	bb 1f       	adc	r27, r27
 812:	a6 17       	cp	r26, r22
 814:	b7 07       	cpc	r27, r23
 816:	10 f0       	brcs	.+4      	; 0x81c <__udivmodhi4_ep>
 818:	a6 1b       	sub	r26, r22
 81a:	b7 0b       	sbc	r27, r23

0000081c <__udivmodhi4_ep>:
 81c:	88 1f       	adc	r24, r24
 81e:	99 1f       	adc	r25, r25
 820:	5a 95       	dec	r21
 822:	a9 f7       	brne	.-22     	; 0x80e <__udivmodhi4_loop>
 824:	80 95       	com	r24
 826:	90 95       	com	r25
 828:	bc 01       	movw	r22, r24
 82a:	cd 01       	movw	r24, r26
 82c:	08 95       	ret

0000082e <_exit>:
 82e:	f8 94       	cli

00000830 <__stop_program>:
 830:	ff cf       	rjmp	.-2      	; 0x830 <__stop_program>
