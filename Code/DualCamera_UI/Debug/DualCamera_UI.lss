
DualCamera_UI.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  0000036c  00000400  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000036c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000008  00800102  00800102  00000402  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00000404  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00000ad0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000a0  00000000  00000000  00000b58  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000659  00000000  00000000  00000bf8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000298  00000000  00000000  00001251  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000003fa  00000000  00000000  000014e9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000f8  00000000  00000000  000018e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000216  00000000  00000000  000019dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000232  00000000  00000000  00001bf2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 07 01 	jmp	0x20e	; 0x20e <__vector_24>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d4 e0       	ldi	r29, 0x04	; 4
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ec e6       	ldi	r30, 0x6C	; 108
  7c:	f3 e0       	ldi	r31, 0x03	; 3
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a2 30       	cpi	r26, 0x02	; 2
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	11 e0       	ldi	r17, 0x01	; 1
  8c:	a2 e0       	ldi	r26, 0x02	; 2
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	aa 30       	cpi	r26, 0x0A	; 10
  96:	b1 07       	cpc	r27, r17
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 53 00 	call	0xa6	; 0xa6 <main>
  9e:	0c 94 b4 01 	jmp	0x368	; 0x368 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <main>:

#define TWI_CMD_MASTER_WRITE 0x10
#define TWI_CMD_MASTER_READ  0x20

int main(void)
{
  a6:	cf 93       	push	r28
  a8:	df 93       	push	r29
  aa:	00 d0       	rcall	.+0      	; 0xac <main+0x6>
  ac:	00 d0       	rcall	.+0      	; 0xae <main+0x8>
  ae:	cd b7       	in	r28, 0x3d	; 61
  b0:	de b7       	in	r29, 0x3e	; 62
	
	char ButtonStatus = 0xFF;
	unsigned char TWI_slaveAddress;
	unsigned char messageBuff[TWI_BUFFER_SIZE];
	DDRD = 0xFF;// Port D is the LED output
  b2:	8f ef       	ldi	r24, 0xFF	; 255
  b4:	8a b9       	out	0x0a, r24	; 10
	DDRC = 0x00; //PortC is the switch input
  b6:	17 b8       	out	0x07, r1	; 7
	//PORTC = 0xFF;
	TWI_slaveAddress = 0x15;
	TWI_Slave_Initialise( (unsigned char)((TWI_slaveAddress<<TWI_ADR_BITS) | (TRUE<<TWI_GEN_BIT) )); 
  b8:	8b e2       	ldi	r24, 0x2B	; 43
  ba:	0e 94 93 00 	call	0x126	; 0x126 <TWI_Slave_Initialise>
	sei();
  be:	78 94       	sei
	TWI_Start_Transceiver();
  c0:	0e 94 cf 00 	call	0x19e	; 0x19e <TWI_Start_Transceiver>
#define TWI_CMD_MASTER_READ  0x20

int main(void)
{
	
	char ButtonStatus = 0xFF;
  c4:	1f ef       	ldi	r17, 0xFF	; 255
				        // TWI_CMD_MASTER_READ prepares the data from PINB in the transceiver buffer for the TWI master to fetch.
				        if (messageBuff[0] == TWI_CMD_MASTER_READ)
				        {	
					        messageBuff[0] = ButtonStatus;
					        TWI_Start_Transceiver_With_Data( messageBuff, 1 );
							ButtonStatus = ButtonMask; //clear all logged button presses
  c6:	0f e0       	ldi	r16, 0x0F	; 15
	sei();
	TWI_Start_Transceiver();
    while(1)
    {
		
		ButtonStatus = (ButtonStatus & PINC) & ButtonMask;
  c8:	86 b1       	in	r24, 0x06	; 6
  ca:	8f 70       	andi	r24, 0x0F	; 15
  cc:	18 23       	and	r17, r24
		//PORTD = ButtonStatus;
        // Check if the TWI Transceiver has completed an operation.
        if ( ! TWI_Transceiver_Busy() )
  ce:	0e 94 9b 00 	call	0x136	; 0x136 <TWI_Transceiver_Busy>
  d2:	88 23       	and	r24, r24
  d4:	c9 f7       	brne	.-14     	; 0xc8 <main+0x22>
        {
	        // Check if the last operation was successful
	        if ( TWI_statusReg.lastTransOK )
  d6:	80 91 02 01 	lds	r24, 0x0102
  da:	80 ff       	sbrs	r24, 0
  dc:	f5 cf       	rjmp	.-22     	; 0xc8 <main+0x22>
	        {
		        // Check if the last operation was a reception
		        if ( TWI_statusReg.RxDataInBuf )
  de:	81 ff       	sbrs	r24, 1
  e0:	1b c0       	rjmp	.+54     	; 0x118 <main+0x72>
		        {
			        TWI_Get_Data_From_Transceiver(messageBuff, 2);
  e2:	ce 01       	movw	r24, r28
  e4:	01 96       	adiw	r24, 0x01	; 1
  e6:	62 e0       	ldi	r22, 0x02	; 2
  e8:	0e 94 df 00 	call	0x1be	; 0x1be <TWI_Get_Data_From_Transceiver>
			        // Check if the last operation was a reception as General Call
			        if ( TWI_statusReg.genAddressCall )
  ec:	80 91 02 01 	lds	r24, 0x0102
  f0:	82 ff       	sbrs	r24, 2
  f2:	03 c0       	rjmp	.+6      	; 0xfa <main+0x54>
			        {
				        // Put data received out to PORTB as an example.
				        PORTB = messageBuff[0];
  f4:	89 81       	ldd	r24, Y+1	; 0x01
  f6:	85 b9       	out	0x05, r24	; 5
  f8:	0f c0       	rjmp	.+30     	; 0x118 <main+0x72>
			        else // Ends up here if the last operation was a reception as Slave Address Match
			        {
				        // Example of how to interpret a command and respond.
				        
				        // TWI_CMD_MASTER_WRITE stores the data to PORTB
				        if (messageBuff[0] == TWI_CMD_MASTER_WRITE)
  fa:	89 81       	ldd	r24, Y+1	; 0x01
  fc:	80 31       	cpi	r24, 0x10	; 16
  fe:	11 f4       	brne	.+4      	; 0x104 <main+0x5e>
				        {
					        PORTD = messageBuff[1];
 100:	8a 81       	ldd	r24, Y+2	; 0x02
 102:	8b b9       	out	0x0b, r24	; 11
				        }
				        // TWI_CMD_MASTER_READ prepares the data from PINB in the transceiver buffer for the TWI master to fetch.
				        if (messageBuff[0] == TWI_CMD_MASTER_READ)
 104:	89 81       	ldd	r24, Y+1	; 0x01
 106:	80 32       	cpi	r24, 0x20	; 32
 108:	39 f4       	brne	.+14     	; 0x118 <main+0x72>
				        {	
					        messageBuff[0] = ButtonStatus;
 10a:	19 83       	std	Y+1, r17	; 0x01
					        TWI_Start_Transceiver_With_Data( messageBuff, 1 );
 10c:	ce 01       	movw	r24, r28
 10e:	01 96       	adiw	r24, 0x01	; 1
 110:	61 e0       	ldi	r22, 0x01	; 1
 112:	0e 94 a6 00 	call	0x14c	; 0x14c <TWI_Start_Transceiver_With_Data>
							ButtonStatus = ButtonMask; //clear all logged button presses
 116:	10 2f       	mov	r17, r16
		        {
			        //__no_operation(); // Put own code here.
		        }
		        // Check if the TWI Transceiver has already been started.
		        // If not then restart it to prepare it for new receptions.
		        if ( ! TWI_Transceiver_Busy() )
 118:	0e 94 9b 00 	call	0x136	; 0x136 <TWI_Transceiver_Busy>
 11c:	88 23       	and	r24, r24
 11e:	a1 f6       	brne	.-88     	; 0xc8 <main+0x22>
		        {
			        TWI_Start_Transceiver();
 120:	0e 94 cf 00 	call	0x19e	; 0x19e <TWI_Start_Transceiver>
 124:	d1 cf       	rjmp	.-94     	; 0xc8 <main+0x22>

00000126 <TWI_Slave_Initialise>:
The TWI module is configured to NACK on any requests. Use a TWI_Start_Transceiver function to 
start the TWI.
****************************************************************************/
void TWI_Slave_Initialise( unsigned char TWI_ownAddress )
{
  TWAR = TWI_ownAddress;                            // Set own TWI slave address. Accept TWI General Calls.
 126:	80 93 ba 00 	sts	0x00BA, r24
  TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
 12a:	84 e0       	ldi	r24, 0x04	; 4
 12c:	80 93 bc 00 	sts	0x00BC, r24
         (0<<TWIE)|(0<<TWINT)|                      // Disable TWI Interupt.
         (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Do not ACK on any requests, yet.
         (0<<TWWC);                                 //
  TWI_busy = 0;
 130:	10 92 03 01 	sts	0x0103, r1
}    
 134:	08 95       	ret

00000136 <TWI_Transceiver_Busy>:
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return TWI_busy;
}
 136:	80 91 03 01 	lds	r24, 0x0103
 13a:	08 95       	ret

0000013c <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
  while ( TWI_Transceiver_Busy() ) {}             // Wait until TWI has completed the transmission.
 13c:	0e 94 9b 00 	call	0x136	; 0x136 <TWI_Transceiver_Busy>
 140:	88 23       	and	r24, r24
 142:	19 f4       	brne	.+6      	; 0x14a <TWI_Get_State_Info+0xe>
  return ( TWI_state );                         // Return error state. 
}
 144:	80 91 00 01 	lds	r24, 0x0100
 148:	08 95       	ret
 14a:	ff cf       	rjmp	.-2      	; 0x14a <TWI_Get_State_Info+0xe>

0000014c <TWI_Start_Transceiver_With_Data>:
Address byte is not included in the message buffers.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
 14c:	1f 93       	push	r17
 14e:	cf 93       	push	r28
 150:	df 93       	push	r29
 152:	d8 2f       	mov	r29, r24
 154:	19 2f       	mov	r17, r25
 156:	c6 2f       	mov	r28, r22
  unsigned char temp;

  while ( TWI_Transceiver_Busy() ) {}             // Wait until TWI is ready for next transmission.
 158:	0e 94 9b 00 	call	0x136	; 0x136 <TWI_Transceiver_Busy>
 15c:	88 23       	and	r24, r24
 15e:	f1 f4       	brne	.+60     	; 0x19c <TWI_Start_Transceiver_With_Data+0x50>

  TWI_msgSize = msgSize;                        // Number of data to transmit.
 160:	c0 93 04 01 	sts	0x0104, r28
  for ( temp = 0; temp < msgSize; temp++ )      // Copy data that may be transmitted if the TWI Master requests data.
 164:	cc 23       	and	r28, r28
 166:	59 f0       	breq	.+22     	; 0x17e <TWI_Start_Transceiver_With_Data+0x32>
 168:	9d 2f       	mov	r25, r29
 16a:	a5 e0       	ldi	r26, 0x05	; 5
 16c:	b1 e0       	ldi	r27, 0x01	; 1
 16e:	ed 2f       	mov	r30, r29
 170:	f1 2f       	mov	r31, r17
  {
    TWI_buf[ temp ] = msg[ temp ];
 172:	81 91       	ld	r24, Z+
 174:	8d 93       	st	X+, r24
  unsigned char temp;

  while ( TWI_Transceiver_Busy() ) {}             // Wait until TWI is ready for next transmission.

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  for ( temp = 0; temp < msgSize; temp++ )      // Copy data that may be transmitted if the TWI Master requests data.
 176:	8e 2f       	mov	r24, r30
 178:	89 1b       	sub	r24, r25
 17a:	8c 17       	cp	r24, r28
 17c:	d0 f3       	brcs	.-12     	; 0x172 <TWI_Start_Transceiver_With_Data+0x26>
  {
    TWI_buf[ temp ] = msg[ temp ];
  }
  TWI_statusReg.all = 0;      
 17e:	10 92 02 01 	sts	0x0102, r1
  TWI_state         = TWI_NO_STATE ;
 182:	88 ef       	ldi	r24, 0xF8	; 248
 184:	80 93 00 01 	sts	0x0100, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
 188:	85 ec       	ldi	r24, 0xC5	; 197
 18a:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|       // Prepare to ACK next time the Slave is addressed.
         (0<<TWWC);                             //
  TWI_busy = 1;
 18e:	81 e0       	ldi	r24, 0x01	; 1
 190:	80 93 03 01 	sts	0x0103, r24
}
 194:	df 91       	pop	r29
 196:	cf 91       	pop	r28
 198:	1f 91       	pop	r17
 19a:	08 95       	ret
 19c:	ff cf       	rjmp	.-2      	; 0x19c <TWI_Start_Transceiver_With_Data+0x50>

0000019e <TWI_Start_Transceiver>:
in the transceiver buffers. The function will hold execution (loop) until the TWI_ISR has completed with the 
previous operation, then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() ) {}             // Wait until TWI is ready for next transmission.
 19e:	0e 94 9b 00 	call	0x136	; 0x136 <TWI_Transceiver_Busy>
 1a2:	88 23       	and	r24, r24
 1a4:	59 f4       	brne	.+22     	; 0x1bc <TWI_Start_Transceiver+0x1e>
  TWI_statusReg.all = 0;      
 1a6:	10 92 02 01 	sts	0x0102, r1
  TWI_state         = TWI_NO_STATE ;
 1aa:	88 ef       	ldi	r24, 0xF8	; 248
 1ac:	80 93 00 01 	sts	0x0100, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
 1b0:	85 ec       	ldi	r24, 0xC5	; 197
 1b2:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|       // Prepare to ACK next time the Slave is addressed.
         (0<<TWWC);                             //
  TWI_busy = 0;
 1b6:	10 92 03 01 	sts	0x0103, r1
}
 1ba:	08 95       	ret
 1bc:	ff cf       	rjmp	.-2      	; 0x1bc <TWI_Start_Transceiver+0x1e>

000001be <TWI_Get_Data_From_Transceiver>:
to fetch in the function call. The function will hold execution (loop) until the TWI_ISR has completed 
with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI State code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
 1be:	1f 93       	push	r17
 1c0:	cf 93       	push	r28
 1c2:	df 93       	push	r29
 1c4:	d8 2f       	mov	r29, r24
 1c6:	19 2f       	mov	r17, r25
 1c8:	c6 2f       	mov	r28, r22
  unsigned char i;

  while ( TWI_Transceiver_Busy() ) {}             // Wait until TWI is ready for next transmission.
 1ca:	0e 94 9b 00 	call	0x136	; 0x136 <TWI_Transceiver_Busy>
 1ce:	88 23       	and	r24, r24
 1d0:	e9 f4       	brne	.+58     	; 0x20c <TWI_Get_Data_From_Transceiver+0x4e>

  if( TWI_statusReg.lastTransOK )               // Last transmission completed successfully.              
 1d2:	80 91 02 01 	lds	r24, 0x0102
 1d6:	80 ff       	sbrs	r24, 0
 1d8:	12 c0       	rjmp	.+36     	; 0x1fe <TWI_Get_Data_From_Transceiver+0x40>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
 1da:	cc 23       	and	r28, r28
 1dc:	59 f0       	breq	.+22     	; 0x1f4 <TWI_Get_Data_From_Transceiver+0x36>
 1de:	a5 e0       	ldi	r26, 0x05	; 5
 1e0:	b1 e0       	ldi	r27, 0x01	; 1
 1e2:	9d 2f       	mov	r25, r29
 1e4:	ed 2f       	mov	r30, r29
 1e6:	f1 2f       	mov	r31, r17
    {
      msg[ i ] = TWI_buf[ i ];
 1e8:	8d 91       	ld	r24, X+
 1ea:	81 93       	st	Z+, r24

  while ( TWI_Transceiver_Busy() ) {}             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission completed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
 1ec:	8e 2f       	mov	r24, r30
 1ee:	89 1b       	sub	r24, r25
 1f0:	8c 17       	cp	r24, r28
 1f2:	d0 f3       	brcs	.-12     	; 0x1e8 <TWI_Get_Data_From_Transceiver+0x2a>
    {
      msg[ i ] = TWI_buf[ i ];
    }
    TWI_statusReg.RxDataInBuf = FALSE;          // Slave Receive data has been read from buffer.
 1f4:	80 91 02 01 	lds	r24, 0x0102
 1f8:	8d 7f       	andi	r24, 0xFD	; 253
 1fa:	80 93 02 01 	sts	0x0102, r24
  }
  return( TWI_statusReg.lastTransOK );                                   
 1fe:	80 91 02 01 	lds	r24, 0x0102
}
 202:	81 70       	andi	r24, 0x01	; 1
 204:	df 91       	pop	r29
 206:	cf 91       	pop	r28
 208:	1f 91       	pop	r17
 20a:	08 95       	ret
 20c:	ff cf       	rjmp	.-2      	; 0x20c <TWI_Get_Data_From_Transceiver+0x4e>

0000020e <__vector_24>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect)
{
 20e:	1f 92       	push	r1
 210:	0f 92       	push	r0
 212:	0f b6       	in	r0, 0x3f	; 63
 214:	0f 92       	push	r0
 216:	11 24       	eor	r1, r1
 218:	8f 93       	push	r24
 21a:	9f 93       	push	r25
 21c:	ef 93       	push	r30
 21e:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
 220:	80 91 b9 00 	lds	r24, 0x00B9
 224:	80 39       	cpi	r24, 0x90	; 144
 226:	09 f4       	brne	.+2      	; 0x22a <__vector_24+0x1c>
 228:	67 c0       	rjmp	.+206    	; 0x2f8 <__vector_24+0xea>
 22a:	81 39       	cpi	r24, 0x91	; 145
 22c:	98 f4       	brcc	.+38     	; 0x254 <__vector_24+0x46>
 22e:	80 37       	cpi	r24, 0x70	; 112
 230:	09 f4       	brne	.+2      	; 0x234 <__vector_24+0x26>
 232:	4f c0       	rjmp	.+158    	; 0x2d2 <__vector_24+0xc4>
 234:	81 37       	cpi	r24, 0x71	; 113
 236:	38 f4       	brcc	.+14     	; 0x246 <__vector_24+0x38>
 238:	88 23       	and	r24, r24
 23a:	09 f4       	brne	.+2      	; 0x23e <__vector_24+0x30>
 23c:	7b c0       	rjmp	.+246    	; 0x334 <__vector_24+0x126>
 23e:	80 36       	cpi	r24, 0x60	; 96
 240:	09 f0       	breq	.+2      	; 0x244 <__vector_24+0x36>
 242:	80 c0       	rjmp	.+256    	; 0x344 <__vector_24+0x136>
 244:	4b c0       	rjmp	.+150    	; 0x2dc <__vector_24+0xce>
 246:	80 38       	cpi	r24, 0x80	; 128
 248:	09 f4       	brne	.+2      	; 0x24c <__vector_24+0x3e>
 24a:	56 c0       	rjmp	.+172    	; 0x2f8 <__vector_24+0xea>
 24c:	88 38       	cpi	r24, 0x88	; 136
 24e:	09 f0       	breq	.+2      	; 0x252 <__vector_24+0x44>
 250:	79 c0       	rjmp	.+242    	; 0x344 <__vector_24+0x136>
 252:	70 c0       	rjmp	.+224    	; 0x334 <__vector_24+0x126>
 254:	88 3a       	cpi	r24, 0xA8	; 168
 256:	91 f0       	breq	.+36     	; 0x27c <__vector_24+0x6e>
 258:	89 3a       	cpi	r24, 0xA9	; 169
 25a:	38 f4       	brcc	.+14     	; 0x26a <__vector_24+0x5c>
 25c:	88 39       	cpi	r24, 0x98	; 152
 25e:	09 f4       	brne	.+2      	; 0x262 <__vector_24+0x54>
 260:	69 c0       	rjmp	.+210    	; 0x334 <__vector_24+0x126>
 262:	80 3a       	cpi	r24, 0xA0	; 160
 264:	09 f0       	breq	.+2      	; 0x268 <__vector_24+0x5a>
 266:	6e c0       	rjmp	.+220    	; 0x344 <__vector_24+0x136>
 268:	5f c0       	rjmp	.+190    	; 0x328 <__vector_24+0x11a>
 26a:	80 3c       	cpi	r24, 0xC0	; 192
 26c:	e1 f0       	breq	.+56     	; 0x2a6 <__vector_24+0x98>
 26e:	88 3c       	cpi	r24, 0xC8	; 200
 270:	09 f4       	brne	.+2      	; 0x274 <__vector_24+0x66>
 272:	60 c0       	rjmp	.+192    	; 0x334 <__vector_24+0x126>
 274:	88 3b       	cpi	r24, 0xB8	; 184
 276:	09 f0       	breq	.+2      	; 0x27a <__vector_24+0x6c>
 278:	65 c0       	rjmp	.+202    	; 0x344 <__vector_24+0x136>
 27a:	02 c0       	rjmp	.+4      	; 0x280 <__vector_24+0x72>
  {
    case TWI_STX_ADR_ACK:            // Own SLA+R has been received; ACK has been returned
//    case TWI_STX_ADR_ACK_M_ARB_LOST: // Arbitration lost in SLA+R/W as Master; own SLA+R has been received; ACK has been returned
      TWI_bufPtr   = 0;                                 // Set buffer pointer to first data location
 27c:	10 92 09 01 	sts	0x0109, r1
    case TWI_STX_DATA_ACK:           // Data byte in TWDR has been transmitted; ACK has been received
      TWDR = TWI_buf[TWI_bufPtr++];
 280:	80 91 09 01 	lds	r24, 0x0109
 284:	e8 2f       	mov	r30, r24
 286:	f0 e0       	ldi	r31, 0x00	; 0
 288:	eb 5f       	subi	r30, 0xFB	; 251
 28a:	fe 4f       	sbci	r31, 0xFE	; 254
 28c:	90 81       	ld	r25, Z
 28e:	90 93 bb 00 	sts	0x00BB, r25
 292:	8f 5f       	subi	r24, 0xFF	; 255
 294:	80 93 09 01 	sts	0x0109, r24
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 298:	85 ec       	ldi	r24, 0xC5	; 197
 29a:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
             (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // 
             (0<<TWWC);                                 //
      TWI_busy = 1;
 29e:	81 e0       	ldi	r24, 0x01	; 1
 2a0:	80 93 03 01 	sts	0x0103, r24
      break;
 2a4:	58 c0       	rjmp	.+176    	; 0x356 <__vector_24+0x148>
    case TWI_STX_DATA_NACK:          // Data byte in TWDR has been transmitted; NACK has been received. 
                                     // I.e. this could be the end of the transmission.
      if (TWI_bufPtr == TWI_msgSize) // Have we transceived all expected data?
 2a6:	90 91 09 01 	lds	r25, 0x0109
 2aa:	80 91 04 01 	lds	r24, 0x0104
 2ae:	98 17       	cp	r25, r24
 2b0:	31 f4       	brne	.+12     	; 0x2be <__vector_24+0xb0>
      {
        TWI_statusReg.lastTransOK = TRUE;               // Set status bits to completed successfully. 
 2b2:	80 91 02 01 	lds	r24, 0x0102
 2b6:	81 60       	ori	r24, 0x01	; 1
 2b8:	80 93 02 01 	sts	0x0102, r24
 2bc:	04 c0       	rjmp	.+8      	; 0x2c6 <__vector_24+0xb8>
      } 
      else                          // Master has sent a NACK before all data where sent.
      {
        TWI_state = TWSR;                               // Store TWI State as errormessage.      
 2be:	80 91 b9 00 	lds	r24, 0x00B9
 2c2:	80 93 00 01 	sts	0x0100, r24
      }        
                                                        
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
 2c6:	85 ec       	ldi	r24, 0xC5	; 197
 2c8:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Keep interrupt enabled and clear the flag
             (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Answer on next address match
             (0<<TWWC);                                 //
      
      TWI_busy = 0;   // Transmit is finished, we are not busy anymore
 2cc:	10 92 03 01 	sts	0x0103, r1
      break;     
 2d0:	42 c0       	rjmp	.+132    	; 0x356 <__vector_24+0x148>
    case TWI_SRX_GEN_ACK:            // General call address has been received; ACK has been returned
//    case TWI_SRX_GEN_ACK_M_ARB_LOST: // Arbitration lost in SLA+R/W as Master; General call address has been received; ACK has been returned
      TWI_statusReg.genAddressCall = TRUE;
 2d2:	80 91 02 01 	lds	r24, 0x0102
 2d6:	84 60       	ori	r24, 0x04	; 4
 2d8:	80 93 02 01 	sts	0x0102, r24
    case TWI_SRX_ADR_ACK:            // Own SLA+W has been received ACK has been returned
//    case TWI_SRX_ADR_ACK_M_ARB_LOST: // Arbitration lost in SLA+R/W as Master; own SLA+W has been received; ACK has been returned    
                                                        // Dont need to clear TWI_S_statusRegister.generalAddressCall due to that it is the default state.
      TWI_statusReg.RxDataInBuf = TRUE;      
 2dc:	80 91 02 01 	lds	r24, 0x0102
 2e0:	82 60       	ori	r24, 0x02	; 2
 2e2:	80 93 02 01 	sts	0x0102, r24
      TWI_bufPtr   = 0;                                 // Set buffer pointer to first data location
 2e6:	10 92 09 01 	sts	0x0109, r1
      
                                                        // Reset the TWI Interupt to wait for a new event.
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 2ea:	85 ec       	ldi	r24, 0xC5	; 197
 2ec:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
             (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Expect ACK on this transmission
             (0<<TWWC);  
      TWI_busy = 1;
 2f0:	81 e0       	ldi	r24, 0x01	; 1
 2f2:	80 93 03 01 	sts	0x0103, r24
      
      break;
 2f6:	2f c0       	rjmp	.+94     	; 0x356 <__vector_24+0x148>
    case TWI_SRX_ADR_DATA_ACK:       // Previously addressed with own SLA+W; data has been received; ACK has been returned
    case TWI_SRX_GEN_DATA_ACK:       // Previously addressed with general call; data has been received; ACK has been returned
      TWI_buf[TWI_bufPtr++]     = TWDR;
 2f8:	80 91 09 01 	lds	r24, 0x0109
 2fc:	90 91 bb 00 	lds	r25, 0x00BB
 300:	e8 2f       	mov	r30, r24
 302:	f0 e0       	ldi	r31, 0x00	; 0
 304:	eb 5f       	subi	r30, 0xFB	; 251
 306:	fe 4f       	sbci	r31, 0xFE	; 254
 308:	90 83       	st	Z, r25
 30a:	8f 5f       	subi	r24, 0xFF	; 255
 30c:	80 93 09 01 	sts	0x0109, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set flag transmission successfull.       
 310:	80 91 02 01 	lds	r24, 0x0102
 314:	81 60       	ori	r24, 0x01	; 1
 316:	80 93 02 01 	sts	0x0102, r24
                                                        // Reset the TWI Interupt to wait for a new event.
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 31a:	85 ec       	ldi	r24, 0xC5	; 197
 31c:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
             (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after next reception
             (0<<TWWC);                                 // 
      TWI_busy = 1;
 320:	81 e0       	ldi	r24, 0x01	; 1
 322:	80 93 03 01 	sts	0x0103, r24
      break;
 326:	17 c0       	rjmp	.+46     	; 0x356 <__vector_24+0x148>
    case TWI_SRX_STOP_RESTART:       // A STOP condition or repeated START condition has been received while still addressed as Slave    
                                                        // Enter not addressed mode and listen to address match
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
 328:	85 ec       	ldi	r24, 0xC5	; 197
 32a:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable interrupt and clear the flag
             (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Wait for new address match
             (0<<TWWC);                                 //
      
      TWI_busy = 0;  // We are waiting for a new address match, so we are not busy
 32e:	10 92 03 01 	sts	0x0103, r1
      
      break;           
 332:	11 c0       	rjmp	.+34     	; 0x356 <__vector_24+0x148>
    case TWI_SRX_ADR_DATA_NACK:      // Previously addressed with own SLA+W; data has been received; NOT ACK has been returned
    case TWI_SRX_GEN_DATA_NACK:      // Previously addressed with general call; data has been received; NOT ACK has been returned
    case TWI_STX_DATA_ACK_LAST_BYTE: // Last data byte in TWDR has been transmitted (TWEA = “0”); ACK has been received
//    case TWI_NO_STATE              // No relevant state information available; TWINT = “0”
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
      TWI_state = TWSR;                 //Store TWI State as errormessage, operation also clears noErrors bit
 334:	80 91 b9 00 	lds	r24, 0x00B9
 338:	80 93 00 01 	sts	0x0100, r24
      TWCR =   (1<<TWSTO)|(1<<TWINT);   //Recover from TWI_BUS_ERROR, this will release the SDA and SCL pins thus enabling other devices to use the bus
 33c:	80 e9       	ldi	r24, 0x90	; 144
 33e:	80 93 bc 00 	sts	0x00BC, r24
      break;
 342:	09 c0       	rjmp	.+18     	; 0x356 <__vector_24+0x148>
    default:     
      TWI_state = TWSR;                                 // Store TWI State as errormessage, operation also clears the Success bit.      
 344:	80 91 b9 00 	lds	r24, 0x00B9
 348:	80 93 00 01 	sts	0x0100, r24
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
 34c:	85 ec       	ldi	r24, 0xC5	; 197
 34e:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Keep interrupt enabled and clear the flag
             (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Acknowledge on any new requests.
             (0<<TWWC);                                 //
      
      TWI_busy = 0; // Unknown status, so we wait for a new address match that might be something we can handle
 352:	10 92 03 01 	sts	0x0103, r1
  }
}
 356:	ff 91       	pop	r31
 358:	ef 91       	pop	r30
 35a:	9f 91       	pop	r25
 35c:	8f 91       	pop	r24
 35e:	0f 90       	pop	r0
 360:	0f be       	out	0x3f, r0	; 63
 362:	0f 90       	pop	r0
 364:	1f 90       	pop	r1
 366:	18 95       	reti

00000368 <_exit>:
 368:	f8 94       	cli

0000036a <__stop_program>:
 36a:	ff cf       	rjmp	.-2      	; 0x36a <__stop_program>
